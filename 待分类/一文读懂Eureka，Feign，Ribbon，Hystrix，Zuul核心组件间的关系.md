[TOC]

## **Spring Cloud的主要组件**

Spring Cloud是目前微服务架构领域的翘楚，无数的书籍博客都在讲解这个技术，实际上，Spring Cloud是一个全家桶式的技术栈，包含了很多组件。本文先从其最核心的几个组件入手，来剖析一下其底层的工作原理。也就是Eureka、Ribbon、Feign、Hystrix、Zuul这几个组件。

## **业务场景介绍**

先来给大家说一个业务场景，假设咱们现在开发一个电商网站，要实现支付订单的功能，流程如下：

- 创建一个订单，如果用户立刻支付了这个订单，我们需要将订单状态更新为“已支付”
- 扣减相应的商品库存
- 通知仓储中心，进行发货
- 给用户的这次购物增加相应的积分

针对上述流程，我们需要有订单服务、库存服务、仓储服务、积分服务。整个流程的大体思路如下：

用户针对一个订单完成支付之后，就会去找订单服务，更新订单状态
订单服务调用库存服务，完成相应功能
订单服务调用仓储服务，完成相应功能
订单服务调用积分服务，完成相应功能

至此，整个支付订单的业务流程结束
下图这张图，清晰表明了各服务间的调用过程：

![img](https://pic2.zhimg.com/80/v2-40604bf030586fd3c292f12e94ec2df9_1440w.webp)



## **Spring Cloud组件之间如何运作**

Eureka组件
咱们来考虑第一个问题：订单服务想要调用库存服务、仓储服务，或者是积分服务，怎么调用？

- 订单服务压根儿就不知道人家库存服务在哪台机器上啊！他就算想要发起一个请求，都不知道发送给谁，有心无力！
- 这时候，就轮到Spring Cloud Eureka出场了。Eureka是微服务架构中的注册中心，专门负责服务的注册与发现。

通过这个图来了解Eureka是如何工作的

![img](https://pic2.zhimg.com/80/v2-85966d4760f955a244779593b01aa4dd_1440w.webp)


如上图所示，库存服务、仓储服务、积分服务中都有一个Eureka Client组件，这个组件专门负责将这个服务的信息注册到Eureka Server中。说白了，就是告诉Eureka Server，自己在哪台机器上，监听着哪个端口。而Eureka Server是一个注册中心，里面有一个注册表，保存了各服务所在的机器和端口号。

订单服务里也有一个Eureka Client组件，这个Eureka Client组件会找Eureka Server问一下：库存服务在哪台机器啊？监听着哪个端口啊？仓储服务呢？积分服务呢？然后就可以把这些相关信息从Eureka Server的注册表中拉取到自己本地缓存起来。

这时如果订单服务想要调用库存服务，不就可以找自己本地的Eureka Client问一下库存服务在哪台机器？监听哪个端口吗？收到响应后，紧接着就可以发送一个请求过去，调用库存服务扣减库存的那个接口！同理，如果订单服务要调用仓储服务、积分服务，也是如法炮制。

Feign组件
现在订单服务确实知道库存服务、积分服务、仓库服务在哪里了，同时也监听着哪些端口号了，但是新问题又来了

- 订单服务要自己写一大堆代码，跟其他服务建立网络连接，然后构造一个复杂的请求，接着发送请求过去，最后对返回的响应结果再写一大堆代码来处理吗？
- 别急，Feign早已为我们提供好了优雅的解决方案

![img](https://pic1.zhimg.com/80/v2-5b633296fb2dfe4f533af728038ff174_1440w.webp)


没有底层的建立连接、构造请求、解析响应的代码，直接就是用注解定义一个 FeignClient接口，然后调用那个接口就可以了。人家Feign Client会在底层根据你的注解，跟你指定的服务建立连接、构造请求、发起靕求、获取响应、解析响应，等等。这一系列脏活累活，人家Feign全给你干了。

Feign实现原理解析

- 首先，如果你对某个接口定义了@FeignClient注解，Feign就会针对这个接口创建一个动态代理
- 接着你要调用哪个接口，本质就是会调用 Feign创建的动态代理，这是核心中的核心
- Feign的动态代理会根据你在接口上的@RequestMapping等注解，来动态构造出你要请求的服务的地址
- 最后针对这个地址，发起请求、解析响应

![img](https://pic3.zhimg.com/80/v2-f5a32e037352868aeb31897e66ffcc02_1440w.webp)



Ribbon组件
说完了Feign，还没完。现在新的问题又来了，如果人家库存服务部署在了3台机器上，如下所示：

- 192.168.170:9090
- 192.168.171:9090
- 192.168.172:9090

这下糟糕了，人家Feign怎么知道该请求哪台机器呢？

Ribbon就派上用场了。Ribbon就是专门解决这个问题的。它的作用是负载均衡，会帮你在每次请求时选择一台机器，均匀的把请求分发到各个机器上。

Ribbon的负载均衡默认使用的最经典的Round Robin轮询算法。这是啥？简单来说，就是如果订单服务对库存服务发起10次请求，那就先让你请求第1台机器、然后是第2台机器、第3台机器、第4台机器、第5台机器，接着再来—个循环，第1台机器、第2台机器。。。以此类推。

Hystrix组件
当然这些服务正常的情况下，系统是没有问题的，但是谁也不能保证做的系统就一点问题也没有，所以万一要是哪台机器的服务挂了，怎么办，服务与服务之间都是紧密联系的，会不会产生连锁反应，导致整个系统崩掉。

![img](https://pic3.zhimg.com/80/v2-cb216af34b0766f56dd7e74bc8546a22_1440w.webp)


如上图，这么多服务互相调用，要是不做任何保护的话，某一个服务挂了，就会引起连锁反应，导致别的服务也挂。比如积分服务挂了，会导致订单服务的线程全部卡在请求积分服务这里，没有一个线程可以工作，瞬间导致订单服务也挂了，别人请求订单服务全部会卡住，无法响应。

但是我们思考一下，就算积分服务挂了，订单服务也可以不用挂啊！为什么？

- 我们结合业务来看：支付订单的时候，只要把库存扣减了，然后通知仓库发货就OK了
- 如果积分服务挂了，大不了等他恢复之后，慢慢人肉手工恢复数据！为啥一定要因为一个积分服务挂了，就直接导致订单服务也挂了呢？不可以接受！
- Hystrix闪亮登场了。Hystrix是隔离、熔断以及降级的一个框架。啥意思呢？说白了，Hystrix会搞很多个小小的线程池，比如订单服务请求库存服务是一个线程池，请求仓储服务是一个线程池，请求积分服务是一个线程池。每个线程池里的线程就仅仅用于请求那个服务。

现在有了Hystrix组件，再次发生积分服务挂了，会怎样？

- 订单服务调用库存服务、仓储服务的这两个线程池都是正常工作的，所以这两个服务不会受到任何影响。
- 订单服务调用积分服务，如果积分服务挂了，那么这时系统会直接返回一个固定的字符串或者图片等等，不至于造成卡顿现象，影响客户体验。

Zuul组件

业务场景：假设你后台部署了几百个服务，现在有个前端兄弟，人家请求是直接从浏览器那儿发过来的。人家要请求一下库存服务，你难道还让人家记着这服务的名字叫做inventory-service？部署在5台机器上？就算人家肯记住这一个，你后台可有几百个服务的名称和地址呢？难不成人家请求一个，就得记住一个？

解决办法：Zuul组件，一种微服务网关组件，负责网络路由的，类似于路由器的功能。所以一般微服务架构中都必然会设计一个网关在里面，像android、ios、pc前端、微信小程序、H5等等，不用去关心后端有几百个服务，就知道有一个网关，所有请求都往网关走，网关会根据请求中的一些特征，将请求转发给后端的各个服务。

## **总结**

最后再来总结一下，上述Spring Cloud核心组件，在微服务架构中，分别扮演的角色：

- Eureka：各个服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉取注册表，从而知道其他服务在哪里
- Ribbon：服务间发起请求的时候，基于Ribbon做负载均衡，从一个服务的多台机器中选择一台
- Feign：基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求
- Hystrix：发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题
- Zuul：如果前端、移动端要调用后端系统，统一从Zuul网关进入，由Zuul网关转发请求给对应的服务

![img](https://pic1.zhimg.com/80/v2-77f2a6969a2e130d74797917e375b544_1440w.webp)

## **文章转载**

**[https://www.jianshu.com/p/31dfb5951](https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/31dfb595170c)**





- https://zhuanlan.zhihu.com/p/164977456
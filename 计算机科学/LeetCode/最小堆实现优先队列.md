[TOC]

## 最小堆

堆排序的原理就是，通过维护一个最小堆来进行排序（和没说一样。

最小堆在数据结构上是个完全二叉树，即除了叶子结点靠右的部分可能缺失以外，其他的地方都是满的。最小堆在结构上的特点是，所有的父结点都比子结点要小。这个特点天然的用于获取第Top-K小的数或者排序。例如找第三小的数，就是从最小堆里面取的第三个数。

最小堆有两个重要的操作，这两个操作都是为了维护最小堆，即在某些结点不满足最小堆属性的时候将堆调节到符合最小堆的状态。

**SiftDown：向下调整**

即若某个结点仅符合该结点上面所有父节点是合理的，而该结点的子结点可能不合理，那么我们要将这个结点和下面的结点做调整，以保证其顺序。做法就是每次比较该结点与子结点的顺序是否一致，若不一致则继续调整，递归到满足条件。（这个地方实现的时候有点意思，因为要把本结点与所有子结点中最小的那个放到最上面的来，所以要把三个结点全部对比一次，另外要注意某些结点可能是没有右子结点的）

**SiftUp：向上调整**

即若某个结点仅符合该结点下面所有子节点是合理的，而该结点的父结点可能不合理，那么我们要将这个结点和下面的结点做调整，以保证其顺序。做法就是每次比较该结点与父结点的顺序是否一致，若不一致则继续调整，递归到满足条件。

对于如何初始堆的操作，我们只需要认为堆里所有的结点都不符合顺序，然后依次对每一个从进行SiftUp就可以（为什么不是SiftDown？类似递归的思想，在排序大的树时只要保证其子树都是最小堆，这样就可以保证该结点下面的所有子结点是合理的，而反过来无法保证）

对于POP，即从堆的顶端取一个元素的操作，我们需要将尾部结点放到顶端，然后将顶端结点SiftDown一次。（为什么取得是尾部结点？因为要满足完全二叉树的性质，取别的就不完全了）对于PUSH，即添加一个元素的操作，我们需要将添加的结点放到尾部，然后SiftUp一次。（为什么放到尾部？同样的道理，保持完全二叉树的性质）

代码如下：

```python3
class prior_queue:
    def __init__(self, values):
        self._tree = [0] + list(values)
        self._size = len(self._tree) - 1
    
    def sift_down(self,i):
        while(i * 2 <= self._size):
            t = i
            if self._tree[i * 2]  < self._tree[t]:
                t = i * 2
            if i * 2 + 1 <= self._size:
                if self._tree[i * 2 + 1] < self._tree[t]:
                    t = i * 2 + 1
            if t == i:
                break
            else:
                self._tree[t], self._tree[i] = self._tree[i], self._tree[t]
                i = t
                
    def sift_up(self,i):
        while(i > 1):
            if self._tree[i // 2] > self._tree[i]:
                self._tree[i // 2], self._tree[i] = self._tree[i], self._tree[i // 2]
                i = i // 2
            else:
                break
        
    def build(self):
        i = self._size // 2
        while(i >= 1):
            self.sift_down(i)
            i = i - 1
            
    def pop(self):
        temp = self._tree[1]
        self._tree[1] = self._tree[self._size]
        self._size = self._size - 1
        self.sift_down(1)
        return temp
    
    def push(self,value):
        _tree.append(value)
        self._size = self._size + 1
        self.sift_up(self._size)
        
    def size(self):
        return self._size
    
    def print(self):
        print(self._tree)
    
    _tree = []
    _size = int(0)
```
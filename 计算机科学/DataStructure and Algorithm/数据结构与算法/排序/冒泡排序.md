[TOC]

## 一、原理

比较两个相邻的元素，将值大的元素交换至右端。 就像冒泡一样，一个泡从水底逐渐冒上来。

1、从列表的第一个数字到倒数第二个数字，逐个检查：若某一位上的数字大于他的下一位，则将它与它的下一位交换。

2、重复1号步骤，直至再也不能交换。

冒泡排序的平均时间复杂度与插入排序相同，也是平方级的，但冒泡排序是原地排序的，也就是说它不需要额外的存储空间



## 二、举例

```java
举例说明：要排序数组：int[] arr={6,3,8,2,9,1};   

第一趟排序：

　　　　第一次排序：6和3比较，6大于3，交换位置：  3  6  8  2  9  1

　　　　第二次排序：6和8比较，6小于8，不交换位置：3  6  8  2  9  1

　　　　第三次排序：8和2比较，8大于2，交换位置：  3  6  2  8  9  1

　　　　第四次排序：8和9比较，8小于9，不交换位置：3  6  2  8  9  1

　　　　第五次排序：9和1比较：9大于1，交换位置：  3  6  2  8  1  9

　　　　第一趟总共进行了5次比较， 排序结果：      3  6  2  8  1  9

---------------------------------------------------------------------

第二趟排序：

　　　　第一次排序：3和6比较，3小于6，不交换位置：3  6  2  8  1  9

　　　　第二次排序：6和2比较，6大于2，交换位置：  3  2  6  8  1  9

　　　　第三次排序：6和8比较，6大于8，不交换位置：3  2  6  8  1  9

　　　　第四次排序：8和1比较，8大于1，交换位置：  3  2  6  1  8  9

　　　　第二趟总共进行了4次比较， 排序结果：      3  2  6  1  8  9

---------------------------------------------------------------------

第三趟排序：

　　　　第一次排序：3和2比较，3大于2，交换位置：  2  3  6  1  8  9

　　　　第二次排序：3和6比较，3小于6，不交换位置：2  3  6  1  8  9

　　　　第三次排序：6和1比较，6大于1，交换位置：  2  3  1  6  8  9

　　　　第二趟总共进行了3次比较， 排序结果：         2  3  1  6  8  9

---------------------------------------------------------------------

第四趟排序：

　　　　第一次排序：2和3比较，2小于3，不交换位置：2  3  1  6  8  9

　　　　第二次排序：3和1比较，3大于1，交换位置：  2  1  3  6  8  9

　　　　第二趟总共进行了2次比较， 排序结果：        2  1  3  6  8  9

---------------------------------------------------------------------

第五趟排序：

　　　　第一次排序：2和1比较，2大于1，交换位置：  1  2  3  6  8  9

　　　　第二趟总共进行了1次比较， 排序结果：  1  2  3  6  8  9

---------------------------------------------------------------------

最终结果：1  2  3  6  8  9

---------------------------------------------------------------------

由此可见：N个数字要排序完成，总共进行N-1趟排序，每i趟的排序次数为(N-i)次，所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数

```



## 三、代码实现

```java
 public static void main(String[] args) {
        int bubblesort[]= new int[]{12, 33, 5, 8, 67};
        for(int i=0;i<bubblesort.length-1;i++){//外层循环控制循环趟数
            for (int j=0;j<bubblesort.length-1-i;j++){//内层循环控制每个泡冒到顶上比较的次数
                if(bubblesort[j]>bubblesort[j+1]){
                    int temp=bubblesort[j+1];
                    bubblesort[j+1]=bubblesort[j];
                    bubblesort[j]=temp;
                }
            }
        }
       System.out.println(Arrays.toString(bubblesort));
    }

//输出：
[5, 8, 12, 33, 67]
```



## 四、算法复杂度 O($n^2$)

冒泡排序的优点：**每进行一趟排序，就会少比较一次**，因为每进行一趟排序都会找出一个较大值。如上例：第一趟比较之后，排在最后的一个数一定是最大的一个数，第二趟排序的时候，只需要比较除了最后一个数以外的其他的数，同样也能找出一个最大的数排在参与第二趟比较的数后面，第三趟比较的时候，只需要比较除了最后两个数以外的其他的数，以此类推……也就是说，没进行一趟比较，每一趟少比较一次，一定程度上减少了算法的量。

用时间复杂度来说：

　　1.如果我们的数据正序，只需要走一趟即可完成排序。所需的比较次数C和记录移动次数M均达到最小值，即：Cmin=n-1;Mmin=0;所以，冒泡排序最好的时间复杂度为O(n)。

　　2.如果很不幸我们的数据是反序的，则需要进行n-1趟排序。每趟排序要进行n-i次比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：冒泡排序的最坏时间复杂度为：O($n^2$) 。

综上所述：冒泡排序总的平均时间复杂度为：O($n^2$) 。



## 五、优化一(连片有序整体无序)

假设我们现在排序ar[]={1,2,3,4,5,6,7,8,**10,9**}这组数据，按照上面的排序方式，第一趟排序后将10和9交换已经有序，接下来的8趟排序就是多余的，什么也没做。所以我们可以在交换的地方加一个标记，如果那一趟排序没有交换元素，说明这组数据已经有序，不用再继续下去。

```java
void BubbleSort(int arr[], int len)
{
    int i = 0;
    int tmp = 0;
    int flag = 0;
    for (i = 0; i < len - 1; i++)//确定排序趟数
    {
        flag=0; //置为0*********************************
        for (int j = 0; j < len - 1 - i; j++)//确定比较次数
        {
                if (arr[j]>arr[j + 1])
            {
                //交换
                tmp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = tmp;
                flag = 1;//加入标记*********************************
            }
        }
        if (flag == 0)//如果没有交换过元素，则已经有序*****************************
        {
            break;
        }
    }
}
```



## 六、优化二(前大半部分无序，后小半部分有序)

优化一仅仅适用于**连片有序而整体无序**的数据(例如：1， 2，3 ，4 ，7，6，5)。但是对于**前面大部分是无序而后边小半部分有序**的数据(1，2，5，7，4，3，6，8，9，10)排序效率也不可观，对于种类型数据，我们可以继续优化。既我们可以记下最后一次交换的位置，后边没有交换，必然是有序的，然后下一次排序从第一个比较到上次记录的位置结束即可。

![](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/q*St3MBqYN*L71igVRyAOCuKCBMeKymFYaT9vD6HPf0!/r/dDABAAAAAAAA)

```java
void BubbleSort(int arr[], int len)
{
    int i = 0;
    int tmp = 0;
    int flag = 0;
    int pos = 0;//用来记录最后一次交换的位置*******************************
    int k = len - 1;
    for (i = 0; i < len - 1; i++)//确定排序趟数
    {
        flag = 0;
        pos = 0;	//+++++++++++++++++++++++++++++++++
        for (int j = 0; j < k; j++)//确定比较次数+++++++++++++++++++++++++++
        {
            if (arr[j]>arr[j + 1])
            {
                //交换
                tmp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = tmp;
                flag = 1;//加入标记
                pos = j;//交换元素，记录最后一次交换的位置****************************
            }
        }
        if (flag == 0)//如果没有交换过元素，则已经有序
        {
            break;
        }
        k = pos;//下一次比较到记录位置即可 +++++++++++++++++++++++++++++++++
    }
}
```



## 七、优化三(一次排序确定两个值)

优化二的效率有很大的提升，还有一种优化方法可以继续提高效率。大致思想就是一次排序可以确定两个值，正向扫描找到最大值交换到最后，反向扫描找到最小值交换到最前面。例如：排序数据1，2，3，4，5，6，0

![](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/a4xltYm.RGdQWk8IzmP2QcB8tXjxt8LoqeMeNDjkQTs!/r/dFQBAAAAAAAA)

```java
void BubbleSort(int arr[], int len)
{
    int i = 0;
    int j = 0;
    int n = 0;//同时找最大值的最小需要两个下标遍历
    int flag = 0;
    int pos = 0;//用来记录最后一次交换的位置
    int k = len - 1;
    for (i = 0; i < len - 1; i++)//确定排序趟数
    {
        pos = 0;
        flag = 0;
        //正向寻找最大值
        for (j = n; j < k; j++)//确定比较次数
        {
            if (arr[j]>arr[j + 1])
            {
                //交换
                int tmp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = tmp;
                flag = 1;//加入标记
                pos = j;//交换元素，记录最后一次交换的位置
            }
        }
        if (flag == 0)//如果没有交换过元素，则已经有序,直接结束
        {
            break;
        }
        k = pos;//下一次比较到记录位置即可
        //反向寻找最小值
        for (j = k; j > n; j--)
        {
            int tmp = arr[j];
            arr[j] = arr[j - 1];
            arr[j - 1] = tmp;
            flag = 1;
        }
        n++;
        if (flag == 0)//如果没有交换过元素，则已经有序,直接结束
        {
            return;
        }
    }
}
```


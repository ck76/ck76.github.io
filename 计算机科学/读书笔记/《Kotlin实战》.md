[TOC]

# 《Kotlin实战》

## 第一部分：简介

### 一、Kotlin：定义和目的

- ​                                                                         

---



### 二、Kotlin基础



---



### 三、函数的定义与调用



---



### 四、类、对象和接口



---



### 五、Lambda编程

- **Lambda 表达式和成员引用** 

  - **简介：**
  
    - Lambda 表达式，或简称 lambda，本质上就是可以传递给其他函数的 一 小段代码 。 有了 lambda，可以轻松地把通用的代码结构抽取成库函数， Kotlin标准库就大量地 使用了它们。最常见的-种 lambda用途就是和集合一起工作
    - 一个 lambda 把**一小段行为进行编码**，你能把它**当作值**到处传递。它可以被独立地声明并存储到一个变量中。但是更常见的还是**直接声明它并传递给函数**
  
  - **Lambda 和集合：**

    -   ```kotlin
        > > val people= listOf(Person{”Alice”, 29) , Person(”Bob”, 31))
        > > println (people. maxBy { it .age }) ←「 比较年龄找到最大 
        Person(name=Bob, age=31)
        //括号中的代码{ it.age}就是实现了这个逻辑的 lambda。
        //它接收一个集合中的元素作为实参(使用 it 引用它)并且返回用来比较的值 。
                                      
        //这个例子你能做的最后简化是使用默认参数名称代替命名参数。
        //如果当前上下文期望的是只有一个参数的 lambda 且这个参数的类型可以推断出来，就会生成这个名称。
        ```
  
    - 如果 lambda 刚好是函数或者属性的委托，可以用成员引用替换。
    - **Kotlin的lambda表达式始终用花括号包围。注意实参并没有用括号括起来。 箭 头把实参列表和 lambda 的函数体隔开。**
  
  - **Lambda 表达式的语法：**

      ```kotlin
         参数             函数体
      
      {x: Int, y: Int -> x + y}
      
           始终在花括号内
      
      //还是年龄例子，如果不用任何简明语法来重写这个例子，你会得到下面的代码:
      people.maxBy({ p: Person-> p.age })
      //Kotlin 有这样 一种语法约定，如果 lambda 表达式是函数调用的最后一个实参，它可以放到括号的外边。
      people. maxBy () { p: Person -> p.age }
      //当 lambda是函数唯一的实参时，还可以去掉调用代码中的空括号对:
      people.maxBy { p: Person -> p.age }
      //如果你想传递两个或更多 的 lambda，不能把超过一个的 lambda 放到外面。
      ```
  
  
  - **在作用域中访问变量：**
    
    - 当在函数内声明一个匿名 内部类的时候，能够在这个匿名类内部引这个函数的 参数和局部变量。 也可以用 lambda 做同样的事情 。 如果在函数内部使用 **lambda, 也可以访问这个函数的参数，还有在 lambda之前定义的局部变量。**
    
    - 这里 Kotiin和 Java 的一个显著区别就是，在 Kotiin 中**不会仅限于访问** final变量， 在 lambda 内部也可以**修改这些变量**
    
    - 从 lambda 内访问外部变量，我们称这些变量被 lambda捕捉，默认情况下，局部变量的生命期被限制在声明这个变量的函数中 。 但是如果它被 lambda 捕捉 了，使用这个变量 的代码可以被存储 并稍后再 执行 
    
      - **原理：**当你捕捉 final变量时，**它的值和使用这个值的 lambda代码一起存储** 。 而对非 final 变量来说，它的值被封装在一个特殊的包装器中，这样你就可以 改变这个值，而**对这个包装器的引用**会和 lambda代码一起存储。
    
      - **内部实现细节：**
    
        Java 只允许你捕捉 final 变量 。 当你想捕捉可变变量的时候，可以使用下面
        两种技巧:要么声明一个单元素的教组，其中存储可变值;要么创建一个包装
        类的实例，其中存储要改变的值的引用。如果你在 Kotlin 中显式地使用这些技术，
        代码看起来是这样的:
    
        ```kotlin
        class Ref <> (var value: T)  //模拟捕捉可变变量的类
        >> val counter=Ref (0)
        >>> val inc = {counter.value++}
        
        形式上是不变量被捕捉了，但是存储在字段中的实际值是可以修改的
        在实际代码中，你不需要创建这样的包装器，可以直接修改这个变量
        
        var counter =0
        val inc = {counter++}
        
        这是什么原理？第一例子展示的就是第二个例子背后的原理。任何时候你捕捉了一个 final 变量（val），它的值被拷贝下来，这和 Java 一样。而当你捕捉了一个可变变量（var）时，它的值被作为 Ref 类的一个实例被存储下来。Ref 变量是 fnal 的能轻易地被捕捉，然而实际值被存储在其字段中，并且可以在 lambda 内修改。
        ```
    
    - 这里有一个重要的注意事项，如果 lambda被用作事件处理器或者用在其他异步 执行的情况，对局部变量的修改只会在 lambda执行的时候发生。例如，下面这段代 码并不是记录按钮点击次数 的正确方法:
    
    ```kotlin
    Fun trytocountbuttonclicks (button: Button): Int{
    	var clicks =0
    	button.Onclick(clicks++)
    	return clicks
    }
    ```
    
    - 这个函数**始终返回 0**。尽管 onClick 处理器可以修改 clicks 的值，你 并不 能观察到值发生了变化，因为 onClick **处理器是 在函数返回之后调用 的** 。这个函数正确的实现需要把点击次数存储在函数外依然可以访问的地方一一**例如类的属性** ， 而不是存储在函数的局部变量中 。
    
  - **成员引用：**
    
    - 
    
    
    
    
  



- **以函数式风格使用集合：** 

- **序列:惰性地执行集合操作：**

- **在 Katlin 中使用 Java 函数式接口：**

- **使用带接收者的 lambda：**





----



### 六、Kotlin的类型系统



---



## 第二部分：拥抱Kotlin

### 七、运算符重载及其他约定



----



### 八、高阶函数：Lambda作为形参和返回值



----



### 九、泛型



---



### 十、注解与反射



---



### 十一、DSL构建



----






CSR（传统的浏览器端渲染）
Client Side Render
通常，我们的Vue项目是在npm run build打包之后，直接放到服务器端。浏览器去请求相应的html，加载对应的js文件，生成DOM。

路由改变，局部刷新，浏览器不会刷新
缺点
需要js全部加载完，页面才能出来，加载较慢（懒加载）
js改变dom，生成页面，不利于SEO

![在这里插入图片描述](https://tva1.sinaimg.cn/large/008i3skNly1gvisxnwkcij60h00duq3o02.jpg)



SSR（服务器端渲染是什么）
Server Side Render
SSR的原理是将打包后的文件，先在服务器端处理，生成一个个的HTML字符串，当浏览器请求的时候直接发过去。

每一个路由请求到的都是一个html串，路由改变，浏览器刷新

![在这里插入图片描述](https://tva1.sinaimg.cn/large/008i3skNly1gvisygxar7j60hb0a0t9502.jpg)

优点
利于SEO，搜索引擎爬虫抓取工具可以直接查看完全渲染的页面
更快的内容到达时间 (time-to-content)，更好的用户体验，特别是对于缓慢的网络情况或运行缓慢的设备。（压力来到了服务器，所以需要权衡哪些用服务端渲染，哪些交给客户端）

缺点

复杂度
库的支持性，代码兼容
性能问题，每个请求都是n个实例的创建，不然会污染，消耗会变得很大
缓存 node serve 、 nginx判断当前用户有没有过期，如果没过期的话就缓存，用刚刚的结果。
降级：监控cpu、内存占用过多，就spa，返回单个的壳
服务器负载变大，相对于前后端分离服务器只需要提供静态资源来说，服务器负载更大，所以要慎重使用（比如一整套图表页面，相对于服务端渲染，可能用户不会在乎初始加载的前几秒，可以交由客户端使用类似于骨架屏，或者懒加载之类的提升用户体验）



预渲染
只是用来改善少数营销页面的 SEO，可以使用预渲染（例如：pre-renderer），在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件，而无需使用 web 服务器实时动态编译 HTML。
也可以考虑用爬虫工具，比如puppeteer，让它直接从spa项目中爬出结果
————————————————
版权声明：本文为CSDN博主「star-1331」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_40970987/article/details/106837588
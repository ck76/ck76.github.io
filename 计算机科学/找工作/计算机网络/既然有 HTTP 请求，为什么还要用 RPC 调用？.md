[TOC]



首先，实名赞扬题主的问题。**这个问题非常好**。

但是，该提问也确实有点问题：**HTTP和RPC不是对等的概念**。

**RPC是一个完整的远程调用方案，它包括了：接口规范+序列化反序列化规范+通信协议等。**

而**HTTP只是一个通信协议，工作在OSI的第七层**，不是一个完整的远程调用方案。



所以，要想回答这个问题，应该拉平为一个对等的概念。例如，**HTTP+Restful规范+序列化与反序列化**，构成一个完整的远程调用方案，再和**RPC**进行比较。而**单纯的HTTP，只是一个通信协议，自然无法和RPC比较**。

这就像是牛（HTTP）不能和马车（RPC）比较。要想比较，就应该将牛补齐为牛车，然后和马车比较。

感觉题主应该是问：**基于HTTP的远程调用方案（包含了接口规范、序列化反序列化等） 和 使用RPC的远程调用方案 有什么不同。有了前者，为什么还要有后者。**

下面我们来解答这个问题。

------

我们先介绍基于HTTP的远程调用方案。

HTTP+Restful，其优势很大。它**可读性好**，且**可以得到防火墙的支持、跨语言的支持**。而且，在近几年的报告中，Restful**大有超过RPC的趋势**。

但是使用该方案也有其缺点，这是与其优点相对应的：

- 首先是**有用信息占比少**，毕竟HTTP工作在第七层，包含了大量的HTTP头等信息。
- 其次是**效率低**，还是因为第七层的缘故，必须按照HTTP协议进行层层封装。
- 还有，其**可读性似乎没有必要**，因为我们可以引入网关增加可读性。
- 此外，使用HTTP协议**调用远程方法比较复杂**，要封装各种参数名和参数值。

而RPC则与HTTP互补，我们详细介绍下。

看完这篇回答，**能让你对RPC的产生、原理、实现代码都有着清晰的了解**。这样，也能在业务系统中，在RPC和HTTP之间做好抉择。

但需要再说一句，不是说RPC好，也不是说HTTP好，**两者各有千秋，还在比拼中**。

要问我站谁？我**根据业务场景，灵活站位……**

------

评论区产生了一些争论，我在这里统一进行说明。争论主要发生在两点：

1、**HTTP和RPC同一级别，还是被RPC包含？**

2、**Restful也属于RPC么？**

对于以上两点，我画图来一一说明。

![img](https://tva1.sinaimg.cn/large/008i3skNly1gqewydjjp5j30jy0ebjsf.jpg)

上图是一个比较完整的关系图，这时我们发现HTTP（图中蓝色框）出现了两次。其中一个是和RPC并列的，都是跨应用调用方法的解决方案；另一个则是被RPC包含的，是RPC通信过程的可选协议之一。

因此，**第一个问题的答案是都对。看指的是哪一个蓝色框。**从题主的提问看，既然题主在纠结这两者，应该是指与RPC并列的蓝色框。所以，题主所述的HTTP请求应该是指：基于HTTP的远程调用方案（包含了接口规范、序列化反序列化等）。这样，它才是和RPC同一级别的概念。

第二个问题是在问远程过程调用（红色框）是不是包含了Restful（黄色框），这种理解的关键在于对RPC的理解。

RPC字面理解是远程过程调用，即在一个应用中调用另一个应用的方法。那Restful是满足的，通过它可以实现在一个应用中调用另一个应用的方法。

但是，上述理解使得RPC的定义过于宽泛。RPC通常特指在一个应用中调用另一个应用的接口而实现的远程调用，即红色框所指的范围。这样，RPC是不包含Restful的。

因此，**第二个问题的答案是Restful不属于RPC，除非对RPC有着非常规的宽泛理解。**

------

RPC的英文全称是Remote Procedure Call，翻译为中文叫“远程过程调用”。其中稍显晦涩的其实就是“过程”，过程其实就是方法。所以，可以把RPC理解为“远程方法调用”。

要了解远程过程调用，那先理解过程调用。非常简单，如下图，就是调用一个方法。这太常见了，不多解释。

![img](https://tva1.sinaimg.cn/large/008i3skNly1gqewycf80tj30bk02lmx0.jpg)

而在分布式系统中，因为每个服务的边界都很小，很有可能调用别的服务提供的方法。这就出现了服务A调用服务B中方法的需求，即远程过程调用。

要想让服务A调用服务B中的方法，最先想到的就是通过HTTP请求实现。是的，这是很常见的，例如服务B暴露Restful接口，然后让服务A调用它的接口。基于Restful的调用方式因为可读性好（服务B暴露出的是Restful接口，可读性当然好）而且HTTP请求可以通过各种防火墙，因此非常不错。

然而，如前面所述，基于Restful的远程过程调用有着明显的缺点，主要是效率低、封装调用复杂。当存在大量的服务间调用时，这些缺点变得更为突出。

服务A调用服务B的过程是应用间的内部过程，**牺牲可读性提升效率、易用性是可取的**。基于这种思路，RPC产生了。

通常，RPC要求在调用方中放置被调用的方法的接口。**调用方只要调用了这些接口，就相当于调用了被调用方的实际方法，十分易用**。于是，调用方可以像调用内部接口一样调用远程的方法，而不用封装参数名和参数值等操作。

![img](https://tva1.sinaimg.cn/large/008i3skNly1gqewyammwcj30e707zdft.jpg)

那要想实现这个过程该怎么办呢？别急，咱们一步一步来。

首先，调用方调用的是接口，必须得为接口构造一个假的实现。显然，要使用动态代理。这样，调用方的调用就被动态代理接收到了。

第二，动态代理接收到调用后，应该想办法调用远程的实际实现。这包括下面几步：

- 识别具体要调用的远程方法的IP、端口
- 将调用方法的入参进行序列化
- 通过通信将请求发送到远程的方法中

这样，远程的服务就接收到了调用方的请求。它应该：

- 反序列化各个调用参数
- 定位到实际要调用的方法，然后输入参数，执行方法
- 按照调用的路径返回调用的结果

整个过程如下所示。

![img](https://tva1.sinaimg.cn/large/008i3skNly1gqewykuzm8j30fv0ciq3h.jpg)

这样，RPC操作就完成了。

调用方调用内部的一个方法，但是被RPC框架偷梁换柱为远程的一个方法。之间的**通信数据可读性不需要好**，只需要RPC框架能读懂即可，因此**效率可以更高**。通常使用UDP或者TCP作为通讯协议，当然也可以使用HTTP。例如下面的示例中，为了保证实现最简单，就用了HTTP进行通信。

讲到这里，**RPC的产生原因、原理应该清楚了**。为了让大家真的明白，我写了一个真的是**最最简单的RPC实现**。把它放到了：

[https://github.com/yeecode/EasyRPCgithub.com](https://link.zhihu.com/?target=https%3A//github.com/yeecode/EasyRPC)

它包含一个客户端，一个服务端。客户端只要调用自身内部的接口，就通过这个小的RPC实现调用到了服务端的方法。

下面是客户端的代码，看着类有点多，其实代码不长。其中的RPC代码完成完成动态代理、远程调用参数序列化、远程调用发起、远程调用结果反序列化的工作。

![img](https://tva1.sinaimg.cn/large/008i3skNly1gqewyijhm9j30da09ndgl.jpg)RPC客户端

下面是服务端的代码，代码更少，完成远程调用接收、调用参数反序列化、调用实际触发、调用结果序列化的工作。

![img](https://tva1.sinaimg.cn/large/008i3skNly1gqewygzvhcj30cy06qt95.jpg)RPC服务端

这样，一个RPC小框架就做完了，并不复杂。

所以，不要被RPC吓到，它就是**让一个应用调用另一个应用中方法的一种实现方式**。与调用远程接口区别不大，条条大路通罗马。

再说一次，不是说RPC好，也不是说HTTP好，两者各有千秋。本质上，两者是**可读性和效率之间的抉择**，**通用性和易用性之间的抉择**。最终谁能发展更好，很难说。

要问我站谁？我**根据业务场景，灵活站位……**

如果还有什么没说清楚，可以留言讨论。



---



这个回答里恰巧讲了一些rpc通信协议的细节，但是强调一遍通信协议不是rpc最重要的部分，不要被这个回答带偏了。如果要了解rpc请更多的去了解服务治理(soa)的一些基本策略,推荐去看看dubbo的文档。这个问题其实是有理解误区的，首先 http 和 rpc 并不是一个并行概念。rpc是远端过程调用，其调用协议通常包含传输协议和序列化协议。传输协议包含: 如著名的 [gRPC]([grpc / grpc.io](https://link.zhihu.com/?target=http%3A//www.grpc.io/)) 使用的 http2 协议，也有如dubbo一类的自定义报文的tcp协议。序列化协议包含: 如基于文本编码的 xml json，也有二进制编码的 protobuf hessian等。因此我理解的你想问的问题应该是：**为什么要使用自定义 tcp 协议的 rpc 做后端进程通信？**要解决这个问题就应该搞清楚 http 使用的 tcp 协议，和我们自定义的 tcp 协议在报文上的区别。首先要否认一点 http 协议相较于自定义tcp报文协议，增加的开销在于连接的建立与断开。http协议是支持连接池复用的，也就是建立一定数量的连接不断开，并不会频繁的创建和销毁连接。二一要说的是http也可以使用protobuf这种二进制编码协议对内容进行编码，因此二者最大的区别还是在传输协议上。通用定义的http1.1协议的tcp报文包含太多废信息，一个POST协议的格式大致如下`HTTP/1.0 200 OK  Content-Type: text/plain Content-Length: 137582 Expires: Thu, 05 Dec 1997 16:00:00 GMT Last-Modified: Wed, 5 August 1996 15:55:28 GMT Server: Apache 0.84 <html>  <body>Hello World</body> </html>`即使编码协议也就是body是使用二进制编码协议，报文元数据也就是header头的键值对却用了文本编码，非常占字节数。如上图所使用的报文中有效字节数仅仅占约 30%，也就是70%的时间用于传输元数据废编码。当然实际情况下报文内容可能会比这个长，但是报头所占的比例也是非常可观的。那么假如我们使用自定义tcp协议的报文如下![img](https://tva1.sinaimg.cn/large/008i3skNly1gqex2nsxp8j30xw058mxn.jpg)报头占用的字节数也就只有16个byte，极大地精简了传输内容。这也就是为什么后端进程间通常会采用自定义tcp协议的rpc来进行通信的原因。-- 分割线 2017.08.03 --可能回答里面没有描述清楚，这个回答仅仅是用来纠正victory的回答的。所谓的效率优势是针对http1.1协议来讲的，http2.0协议已经优化编码效率问题，像grpc这种rpc库使用的就是http2.0协议。这么来说吧http容器的性能测试单位通常是kqps，自定义tpc协议则通常是以10kqps到100kqps为基准简单来说成熟的rpc库相对http容器，更多的是封装了“服务发现”，"负载均衡"，“熔断降级”一类面向服务的高级特性。可以这么理解，rpc框架是面向服务的更高级的封装。如果把一个http servlet容器上封装一层服务发现和函数代理调用，那它就已经可以做一个rpc框架了。所以为什么要用rpc调用？因为良好的rpc调用是面向服务的封装，针对服务的可用性和效率等都做了优化。单纯使用http调用则缺少了这些特性。





我估计题主是看了下面这个图，觉得http和rpc是在同一个层，而且互斥的概念。RPC只是对底层协议的封装，其实对具体的通信协议是啥并没有太多要求。
![img](https://tva1.sinaimg.cn/large/008i3skNly1gqex2gxupfj31400u0420.jpg)
实际上application layer是可以有不止一层的，比如说RPC可以直接建立在tcp之上，也可以建立在http协议之上。对于rpc来说，这都是一样的，只要把通讯的内容塞进不同的报文理好了。其实http是最常用的承载RPC的通信协议之一。而且我们可以在http 上传输xml和json这样的文本协议，也可以是protobuf和thrift这样的二进制协议，这都不是问题。大家常用的REST api就可以很好的封装成rpc。当然，http这种协议是笨重一些，但它的穿透性比较好，配套的设施也齐全，也比较简单直观，还是比较收欢迎的。比如说著名的grpc就通过http来传输。至于题主说引用太多包的问题，这就是RPC的服务器端框架和实现的问题了。要看题主要用什么样的框架，但总的来说这些rpc框架是让你的远程调用更方便，而不是更麻烦的。补充视频讲解：[https://youtu.be/a4Kf2LK8BUM​youtu.be](https://link.zhihu.com/?target=https%3A//youtu.be/a4Kf2LK8BUM)



---

下面一堆答案给题主科普各种RPC和HTTP的原理，什么RPC也可以包含HTTP协议，其实并没有解答题主的困惑。题主的问题准确来讲，是说：既然有HTTP请求可以解决系统间调用的问题了，为什么还会有人使用RPC调用？题主明显是只看到现状，而忽略了两种远程请求调用的历史进程。RPC在1984年就被人用来做分布式系统的通信，Java在1.1版本提供了Java版本的RPC框架（RMI），而HTTP协议在1990年才开始作为主流协议出现，而且HTTP发明的场景是用于web架构，而不是分布式系统间通信，这导致了在很长一段时间内，HTTP都是浏览器程序和后端web系统通信用的东西，上面的文档格式都是HTML（非常啰嗦），没有人会把HTTP作为分布式系统通信的协议。在很长一段时间内，RPC才是正统。随着前端技术的发展，AJAX技术和JSON文档在前端界逐渐成为主流，HTTP调用才摆脱HTML，开始使用JSON这一相对简洁的文档格式，为后面用于系统间调用定下基础。最后随着RESTFUL思潮的兴起，越来越多系统考虑用HTTP来提供服务，但这时候，RPC已经是各种大型分布式调用的标配了。所以题主的问题真正应该要反过来问，既然有RPC了，为什么还要有HTTP请求？这个问题不难回答，因为现在大部分的系统都是给浏览器使用的，因此HTTP协议必不可少，而这大部分系统中的绝大部分，对于后端系统间调用的性能都是要求不高的，毕竟走的都是内网，它们关心的是前端和后端的性能，因此后端系统间调用如果能够采用和前端一样的技术栈，那无疑是维护成本最低的，而这时HTTP的技术生态也刚好满足这个条件，所以就星星之火可以燎原了。那么对于少数的部分系统，他们需要使用RPC，一可能是老架构，也不敢动这块，二是性能要求可能只有RPC可以满足。就我个人而言，我所任职的公司的云平台也早就统一要求走HTTP了，性能，有别的路可以想办法，而且HTTP2也有了很大改进了。

---

只要是远程调用都可以叫RPC，和是不是通过http没什么关系。

REST就是一种常用的rpc，M纪用的实现是OData，A纪用的是CoralService，都是基于http的封装。

另外你说http同样功能几乎零配置，那是胡扯。你要想达到同等级的通用性，扩展性，还加上一堆常用的feature如重试、限流、容错等等，自个配置好http差不多拿出来也是和这几个一个等级的框架了。你能这么说说明你对常用rpc框架提供的功能压根没有什么概念。

当然rpc也有不通过http的，可以直接走socket，或者其他协议，在不同的场景甚至有优于http的性能表现，这个很正常。用http不是因为它性能好，而是因为它普适，随便一个web容器就能跑起来你的应用。

---



感觉题主是想问用HTTP实现RPC的功能比起其他的RPC框架（如thrift，grpc）更加方便，但为何还有人用thrift/grpc。

Well，题主说的没错。如果没有啥特殊需求，完全可以用http实现全部的rpc功能。想想看，当我们使用rpc，大概想实现什么功能？

- 发出一个“请求”，包含请求名称和参数；以及收到一个“返回”。在http中可以使用domain/url path/query string/body/header/status code等形式来描述请求和参数；
- 请求被可以以某种格式编码，完成传输。http实际上并不限制任何编码类型，只要配合Content-Type，用text，json，form，xsl，jpg，甚至是protobuf都可以。而传输过程中http在2.0或之前使用TCP。2.0因为使用了二进制格式会更高效。ip+tcp+ssl实现了寻址、可靠传输、加密传输的能力。实际上rpc也是使用ip+tcp+ssl这套机制。所以如果有了解过grpc的话，会发现它底层实际上是用的就是http 2.0；而[https://github.com/anujdas/thtp](https://link.zhihu.com/?target=https%3A//github.com/anujdas/thtp)实现了基于http的thrift能力；
- 围绕rpc建立起来的一系列辅助微服务工作的机制，如服务发现，限流，熔断，负载均衡……。其实这些内容和是否使用http没有什么关系。不管怎么折腾rpc，都是能实现的。
- 对数据格式的强类型检查。一般http使用json，对传输的请求/返回的约束比较松。而thrift和grpc都有自己的IDL，可以对格式进行强制约束和检查。但就算是使用json，也可以在客户端强加一个json schema check。而且刚才说过了，使用http的同时也可以使用thrift和protobuf，依然可以利用上IDL；但如果要传输高效，则一定要选择基于IDL的序列化方法。json的冗余还是太大了。
- 传递rpc的上下文。出于鉴权/tracing的需要，rpc一般需要传递上下文。若使用http，可以用header实现。thrift和protobuf可以hack其传输协议，增加等价于http header的东西，如果懒得搞也可以用“BaseRequest/BaseResponse“的方式解决（虽然有点丑）。

所以原则上，当你想基于rpc落地一套微服务框架时，传输的方式，序列化格式，服务治理……这些都可以任意搭配的。http和rpc早已你中有我，我中有你。只不过不管哪一种搭配，都需要花大量资源去落地。比如虽然http，thrift，grpc都可实现服务发现，限流，熔断……但每种技术的实际实现是完全不同的，基于不同语言去写的代码也不同。这个落地的代价是不可忽略的。因此，作为主要精力是处理业务的使用方，会直接使用目前生态比较成熟的全套解决方案，一揽子解决问题。所以一般是dubbo，spring cloud，thrift，grpc这几个选一套。

关键是一定要选**一套**，满足性能、自研扩展、容易维护的需要。

------

https://www.zhihu.com/collection/635148785?page=2
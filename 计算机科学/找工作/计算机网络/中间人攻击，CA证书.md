## 1、基础知识

### 1.1 对称加密算法

对称加密算法的特点是加密密钥和解密密钥是同一把密钥K，且加解密速度快，典型的对称加密算法有DES、AES等

[![image](https://images2015.cnblogs.com/blog/548912/201603/548912-20160303105320549-487055351.png)](http://images2015.cnblogs.com/blog/548912/201603/548912-20160303105320002-1643319367.png)

​                     **对称加密算法加密流程和解密流程**

### 1.2 非对称加密算法

非对称加密算法的特点是加密密钥K1和解密密钥K2是不一样的，他们是一对可互为加解密的密钥，一个可以公开，叫公钥；一个自己保留，不能让其他人知道，叫私钥。这样就能比较好的解决信息传递的安全性，相对来说加解密速度较慢，典型的非对称加密算法有RSA、DSA等。问题是如何保证加密用的接收者的公钥，即如何安全的传递公钥。

[![image](https://images2015.cnblogs.com/blog/548912/201603/548912-20160303111011190-1826727713.png)](http://images2015.cnblogs.com/blog/548912/201603/548912-20160303111010393-362603889.png)

​                         **非对称加密算法加密流程和解密流程**

### 1.3 摘要算法、数字签名

F(M) = D       E(D)=S

F是单向散列函数:即如果已知x，很容易计算F(x)，但已知F(x)，却很难算出x

数字签名就是用私钥将摘要加密的结果，这样能够保证数据的完整性、放篡改、以及不可抵赖性。

[![image](https://images2015.cnblogs.com/blog/548912/201603/548912-20160303111013487-1921207550.png)](http://images2015.cnblogs.com/blog/548912/201603/548912-20160303111011690-2075672771.png)

​                           **摘要算法及数字签名过程**

### 1.4 校验数据的完整性

乙方把接收到的发送方的明文用单向哈希函数取得摘要值与甲方的公钥解密甲方的数字签名而得到的摘要值进行比较，如果一样说明信息完整，未受篡改，如果不一样说明受到篡改

 

[![image](https://images2015.cnblogs.com/blog/548912/201603/548912-20160303111014549-473199446.png)](http://images2015.cnblogs.com/blog/548912/201603/548912-20160303111013987-84905129.png)

​               **检验数据完整性过程**

### 1.5 严密的数字加解密、数字签名与验证流程

在发送过程中首先将甲方的明文取摘要值，再将此摘要值用甲方的私钥加密得到甲方的签名，然后将甲的明文、数字签名和数字证书合在一起用甲方随机生成的对称密钥加密得到密文；第二步是将这一随机生成的对称密钥用乙方的公钥加密后得到数字信封；最后将密文和数字信封一起发送给乙方。

在乙方接收过程中，首先将收到数字信封用乙方的私钥解密，得到随机生成的对称密钥，第二步是解密得到的随机生成的对称密钥将密文解密，得到甲方的明文、数字签名和数字证书；第三步将甲方的明文取摘要值与甲方的数字签名用甲方的公钥解密得到的摘要进行比较，从而验证签名和检验数据的完整性。这一流程同时用到对称算法和非对称算法，是比较安全的流程

数字证书在这里起到的作用有：提供甲方的公钥，保证发送信息方的不可抵赖性。

[![image](https://images2015.cnblogs.com/blog/548912/201603/548912-20160303111015924-1066276656.png)](http://images2015.cnblogs.com/blog/548912/201603/548912-20160303111015049-1939114279.png)

​               **严密的数字加解密、数字签名和验证流程**

### 1.6 X.509证书

为了保证证书的一致性，国际电信联盟设计了一套专门针对证书格式的标准X.509，其核心提供了一种描述证书的格式。

X.509数字证书不仅包括用户名和密码，而且还包含了与用户有关的其他信息，通过使用证书，CA可以为证书接收者提供一种方法，使他们不仅信任证书主体的公钥，而且还信任有关证书主体的其他信息

X.509证书有有效期限、证书在期满后就会失效。期间CA可能会出于某些原因吊销证书。要吊销证书，CA保存并分发一个吊销证书的列表，即证书吊销列表CRL。网络用户可以访问CRL以确定证书的有效性

目前, X.509标准已在编排公共密钥格式方面被广泛接受，用户许多网络安全的应用程序，其中包括Ipsec, SSL, SET, S/MIME(安全多媒体Internet邮件扩展)

[![image](https://images2015.cnblogs.com/blog/548912/201603/548912-20160303111017377-1583281171.png)](http://images2015.cnblogs.com/blog/548912/201603/548912-20160303111016471-2104007069.png)

​                           **证书中主要域**

## 2、HTTPS协议详解

### 2.1 HTTPS概念说明

HTTPS(Hypertext Transfer Protocol over Secure Socket Layer)，是以安全为目标的HTTP通道，简单讲就是HTTP的安全版。其实现是在HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。

SSL协议位于TCP/IP协议与各种应用协议之间，是一种国际标准的加密及身份认证通信协议，为TCP提供一个可靠的端到端的安全服务，为两个通讯个体之间提供保密性和完整性。SSL层所处位置如下

[![image](https://images2015.cnblogs.com/blog/548912/201603/548912-20160303111018674-1292452276.png)](http://images2015.cnblogs.com/blog/548912/201603/548912-20160303111018205-824684771.png)

​                     **SSL示意图**

### 2.2、SSL协议特点

①SSL协议可用于保护正常运行与TCP之上的任何应用协议，如HTTP、FTP、SMTP或Telent的通信，最常见的是用户SSL来保护HTTP通信

②SSL协议的优点在于它是应用层协议无关的。高层的应用协议能透明的建立于SSL协议之上

③SSL协议的应用层协议之前就完成加密算法、通信密钥的协商以及服务器的认证工作。在此之后应用层协议所传送的数据都会被加密。从而保证通信的安全性。

④SSL协议使用通信双方的客户证书以及CA根证书。允许客户/服务器应用以一种不能被偷听的方式通信，在通信双方建立起了一条安全的、可信任的通信通道。

⑤该协议使用密钥对传送数据加密，许多网站都是通过这种协议从客户端接收信用卡编号等保密信息。常用于交易过程

### 2.3、SSL协议工作的基本流程

Sl工作基本流程图如下所示

[![image](https://images2015.cnblogs.com/blog/548912/201603/548912-20160303111020315-927640040.png)](http://images2015.cnblogs.com/blog/548912/201603/548912-20160303111019549-1250085261.png)

​               SSl工作基本流程图

SSL协议既用到了非对称加密技术又用到了对称加密技术。对称加密技术虽然比公钥加密技术的速度快，可是非对称加密技术提供的更好的身份认证技术。SSL的握手协议非常有效的让客户端和服务器之间完成相互之间的身份认证。其主要过程如下：

1)客户端向服务器传输客户端的SSL协议版本号，支持的加密算法的种类，产生的随机数Key1及其他信息

2)服务器在客户端发送过来的加密算法列表中选取一种，产生随机数Key2，然后发送给客户端

3)服务器将自己的证书发送给客户端

4)客户端验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的CA是否可靠，发行者的公钥能否正确解开服务器证书的”发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配，如果合法性验证没有通过，通信将断开，如果合法性验证通过，将继续向下进行；

5)客户端随机产生一个Pre-Master-Key，然后用服务器的公钥(从证书中获得)对其加密，然后将该Pre-Master-Key发送给服务器

6)服务器接收到Pre-Master-Key，则使用协商好的算法(H)计算出真正的用户通信过程中使用的对称加密密钥Master-Key=H(C1+S1+PreMaster);

7)至此为止，服务器和客户端之间都得到Master-Key，之后的通信过程就使用Master-Key作为对称加密的密钥进行安全通信；

## 3、中间人攻击原理

针对SSL的中间人攻击方式主要有两类，分别是SSL劫持攻击和SSL剥离攻击

### 3.1 SSL劫持攻击

SSL劫持攻击即SSL证书欺骗攻击，攻击者为了获得HTTPS传输的明文数据，需要先将自己接入到客户端和目标网站之间；在传输过程中伪造服务器的证书，将服务器的公钥替换成自己的公钥，这样，中间人就可以得到明文传输带Key1、Key2和Pre-Master-Key，从而窃取客户端和服务端的通信数据；

但是对于客户端来说，如果中间人伪造了证书，在校验证书过程中会提示证书错误，由用户选择继续操作还是返回，由于大多数用户的安全意识不强，会选择继续操作，此时，中间人就可以获取浏览器和服务器之间的通信数据

### 3.2 SSL剥离攻击

这种攻击方式也需要将攻击者设置为中间人，之后见HTTPS范文替换为HTTP返回给浏览器，而中间人和服务器之间仍然保持HTTPS服务器。由于HTTP是明文传输的，所以中间人可以获取客户端和服务器传输数据

[![image](https://images2015.cnblogs.com/blog/548912/201603/548912-20160303111022127-2010206344.png)](http://images2015.cnblogs.com/blog/548912/201603/548912-20160303111021065-1891624863.png)



---

## 中间人攻击

所谓中间人攻击就是服务器传递给客户端的公钥可能被攻击者替换，这样安全性就荡然无存了。接下来用例子说明如何产生攻击，例子中使用RSA密钥协商算法协商出密钥块，然后客户端和服务器端分别使用AES对称加密算法结合密钥块加密解密数据。

![img](https://pic1.zhimg.com/v2-1cc1c2bc554be5c02a797d9fbb6888fc_r.jpg)

上图流程：

- 客户端向服务器端发起连接请求，期望获取服务器的RSA公钥，攻击者劫持了这个请求。
- 攻击者自己生成一对RSA密钥对，然后将攻击者的RSA公钥发送给客户端。
- 攻击者然后再向服务器端发送请求，服务器生成RSA密钥对，将RSA公钥发送给客户端，实际上是发送给攻击者。
- 客户端通过攻击者的公钥加密密钥块并发送给服务器，实际上是发送给攻击者。
- 攻击者用自己的RSA私钥解密了密钥块A，然后自己生成一个密钥块B，用服务器的RSA公钥加密后发送给服务器端。
- 服务器端接收到请求后，用自己的RSA私钥解密出攻击者的密钥块B。
- 客户端使用攻击者的密钥块A，采用AES算法加密数据并发送给服务器端，实际上是发送给攻击者。
- 攻击者使用自己的密钥块A、采用AES算法解密出明文，客户端相当于泄露了隐私，攻击者使用密钥块B，采用AES算法加密明文后发送给服务器。
- 服务器使用密钥块B，采用AES算法加密数据并发送给攻击者。
- 攻击者使用密钥块B，采用AES算法解密出明文数据，此时客户端和服务器端的加密数据被成功破解。

这就是中间人攻击，在TLS/SSL协议中，客户端无法确认服务器端的真实身份，客户端访问https://www.example.com，接收到一个服务器公钥，但是无法确认公钥是不是真正属于http://www.example.com。公钥只是一串数字，需要有一种手段去认证公钥的真正主人，解决方案就是[PKI](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%85%AC%E9%92%A5%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/10881894%3Ffromtitle%3DPKI%26fromid%3D212376)。公开密钥算法中，所有的网络通信都会存在中间人攻击，这是务必要记住的一点，在HTTPS协议中必须引入PKI技术解决身份验证的问题，PKI技术的核心就是证书。

简单地说，PKI技术能够确保客户端接收到的服务器公钥（比如http://www.example.com网站的公钥）确实是http://www.example.com网站的公钥。

## 什么是PKI

简单通过一个示例解释什么是PKI，在中国，某个公民去银行办理业务，银行首先需要确认公民的身份，可是公民无法自己证明自己。国家的管理机构想到了一个好的方法，每个公民都要遵纪守法，为了确认公民的身份，国家给每个公民发了一张身份证，身份证上包括公民的姓名、年龄、地址、身份证号等关键信息。公民去银行办理业务的时候，使用身份证证明自己的身份，可为什么银行一定要信任身份证呢？因为身份证是国家签发的，身份证具有法律效应，银行机构作为这个法治国家的一部分，必须信任国家，这是基础条件，所有的信任都有一个基本前提。

但是身份证只是一张卡片，卡片可能被伪造（想到中间人攻击了吗？），实际上身份证的签署有复杂的技术基础，银行有专门的技术去校验身份证的真伪。总结来说，银行充分信任国家这个监管机构，也信任国家签发的身份证，一旦公民和身份证确认是一致的，等于是确认了公民的真实身份。如果公民拿着中国的身份证去国外银行办理业务，国外银行是不能进行身份认证的，原因就在于国外银行只信任本国的法律，没有义务信任别国的制度，这也进一步证明信任是相对的，是建立在一定基础上的。

PKI由多个不同的组织构成，组织必须基于一定的信任基础，主要由以下几部分组成。

- 服务器实体：公民相当于服务器实体，服务器实体就是HTTPS网站的提供者。
- 客户端（浏览器）：银行相当于客户端（浏览器）。
- CA机构：在HTTPS中，国家相当于CA机构，CA机构会向服务器实体签发一张证书（身份证）。和身份证一样，CA机构会签发一张证书（可以理解为就是一张身份证），证书中包含了一些关键信息，比如服务器的主机、服务器的公钥。

浏览器基于对CA机构的信任，有方法校验服务器的身份，和身份证不一样的是，互联网上的证书就是普普通通的文件，客户端如何校验证书呢？如何确认用户的身份呢（银行校验身份证的技术）？解决方案就是数字签名技术。

## 数字签名技术

### 申请证书流程

- 服务器实体希望发布一个HTTPS网站（https://www.example.com）。
- 服务器实体生成公开密钥算法的一对密钥，比如一对RSA密钥。
- 服务器实体生成一个CSR（Cerificate Signing Request）文件，CSR是证书签名请求文件，其中包含的重要信息是网站的域名（http://www.example.com）、RSA密钥对的公钥、营业执照，然后将CSR文件发送给CA机构申请证书。
- CA机构收到CSR文件后，核实申请者的身份，最简单的核实就是校验域名（http://www.example.com）的拥有者是不是证书申请者。
- 一旦审核成功，CA机构用自己的密钥对（比如ECDSA密钥对）的私钥签名CSR文件的内容得到签名值，然后将签名值附在CSR文件后面得到证书文件，证书文件中除了包含申请者的信息，还包括CA机构的信息，比如包括CA机构采用的签名算法（比如ECDSA签名算法）、CA机构的名称。
- 最终CA机构将证书文件发送给服务器实体。

### 客户端验证证书流程

- 浏览器向服务器端发送连接请求https://www.example.com。
- 服务器接收到请求后，将证书文件和RSA密钥对的公钥发送给浏览器。
- 浏览器接收到证书文件，从中判断出是某CA机构签发的证书，并且知道了证书签名算法是ECDSA算法，由于浏览器内置了该CA机构的根证书，根证书包含了CA机构的ECDSA公钥，用于验证签名。
- 浏览器一旦验证签名成功，代表该证书确实是合法CA机构签发的。
- 浏览器接着校验证书申请者的身份，从证书中取出RSA公钥（注意不是CA机构的公钥）和主机名，假设证书包含的主机也是http://www.example.com，且连接阶段接收到的RSA公钥等同于证书中包含的RSA公钥，则表示浏览器成功校验了服务器的身份，连接的服务器确实是http://www.example.com主机的拥有者。一旦服务器身份校验成功，接下来就是进行密钥协商，协商出密钥块。
- 密钥协商算法大致就是：客户端生成一个随机值，这个值必须是随机的，不能被攻击者猜出，这个值就是会话密钥。
- 客户端使用服务器RSA密钥对的公钥加密会话密钥，并发送给服务器端，由于攻击者没有服务器的私钥，所以无法解密会话密钥。
- 服务器端用它的私钥解密出会话密钥。
- 至此双方完成连接，接下来服务器端和客户端可以使用对称加密算法和会话密钥加密解密数据。

---

## **前言**

近年来各大公司对信息安全传输越来越重视，也逐步把网站升级到 HTTPS 了，那么大家知道 HTTPS 的原理是怎样的吗，到底是它是如何确保信息安全传输的？网上挺多介绍 HTTPS，但我发现总是或多或少有些点有些遗漏，没有讲全，今天试图由浅入深地把 HTTPS 讲明白，相信大家看完一定能掌握 HTTPS 的原理，本文大纲如下：

1. HTTP 为什么不安全
2. 安全通信的四大原则
3. HTTPS 通信原理简述

- 对称加密
- 数字证书
- 非对称加密
- 数字签名

1. 其它 HTTPS 相关问题

## **HTTP 为什么不安全**

HTTP 由于是明文传输，主要存在三大风险

1、 窃听风险

中间人可以获取到通信内容，由于内容是明文，所以获取明文后有安全风险

![img](https://pic1.zhimg.com/v2-957f639f9718eb380093dc99121357b4_r.jpg)

2、 篡改风险

中间人可以篡改报文内容后再发送给对方，风险极大

![img](https://pic1.zhimg.com/v2-f73b5a80a4997752dfb44e6834ff9688_r.jpg)

3、 冒充风险

比如你以为是在和某宝通信，但实际上是在和一个钓鱼网站通信。

![img](https://pic3.zhimg.com/v2-8e4fef204716b81fc2e8f56df70ccdce_r.jpg)

HTTPS 显然是为了解决这三大风险而存在的，接下来我们看看 HTTPS 到底解决了什么问题。

## **安全通信的四大原则**

看了上一节，不难猜到 HTTPS 就是为了解决上述三个风险而生的，一般我们认为安全的通信需要包括以下四个原则: **机密性**、**完整性**，**身份认证**和**不可否认**

1. **机密性**：即对数据加密，解决了窃听风险，因为即使被中间人窃听，由于数据是加密的，他也拿不到明文
2. **完整性**：指数据在传输过程中没有被篡改，不多不少，保持原样，中途如果哪怕改了一个标点符号，接收方也能识别出来，从来判定接收报文不合法
3. **身份认证**：确认对方的真实身份，即证明「你妈是你妈」的问题，这样就解决了冒充风险，用户不用担心访问的是某宝结果却在和钓鱼网站通信的问题
4. **不可否认**: 即不可否认已发生的行为，比如小明向小红借了 1000 元，但没打借条，或者打了借条但没有**签名**，就会造成小红的资金损失

接下来我们一步步来看看 HTTPS 是如何实现以满足以上四大安全通信原则的。

## **HTTPS 通信原理简述**

### **对称加密： HTTPS 的最终加密形式**

既然 HTTP 是明文传输的，那我们给报文加密不就行了，既然要加密，我们肯定需要通信双方协商好密钥吧，一种是通信双方使用**同一把密钥**，即**对称加密**的方式来给报文进行加解密。

![img](https://pic3.zhimg.com/v2-c6c30e5118ba8e1487697a152ff846ee_r.jpg)

如图示：使用对称加密的通信双方使用**同一把**密钥进行加解密。

对称加密具有加解密速度快，性能高的特点，也是 HTTPS 最终采用的加密形式，但是这里有一个关键问题，对称加密的通信双方要使用同一把密钥，这个密钥是如何协商出来的？如果通过报文的方式直接传输密钥，之后的通信其实还是在裸奔，因为这个密钥会被中间人截获甚至替换掉，这样中间人就可以用截获的密钥解密报文，甚至替换掉密钥以达到篡改报文的目的。

![img](https://pic2.zhimg.com/v2-4159c1a080ba6bc119031c015d19e591_r.jpg)

有人说对这个密钥加密不就完了，但对方如果要解密这个密钥还是要传加密密钥给对方，依然还是会被中间人截获的，这么看来直接传输密钥无论怎样都无法摆脱俄罗斯套娃的难题，是不可行的。

### **非对称加密：解决单向对称密钥的传输问题**

直接传输密钥无论从哪一端传从上节分析来看是不行了，这里我们再看另一种加密方式：**非对称加密**。

非对称加密即加解密双方使用不同的密钥，一把作为公钥，可以公开的，一把作为私钥，不能公开，公钥加密的密文只有私钥可以解密，私钥加密的内容，也只有公钥可以解密。

**注：私钥加密其实这个说法其实并不严谨，准确的说私钥加密应该叫私钥签名，因为私密加密的信息公钥是可以解密的，而公钥是公开的，任何人都可以拿到，用公钥解密叫做验签**

这样的话对于 server 来说，保管好私钥，发布公钥给其他 client, 其他 client 只要把对称加密的密钥加密传给 server 即可，如此一来由于公钥加密只有私钥能解密，而私钥只有 server 有，所以能保证 client 向 server 传输是安全的，server 解密后即可拿到对称加密密钥，这样交换了密钥之后就可以用对称加密密钥通信了。

![img](https://pic2.zhimg.com/v2-c93ee89d03f648e073fc48e479b1a1fd_r.jpg)

但是问题又来了， server 怎么把公钥**安全地**传输给 client 呢。如果直接传公钥，也会存在被中间人调包的风险。

![img](https://pic1.zhimg.com/v2-8bf4baa3417243b00438de6723e02678_r.jpg)

### **数字证书，解决公钥传输信任问题**

如何解决公钥传输问题呢，从现实生活中的场景找答案，员工入职时，企业一般会要求提供学历证明，显然不是什么阿猫阿狗的本本都可称为学历，这个学历必须由**第三方权威机构（Certificate Authority，简称 CA）**即教育部颁发，同理，server 也可以向 CA 申请证书，**在证书中附上公钥**，然后将证书传给 client，证书由站点管理者向 CA 申请，申请的时候会提交 DNS 主机名等信息，CA 会根据这些信息生成证书

![img](https://pic2.zhimg.com/v2-910d095c64715b27100fa5f5c5aa2031_r.jpg)

这样当 client 拿到证书后，就可以获得证书上的公钥，再用此公钥加密**对称加密密钥**传给 server 即可，看起来确实很完美，不过在这里大家要考虑两个问题

**问题一、 如何验证证书的真实性，如何防止证书被篡改**

想象一下上文中我们提到的学历，企业如何认定你提供的学历证书是真是假呢，答案是用学历编号，企业拿到证书后用学历编号在学信网上一查就知道证书真伪了，学历编号其实就是我们常说的**数字签名**，可以防止证书造假。

回到 HTTPS 上，证书的数字签名该如何产生的呢，一图胜千言

![img](https://pic4.zhimg.com/v2-5d9ac5fc1bba7e02d9e1d611001dd4eb_r.jpg)

步骤如下 1、 首先使用一些摘要算法（如 MD5）将证书明文（如证书序列号，DNS主机名等）生成摘要，然后再用第三方权威机构的私钥对生成的摘要进行加密（签名）

> 消息摘要是把任意长度的输入揉和而产生长度固定的伪随机输入的算法，无论输入的消息有多长，计算出来的消息摘要的长度总是固定的，一般来说，只要内容不同，产生的摘要必然不同（相同的概率可以认为接近于 0），所以可以验证内容是否被篡改了。

为啥要先生成摘要再加密呢，不能直接加密？

因为使用非对称加密是非常耗时的，如果把整个证书内容都加密生成签名的话，客户端验验签也需要把签名解密，证书明文较长，客户端验签就需要很长的时间，而用摘要的话，会把内容很长的明文压缩成小得多的定长字符串，客户端验签的话就会快得多。

2、客户端拿到证书后也用同样的摘要算法对证书明文计算摘要，两者一笔对就可以发现报文是否被篡改了，那为啥要用第三方权威机构（Certificate Authority，简称 CA）私钥对摘要加密呢，因为摘要算法是公开的，中间人可以替换掉证书明文，再根据证书上的摘要算法计算出摘要后把证书上的摘要也给替换掉！这样 client 拿到证书后计算摘要发现一样，误以为此证书是合法就中招了。所以必须要用 CA 的私钥给摘要进行加密生成签名，这样的话 client 得用 CA 的公钥来给签名解密，拿到的才是未经篡改合法的摘要（私钥签名，公钥才能解密）

server 将证书传给 client 后，client 的验签过程如下

![img](https://pic4.zhimg.com/v2-984d60947eac687c0353c33bc5442d73_r.jpg)

这样的话，由于只有 CA 的公钥才能解密签名，如果客户端收到一个假的证书，使用 CA 的公钥是无法解密的，如果客户端收到了真的证书，但证书上的内容被篡改了，摘要比对不成功的话，客户端也会认定此证书非法。

细心的你一定发现了问题，CA 公钥如何安全地传输到 client ？如果还是从 server 传输到 client，依然无法解决公钥被调包的风险，**实际上此公钥是存在于 CA 证书上，而此证书（也称 Root CA 证书）被操作系统信任，内置在操作系统上的，无需传输**，如果用的是 Mac 的同学，可以打开 keychain 查看一下，可以看到很多内置的被信任的证书。

![img](https://pic3.zhimg.com/v2-4785b622c7c98f9b98d1193db6d97a5e_r.jpg)

server 传输 CA 颁发的证书，客户中收到证书后使用**内置 CA 证书中的公钥**来解密签名，验签即可，这样的话就解决了公钥传输过程中被调包的风险。

**问题二、 如何防止证书被调包**

实际上任何站点都可以向第三方权威机构申请证书，中间人也不例外。

![img](https://pic2.zhimg.com/v2-9178ef2b67732c9c9eaf37a716b2cdc1_r.jpg)

正常站点和中间人都可以向 CA 申请证书，获得认证的证书由于都是 CA 颁发的，所以都是合法的，那么此时中间人是否可以在传输过程中将正常站点发给 client 的证书替换成自己的证书呢，如下所示

![img](https://pic2.zhimg.com/v2-915a28e82964636a5a8e2a86d5dc0465_r.jpg)

答案是不行，因为客户端除了通过验签的方式验证证书是否合法之外，**还需要验证证书上的域名与自己的请求域名是否一致**，中间人中途虽然可以替换自己向 CA 申请的合法证书，但此证书中的域名与 client 请求的域名不一致，client 会认定为不通过！

但是上面的证书调包给了我们一种思路，什么思路？大家想想， HTTPS 既然是加密的， charles 这些「中间人」为啥能抓到明文的包呢，其实就是用了证书调包这一手法，想想看，在用 charles 抓 HTTPS 的包之前我们先要做什么，当然是安装 charles 的证书

![img](https://pic1.zhimg.com/v2-617ad33d419e9156b49e9e5672d2dcec_r.jpg)

这个证书里有 charles 的公钥，这样的话 charles 就可以将 server 传给 client 的证书调包成自己的证书，client 拿到后就可以用你安装的 charles 证书来验签等，验证通过之后就会用 charles 证书中的公钥来加密对称密钥了，整个流程如下

![img](https://pic4.zhimg.com/v2-1bbb48dfc7178cfdea597a57521bbce7_r.jpg)

由此可知，charles 这些中间人能抓取 HTTPS 包的前提是信任它们的 CA 证书，然后就可以通过替换证书的方式进行瞒天过海，所以我们千万不要随便信任第三方的证书，避免安全风险。

## **其它 HTTPS 相关问题**

> 什么是双向认证 以上的讲述过程中，我们只是在 client 端验证了 server 传输证书的合法性，但 server 如何验证 client 的合法性，还是用证书，我们在网上进行转账等操作时，想想看是不是要先将银行发给我们的 U 盾插到电脑上？其实也是因为 U 盾内置了证书，通信时将证书发给 server，server 验证通过之后即可开始通信。 **画外音：身份认证只是 U 盾功能的一种，还有其他功能，比如加解密都是在 U 盾中执行，保证了密钥不会出现在内存中**
>
> 什么是证书信任链

前文说了，我们可以向 CA 申请证书，但全世界的顶级 CA（Root CA） 就那么几个，每天都有很多人要向它申请证书，它也忙不过来啊，怎么办呢，想想看在一个公司里如果大家都找 CEO 办事，他是不是要疯了，那他能怎么办？授权，他会把权力交给 CTO，CFO 等，这样你们只要把 CTO 之类的就行了，CTO 如果也忙不过来呢，继续往下授权啊。

![img](https://pic1.zhimg.com/80/v2-a77db9bf8dc2845a4108b3783b8cb9dc_1440w.jpg)

同样的，既然顶级 CA 忙不过来，那它就向下一级，下下级 CA 授权即可，这样我们就只要找一级/二级/三级 CA 申请证书即可。怎么证明这些证书被 Root CA 授权过了呢，小一点的 CA 可以让大一点的 CA 来签名认证，比如一级 CA 让 Root CA 来签名认证，二级 CA 让一级 CA 来签名认证,Root CA 没有人给他签名认证，只能自己证明自己了，这个证书就叫「自签名证书」或者「根证书」，我们必须信任它，不然证书信任链是走不下去的（这个根证书前文我们提过，其实是是内置在操作系统中的）

![img](https://pic4.zhimg.com/v2-9ea2d658341d8ef01a1a383026fd4827_r.jpg)

现在我们看看如果站点申请的是 二级 CA 颁发的证书，client 收到之后会如何验证这个证书呢，实际上 service 传了传给二级 CA 的证书外，**还会把证书信任链也一起传给客户端**，这样客户端会按如下步骤进行验证：

1. 浏览器就使用信任的根证书（根公钥）解析证书链的根证书得到一级证书的公钥+摘要验签
2. 拿一级证书的公钥解密一级证书，拿到二级证书的公钥和摘要验签
3. 再然后拿二级证书的公钥解密 server 传过来的二级证书，得到服务器的公钥和摘要验签，验证过程就结束了

## **总结**

相信大家看完本文应该对 HTTPS 的原理有了很清楚的认识了， HTTPS 无非就是 HTTP + SSL/TLS

![img](https://pic2.zhimg.com/v2-39bcf2fa71762981cf95c7ad2bb9d34d_r.jpg)

而 SSL/TLS 的功能其实本质上是**如何协商出安全的对称加密密钥以利用此密钥进行后续通讯的过程**，带着这个疑问相信你不难理解数字证书和数字签名这两个让人费解的含义，搞懂了这些也就明白了为啥 HTTPS 是加密的，charles 这些工具却能抓包出明文来。



---

我们知道，HTTP请求都是明文传输的，所谓的明文指的是没有经过加密的信息，如果HTTP请求被黑客拦截，并且里面含有银行卡密码等敏感数据的话，会非常危险。为了解决这个问题，Netscape 公司制定了HTTPS协议，HTTPS可以将数据加密传输，也就是传输的是密文，即便黑客在传输过程中拦截到数据也无法破译，这就保证了网络通信的安全。

## 密码学基础

在正式讲解HTTPS协议之前，我们首先要知道一些密码学的知识。

**明文**： 明文指的是未被加密过的原始数据。
 **密文**：明文被某种加密算法加密之后，会变成密文，从而确保原始数据的安全。密文也可以被解密，得到原始的明文。
 **密钥**：密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥，分别应用在对称加密和非对称加密上。

**对称加密**：对称加密又叫做私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据。对称加密的特点是算法公开、加密和解密速度快，适合于对大数据量进行加密，常见的对称加密算法有DES、3DES、TDEA、Blowfish、RC5和IDEA。
 其加密过程如下：**明文 + 加密算法 + 私钥 => 密文**
 解密过程如下：   **密文 + 解密算法 + 私钥 => 明文**

对称加密中用到的密钥叫做私钥，私钥表示个人私有的密钥，即该密钥不能被泄露。
 其加密过程中的私钥与解密过程中用到的私钥是同一个密钥，这也是称加密之所以称之为“对称”的原因。由于对称加密的算法是公开的，所以一旦私钥被泄露，那么密文就很容易被破解，所以对称加密的缺点是密钥安全管理困难。

**非对称加密**：非对称加密也叫做公钥加密。非对称加密与对称加密相比，其安全性更好。对称加密的通信双方使用相同的密钥，如果一方的密钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对密钥，即公钥和私钥，且二者成对出现。私钥被自己保存，不能对外泄露。公钥指的是公共的密钥，任何人都可以获得该密钥。用公钥或私钥中的任何一个进行加密，用另一个进行解密。
 被公钥加密过的密文只能被私钥解密，过程如下：
 **明文 + 加密算法 + 公钥 => 密文， 密文 + 解密算法 + 私钥 => 明文**
 被私钥加密过的密文只能被公钥解密，过程如下：
 **明文 + 加密算法 + 私钥 => 密文， 密文 + 解密算法 + 公钥 => 明文**

由于加密和解密使用了两个不同的密钥，这就是非对称加密“非对称”的原因。
 非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。
 在非对称加密中使用的主要算法有：RSA、Elgamal、Rabin、D-H、ECC（椭圆曲线加密算法）等。

## HTTPS通信过程

**HTTPS协议 = HTTP协议 + SSL/TLS协议**，在HTTPS数据传输的过程中，需要用SSL/TLS对数据进行加密和解密，需要用HTTP对加密后的数据进行传输，由此可以看出HTTPS是由HTTP和SSL/TLS一起合作完成的。

SSL的全称是Secure Sockets Layer，即安全套接层协议，是为网络通信提供安全及数据完整性的一种安全协议。SSL协议在1994年被Netscape发明，后来各个浏览器均支持SSL，其最新的版本是3.0

TLS的全称是Transport Layer Security，即安全传输层协议，最新版本的TLS（Transport Layer Security，传输层安全协议）是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本。在TLS与SSL3.0之间存在着显著的差别，主要是它们所支持的加密算法不同，所以TLS与SSL3.0不能互操作。虽然TLS与SSL3.0在加密算法上不同，但是在我们理解HTTPS的过程中，我们可以把SSL和TLS看做是同一个协议。

HTTPS为了兼顾安全与效率，同时使用了对称加密和非对称加密。数据是被对称加密传输的，对称加密过程需要客户端的一个密钥，为了确保能把该密钥安全传输到服务器端，采用非对称加密对该密钥进行加密传输，总的来说，对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输。

以下图片来自于[limboy的博客](https://links.jianshu.com/go?to=http%3A%2F%2Flimboy.me%2Ftech%2F2011%2F02%2F19%2Fhttps-workflow.html)

![img](https://tva1.sinaimg.cn/large/0081Kckwly1glojg8o6w6j30i00fkwfx.jpg)

image.png

**HTTPS在传输的过程中会涉及到三个密钥：**

服务器端的公钥和私钥，用来进行非对称加密

客户端生成的随机密钥，用来进行对称加密

一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步。
 1.客户端向服务器发起HTTPS请求，连接到服务器的443端口

2.服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。

3.服务器将自己的公钥发送给客户端。

4.客户端收到服务器端的证书之后，会对证书进行检查，验证其合法性，如果发现发现证书有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性，关于客户端如何验证数字证书的合法性，下文会进行说明。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。

5.客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。

6.服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。

7.然后服务器将加密后的密文发送给客户端。

8.客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。



作者：Leon_hy
链接：https://www.jianshu.com/p/14cd2c9d2cd2
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
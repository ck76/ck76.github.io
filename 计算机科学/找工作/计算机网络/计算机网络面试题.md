[TOC]

1 osi七层模型都是什么
我就背了一下五层模型，哈哈，然后展开说了一下各个层有的网络协议及端口和物理设备



##### 解释DNS和解析流程

```
DNS修改是指域bai名解析服du务器(Domain Name System)的修改。
如果您自己zhi有独立DNS服务dao器，想通过此zhuanDNS解析己注册成功的shu域名，您可选择DNS修改业务。登陆会员区-域名服务－域名管理－点击相应域名－DNS修改处修改您的域名DNS信息。
域名解析过程
第一步：客户机提出域名解析请求,并将该请求发送给本地的域名服务器。
第二步：当本地的域名服务器收到请求后,就先查询本地的缓存,如果有该纪录项,则本地的域名服务器就直接把查询的结果返回。
第三步：如果本地的缓存中没有该纪录,则本地域名服务器就直接把请求发给根域名服务器,然后根域名服务器再返回给本地域名服务器一个所查询域(根的子域)的主域名服务器的地址。
第四步：本地服务器再向上一步返回的域名服务器发送请求,然后接受请求的服务器查询自己的缓存,如果没有该纪录,则返回相关的下级的域名服务器的地址。
第五步：重复第四步,直到找到正确的纪录。
第六步：本地域名服务器把返回的结果保存到缓存,以备下一次使用,同时还将结果返回给客户机。
```

##### DNS协议/DNS域名解析的过程/DNS劫持

```
域名劫持 锁定
同义词 DNS劫持一般指域名劫持
域名劫持是互联网攻击的一种方式，通过攻击域名解析服务器（DNS），或伪造域名解析服务器（DNS）的方法，把目标网站域名解析到错误的IP地址从而实现用户无法访问目标网站的目的或者蓄意或恶意要求用户访问指定IP地址（网站）的目的。
```



##### socket 的使用流程

```

```



##### time_wait阶段在做什么

在TCP断开的过程中会有四个状态变化过程,如下图所示:

![img](https://tva1.sinaimg.cn/large/0081Kckwly1glkcx19pcrj30fe0a0gls.jpg)

 

在连接撤销过程中，有如下过程:                     

1.HOST1上的应用程序关闭己方的连接导致TCP发送一个FIN消息给HOST2。

2.HOST2发送一个确认消息给HOST1,并且HOST2把FIN作为EOF递交给HOST2上的应用程序。

3.一段时间过后，HOST2上的应用程序关闭它那边的连接，引发一个FIN消息给HOST1。

4.HOST1给HOST2发送一个确认消息，然后HOST2关闭连接并释放资源，然而，HOST1却没有关闭连接，而是进入了TIME_WAIT状态，并为两个最大段生存时间(2MSL)保留在此状态.

**为什么需要**TIME_WAIT**?**

1.因为在第四步的时候，HOST1发送的ACK可能丢失并导致HOST2重新发送FIN消息，TIME_WAIT维护连接状态.

 如果执行主动关闭的一方HOST1 不进入到TIME_WAIT状态就关闭连接那会发生什么呢？当重传的FIN消息到达时，因为TCP已经不再有连接的信息了，所以就用RST(重新启动)消息应答，导致**HOST2进入错误的状态而不是有序终止状态**，如果发送最后ACK消息的一方处于TIME_WAIT状态并仍然记录着连接的信息，它就可以正确的响应对等方HOST2的FIN消息了.

2.TIME_WAIT为连接中”离群的段”提供从网络中消失的时间.

 考虑一下，如果延迟或者重传段在连接关闭后到达时会发生什么呢？通常情况下，因为TCP仅仅丢弃该数据并响应RST消息，所以这不会造成任何问题。当RST消息到达发出延时段的主机时，因为该主机也没有记录连接的任何信息，所以它也丢弃该段。然而，如果两个相同主机之间又建立了一个具有相同端口号的新连接，那么离群的段就可能被看成是新连接的，如果离群的段中数据的任何序列号恰恰在新连接的当前接收窗口中，数据就会被重新接收，其结果就是破坏新连接。

总结一下：

1.服务器上出现大量TIME_WAIT状态时因为服务器主动关闭连接后，需要等待2MSL（最大段生命周期）时间。

2.TIME_WAIT状态存在的原因：

(1)解决对端重发Fin消息场景下，本机回复RST导致对端出现Connect Reset异常问题

(2)解决对端关闭后离群的消息段到达本机，造成本机与对端通信数据被破坏问题。

---



##### C/S模型，socket的建立过程

```
https://blog.csdn.net/u013782203/article/details/51767763
```

```
1、网络中进程之间如何通信？
本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：

消息传递（管道、FIFO、消息队列）
同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）
共享内存（匿名的和具名的）
远程过程调用（Solaris门和Sun RPC）
```




##### DNS拦截和HTTP拦截

```
    简单介绍一下HTTP劫持和DNS劫持的概念，也就是运营商通过某些方式篡改了用户正常访问的网页，插入广告或者其他一些杂七杂八的东西。

    首先对运营商的劫持行为做一些分析，他们的目的无非就是赚钱，而赚钱的方式有两种：

    1、对正常网站加入额外的广告，这包括网页内浮层或弹出广告窗口；

    2、针对一些广告联盟或带推广链接的网站，加入推广尾巴。例如普通访问百度首页，被前置跳转为http://www.baidu.com/?tn=90509114_hao_pg 

    在具体的做法上，一般分为DNS劫持和HTTP劫持。

    DNS劫持：

    一般而言，用户上网的DNS服务器都是运营商分配的，所以，在这个节点上，运营商可以为所欲为。

    例如，访问http://jiankang.qq.com/index.html，正常DNS应该返回腾讯的ip，而DNS劫持后，会返回一个运营商的中间服务器ip。访问该服务器会一致性的返回302，让用户浏览器跳转到预处理好的带广告的网页，在该网页中再通过iframe打开用户原来访问的地址。

    HTTP劫持：

    在运营商的路由器节点上，设置协议检测，一旦发现是HTTP请求，而且是html类型请求，则拦截处理。后续做法往往分为2种，1种是类似DNS劫持返回302让用户浏览器跳转到另外的地址，还有1种是在服务器返回的HTML数据中插入js或dom节点（广告）。
```



##### 对称加密秘钥和非对称加密有哪些

```
//对称性加密和非对称性加密分别什么时候使用（对称性在加密数据时使用，在传输密钥时使用非对称加密）
```



##### 五层协议的体系结构分别是什么？每一层都有哪些协议？time-wait

```java
物理层
数据链路层：逻辑链路控制LLC、媒体接入控制MAC
网络层：IP协议、地址解析协议ARP、逆地址解析协议RARP、因特网控制报文协议ICMP
传输层：传输控制协议TCP、用户数据报协议UDP
应用层：文件传输协议FTP、远程登录协议TELNET、超文本传输协议HTTP、域名系统DNS、简单邮件协议SMTP、简单网络管理协议SNMP
```



##### 为何有MAC地址还要IP地址？

```java
每台主机在出厂时都有一个唯一的MAC地址，但是IP地址的分配是根据网络的拓朴结构，得以保证路由选择方案建立在网络所处的拓扑位置基础而不是设备制造商的基础上
使用IP地址更方便数据传输。数据包在这些节点之间的移动都是由ARP协议负责将IP地址映射到MAC地址上来完成的。
```

```
长话短说，理由有三点。

一. 整体与局部

信息传递时候，需要知道的其实是两个地址：

终点地址（Final destination address）
下一跳的地址（Next hop address）
IP地址本质上是终点地址，它在跳过路由器（hop）的时候不会改变，而MAC地址则是下一跳的地址，每跳过一次路由器都会改变。

这就是为什么还要用MAC地址的原因之一，【它起到了记录下一跳的信息的作用。】

注：一般来说IP地址经过路由器是不变的，不过NAT（Network address translation）例外，这也是有些人反对NAT而支持IPV6的原因之一。

二. 分层实现
如果在IP包头（header）中增加了”下一跳IP地址“这个字段，在逻辑上来说，如果IP地址够用，交换机也支持根据IP地址转发（现在的二层交换机不支持这样做），其实MAC地址并不是必要的。

但用MAC地址和IP地址两个地址，用于分别表示物理地址和逻辑地址是有好处的。这样分层可以使网络层与链路层的协议更灵活地替换，网络层不一定非要用『IP』协议，链路层也不一定非用『以太网』协议。

这就像OSI七层模型，TCP/IP五层模型其实也不是必要的，用双层模型甚至单层模型实现网络也不是不可以的，只是那样做很蛋疼罢了。

三. 早期的『以太网』实现

早期的以太网只有集线器（hub），没有交换机（switch），所以发出去的包能被以太网内的所有机器监听到，因此要附带上MAC地址，每个机器只需要接受与自己MAC地址相匹配的包。
```

```
题主的问题应该和这个问题是等效的：有了 MAC 地址，为什么还要用 IP 地址？（因为两个问题的想法都是直接用设备的唯一 ID 来进行路由，只不过题主是把这个 ID 称作 IP，而我的这个问题是把这个 ID 称作 MAC 罢了。）

然后我们就发现这个问题变得简单了：当年设计 IP 地址的目的是什么呢？当年设计出 IP 地址这个东西，就是因为随着网络中的设备逐渐增多，人们发现路由（也就是寻找数据包从发送方到接收方的路径）变得越来越困难了。于是人们想了一个办法，就是把网络划分成很多个子网。这样，在路由的时候，路由器可以把其他子网看成一个整体来进行计算。对于目的地在其他子网的数据包，路由器只需要让数据包到达那个子网即可，而剩下的工作就由子网内部解决了。虽然这种方法只能让寻找到的路径接近最优而不保证最优，不过它大大减少了路由器的计算量，利大于弊，所以被采用了。

那么为什么我们需要 IP 地址呢？因为如果我们只用 MAC 地址的话，我们会发现路由器需要记住每个 MAC 地址所在的子网是哪一个（不然每一次收到数据包的时候路由器都要重新满世界地去找这个 MAC 地址的位置）。而世界上有[公式]个 MAC 地址，这就意味着即使我们给每个 MAC 地址只留 1 字节的储存空间，每个路由器也需要 256 TB 的内存！这显然是不可能实现的。

这就是我们需要 IP 地址的原因了。和 MAC 不同的是，【IP 地址是和地域相关的】。对于位于同一个子网上的设备，我们给他们分配的 IP 地址前缀都是一样的。这个前缀就像邮政编码一样。这样，路由器过 IP 地址的前缀就能知道这个设备在哪个子网上了。现在，路由器只需要记住每个子网的位置即可，【大大减少了路由器所需要的内存。】

既然 IP 地址不能去掉，那么能不能去掉 MAC 地址呢？也不能。因为 IP 地址是要设备上线以后，才能根据他进入了哪个子网来分配的，在设备还没有 IP 地址的时候（或者分配 IP 地址的过程中），我们还需要用 MAC 地址来区分不同的设备。

总之，MAC 地址就像自己的 ID 号，而 IP 地址就像带着邮政编码的住址，各有各的用途。所以我们需要两个地址，缺一不可。
```

```
简单地说：ip地址是服务商给你的bai，mac地址是你的网卡物理地址。
　　以下详情为转载：
　　一、IP地址
　　对于IP地址，相信大家都很熟悉，即指使用TCP/IP协议指定给主机的32位地址。IP地址由用点分隔开的4个8八位组构成，如192.168.0.1就是一个IP地址，这种写法叫点分十进制格式。IP地址由网络地址和主机地址两部分组成，分配给这两部分的位数随地址类（A类、B类、C类等）的不同而不同。网络地址用于路由选择，而主机地址用于在网络或子网内部寻找一个单独的主机。一个IP地址使得将来自源地址的数据通过路由而传送到目的地址变为可能。
　　二、MAC地址
　　对于MAC地址，由于我们不直接和它接触，所以大家不一定很熟悉。在OSI（Open System Interconnection，开放系统互连）7层网络协议（物理层，数据链路层，网络层，传输层，会话层，表示层，应用层）参考模型中，第二层为数据链路层（Data Link）。它包含两个子层，上一层是逻辑链路控制（LLC：Logical Link Control），下一层即是我们前面所提到的MAC（Media Access Control）层，即介质访问控制层。所谓介质（Media），是指传输信号所通过的多种物理环境。常用网络介质包括电缆（如：双绞线，同轴电缆，光纤），还有微波、激光、红外线等，有时也称介质为物理介质。MAC地址也叫物理地址、硬件地址或链路地址，由网络设备制造商生产时写在硬件内部。这个地址与网络无关，也即无论将带有这个地址的硬件（如网卡、集线器、路由器等）接入到网络的何处，它都有相同的MAC地址，MAC地址一般不可改变，不能由用户自己设定。
　　三、MAC地址的长度、表示方法、分配方法及其唯一性
　　MAC地址的长度为48位（6个字节），通常表示为12个16进制数，每2个16进制数之间用冒号隔开，如：08:00:20:0A:8C:6D就是一个MAC地址，其中前6位16进制数08:00:20代表网络硬件制造商的编号，它由IEEE（Istitute of Electrical and Electronics Engineers，电气与电子工程师协会）分配，而后3位16进制数0A:8C:6D代表该制造商所制造的某个网络产品（如网卡）的系列号。每个网络制造商必须确保它所制造的每个以太网设备都具有相同的前三字节以及不同的后三个字节。这样就可保证世界上每个以太网设备都具有唯一的MAC地址。
　　四、IP地址与MAC地址在互连网中的作用
　　既然每个以太网设备在出厂时都有一个唯一的MAC地址了，那为什么还需要为每台主机再分配一个IP地址呢？或者说为什么每台主机都分配唯一的IP地址了，为什么还要在网络设备（如网卡，集线器，路由器等）生产时内嵌一个唯一的MAC地址呢？主要原因有以下几点：（1）IP地址的分配是根据网络的拓朴结构，而不是根据谁制造了网络设置。若将高效的路由选择方案建立在设备制造商的基础上而不是网络所处的拓朴位置基础上，这种方案是不可行的。（2）当存在一个附加层的地址寻址时，设备更易于移动和维修。例如，如果一个以太网卡坏了，可以被更换，而无须取得一个新的IP地址。如果一个IP主机从一个网络移到另一个网络，可以给它一个新的IP地址，而无须换一个新的网卡。（3）无论是局域网，还是广域网中的计算机之间的通信，最终都表现为将数据包从某种形式的链路上的初始节点出发，从一个节点传递到另一个节点，最终传送到目的节点。数据包在这些节点之间的移动都是由ARP（Address Resolution Protocol：地址解析协议）负责将IP地址映射到MAC地址上来完成的。下面我们来通过一个例子看看IP地址和MAC地址是怎样结合来传送数据包的。
　　假设网络上要将一个数据包（名为PAC）由北京的一台主机（名称为A，IP地址为IP_A，MAC地址为MAC_A）发送到华盛顿的一台主机（名称为B，IP地址为IP_B，MAC地址为MAC_B）。这两台主机之间不可能是直接连接起来的，因而数据包在传递时必然要经过许多中间节点（如路由器，服务器等等），我们假定在传输过程中要经过C1、C2、C3（其MAC地址分别为M1，M2，M3）三个节点。A在将PAC发出之前，先发送一个ARP请求，找到其要到达IP_B所必须经历的第一个中间节点C1的MAC地址M1，然后在其数据包中封装（Encapsulation）这些地址：IP_A、IP_B，MAC_A和M1。当PAC传到C1后，再由ARP根据其目的IP地址IP_B，找到其要经历的第二个中间节点C2的MAC地址M2，然后再将带有M2的数据包传送到C2。如此类推，直到最后找到带有IP地址为IP_B的B主机的地址MAC_B，最终传送给主机B。在传输过程中，IP_A、IP_B和MAC_A不变，而中间节点的MAC地址通过ARP在不断改变（M1，M2，M3），直至目的地址MAC_B。
　　
　　综合上面所述，我们可以归纳出IP地址和MAC地址相同点是它们都唯一，不同的特点主要有：
　　1. 对于网络上的某一设备，如一台计算机或一台路由器，其IP地址可变（但必须唯一），而MAC地址不可变。我们可以根据需要给一台主机指定任意的IP地址，如我们可以给局域网上的某台计算机分配IP地址为192.168.0.112 ，也可以将它改成192.168.0.200。而任一网络设备（如网卡，路由器）一旦生产出来以后，其MAC地址永远唯一且不能由用户改变。
　　2. 长度不同。IP地址为32位，MAC地址为48位。
　　3. 分配依据不同。IP地址的分配是基于网络拓朴，MAC地址的分配是基于制造商。
　　4. 寻址协议层不同。IP地址应用于OSI第三层，即网络层，而MAC地址应用在OSI第二层，即数据链路层。 数据链路层协议可以使数据从一个节点传递到相同链路的另一个节点上（通过MAC地址），而网络层协议使数据可以从一个网络传递到另一个网络上（ARP根据目的IP地址，找到中间节点的MAC地址，通过中间节点传送，从而最终到达目的网络）。
```



##### TCP和UDP的区别？

```java
TCP传输控制协议：
  面向连接；
  使用全双工的可靠信道；【超时重传，确认应答，滑动窗口，拥塞控制】
  提供可靠的服务，即无差错、不丢失、不重复且按序到达；
  拥塞控制、流量控制、超时重发、丢弃重复数据等等可靠性检测手段；
  面向字节流；每条TCP连接只能是点到点的；
  用于传输可靠性要求高的数据
UDP用户数据报协议：
  无连接；
  使用不可靠信道；
  尽最大努力交付，即不保证可靠交付；
  无拥塞控制等；
  面向报文；
  支持一对一、一对多、多对一和多对多的交互通信；
  用于传输可靠性要求不高的数据
```



##### TCP 、UDP 的具体字段信

- https://blog.csdn.net/qq_42441693/article/details/102773890
- https://blog.csdn.net/advsance/article/details/97623764

```

```



##### 怎么理解TCP的连接 ，可靠和字节流

```
超时重传，确认应答，滑动窗口，拥塞控制
```

https://blog.csdn.net/qq_21586317/article/details/106463935



##### 长连接、短连接

- https://www.cnblogs.com/gotodsp/p/6366163.html
- https://www.pianshen.com/article/1143961519/

```
长连接怎么保活，心跳间隔为多久，长了怎么样，短了会怎么样
```



##### TCP传输的进行，如何保证数据的安全性

- （答了TCP首部的字段，引出checksum）（答了checksum、ack、sequence number、定时器）
- sequence number底层怎么设计的
- checksum怎么就能保证呢？（比特按位与）
- DNS劫持是什么？怎么解决？（只答出来了是什么

什么是tcp校验和？

![img](https://tva1.sinaimg.cn/large/0081Kckwly1glk4ijh8ngj30lu09g0ut.jpg)

tcp报文中，在tcp的首部之前，多了一个12字节的伪首部，伪首部中4个字节保存源ip信息，4个字节目的ip信息，一个字节的保留位置，一个字节保存协议号（6代表tcp，17代表udp），2个字节保存tcp的真正首部和数据。

根据伪首部的信息通过位运算，得到了一个校验和数据，保存在tcp保温的checksum字段。接收端接收到tcp报文后，也按照特定算法计算出一个校验和，与checksum保存的校验和比较，如果相同，则完成此报文的接收。如果不相同，则丢弃此报文，让发送端重传。

tcp校验和与ip校验和的区别是：TCP和UDP检验和覆盖首部和数据，而IP首部中的检验和只覆盖IP的首部，不覆盖IP数据报中的任何数据。

tcp校验和和udp校验和的区别是：TCP的检验和是必需的，而UDP的检验和是可选的。



##### TCP头部字段以及序列号的作用

```

```



##### 拥塞控制和流量控制都是什么，两者的区别？

```java
拥塞控制：对网络中的路由和链路传输进行速度限制，避免网络过载；包含四个过程：慢启动、拥塞避免、快重传和快恢复
流量控制 ：对点和点/发送方和接收方之间进行速度匹配，由于接收方的应用程序读取速度不一定很迅速，加上缓存有限，因此需要避免发送速度过快；相关技术：TCP滑动窗口、回退N针协议
```



##### 一、快速重传机制

上一篇讲到了TCP 的超时重传，但是超时重传往往会带来许多微妙的问题，比如说：

- 当一个报文段丢失时，会等待一定的超时周期然后才重传分组，增加了端到端的时延。
- 当一个报文段丢失时，在其等待超时的过程中，可能会出现这种情况：其后的报文段已经被接收端接收但却迟迟得不到确认，发送端会认为也丢失了，从而引起不必要的重传，既浪费资源也浪费时间。

幸运的是，由于TCP采用的是累计确认机制，即当接收端收到比期望序号大的报文段时，便会重复发送最近一次确认的报文段的确认信号，我们称之为冗余ACK（duplicate ACK）。
如图所示，报文段1成功接收并被确认ACK 2，接收端的期待序号为2，当报文段2丢失，报文段3失序到来，与接收端的期望不匹配，接收端重复发送冗余ACK 2。
![这里写图片描述](https://tva1.sinaimg.cn/large/0081Kckwly1glq3s3ejwcj307c07omya.jpg)

这样，如果在超时重传定时器溢出之前，接收到连续的三个重复冗余ACK（其实是收到4个同样的ACK，第一个是正常的，后三个才是冗余的），发送端便知晓哪个报文段在传输过程中丢失了，于是重发该报文段，不需要等待超时重传定时器溢出，大大提高了效率。这便是快速重传机制。



##### 请求方法有哪些，什么含义

```
GET
GET请求是向服务端请求获取某个或某些资源（resource），比如查询数据库单个或list数据，服务端成功的话，一般状态码返回200。

POST
POST请求是用来向服务端请求新增资源（resource），处理成功的话，服务端一般返回状态码201。

PUT
PUT请求一般是用来向服务端请求修改某个已存在的资源（resource）,服务端一般返回状态码200，204等。

DELETE
DELETE请求一般是用来向服务端请求删除某个已存在的资源（resource），服务端一般返回200，202等。

PATCH
PATCH请求一般是对某个资源做局部修改,如个别字段。

PUT和PATCH区别
PUT和PATCH都是用来修改服务端某个资源的，但是PUT和PATCH修改时提交的数据是不同的，PUT是将整个资源的信息都提交到服务端，包括修改的，未修改的都提交到服务端，而PATCH只提交已修改的字段到服务端。而服务端对PUT请求应该是整体替换，PATCH请求只修改提交的字段。所以PUT请求应该是幂等的，即多次提交同一个请求，结果是相同的。
```





##### HTTP和TCP的区别

```java
TCP是传输层协议，定义数据传输和连接方式的规范。通过三次握手建立连接、四次挥手释放连接。
HTTP是应用层协议，定义的是传输数据的内容的规范。HTTP的连接使用"请求-响应"方式。基于TCP协议传输，默认端口号是80。
```



##### get和post有什么区别

- https://blog.csdn.net/qq_32534441/article/details/89598975

```
回答1：
GET请求后退/刷新无害，POST后退/刷新则会导致重新提交数据。
GET书签可被收藏、POST为书签不可收藏。
GET能被缓存、POST不能被缓存。
GET编码类型application/x-www-form-url、POST编码类型常见encodedapplication/x-www-form-urlencoded或multipart/form-data。
GET历史参数保留在浏览器历史中、POST参数不会保存在浏览器历史中。
GET对数据长度有限制（url限制2048个字符）、POST无限制。
GET只允许ASCII字符、POST没有限制，也允许二进制数据。

回答2：
• GET 被强制服务器支持
• 浏览器对URL的长度有限制，所以GET请求不能代替POST请求发送大量数据
• GET请求发送数据更小
• GET请求是不安全的
• GET请求是幂等的
• POST请求不能被缓存
• POST请求相对GET请求是「安全」的

• 在以下情况中，请使用 POST 请求：

无法使用缓存文件（更新服务器上的文件或数据库）
向服务器发送大量数据（POST 没有数据量限制）
发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
post比Get安全性更高
```



##### 在地址栏打入URL会发生什么？八个步骤

```java
浏览器向DNS服务器请求解析该URL中的域名所对应的IP地址
解析出IP地址后，根据该IP地址和默认端口80，和服务器建立TCP连接
浏览器发出读取文件的HTTP请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器
服务器对浏览器请求作出响应，并把对应的html文本发送给浏览器
释放TCP连接，若connection模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接；若connection模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求
客户端将服务器响应的html文本解析并显示
```



https://blog.csdn.net/weixin_48684274/article/details/108263608

##### 1、TCP/IP

- TCP（传输控制协议）是一种面向连接的通过失败重传机制确保数据在端到端之间可靠传输的协议。

- IP是面向无连接的没有额外的控制机制保证发送的包是否有序到达。

- 五层模型：应用层、传输层、网络层、链路层、物理层

- 总结一下：程序在发送消息时，应用层按既定的协议打包数据，随后由数据层加上双方端口号，网络层加上双方IP地址，链路层加上双方MAC地址，并且将数据拆分成数据帧，经过多个路由器和网关后到达目的机器。简而言之，就是按“端口--IP地址--MAC地址”这样的路径进行数据的封装和发送。
  - 三次握手：SYN和ACK置0和1，seq 和 ack [序号和应答号]    x和y
  - 你听得见吗？
  - 我听得见，你听得见吗？
  - 我也听得见，我们说话吧。

- 通过三次握手，A和B都能确认自己和对方的收发信能力，相当于建立了互相的信任，就可以开始通信了。

  下面，我们介绍一下三次握手具体发送的内容，用一张图描述如下：

  

  <img src="http://s191.photo.store.qq.com/psb?/V14L47VC0w3vOf/EK0CYGY18Zs1mQ3LUCmJFeDinln7*O8Jb0rs9N6AJys!/b/dL8AAAAAAAAA" alt="img" style="zoom:50%;" />

  

  首先，介绍一下几个概念：

  - ACK：响应标识，1表示响应，连接建立成功之后，所有报文段ACK的值都为1
  - SYN：连接标识，1表示建立连接，连接请求和连接接受报文段SYN=1，其他情况都是0
  - FIN：关闭连接标识，1标识关闭连接，关闭请求和关闭接受报文段FIN=1，其他情况都是0，跟SYN类似
  - seq number：序号，一个随机数X，请求报文段中会有该字段，响应报文段没有
  - ack number：应答号，值为请求seq+1，即X+1，除了连接请求和连接接受响应报文段没有该字段，其他的报文段都有该字段

  知道了上面几个概念后，看一下三次握手的具体流程：

  1. 第一次握手：建立连接请求。客户端发送连接请求报文段，将SYN置为1，seq为随机数x。然后，客户端进入SYN_SEND状态，等待服务器确认。
  2. 第二次握手：确认连接请求。服务器收到客户端的SYN报文段，需要对该请求进行确认，设置ack=x+1（即客户端seq+1）。同时自己也要发送SYN请求信息，即SYN置为1，seq=y。服务器将SYN和ACK信息放在一个报文段中，一并发送给客户端，服务器进入SYN_RECV状态。
  3. 第三次握手：客户端收到SYN+ACK报文段，将ack设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕，客户端和服务券进入ESTABLISHED状态，完成Tcp三次握手。

- 四次握手：
  - 我们分手吧
  - 好等我收拾东西，收拾完我告诉你
  - 我收拾完了
  - 好再见

##### tcp为啥是三次握手，四次挥手

```

```

断开连接是只有[客户端](https://www.nowcoder.com/jump/super-jump/word?word=客户端)断开还是两方都能断开



##### 断点续传怎么做的/

```
断点续传是怎么实现的？
可使用HTTP报文首部字段Range实现范围请求

对一份10000字节大小的资源，如果使用【范围请求】，可只请求5001~10000字节内的资源。

执行范围请求时，会用到HTTP首部字段Range来指定资源的byte范围。形式如下：

5001~10000字节

Range:bytes=5001-10000
从5001字节之后全部的

Range:bytes=5001-
从1开始到3000字节和从5000开始到7000字节的多重范围

Range:bytes=-3000,5000-7000
针对范围请求，响应会返回状态码为206 Partial Content 的响应报文。另外，对于多重范围的范围请求，响应会在首部字段Content-Type标明multipart/byteranges后返回响应报文。

如果服务器无法响应范围请求，则会返回状态码200 OK和完整的实体内容。

因此，在进行断点续传时，只需使用范围请求，通过指定HTTP请求报文首部字段Range来请求尚未收到的资源。


以上内容摘抄自《图解HTTP》，整理至此便于复习。
```



##### 有了mac地址为什么要有ip地址

```
一. 整体与局部

信息传递时候，需要知道的其实是两个地址：

终点地址（Final destination address）
下一跳的地址（Next hop address）
IP地址本质上是终点地址，它在跳过路由器（hop）的时候不会改变，而MAC地址则是下一跳的地址，每跳过一次路由器都会改变。

这就是为什么还要用MAC地址的原因之一，它起到了记录下一跳的信息的作用。

注：一般来说IP地址经过路由器是不变的，不过NAT（Network address translation）例外，这也是有些人反对NAT而支持IPV6的原因之一。

二. 分层实现
如果在IP包头（header）中增加了”下一跳IP地址“这个字段，在逻辑上来说，如果IP地址够用，交换机也支持根据IP地址转发（现在的二层交换机不支持这样做），其实MAC地址并不是必要的。

但用MAC地址和IP地址两个地址，用于分别表示物理地址和逻辑地址是有好处的。这样分层可以使网络层与链路层的协议更灵活地替换，网络层不一定非要用『IP』协议，链路层也不一定非用『以太网』协议。

这就像OSI七层模型，TCP/IP五层模型其实也不是必要的，用双层模型甚至单层模型实现网络也不是不可以的，只是那样做很蛋疼罢了。

三. 早期的『以太网』实现

早期的以太网只有集线器（hub），没有交换机（switch），所以发出去的包能被以太网内的所有机器监听到，因此要附带上MAC地址，每个机器只需要接受与自己MAC地址相匹配的包。
```

![img](https://tva1.sinaimg.cn/large/0081Kckwly1glq48jtt9bj30u00bst9y.jpg)



```
1. ARP出现原因

ARP协议是“Address Resolution Protocol”（地址解析协议）的缩写。其作用是在以太网环境中，数据的传输所依懒的是MAC地址而非IP地址，而将已知IP地址转换为MAC地址的工作是由ARP协议来完成的。

在局域网中，网络中实际传输的是“帧”，帧里面是有目标主机的MAC地址的。在以太网中，一个主机和另一个主机进行直接通信，必须要知道目标主机的MAC地址。但这个目标MAC地址是如何获得的呢？它就是通过地址解析协议获得的。所谓“地址解析”就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。ARP协议的基本功能就是通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。
```



##### HTTPS的加密过程

- https://www.pianshen.com/article/5553679193/
- https://www.pianshen.com/article/1341752136/

##### 2、HTTPS

- 哈希算法：MD5、 SHA
- 对称加密：AES、DES、3DES
- 非对称加密：RSA
- Https握手过程
  - 客户端给出协议版本号、一个客户端随机数A（Client random）以及客户端支持的加密方式
  - 服务端确认双方使用的加密方式，并给出数字证书、一个服务器生成的随机数B（Server random）
  - 客户端确认数字证书有效，生成一个新的随机数C（Pre-master-secret），**使用证书中的公钥**对C加密，发送给服务端
  - 服务端使用自己的私钥解密出C
  - 客户端和服务器根据约定的加密方法，使用三个随机数ABC，生成对话秘钥，之后的通信都用这个对话秘钥进行加密。

##### 请求头字段

https://www.cnblogs.com/qufanblog/p/3963963.html

https://blog.csdn.net/huagjie/article/details/80720249

算法原理简介



##### socket

- https://blog.csdn.net/pashanhu6402/article/details/96428887



##### 访问一个国外网站的过程如何提升访问速度

```
DNS服务器的主要作用就是解析域名,它就像一个翻译官,当我们从浏览器地址栏发送网址时,首先要通过它将网址转换成真实的IP地址才能访问站点。所以作为中间人,DNS服务器的反应速度也会影响上网速度。

我们知道,DNS解析也是决定网速快慢的一个很大原因。如果总是自己手动查找并配置速度较快的DNS服务器,实在麻烦,其实彗星DNS优化器。可以智能做这件事:它提供了2000个左右备选的DNS,并可以一键测速并选择最快的DNS作为本机DNS服务器。启动程序后,单击“操作→一键完成(推荐)”即可。程序会自动将测试最快的DNS写入网络连接里的设置,此时再打开“网络连接→支持→详细信息”就可以看到多个DNS地址了。

另外,还可以使用谷歌推出的“namebench”,启动程序后单击“Runing”,程序会自动对200个DNS进行测速,并给出具体测试结果,我们只要按提示输入最快DNS服务器地址就可以啦。
```



#####  ping采用什么协议（ICMP协议）说错了

```
使用的是ICMP协议，是“Internet Control Message Protocol”（Internet控制消息协议）的缩写，是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。
它是用来检查网络是否通畅或者网络连接速度的命令。它所利用的原理是这样的：利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据包来确定两台网络机器是否连接相通，时延是多少。
```



##### 现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？

```
先来谈谈第一个问题：现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？

在 HTTP/1.0 中，一个服务器在发送完一个 HTTP 响应后，会断开 TCP 链接。但是这样每次请求都会重新建立和断开 TCP 连接，代价过大。所以虽然标准中没有设定，某些服务器对 Connection: keep-alive 的 Header 进行了支持。

意思是说，完成这个 HTTP 请求之后，不要断开 HTTP 请求使用的 TCP 连接。这样的好处是连接可以被重新使用，之后发送 HTTP 请求的时候不需要重新建立 TCP 连接，以及如果维持连接，那么 SSL 的开销也可以避免.持久连接：既然维持 TCP 连接好处这么多，HTTP/1.1 就把 Connection 头写进标准，并且默认开启持久连接，除非请求中写明 Connection: close，那么浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉。

所以第一个问题的答案是：默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 Connection: close 才会在请求完成后关闭连接。
```



##### 一个 TCP 连接可以对应几个 HTTP 请求？

```
了解了第一个问题之后，其实这个问题已经有了答案，如果维持连接，一个 TCP 连接是可以发送多个 HTTP 请求的。
```



##### 一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？

```
HTTP/1.1 存在一个问题，单个 TCP 连接在同一时刻只能处理一个请求，意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。

虽然 HTTP/1.1 规范中规定了 Pipelining 来试图解决这个问题，但是这个功能在浏览器中默认是关闭的。
一个支持持久连接的客户端可以在一个连接中发送多个请求（不需要等待任意请求的响应）。收到请求的服务器必须按照请求收到的顺序发送响应。

至于标准为什么这么设定，我们可以大概推测一个原因：由于 HTTP/1.1 是个文本协议，同时返回的内容也并不能区分对应于哪个发送的请求，所以顺序必须维持一致。比如你向服务器发送了两个请求 GET /query?q=A 和 GET /query?q=B，服务器返回了两个结果，浏览器是没有办法根据响应结果来判断响应对应于哪一个请求的。

Pipelining 这种设想看起来比较美好，但是在实践中会出现许多问题：

一些代理服务器不能正确的处理 HTTP Pipelining。

正确的流水线实现是复杂的。

Head-of-line Blocking 连接头阻塞：在建立起一个 TCP 连接之后，假设客户端在这个连接连续向服务器发送了几个请求。按照标准，服务器应该按照收到请求的顺序返回结果，假设服务器在处理首个请求时花费了大量时间，那么后面所有的请求都需要等着首个请求结束才能响应。

所以现代浏览器默认是不开启 HTTP Pipelining 的。

但是，HTTP2 提供了 Multiplexing 多路传输特性，可以在一个 TCP 连接中同时完成多个 HTTP 请求。至于 Multiplexing 具体怎么实现的就是另一个问题了。
所以这个问题也有了答案：在 HTTP/1.1 存在 Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。

那么在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？主要有下面两点：

维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求。

和服务器建立多个 TCP 连接。
```



##### 为什么有的时候刷新页面不需要重新建立 SSL 连接？

```
在第一个问题的讨论中已经有答案了，TCP 连接有的时候会被浏览器和服务端维持一段时间。TCP 不需要重新建立，SSL 自然也会用之前的。
```



##### 浏览器对同一 Host 建立 TCP 连接到数量有没有限制？

```
假设我们还处在 HTTP/1.1 时代，那个时候没有多路传输，当浏览器拿到一个有几十张图片的网页该怎么办呢？肯定不能只开一个 TCP 连接顺序下载，那样用户肯定等的很难受，但是如果每个图片都开一个 TCP 连接发 HTTP 请求，那电脑或者服务器都可能受不了，要是有 1000 张图片的话总不能开 1000 个TCP 连接吧，你的电脑同意 NAT 也不一定会同意。

所以答案是：有。Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别
```



##### **那么回到最开始的问题，收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？**

```
如果图片都是 HTTPS 连接并且在同一个域名下，那么浏览器在 SSL 握手之后会和服务器商量能不能用 HTTP2，如果能的话就使用 Multiplexing 功能在这个连接上进行【多路传输】。不过也未必会所有挂在这个域名的资源都会使用一个 TCP 连接去获取，但是可以确定的是 Multiplexing 很可能会被用到。

如果发现用不了 HTTP2 呢？或者用不了 HTTPS（现实中的 HTTP2 都是在 HTTPS 上实现的，所以也就是只能使用 HTTP/1.1）。那浏览器就会在一个 HOST 上建立多个 TCP 连接，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求，如果所有的连接都正在发送请求呢？那其他的请求就只能等等了。
```


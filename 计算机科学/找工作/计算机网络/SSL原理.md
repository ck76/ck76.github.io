http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html

https://blog.csdn.net/it_man/article/details/24698093

https://www.cnblogs.com/bhlsheji/p/4586597.html

互联网的通信安全，建立在SSL/TLS协议之上。

本文简要介绍SSL/TLS协议的运行机制。文章的重点是设计思想和运行过程，不涉及具体的实现细节。如果想了解这方面的内容，请参阅[RFC文档](http://tools.ietf.org/html/rfc5246)。

**一、作用**

不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。

> （1） **窃听风险**（eavesdropping）：第三方可以获知通信内容。
>
> （2） **篡改风险**（tampering）：第三方可以修改通信内容。
>
> （3） **冒充风险**（pretending）：第三方可以冒充他人身份参与通信。

SSL/TLS协议是为了解决这三大风险而设计的，希望达到：

> （1） 所有信息都是**加密传播**，第三方无法窃听。
>
> （2） 具有**校验机制**，一旦被篡改，通信双方会立刻发现。
>
> （3） 配备**身份证书**，防止身份被冒充。

互联网是开放环境，通信双方都是未知身份，这为协议的设计带来了很大的难度。而且，协议还必须能够经受所有匪夷所思的攻击，这使得SSL/TLS协议变得异常复杂。

**二、历史**

互联网加密通信协议的历史，几乎与互联网一样长。

> 1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。
>
> 1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。
>
> 1996年，SSL 3.0版问世，得到大规模应用。
>
> 1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版[TLS](http://en.wikipedia.org/wiki/Secure_Sockets_Layer) 1.0版。
>
> 2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的[修订版](http://tools.ietf.org/html/rfc6176)。

目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。

TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。

**三、基本的运行过程**

SSL/TLS协议的基本思路是采用[公钥加密法](http://en.wikipedia.org/wiki/Public-key_cryptography)，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。

但是，这里有两个问题。

**（1）如何保证公钥不被篡改？**

> 解决方法：将公钥放在[数字证书](http://en.wikipedia.org/wiki/Digital_certificate)中。只要证书是可信的，公钥就是可信的。

**（2）公钥加密计算量太大，如何减少耗用的时间？**

> 解决方法：每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。

因此，SSL/TLS协议的基本过程是这样的：

> （1） 客户端向服务器端索要并验证公钥。
>
> （2） 双方协商生成"对话密钥"。
>
> （3） 双方采用"对话密钥"进行加密通信。

上面过程的前两步，又称为"握手阶段"（handshake）。

**四、握手阶段的详细过程**

![img](https://tva1.sinaimg.cn/large/0081Kckwly1glq50qh7h7j30g40erwem.jpg)

"握手阶段"涉及四次通信，我们一个个来看。需要注意的是，"握手阶段"的所有通信都是明文的。

**4.1 客户端发出请求（ClientHello）**

首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。

在这一步，客户端主要向服务器提供以下信息。

> （1） 支持的协议版本，比如TLS 1.0版。
>
> （2） 一个客户端生成的随机数，稍后用于生成"对话密钥"。
>
> （3） 支持的加密方法，比如RSA公钥加密。
>
> （4） 支持的压缩方法。

这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。

对于虚拟主机的用户来说，这当然很不方便。2006年，TLS协议加入了一个[Server Name Indication扩展](http://tools.ietf.org/html/rfc4366)，允许客户端向服务器提供它所请求的域名。

**4.2 服务器回应（SeverHello）**

服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。

> （1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
>
> （2） 一个服务器生成的随机数，稍后用于生成"对话密钥"。
>
> （3） 确认使用的加密方法，比如RSA公钥加密。
>
> （4） 服务器证书。

除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供"客户端证书"。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。

**4.3 客户端回应**

客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。

如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。

> （1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。
>
> （2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
>
> （3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。

上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称"pre-master key"。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把"会话密钥"。

至于为什么一定要用三个随机数，来生成"会话密钥"，[dog250](http://blog.csdn.net/dog250/article/details/5717162)解释得很好：

> "不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。
>
> 对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。
>
> pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。"

此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。

**4.4 服务器的最后回应**

服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的"会话密钥"。然后，向客户端最后发送下面信息。

> （1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
>
> （2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。

至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用"会话密钥"加密内容。

![img](https://tva1.sinaimg.cn/large/0081Kckwly1glq51eb4ptg308t08e0sm.gif)



---

### 公钥和私钥 

一直以来对公钥和私钥都理解得不是很透彻，感觉到模棱两可。今天在网上找了半天，通过查看对这个密钥对的理解，总算弄清楚了。
   公钥和私钥就是俗称的不对称加密方式，是从以前的对称加密（使用用户名与密码）方式的提高。用电子邮件的方式说明一下原理。
   使用公钥与私钥的目的就是实现安全的电子邮件，必须实现如下目的：
   \1. 我发送给你的内容必须加密，在邮件的传输过程中不能被别人看到。
   \2. 必须保证是我发送的邮件，不是别人冒充我的。
   要达到这样的目标必须发送邮件的两人都有公钥和私钥。
   公钥，就是给大家用的，你可以通过电子邮件发布，可以通过网站让别人下载，公钥其实是用来加密/验章用的。私钥，就是自己的，必须非常小心保存，最好加上 密码，私钥是用来解密/签章，首先就Key的所有权来说，私钥只有个人拥有。公钥与私钥的作用是：用公钥加密的内容只能用私钥解密，用私钥加密的内容只能 用公钥解密。
   比如说，我要给你发送一个加密的邮件。首先，我必须拥有你的公钥，你也必须拥有我的公钥。
   首先，我用你的公钥给这个邮件加密，这样就保证这个邮件不被别人看到，而且保证这个邮件在传送过程中没有被修改。你收到邮件后，用你的私钥就可以解密，就能看到内容。
   其次我用我的私钥给这个邮件加密，发送到你手里后，你可以用我的公钥解密。因为私钥只有我手里有，这样就保证了这个邮件是我发送的。
   当A->B资料时，A会使用B的公钥加密，这样才能确保只有B能解开，否则普罗大众都能解开加密的讯息，就是去了资料的保密性。验证方面则是使用签 验章的机制，A传资料给大家时，会以自己的私钥做签章，如此所有收到讯息的人都可以用A的公钥进行验章，便可确认讯息是由 A 发出来的了。



数字证书的原理

  数字证书采用公钥体制，即利用一对互相匹配的密钥进行加密、解密。每个用户自己设定一把特定的仅为本人所知的私有密钥（私钥），用它进行解密和签名；同时 设定一把公共密钥（公钥）并由本人公开，为一组用户所共享，用于加密和验证签名。当发送一份保密文件时，发送方使用接收方的公钥对数据加密，而接收方则使 用自己的私钥解密，这样信息就可以安全无误地到达目的地了。通过数字的手段保证加密过程是一个不可逆过程,即只有用私有密钥才能解密. 在公开密钥密码体制中，常用的一种是RSA体制。
用户也可以采用自己的私钥对信息加以处理，由于密钥仅为本人所有，这样就产生了别人无法生成的文件，也就形成了数字签名。采用数字签名，能够确认以下两点：
（1）保证信息是由签名者自己签名发送的，签名者不能否认或难以否认；
（2）保证信息自签发后到收到为止未曾作过任何修改，签发的文件是真实文件。

 

 

SSL 是一个安全协议，它提供使用 TCP/IP 的通信应用程序间的隐私与完整性。因特网的 超文本传输协议 （HTTP）使用 SSL 来实现安全的通信。

在客户端与服务器间传输的数据是通过使用对称算法（如 DES 或 RC4）进行加密的。公用密钥算法（通常为 RSA）是用来获得加密密钥交换和数字签名的，此算法使用服务器的SSL数字证书中的公用密钥。有了服务器的SSL数字证书，客户端也可以验证服务器的身 份。SSL 协议的版本 1 和 2 只提供服务器认证。版本 3 添加了客户端认证，此认证同时需要客户端和服务器的数字证书。

**SSL 握手/**

SSL 连接总是由客户端启动的。在SSL 会话开始时执行 SSL 握手。此握手产生会话的密码参数。关于如何处理 SSL 握手的简单概述，如下图所示。此示例假设已在 Web 浏览器 和 Web 服务器间建立了 SSL 连接。

[![img](http://new.51cto.com/files/uploadimg/20090817/1618500.jpg)](http://new.51cto.com/files/uploadimg/20090817/1618500.jpg)

(1) 客户端发送列出客户端密码能力的客户端“您好”消息（以客户端首选项顺序排序），如 SSL 的版本、客户端支持的密码对和客户端支持的数据压缩方法。消息也包含 28 字节的随机数。

(2) 服务器以服务器“您好”消息响应，此消息包含密码方法（密码对）和由服务器选择的数据压缩方法，以及会话标识和另一个随机数。

注意:客户端和服务器至少必须支持一个公共密码对，否则握手失败。服务器一般选择最大的公共密码对。

(3) 服务器发送其SSL数字证书。（服务器使用带有 SSL 的 X.509 V3 数字证书。）

如果服务器使用 SSL V3，而服务器应用程序（如 Web 服务器）需要数字证书进行客户端认证，则客户端会发出“数字证书请求”消息。在 “数字证书请求”消息中，服务器发出支持的客户端数字证书类型的列表和可接受的CA的名称。

(4) 服务器发出服务器“您好完成”消息并等待客户端响应。

(5) 一接到服务器“您好完成”消息，客户端（ Web 浏览器）将验证服务器的SSL数字证书的有效性并检查服务器的“你好”消息参数是否可以接受。

如果服务器请求客户端数字证书，客户端将发送其数字证书；或者，如果没有合适的数字证书是可用的，客户端将发送“没有数字证书”警告。此警告仅仅是警告而已，但如果客户端数字证书认证是强制性的话，服务器应用程序将会使会话失败。

(6) 客户端发送“客户端密钥交换”消息。

此消息包含 pre-master secret （一个用在对称加密密钥生成中的 46 字节的随机数字），和 消息认证代码 （ MAC ）密钥（用服务器的公用密钥加密的）。

如果客户端发送客户端数字证书给服务器，客户端将发出签有客户端的专用密钥的“数字证书验证”消息。通过验证此消息的签名，服务器可以显示验证客户端数字证书的所有权。

注意: 如果服务器没有属于数字证书的专用密钥，它将无法解密 pre-master 密码，也无法创建对称加密算法的正确密钥，且握手将失败。

(7) 客户端使用一系列加密运算将 pre-master secret 转化为 master secret ，其中将派生出所有用于加密和消息认证的密钥。然后，客户端发出“更改密码规范” 消息将服务器转换为新协商的密码对。客户端发出的下一个消息（“未完成”的消息）为用此密码方法和密钥加密的第一条消息。

(8) 服务器以自己的“更改密码规范”和“已完成”消息响应。

(9) SSL 握手结束，且可以发送加密的应用程序数据。





SSL单向双向认证

单向认证：客户端向服务器发送消息，服务器接到消息后，用服务器端的密钥库中的私钥对数据进行加密，然后把加密后的数据和服务器端的公钥一起发送到客户端，客户端用服务器发送来的公钥对数据解密，然后在用传到客户端的服务器公钥对数据加密传给服务器端，服务器用私钥对数据进行解密，这就完成了客户端和服务器之间通信的安全问题，但是单向认证没有验证客户端的合法性。

双向认证：客户端向服务器发送消息，首先把消息用客户端证书加密然后连同时把客户端证书一起发送到服务器端，服务器接到消息后用首先用客户端证书把消息解密，然后用服务器私钥把消息加密，把服务器证书和消息一起发送到客户端，客户端用发来的服务器证书对消息进行解密，然后用服务器的证书对消息加密，然后在用客户端的证书对消息在进行一次加密，连同加密消息和客户端证书一起发送到服务器端，到服务器端首先用客户端传来的证书对消息进行解密，确保消息是这个客户发来的，然后用服务器端的私钥对消息在进行解密这个便得到了明文数据。





关键词：SSL，PKI，MAC

摘  要：SSL利用数据加密、身份验证和消息完整性验证机制，为基于TCP等可靠连接的应用层协议提供安全性保证。本文介绍了SSL的产生背景、安全机制、工作过程及典型组网应用。

缩略语：

| 缩略语 | 英文全名                           | 中文解释             |
| ------ | ---------------------------------- | -------------------- |
| AES    | Advanced Encryption Standard       | 高级加密标准         |
| CA     | Certificate Authority              | 证书机构             |
| DES    | Data Encryption Standard           | 数据加密标准         |
| HTTPS  | Hypertext Transfer Protocol Secure | 安全超文本传输协议   |
| MAC    | Message Authentication Code        | 消息验证码           |
| MD5    | Message Digest 5                   | 消息摘要算法5        |
| PKI    | Public Key Infrastructure          | 公钥基础设施         |
| RSA    | Rivest Shamir and Adleman          | 非对称密钥算法的一种 |
| SHA    | Secure Hash Algorithm              | 安全散列算法         |
| SSL    | Secure Sockets Layer               | 安全套接层           |
| VPN    | Virtual Private Network            | 虚拟专有网络         |

 




# 1 概述

## 1.1 产生背景

基于万维网的电子商务和网上银行等新兴应用，极大地方便了人们的日常生活，受到人们的青睐。由于这些应用都需要在网络上进行在线交易，它们对网络通信的安全性提出了更高的要求。传统的万维网协议HTTP不具备安全机制——采用明文的形式传输数据、不能验证通信双方的身份、无法防止传输的数据被篡改等，导致HTTP无法满足电子商务和网上银行等应用的安全性要求。

Netscape公司提出的安全协议SSL，利用数据加密、身份验证和消息完整性验证机制，为网络上数据的传输提供安全性保证。SSL可以为HTTP提供安全连接，从而很大程度上改善了万维网的安全性问题。

## 1.2 技术优点

SSL具有如下优点：

l       提供较高的安全性保证。SSL利用数据加密、身份验证和消息完整性验证机制，保证网络上数据传输的安全性。

l       支持各种应用层协议。虽然SSL设计的初衷是为了解决万维网安全性问题，但是由于SSL位于应用层和传输层之间，它可以为任何基于TCP等可靠连接的应用层协议提供安全性保证。

l       部署简单。目前SSL已经成为网络中用来鉴别网站和网页浏览者身份，在浏览器使用者及Web服务器之间进行加密通信的全球化标准。SSL协议已被集成到大部分的浏览器中，如IE、Netscape、Firefox等。这就意味着几乎任意一台装有浏览器的计算机都支持SSL连接，不需要安装额外的客户端软件。

# 2 协议安全机制

SSL协议实现的安全机制包括：

l       数据传输的机密性：利用对称密钥算法对传输的数据进行加密。

l       身份验证机制：基于证书利用数字签名方法对服务器和客户端进行身份验证，其中客户端的身份验证是可选的。

l       消息完整性验证：消息传输过程中使用MAC算法来检验消息的完整性。

## 2.1 数据传输的机密性

网络上传输的数据很容易被非法用户窃取，SSL采用在通信双方之间建立加密通道的方法保证数据传输的机密性。

所谓加密通道，是指发送方在发送数据前，使用加密算法和加密密钥对数据进行加密，然后将数据发送给对方；接收方接收到数据后，利用解密算法和解密密钥从密文中获取明文。没有解密密钥的第三方，无法将密文恢复为明文，从而保证数据传输的机密性。

加解密算法分为两类：

l       对称密钥算法：数据加密和解密时使用相同的密钥。

l       非对称密钥算法：数据加密和解密时使用不同的密钥，一个是公开的公钥，一个是由用户秘密保存的私钥。利用公钥（或私钥）加密的数据只能用相应的私钥（或公钥）才能解密。

与非对称密钥算法相比，对称密钥算法具有计算速度快的优点，通常用于对大量信息进行加密（如对所有报文加密）；而非对称密钥算法，一般用于数字签名和对较少的信息进行加密。

SSL加密通道上的数据加解密使用对称密钥算法，目前主要支持的算法有DES、3DES、AES等，这些算法都可以有效地防止交互数据被窃听。

对称密钥算法要求解密密钥和加密密钥完全一致。因此，利用对称密钥算法加密传输数据之前，需要在通信两端部署相同的密钥。对称密钥的部署方法请参见“2.4 利用非对称密钥算法保证密钥本身的安全”。

## 2.2 身份验证机制

电子商务和网上银行等应用中必须保证要登录的Web服务器是真实的，以免重要信息被非法窃取。SSL利用数字签名来验证通信对端的身份。

非对称密钥算法可以用来实现数字签名。由于通过私钥加密后的数据只能利用对应的公钥进行解密，因此根据解密是否成功，就可以判断发送者的身份，如同发送者对数据进行了“签名”。例如，Alice使用自己的私钥对一段固定的信息加密后发给Bob，Bob利用Alice的公钥解密，如果解密结果与固定信息相同，那么就能够确认信息的发送者为Alice，这个过程就称为数字签名。

SSL客户端必须验证SSL服务器的身份，SSL服务器是否验证SSL客户端的身份，则由SSL服务器决定。SSL客户端和SSL服务器的身份验证过程，请参见“3.2 SSL握手过程”。

使用数字签名验证身份时，需要确保被验证者的公钥是真实的，否则，非法用户可能会冒充被验证者与验证者通信。如图1所示，Cindy冒充Bob，将自己的公钥发给Alice，并利用自己的私钥计算出签名发送给Alice，Alice利用“Bob”的公钥（实际上为Cindy的公钥）成功验证该签名，则Alice认为Bob的身份验证成功，而实际上与Alice通信的是冒充Bob的Cindy。SSL利用PKI提供的机制保证公钥的真实性，详细介绍请参见“2.5 利用PKI保证公钥的真实性”。

![img](https://tva1.sinaimg.cn/large/0081Kckwly1glq5178qszj309104qt8o.jpg)

图1 伪造公钥

## 2.3 消息完整性验证

为了避免网络中传输的数据被非法篡改，SSL利用基于MD5或SHA的MAC算法来保证消息的完整性。

MAC算法是在密钥参与下的数据摘要算法，能将密钥和任意长度的数据转换为固定长度的数据。利用MAC算法验证消息完整性的过程如图2所示。发送者在密钥的参与下，利用MAC算法计算出消息的MAC值，并将其加在消息之后发送给接收者。接收者利用同样的密钥和MAC算法计算出消息的MAC值，并与接收到的MAC值比较。如果二者相同，则报文没有改变；否则，报文在传输过程中被修改，接收者将丢弃该报文。

![img](https://tva1.sinaimg.cn/large/0081Kckwly1glq515y23tj30dm03zdfp.jpg)

图2 MAC算法示意图

MAC算法具有如下特征，使其能够用来验证消息的完整性：

l       消息的任何改变，都会引起输出的固定长度数据产生变化。通过比较MAC值，可以保证接收者能够发现消息的改变。

l       MAC算法需要密钥的参与，因此没有密钥的非法用户在改变消息的内容后，无法添加正确的MAC值，从而保证非法用户无法随意修改消息内容。

MAC算法要求通信双方具有相同的密钥，否则MAC值验证将会失败。因此，利用MAC算法验证消息完整性之前，需要在通信两端部署相同的密钥。MAC密钥的部署方法请参见“2.4 利用非对称密钥算法保证密钥本身的安全”。

## 2.4 利用非对称密钥算法保证密钥本身的安全

对称密钥算法和MAC算法要求通信双方具有相同的密钥，否则解密或MAC值验证将失败。因此，要建立加密通道或验证消息完整性，必须先在通信双方部署一致的密钥。

SSL利用非对称密钥算法加密密钥的方法实现密钥交换，保证第三方无法获取该密钥。如图3所示，SSL客户端（如Web浏览器）利用SSL服务器（如Web服务器）的公钥加密密钥，将加密后的密钥发送给SSL服务器，只有拥有对应私钥的SSL服务器才能从密文中获取原始的密钥。SSL通常采用RSA算法加密传输密钥。

![img](https://tva1.sinaimg.cn/large/0081Kckwly1glq513iea9j30by038745.jpg)

图3 密钥交换示意图

![img](http://www.h3c.com.cn/res/200812/12/20081212_705430_image004_622834_30003_0.png)

l   实际上，SSL客户端发送给SSL服务器的密钥不能直接用来加密数据或计算MAC值，该密钥是用来计算对称密钥和MAC密钥的信息，称为premaster secret。SSL客户端和SSL服务器利用premaster secret计算出相同的主密钥（master secret），再利用master secret生成用于对称密钥算法、MAC算法等的密钥。premaster secret是计算对称密钥、MAC算法密钥的关键。

l   用来实现密钥交换的算法称为密钥交换算法。非对称密钥算法RSA用于密钥交换时，也可以称之为密钥交换算法。

 

利用非对称密钥算法加密密钥之前，发送者需要获取接收者的公钥，并保证该公钥确实属于接收者，否则，密钥可能会被非法用户窃取。如图1所示，Cindy冒充Bob，将自己的公钥发给Alice，Alice利用Cindy的公钥加密发送给Bob的数据，Bob由于没有对应的私钥无法解密该数据，而Cindy截取数据后，可以利用自己的私钥解密该数据。SSL利用PKI提供的机制保证公钥的真实性，详细介绍请参见“2.5 利用PKI保证公钥的真实性”。

## 2.5 利用PKI保证公钥的真实性

PKI通过数字证书来发布用户的公钥，并提供了验证公钥真实性的机制。数字证书（简称证书）是一个包含用户的公钥及其身份信息的文件，证明了用户与公钥的关联。数字证书由权威机构——CA签发，并由CA保证数字证书的真实性。

SSL客户端把密钥加密传递给SSL服务器之前，SSL服务器需要将从CA获取的证书发送给SSL客户端，SSL客户端通过PKI判断该证书的真实性。如果该证书确实属于SSL服务器，则利用该证书中的公钥加密密钥，发送给SSL服务器。

验证SSL服务器/SSL客户端的身份之前，SSL服务器/SSL客户端需要将从CA获取的证书发送给对端，对端通过PKI判断该证书的真实性。如果该证书确实属于SSL服务器/SSL客户端，则对端利用该证书中的公钥验证SSL服务器/SSL客户端的身份。

# 3 协议工作过程

## 3.1 SSL的分层结构

![img](https://tva1.sinaimg.cn/large/0081Kckwly1glq512jqsrj30bo03at8i.jpg)

图4 SSL协议分层

如图4所示，SSL位于应用层和传输层之间，它可以为任何基于TCP等可靠连接的应用层协议提供安全性保证。SSL协议本身分为两层：

l       上层为SSL握手协议（SSL handshake protocol）、SSL密码变化协议（SSL change cipher spec protocol）和SSL警告协议（SSL alert protocol）；

l       底层为SSL记录协议（SSL record protocol）。

其中：

l       SSL握手协议：是SSL协议非常重要的组成部分，用来协商通信过程中使用的加密套件（加密算法、密钥交换算法和MAC算法等）、在服务器和客户端之间安全地交换密钥、实现服务器和客户端的身份验证。

l       SSL密码变化协议：客户端和服务器端通过密码变化协议通知对端，随后的报文都将使用新协商的加密套件和密钥进行保护和传输。

l       SSL警告协议：用来向通信对端报告告警信息，消息中包含告警的严重级别和描述。

l       SSL记录协议：主要负责对上层的数据（SSL握手协议、SSL密码变化协议、SSL警告协议和应用层协议报文）进行分块、计算并添加MAC值、加密，并把处理后的记录块传输给对端。

## 3.2 SSL握手过程

SSL通过握手过程在客户端和服务器之间协商会话参数，并建立会话。会话包含的主要参数有会话ID、对方的证书、加密套件（密钥交换算法、数据加密算法和MAC算法等）以及主密钥（master secret）。通过SSL会话传输的数据，都将采用该会话的主密钥和加密套件进行加密、计算MAC等处理。

不同情况下，SSL握手过程存在差异。下面将分别描述以下三种情况下的握手过程：

l       只验证服务器的SSL握手过程

l       验证服务器和客户端的SSL握手过程

l       恢复原有会话的SSL握手过程

### 3.2.1 只验证服务器的SSL握手过程

![img](https://tva1.sinaimg.cn/large/0081Kckwly1glq510ocnsj308m091aa3.jpg)

图5 只验证服务器的SSL握手过程

如图5所示，只需要验证SSL服务器身份，不需要验证SSL客户端身份时，SSL的握手过程为：

```
(1)    SSL客户端通过Client Hello消息将它支持的SSL版本、加密算法、密钥交换算法、MAC算法等信息发送给SSL服务器。

(2)    SSL服务器确定本次通信采用的SSL版本和加密套件，并通过Server Hello消息通知给SSL客户端。如果SSL服务器允许SSL客户端在以后的通信中重用本次会话，则SSL服务器会为本次会话分配会话ID，并通过Server Hello消息发送给SSL客户端。

(3)    SSL服务器将携带自己公钥信息的数字证书通过Certificate消息发送给SSL客户端。

(4)    SSL服务器发送Server Hello Done消息，通知SSL客户端版本和加密套件协商结束，开始进行密钥交换。

(5)    SSL客户端验证SSL服务器的证书合法后，利用证书中的公钥加密SSL客户端随机生成的premaster secret，并通过Client Key Exchange消息发送给SSL服务器。

(6)    SSL客户端发送Change Cipher Spec消息，通知SSL服务器后续报文将采用协商好的密钥和加密套件进行加密和MAC计算。

(7)    SSL客户端计算已交互的握手消息（除Change Cipher Spec消息外所有已交互的消息）的Hash值，利用协商好的密钥和加密套件处理Hash值（计算并添加MAC值、加密等），并通过Finished消息发送给SSL服务器。SSL服务器利用同样的方法计算已交互的握手消息的Hash值，并与Finished消息的解密结果比较，如果二者相同，且MAC值验证成功，则证明密钥和加密套件协商成功。

(8)    同样地，SSL服务器发送Change Cipher Spec消息，通知SSL客户端后续报文将采用协商好的密钥和加密套件进行加密和MAC计算。

(9)    SSL服务器计算已交互的握手消息的Hash值，利用协商好的密钥和加密套件处理Hash值（计算并添加MAC值、加密等），并通过Finished消息发送给SSL客户端。SSL客户端利用同样的方法计算已交互的握手消息的Hash值，并与Finished消息的解密结果比较，如果二者相同，且MAC值验证成功，则证明密钥和加密套件协商成功。
```



SSL客户端接收到SSL服务器发送的Finished消息后，如果解密成功，则可以判断SSL服务器是数字证书的拥有者，即SSL服务器身份验证成功，因为只有拥有私钥的SSL服务器才能从Client Key Exchange消息中解密得到premaster secret，从而间接地实现了SSL客户端对SSL服务器的身份验证。

& 说明：

l   Change Cipher Spec消息属于SSL密码变化协议，其他握手过程交互的消息均属于SSL握手协议，统称为SSL握手消息。

l   计算Hash值，指的是利用Hash算法（MD5或SHA）将任意长度的数据转换为固定长度的数据。

 

### 3.2.2 验证服务器和客户端的SSL握手过程

![img](https://tva1.sinaimg.cn/large/0081Kckwly1glq50ycqj3j308m0bkwel.jpg)

图6 验证服务器和客户端的SSL握手过程

SSL客户端的身份验证是可选的，由SSL服务器决定是否验证SSL客户端的身份。如图6中蓝色部分标识的内容所示，如果SSL服务器验证SSL客户端身份，则SSL服务器和SSL客户端除了交互“3.2.1 只验证服务器的SSL握手过程”中的消息协商密钥和加密套件外，还需要进行以下操作：

(1)    SSL服务器发送Certificate Request消息，请求SSL客户端将其证书发送给SSL服务器。

(2)    SSL客户端通过Certificate消息将携带自己公钥的证书发送给SSL服务器。SSL服务器验证该证书的合法性。

(3)    SSL客户端计算已交互的握手消息、主密钥的Hash值，利用自己的私钥对其进行加密，并通过Certificate Verify消息发送给SSL服务器。

(4)    SSL服务器计算已交互的握手消息、主密钥的Hash值，利用SSL客户端证书中的公钥解密Certificate Verify消息，并将解密结果与计算出的Hash值比较。如果二者相同，则SSL客户端身份验证成功。

### 3.2.3 恢复原有会话的SSL握手过程

![img](https://tva1.sinaimg.cn/large/0081Kckwly1glq50wxi8xj308m06jt8o.jpg)

图7 恢复原有会话的SSL握手过程

协商会话参数、建立会话的过程中，需要使用非对称密钥算法来加密密钥、验证通信对端的身份，计算量较大，占用了大量的系统资源。为了简化SSL握手过程，SSL允许重用已经协商过的会话，具体过程为：

(1)    SSL客户端发送Client Hello消息，消息中的会话ID设置为计划重用的会话的ID。

(2)    SSL服务器如果允许重用该会话，则通过在Server Hello消息中设置相同的会话ID来应答。这样，SSL客户端和SSL服务器就可以利用原有会话的密钥和加密套件，不必重新协商。

(3)    SSL客户端发送Change Cipher Spec消息，通知SSL服务器后续报文将采用原有会话的密钥和加密套件进行加密和MAC计算。

(4)    SSL客户端计算已交互的握手消息的Hash值，利用原有会话的密钥和加密套件处理Hash值，并通过Finished消息发送给SSL服务器，以便SSL服务器判断密钥和加密套件是否正确。

(5)    同样地，SSL服务器发送Change Cipher Spec消息，通知SSL客户端后续报文将采用原有会话的密钥和加密套件进行加密和MAC计算。

(6)    SSL服务器计算已交互的握手消息的Hash值，利用原有会话的密钥和加密套件处理Hash值，并通过Finished消息发送给SSL客户端，以便SSL客户端判断密钥和加密套件是否正确。

# 4 典型组网应用

## 4.1 HTTPS

HTTPS是基于SSL安全连接的HTTP协议。HTTPS通过SSL提供的数据加密、身份验证和消息完整性验证等安全机制，为Web访问提供了安全性保证，广泛应用于网上银行、电子商务等领域。

图8为HTTPS在网上银行中的应用。某银行为了方便客户，提供了网上银行业务，客户可以通过访问银行的Web服务器进行帐户查询、转帐等。通过在客户和银行的Web服务器之间建立SSL连接，可以保证客户的信息不被非法窃取。

![img](https://tva1.sinaimg.cn/large/0081Kckwly1glq50voknjj307l05ydfu.jpg)

图8 HTTPS在网上银行中的应用

## 4.2 SSL VPN

SSL VPN是以SSL为基础的VPN技术，利用SSL提供的安全机制，为用户远程访问公司内部网络提供了安全保证。如图9所示，SSL VPN通过在远程接入用户和SSL VPN网关之间建立SSL安全连接，允许用户通过各种Web浏览器，各种网络接入方式，在任何地方远程访问企业网络资源，并能够保证企业网络的安全，保护企业内部信息不被窃取。

![img](https://tva1.sinaimg.cn/large/0081Kckwly1glq50uab74j30c50803yu.jpg)

图9 SSL VPN的典型组网环境

---


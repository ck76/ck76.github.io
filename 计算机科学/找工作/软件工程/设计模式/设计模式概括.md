-  **创建型模式** 
  - [x]  单例模式(Singleton Pattern)
  - [ ]  建造者模式（Builder Pattern）
  - [x]  原型模式（Prototype Pattern）
  - [x]  工厂方法模式（Factory Method Pattern）
  - [x]  抽象工厂模式（Abstract Factory Pattern）
-  **结构型模式** 
  - [x] 适配器模式(Adapter Pattern)
  - [ ] 装饰者模式(Decorator Pattern)
  - [ ] 组合模式(Composite Pattern)
  - [ ] 桥接模式(Bridge Pattern)
  - [ ] 外观模式(Facade Pattern)
  - [ ] 享元模式(Flyweight Pattern)
  - [x] 代理模式(Proxy Pattern)
-  **行为型模式** 
  - [ ]  策略模式(Strategy Pattern)
  - [x]  观察者模式(Observer Pattern)
  - [ ]  迭代器模式(Iterator Pattern)
  - [ ]  命令模式(Command Pattern)
  - [ ]  备忘录模式(Memento Pattern)
  - [ ]  中介者模式(Mediator Pattern)
  - [ ]  解释器模式(Interpreter Pattern)
  - [ ]  访问者模式(Visitor Pattern)
  - [x]  责任链模式(Chain of Responsibility Pattern)
  - [ ]  状态模式(State Pattern)
  - [ ]  模板方法模式(Template Method Pattern)

## 概念

设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。

使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。

​														--------------------------《百度百科》

## 六大原则

| **原则**     | **含义**                                         | **具体方法**                     |
| ------------ | ------------------------------------------------ | -------------------------------- |
| 开闭原则     | 对扩展开放,对修改关闭                            | 多使用抽象类和接口               |
| 里氏代换原则 | 基类可以被子类替换                               | 使用抽象类继承,不使用具体类继承  |
| 依赖倒转原则 | 要依赖于抽象,不要依赖于具体                      | 针对接口编程,不针对实现编程      |
| 接口隔离原则 | 使用多个隔离的接口,比使用单个接口好              | 建立最小的接口                   |
| 迪米特法则   | 一个软件实体应当尽可能少地与其他实体发生相互作用 | 通过中间类建立联系               |
| 合成复用原则 | 尽量使用合成/聚合,而不是使用继承                 | 尽量使用合成/聚合,而不是使用继承 |

**1、开闭原则（Open Close Principle）**

开闭原则的意思是：**对扩展开放，对修改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

**2、里氏代换原则（Liskov Substitution Principle）**

里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，**任何基类可以出现的地方，子类一定可以出现**。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

**3、依赖倒转原则（Dependence Inversion Principle）**

这个原则是开闭原则的基础，具体内容：**针对接口编程，依赖于抽象而不依赖于具体**。

**4、接口隔离原则（Interface Segregation Principle）**

这个原则的意思是：**使用多个隔离的接口，比使用单个接口要好。**它还有另外一个意思是：**降低类之间的耦合度。**由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。

**5、迪米特法则，又称最少知道原则（Demeter Principle）**

最少知道原则是指：**一个实体应当尽量少地与其他实体之间发生相互作用，**使得系统功能模块相对独立。

**6、合成复用原则（Composite Reuse Principle）**

合成复用原则是指：尽量使用**合成/聚合**的方式，而**不是**使用继承。



## 分类

总共分为三类，23种：

- 结构型模式：

  >  这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。

  - 适配器：用来把一个接口转化成另一个接口，如 java.util.Arrays#asList()。
  - 桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC；
  - 组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 Map.putAll，List.addAll、Set.addAll。
  - 装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。
  - 享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。
  - 代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 java.lang.reflect.Proxy

- 创建模式:

  > 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。

  - 抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 java.util.Calendar#getInstance()。
  - 建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。
  - 工厂方法：就是 **一个返*** 回具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。
  - 原型模式：使得类的实例能够生成自身的拷贝、如：java.lang.Object#clone()。
  - 单例模式：全局只有一个实例，如 java.lang.Runtime#getRuntime()。

- 行为模式：

  >  这些设计模式特别关注对象之间的通信。

  - 责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 javax.servlet.Filter#doFilter()。
  - 命令模式：将操作封装到对象内，以便存储，传递和返回，如：java.lang.Runnable。
  - 解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，java.text.Format，java.text.Normalizer。
  - 迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 java.util.Iterator。
  - 中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，java.lang.reflect.Method#invoke()。
  - 空对象模式：如 java.util.Collections#emptyList()。
  - 观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 java.util.EventListener。
  - 模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 java.util.Collections#sort()。

## 常用设计模式及面试问点

- 单例模式：懒汉式、饿汉式、双重校验锁、静态加载，内部类加载、枚举类加载。保证一个类仅有一个实例，并提供一个访问它的全局访问点。
- 代理模式：动态代理和静态代理，什么时候使用动态代理。
- 适配器模式：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
- 装饰者模式：动态给类加功能。
- 观察者模式：有时被称作发布/订阅模式，观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。
- 策略模式：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。
- 外观模式：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
- 命令模式：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。
- 创建者模式：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。
- 抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类



[菜鸟教程-设计模式链接](http://www.runoob.com/design-pattern/design-pattern-tutorial.html)
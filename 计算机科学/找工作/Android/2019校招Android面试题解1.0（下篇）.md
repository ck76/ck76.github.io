**1.3 计算机网络**

- 基础

```
Q：五层协议的体系结构分别是什么？每一层都有哪些协议？
```

> - 技术点：网络模型、协议
> - 思路：分条解释每层名字以及协议
> - 参考回答：
>   - 物理层
>   - 数据链路层：逻辑链路控制LLC、媒体接入控制MAC
>   - 网络层：IP协议、地址解析协议ARP、逆地址解析协议RARP、因特网控制报文协议ICMP
>   - 传输层：传输控制协议TCP、用户数据报协议UDP
>   - 应用层：文件传输协议FTP、远程登录协议TELNET、超文本传输协议HTTP、域名系统DNS、简单邮件协议SMTP、简单网络管理协议SNMP

```
Q：为何有MAC地址还要IP地址？
```

> - 技术点：MAC地址、IP地址
> - 参考回答：
>   - 每台主机在出厂时都有一个唯一的MAC地址，但是IP地址的分配是根据网络的拓朴结构，得以保证路由选择方案建立在网络所处的拓扑位置基础而不是设备制造商的基础上
>   - 使用IP地址更方便数据传输。数据包在这些节点之间的移动都是由ARP协议负责将IP地址映射到MAC地址上来完成的。

- TCP

```
Q：TCP和UDP的区别？
```

> - 技术点：传输层协议对比
> - 参考回答：
>   - TCP传输控制协议：面向连接；使用全双工的可靠信道；提供可靠的服务，即无差错、不丢失、不重复且按序到达；拥塞控制、流量控制、超时重发、丢弃重复数据等等可靠性检测手段；面向字节流；每条TCP连接只能是点到点的；用于传输可靠性要求高的数据
>   - UDP用户数据报协议：无连接；使用不可靠信道；尽最大努力交付，即不保证可靠交付；无拥塞控制等；面向报文；支持一对一、一对多、多对一和多对多的交互通信；用于传输可靠性要求不高的数据

```
Q：拥塞控制和流量控制都是什么，两者的区别？
```

> - 技术点：拥塞控制、流量控制
> - 参考回答：
>   - 拥塞控制：对网络中的路由和链路传输进行速度限制，避免网络过载；包含四个过程：**慢启动、拥塞避免、快重传和快恢复**
>   - 流量控制 ：对点和点/发送方和接收方之间进行速度匹配，由于接收方的应用程序读取速度不一定很迅速，加上缓存有限，因此需要避免发送速度过快；相关技术：TCP滑动窗口、回退N针协议

```
快重传和快恢复
快速重传(Fast retransmit)要求接收方在收到一个【失序的报文段】后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方），而不要等到自己发送数据时捎带确认。
　　快重传算法规定，发送方只要一连收到【3个重复确认】就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计数器时间到期。

快速恢复(Fast Recovery)
（1）当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。
（2）由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。

发送方窗口的上限值 = Min [ rwnd, cwnd ]
当rwnd < cwnd 时，是接收方的接收能力限制发送方窗口的最大值。
当cwnd < rwnd 时，则是网络的拥塞限制发送方窗口的最大
```
![image.png](https://tva1.sinaimg.cn/large/0081Kckwly1glpohhabo4j30j308awih.jpg)
```
Q：谈谈TCP为什么要三次握手？为什么要四次挥手？
```

> - 技术点：TCP可靠保证
>
> - 参考回答：
>
> - （1）建立TCP连接：TCP的三次握手
>
>   ![image-20201208232955153](https://tva1.sinaimg.cn/large/0081Kckwly1glgv93qeptj30y30u0nlc.jpg)
>
>   - 客户端向服务端发送一个表示建立连接的报文段SYN报文段；一旦包含SYN报文段的IP数据报到达服务器主机，服务器从IP数据报中提取出TCP、SYN报文段，为该TCP连接【分配需要的缓存和变量】，并向客户端发送表示允许连接的报文段ACK；在收到ACK报文段之后，【客户端也要给该连接分配缓存和变量】，客户端向服务器再发送一个报文段ACK，表示对允许连接的报文段进行了确认。自此完成一次TCP连接。
>   - 第三次握手可以避免由于客户端延迟的请求连接的请求，使得服务端无故再次建立连接。
>
> - （2）断开TCP连接：TCP的四次挥手
>
>   ![image-20201208233007444](https://tva1.sinaimg.cn/large/0081Kckwly1glgv9b64vlj30zc0q64db.jpg)
>
>   - 由于TCP连接是【全双工的】，因此【每个方向都必须单独关闭】。客户端在数据发送完毕后发送一个结束数据段FIN，且服务端也返回确认数据段ACK，此时结束了客户端到服务端的连接；然后客户端接收到服务端发送的FIN，且服务端也收到了ACK之后，自此双方的数据通信完全结束。简单说来是 “先关读，后关写”，一共需要四个阶段：服务器读通道关闭->客户机写通道关闭->客户机读通道关闭->服务器写通道关闭。
>
> - 引申：谈谈客户端到达的TIME_WAIT状态时间是MaximumSegmentLifetime的两倍，而不是直接进入CLOSED状态的原因。（保证TCP协议的全双工连接能够可靠关闭、保证本次连接的重复数据段从网络中消失）

```
Q：播放视频用TCP还是UDP？为什么？
```

> - 技术点：传输层协议适用场景
> - 参考回答：播放视频适合用UDP。UDP适用于对网络通讯质量要求不高、要求网络通讯速度能尽量快的实时性应用；而TCP适用于对网络通讯质量有要求的可靠性应用。而且视频区分关键帧和普通帧，虽然UDP会丢帧但如果只是丢普通帧损失并不大，取而代之的是高速率和实时性。
> - 引申：TCP、UDP适用的场景

- HTTP

```
Q：了解哪些响应状态码？
```

> - 技术点：响应状态码
> - 思路：
> - 参考回答：状态码由三位数字组成，第一位数字表示响应的类型，常用的状态码有五大类：
>   - 1xx：表示服务器已接收了客户端请求，客户端可继续发送请求
>   - 2xx：表示服务器已成功接收到请求并进行处理
>     - 200 OK：表示客户端请求成功
>   - 3xx：表示服务器要求客户端重定向
>   - 4xx：表示客户端的请求有非法内容
>     - 400 Bad Request：表示客户端请求有语法错误，不能被服务器所理解
>     - 401 Unauthonzed：表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用
>     - 403 Forbidden：表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因
>     - 404 Not Found：请求的资源不存在，例如，输入了错误的URL
>   - 5xx：表示服务器未能正常处理客户端的请求而出现意外错误
>     - 500 Internal Server Error：表示服务器发生不可预期的错误，导致无法完成客户端的请求
>     - 503 Service Unavailable：表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常

```
Q：get和post的区别？
```

> - 技术点：HTTP请求方法
> - 参考回答：
>   - GET：当客户端要从服务器中读取某个资源时使用GET；一般用于获取/查询资源信息；GET参数通过URL传递，传递的参数是有长度限制，不能用来传递敏感信息
>   - POST：当客户端给服务器提供信息较多时可以使用POST；POST会附带用户数据，一般用于更新资源信息；POST将请求参数封装在HTTP 请求数据中，可以传输大量数据，传参方式比GET更安全

```
Q：HTTP1.0、HTTP1.1、HTTP2.0的区别？
```

> - 技术点：HTTP协议发展
> - 参考回答：
> - （1）HTTP1.0和HTTP1.1的区别：
>   - HTTP1.0默认使用短连接，HTTP1.1开始默认使用长连接
>   - HTTP1.1增加更多的请求头和响应头来改进和扩充HTTP1.0的功能，比如身份认证、状态管理和Cache缓存等
> - （2）HTTP2.0和HTTP1.X相比的新特性：
>   - 新的二进制格式：HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮，不同于HTTP1.x的解析是基于文本
>   - 多路复用：连接共享，即每一个request都是是用作连接共享机制的
>   - 服务端推送：服务器主动向客户端推送消息
> - 引申：长连接和短连接的优缺点和适用场景，[HTTP 长连接和短连接](https://www.jianshu.com/p/caeec6bd1d3f)

```
Q：HTTP和TCP的区别
```

> - 技术点：HTTP、TCP
> - 参考回答：
>   - TCP是传输层协议，定义数据传输和连接方式的规范。通过三次握手建立连接、四次挥手释放连接。
>   - HTTP是应用层协议，定义的是传输数据的内容的规范。HTTP的连接使用"请求-响应"方式。基于TCP协议传输，默认端口号是80。

```
Q：HTTP和HTTPS的区别
```

> - 技术点：HTTP、HTTPS
>   - HTTP（超文本传输协议）：运行在TCP之上；传输的内容是明文；端口是80
>   - HTTPS（安全为目标的HTTP）：运行在SSL/TLS之上，SSL/TLS运行在TCP之上；传输的内容经过加密；端口是443

`Q：HTTP和Socket的区别`-

> - 技术点：HTTP、Socket
> - 参考回答：
>   - HTTP是应用层协议；基于TCP协议；使用“请求—响应”方式建立连接，在请求时需要先建立连接且客户端要先发出请求，可见服务器需要等到客户端发送一次请求后才能将数据传回给客户端
>   - Socket（套接字）**【是对TCP/IP协议的封装】，【是接口而不是协议】**；创建Socket连接时可以指定传输层协议TCP或UDP；Socket建立连接过程三步骤：服务器监听->客户端请求->连接确认，可见服务器可以直接将数据传送给客户端（HTTP2.0也增加了服务端推送的功能）

```
Q：在地址栏打入URL会发生什么？
```

> - 技术点：理解网络模型
> - 参考回答：在浏览器地址栏键入URL，按下回车之后会经历以下流程：
>   - 浏览器向DNS服务器请求解析该URL中的域名所对应的IP地址
>   - 解析出IP地址后，根据该IP地址和默认端口80，和服务器建立TCP连接
>   - 浏览器发出读取文件的HTTP请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器
>   - 服务器对浏览器请求作出响应，并把对应的html文本发送给浏览器
>   - 释放TCP连接，若**【connection模式】**为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接；若connection模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求
>   - 客户端将服务器响应的html文本解析并显示

**1.4 JVM**

```
Q：JVM内存是如何划分的？
```

> - 技术点：JVM内存管理
>
> - 思路：分条解释每部分内存的作用，详见[要点提炼| 理解JVM之内存管理](https://www.jianshu.com/p/cd93567ed868)
>
> - 参考回答：JVM会用一段空间来存储执行程序期间需要用到的数据和相关信息，这段空间就是
>
>   运行时数据区（Runtime Data Area）
>
>   ，也就是常说的JVM内存。JVM会将它所管理的内存划分为
>
>   线程私有数据区
>
>   和
>
>   线程共享数据区
>
>   两大类：
>
>   - 线程私有数据区包含：
>     - 程序计数器：是**当前线程**所执行的字节码的行号指示器
>     - 虚拟机栈：是**Java方法**执行的内存模型
>     - 本地方法栈：是虚拟机使用到的**Native方法**服务
>   - 线程共享数据区包含：
>     - Java堆：用于存放几乎所有的对象实例和数组；是垃圾收集器管理的主要区域，也被称做“GC堆”；是Java虚拟机所管理的内存中最大的一块
>     - 方法区：用于存储已被虚拟机加载的**类信息、常量、静态变量、即时编译器编译后的代码等数据**；Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是**常量池（Constant Pool Table）**，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放
>
> - 引申：谈谈JVM的堆和栈差别

```
Q：谈谈垃圾回收机制？为什么引用计数器判定对象是否回收不可行？知道哪些垃圾回收算法？
```

> - 技术点：垃圾回收机制
>
> - 思路：从如何判定对象可回收、如果回收具体算法这两方面展开谈垃圾回收机制，详见[要点提炼| 理解JVM之GC](https://www.jianshu.com/p/a62697f00b85)
>
> - 参考回答：
>
> - （1）判定对象可回收有两种方法：
>
>   - **引用计数算法**：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。然而在主流的Java虚拟机里未选用引用计数算法来管理内存，主要原因是它难以解决对象之间**相互循环引用**的问题，所以出现了另一种对象存活判定算法。
>   - **可达性分析法**：通过一系列被称为『GC Roots』的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为**引用链**，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。其中可作为GC Roots的对象：虚拟机栈中引用的对象，主要是指栈帧中的**本地变量**、本地方法栈中**Native方法**引用的对象、方法区中**类静态属性**引用的对象、方法区中**常量**引用的对象
>
> - （2）回收算法有以下四种：
>
>   - 分代收集算法
>
>     ：是当前商业虚拟机都采用的一种算法，根据对象存活周期的不同，将Java堆划分为新生代和老年代，并根据各个年代的特点采用最适当的收集算法。
>
>     - 新生代：**大批对象死去，只有少量存活**。使用『复制算法』，只需复制少量存活对象即可。
>       - **复制算法**：把可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用尽后，把还存活着的对象『复制』到另外一块上面，再将这一块内存空间一次清理掉。
>     - 老年代：对象存活率高。使用『**标记—清理算法**』或者『**标记—整理算法**』，只需标记较少的回收对象即可。
>       - **标记-清除算法**：首先『标记』出所有需要回收的对象，然后统一『清除』所有被标记的对象。
>       - **标记-整理算法**：首先『标记』出所有需要回收的对象，然后进行『整理』，**使得存活的对象都向一端移动**，最后直接清理掉端边界以外的内存。
>
> - 引申：谈谈每种回收算法的优缺点

```
Q：Java中引用有几种类型？在Android中常用于什么情景？
```

> - 技术点：Java引用类型
> - 思路：分条解释每种类型的特点和适用场景，详见[要点提炼| 理解JVM之GC](https://www.jianshu.com/p/a62697f00b85)
> - 参考回答：引用的四种类型
>   - **强引用**（StrongReference）：具有强引用的**对象不会被GC**；即便内存空间不足，JVM宁愿抛出OutOfMemoryError使程序异常终止，也不会随意回收具有强引用的对象。
>   - **软引用**（SoftReference）：只具有软引用的对象，会在**内存空间不足的时候**被GC；软引用常用来实现内存敏感的高速**缓存**。
>   - **弱引用**（WeakReference）：只被弱引用关联的对象，**无论当前内存是否足够都会被GC**；强度比软引用更弱，常用于描述**非必需**对象；常用于解决内存泄漏的问题
>   - **虚引用**（PhantomReference）：仅持有虚引用的对象，**在任何时候都可能被GC**；常用于跟踪对象被GC回收的活动；必须和**引用队列** （ReferenceQueue）联合使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。

```
Q：类加载的全过程是怎样的？什么是双亲委派模型？
```

> - 技术点：类加载机制、双亲委派模型
>
> - 思路：类加载机制的含义以及每个阶段的作用，在解释双亲委派模型之前需要先理解类加载器，详见[要点提炼| 理解JVM之类加载机制](https://www.jianshu.com/p/9ea809edebb6)
>
> - 参考回答：
>
> - （1）类加载机制：是虚拟机把描述类的数据从Class文件
>
>   加载
>
>   到内存，并对数据进行
>
>   校验
>
>   、
>
>   转换解析
>
>   和
>
>   初始化
>
>   ，最终形成可被虚拟机直接使用的Java类型的过程。另外，类型的加载、连接和初始化过程都是在程序
>
>   运行期
>
>   完成的，从而通过牺牲一些性能开销来换取Java程序的高度灵活性。下面介绍类加载每个阶段的任务：
>
>   - **加载**（Loading）：通过类的全限定名来获取定义此类的**二进制字节流**；将该二进制字节流所代表的**静态存储结构**转化为方法区的**运行时数据结构**，该数据存储数据结构由虚拟机实现自行定义；在内存中生成一个代表这个类的java.lang.Class对象，它将作为程序访问方法区中的这些类型数据的外部接口
>   - **验证**（Verification）：确保Class文件的字节流中包含的信息符合当前虚拟机的要求，包括文件格式验证、元数据验证、字节码验证和符号引用验证
>   - **准备**（Preparation）：为类变量**分配内存**，因为这里的变量是由方法区分配内存的，所以仅包括类变量而不包括实例变量，后者将会在对象实例化时随着对象一起分配在Java堆中；设置类变量**初始值**，通常情况下零值
>   - **解析**（Resolution）：虚拟机将**常量池**内的符号引用替换为直接引用的过程
>   - **初始化**（Initialization）：是类加载过程的最后一步，会开始真正执行类中定义的Java字节码。而之前的类加载过程中，除了在『加载』阶段用户应用程序可通过自定义类加载器参与之外，其余阶段均由虚拟机主导和控制
>
> - （2）类加载器：不仅用于加载类，还和这个类本身一起作为在JVM中的唯一标识。常见类加载器类型有：
>
>   - 启动类加载器：是虚拟机自身的一部分
>   - 扩展类加载器、应用程序类加载器、自定义类加载器：独立于虚拟机外部
>
> - （3）**双亲委派模型**：表示类加载器之间的层次关系。
>
>   - **前提**：除了顶层启动类加载器外，其余类加载器都应当有自己的父类加载器，且它们之间关系一般不会以**继承**（Inheritance）关系来实现，而是通过**组合**（Composition）关系来复用父加载器的代码。
>   - **工作过程**：若一个类加载器收到了类加载的请求，它先会把这个请求**委派**给父类加载器，并向上传递，最终请求都传送到顶层的启动类加载器中。只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。

```
Q：工作内存和主内存的关系？在Java内存模型有哪些可以保证并发过程的原子性、可见性和有序性的措施？
```

> - 技术点：JVM内存模型、线程安全
>
> - 思路：理解Java内存模型的结构、详见[要点提炼| 理解JVM之内存模型&线程](https://www.jianshu.com/p/90a036212cb4)
>
> - 参考回答：Java内存模型就是通过定义程序中各个
>
>   变量
>
>   的
>
>   访问规则
>
>   ，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。
>
>   - ![image-20201208233028941](https://tva1.sinaimg.cn/large/0081Kckwly1glgv9pisjaj30yq0fyafs.jpg)
>
>     其中 ，
>
>     主内存
>
>     （Main   Memory）是所有变量的存储位置，每条线程还有自己的
>
>     工作内存
>
>     ，用于保存被该线程使用到的变量的主内存副本拷贝。为了获取更好的运行速度，虚拟机可能会让工作内存优先存储于寄存器和高速缓存中。
>
>   - 保证并发过程的原子性、可见性和有序性的措施：
>
>     - 原子性
>
>       （Atomicity）：**一个操作要么都执行要么都不执行。**
>
>       - 可直接保证的原子性变量操作有：`read`、`load`、`assign`、`use`、`store`和`write`，因此可认为基本数据类型的访问读写是具备原子性的。
>       - 若需要保证更大范围的原子性，可通过**更高层次的字节码指令**`monitorenter`和`monitorexit`来隐式地使用`lock`和`unlock`这两个操作，反映到Java代码中就是同步代码块`synchronized`关键字。
>
>     - 可见性
>
>       （Visibility）：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。
>
>       - **通过在变量修改后将新值同步回主内存**，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现。
>       - 提供三个关键字保证可见性：`volatile`能保证新值能**立即**同步到主内存，且每次使用前立即从主内存刷新；`synchronized`对一个变量执行unlock操作之前可以先把此变量同步回主内存中；被`final`修饰的字段在构造器中一旦初始化完成且构造器没有把`this`的引用传递出去，就可以在其他线程中就能看见final字段的值。
>
>     - 有序性
>
>       （Ordering）：程序代码按照指令顺序执行。
>
>       - 如果在本线程内观察，所有的操作都是有序的，指“线程内表现为串行的语义”；如果在一个线程中观察另一个线程，所有的操作都是无序的，指“指令重排序”现象和“工作内存与主内存同步延迟”现象。
>       - 提供两个关键字保证有序性：`volatile` 本身就包含了禁止指令重排序的语义；`synchronized`保证一个变量在同一个时刻只允许一条线程对其进行lock操作，使得持有同一个锁的两个同步块只能串行地进入。

```
Q：JVM、Dalvik、ART的区别？
```

> - 技术点：虚拟机对比
>
> - 思路：分别谈谈JVM和Dalvik、Dalvik和ART的区别，详见[Jvm、Dalvik和Art的区别](https://www.jianshu.com/p/59d98244fb52)
>
> - 参考回答：
>
>   - 
>
>     
>
>     Dalvik ：是Google公司自己设计用于Android平台的Java虚拟机，不是Java虚拟机，没有遵循Java虚拟机规范，具体区别如下图：
>
>     ![image-20201208233046234](https://tva1.sinaimg.cn/large/0081Kckwly1glgv9zmdekj31lr0u04qq.jpg)
>
>   - ART：代替Dalvik，应用无需每次运行都要先编译，而是在安装时就**预编译**字节码到机器语言，提升运行时效率；预先编译也使得ART占用空间比Dalvik大，即用空间换时间；由于减少运行时重复编译，可明显改善电池续航，降低了能耗。

```
Q：Java中堆和栈的区别？
```

> - 技术点：内存管理
> - 思路：从存放数据和内存回收角度出发
> - 参考回答： 在java中，堆和栈都是内存中存放数据的地方，具题区别是：
>   - 栈内存：主要用来存放**基本数据类型**和**局部变量**；当在代码块定义一个变量时会在栈中为这个变量分配内存空间，当超过变量的作用域后这块空间就会被自动释放掉。
>   - 堆内存：用来存放**运行时创建的对象**，比如通过new关键字创建出来的对象和数组；需要由Java虚拟机的自动垃圾回收器来管理。

**1.5 操作系统**

```
Q：操作系统中进程和线程的区别？
```

> - 技术点：进程、线程
> - 参考回答：
>   - 进程是操作系统分配和管理资源的单位，线程是CPU调度和管理的单位，是CPU调度的最小单元
>   - 进程拥有独立的地址空间，而线程间共享地址空间
>   - 进程创建的开销比较大，线程创建的开销小
> - 引申：可谈谈安卓系统中对进程和线程的理解

```
Q：进程死锁的产生和避免?
```

> - 技术点：死锁
> - 思路：可从死锁含义、产生条件、解决办法、避免手段出发
> - 参考回答：死锁是指多个进程因循环等待资源而造成无法执行的现象，它会造成进程无法执行，同时会造成系统资源的极大浪费。
>   - 死锁产生的条件：
>     - 互斥使用：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
>     - 不可抢占：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
>     - 请求和保持：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
>     - 循环等待：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。
>   - 解决死锁的策略：
>     - **银行家算法：判断此次请求是否造成死锁若会造成死锁，否则拒绝该请求**
>     - 鸵鸟算法：忽略该问题，常用于在极少发生死锁的的情况
>   - 死锁的避免：通过合理的资源分配算法来确保永远不会形成环形等待的封闭进程链，即“如果一个进程的当前请求的资源会导致死锁，系统拒绝启动该进程；如果一个资源的分配会导致下一步的死锁，系统就拒绝本次的分配”

**1.6 数据结构&算法**

```
Q：怎么理解数据结构？`
 `Q：什么是斐波那契数列？`
 `Q：迭代和递归的特点，并比较优缺点`
 `Q：了解哪些查找算法，时间复杂度都是多少？`
 `Q：了解哪些排序算法，并比较一下，以及适用场景`
 `Q：快排的基本思路是什么？最差的时间复杂度是多少？如何优化？`
 `Q：AVL树插入或删除一个节点的过程是怎样的？`
 `Q：什么是红黑树？`
 `Q：100盏灯问题`
 `Q：老鼠和毒药问题，加个条件，必须要求第二天出结果`
 `Q：海量数据问题`
 `Q：（手写算法）二分查找`
 `Q：（手写算法）反转链表`
 `Q：（手写算法）用两个栈实现队列`
 `Q：（手写算法）多线程轮流打印问题`
 `Q：（手写算法）如何判断一个链有环/两条链交叉`
 `Q：（手写算法）快速从一组无序数中找到第k大的数/前k个大的数`
 `Q：（手写算法）最长（不）重复子串
```

> - 技术点：数据结构、手写算法
> - 思路：篇幅问题，该部分将单独做一篇总结

**1.7 设计模式**

```
Q：谈谈MVC、MVP和MVVM，好在哪里，不好在哪里？
```

> - 技术点：MVC、MVP、MVVM
>
> - 思路：详见[MVP、MVVM模式](https://www.jianshu.com/p/e0867ac2a261)
>
> - 参考回答：
>
>   - MVP的含义：
>
>     - **Model**：数据层，负责存储、检索、操纵数据。
>     - **View：UI**层，显示数据，并向Presenter报告用户行为。
>     - **Presenter**：作为View与Model交互的中间纽带，从Model拿数据，应用到UI层，管理UI的状态，响应用户的行为。
>
>   - MVP相比于MVC的
>
>     优势
>
>     - 分离了视图逻辑和业务逻辑，降低了耦合。
>- Activity只处理生命周期的任务，代码变得更加**简洁**。
>     - 视图逻辑和业务逻辑分别抽象到了View和Presenter的**接口**中去，提高代码的可阅读性。
>     - Presenter被抽象成接口，可以有多种具体的实现，所以方便进行**单元测试**。
>     - 把业务逻辑抽到Presenter中去，避免后台线程引用着Activity导致Activity的资源无法被系统回收从而引起**内存泄露**和OOM。
>     
>   - MVVM的含义：与MVP类似，利用**数据绑定**(Data Binding)、**依赖属性**(Dependency Property)、**命令**(Command)、**路由事件**(Routed Event)等新特性，打造了一个更加灵活高效的架构。
>
>   - MVVM相比于MVP的**优势**：在常规的开发模式中，数据变化需要更新UI的时候，需要先获取UI控件的引用，然后再更新UI，获取用户的输入和操作也需要通过UI控件的引用，但在MVVM中，这些都是通过**数据驱动**来自动完成的，数据变化后会自动更新UI，UI的改变也能自动反馈到数据层，数据成为主导因素。这样MVVM层在业务逻辑处理中只要关心数据，不需要直接和UI打交道，在业务处理过程中简单方便很多。

```
Q：如何理解生产者消费者模型？
```

> - 技术点：生产者消费者模型
> - 参考回答：生产者消费者模型通过一个缓存队列，既解决了生产者和消费者之间强耦合的问题，又平衡了生产者和消费者的处理能力。
>   - 具体规则：生产者只在缓存区未满时进行生产，缓存区满时生产者进程被阻塞；消费者只在缓存区非空时进行消费，缓存区为空时消费者进程被阻塞；当消费者发现缓存区为空时会通知生产者生产；当生产者发现缓存区满时会通知消费者消费。
>   - 实现关键：synchronized保证对象只能被一个线程占用；wait()让当前线程进入等待状态，并释放它所持有的锁；notify()&notifyAll()唤醒一个（所有）正处于等待状态的线程

```
Q：是否能从Android中举几个例子说说用到了什么设计模式？
```

> - 技术点：设计模式
> - 参考回答：
>   - View事件分发：责任链模式
>   - BitmapFactory加载图片：工厂模式
>   - Adapter：适配器模式
>   - Builder：建造者模式
>   - Adapter.notifyDataSetChanged()：观察者模式
>   - Binder机制：代理模式

```
Q：装饰模式和代理模式有哪些区别？
```

> - 技术点：装饰模式、代理模式
> - 参考回答：
>   - 使用目的不同：代理模式是给目标对象提供一个代理对象，并由代理对象控制对目标对象的引用；装饰模式是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能
>   - 构造不同：代理模式内部保持对目标对象的引用；装饰模式是通过构造函数传参的方式得到目标对象

```
Q：实现单例模式有几种方法？懒汉式中双层锁的目的是什么？两次判空的目的又是什么？
```

> - 技术点：单例模式
> - 参考回答：实现单例模式常见的两种方式：
>    （1）懒汉式：延迟加载，同时也要保证多线程环境下会产生多个single对象（DCL）



```java
public class Singleton {

    private Singleton() {}
    private volatile static Singleton instance;//第一层锁：保证变量可见性

    public static Singleton getInstance() {
        if (single == null) {//第一次判空：无需每次都加锁，提高性能
            synchronized (Singleton.class) {//第二层锁：保证线程同步
                if (single == null) {//第二次判空:避免多线程同时执行getInstance()产生多个single对象
                    single = new Singleton();
                }
            }
        }
        return single;
    }
}
```

> （2）饿汉式：在类加载初始化时就创建好一个静态的对象供外部使用

```java
public class Singleton {

    private Singleton() {}
    private static Singleton single = new Singleton();

    public static Singleton getInstance() {
        return single;
    }
}
Q：谈谈了解的设计模式原则？
```

> - 技术点：设计模式原则
> - 参考回答：
>   - 单一职责原则：一个类只负责一个功能领域中的相应职责
>   - 开放封闭原则：对扩展开放，对修改关闭
>   - 依赖倒置原则：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程
>   - 迪米特法则：应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用
>   - 合成/聚合复用原则：要尽量使用合成/聚合，尽量不要使用继承

**1.8 数据库**

```
Q：数据库中的事务了解吗？事务的四大特性？
```

> - 技术点：事务
> - 参考回答：
>   - 事务是并发控制的单位，是用户定义的一个操作序列。它指这些操作要么都做，要么都不做，以便服务器保持数据的完整性。
>   - 事务通常是以BEGIN TRANSACTION开始，以COMMIT或ROLLBACK结束。
>   - 事务的四大特性（ACID特性）：
>   - 原子性（Atomicity）表示事务中包括的诸操作要么全做，要么全不做；
>   - 一致性（Consistency）表示事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态；
>   - 隔离性（Isolation）表示一个事务的执行不能被其他事务干扰；
>   - 持续性（Durability）表示一个事务一旦提交，它对数据库中数据的改变就应该是永久性的
> - 引申：谈谈[数据库事务的并发控制](https://www.jianshu.com/p/478c6dca1b74)

```
Q：如何理解数据库的范式？
```

> - 技术点：范式
> - 思路：详见实例讲解[数据库的3大范式和5大约束](https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fqq_33862644%2Farticle%2Fdetails%2F79692652)
> - 参考回答：
>   - 第一范式（1NF）：数据表中的每个字段必须是不可拆分的最小单元，即确保每一列的原子性
>   - 第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系
>   - 第三范式（3NF）：必须先满足第二范式，要求表中的每一列只与主键直接相关而不是间接相关，即表中的每一列只能依赖于主键

**1.9 hr问题**

```
Q：请简单的自我介绍一下
```

> - 可能意图：开场白；短期内快速了解候选人情况；考察表达能力和逻辑思维；是否有备而来；第一印象
> - 思路：说亮点、语言精炼、熟练回答

```
Q：谈谈项目经历，为什么会做，怎么做的，遇到的难点？`
 `Q：谈谈实习经历，做了什么，收获有哪些？`
 `Q：谈谈学习Android的经历，有哪些学习方法和技巧？`
 `Q：成绩怎么样？奖学金情况?`
 `Q：学过哪些课程？那门课印象最深刻/最有意义/学的最好/最不喜欢？为什么？`
 `Q：学习生活中遇到什么挫折，如何解决的？`
 `Q：家是哪里的？是独生子女吗？从小的家庭环境如何？`
 `Q：平常有哪些兴趣爱好？大学参加了哪些校园活动？`
 `Q：评价一下自己的优缺点？/用x个词形容你自己。/别人都是怎样评价你的？`
 `Q：觉得自己博客写的最好的文章是什么？为什么？`
 `Q：觉得自己的优势是什么？
```

> - 可能意图：了解候选人的性格、各方面特质，是否符合企业价值观；了解其沟通表达能力、学习能力等才能，是否具有可塑性
> - 思路：结合具体实例体现自己确是企业想要的人才

```
Q：是否会考研？/为何不保研？`
 `Q：近x年的职业规划？`
 `Q：为什么想来我们公司？/为何不转正留在xx?`
 `Q：对公司/部门是否有了解？`
 `Q：为何会选择做技术？/对女生做开发的看法？`
 `Q：还投过那些公司，进展如何？如果xx和xx都给你发offer会如何选择？`
 `Q：有男/女朋友吗？未来有什么规划？`
 `Q：如何看待加班？`
 `Q：意向工作城市是哪？/是否会考虑在xx发展?`
 `Q：对于薪酬有什么想法？
```

> - 可能意图：了解候选人对企业的意向度和忠诚度，是否值得给发offer
> - 思路：表现出想去该公司的态度、并已为之做了准备

```
Q：有什么问题想要问我？
```

> - 可能意图：结束语；主动权交由候选人
> - 思路：咨询和岗位&部门&公司发展相关的情况、探讨对某技术的看法、询问面试官对你的评价、寻求学习等方面的建议、了解后续面试流程和进度；**注意**，避免问薪资和加班问题、也不要直接说“没有问题”

**1.10 项目相关、实习相关技术问题（略）**

```
Q：使用那些版本控制工具？Git和SVN的区别？
```

> - 技术点：版本控制工具
> - 参考回答：Git和SVN的区别有以下几点：
>   - Git是分布式的，而SVN是集中式的（核心区别）
>   - Git按元数据方式存储内容，而SVN按文件存储内容
>   - 在Git上每个工作成员可以任意在自己的本地版本库开启无限个分支且互不影响，而对于SVN分支是一个完整的目录且这个目录拥有完整的实际文件
>   - Git没有一个全局的版本号，而SVN有
>   - Git 的内容完整性要优于SVN
>   - 在Git中的绝大多数操作都只需要访问本地文件和资源，不必联网就可以看到所有的历史版本记录，而SVN 却需要联网
> - 引申：谈谈两种版本控制工具的优缺点：[SVN与GIT的优缺点对比](https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fu013594477%2Farticle%2Fdetails%2F80828842)

```
Q：了解Git工具吗？用过哪些命令？解决冲突时git merge和git rebase的区别？
```

> - 技术点：版本控制工具Git
>
> - 思路：通过图记忆Git常用命令，详见[Git、GitHub、Stash](https://www.jianshu.com/p/e0867ac2a261)
>
> - 参考回答： 常用命令见图，源自
>
>   一篇文章，教你学会Git
>
>   ![image-20201208233108652](https://tva1.sinaimg.cn/large/0081Kckwly1glgvadv6rij30z60amwid.jpg)
>
>   合并用到的命令git merge与git rebase的区别是，git merge会生成一个新的节点，并将之前的提交分开显示；git rebase操作不会生成新的节点，而是将两个分支融合成一个线性的提交。

（持续更新...）

------

**2.彩蛋时刻**

> 之前因一篇总结文获得各路大佬的喜爱，很是受宠若惊，更有前辈愿与小白我切磋交流，实在不敢当。深知自己才疏学浅，还需再接再厉，以下都是个人拙见，如有不当，还请包涵。

```
Q：有关个人背景
```

之前有简单介绍过，这里再具体下，更加深刻意识到自己的菜orz。我妹子一只，现在大连理工大学读大四，明年毕业，专业是信息管理与信息系统，属于管理学院，由于非科班，少学一些专业课，尤其算法很渣。

很多人好奇为什么一个妹子选择做开发，其实是学长带坑的hhh，当然我还会坚持把这个坑挖的更深，至少做技术是一定的，毕竟对此还是饶有兴趣。但随着技术的日新月异，将来在哪条路上继续另当别论了。

------

```
Q：有关学习经历/推荐书目/面试准备
```

这部分内容详见春招总结：[2018Android暑期实习面试总结](https://www.jianshu.com/p/eb570935d586)。

关于校招面试多做些补充，主要是常常听到一些同学会埋怨，“**为何笔试多少多少AC却没面试通知？**”、“**为何面试问题基本都回答上来却不通过？**”。

对于前一个问题强调很多次，笔试成绩只作参考，面试官还会综合简历去决定是否愿意对你发起面试，因此简历的作用不言而喻。好简历的几个必备点：**排版美观、重点突出、语言精炼、一页纸、充分展示个人亮点**（博客&Github、学历&成绩&实验室、实习&项目、竞赛&论文&荣誉奖励......）。如果说不清楚实习&项目的情况，建议分条列举出重要的技术点（+影响力）。

对于后一个问题，可能的原因有：**硬实力足够但是软实力欠缺**，是否有良好的沟通表达能力、积极向上的性格、端正的学习态度等等；再就是**缺少一点运气**，除了客观因素比如岗位竞争激烈、候选者又很厉害、岗位hc还少，再就是眼缘等主观感受。

所以不得不说我能有好成绩真的很走运，今年校招不少厂子缺移动端简历，反而算法岗过热，相对竞争小机会大；加上快人一步，提前上车，抢先夺个好印象。

再多说一句，之前的总结文针对的都是**校招面试**，可见侧重于基础；而**社招面试**大多针对有工作经验的求职者，更偏向项目&场景、考察工程思维，侧重点会稍有不同，当然还是因面试官而异了。

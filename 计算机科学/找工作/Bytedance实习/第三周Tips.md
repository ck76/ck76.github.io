- [持续交付(CI)](https://zh.wikipedia.org/wiki/%E6%8C%81%E7%BA%8C%E6%95%B4%E5%90%88)
  
  - **持续集成**（英语：Continuous integration，缩写CI），又译为**持续集成**，是一种[软件工程](https://zh.wikipedia.org/wiki/軟體工程)流程，是将所有[软件工程师](https://zh.wikipedia.org/wiki/軟件工程師)对于软件的工作副本持续集成到共享主线（mainline）的一种举措。该名称最早由[[1\]](https://zh.wikipedia.org/wiki/持續整合#cite_note-1)[葛来迪·布区](https://zh.wikipedia.org/wiki/葛來迪·布區)（Grady Booch）在他的[布区方法](https://zh.wikipedia.org/w/index.php?title=布區方法&action=edit&redlink=1)[[2\]](https://zh.wikipedia.org/wiki/持續整合#cite_note-2)中提出，不过他并不支持在一天中进行数次集成。之后该举措成为[极限编程](https://zh.wikipedia.org/wiki/极限编程)（extreme programming）的一部分时，其中建议每天应集成超过一次，甚至达到数十次。[[3\]](https://zh.wikipedia.org/wiki/持續整合#cite_note-3)在[测试驱动开发](https://zh.wikipedia.org/wiki/测试驱动开发)（TDD）的作法中，通常还会搭配自动[单元测试](https://zh.wikipedia.org/wiki/单元测试)。持续集成的提出主要是为解决软件进行[系统集成](https://zh.wikipedia.org/wiki/系統整合)时面临的各项问题，[极限编程](https://zh.wikipedia.org/wiki/极限编程)称这些问题为集成地狱（integration hell）。
  
- **敏捷开发**

  - **敏捷软件开发**（英语：Agile software development），又称**敏捷开发**，是一种从1990年代开始逐渐引起广泛关注的一些新型[软件开发](https://zh.wikipedia.org/wiki/软件开发)方法，是一种应对快速变化的需求的一种软件开发能力。它们的具体名称、理念、过程、术语都不尽相同，相对于“非敏捷”，更强调程序员团队与业务专家之间的紧密协作、面对面的沟通（认为比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重软件开发过程中人的作用。

    敏捷软件开发（或称快速程序开发RAD）描述了一套[软件开发](https://zh.wikipedia.org/wiki/軟件開發)的价值和原则，在这些开发中，需求和解决方案皆通过自组织[跨功能团队](https://zh.wikipedia.org/wiki/交叉功能工作小组)达成[[1\]](https://zh.wikipedia.org/wiki/敏捷软件开发#cite_note-Collier_2011-1)。敏捷软件开发主张适度的项目、进化开发、提前交付与持续改进，并且鼓励快速与灵活的面对开发与变更。这些原则支持许多[软件开发方法](https://zh.wikipedia.org/wiki/软件开发过程)的定义和持续进化。

    “敏捷”（Agile或agile[[2\]](https://zh.wikipedia.org/wiki/敏捷软件开发#cite_note-2)）一词由“敏捷软件开发宣言”（Manifesto for agile software development）中开始推广，“敏捷软件开发宣言”定义了相关的价值和原则。敏捷软件开发的[框架](https://zh.wikipedia.org/wiki/软件开发过程)不断的发展，两个最广泛被使用的是[Scrum](https://zh.wikipedia.org/wiki/Scrum)与[Kanban](https://zh.wikipedia.org/wiki/看板_(软件开发))。

  - **迭代、渐进和进化**

    大多数敏捷开发方法将产品开发工作细分微小化，因此大大的减少了前期规划和设计的数量。迭代或冲刺都是短时间的框架(时间)，通常持续一到四周。每个迭代都具有跨功能、职能的团队，包含了规划、分析、设计、程序编码、单元测试和验收测试。在迭代结束时，将工作产品向利益相关者展示。透过上述方式让整体风险降至最低，并使产品能够快速适应变化。迭代的方式，可能不会一次增加足够的功能来保证可立即发布使用，但是目标是在每次迭代结束时，有一个可用的发行版（最小化程序缺点）。因此完整产品的发布或新功能可能需要多次迭代。

  - **工作软件是进化的主要手段**

  - **高效率的面对面沟通**

    无论采用哪种开发方式，每个团队都应该包含一个客户代表（Scrum中的产品负责人）。这个人是由利益相关者同意代表他们行事，并作出个人承诺，回应开发人员在开发迭代过程中的问题。在每次迭代结束时，利益相关方和客户代表将审查进度并重新评估优先级，以优化投资回报（ROI）并确保与客户需求和公司目标保持一致。在敏捷软件开发中，会在开发团队附近设置一个消息发布器（通常很大）实体显示器，甚至路人也可以看到它。它提供了最新的产品开发状态摘要。并透过建置状态指示灯以通知团队他们的产品开发的当前状态。

  - **非常短的反馈回路和适应周期**

    敏捷软件开发中的一个共同特点就是每日站立（也被称为日常scrum）。 在一个简短的会议中，团队成员相互报告他们前一天对于团队的迭代目标、今天打算做的目标以及他们可以看到的任何障碍或阻碍。

  - **质量焦点**

    经常使用诸如持续集成、自动化单元测试、配对程序开发、测试驱动开发、设计模式、领域驱动设计，代码重构和其他技术的特定工具和技术来提高质量和提高产品开发敏捷性

- **极限编程**

  - **极限编程**（英语：Extreme programming，缩写为XP），是一种[软件工程](https://zh.wikipedia.org/wiki/软件工程)方法学，是[敏捷软件开发](https://zh.wikipedia.org/wiki/敏捷软件开发)中可能是最富有成效的几种方法学之一[[来源请求\]](https://zh.wikipedia.org/wiki/Wikipedia:列明来源)。如同其他敏捷方法学，极限编程和传统方法学的本质不同在于它更强调可适应性而不是可预测性。极限编程的支持者认为软件需求的不断变化是很自然的现象，是软件项目开发中不可避免的、也是应该欣然接受的现象；他们相信，和传统的在项目起始阶段定义好所有需求再费尽心思的控制变化的方法相比，有能力在项目周期的任何阶段去适应变化，将是更加现实更加有效的方法。

    极限编程为管理人员和开发人员开出了一剂指导日常[实践](https://zh.wikipedia.org/wiki/實踐)的良方；这个实践意味着接受并鼓励某些特别的有价值的方法。支持者相信，这些在传统的软件工程中看来是“极端的”实践，将会使开发过程比传统方法更加好的响应用户需求，因此更加敏捷，更好的构建出高质量软件。

  - 极限编程的主要**目标**在于**降低因需求变更而带来的成本**。在传统系统开发方法中，系统需求是在项目开发的开始阶段就确定下来，并在之后的开发过程中保持不变的。这意味着项目开发进入到之后的阶段时出现的需求变更（而这样的需求变更在一些发展极快的领域中是不可避免的）将导致开发成本急速增加。

    极限编程透过引入基本价值、原则、方法等概念来达到降低变更成本的目的。一个应用了极限编程方法的系统开发项目在应对需求变更时将显得更为灵活。

- **测试驱动开发**

  - **测试驱动开发**（英语：Test-driven development，缩写为TDD）是一种[软件开发过程](https://zh.wikipedia.org/wiki/软件开发过程)中的应用方法，由[极限编程](https://zh.wikipedia.org/wiki/极限编程)中倡导，以其倡导先写测试程序，然后编码实现其功能得名。测试驱动开发始于20世纪90年代。测试驱动开发的目的是取得快速反馈并使用“illustrate the main line”方法来构建程序。

    测试驱动开发是戴两顶帽子思考的开发方式：先戴上实现功能的帽子，在测试的辅助下，快速实现其功能；再戴上[重构](https://zh.wikipedia.org/wiki/软件重构)的帽子，在测试的保护下，通过去除冗余的代码，提高代码质量。测试驱动着整个开发过程：首先，驱动代码的设计和功能的实现；其后，驱动代码的再设计和重构。

- **单元测试**

  - 在[计算机编程](https://zh.wikipedia.org/wiki/计算机编程)中，**单元测试**（英语：Unit Testing）又称为**模块测试**，是针对[程序模块](https://zh.wikipedia.org/wiki/模組_(程式設計))（[软件设计](https://zh.wikipedia.org/wiki/软件设计)的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在[过程化编程](https://zh.wikipedia.org/wiki/過程化編程)中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。

    通常来说，程序员每修改一次程序就会进行最少一次单元测试，在编写程序的过程中前后很可能要进行多次单元测试，以证实程序达到[软件规格书](https://zh.wikipedia.org/wiki/規格_(技術標準))要求的工作目标，没有[程序错误](https://zh.wikipedia.org/wiki/Bug)；虽然单元测试不是必须的，但也不坏，这牵涉到[项目管理](https://zh.wikipedia.org/wiki/專案管理)的政策决定。

    每个理想的[测试案例](https://zh.wikipedia.org/wiki/测试案例)独立于其它案例；为测试时隔离模块，经常使用stubs、mock[[1\]](https://zh.wikipedia.org/wiki/单元测试#cite_note-mocksarentstubs-1)或fake等测试[马甲程序](https://zh.wikipedia.org/w/index.php?title=马甲程序&action=edit&redlink=1)。单元测试通常由[软件开发人员](https://zh.wikipedia.org/w/index.php?title=软件开发人员&action=edit&redlink=1)编写，用于确保他们所写的代码匹配软件需求和遵循[开发目标](https://zh.wikipedia.org/w/index.php?title=开发目标&action=edit&redlink=1)。它的实施方式可以是非常手动的（透过纸笔），或者是做成[构建自动化](https://zh.wikipedia.org/wiki/構建自動化)的一部分。

- **[透传](https://www.cnblogs.com/kenshinobiy/p/5632148.html)**
  - 什么是透传？透传即是透明传送，即传送网络无论传输业务如何，只负责将需要传送的业务传送到目的节点，同时保证传输的质量即可，而不对传输的业务进行处理。透传消息，就是消息体格式及内容，对于传递的通道来说是不去过问的，通道只负责消息的传递，对消息不做任何处理，当客户端接收到透传消息后，由客户端自己来决定如何处理消息。正是因为透传消息可以自定义消息体，也可以自定义消息的展示方式及后续动作处理，所以弥补了通知栏消息的一些不足之处(通知栏消息是直接展示出来，相关的动作客户端无法捕获到)。
  - **透传消息主要有如下几个方面的特点：**
    - 后台处理，用户无感知。
    - 前台展示，提醒用户。
    - 展示的多样化。
  - 整个透传消息的流程如下：根据个推提供的API接口或在个推开发者平台上推送透传消息，个推服务端接收到推送的消息后，不做任何处理，直接发送给目标用户。当客户端SDK接收到透传消息后，以广播方式发送给客户端，客户端在配置的第三方BroadReceiver里接收到透传消息后进行处理。
  - 透传消息的消息体，可以根据不同的需求传递不同的参数或格式。如传递一个简单的字符串，或传递一个Json字符串，里面根据需求传递需要的字段。
    用户无感知的透传，如：更新相关信息，在主界面中相关栏位用红点标识进行弱提醒，推送一条命令用来检测用户是否有登录等。通知栏消息虽然方便的提醒用户，但也在一定程度上给用户带来了打扰，用户无感知的消息推送有时效果会更好。
  - 用户有感知的透传：把透传消息处理成通知栏展示出来，提醒用户方便点击查看相关信息（如个人帐单信息），直接打开应用或跳转到指定的应用界面中（根据透传消息的相关参数来判断跳转到哪一个指定的界面，相关参数传递要打开的界面的类名或Intent即可）等。对于开发者，处理成通知栏的相关事件也是可以捕获的，如通知栏的展示、点击等事件都可以进行捕获，以方便进行后续的操作。
    因透传消息可以自己处理成通知栏内容展示，所以通知栏的样式也可以根据需求来做对应的改变。在Android 4.4及以上的系统，通知栏可以是样式丰富的通知栏，放入图片和视频等；可以展示普通的通知，也可以展示多样化的通知。
  
- [**APM**](https://www.jianshu.com/p/8123fc17fe0e)

  - `APM` 的全称是`Application performance management`，即应用性能管理，通过对应用的可靠性、稳定性等方面的监控，进而达到可以快速修复问题、提高用户体验的目的。
  - 国内各大公司都有自己的一套监控体系，这个系统可能是自己研发，也可能是第三方提供，当然对于这个数据为王的时代，很多有实力的公司倾向于自主研发，掌握核心数据。比较有代表性的 APM 产品有：听云、阿里百川、腾讯 bugly、NewRelic、OneAPM、网易云捕等
  - 说到监控，那么指标是我们所关注的呢？如下所示
    - 网络请求：成功率、状态码、流量、网络响应时间、HTTP与HTTPS的 DNS 解析、TCP握手、SSL握手（HTTP除外）、首包时间等时间
    - 界面卡顿、卡顿堆栈
    - 崩溃率、崩溃堆栈
    - Abort 率：也就是由于内存过高的等原因，被系统杀死的情况
    - 交互监控：页面加载时间、页面的交互痕迹
    - 维度信息：地域、运营商、网络接入方式、操作系统、应用版本等
    - 其他：内存、帧率、CPU使用率、启动时间、电量等

- **埋点**

  - [简书](https://www.jianshu.com/p/08e46151724b)
  - [百度百科](https://baike.baidu.com/item/%E5%9F%8B%E7%82%B9/20232533)

- **Java中valueOf与parseInt**
  
  - valueOf返回Integer对象，parseInt返回int基本类型
  
- **git cherry-pick**

  - 假设你在dev01分支开发了2个新功能(A,B)，对应2个commitA,commitB,但是上线前被告知只能上线功能A，此时可以：

    1. 新建1个分支dev02

    2. 将dev01上功能A对应代码cherry-pick到dev02上，dev02就有了功能A对应的代码

    - cherry-pick的用法：

    - ```git
      $ git cherry-pick 6bbf6b4 #6bbf6b4为dev01上的commitId
      ```

- **Pair类**

  - **Pair是一个容器，作用是轻便地对两个对象组成的元素组进行传递。这个对象提供了一个合理的equals()方法，如果两个对象的first和second值相等则返回true。**

  - 1、Pair(F first, S second)，一个Pair容器里面有2个元素，他们成组存在。
  - 2、Pair里面两个元素都是final的
  - 3、Pair的equals是**值比较**，不是地址比较
  - 比如我们知道，List和Map这两个集合容器是有很大不同的，但是如果在某些情况下，我们想用到List有的但是map没有的特性，但是我们数据又有一定关联成对出现或者说需要捆绑，那么我们是不是利用一下Pair呢？
  - **1、利用Pair和既有数据组成 组元素，不破坏原有结构的同时让两个数据产生绑定关系。**
  - **2、利用Pair和List结合，形成类似Map的效果。**

- **@CallSuper注解**
  
  - 表示任何重写方法也应该调用此方法
  
  - 主要是用来强调在覆盖父类方法的时候，需要实现父类的方法，及时调用对应的super.方法，当使用 @CallSuper 修饰了某个方法，如果子类覆盖父类该方法后没有实现对父类方法的调用就会报错
  






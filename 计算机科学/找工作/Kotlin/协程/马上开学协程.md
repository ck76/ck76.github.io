- Kotlin协程是借助的Kotlin语法的线程框架

- 协程最根本是**并发，多线程**
- 最大的好处是可以把运行在不同线程的代码写在同一代码块里，用同步的方式写异步
- 非阻塞式挂起：

```kotlin
launch(Dispachers.IO){
    	val image = getImage()
}
//创建一个新的协程并在指定线程上运行它，创建出的协程就是整个代码块里包裹的东西
需要切换线程的时候就用协程
launch(Dispachers.IO){
    val image = getImage()
    //前台更新界面，再切？？不对劲
    launch(Dispachers.Main){
        textview.setImageBitmap(image)
    }
}
```

- 协程里有一个很厉害的函数`withContext()`，这个函数可以指定线程来执行代码，执行完成之后会再自动切回来
  - `withContext()`是一个suspend函数，需要在协程里被调用

```kotlin
launch(Dispachers.Main){
    val image = withContext(Dispachers.IO){
         getImage()
    }
    textview.setImageBitmap(image)
}
```

- `suspend`：挂起（暂时切走，稍后再切回来）
  - 代码执行到suspend函数的时候会挂起，并且这个挂起是非阻塞式的，他不会阻塞你当前的线程
  - 具体挂起的既不是线程，也不是函数，是挂起的协程，协程就是launch里的代码 ，说白了就是这个协程从正在执行它的线程上脱离了，不是停了，是这个协程所在的线程从这行代码开始不再运行这个协程了
  - 此时如果线程是后台线程，那么该干嘛干嘛去，可能没事干，也可能被回收
  - 如果是Android的主线程接下来就会回去继续工作，在主线程启动一个协程相当于向主线程post了一个任务，协程挂起相当于这和任务提前结束了
  - 协程在和线程分离了之后会发生什么？
    - 函数代码在达到挂起函数的时候被切断了，所以接下来，他会在挂起函数继续往下执行，不过是在挂起函数指定的线程继续执行，在挂起函数执行完成之后，协程为我们做的最爽的事就来了， 他会自动把线程再切回来，比如原本线程是在主线程运行的，切回来就相当于在挂起函数执行完成之后再次向主线程post一个任务，让我们剩下的代码继续在主线程执行，这就是为什么在withContext里执行线程参数不叫Threads而叫Dispachers（调度器），这个调度器不仅能指定协程执行的线程，还能在suspend挂起函数执行完之后自动切回来，（可以通过特殊的Dispatcher让它不切回来）

- **协程的挂起就是切线程**，而且是可以自己切回来的线程，和Java切线程完全一样，只是他在完成之后能自动的切回来。Java的切线程和Kotlin的协程都是非阻塞式的。只是Kotlin的挂起看起来是阻塞的而已，
- 所谓的非阻塞式挂起只是用阻塞的方式写出了非阻塞的代码，完全是协程库的操作
- 协程并不比Java的原生线程性能高-官方文档有误
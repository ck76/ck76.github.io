https://www.jianshu.com/p/cd93567ed868

https://www.jianshu.com/nb/40078451

https://www.jianshu.com/nb/18383488

[TOC]



# 理解JVM之内存管理机制

> 本系列专题的第二个板块“理解JVM”是对周志明老师的《深入理解Java虚拟机》著作的学习和扩展，也是在春招过程中发现自己Java基础的不足，特意精选了几个重要知识点进行总结。关于Java技术体系的过去、现在和未来等介绍推荐阅读[走近 Java](https://www.jianshu.com/p/4aa86f791beb)，现在先从非常重要的内存管理开始吧~

#### 本篇将了解JVM内存是如何划分的，以及每个区域的具体内容。

- 概述
- JVM内存区域划分
- 操作系统内存与JVM内存
- HotSpot虚拟机内存对象探秘

------

**1.概述**

> Java与C++之间有一堵由**内存动态分配**和**垃圾回收机制**所围成的高墙，墙外面的人想进去，墙里面的人出不来。

**必要性**：虽然JVM有自动内存管理机制，不需要人为地给每一个new操作写配对的delete/free代码，不容易出现内存泄漏和内存溢出问题。然而一旦出现内存泄漏和溢出方面的问题，如果不清楚JVM内存的内存管理机制，那么将很难定位与解决问题。

------

**2.JVM内存区域划分**

> JVM执行Java程序的过程：Java源代码文件(.java)会被Java编译器编译为字节码文件(.class)，然后由JVM中的类加载器加载各个类的字节码文件，加载完毕之后，交由JVM执行引擎执行。

在上述过程中，JVM会用一段空间来存储执行程序期间需要用到的数据和相关信息，这段空间就是**运行时数据区（Runtime Data Area）**，也就是常说的JVM内存。JVM会将它所管理的内存划分为若干个不同的数据区域，划分结果如图：

![image-20201210002032215](https://tva1.sinaimg.cn/large/0081Kckwly1gli2c34o8jj30qw0lm45n.jpg)

可见，运行时数据区被分为**线程私有数据区**和**线程共享数据区**两大类：

- 线程私有数据区包含：程序计数器、虚拟机栈、本地方法栈
- 线程共享数据区包含：Java堆、方法区（内部包含常量池）

------

接下来分别介绍：

a.**程序计数器（Program Counter Register）**

- 是

  当前线程

  所执行的字节码的行号指示器。

  - 如果线程正在执行的是一个Java方法，那么计数器记录的是正在执行的虚拟机字节码指令的**地址**；
  - 如果线程正在执行的是一个Native方法，那么计数器的值则为**空**。

> 字节码解释器工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

- 为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个**独立**的程序计数器，各条线程之间计数器互不影响，独立存储，因此它是线程**私有**的内存。
- 在Java虚拟机规范中，是**唯一一个没有**规定任何OutOfMemoryError情况的区域。

------

b.**Java虚拟机栈（Java Virtual Machine Stacks）**

- 是

  Java方法

  执行的内存模型。

  - 每个方法在执行的同时都会创建一个栈帧，用于存储**局部变量表**、操作数栈、动态链接、方法出口等信息。
  - 每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

> 局部变量表存放了编译期可知的各种基本数据类型、对象引用类型和returnAddress类型，它所需的内存空间在**编译**期间完成分配。

- 是线程私有的内存，与线程生命周期相同。
- 一般把Java内存区分为堆内存（Heap）和栈内存（Stack），其中『栈』指的是虚拟机栈，『堆』指的是Java堆。
- 在Java虚拟机规范中，对这个区域规定了两种异常状况：
  - 如果线程请求的栈深度**大于**虚拟机所允许的深度，将抛出StackOverflowError异常；
  - 如果虚拟机栈可动态扩展且扩展时**无法**申请到足够的内存，将抛出OutOfMemoryError异常。

------

c.**本地方法栈（Native Method Stack）**

- 是虚拟机使用到的**Native方法**服务。
- 在虚拟机规范中，对这个区域无强制规定，由具体的虚拟机自由实现。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。

------

d.**Java堆（Java Heap）**

- 用于存放几乎所有的对象实例和数组。
- 被所有线程共享的一块内存区域，在虚拟机启动时创建。

> 在Java堆中，可能划分出多个**线程私有**的分配缓冲区（Thread Local Allocation Buffer，TLAB），但无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。

- 是垃圾收集器管理的主要区域，也被称做“GC堆”。
- 是Java虚拟机所管理的内存中最大的一块。
- 可处于物理上不连续的内存空间中，只要逻辑上是连续的即可。
- 在Java虚拟机规范中，如果在堆中没有内存完成实例分配，且堆也无法再扩展时，将会抛出OutOfMemoryError异常。

------

e.**方法区（Method Area）**

- 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
- 与Java堆一样，是各个线程共享的内存区域。
- 人们更愿意把这个区域称为**“永久代”（Permanent Generation）**，在发布的JDK1.7的HotSpot中，已经把原本放在永久代的字符串常量池移出。它还有个别名叫做**Non-Heap（非堆）**。
- 和Java堆一样不需要连续的内存和可以选择固定大小或可扩展外，还可选择不实现GC。
- 在Java虚拟机规范中，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。

------

f.**运行时常量池（Runtime Constant Pool）**

> Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是**常量池（Constant Pool Table）**，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

- 相对于Class文件常量池的一个重要特征是具备**动态性**，体现在并非只有预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中。
- 是方法区的一部分，会受到方法区内存的限制。
- 在Java虚拟机规范中，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。

**推荐阅读**：[JVM内存溢出详解（栈溢出，堆溢出，持久代溢出、无法创建本地线程）](https://www.jianshu.com/p/2a2a5ec2af00)

------

**3.操作系统内存与JVM内存**

![image-20201210002049691](https://tva1.sinaimg.cn/large/0081Kckwly1gli2cde5auj310y0sue13.jpg)

从上图可见操作系统内存和JVM内存的联系：

> 操作系统分为栈和堆：
>
> - 栈
>
>   由操作系统管理，并由操作系统自动回收。
>
>   - JVM本地方法栈使用的是操作系统的栈。
>
> - 堆
>
>   由用户分配使用。
>
>   - 除JVM本地方法栈以外的JVM内存使用的操作系统的堆，以防JVM分配的内存被操作系统回收。

**图片来源**：[JVM内存管理—运行时内存区域](https://www.jianshu.com/p/1696f1bdff8b)

------

**4.HotSpot虚拟机内存对象探秘**

> 在熟悉虚拟机内存划分及其具体内容之后，为详细了解虚拟机内存中数据的其他细节，以常用的虚拟机HotSpot和常用的内存区域Java堆为例，探讨HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。

a.**对象的创建**：遇到一个new指令后创建过程分三步

- 类加载检查：检查new指令的参数是否能在常量池中定位到一个类的符号引用且该符号引用代表的类是否已被加载、解析和初始化，若没有则需先执行相应的类加载，反之下一步。
- 分配内存：由Java堆中的内存是否规整决定如何给新生对象分配可用空间。
  - 若规整，采用“指针碰撞”分配方式：
    - 过程：将用过和空闲的内存放在两边，中间以一个指针作为分界指示器。当分配内存时，就把指针向空闲一边挪动与对象大小相等的距离即可。
    - 应用：Serial、ParNew等带Compact过程的收集器。
  - 若非规整，采用“空闲列表”分配方式：
    - 过程：维护一个记录可用内存块的列表。当分配内存时，就从列表中找到一块足够大的空间划分给对象实例并更新记录。
    - 应用：基于Mark-Sweep算法的CMS收集器。

> 保证内存分配是线程安全的解决方案：
>
> - 对内存分配的动作进行同步处理；
> - 每个线程在Java堆中预先分配一块内存（本地线程分配缓冲TLAB），在本线程的TLAB上进行分配，当TLAB用完需要分配新的TLAB时再同步锁定。

- 设置对象头：将对象的所属类、找到类的元数据信息的方式、对象的哈希码、对象的GC分代年龄等信息存放在对象的对象头中。

> 经过上述步骤，一个对象就产生了，但此时所有的字段都还为零，还需要执行`<init>`方法进行初始化，才能成为真正可用的对象。

b.**对象的内存布局**：分为三块区域

- 对象头（Header）：包括两部分信息
  - Mark  Word：用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。
  - 类型指针：用于确定这个对象的所属类。
- 实例数据（Instance Data）：存储真正的有效信息，是程序代码中定义的各种类型的字段内容。存储顺序会受虚拟机分配策略参数和字段在Java源码中定义顺序这两个因素影响。
- 对齐填充（Padding）：占位符，帮助补全未对齐的对象实例数据部分（保证是8字节的倍数），非必需。

c.**对象的访问定位**：主流的两种访问方式

- 通过句柄访问对象：在Java堆中划分出一块内存来作为句柄池，reference存储的是对象的句柄地址，在句柄中包含了对象实例数据与类型数据各自的具体地址信息。好处：reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。

  ![image-20201210002103271](https://tva1.sinaimg.cn/large/0081Kckwly1gli2clscvfj310s0hojxi.jpg)

- 通过直接指针访问对象：在Java堆对象的布局中考虑如何放置访问类型数据的相关信息，reference存储的直接就是对象地址。好处：速度更快，节省了一次指针定位的时间开销。

  ![image-20201210002123807](https://tva1.sinaimg.cn/large/0081Kckwly1gli2cyktdgj310s0gyn22.jpg)

------

下篇将介绍和内存管理紧密相关的垃圾回收机制。



作者：厘米姑娘
链接：https://www.jianshu.com/p/cd93567ed868
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# 理解JVM之GC&内存分配

#### 有内存分配就会有内存回收，[上篇](https://www.jianshu.com/p/cd93567ed868)也了解到Java堆是垃圾收集器管理的主要区域，本篇将理解这部分内存的垃圾回收机制。

- 对象存活判定算法
- 垃圾收集算法
- HotSpot算法实现&垃圾收集器
- 内存分配与回收策略

------

**1.对象存活判定算法**

> 概念：引用的四种类型
>
> - 强引用
>
>   （StrongReference）
>
>   - 具有强引用的对象不会被GC；
>   - 即便内存空间不足，JVM宁愿抛出`OutOfMemoryError`使程序异常终止，也不会随意回收具有强引用的对象。
>
> - 软引用
>
>   （SoftReference）
>
>   - 只具有软引用的对象，会在内存空间不足的时候被GC，如果回收之后内存仍不足，才会抛出OOM异常；
>   - 软引用常用于描述有用但并非必需的对象，比如实现内存敏感的高速**缓存**。
>
> - 弱引用
>
>   （WeakReference）
>
>   - 只被弱引用关联的对象，无论当前内存是否足够都会被GC；
>   - 强度比软引用更弱，常用于描述**非必需**对象。
>
> - 虚引用
>
>   （PhantomReference）
>
>   - 仅持有虚引用的对象，在任何时候都可能被GC；
>   - 常用于跟踪对象被GC回收的活动；
>   - 必须和**引用队列** （ReferenceQueue）联合使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。

------

a.**引用计数算法**：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。

> 然而在主流的Java虚拟机里未选用引用计数算法来管理内存，主要原因是它难以解决对象之间**相互循环引用**的问题，所以出现了另一种对象存活判定算法。

b.**可达性分析法**：通过一系列被称为『GC Roots』的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为**引用链**，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。

> 可作为GC Roots的对象：
>
> - 虚拟机栈中引用的对象，主要是指栈帧中的**本地变量**
> - 本地方法栈中**Native方法**引用的对象
> - 方法区中**类静态属性**引用的对象
> - 方法区中**常量**引用的对象

![image-20201210002246874](https://tva1.sinaimg.cn/large/0081Kckwly1gli2eeenkqj310u0pk10h.jpg)

需要注意的是，在可达性分析算法中被判定不可达的对象还未真的判『死刑』，至少要经历两次标记过程：判断对象是否有必要执行`finalize()`方法；若被判定为有必要执行`finalize()`方法，之后还会对对象再进行一次筛选，如果对象能在`finalize()`中重新与引用链上的任何一个对象建立关联，将被移除出“即将回收”的集合。

------

> 引伸：有关**方法区**的GC，可分成两部分
>
> - **废弃常量**与回收Java堆中的对象的GC很类似，即在任何地方都未被引用的常量会被GC。
>
> - 无用的类
>
>   需满足以下三个条件才会被GC：
>
>   - 该类所有的实例都已被回收，即Java堆中不存在该类的任何实例；
>   - 加载该类的`ClassLoader`已经被回收；
>   - 该类对应的java.lang.Class对象没在任何地方被引用，即无法在任何地方通过**反射**访问该类的方法。

------

**2.垃圾收集算法**

> 上一节介绍了JVM会回收哪些对象，接下来介绍JVM会如何回收掉这些对象。

a.**分代收集算法**

- 根据对象存活周期的不同，将Java堆划分为新生代和老年代，并根据各个年代的特点采用最适当的收集算法。
  - 新生代：大批对象死去，只有少量存活。使用『复制算法』，只需复制少量存活对象即可。
  - 老年代：对象存活率高。使用『标记—清理算法』或者『标记—整理算法』，只需标记较少的回收对象即可。
- 是当前商业虚拟机都采用的一种算法。

> 接下来依次介绍以上提及的另外三种算法。

b.**复制算法**

- 把可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用尽后，把还存活着的对象『复制』到另外一块上面，再将这一块内存空间一次清理掉。
- 优点：每次都是对整个半区进行内存回收，无需考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。
- 缺点：每次可使用的内存缩小为原来的一半，内存使用率低。

![image-20201210002302384](https://tva1.sinaimg.cn/large/0081Kckwly1gli2eocvajj31380qitdi.jpg)

> 有研究表明新生代中的对象98%是朝生夕死的，因此没必要按照1:1来划分内存空间，而是分为一块较大的Eden空间和两块较小的Survivor空间，在HotSpot虚拟机中默认比例为8:1:1。每次使用Eden和一块Survivor，回收时将这两块中存活着的对象一次性地复制到另外一块Survivor上，再做清理。可见只有10%的内存会被“浪费”，倘若Survivor空间不足还需要依赖其他内存（老年代）进行分配担保。

c.**标记-清除算法**

- 首先『标记』出所有需要回收的对象，然后统一『清除』所有被标记的对象。
- 是最基础的收集算法。
- 缺点：『标记』和『清除』过程的效率不高；空间碎片太多，『标记』『清除』之后会产生大量不连续的内存碎片，可能会导致后续需要分配较大对象时，因无法找到足够的连续内存而提前触发另一次GC，影响系统性能。

![image-20201210002315159](https://tva1.sinaimg.cn/large/0081Kckwly1gli2evmhsdj312a0qeq7p.jpg)

d.**标记-整理算法**

- 首先『标记』出所有需要回收的对象，然后进行『整理』，使得存活的对象都向一端移动，最后直接清理掉端边界以外的内存。
- 优点：即没有浪费50%的空间，又不存在空间碎片问题，性价比较高。
- 一般情况下，老年代会选择标记-整理算法。

![image-20201210002328108](https://tva1.sinaimg.cn/large/0081Kckwly1gli2f4525vj311q0pu430.jpg)

------

3.**HotSpot算法实现&垃圾回收器**

> 接下来介绍如何在HotSpot虚拟机上实现对象存活判定算法和垃圾收集算法，并保证虚拟机高效运行。

a.**枚举根节点**

主流Java虚拟机使用的都是**准确式GC**，在执行系统停顿之后无需检查所有执行上下文和全局的引用位置，而是通过一些办法直接获取到存放对象引用的地方，在HotSpot中是通过一组称为**OopMap**的数据结构来实现的，完成类加载后会计算出对象某偏移量上某类型数据、JIT编译时会在**特定的位置**记录栈和寄存器中是引用的位置。这样GC在扫描时就可直接得知这些信息，并快速准确地完成GC Roots的枚举。

b.**安全点**（Sefepoint）

上述“特定的位置”被称为安全点，即程序执行时并非在所有地方都停顿执行GC，只在到达安全点时才暂停，降低GC的空间成本。

- 安全点的选定标准：可让程序**长时间执行**的地方，如方法调用、循环跳转、异常跳转等具有指令序列复用的特征。
- 使所有线程在最近的安全点上再停顿的方案：
  - 抢先式中断（Preemptive Suspension）：无需代码主动配合，在GC发生时把所有线程全部中断，若线程中断处不在安全点上就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。
  - 主动式中断（Voluntary Suspension）：在GC要中断线程时不直接对线程操作，而是设置一个中断标志，让各个线程在执行时主动轮询它，当中断标志为真时就自己中断挂起。

c.**安全区域**（Safe Region）

安全点机制只能保证程序执行时，在不太长的时间内遇到可进入GC的安全点，但在程序不执行时（如线程处于Sleep或Blocked状态）线程无法响应JVM的中断请求，此时就需要安全区域来解决。

- 安全区域：引用关系不会发生变化的一段代码片段，在安全区域中的任意地方开始GC都是安全的，可看做是扩展的安全点。
- 执行过程：当线程执行到安全区域中的代码时就标识一下，如果这时JVM要发起GC就不用管被标识的线程；在线程要离开安全区域时检查系统是否已经完成了根节点枚举，若完成则线程可以继续执行，否则等待直到收到可以安全离开安全区域的信号为止。

> 到此只是简单介绍了HotSpot如何发起内存回收，而具体的回收动作是由虚拟机所采用的GC收集器决定的，通常虚拟机中往往不止有一种GC收集器，下图展示的是HotSpot虚拟机中存在的七种作用于不同分代（新生代、老年代）的收集器，其中被连线的两个收集器表示可以搭配使用。

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gli2fgfu56j30ug0u0gvc.jpg" alt="image-20201210002347977" style="zoom:50%;" />

以下是对比图，来源于文章[JVM（HotSpot） 垃圾收集器](https://www.jianshu.com/p/b4a03b5de0d9)

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gli2fqa85yj31120j2wpk.jpg" alt="image-20201210002358838" style="zoom:50%;" />

> **并行(Parallel)**：多条垃圾收集线程并行工作，而用户线程仍处于等待状态。
>  **并发(Concurrent)**：垃圾收集线程与用户线程一段时间内同时工作，用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。

------

5.**内存分配与回收策略**

> 对象的内存分配广义上是指在堆上分配，主要是在**新生代**的Eden区上，如果启动了TLAB，将按线程优先在TLAB上分配，少数情况下也可能会分配在老年代中。分配细节还是取决于所使用的GC收集器组合以及虚拟机中与内存相关的参数的设置。以下介绍几条普遍的内存分配规则。

- **对象优先在Eden分配**：大多数情况下对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时虚拟机将发起一次Minor GC。

> 新生代GC（Minor GC）：发生在新生代的垃圾收集动作。较频繁、回收速度也较快。
>  老年代GC（Major GC/Full GC）：发生在老年代的垃圾收集动作。出现Major GC经常会伴随至少一次的Minor GC。速度一般比Minor GC慢10倍以上。

- **大对象直接进入老年代**：对于需要大量连续内存空间的Java对象（如很长的字符串以及数组），如果大于虚拟机设定的`-XX：PretenureSizeThreshold`参数值将直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。
- **长期存活的对象将进入老年代**：虚拟机会给每个对象定义一个年龄计数器，当对象在Eden出生并经过第一次Minor GC后仍存活且能被Survivor容纳的话，将被移动到Survivor空间中并将对象年龄设为1；当对象在Survivor区中每“熬过”一次Minor GC年龄就+1，直至增加到一定程度（默认为15岁，可通过`-XX： MaxTenuringThreshold`设置）就会被晋升到老年代中。
- **动态对象年龄判定**：为了能更好地适应不同程序的内存状况，虚拟机并不要求一定要达到`-XX： MaxTenuringThreshold`设置值才能晋升到老年代，当Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，那么年龄大于或等于该年龄的对象可以直接进入老年代。
- **空间分配担保**：在发生Minor GC之前虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，若是，说明可确保Minor GC是安全的，反之虚拟机会查看`-XX：HandlePromotionFailure`设置值是否允许担保失败；若允许，会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小；若大于，将尝试进行一次Minor GC，若小于或者不允许担保失败，将改为进行一次Full GC。

> 解释：当大量对象在MinorGC后仍然存活的情况时，需要借助老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代，但前提是老年代本身还有容纳这些对象的剩余空间，由于在完成内存回收之前无法预知实际存活对象，只好取之前每次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，从而决定是否进行Full GC来让老年代腾出更多空间。



作者：厘米姑娘
链接：https://www.jianshu.com/p/a62697f00b85
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# 理解JVM之类文件结构



> 之前还在美团实习的时候，当时读《深入理解Java虚拟机》由于时间原因只总结了几个章节，现在把余下的几个章节补充上，发表顺序有些混乱，章节主线详见[文章汇总|学习Android的一点一滴](https://www.jianshu.com/p/c44d7a106302)。

#### 本篇将介绍Class文件结构中的各个组成部分，以及每个部分的定义、数据结构和使用，有利于进一步了解虚拟机执行引擎。

- 概述
- 类文件结构
- 字节码指令

------

1.**概述**

运行在各种不同平台上的虚拟机通过载入和执行同一种平台无关的字节码来实现了程序的“**一次编写，到处运行**”。可见字节码是构成**平台无关性**的基石。

Java虚拟机不和Java等任何语言绑定，只和存储字节码的**Class文件**这种特定的二进制文件格式关联，且并不关心Class的来源是何种语言，也体现了Java虚拟机的**语言无关性**。

![image-20201210002507615](https://tva1.sinaimg.cn/large/0081Kckwly1gli2h3w7hmj311e0l2dhh.jpg)

------

2.**类文件结构**

> - Class文件是一组以**8位字节**为基础单位的二进制流，各个数据项目**严格**按照顺序紧凑地排列在Class文件之中，中间无任何分隔符，当遇到需要占用8位字节以上空间的数据项时，会按照**高位在前**的方式分割成若干个8位字节进行存储。
>
> - Class文件格式采用一种类似于C语言结构体的
>
>   伪结构
>
>   来存储数据，包含两种数据类型：
>
>   - **无符号数**：属于基本数据类型；以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数；可用于描述数字、索引引用、数量值或按照UTF-8 编码构成的字符串值。
>   - **表**：由多个无符号数或其他表作为数据项构成的复合数据类型；常以“_info”结尾；可用于描述有层次关系的复合结构的数据。
>
> - 整个Class文件本质上就是一张表，所包含的数据项如图：

![image-20201210002551320](https://tva1.sinaimg.cn/large/0081Kckwly1gli2hmjnhaj311k0oogst.jpg)

接下来依次介绍表中各个数据项的具体含义。

a. **魔数**

- 魔数（Magic  Number）：每个Class文件的头4个字节
- 作用：判断该文件是否为一个能被虚拟机接受的Class文件

b.**版本号**

- 版本号：包含主版本号和一系列次版本号
  - 次版本号（Minor Version）：第5和第6个字节
  - 主版本号（Major Version）：第7和第8个字节
- 作用：判断该文件是否在虚拟机处理的有效范围内

c.**常量池**

- 常量池：使用一个前置的容量计数器（constant_pool_count）加上若干个连续的常量项（constant_pool）来描述
  - 容量计数器：从1开始，目的是满足后面某些指向常量池的索引值的数据在特定情况下需要表达“**不引用任何一个常量池项目**”的含义，这时可以把索引值置为0来表示
  - 常量项：如constant_pool_count=2表示常量池中有1个常量项
- 特点：是Class文件的资源仓库、是Class文件结构中与其他项目关联最多的数据类型、是占用Class文件空间最大的数据项目之一、是在Class文件中第一个出现的表类型数据项目
- 存放内容：两大类常量
  - 字面量（Literal）：指Java语言层面的常量概念，如文本字符串、声明为final的常量值等
  - 符号引用（Symbolic References）：指编译原理方面的概念，包含类和接口的全限定名（Fully Qualified Name）、字段的名称和描述符（Descriptor）、方法的名称和描述符

> Java代码进行Javac编译的过程同虚拟机加载Class文件的过程是**动态连接**的，因此在Class文件中不会保存各个方法、字段的最终内存布局信息，这就需要虚拟机在运行时从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。

- 常量池中每一个常量都是一个表，详解见[Class文件结构--常量池（一）](https://www.jianshu.com/p/d8492e748c57)

d.**访问标志**

- 访问标志（access_flags）：常量池结束后两个字节
- 作用：识别一些类或者接口层次的访问信息，包括该Class是类还是接口、是否定义为public类型、是否定义为abstract类型、若是类是否被声明为final等。具体的标志位以及含义见图：

![image-20201210002608579](https://tva1.sinaimg.cn/large/0081Kckwly1gli2hwdus9j312g0hu490.jpg)

e.**类索引、父类索引与接口索引集合**

- 类索引（this_class）和父类索引（super_class）都是一个u2类型的数据、接口索引集合（interfaces）是一组u2类型的数据的集合
- 作用： 通过这三项数据来确定这个类的继承关系，具体的
  - 类索引：确定这个类的**全限定名**
  - 父类索引：确定这个类的父类的**全限定名**
  - 接口索引集合：描述这个类所实现的接口，并按照implements语句后的接口顺序从左到右排列在接口索引集合中
    - 接口索引集合的入口第一项u2类型数据为接口计数器（interfaces_count），从0计数，如nterfaces_count=2表示该类实现了两个接口

> 类全限定名：把类全名中的“.”都替换成“/”，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“；”表示全限定名结束

f.**字段表集合**

- 字段表（field_info）：用于描述接口或者类中声明的变量
- 格式如图
  - ![image-20201210002636509](https://tva1.sinaimg.cn/large/0081Kckwly1gli2idr4ptj30u00vdwts.jpg)
  - attribute_info：属性表见后

g.**方法表集合**

- 方法表（methods_info）：用于描述接口或者类中声明的方法
- 格式如图，可见和描述字段的方式非常类似，仅在访问标志和属性表集合的可选项中有所区别。
  - ![image-20201210002650178](https://tva1.sinaimg.cn/large/0081Kckwly1gli2imq52wj31260qg7g6.jpg)

h.**属性表集合**

- 属性表（attribute_info）：用于描述某些场景专有的信息，在字段表、方法表等都携带自己的属性表集合

- 种类:

  ![img](https://tva1.sinaimg.cn/large/0081Kckwly1gli2j1rgblj30u01971kx.jpg)

- 结构：属性名需要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，属性值是自定义的、需要通过一个u4的长度属性说明属性值所占用的位数

![image-20201210002730276](https://tva1.sinaimg.cn/large/0081Kckwly1gli2jc1c9jj31180660um.jpg)

**举例**：[class文件结构解析](https://www.jianshu.com/p/0ddf610991a5)、[class文件属性表解析](https://www.jianshu.com/p/4db052bc2e1f)

------

3.**字节码指令**

- 构成：由一个字节长度的表示某种特定操作含义的操作（**操作码**、Opcode）和零至多个代表此操作所需的参数（**操作数**、Operands）构成
- 特点：**非完全独立**，即并非每种数据类型和每一种操作都有对应的指令，有些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型
- 分类：将字节码操作按用途大致分为9类
  - **加载和存储指令**：用于将数据在栈帧中的局部变量表和操作数栈之间来回传输
  - **运算指令**：用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶
  - **类型转换指令** ：用于实现用户代码中的显式类型转换操作，或者用于处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题
  - **对象创建与访问指令**：用于对象创建，并通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素
  - **操作数栈管理指令**：用于直接操作操作数栈
  - **控制转移指令**：用于从指定的位置有条件或无条件地进行指令
  - **方法调用和返回指令**：用于方法的调用，并根据返回值的类型去返回
  - **异常处理指令**：用于检测到异常状况时自动抛出异常
  - **同步指令**：用于方法内部一段指令序列的同步

具体指令见[Java虚拟机字节码指令简介](https://www.jianshu.com/p/503ec161e602)



作者：厘米姑娘
链接：https://www.jianshu.com/p/43a93c3216b8
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



# 理解JVM之类加载机制

#### 本篇将了解类加载机制和双亲委派模型这两大知识考点：

- 概述
- 类加载全过程
- 类加载器&双亲委派模型

------

1.**概述**

a.**JVM类加载机制**：是虚拟机把描述类的数据从`Class`文件**加载**到内存，并对数据进行**校验**、**转换解析**和**初始化**，最终形成可被虚拟机直接使用的`Java`类型的过程。

b.**特性**：运行期类加载。即在Java语言里面，类型的加载、连接和初始化过程都是在程序**运行期**完成的，从而通过牺牲一些性能开销来换取Java程序的高度灵活性。

> JVM运行期动态加载+动态连接->Java语言的动态扩展特性

------

2.**类加载全过程**

类从被加载到虚拟机内存中开始、到卸载出内存为止，整个生命周期包括7阶段：

- **加载**（Loading）
- **验证**（Verification）
- **准备**（Preparation）
- **解析**（Resolution）
- **初始化**（Initialization）
- **使用**（Using）
- **卸载**（Unloading）

其中，验证、准备、解析这3个部分统称为**连接**（Linking），流程如下图：

![image-20201210002830402](https://tva1.sinaimg.cn/large/0081Kckwly1gli2kdiq6xj310q0do0y1.jpg)

> 注意：
>
> - 『加载』->『验证』->『准备』->『初始化』->『卸载』这5个阶段的顺序是确定的，而『解析』可能为了支持Java语言的运行时绑定会在『初始化』后才开始。
> - 上述阶段通常都是互相交叉地混合式进行的，比如会在一个阶段执行的过程中调用、激活另外一个阶段。

接下来将分别介绍上述几个阶段。

------

a.**加载**

> **任务**:
>
> - 通过类的全限定名来获取定义此类的**二进制字节流**。如从ZIP包读取、从网络中获取、通过运行时计算生成、由其他文件生成、从数据库中读取等等途径......
> - 将该二进制字节流所代表的**静态存储结构**转化为方法区的**运行时数据结构**，该数据存储数据结构由虚拟机实现自行定义。
> - 在内存中生成一个代表这个类的`java.lang.Class`对象，它将作为程序访问方法区中的这些类型数据的外部接口。

------

b.**验证**

- 是连接阶段的**第一步**，且工作量在JVM类加载子系统中占了相当大的一部分。
- **目的**：为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

> 由此可见，它能直接决定JVM能否承受恶意代码的攻击，因此验证阶段很有必要，但由于它对程序运行期没有影响，并不一定必要，可以考虑使用`-Xverify：none`参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

- 检验过程包括以下四个

  阶段

  ：

  - 文件格式验证

    ：

    - 内容：验证字节流是否符合Class文件格式的规范、以及是否能被当前版本的虚拟机处理。
    - 目的：保证输入的**字节流**能正确地解析并存储于==**方法区**==之内，且格式上符合描述一个Java类型信息的要求。只有保证二进制字节流通过了该验证后，它才会进入内存的方法区中进行存储，所以后续3个验证阶段全部是基于方法区而不是字节流了。

  - 元数据验证

    ：

    - 内容：对字节码描述的信息进行**语义**分析，以保证其描述的信息符合Java语言规范的要求。
    - 目的：对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。

  - 字节码验证

    ：是验证过程中

    最复杂

    的一个阶段。

    - 内容：对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。
    - 目的：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。

  - 符号引用验证

    ：

    - 内容：对类自身以外（如常量池中的各种符号引用）的信息进行匹配性校验。
    - 目的是确保解析动作能正常执行，如果无法通过符号引用验证，那么将会抛出一个`java.lang.IncompatibleClassChangeError`异常的子类。
    - 注意：该验证发生在虚拟机将**符号引用**转化为**直接引用**的时候，即『解析』阶段。

------

c.**准备**

> **任务**：
>
> - 为类变量**分配内存**：因为这里的变量是由方法区分配内存的，所以仅包括类变量而不包括实例变量，后者将会在对象实例化时随着对象一起分配在Java堆中。
> - 设置类变量**初始值**：通常情况下零值。

------

d.**解析**

- 之前提过，解析阶段就是虚拟机将

  常量池

  内的符号引用替换为直接引用的过程。

  - 符号引用

    （Symbolic References）：以一组符号来描述所引用的目标。

    - 可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。
    - 与虚拟机实现的内存布局无关，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中，所以即使各种虚拟机实现的内存布局不同，但是能接受符号引用都是一致的。

  - 直接引用

    （Direct References）：

    - 可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。
    - 与虚拟机实现的内存布局相关，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不同。

- **发生时间**：JVM会根据需要来判断，是在类被加载器**加载时**就对常量池中的符号引用进行解析，还是等到一个符号引用将要被**使用前**才去解析。

- 解析动作

  ：有7类符号及其对应在常量池的7种常量类型

  - **类或接口**(`CONSTANT_Class_info`)
  - **字段**(`CONSTANT_Fieldref_info`)
  - **类方法**(`CONSTANT_Methodref_info`)
  - **接口方法**(`CONSTANT_InterfaceMethodref_info`)
  - **方法类型**(`CONSTANT_MethodType_info`)
  - **方法句柄**(`CONSTANT_MethodHandle_info`)
  - **调用点限定符**(`CONSTANT_InvokeDynamic_info`)

> 举个例子，设当前代码所处的为类D，把一个从未解析过的**符号引用N**解析为一个**类或接口C的直接引用**，解析过程分三步：
>
> - 若C不是数组类型：JVM将会把代表N的全限定名传递给D类加载器去加载这个类C。在加载过程中，由于**元数据验证**、**字节码验证**的需要，又可能触发其他相关类的加载动作。一旦这个加载过程出现了任何异常，解析过程就宣告失败。
> - 若C是数组类型且数组元素类型为对象：JVM也会按照上述规则加载数组元素类型。
> - 若上述步骤无任何异常：此时C在JVM中已成为一个有效的类或接口，但在解析完成前还需进行**符号引用验证**，来确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出`java.lang.IllegalAccessError`异常。

------

e.**初始化**

- 是类加载过程的最后一步，会开始真正执行类中定义的Java字节码。而之前的类加载过程中，除了在『加载』阶段用户应用程序可通过自定义类加载器参与之外，其余阶段均由虚拟机主导和控制。

- 与『准备』阶段的

  区分

  ：

  - 准备阶段：变量赋初始零值。
  - 初始化阶段：根据Java程序的设定去初始化类变量和其他资源，或者说是执行类构造器`<clinit>()`的过程。

> `<clinit>()`：由编译器自动收集类中的所有类变量的赋值动作和静态语句块`static{}`中的语句合并产生。
>
> - 是线程安全的，在多线程环境中被正确地加锁、同步。
> - 对于类或接口来说是**非**必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成 `<clinit>()`。
> - 接口与类不同的是，执行接口的 `<clinit>()`不需要先执行父接口的 `<clinit>()`，只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的`<clinit>()`。

- 在虚拟机规范中，规定了有且只有五种情况必须立即对类进行『初始化』：
  - 遇到`new`、`getstatic`、`putstatic`或`invokestatic`这4条字节码指令时；
  - 使用`java.lang.reflect`包的方法对类进行反射调用的时候；
  - 当初始化一个类的时候，若发现其父类还未进行初始化，需先触发其父类的初始化；
  - 在虚拟机启动时，需指定一个要执行的**主类**，虚拟机会先初始化它；
  - 当使用JDK1.7的动态语言支持时，若一个`java.lang.invoke.MethodHandle`实例最后的解析结果为`REF_getStatic`、`REF_putStatic`、`REF_invokeStatic`的方法句柄，且这个方法句柄所对应的类未进行初始化，需先触发其初始化。

------

3.**类加载器&双亲委派模型**

> 每个类加载器都拥有一个独立的类名称空间，它不仅用于加载类，还和这个类本身一起作为在JVM中的唯一标识。所以比较两个类是否相等，只要看它们是否由同一个类加载器加载，即使它们来源于同一个Class文件且被同一个JVM加载，只要加载它们的类加载器不同，这两个类就必定不相等。

a.**类加载器**

从JVM的角度，可将类加载器分为两种：

- 启动类加载器

  （Bootstrap    ClassLoader）

  - 由`C++`语言实现，是虚拟机自身的一部分。
  - 负责加载存放在`＜JAVA_HOME＞\lib`目录中、或被`-Xbootclasspath`参数所指定路径中的、且可被虚拟机识别的类库。
  - 无法被Java程序直接引用，如果自定义类加载器想要把加载请求委派给引导类加载器的话，可直接用null代替。

- 其他类加载器：由

  ```
  Java
  ```

  语言实现，独立于虚拟机外部，并且全都继承自抽象类

  ```
  java.lang.ClassLoader
  ```

  ，可被Java程序直接引用。常见几种：

  - 扩展类加载器

    （Extension ClassLoader）

    - 由`sun.misc.Launcher$ExtClassLoader`实现。
    - 负责加载`＜JAVA_HOME＞\lib\ext`目录中的、或者被`java.ext.dirs`系统变量所指定的路径中的所有类库。

  - 应用程序类加载器

    （Application ClassLoader）

    - 是**默认**的类加载器，是`ClassLoader#getSystemClassLoader()`的返回值，故又称为**系统类加载器**。
    - 由`sun.misc.Launcher$App-ClassLoader`实现。
    - 负责加载用户类路径上所指定的类库。

  - **自定义类加载器**（User ClassLoader）：如果以上类加载起不能满足需求，可自定义。

上述几种类加载器的关系如图：

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gli2kqxjmlj30ut0u0tjq.jpg" alt="image-20201210002852758" style="zoom:50%;" />

需要注意的是，虽然数组类不通过类加载器创建而是由JVM直接创建的，但仍与类加载器有密切关系，因为数组类的元素类型最终还要靠类加载器去创建。

b.**双亲委派模型**（Parents Delegation Model）

- 表示类加载器之间的层次关系。
- **前提**：除了顶层启动类加载器外，其余类加载器都应当有自己的父类加载器，且它们之间关系一般不会以**继承**（Inheritance）关系来实现，而是通过**组合**（Composition）关系来复用父加载器的代码。
- **工作过程**：若一个类加载器收到了类加载的请求，它先会把这个请求**委派**给父类加载器，并向上传递，最终请求都传送到顶层的启动类加载器中。只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。
- **注意**：不是一个强制性的约束模型，而是Java设计者推荐给开发者的一种类加载器实现方式。
- **优点**：类会随着它的类加载器一起具备带有**优先级**的层次关系，可保证Java程序的稳定运作；实现简单，所有实现代码都集中在`java.lang.ClassLoader的loadClass()`中。

> 比如，某些类加载器要加载`java.lang.Object`类，最终都会委派给最顶端的启动类加载器去加载，这样`Object`类在程序的各种类加载器环境中都是同一个类。相反，系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。

```java
首先明确一点：jvm如何认定两个对象同属于一个类型，必须同时满足下面两个条件：
都是用同名的类完成实例化的。
两个实例各自对应的同名的类的加载器必须是同一个。比如两个相同名字的类，一个是用系统加载器加载的，一个扩展类加载器加载的，两个类生成的对象将被jvm认定为不同类型的对象。
所以，为了系统类的安全，类似“ java.lang.Object”这种核心类，jvm需要保证他们生成的对象都会被认定为同一种类型。即“通过代理模式，对于 Java 核心库的类的加载工作由引导类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的”。
```



# 理解JVM之字节码执行引擎

#### 本篇将从概念模型的角度来介绍虚拟机的方法调用和字节码执行。

- 概述
- 运行时栈帧结构
- 方法调用

------

1.**概述**

a.有关**虚拟机与物理机**的异同

- 同：都有代码执行能力
- 异：
  - 物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的
  - 虚拟机的执行引擎是由自定义的，可自行制定指令集与执行引擎的结构体系，且能够执行不被硬件直接支持的指令集格式

b.有关Java虚拟机字节码执行引擎的**概念模型**

- 从外观上，所有Java虚拟机的执行引擎都是一致的。输入的是字节码文件，处理的是字节码解析的等效过程，输出的是执行结果
- 从实现上，执行引擎有多种执行Java代码的选择
  - 解释执行：通过解释器执行
  - 编译执行：通过即时编译器产生本地代码执行
  - 两者兼备，甚至还会包含几个不同级别的编译器执行引擎

------

2.**运行时栈帧结构**

> - **栈帧**（Stack Frame）：用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机[运行时数据区中的虚拟机栈](https://www.jianshu.com/p/cd93567ed868)的栈元素
>
> - 存储内容：方法的局部变量表、操作数栈、动态连接、方法返回地址一些额外的附加信息
>
> - 每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
>
> - 一个栈帧需要分配多少内存在程序编译期就已确定，而不会受到程序运行期变量数据的影响
>
> - 对于执行引擎来说，只有位于栈顶的栈帧（**当前栈帧**）才是有效的，即所有字节码指令只对当前栈帧进行操作，与当前栈帧相关联的方法称为**当前方法**
>
> - 
>
>   
>
>   在概念模型上，典型的栈帧结构如图：
>
>   ![image-20201210003135525](https://tva1.sinaimg.cn/large/0081Kckwly1gli2nkpv2lj30u00wljzg.jpg)

接下来详细介绍栈帧中各个部分的作用和数据结构

a.**局部变量表**

- 局部变量表（Local Variable Table）是一组变量值存储空间

- 作用：存放方法参数和方法内部定义的局部变量

- 分配时期：Java程序**编译**为Class文件时，会在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量

- 最小单位：

  变量槽

  - 大小：虚拟机规范中没有明确指明一个变量槽占用的内存空间大小，允许变量槽长度随着处理器、操作系统或虚拟机的不同而发生变化
    - 对于32位以内的数据类型（boolean、byte、char、short、int、float、reference、returnAddress ），虚拟机会为其分配一个变量槽空间
    - 对于64位的数据类型（long、double ），虚拟机会以高位对齐的方式为其分配两个连续的变量槽空间
  - 特点：可重用。为了尽可能节省栈帧空间，若当前字节码PC计数器的值已超出了某个变量的作用域，则该变量对应的变量槽可交给其他变量使用

- 访问方式：通过索引定位。索引值的范围是从0开始至局部变量表最大的变量槽数量

b.**操作数栈**

- 操作数栈（Operand Stack）是一个后入先出栈
- 作用：在方法**执行过程**中，写入（进栈）和提取（出栈）各种字节码指令
- 分配时期：同样的，在编译时会在方法的Code属性的max_locals数据项中确定操作数栈的最大深度

> 在方法执行的任何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值

- 栈容量：操作数栈的每一个元素可以是任意的Java数据类型——32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2
- 注意：操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译时编译器需要验证一次、在类校验阶段的数据流分析中还要再次验证

==c.**动态连接**（Dynamic  Linking）==：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接

> 静态解析和动态连接：Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数，这些符号引用：
>
> - 一部分会在类加载阶段或者第一次使用的时候就转化为直接引用（**静态解析**）
> - 另一部分会在每一次**运行期**间转化为直接引用（**动态连接**）

d.**方法返回地址**

- 方法退出的两种方式：
  - **正常完成出口**（Normal Method Invocation Completion）：执行中遇到任意一个方法返回的字节码指令；**可能会**给上层调用者传递返回值
  - **异常完成出口**（Abrupt Method Invocation Completion）：执行中遇到异常、且在本方法的异常表中没有搜索到匹配的异常处理器区处理；**不会**给上层调用者传递返回值
- 作用：无论哪种退出方式，在方法返回时都可能在栈帧中保存一些信息，用于恢复上层方法调用者的执行状态
  - 正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值
  - 异常退出时，通过异常处理器表来确定返回地址，栈帧中一般不会保存这部分信息
- 方法退出的执行操作：恢复上层方法的局部变量表和操作数栈、若有返回值把它压入调用者栈帧的操作数栈中、调整PC计数器的值以指向方法调用指令后面的一条指令等

e.**附加信息**：增加一些规范里没有描述的信息到栈帧之中，如与调试相关的信息

> 在实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部一起称为**栈帧信息**

------

3.**方法调用**

- 方法调用是最普遍、最频繁的操作（方法调用≠方法执行）

- 任务：确定被调用方法的版本，即调用哪一个方法，不涉及方法内部的具体运行过程

- 类型：

  - ==解析（Resolution）调用==

    ：

    - 特点：是静态过程；在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，而不会延迟到运行期再去完成，即**编译期可知、运行期不可变**
    - 适用对象：静态方法（与类型直接关联）、私有方法（在外部不可被访问），它们都不可能通过继承或其他方式重写其他版本

  - ==分派（Dispatch）调用==

    ：

    - 特点：可静可动
    - 类型：
      - **静态分派**：依赖静态类型来定位方法的执行版本；典型应用是**方法重载**；发生在编译阶段，不由Java虚拟机来执行
      - **动态分派**：依赖动态类型来定位方法的执行版本；典型应用是**方法重写**；发生在运行阶段，由Java虚拟机来执行
      - **单分派**：根据一个宗量对目标方法进行选择（方法的接受者与方法的参数统称为方法的宗量）
      - **多分派**：根据多于一个宗量对目标方法进行选择

[如何理解Java语言是一门静态多分派、动态单分派的语言？](https://blog.csdn.net/p10010/article/details/50456276)

---





# 理解JVM之程序编译&代码优化

#### 本篇将介绍程序编译时期的代码优化手段，分成两个阶段：

- 概述
- 早期（编译期）优化
- 晚期（运行期）优化

------

1.**概述**

a.由于对Java语言的编译期理解不同，可以分出几个时期：

- 前端编译器
  - 作用：把Java代码转变成字节码
  - 代表：Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）
  - 该时期的优化主要用于提升程序的编码效率
- 后端运行期编译器／JIT编译器
  - 作用：把字节码转变成本地机器码
  - 代表：HotSpot VM的C1、C2编译器
  - 该时期的优化主要用于提升程序的运行效率
- 静态提前编译器／AOT编译器
  - 作用：直接把Java代码编译成本地机器码
  - 代表：GNU Compiler for the Java（GCJ）、Excelsior JET

b.**Java即时编译器与C/C++静态编译器的对比**

- 即时编译器运行需要占用程序运行时间，使得优化手段受制于编译成本，否则用户将在启动程序察觉到重大延迟；而静态编译器的编译时间成本不是重点
- 静态编译器所有优化都在编译期完成，而即时编译器的动态性是把双刃剑，一方面要求虚拟机频繁进行动态检查从而消耗大量运行时间，而且难以全局优化、只能以激进优化来完成，另一方面拥有运行期性能监控的优化措施，如调用频率预测、分支频率预测、裁剪未被选择的分支等
- Java中使用虚方法的频率远大于C/C++，表示运行时对方法接收者进行多态选择的频率更大，因此在进行某些优化难度会更大
- Java在堆上进行对象的内存分配，而C/C++可在堆、栈上分配，减轻了内存回收的压力；且C/C++中主要由用户程序代码回收内存，不存在无用对象的筛选，相比于垃圾收集机制运行效率更高

------

2.**早期（编译期）优化**

> 几乎所有语言都提供一些**语法糖**来方便开发，或能提高效率、或能提升语法的严谨性、或能减少编码出错的机会，下面是几种常见语法糖：

- **泛型与类型擦除**
  - C#的泛型是**真实泛型**：无论在程序源码、编译后的IL、还是运行期的CLR中都是切实存在的，List＜int＞和List＜String＞在系统运行期生成，有自己的虚方法表和类型数据，属于不同的类型，这种实现称为**类型膨胀**
  - Java的泛型是**伪泛型**：只在程序源码中存在，在编译后的字节码文件中就已替换为原生类型，并在相应的地方插入了强制转型代码，因此ArrayList＜int＞与ArrayList＜String＞是同一个类，这种实现称为**类型擦除**
- [**自动装箱、拆箱**](https://droidyue.com/blog/2015/04/07/autoboxing-and-autounboxing-in-java/)
- **遍历循环**
- **条件编译**：使用条件为常量的if语句

[更多Java语法糖系列](https://www.jianshu.com/p/628568f94ef8)

------

3.**晚期（运行期）优化**

a.HotSpot虚拟机采用**解释器与编译器并存**的架构，交互情况：

- 当程序需要迅速启动和执行时，解释器可以先发挥作用，从而省去编译时间
- 程序运行后，随着时间的推移，编译器逐渐发挥作用，把更多代码编译成本地代码，从而获取更高的执行效率
- 如果程序运行环境受内存资源限制较大，可以用解释执行节约内存，反之可以用编译执行提升效率
- 解释器可作为编译器**激进优化**的逃生门，当激进优化不成立时，如加载新类后类型继承结构出现变化、出现罕见陷阱，可通过**逆优化**退回到解释状态继续执行。如图：

![image-20201210003224461](https://tva1.sinaimg.cn/large/0081Kckwly1gli2ofklhsj311k0j4grg.jpg)

解释器与编译器的交互

> 有上图可见，HotSpot虚拟机中内置了两个即时编译器：Client    Compiler（C1编译器和）和Server Compiler（C2编译器），搭配模式：
>
> - **混合模式**（Mixed    Mode）：默认采用解释器与其中一个编译器进行配合工作，虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式和编译器，用户可以使用`-client`或`-server`参数去强制指定虚拟机运行在Client模式或Server模式。
> - **解释模式**（Interpreted  Mode）：使用参数`-Xint`，编译器不工作，都使用解释方式执行。
> - **编译模式**（Compiled  Mode）：使用参数`-Xcomp`，优先采用编译方式执行，但解释器仍然要在编译无法进行的情况下介入执行过程。

b.HotSpot即时编译器的编译对象：**热点代码**

- 分类：

  - 被多次调用的**方法**：采用JIT编译方式，以整个方法作为编译对象
  - 被多次执行的**循环体**：采用OSR编译方式，发生在方法执行过程中，仍以整个方法作为编译对象

- 判断方式：通过

  热点探测

  - 基于采样的热点探测

    （Sample Based Hot Spot Detection）：周期性检查各个线程的栈顶，常出现在栈顶的方法就是热点方法

    - 好处：实现简单、高效、易于获取方法调用关系
    - 缺点：难以精确确认某个方法的热度、易受到线程阻塞或外界影响而扰乱热点探测

  - 基于==计数器==的热点探测

    （Counter Based Hot Spot Detection）：为每个方法建立计数器来统计方法的执行次数，执行次数超过一定的阈值就是热点方法

    - 优点：精确、严谨
    - 缺点：实现较麻烦、不能直接获取到方法的调用关系
    - 计数器类型：
      - **方法调用计数器**（Invocation  Counter）：统计方法被调用的次数，当计数器超过阈值会触发JIT编译
      - **回边计数器**（Back  Edge Counter）：统计方法中循环体代码执行的次数，当计数器超过阈值会触发OSR编译

c.HotSpot即时编译器的**编译过程**

- Client Compiler：主要进行局部优化、放弃耗时较长的全局优化。采用简单快速的三段式编译：
  - 第一个阶段：一个平台独立的前端把字节码构造成一种**高级中间代码表示**（HIR），在此之前会在字节码上完成一部分基础优化，如方法内联、常量传播等
  - 第二个阶段：一个平台相关的后端从HIR中产生**低级中间代码表示**（LIR），在此之前会在HIR上完成另外一些优化，如空值检查消除、范围检查消除等，以便让HIR达到更高效的代码表示形式
  - 第三个阶段：平台相关的后端使用线性扫描算法在LIR 上分配寄存器，并在LIR上做窥孔优化，然后产生机器代码。大致执行过程如图：

![image-20201210003258191](https://tva1.sinaimg.cn/large/0081Kckwly1gli2p00yrzj311y0mon5c.jpg)

- Server Compiler：专门面向

  服务端

  的典型应用并且特别为服务端的性能配置调整过，是一个充分优化过的高级编译器，体现在：

  - 会执行所有经典的优化动作：如无用代码消除、循环展开、循环表达式外提、消除公共子表达式、常量传播、基本块重排序等
  - 会实施与Java特性密切相关的优化技术：如范围检查消除、空值检查消除等
  - 根据解释器或Client Compiler提供的性能监控信息可能会进行一些不稳定的激进优化：如守护内联、分支频率预测等

> 另外，Server Compiler的寄存器分配器是一个全局图着色分配器，能够充分利用某些处理器架构上的大寄存器集合。虽然Server Compiler的编译时间比较缓慢，但是其编译速度远超于传统的静态优化编译器，且比Client Compiler编译输出的代码质量更高，能减少本地代码的执行时间，从而抵消了额外的编译时间开销。

d.HotSpot虚拟机即时编译器在生成代码时采用的代码**优化技术**：

![img](https://tva1.sinaimg.cn/large/0081Kckwly1gli2pbzookj31cn0u04qp.jpg)

其中几种最有代表性的优化技术：

- 语言无关的经典优化技术之一：

  公共子表达式消除

  （Common Subexpression Elimination）

  - 含义：若一个表达式E已经计算过且E中所有变量值未发生任何变化，则称E为公共子表达式，此时没必要花时间再次计算，直接用之前计算过的表达式结果代替E即可
  - 类型：
    - 局部公共子表达式消除：优化仅限于程序的基本块内
    - 全局公共子表达式消除：优化的范围涵盖了多个基本块

- 语言相关的经典优化技术之一 ：

  数组边界检查消除

  （Array Bounds Checking Elimination）

  - 若数组下标是个常量，只要在编译期根据数据流分析确定这个数组的长度，且判断得出该数组下标未越界，那么运行时无需再检查
  - 若数组访问发生在循环中且使用循环变量来进行数组访问，只要在编译期根据数据流分析确定循环变量的取值范围永远在区间[0，数组长度）内，那么在整个循环中无需再进行多次检查

- 最重要的优化技术之一：

  方法内联

  （Method Inlining）

  - 含义：把目标方法的代码复制到发起调用的方法之中，避免发生真实的方法调用
  - 主要目的：去除方法调用的成本，如建立栈帧等；为其他优化建立良好的基础，便于在更大范围上采取后续的优化手段、获取更好的优化效果

- 最前沿的优化技术之一：

  逃逸分析

  （Escape   Analysis）

  - 基本行为：分析对象动态作用域
  - 类型：
    - **方法逃逸**：一个对象在方法中被定义后，可能被外部方法所引用。如作为调用参数传递到其他方法中
    - **线程逃逸**：一个对象在方法中被定义后，能被外部线程访问到。如赋值给类变量或可以在其他线程中访问的实例变量
  - 对能够证明不会逃逸到方法或线程之外的对象可进行的优化手段：
    - **栈上分配**（Stack Allocation）：在栈上对该对象进行内存分配，此时该对象所占用的内存空间会随栈帧出栈而销毁，可减少垃圾收集系统的压力
    - **同步消除**（Synchronization Elimination）：在该对象上不会有读写竞争，可消除掉对该对象的同步措施，从而减少资源的消耗
    - **标量替换**（Scalar   Replacement）：若该对象可以进一步分解，那么直接创建它的若干个被这个方法使用到的成员变量来替换



作者：厘米姑娘
链接：https://www.jianshu.com/p/904c17f0d09e
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



# 理解JVM之内存模型&线程

#### 本篇将介绍虚拟机如何实现多线程、多线程之间由于共享和竞争数据而导致的一系列问题及解决方案。

- 概述
- Java内存模型
- Java与线程

------

**1.概述**

a.**多任务处理**的必要性：

- 充分利用计算机处理器的能力，避免处理器在磁盘I/O、网络通信或数据库访问时总是处于等待其他资源的状态。
- 便于一个服务端同时对多个客户端提供服务。通过指标**TPS**（Transactions Per Second）可衡量一个服务性能的高低好坏，它表示每秒服务端平均能响应的请求总数，进而体现出程序的并发能力。

b.**硬件的效率与一致性**

> 为了更好的理解Java内存模型，先理解物理计算机中的并发问题，两者有很高的可比性。

为了平衡计算机的存储设备与处理器的运算速度之间几个数量级的差距，引入一层**高速缓存**（Cache）来作为内存与处理器之间的缓冲：

- 将运算需要使用到的数据复制到缓存中，让运算能快速进行；
- 当运算结束后再从缓存同步回内存之中，而无须让处理器等待缓慢的内存读写。

但是基于高速缓存的存储交互在多处理器系统中会带来**缓存一致性**（Cache Coherence）的问题。这是因为每个处理器都有自己的高速缓存，而它们又共享同一**主内存**（Main Memory），当多个处理器的运算任务都涉及同一块主内存区域时，就可能导致各自的缓存数据不一致。解决办法就是需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作。如下图。

![image-20201210003358962](https://tva1.sinaimg.cn/large/0081Kckwly1gli2q22ol5j31220g40zl.jpg)

因此，这里所说的**内存模型**可以理解为：在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。

------

2.**Java内存模型**（Java  Memory  Model，JMM）

a.**目的**：屏蔽掉各种硬件和操作系统的内存访问差异，实现Java程序在各种平台下都能达到一致的内存访问效果。

b.**方法**：通过定义程序中各个**变量**的**访问规则**，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。

> **注意**：这里的变量与Java中说的变量不同，而指的是实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。

c.**结构**：模型结构如图，和上张图进行类比。

![image-20201210003410206](https://tva1.sinaimg.cn/large/0081Kckwly1gli2q8unm1j31180hcn3y.jpg)

- **主内存**（Main Memory）：所有变量的存储位置。直接对应于物理硬件的内存。

> **注意**：这里的主内存、工作内存与[要点提炼| 理解JVM之内存管理](https://www.jianshu.com/p/cd93567ed868)说的Java内存区域中的Java堆、栈、方法区等并不是同一个层次的内存划分。

- **工作内存**（Working Memory）：每条线程还有自己的工作内存，用于保存被该线程使用到的变量的主内存副本拷贝。为了获取更好的运行速度，虚拟机可能会让工作内存优先存储于寄存器和高速缓存中。

> **注意**：
>
> - 线程对变量的所有操作都**必须**在工作内存中进行，而不能直接读写主内存中的变量。
> - 不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递**必须**通过主内存来完成。

- 交互协议

  ：用于规定一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节。共有8种操作：

  - ①用于主内存变量：
  - **锁定**（`lock`）：把变量标识为一条线程独占的状态。
  - **解锁**（`unlock`）：把处于锁定状态的变量释放出来。
  - **读取**（`read`）：把变量的值从主内存传输到线程的工作内存中，以便随后的`load`动作使用。
  - **载入**（`load`）：把`read`操作从主内存中得到的变量值放入工作内存的变量副本中。
  - ②用于工作内存变量：
  - **使用**（`use`）：把工作内存中一个变量的值传递给执行引擎。
  - **赋值**（`assign`）：把从执行引擎接收到的值赋给工作内存的变量。
  - **存储**（`store`）：把工作内存中变量的值传送到主内存中，以便随后的`write`操作使用。
  - **写入**（`write`）：把`store`操作从工作内存中得到的变量的值放入主内存的变量中。

> **结论**：注意是顺序非连续
>
> - 如果要把变量从主内存**复制**到工作内存，那就要**顺序**地执行`read`和`load`。
> - 如果要把变量从工作内存**同步**回主内存，就要**顺序**地执行`store`和`write`。

d.确保并发操作安全的**原则**：

①在Java内存模型中规定了执行上述8种基本操作时需要满足如下规则：

- 不允许`read`和`load`、`store`和`write`操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。
- 不允许一个线程丢弃它的最近的`assign`操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。
- 不允许一个线程无原因地，即没有发生过任何`assign`操作就把数据从线程的工作内存同步回主内存中。
- 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（`load`或`assign`）的变量，即对一个变量实施`use`、`store`操作之前必须先执行过了`assign`和`load`操作。
- 一个变量在同一个时刻只允许一条线程对其进行`lock`操作，但`lock`操作可以被同一条线程重复执行多次，多次执行`lock`后，只有执行相同次数的`unlock`操作，变量才会被解锁。
- 如果对一个变量执行`lock`操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行`load`或`assign`操作初始化变量的值。
- 如果一个变量事先没有被`lock`操作锁定，那就不允许对它执行`unlock`操作，也不允许去`unlock`一个被其他线程锁定住的变量。
- 对一个变量执行`unlock`操作之前，必须先把此变量同步回主内存中。

> 可见这么多规则非常繁琐，实践也麻烦，下面再介绍一个等效判断原则--先行发生原则。

②**先行发生原则**：是Java内存模型中定义的两项操作之间的偏序关系。下面例举一些“天然的”先行发生关系，无须任何同步器协助就已经存在，可以在编码中直接使用。

- **程序次序规则**（Program Order Rule）：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。
- **管程锁定规则**（Monitor Lock Rule）：一个unlock操作先行发生于后面对**同一个**锁的lock操作。
- **volatile变量规则**（Volatile Variable Rule）：对一个volatile变量的**写**操作先行发生于后面对这个变量的**读**操作。
- **线程启动规则**（Thread Start Rule）：Thread对象的`start()`先行发生于此线程的每一个动作。
- **线程终止规则**（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测.可通过`Thread.join()`结束、`Thread.isAlive()`的返回值等手段检测到线程已经终止执行。
- **线程中断规则**（Thread Interruption Rule）：对线程`interrupt()`的调用先行发生于被中断线程的代码检测到中断事件的发生。可通过`Thread.interrupted()`检测到是否有中断发生。
- **对象终结规则**（Finalizer Rule）：一个对象的初始化完成先行发生于它的`finalize()`的开始。
- **传递性**（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A一定先行发生于操作C。

e.Java内存模型保证并发过程的原子性、可见性和有序性的措施：

- 原子性

  （Atomicity）：一个操作要么都执行要么都不执行。

  - 可直接保证的原子性变量操作有：`read`、`load`、`assign`、`use`、`store`和`write`，因此可认为基本数据类型的访问读写是具备原子性的。
  - 若需要保证更大范围的原子性，可通过更高层次的字节码指令`monitorenter`和`monitorexit`来隐式地使用`lock`和`unlock`这两个操作，反映到Java代码中就是同步代码块`synchronized`关键字。

- 可见性

  （Visibility）：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。

  - 通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现。
  - 提供三个关键字保证可见性：`volatile`能保证新值能**立即**同步到主内存，且每次使用前立即从主内存刷新；`synchronized`对一个变量执行unlock操作之前可以先把此变量同步回主内存中；被`final`修饰的字段在构造器中一旦初始化完成且构造器没有把`this`的引用传递出去，就可以在其他线程中就能看见final字段的值。

- 有序性

  （Ordering）：程序代码按照指令顺序执行。

  - 如果在本线程内观察，所有的操作都是有序的，指“线程内表现为串行的语义”；如果在一个线程中观察另一个线程，所有的操作都是无序的，指“指令重排序”现象和“工作内存与主内存同步延迟”现象。
  - 提供两个关键字保证有序性：`volatile` 本身就包含了禁止指令重排序的语义；`synchronized`保证一个变量在同一个时刻只允许一条线程对其进行lock操作，使得持有同一个锁的两个同步块只能串行地进入。

------

3.**Java与线程**

a.**线程实现的三种方式**

①使用**内核线程**（Kernel-Level Thread,KLT）

- **定义**：直接由操作系统内核支持的线程。

- **原理**：由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身， 这样操作系统就有能力同时处理多件事情。

- **多线程内核**（Multi-Threads Kernel）：支持多线程的内核

- 轻量级进程

  （Light Weight Process,LWP）：内核线程的一种高级接口

  - **优点**：每个轻量级进程都由一个内核线程支持，因此每个都成为一个独立的调度单元，即使有一个轻量级进程在系统调用中阻塞，也不会影响整个进程继续工作。
  - **缺点**：由于基于内核线程实现，所以各种线程操作（创建、析构及同步）都需要进行系统调用，代价相对较高，需要在**用户态**（User Mode）和**内核态**（Kernel Mode）中来回切换；另外，一个系统支持轻量级进程的数量是有限的。
  - **一对一线程模型**：轻量级进程与内核线程之间1：1的关系，如图所示

![image-20201210003427068](https://tva1.sinaimg.cn/large/0081Kckwly1gli2qjyk3pj31200pswrh.jpg)

②使用**用户线程**（User Thread,UT）

- **定义**：广义上认为一个线程不是内核线程就是用户线程；狭义上认为用户线程指的是完全建立在用户空间的线程库上，而系统内核不能感知线程存在的实现。
- **优点**：由于用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助，甚至可以不需要切换到内核态，所以操作非常快速且低消耗的，且可以支持规模更大的线程数量。
- **缺点**：由于没有系统内核的支援，所有的线程操作都需要用户程序自己处理，线程的创建、切换和调度都是需要考虑的问题，实现较复杂。
- **一对多的线程模型进程**：进程与用户线程之间1：N的关系，如图所示

![image-20201210003438572](https://tva1.sinaimg.cn/large/0081Kckwly1gli2qq7xidj312y0piaj2.jpg)

③使用**用户线程加轻量级进程混合**

- **定义**：既存在用户线程，也存在轻量级进程。
- **优点**：用户线程完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发；操作系统提供支持的轻量级进程作为用户线程和内核线程之间的桥梁，可以使用内核提供的线程调度功能及处理器映射，且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险。
- **多对多的线程模型**：用户线程与轻量级进程的数量比不定，即用户线程与轻量级进程之间N：M的关系，如图所示

![image-20201210003510406](https://tva1.sinaimg.cn/large/0081Kckwly1gli2ranppqj311w0pkws2.jpg)

> 那么Java线程的实现是选择哪一种呢？答案是**不确定**的。操作系统支持怎样的线程模型，在很大程度上决定了Java虚拟机的线程是怎样映射的。线程模型只对线程的并发规模和操作成本产生影响，而对Java程序的编码和运行过程来说，这些差异都是透明的。

b.**Java线程调度的两种方式**

> 线程调度：指系统为线程分配处理器使用权的过程。

①**协同式线程调度**（Cooperative Threads-Scheduling）

- 由**线程本身**来控制线程的执行时间。线程把自己的工作执行完后，要主动通知系统切换到另外一个线程上。
- **好处**：实现简单；切换操作自己可知，不存在线程同步的问题。
- **坏处**：线程执行时间不可控，假如一个线程编写有问题一直不告知系统进行线程切换，那么程序就会一直被阻塞。

②**抢占式线程调度**（Preemptive Threads-Scheduling）

- 由**系统**来分配每个线程的执行时间。
- **好处**：线程执行时间是系统可控的，不存在一个线程导致整个进程阻塞的问题。
- 可以通过设置线程**优先级**，优先级越高的线程越容易被系统选择执行。

> 但是线程优先级并不是太靠谱，一方面因为Java的线程是通过映射到系统的原生线程上来实现的，所以线程调度最终还是取决于操作系统，在一些平台上不同的优先级实际会变得相同；另一方面优先级可能会被系统自行改变。

c.**线程的五种状态**

在任意一个时间点，一个线程只能有且只有其中的一种状态：

- **新建**（New）：线程创建后尚未启动

- **运行**（Runable）：包括正在执行（Running）和等待着CPU为它分配执行时间（Ready）两种

- 无限期等待

  （Waiting）：该线程不会被分配CPU执行时间，要等待被其他线程显式地唤醒。以下方法会让线程陷入无限期等待状态：

  - 没有设置Timeout参数的`Object.wait()`
  - 没有设置Timeout参数的`Thread.join()`
  - `LockSupport.park()`

- 限期等待

  （Timed Waiting）：该线程不会被分配CPU执行时间，但在一定时间后会被系统自动唤醒。以下方法会让线程进入限期等待状态：

  - `Thread.sleep()`
  - 设置了Timeout参数的`Object.wai()`
  - 设置了Timeout参数的`Thread.join()`
  - `LockSupport.parkNanos()`
  - `LockSupport.parkUntil()`

- **阻塞**（Blocked）：线程被阻塞

> **注意区别**：
>
> - 阻塞状态：在等待获取到一个**排他锁**，在另外一个线程放弃这个锁的时候发生；
> - 等待状态：在等待一段**时间**或者**唤醒动作**的发生，在程序等待进入同步区域的时候发生。

- **结束**（Terminated）：线程已经结束执行

下图是线程状态之间的转换：

![image-20201210003521600](https://tva1.sinaimg.cn/large/0081Kckwly1gli2rhm6kej311i0mak00.jpg)



作者：厘米姑娘
链接：https://www.jianshu.com/p/90a036212cb4
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



# 理解JVM之线程安全&锁优化

#### 本篇将介绍线程安全所涉及的概念和分类、同步实现的方式及虚拟机的底层运作原理，以及虚拟机为了实现高效并发所采取的一系列锁优化措施。

- 概述
- 线程安全
- 锁优化

------

**1.概述**

> 在[要点提炼| 理解JVM之内存模型&线程](https://www.jianshu.com/p/90a036212cb4)中主要介绍了虚拟机如何实现『并发』，现在的关注点是虚拟机如何实现『高效』。

------

**2.线程安全**

> 在实现高效之前，首先需要保证并发的正确性，因此本节先介绍线程安全。

a.**定义**：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。

> **要求线程安全的代码都必须具备一个特征**：
>  代码本身封装了所有必要的正确性保障手段（如互斥同步等），令调用者无须关心多线程的问题，更无须自己采取任何措施来保证多线程的正确调用。

b.**分类**：按照线程安全的程度由强至弱分成五类

- 不可变

  ：外部的可见状态永远不会改变，在多个线程之中永远是一致的状态。

  - **一定**是线程安全的

  - 如何实现

    ：

    - 如果共享数据是一个**基本数据类型**，只要在定义时用`final`关键字修饰；
    - 如果共享数据是一个**对象**，最简单的方法是把对象中带有状态的变量都声明为`final`。

- **绝对线程安全**：完全满足之前给出的线程安全的定义，即达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”。

- 相对线程安全

  ：能保证对该对象单独的操作是线程安全的，在调用时无需做额外保障措施，但对于一些特定顺序的连续调用，可能需要在调用端使用额外的同步措施来保证调用的正确性。

  - 是通常意义上所讲的线程安全
  - 大部分的线程安全类都属于这种类型，如`Vector`、`HashTable`、`Collections#synchronizedCollection()`包装的集合...
  - 有关**实现**在下一小节细说。

- 线程兼容

  ：对象本身非线程安全的，但可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，

  - 是通常意义上所讲的非线程安全
  - Java API中大部分类都是属于线程兼容的，如`ArrayList`和`HashMap`...

- **线程对立**：无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。

c.线程安全的**实现**

> 可分成两大手段，本篇重点在虚拟机本身
>
> - 通过代码编写实现线程安全
> - 通过虚拟机本身实现同步与锁

①**互斥同步**(Mutual Exclusion＆Synchronization）

- 含义

  ：

  - **同步**：在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个线程使用。
  - **互斥**：是实现同步的一种**手段**，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。

> 互斥是因，同步是果；互斥是方法，同步是目的。

- 属于**悲观**并发策略，即认为只要不做正确的同步措施就肯定会出现问题，因此无论共享数据是否真的会出现竞争，都要加锁。

- 最大的**问题**是进行线程阻塞和唤醒所带来的性能问题，也称为**阻塞同步**（Blocking Synchronization）

- 手段

  ：

  - 使用

    ```
    synchronized
    ```

    关键字：

    - **原理**：编译后会在同步块的**前后**分别形成`monitorenter`和`monitorexit`这两个字节码指令，并通过一个`reference`类型的参数来指明要锁定和解锁的对象。若明确指定了对象参数，则取该对象的`reference`；否则，会根据`synchronized`修饰的是实例方法还是类方法去取对应的对象实例或Class对象来作为锁对象。
    - **过程**：执行`monitorenter`指令时先要尝试获取对象的锁。若该对象没被锁定或者已被当前线程获取，那么锁计数器+1；而在执行`monitorexit`指令时，锁计数器-1；当锁计数器=0时，锁就被释放；若获取对象锁失败，那当前线程会一直被阻塞等待，直到对象锁被另外一个线程释放为止。
    - **特别注意**： `synchronized`同步块对同一条线程来说是**可重入**的，不会出现自我锁死的问题；还有，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。

  - 使用重入锁

    ```
    ReentrantLock
    ```

    ：

    - **相同**：用法与`synchronized`很相似，且都可重入。

    - 与

      ```
      synchronized
      ```

      的

      不同

      ：

      - **等待可中断**：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。
      - **公平锁**：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。而`synchronized`是非公平的，即在锁被释放时，任何一个等待锁的线程都有机会获得锁。`ReentrantLock`默认情况下也是非公平的，但可以通过带布尔值的构造函数改用公平锁。
      - **锁绑定多个条件**：一个`ReentrantLock`对象可以通过多次调用`newCondition()`同时绑定多个`Condition`对象。而在`synchronized`中，锁对象的`wait()`和`notify()`或`notifyAl()`只能实现一个隐含的条件，若要和多于一个的条件关联不得不额外地添加一个锁。

    - **选择**：在`synchronized`能实现需求的情况下，优先考虑使用它来进行同步。下两张图是两者在不同处理器上的吞吐量对比。

![image-20201210003826563](https://tva1.sinaimg.cn/large/0081Kckwly1gli2up9e8wj30u00wo4ay.jpg)

②**非阻塞同步**（Non-Blocking Synchronization）：

- 基于冲突检测的**乐观**并发策略，即先进行操作，若无其他线程争用共享数据，操作成功；反之产生了冲突再去采取其他的补偿措施。

- 为了保证

  操作

  和

  冲突检测

  这两步具备原子性，需要用到硬件指令集，比如：

  - **测试并设置**（Test-and-Set）
  - **获取并增加**（Fetch-and-Increment）
  - **交换**（Swap）
  - **比较并交换**==（Compare-and-Swap,CAS）==
  - **加载链接/条件存储**（Load-Linked/Store-Conditional,LL/SC）

③**无同步方案**

- **定义**：不用同步的方式保证线程安全，因为有些代码天生就是线程安全的。下面举两个例子：

- ①

  可重入代码

  （Reentrant Code）/

  纯代码

  （Pure Code）

  - **含义**：可在代码执行的任何时刻中断它去执行另外一段代码，当控制权返回后原来的程序并不会出现任何错误。
  - **共同特征**：不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法...
  - **判定依据**：如果一个方法，它的返回结果是可预测的，只要输入相同的数据就都能返回相同的结果，就满足可重入性。

> 满足可重入性的代码**一定**是线程安全的，反之，满足线程安全的代码**不一定**是可重入的。

- ②

  线程本地存储

  （Thread Local Storage）

  - **含义**：把共享数据的可见范围限制在同一个线程之内，无须同步就能保证线程之间不出现数据争用的问题。
  - 使用`ThreadLocal`类可实现线程本地存储的功能：每个线程的`Thread`对象中都有一个**ThreadLocalMap**对象，它存储了一组以**ThreadLocal.threadLocalHashCode**为key、以本地线程变量为value的键值对，而**ThreadLocal**对象就是当前线程的**ThreadLocalMap**的访问入口，也就包含了一个独一无二的**threadLocalHashCode**值，通过这个值就可以在线程键值值对中找回对应的本地线程变量。

------

**3.锁优化**

> 解决并发的正确性之后，为了能在线程之间更『高效』地共享数据、解决竞争问题、提高程序的执行效率，下面介绍五种锁优化技术。

a.**适应性自旋**（Adaptive Spinning）

- **背景**：互斥同步在实现阻塞和唤醒时需要==挂起线程和恢复线程==的操作，都需要转入内核态中完成，很影响系统的并发性能；同时，在许多应用上共享数据的锁定状态只是暂时，没必要去挂起和恢复线程。

- 自旋锁

  ：当物理机器有多个处理器使得多个线程同时并行执行时，先让后请求锁的线程等待，但==不放弃处理器的执行时间==，看看持有锁的线程是否很快就会释放锁，这时只需让线程执行一个忙循环，即自旋。

  - **注意**：自旋等待**不能**代替阻塞，它虽然能避免线程切换的开销，但会占用处理器时间，因此自旋等待的时间**必须**要有一定的限度，如果自旋超过了限定的次数仍未成功获锁，就需要挂线程了。

- 自适应自旋锁

  ：自旋的时间不再固定，而是由该锁上的上次自旋时间及锁的拥有者的状态共同决定。具体表现是：

  - 如果对于某个锁，自旋等待刚刚成功获得，且持有锁的线程正在运行中，那么虚拟机很可能允许自旋等待的时间更久点。
  - 如果对于某个锁，自旋很少成功获得过，那么很可能以后将省略自旋等待这个锁，避免浪费处理器资源。

b.**锁消除**（Lock Elimination）

- **锁消除**：指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。
- **判定依据**：如果一段代码中**堆**上的所有数据都不会逃逸出去被其他线程访问到，可把它们当做**栈**上数据对待，即线程私有的，无须同步加锁。

c.**锁粗化**（Lock Coarsening）

一般情况下，会将同步块的作用范围限制到只在共享数据的实际作用域中才进行同步，使得需要同步的操作数量尽可能变小，保证就算存在锁竞争，等待锁的线程也能尽快拿到锁。

但==如果反复操作对同一个对象进行加锁和解锁，即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗，此时，虚拟机将会把加锁同步的范围粗化到整个操作序列的外部，这样只需加一次锁==。

d.**轻量级锁**（Lightweight Locking）

- **目的**：在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，注意不是用来代替重量级锁的。

> 首先先理解HotSpot虚拟机的对象头的内存布局：分为两部分
>
> - 第一部分用于存储对象自身的运行时数据，这部分被称为Mark Word，是实现轻量级锁和偏向锁的关键。如哈希码、GC分代年龄等。
> - 另外一部分用于存储指向方法区对象类型数据的指针，如果是数组对象还会有一个额外的部分用于存储数组长度。

![image-20201210003848797](https://tva1.sinaimg.cn/large/0081Kckwly1gli2v38wc9j30up0u0n8b.jpg)

之后虚拟机会尝试用CAS操作将对象的Mark Word更新为指向Lock Record的指针。若更新动作成功，那么当前线程就拥有了该对象的锁，且对象Mark Word的锁标志位变为`00`，即处于轻量级锁定状态；反之，虚拟机会先检查对象的Mark Word是否指向当前线程的栈帧，若当前线程已有该对象的锁，可直接进入同步块继续执行，否则说明改对象已被其他线程抢占。如下图。

![image-20201210003902395](https://tva1.sinaimg.cn/large/0081Kckwly1gli2vb2yhaj312q0lqgqo.jpg)

> 另外，如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志位变为`10`，Mark Word中存储的就是指向重量级锁的指针，后面等待锁的线程也要进入阻塞状态。

- **解锁过程**：若对象的Mark Word仍指向着线程的Lock Record，就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来。若替换成功，那么就完成了整个同步过程；反之，说明有其他线程尝试获取该锁，那么就要在释放锁的同时唤醒被挂起的线程。
- **优点**：因为对于绝大部分的锁，在整个同步周期内都是不存在竞争的，所以轻量级锁通过使用CAS操作消除同步使用的互斥量。

e.**偏向锁**（Biased Locking）

- **目的**：消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。
- **含义**：偏向锁==会偏向于第一个获得它的线程==，如果在后面的执行中该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。
- **加锁过程**：启用偏向锁的锁对象在第一次被线程获取时，Mark Word的锁标志位会被设置为`01`，即偏向模式，同时使用CAS操作把获取到这个锁的线程ID记录在对象的Mark Word中。若操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时都可不再进行任何同步操作。
- **解锁过程**：当有另外的线程去尝试获取这个锁时，根据锁对象目前是否处于被锁定的状态，撤销偏向后恢复到未锁定`01`或轻量级锁定`00`的状态，后续的同步操作就如轻量级锁执行过程。如下图。

![image-20201210003914039](https://tva1.sinaimg.cn/large/0081Kckwly1gli2vj26vtj312c0k0n6k.jpg)

- **优点**：可提高带有同步但无竞争的程序性能，但若程序中大多数锁总被多个线程访问，此模式就没必要了。



作者：厘米姑娘
链接：https://www.jianshu.com/p/ca8801044352
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



---

- https://blog.csdn.net/qq_41701956/article/details/81664921

![img](https://tva1.sinaimg.cn/large/0081Kckwly1gli2xavyzxj30uj0u07mn.jpg)


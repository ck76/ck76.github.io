[TOC]

## C++ 引用与指针的比较

引用是 C++ 中的概念，初学者容易把引用和指针混淆一起。

一下程序中，n 是m的一个引用（reference），m 是被引用物（referent）。

```c++
int m; 
int &n = m; 
```

n 相当于 m 的别名（绰号），对 n 的任何操作就是对m的操作。

所以 n 既不是m的拷贝，也不是指向 m 的指针，其实n就是 m 它自己。

引用的规则：

- （1）引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。
- （2）不能有 NULL 引用，引用必须与合法的存储单元关联（指针则可以是 NULL）。
- （3）一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。

以下示例程序中，k 被初始化为i的引用。

语句 k = j 并不能将 k 修改成为j的引用，只是把k的值改变成为 6。

由于 k 是 i 的引用，所以i的值也变成了 6。

```c++
int i = 5; 
int j = 6; 
int &k = i; 
k = j; // k 和 i 的值都变成了 6;
```

引用的主要功能是传递函数的参数和返回值。

C++ 语言中，函数的参数和返回值的传递方式有三种：值传递、指针传递和引用传递。

以下是"值传递"的示例程序。

由于 Func1 函数体内的 x 是外部变量 n 的一份拷贝，改变 x 的值不会影响 n, 所以 n 的值仍然是 0。

```c++
void Func1(int x) 
{ 
    x = x + 10; 
} 
... 
int n = 0; 
Func1(n); 
cout << "n = " << n << endl; // n = 0 
```

以下是"指针传递"的示例程序。

由于 Func2 函数体内的 x 是指向外部变量 n 的指针，改变该指针的内容将导致 n 的值改变，所以 n 的值成为 10。

```c++
void Func2(int *x) 
{ 
    (* x) = (* x) + 10; 
} 
... 
int n = 0; 
Func2(&n); 
cout << "n = " << n << endl; // n = 10 
```

以下是"引用传递"的示例程序。

由于 Func3 函数体内的 x 是外部变量 n 的引用，x 和 n 是同一个东西，改变 x 等于改变 n，所以 n 的值成为 10。

```c++
void Func3(int &x) 
{ 
    x = x + 10; 
} 
... 
int n = 0; 
Func3(n); 
cout << "n = " << n << endl; // n = 10
```

对比上述三个示例程序，会发现"引用传递"的性质象"指针传递"，而书写方式象"值传递"。

**实际上"引用"可以做的任何事情"指针"也都能够做，为什么还要"引用"这东西？**

答案是"用适当的工具做恰如其分的工作"。

指针能够毫无约束地操作内存中的任何东西，尽管指针功能强大，但是非常危险。

**如果的确只需要借用一下某个对象的"别名"，那么就用"引用"，而不要用"指针"，以免发生意外。**



- <https://www.runoob.com/w3cnote/cpp-difference-between-pointers-and-references.html>
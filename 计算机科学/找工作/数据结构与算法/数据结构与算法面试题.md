[TOC]

# 数据结构与算法

## 一、概念性

### 【2】怎么理解数据结构？

> 思路：数据结构的定义、分类
>
> 参考回答：研究数据的逻辑结构和物理结构以及它们之间相互关系，并对这种结构定义相应的运算，而且确保经过这些运算后所得到的新结构仍然是原来的结构类型。
>
> - 按照逻辑结构分类
>   - 线性结构：线性表、栈、队列
>   - 非线性结构：树、图
> - 按照存储结构分为顺序结构、链式结构、索引结构、哈希结构



### 【2】迭代和递归的特点，并比较优缺点

> - 技术点：递归和循环
> - 参考回答：递归和迭代都是循环的一种，特点：
>   - 递归就是通过重复调用函数自身实现循环；满足终止条件时会逐层返回来结束循环
>   - 迭代通过函数内某段代码实现循环；使用计数器结束循环

|      | 优点                         | 缺点                                                         |
| ---- | ---------------------------- | ------------------------------------------------------------ |
| 递归 | 代码更简洁清晰，可读性更好   | 需要调用函数，会造成空间的浪费；使用栈机制，循环次数太多易造成堆栈溢出 |
| 迭代 | 效率高；无额外开销，节省空间 | 代码不如递归简洁                                             |



### 【3】了解哪些查找算法，时间复杂度都是多少？

| 查找                 | 平均时间复杂度 | 查找条件               | 算法描述                                                     |
| -------------------- | -------------- | ---------------------- | ------------------------------------------------------------ |
| 顺序查找             | O(n)           | 无序或有序队列         | 按顺序比较每个元素，直到找到关键字为止                       |
| 二分查找（折半查找） | O(logn)        | 有序数组               | 查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。　如果在某一步骤数组为空，则代表找不到。 |
| 二叉排序树查找       | O(logn)        | 二叉排序树             | 在二叉查找树b中查找x的过程为：1. 若b是空树，则搜索失败2. 若x等于b的根节点的数据域之值，则查找成功；3. 若x小于b的根节点的数据域之值，则搜索左子树4. 查找右子树。 |
| 哈希表法（散列表）   | O(1)           | 先创建哈希表（散列表） | 根据键值方式(Key value)进行查找，通过散列函数，定位数据元素。 |
| 分块查找             | O(logn)        | 无序或有序队列         | 将n个数据元素"按块有序"划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须"按块有序"；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……。然后使用二分查找及顺序查找。 |



### 【4】了解哪些排序算法，并比较一下，以及适用场景

<img src="http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/VZ4iMbv5C*wHe7ZkHrr8ET.WQQbZJhw.luEFOYCg4YU!/r/dLkAAAAAAAAA" alt="排序算法复杂度" style="zoom:77%;" />

| 名称     | 特点                                                         | 适用                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 冒泡     | 重复走访要排序的数列，一次比较两个元素，若较小元素在后则交换，能看到越小的元素会经由交换慢慢浮到数列的顶端 | 数据规模较小                                                 |
| 简单选择 | 每次都在未排序序列中找最小元素                               | 数据规模较小且对稳定性有要求                                 |
| 直接插入 | 对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入 | 数据规模较小且待排序列基本有序                               |
| 希尔     | 将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序 | 数据规模较大                                                 |
| 归并     | 先使每个子序列有序，再使子序列段间有序                       | 数据规模较大且对稳定性有要求                                 |
| 堆       | 近似完全二叉树的结构，子结点的键值或索引总是小于（或大于）其父节点 | 数据规模较大，相比快排好处是不会出现最坏情况、需要的辅助空间少 |
| 快速     | 取一个记录作为枢轴，经过一趟排序将整段序列分为两个部分，使得数轴左侧都小于枢轴、右侧都大于枢轴；再对这两部分继续进行排序使整个序列达到有序 | 数据规模较大且待排序列无序                                   |



### 【5】快排的基本思路是什么？最差的时间复杂度是多少？如何优化？

> 快速排序使用分治的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字均比另一部分记录的关键字小；再分别对这两部分记录继续进行排序，以达到整个序列有序的目的。当待排序列有序时会出现最坏时间复杂度O(n^2)。几种优化方式：
>
> > 快速排序的最好情况： 
> > 快速排序的最好情况是每次都**【划分后左右子序列的大小都相等】**，其运行的时间就为O(N*logN)
> >
> > 快速排序的最坏情况： 
> > 快速排序的最坏的情况就是**【完全正序或者倒序】**，这时候其运行时间就变为O(N*N)
> >
> > 快速排序的平均情况： 
> >
> > 平均情况下是O(N*logN)
>
> - 当待排序序列的长度较小时采用直接插入排序
> - 优化所选取数轴的计算方法，如三数取中
> - 迭代取代递归，效率高
> - 存储数轴值，节省无必要的交换
>
> [推荐阅读](https://www.cnblogs.com/penghuwan/p/7883076.html?utm_source=tuicool&utm_medium=referral)



### 【6】什么是红黑树？

> 红黑树是一种自平衡二叉查找树，包含性质：
>
> - 节点是红色或黑色
> - 根节点是黑色
> - 叶子节点是黑色
> - 每个红色节点的两个子节点都是黑色
> - 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点



### 【7】海量数据处理

> - 技术点：海量数据问题
> - 思路：分治、哈希、bit、堆
> - 参考回答：[海量数据处理面试题集锦](https://blog.csdn.net/v_july_v/article/details/6685962)



## 二、排序

- [博客园图解排序](https://www.cnblogs.com/chengxiao/p/6129630.html)

### 【1】冒泡排序

> 比较两个相邻的元素，将值大的元素交换至右端。 就像冒泡一样，一个泡从水底逐渐冒上来。

```java
 public static void main(String[] args) {
        int bubblesort[]= new int[]{12, 33, 5, 8, 67};
        for(int i=0;i<bubblesort.length-1;i++){//外层循环控制循环趟数
            for (int j=0;j<bubblesort.length-1-i;j++){//内层循环控制每个泡冒到顶上比较的次数
                if(bubblesort[j]>bubblesort[j+1]){
                    int temp=bubblesort[j+1];
                    bubblesort[j+1]=bubblesort[j];
                    bubblesort[j]=temp;
                }
            }
        }
    }
```



### 【2】快速排序

```java
public class QuickSort {
    public static void main(String[] args) {
        int[] a={1,5,2,4,6,7};
        quickSort(a,0,a.length-1);
        System.out.println(Arrays.toString(a));
    }

    static void quickSort(int[] array, int left, int right) {
        if (array != null || array.length >= 1) {

            int temp = array[left];//基准数
            int i = left;
            int j = right;
            int swap;

            while (i < j) {
                //顺序很重要，要先从右边开始找
                while (array[j] >= temp && i < j) {
                    j--;
                }
                //再找右边的
                while (array[i] <= temp && i < j) {
                    i++;
                }
                //交换两个数在数组中的位置
                if (i < j) {
                    swap = array[i];
                    array[i] = array[j];
                    array[j] = swap;
                }
            }

            //最终将基准数归位
            array[i] = temp;
            quickSort(array, left, i - 1);//继续处理左边的，这里是一个递归的过程
            quickSort(array, i + 1, right);//继续处理右边的 ，这里是一个递归的过程
        }
    }
}
```

```c
void sort(int *a, int left, int right)
{
    if(left >= right)/*如果左边索引大于或者等于右边的索引就代表已经整理完成一个组了*/
    {
        return ;
    }
    int i = left;
    int j = right;
    int key = a[left];
     
    while(i < j)                               /*控制在当组内寻找一遍*/
    {
        while(i < j && key <= a[j])
        /*而寻找结束的条件就是，1，找到一个小于或者大于key的数（大于或小于取决于你想升
        序还是降序）2，没有符合条件1的，并且i与j的大小没有反转*/ 
        {
            j--;/*向前寻找*/
        }
         
        a[i] = a[j];
        /*找到一个这样的数后就把它赋给前面的被拿走的i的值（如果第一次循环且key是
        a[left]，那么就是给key）*/
         
        while(i < j && key >= a[i])
        /*这是i在当组内向前寻找，同上，不过注意与key的大小关系停止循环和上面相反，
        因为排序思想是把数往两边扔，所以左右两边的数大小与key的关系相反*/
        {
            i++;
        }
         
        a[j] = a[i];
    }
     
    a[i] = key;/*当在当组内找完一遍以后就把中间数key回归*/
    sort(a, left, i - 1);/*最后用同样的方式对分出来的左边的小组进行同上的做法*/
    sort(a, i + 1, right);/*用同样的方式对分出来的右边的小组进行同上的做法*/
                       /*当然最后可能会出现很多分左右，直到每一组的i = j 为止*/
}
```



### 【3】堆排序

```java
//构建大根堆：将array看成完全二叉树的顺序存储结构
    private int[] buildMaxHeap(int[] array){
        //从最后一个节点array.length-1的父节点（array.length-1-1）/2开始，直到根节点0，反复调整堆
        for(int i= array.length/2-1 ; i>=0 ;i--){ 
            adjustDownToUp(array, i,array.length);
        }
        return array;
    }
    
    //将元素array[k]自下往上逐步调整树形结构
    private void adjustDownToUp(int[] array,int k,int length){
        int temp = array[k];   
        for(int i=2*k+1; i<length-1; i=2*i+1){    //i为初始化为节点k的左孩子，沿节点较大的子节点向下调整
            if(i<length && array[i]<array[i+1]){  //取节点较大的子节点的下标
                i++;   //如果节点的右孩子>左孩子，则取右孩子节点的下标
            }
            if(temp>=array[i]){  //根节点 >=左右子女中关键字较大者，调整结束
                break;
            }else{   //根节点 <左右子女中关键字较大者
                array[k] = array[i];  //将左右子结点中较大值array[i]调整到双亲节点上
                k = i; //【关键】修改k值，以便继续向下调整
            }
        }
        array[k] = temp;  //被调整的结点的值放人最终位置
    }

//堆排序
    public int[] heapSort(int[] array){
        array = buildMaxHeap(array); //初始建堆，array[0]为第一趟值最大的元素
        for(int i=array.length-1;i>1;i--){  
            int temp = array[0];  //将堆顶元素和堆低元素交换，即得到当前最大元素正确的排序位置
            array[0] = array[i];
            array[i] = temp;
            adjustDownToUp(array, 0,i);  //整理，将剩余的元素整理成堆
        }
        return array;
    }
```



## 三、查找

### 【1】二分查找

```java
public static int binarySearch(int[] a, int key) {
    int low, mid, high;
    low = 0;//最小下标
    high = a.length - 1;//最大小标
    //类似快速排序，但是low<=high
    while (low <= high) {
        mid = (high + low) / 2;//折半下标
        if (key > a[mid]) {
            low = mid + 1; //关键字比折半值大，则最小下标调成折半下标的下一位
        } else if (key < a[mid]) {
            high = mid - 1;//关键字比折半值小，则最大下标调成折半下标的前一位
        } else {
            return mid; //关键字和折半值相等时返回折半下标
        }
    }
    return -1;
}
```

```java
//非递归
public int search(int key,int[] arr){
        int start=0;
        int end=arr.length-1;
        while(start<=end){
            int mid=start+(end-start)/2;
            if(key<arr[mid]){
                end=mid-1;
            }else if(key>arr[mid]){
                start=mid+1;
            }else{
                return mid;
            }
        }
        return -1;
    }
//
 public static int binarySearch(Integer[]srcArray,int des){  
        //第一个位置.  
        int low=0;  
        //最高位置.数组长度-1,因为下标是从0开始的.  
        int high=srcArray.length-1;  
        //当low"指针"和high不重复的时候.  
        while(low<=high){  
            //中间位置计算,low+ 最高位置减去最低位置,右移一位,相当于除2.也可以用(high+low)/2  
            int middle=low+((high-low)>>1);  
        //与最中间的数字进行判断,是否相等,相等的话就返回对应的数组下标.  
        if(des==srcArray[middle]){  
            return middle;  
        //如果小于的话则移动最高层的"指针"  
        }else if(des<srcArray[middle]){  
            high=middle-1;  
        //移动最低的"指针"   
        }else{  
            low=middle+1;  
            }  
        }  
        return-1;  
        }  
}
```



## 四、Java多线程

### 【1】用三个线程，顺序打印字母A-Z

> - 题目：用三个线程，顺序打印字母A-Z，输出结果是1A、2B、3C、1D 2E...
> - 思路：加锁进行限制，并配合wait()和notifyAll()

```java
private static char c = 'A';
private static int i = 0;
public static void main(String[] args) {        
    Runnable runnable = new Runnable() {
           public void run() {
              synchronized (this) {//加锁
                try {
                    int threadId = Integer.parseInt(Thread.currentThread().getName());
                    while (i < 26) {
                        //关键代码
                         if (i % 3 == threadId - 1) {
                             System.out.println(threadId +""+ (char) c++);
                             i++;
                             notifyAll();// 唤醒处于等待状态的线程
                         } else {
                             wait();// 【*】释放当前锁并进入等待状态
                         }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
              }//执行结束释放当前锁
           }
        };
        Thread t1 = new Thread(runnable, "1");
        Thread t2 = new Thread(runnable, "2");
        Thread t3 = new Thread(runnable, "3");
        t1.start();
        t2.start();
        t3.start();
}
```



### 【2】基本生产者消费者

-  [一个链接](https://www.cnblogs.com/xindoo/p/11426659.html)

```java
import java.util.LinkedList;
import java.util.Queue;

public class ProducerAndConsumer {
    private final int MAX_LEN = 10;
    private Queue<Integer> queue = new LinkedList<Integer>();
    class Producer extends Thread {
        @Override
        public void run() {
            producer();
        }
        private void producer() {
            while(true) {
                synchronized (queue) {
                    if (queue.size() == MAX_LEN) {
                        queue.notify();
                        System.out.println("当前队列满");
                        try {
                          	 queue.wait();//【*】就在满了的时候才wait
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    queue.add(1);
                    queue.notify();
                    System.out.println("生产者生产一条任务，当前队列长度为" + queue.size());
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
    class Consumer extends Thread {
        @Override
        public void run() {
            consumer();
        }
        private void consumer() {
            while (true) {
                synchronized (queue) {
                    if (queue.size() == 0) {
                        queue.notify();
                        System.out.println("当前队列为空");
                        try {
                            queue.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    queue.poll();
                    queue.notify();
                    System.out.println("消费者消费一条任务，当前队列长度为" + queue.size());
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
    public static void main(String[] args) {
        ProducerAndConsumer pc = new ProducerAndConsumer();
        Producer producer = pc.new Producer();
        Consumer consumer = pc.new Consumer();
        producer.start();
        consumer.start();
    }
}
```



### 【3】5个线程先打印Hello再打印World

> countDownLatch.countDown();计数器加1
>
>  countDownLatch.await();等待

```java
public class FiveThreadCommunication {

    private static final int MAX_THREAD = 5;

    private static final class PrintRunnable implements Runnable {

        private final CountDownLatch countDownLatch;

        public PrintRunnable(CountDownLatch countDownLatch) {
            this.countDownLatch = countDownLatch;
        }

        @Override
        public void run() {
            System.out.println("Thread-" + Thread.currentThread().getId() + " Hello");
            countDownLatch.countDown();
            try {
                countDownLatch.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("Thread-" + Thread.currentThread().getId() + " World");
        }

    }


    public static void main(String args[]) throws InterruptedException {
        CountDownLatch countDownLatch = new CountDownLatch(MAX_THREAD);
        for (int i = 0; i < MAX_THREAD; i++) {
            new Thread(new PrintRunnable(countDownLatch)).start();
        }
    }


}
```



### 【4】写一个简单的死锁

> 两个线程争资源

```java
public class DeadLock {
    public static String obj1 = "obj1";
    public static String obj2 = "obj2";
    public static void main(String[] args){
        Thread a = new Thread(new Lock1());
        Thread b = new Thread(new Lock2());
        a.start();
        b.start();
    }    
}
class Lock1 implements Runnable{
    @Override
    public void run(){
        try{
            System.out.println("Lock1 running");
            while(true){
                synchronized(DeadLock.obj1){
                    System.out.println("Lock1 lock obj1");
                    Thread.sleep(3000);//获取obj1后先等一会儿，让Lock2有足够的时间锁住obj2
                    synchronized(DeadLock.obj2){
                        System.out.println("Lock1 lock obj2");
                    }
                }
            }
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}
class Lock2 implements Runnable{
    @Override
    public void run(){
        try{
            System.out.println("Lock2 running");
            while(true){
                synchronized(DeadLock.obj2){
                    System.out.println("Lock2 lock obj2");
                    Thread.sleep(3000);
                    synchronized(DeadLock.obj1){
                        System.out.println("Lock2 lock obj1");
                    }
                }
            }
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}
```



### 【5】ABABAB

```java
public class Main {
    static  Object lock=new Object();
    public static void main(String[] args) {
        Runnable runnable1=new Runnable() {
            @Override
            public void run() {
                while (true){
                    synchronized (lock){
                        System.out.println("A");

                        lock.notify();
                        try {
                            lock.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        };

        Runnable runnable2=new Runnable() {
            @Override
            public void run() {
                while (true){
                    synchronized (lock){
                        System.out.println("B");

                        lock.notify();
                        try {
                            lock.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        };

        Thread thread1=new Thread(runnable1);
        Thread thread2=new Thread(runnable2);
        thread1.start();
        thread2.start();
    }
}
```





## 五、剑指Offer

### 1、数据结构与算法操作

#### 递归和循环

##### 【1】斐波那契数列

```java
//递归版
long fibonacci(int n) {
        if (n == 1) {
            return 0;
        } else if (n == 2) {
            return 1L;
        }
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
//循环版
long fibonacci(int n) {
        int result[] = {0, 1};
        if (n <= 2) {
            return result[n];
        }

        long fibOne = 0;
        long fibTwo = 1;
        long finResult = 0;
        for (int i = 3; i <= n; i++) {
            finResult = fibOne + fibTwo;
            fibOne = fibTwo;
            fibTwo = finResult;
        }
        return finResult;
    }
```



#### 栈和队列

##### 【1】最小栈

> - **题目：**定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度为O（1）
> - **思路：**
>   - 【重复压栈】，当前最小值地下总是压着一个上一次最小值
>     - 输入：2 8 6 1 4 
>     - 栈内：【MAX 2】 8 6 【2 1】 4 
>   - 利用辅助栈: s1主栈，s2最小值栈[存储最小值]
>     - 输入：2 8 6 1 4 
>     - S1栈内：2 8 6  1 4 
>     - S2栈内：2 1
> - 自定义一个最小元素栈，进行push操作时, 如果压入的元素小于等于栈顶元素, 则压入最小元素栈；进行pop操作时, 如果弹出的元素和栈顶元素相等, 就把最小元素栈顶也弹出。

```java
//重复压栈
public class MinStack {
    //保存最小值
    private int min_val = Integer.MAX_VALUE;
    private Stack<Integer> s = new Stack<>();
    
    /** initialize your data structure here. */
    public MinStack() {}
    
    public void push(int x) {
        //重复压栈操作
        if (x <= min_val) {
            s.push(min_val);
          //【重新赋值最小值】
            min_val = x;
        }
        s.push(x);
    }
    
    public void pop() {
        //如果弹出的是最小元素
        if (s.pop() == min_val) 
            //改变当前最小值
            min_val = s.pop();
    }
    
    public int top() {
        return s.peek();
    }
    
    public int getMin() {
        return min_val;
    }
}

//利用两个栈: s1主栈，s2最小值栈
public class MinStack {
    private Stack<Integer> s1 = new Stack<>();
    private Stack<Integer> s2 = new Stack<>();
    
    /** initialize your data structure here. */
    public MinStack() {}
    
    public void push(int x) {
        s1.push(x);
        //如果s2位空或者将要push的数字比s2栈顶的数字小，那么也压入s2一份
        if (s2.isEmpty() || s2.peek() >= x) 
            s2.push(x);
    }
    
    public void pop() {
        // Cannot write like the following:
        // if (s2.peek() == s1.peek()) s2.pop();
        // s1.pop();
        int x = s1.pop();
        if (s2.peek() == x) 
            s2.pop();
    }
    
    public int top() {
        return s1.peek();
    }
    
    public int getMin() {
        return s2.peek();
    }
}
```



##### 【2】栈弹出顺序

> - **题目：**输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1、2、3、4、5是某栈的压入顺序，序列4、5、3、2、1是该压栈序列对应的一个弹出序列，而4、3、5、1、2不可能是该压栈序列的弹出序列。
> - **思路：**借用一个辅助栈。遍历压栈顺序，将元素放入辅助栈，然后判断栈顶元素与弹出顺序第一个元素相等，若相等则出栈并将弹出顺序向后移动一位，直到不相等；最后若辅助栈不为空，说明弹出序列不是该栈的弹出顺序

```java
public class Solution {
    public boolean IsPopOrder(int [] pushA,int [] popA) {
        if(pushA.length == 0 || popA.length == 0)
            return true;
        Stack<Integer> s = new Stack<Integer>();//辅助栈
        int popIndex = 0;//用于标识弹出序列的位置
        for(int i = 0; i< pushA.length;i++){
            s.push(pushA[i]);
            //如果栈不为空且栈顶元素等于弹出序列，则出栈并将弹出序列向后移动一位
          	//【总之匹配上一个就挪一个pop一个】
            while(!s.empty() &&s.peek() == popA[popIndex]){
                s.pop();
                popIndex++;
            }
        }
        return s.empty();
    }
}
```



##### 【3】两个队列实现栈【可以用abcde测试数据梳理思路】

```java
class MyStack {
    Queue<Integer> queue1;
    Queue<Integer> queue2;

    /** Initialize your data structure here. */
    public MyStack() {
        queue1 = new LinkedList<Integer>();
        queue2 = new LinkedList<Integer>();
    }
    
    /** Push element x onto stack. */
    public void push(int x) {
        queue2.offer(x);
        while (!queue1.isEmpty()) {
            queue2.offer(queue1.poll());
        }
        Queue<Integer> temp = queue1;
        queue1 = queue2;
        queue2 = temp;
    }
    
    /** Removes the element on top of the stack and returns that element. */
    public int pop() {
        return queue1.poll();
    }
    
    /** Get the top element. */
    public int top() {
        return queue1.peek();
    }
    
    /** Returns whether the stack is empty. */
    public boolean empty() {
        return queue1.isEmpty();
    }
}
```



##### 【4】两个栈实现队列

> - **题目：**两个栈实现队列
>
> - **思路：**就是入队的时候都进到左边栈当中，出队的话各种判空处理
>
>   - 进队操作简单：全部进入一栈
>
>   - 出队：
>     - 二为空的话：一栈全部出弹出到二栈，输出最后一个。
>     - 二不为空：不用管一什么情况，直接二弹出栈顶
>
> - **复杂度：**入队O（1），出队最坏情况O（n）

```java
//仅有关键代码
public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    
    public void push(int node) {
        stack1.push(node);
    }
    
    public int pop() {
      	//【切记】2空才让1入
        if(stack2.isEmpty()){
            while(!stack1.isEmpty()){
                stack2.push(stack1.pop()); 
            }
        }
 
        return stack2.pop();
    }
}
```



##### 【20】括号匹配

- [Leetcode-20](https://leetcode-cn.com/problems/valid-parentheses/)

```java
class Solution {
    public boolean isValid(String s) {
        LinkedList<Character> stack = new LinkedList<>();
        for (char c : s.toCharArray()) {
            if (c == '[') stack.push(']');
            else if (c == '(') stack.push(')');
            else if (c == '{') stack.push('}');
            else if (stack.isEmpty() || c != stack.pop()) return false;
        }
        return stack.isEmpty();
    }
}
```

##### 【22】括号生成

- [Leet22](https://leetcode-cn.com/problems/generate-parentheses/)

```
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

示例：

输入：n = 3
输出：[
       "((()))",
       "(()())",
       "(())()",
       "()(())",
       "()()()"
     ]
```

```java
//看不懂题解，这个题有这么复杂吗？有规律啊，【剩余左括号总数要小于等于右括号】。 递归把所有符合要求的加上去就行了
class Solution {
        List<String> res = new ArrayList<>();
        public List<String> generateParenthesis(int n) {
            if(n <= 0){
                return res;
            }
            getParenthesis("",n,n);
            return res;
        }

        private void getParenthesis(String str,int left, int right) {
            if(left == 0 && right == 0 ){
                res.add(str);
                return;
            }
            if(left == right){
                //剩余左右括号数相等，下一个只能用左括号
                getParenthesis(str+"(",left-1,right);
            }else if(left < right){
                //剩余左括号小于右括号，下一个可以用左括号也可以用右括号
                if(left > 0){
                    getParenthesis(str+"(",left-1,right);
                }
                getParenthesis(str+")",left,right-1);
            }
        }
    }
```

```java
解题思路
这个解法是覃超老师的解法，我个人觉得他讲的很清晰，对递归归纳的很好，这里记录一下他的解题思路.
这道题他用递归的方式完成
终止条件为：左右两边的括号都用完。
括号的合法性为：
  左右两边的括号总和为2n， 左右各为n
  左括号的数量必须小于等于n
  右括号的数量必须小于现存的左括号
  在每次递归的过程中更新左右括号的状态，同时使用分支验证括号的合法性。
链接：https://leetcode-cn.com/problems/generate-parentheses/solution/1ms5xing-dai-ma-wan-cheng-di-gui-by-mlscy/

class Solution {
    ArrayList<String> strings = null;
    public List<String> generateParenthesis(int n) {
        strings = new ArrayList<String>();
        generateParenthesis(n,0,0,"");
        return strings;
    }

    public void generateParenthesis(int n, int left, int right, String s){
        if(left == n && right == n){
            strings.add(s);
            return;
        }
        if(left<n) 
          generateParenthesis(n,left+1,right,s+"(");
        if(right<left) 
          generateParenthesis(n,left,right+1,s+")");
    }
}
```

```java
left=0 right= 0
left=1 right= 0
left=1 right= 1
()
3
[()]
//---------------------
left=0 right= 0
left=1 right= 0
left=2 right= 0
left=2 right= 1
left=2 right= 2
(())
5
left=1 right= 1
left=2 right= 1
left=2 right= 2
()()
8
[(()), ()()]
//----------------------
left=0 right= 0
left=1 right= 0
left=2 right= 0
left=3 right= 0
left=3 right= 1
left=3 right= 2
left=3 right= 3
((()))
7
left=2 right= 1
left=3 right= 1
left=3 right= 2
left=3 right= 3
(()())
11
left=2 right= 2
left=3 right= 2
left=3 right= 3
(())()
14
left=1 right= 1
left=2 right= 1
left=3 right= 1
left=3 right= 2
left=3 right= 3
()(())
19
left=2 right= 2
left=3 right= 2
left=3 right= 3
()()()
22
```



##### 【6】表达式计算

```java
public class Solution {
    
    public int solve (String s) {
        // write code here
        Stack<Integer> stack = new Stack<Integer>();
        //用来记录每一个参数计算的数（可能是 一位数、二位数。。。）
        int number = 0;
        //用来存储整个算式的结果
        int sun = 0;
        //记录当前运算符
        char sign = '+';
        char[] chars = s.toCharArray();
        for(int i = 0;i < chars.length;i++){
            char c = chars[i];
            if(c == '('){
                //计算（）的数量
                int j = i + 1;
                int count = 1;
                while(count > 0){
                    if(chars[j] == '('){
                        count++;
                    }else if(chars[j] == ')'){
                        count--;
                    }
                    j++;
                }
                number = solve(s.substring(i + 1,j - 1));
                i = j - 1;
            }else if(Character.isDigit(c)){
                //因为如果是 两位以上的数，会有练习几个 c 都是数字的情况，所以这种情况要乘10 计算
                number = number * 10 + c - '0';
            }
            if(!Character.isDigit(c) || i == chars.length - 1){
                    switch(sign){
                        case '+':
                            stack.push(number);
                            break;
                        case '-':
                            stack.push(-1 * number);
                            break;
                        case '*':
                            stack.push(stack.pop() * number);
                            break;
                        case '/':
                            stack.push((stack.pop() / number));
                            break;
                    }
                    number = 0;
                    sign = c;
            }
        }
        while(!stack.isEmpty()){
            sun += stack.pop();
        }
        return sun;
    }
}
```



#### 动态规划

##### 【1】跳台阶

> - **题目：**一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
> - **思路：**对于第n个台阶来说，只能从n-1或n-2的台阶跳上来，因此跳到n阶的跳法=跳到n-1阶的方案+跳到n-2阶的方案，即F(n) = F(n-1) + F(n-2)，是个斐波拉契数序列，比如跳到第十节台阶可以从第9节或者第8节跳上来，这个时候F(10)=F(9)+F(8)

```java
//递归法
public class Solution {
    public int JumpFloor(int target) {
        if (target <= 2) {
            return target;
        } else {
            return  JumpFloor(target-1)+JumpFloor(target-2);
        }
    }
}
//迭代法
public class Solution {
    public int JumpFloor(int target) {
        if (target <= 2) {
            return target;
        } 
        int f1=1;
        int f2=2;
        int f=0;
        for(int i=3;i<=target;i++){
            f=f1+f2;
            f1=f2;
            f2=f;
        }
        return f;
    }
}
```



##### 【2】变态跳台阶

> 就是每次不只是可以跳1或者2节台阶，可以跳n节
>
> 假设跳上第n个台阶有f(n)种方法，则f(1)=1,f(2)=2,f(3)=4,f(4)=8,我们隐约感觉到f(n)=2^(n-1)。但是需要证明下，同样根据我们根据上篇文章中跳台阶的思路，==可以得到**f(n)=f(n-1)+f(n-2)+....+f(1)+1,而f(n-1)=f(n-2)+....+f(1)+1**,两个式子相减，得到f(n) = 2f(n-1),很明显可以得到**f(n)=2^(n-1)**==

```java
//循环
public static  int JumpFloorII(int target) {
     	if (target==0){
            return 0;
        }
    
        int result=1;
        for (int i=0;i<target-1;i++){
            result=result*2;
        }
    	//其实就是下面一行代码
   		//result= (int) Math.pow(2,target-1);
        return result;
    }
//递归
//f(n) = 2*f(n-1)*/
    public int JumpFloorII(int target) {
        if(target<=0){
            return 0;
        }else if(target==1){
            return 1;
        }else{
            return 2*JumpFloorII(target-1);
        }
    }
```



##### 【3】剪绳子

> - **题目：**
>   - 给你一根长度为n的绳子，请把绳子剪成m段（m , n ）都是正整数，（n>1&m>1）
>   - 每段绳子的长度为k[0],k[1],k[2],...,k[m]。请问k[0]*k[1]*k[2]*...*k[m]的最大值。
>   - 例如绳子是长度为8，我们把它剪成的长度分别为2,3,3的三段，此时得到的最大的乘积是18
> - **思路：**
>   - 动态规划：先从最低处开始计算乘积并将每个数可以剪切后得到的乘积最大值进行存储。当计算后面的值的时候利用已经存储好的最大值，计算所有可能的结果并保留最大的。
>   - 贪婪算法：这次我们来换一个思路，我们可以知道当(n>=5)时，存在(2*(n-2))>n和(3*(n-3))>n。
>     又因为当n>=5 时有 3*(n-3)>=2*(n-2)，所以我们应该**尽量剪出3来得到最大值**。
>     **当长度为4时，2*2最大**。
> - **复杂度：**
>   - 动态规划：时间：O（n^2），空间O（n）
>   - 贪婪算法：时间：O（1），空间O（1）

```java
//动态规划
public static int getMaxResult(int length) {
        
        int[] res = null ;
        int max = 0 ;
        if(length < 2 ) {
            return 0 ;
        }
        if(length == 2) {
            return 1 ;
        }
        if(length == 3) {
            return 2 ;
        }
        
    	//res的值子问题最优解数组
        res = new int[length+1] ;
        res[0] = 0 ;
        res[1] = 1 ;
        res[2] = 2 ;
        res[3] = 3 ;
        //此处是关键，
    	//res[4] = 4; -》[1，3] [2，2]
    	//res[5] = 6; -》[1，4] [2，3]
        for(int i = 4 ; i <= length ; i ++) {
            max = 0 ;
            //这个循环就是两端相乘，往中间缩进
            for(int j = 1 ; j <= i/2 ; j++) {
                int r = res[j] * res[i-j] ;
                if(max < r) {
                    max = r ;
                    res[i] =max ;
                }
            }
        }
        max = res[length] ;
        return max ;
    }

//贪婪算法
class Solution {
    public int cuttingRope(int length) {
        if(length < 3 ) {
            return length - 1 ;
        }
        
        int timesOf3 = length/3 ;
    	//如果能有一个四
        if(length - timesOf3*3 == 1) {
            //提取出一个四，3的段数减一
            timesOf3 -= 1 ;
        }
        
    	//0个或者1个
        int timesOf2 = (length - timesOf3*3)/2 ;
        //pow() 函数用来求 x 的 y 次幂(次方),
        return (int) (Math.pow(3, timesOf3) * Math.pow(2, timesOf2)) ;
    }
}
```



##### 【4】礼物的最大价值

https://blog.csdn.net/weixin_38361153/article/details/88909186

**分析思路：**
利用循环的动态规划实现，使用辅助二维数组
•定义f(i,j)表示到达坐标为(i,j)的格子时能拿到的礼物总和的最大值；
•有两种路径到达(i,j)：（i-1,j）或者（i,j-1）；
•f(i,j) = max(f(i-1,j), f(i,j-1)) + gift[i,j]；
•使用循环来计算避免重复子问题。

优化空间复杂度，使用一维数组
•题目中可知，坐标(i,j)的最大礼物价值仅仅取决于坐标为(i-1,j)和(i,j-1)两个格子；
•因此第i-2行以上的最大价值没有必要保存下来。
•使用一维数组保存：(0,0)…(0,j-1)保存的是(i,0)…(i,j-1)的最大价值；(0,j)…(0,cols-1)保存的是(i-1,j)…(i-1,cols-1)的最大价值。

```java
	/*
 * 面试题47：礼物的最大价值
 * 题目：在一个m*n的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于0）。
 * 你可以从棋盘的 左上角开始拿格子里的礼物，并每次向左或者向下移动一格，直到到达棋盘
 * 的右下角。给定一个棋盘及其上面的礼物，请计算你最多能拿到多少价值的礼物。
 */
public class Demo47 {

	public static void main(String[] args) {
		int[][] arr = { { 1, 10, 3, 8 }, 
				       			 { 12, 2, 9, 6 },
				      			  { 5, 7, 4, 11 },
                        { 3, 7, 16, 5 } };
		System.out.println(getMaxValue1(arr));
		System.out.println(getMaxValue2(arr));
	}
	
	//利用循环的动态规划实现
	public static int getMaxValue1(int[][] arr) {
		if(arr==null || arr.length==0)
			return 0;
		
		int rows = arr.length; //行
		int cols = arr[0].length; //列
		
		int[][] maxValue = new int[rows][cols];
		for(int i=0;i<rows;i++) {
			for(int j=0;j<cols;j++) {
				int left = 0;
				int up = 0;
				if(i>0)
					up = maxValue[i-1][j];
				if(j>0)
					left = maxValue[i][j-1];
			maxValue[i][j] = Math.max(up, left) + arr[i][j];
			}
		}
		return maxValue[rows-1][cols-1];
	}
}
```

```java
	//使用循环实现
	public static int getMaxValue2(int[][] arr) {
		if(arr==null || arr.length==0)
			return 0;
		
		int rows = arr.length;
		int cols = arr[0].length;
		int[] maxValue = new int[cols];
		for(int i=0;i<rows;i++) {
			for(int j=0;j<cols;j++) {
				int left = 0;
				int up = 0;
				if(i>0)
					up = maxValue[j];
				if(j>0)
					left = maxValue[j-1];
				maxValue[j] = Math.max(up, left)+arr[i][j];
			}
		}
		return maxValue[cols-1];
	}
```



##### 【5】矩阵最小路径和dp

```java
题目描述
给定一个 n * m 的矩阵 a，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，输出所有的路径中最小的路径和。

题解
第一行 只能从左往右
第一个元素 的值为 原数组的第一个元素 dp[0][0] = a[0][0]
dp[0][j] = a[0][j] + dp[0][j-1];
第一列元素 只能从上往下
dp[i][0] = dp[i-1][0] + a[i][0]

第二行第二列元素的可能从 当前节点的左节点 和上节点过来
那么该节点的最小值应为 当前节点的值 加上 min （ 上节点 左节点）
dp[i][j] = a[i][j] + Math.min(dp[i][j-1],dp[i-1][j]);

那么最后一个节点的值就为最小的路径和
```

```java
public class Solution {
 public int minPathSum (int[][] matrix) {
          int[][]  dp = new int[matrix.length][matrix[0].length];
          dp[0][0] = matrix[0][0];
          for(int i =1; i< matrix.length; i++) {
              dp[i][0] =  dp[i-1][0] + matrix[i][0];
          }
          for(int i =1; i< matrix[0].length; i++) {
              dp[0][i] =  dp[0][i-1] + matrix[0][i];
          }

          for (int i = 1; i < dp.length; i++) {
            for (int j = 1; j < dp[0].length; j++) {
                 dp[i][j] = matrix[i][j] + Math.min(dp[i-1][j], dp[i][j-1]);
            }
        }
          return dp[matrix.length-1][matrix[0].length-1];
     }
}
```



##### 【198】[打家劫舍](https://leetcode-cn.com/problems/house-robber/)

```
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

示例 1：
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 2：
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

```java
class Solution {
    public int rob(int[] nums) {
        int prev = 0;
        int curr = 0;

        // 每次循环，计算“偷到当前房子为止的最大金额”
        for (int i : nums) {
            // 循环开始时，curr 表示 dp[k-1]，prev 表示 dp[k-2]
            // dp[k] = max{ dp[k-1], dp[k-2] + i }
            int temp = Math.max(curr, prev + i);
            prev = curr;
            curr = temp;
            // 循环结束时，curr 表示 dp[k]，prev 表示 dp[k-1]
        }

        return curr;
    }
}

public int rob(int[] nums) {
    if (nums.length == 0) {
        return 0;
    }
    // 子问题：
    // f(k) = 偷 [0..k) 房间中的最大金额

    // f(0) = 0
    // f(1) = nums[0]
    // f(k) = max{ rob(k-1), nums[k-1] + rob(k-2) }

    int N = nums.length;
    int[] dp = new int[N+1];
    dp[0] = 0;
    dp[1] = nums[0];
    for (int k = 2; k <= N; k++) {
        dp[k] = Math.max(dp[k-1], nums[k-1] + dp[k-2]);
    }
    return dp[N];
}
```



### 2、数组

#### 【1】快速从一组无序数中找到第k大的数（或前k个大的数）

> 思路：利用快排思想，直至找到一个排在第k位置的枢轴，因为左边所有数据都比它大，右边都比它小。

```java
class QuickSort {
    public static void main(String[] args) {
        int[] a = {1, 5, 2, 4, 6, 7, 8, 9, 11, 3};
//        int[] a = {1, 2, 3, 4, 5, 6};
        findK(2, a, 0, 9);
        System.out.println(Arrays.toString(a));
    }

    public static void findK(int k, int[] arr, int low, int high) {
        int temp = partition(arr, low, high);
        if (temp == k - 1) {
            System.out.print("第" + k + "大的数是：" + arr[temp]);
        } else if (temp > k - 1) {
            //注意范围的变换
          //剩下的不需要的数组范围不需要排序了
            findK(k, arr, low, temp - 1);
        } else {
            findK(k, arr, temp + 1, high);
        }
    }

    static int partition(int[] array, int left, int right) {
        if (array != null || array.length >= 1) {

            int temp = array[left];//基准数
            int i = left;
            int j = right;
            int swap;

            while (i < j) {
                //顺序很重要，要先从右边开始找
                while (array[j] >= temp && i < j) {
                    j--;
                }
                //再找右边的
                while (array[i] <= temp && i < j) {
                    i++;
                }
                //交换两个数在数组中的位置
                if (i < j) {
                    swap = array[i];
                    array[i] = array[j];
                    array[j] = swap;
                }
            }

            //最终将基准数归位
            array[left] = array[i];
            array[i] = temp;
          //这里不递归，返回中位数也就是key的位置，如果是k位
            return j;
        }
        return 0;
    }
}
```



#### 【2】二维数组查找

> - 题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数
> - 思路：从左下角开始查找，当比关键字小时右移，反之上移

```java
public class Solution {
    //右上角开始找
    private boolean findInArrayFromRightTop(int[][] arr, int rows, int columns, int number) {

        if (arr != null && rows > 0 && columns > 0) {
            int currntRow = 0;
            int currentColumn = columns - 1;
            while (currntRow < rows && currentColumn >= 0) {//往左下方缩小，所以控制范围
                if (arr[currntRow][currentColumn] == number) {
                    System.out.println("该数坐标:"+currntRow+"，"+currentColumn);
                    return true;
                } else if (arr[currntRow][currentColumn] < number) {
                    currntRow++;
                } else {
                    currentColumn--;
                }
            }
        }
        return false;
    }
    
	//左下角开始找
    private boolean findInArrayFromLeftBottom(int[][] arr, int rows, int columns, int number) {

        if (arr != null && rows > 0 && columns > 0) {
            int currntRow = rows - 1;
            int currentColumn = 0;
            while (currntRow >= 0 && currentColumn < columns) {//往右上方缩小，所以控制范围
                if (arr[currntRow][currentColumn] == number) {
                    System.out.println("该数坐标:"+currntRow+"，"+currentColumn);
                    return true;
                } else if (arr[currntRow][currentColumn] < number) {
                    currentColumn++;
                } else {
                    currntRow--;
                }
            }
        }
        return false;
    }
}
```

```java
public boolean searchMatrix(int[][] matrix, int target) {
    int m = matrix.length;
    int n = matrix[0].length;
    int i = 0, j = n - 1;
    while (i < m && j >= 0) {
        if (matrix[i][j] == target) {
            return true;
        } else if (matrix[i][j] > target) {
            j--;
        } else {
            i++;
        }
    }
    return false;
}
```

#### 【1351】[统计有序矩阵中的负数](https://leetcode-cn.com/problems/count-negative-numbers-in-a-sorted-matrix/)

```
给你一个 m * n 的矩阵 grid，矩阵中的元素无论是按行还是按列，都以非递增顺序排列。 
请你统计并返回 grid 中 负数 的数目。

示例 1：
输入：grid = [	[4,3,2,-1],
							[3,2,1,-1],
							[1,1,-1,-2],
							[-1,-1,-2,-3]]
输出：8
解释：矩阵中共有 8 个负数。
示例 2：
输入：grid = [[3,2],[1,0]]
输出：0
示例 3：
输入：grid = [[1,-1],[-1,-1]]
输出：3
示例 4：
输入：grid = [[-1]]
输出：1
```

```java
//搜索【行列都是降序】
class Solution {
    public int countNegatives(int[][] grid) {
        if(grid.length == 0 || grid[0].length == 0){
            return 0;
        }
        /*
        [4,3,2,-1],
        [3,2,1,-1],
        [1,1,-1,-2],
        [-1,-1,-2,-3]
        从右上角开始遍历，i = 0, j = grid[0].length - 1
        如果当前值大于等于 0，那么前面的值肯定都非负，那么直接跳过，进入下一行, 即 i++
        如果当前值小于 0，那么当前值以及同列下的值都是小于 0 的，那么直接添加，然后进行下一列，即 j--
        */
        int count = 0;
        for(int i = 0, j = grid[0].length - 1; i < grid.length && j >= 0; ){
            if(grid[i][j] >= 0){
                i++;
            }else{
                count += grid.length - i;
                j--;
            }
        }
        return count;
    }
}
```



#### 【3】数组中出现次数超过一半的数字

> - 题目：找出数组中有出现的次数超过数组长度的一半的数字，如果不存在则输出0。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}，由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。
> - 思路：在遍历数组时保存两个值，一是数组中一个数字，一是次数；遍历下一个数字时，若它与之前保存的数字相同，则次数加1，否则减1；若次数为0，则保存下一个数字，并将次数置为1；遍历结束后，所保存的数字即为所求；然后再判断它是否符合条件即可。

```java
class Solution {
    public int majorityElement(int[] nums) {
        Arrays.sort(nums);
        return nums[nums.length/2];
    }
}
```

```java
class Solution {
    /**
     * 依据数组结构特性，超过一半。。。。 
     * 遍历数组，如果下一个数字和之前保存的数字相同则次数+1，不同则-1
     * 如果次数为0，则需要保存下一个数字，并设置次数为1
     * 最后一次把次数设置为1的数字就是结果
     */
    public int majorityElement(int[] numbers) {
        if (numbers == null || numbers.length < 1) {
            return 0;
        }

        int result = numbers[0];
        int times = 1;
        //首先找出出现最多的数字，然后再检验是否超过半数
        for (int i = 1; i < numbers.length; i++) {
            //注意次数减为0的情况
            if (times == 0) {
                result = numbers[i];
                times = 1;
            } else if (result == numbers[i]) {
                times++;
            } else {
                times--;
            }
        }

        //检验是否超半数+++++++++++++
        times = 0;
        for (int i = 0; i < numbers.length; i++) {
            if (numbers[i] == result) {
                times++;
            }
        }
        if (times * 2 <= numbers.length) {
            return 0;
        }

        return result;
    }
}
```

```java
import java.util.Arrays;
public class Solution {
    public int MoreThanHalfNum_Solution(int [] array) {
      //排序，超过一半的数字必定会出现在中间
       Arrays.sort(array);
        int count=0;
        int half=array.length/2;
        for (int i=0;i<array.length;i++)
        {
            if (array[i]==array[half])
                count++;
        }
        if (count>half)
            return array[half];
        else
            return 0;
    }
}
```



#### 【3+】只出现一次的数字(两个)[分组亦或^]

```
假设数组异或的二进制结果为10010，那么说明这两个数从右向左数第2位是不同的
```

```java
//num1,num2分别为长度为1的数组。传出参数
//将num1[0],num2[0]设置为返回结果
public class Solution {
 public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) {
        int xor1 = 0;
        for(int i=0; i < array.length; i++)
            xor1 = xor1^array[i];
        //在xor1中找到第一个不同的位对数据进行分类，分类为两个队列对数据进行异或求和找到我们想要的结果
        int index = 1;
        while((index & xor1)==0)
            index = index <<1;//因为可能有多个位为1所以需要求一下位置
        int result1 = 0;
        int result2 = 0;
        for(int i=0; i < array.length; i++){
            if((index & array[i]) == 0)
                result1 = result1^array[i];
            else
                result2 = result2^array[i];
        }
        num1[0] = result1;
        num2[0] = result2;
	}
}
```

```java
//一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

//num1,num2分别为长度为1的数组。传出参数
//将num1[0],num2[0]设置为返回结果
public class Solution {
    public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) {
         int temp = array[0];
        //首先把数组中的数字全部进行异或
        for (int i = 1; i < array.length; i ++){
            temp ^= array[i];
        }
        //把异或结果的最后一位1的那位找出来
        temp &= -temp;
        //以这一位是否为1或者0作为分类标准进行分类
        for (int val : array){
            if ((val&temp) == 0){
                num1[0] ^= val;
            } else {
                num2[0] ^= val;
            }
        }
    }
}
```



#### 【4】顺时针打印矩阵

> 处理一行、一列、两行的特殊情况

> - 题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。例如如果输入如下4 X 4矩阵， 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10
>
>   1    2   3   4
>   5    6   7   8
>   9   10 11 12
>   13 14 15 16
>
> - 思路：用左上和右下的坐标定位出一次要旋转打印的数据，一次旋转打印结束后，往对角分别前进和后退一个单位。注意单行或者单列的情况。

```java
public static void main(String[] args) {
        //1  2  3   4 5
        //6  7  8   9 10
        //11 12 13 14 15
        //16 17 18 19 20
        //21 22 23 24 25
        int count = 1;
        int[][] matrix = new int[5][5];
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[i].length; j++) {
                matrix[i][j] = count;
                count++;
            }
        }
        Solution.printMatrix(matrix, 5, 5);
    }

class Solution {
    public static void printMatrix(int[][] matrix, int columns, int rows) {
        if (matrix == null || columns <= 0 || rows <= 0) {
            return;
        }

        //start可以理解为对角线偏移量
        int start = 0;
        //注意while循环的控制条件
        while (columns > 2 * start && rows > 2 * start) {
            printCircle(matrix, columns, rows, start);
            start++;
            System.out.println("");
        }
    }

    //for + 3if模型
    //if里的判断条件在极端的时候适用，比如横线，竖线，两行横线这种情况
    private static void printCircle(int[][] matrix, int columns, int rows, int start) {
        //结束标志
        int endX = columns - 1 - start;
        int endY = rows - 1 - start;
        //从左到右打印第一行
        for (int i = start; i <= endX; i++) {
            System.out.print(matrix[start][i] + " ");
        }
        //从上到下打印第一列
        if (start < endY) {
            for (int i = start + 1; i <= endY; i++) {
                System.out.print(matrix[i][endX] + " ");
            }
        }
        //从右到左打印第二行
        if (start < endX && start < endY) {
            for (int i = endX - 1; i >= start; i--) {
                System.out.print(matrix[endY][i] + " ");
            }
        }
        //从下到上打印第二列
        if (start < endX && start < endY - 1) {
            for (int i = endY - 1; i >= start + 1; i--) {
                System.out.print(matrix[i][start] + " ");
            }
        }
        //打印结果
        //1 2 3 4 5 10 15 20 25 24 23 22 21 16 11 6
        //7 8 9 14 19 18 17 12
        //13
    }
}
```

#### 【4+】顺时针旋转矩阵

- [牛客](https://www.nowcoder.com/practice/2e95333fbdd4451395066957e24909cc?tpId=117&&tqId=35045&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking)

```java
有一个NxN整数矩阵，请编写一个算法，将矩阵顺时针旋转90度。
给定一个NxN的矩阵，和矩阵的阶数N,请返回旋转后的NxN矩阵,保证N小于等于300。

示例1
输入
[[1,2,3],
 [4,5,6],
 [7,8,9]],3
返回值
[[7,4,1],
 [8,5,2],
 [9,6,3]]
```

```java
public class Main {

	public static void main(String[] args) {
		Scanner in=new Scanner(System.in);
		while(in.hasNext()){
		
		
		String inStr=in.next();
		String[] inArr = inStr.split("],");
		int len=inArr.length;
		int lenArr=Integer.valueOf(inArr[len-1]);//[]里数组长度
		
		StringBuffer rsTemp=new StringBuffer("");
		
		//处理第一个数组
		StringBuffer firstArr = new StringBuffer(inArr[0]);
		String firstStr=firstArr.substring(2);
		rsTemp.append(firstStr+",");
		//System.out.println(firstStr);
		
		//处理中间数组
		for (int i = 1; i < lenArr-1; i++) {
			String midStr = inArr[i].substring(1);
			rsTemp.append(midStr+",");
			//System.out.println(midStr);
		}
		
		//处理最后一个数组
		StringBuffer lastArr = new StringBuffer(inArr[lenArr-1]);
		String lastStr=lastArr.substring(1,lastArr.length()-1);
		rsTemp.append(lastStr);
		//System.out.println(lastStr);
		
		//System.out.println(rsTemp.toString());
		
		String[] strArr = rsTemp.toString().split(",");
		//System.out.println(strArr.length);
		StringBuffer rs=new StringBuffer("");
		int strArrlen=strArr.length;
		for(int j=strArrlen-lenArr;j<=strArrlen-1;j++){
			//System.out.println(j);
			rs.append("[");
			for(int i=j;i>=0;i-=lenArr){
				if(i<lenArr){
					rs.append(strArr[i]);
				}else{
					rs.append(strArr[i]+",");
				}
				//System.out.println(i);
			}
			if(j==strArrlen-1){
				rs.append("]");
			}else{
				rs.append("],");
			}
			
		}
		System.out.println("["+rs+"]");
	}
	}
}
```

#### 【4++】[对角线遍历](https://leetcode-cn.com/problems/diagonal-traverse/)矩阵

```
输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]

输出:  [1,2,4,7,5,3,6,8,9]
```

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwja7pjo5j30b30b60t4.jpg" alt="img" style="zoom:50%;" />

```java
class Solution {
    public int[] findDiagonalOrder(int[][] matrix) {
        // 参数校验
        if (matrix.length == 0) {
            return new int[0];
        }
        int row_count = matrix.length;
        int column_count = matrix[0].length;
        // 遍历次数/对角线条数
        int count = row_count + column_count - 1;
        int row = 0;
        int column = 0;
        // 出参
        int[] result = new int[row_count * column_count];
        int retIndex = 0;
        // 遍历次数
        for (int k = 0; k < count; k++) {
            if (k % 2 == 0) {
                // 从左到右往上遍历
                while (row >= 0 && column < column_count) {
                    result[retIndex] = matrix[row][column];
                    retIndex++;
                    row--;
                    column++;
                }

                // 数组越界，计算下次遍历开始坐标
                if (column < column_count) {
                    row = row + 1;
                } else {
                    row = row + 2;
                    column = column - 1;
                }
            } else {
                // 从右到左往下遍历
                while (row < row_count && column >= 0) {
                    result[retIndex] = matrix[row][column];
                    retIndex++;
                    row++;
                    column--;
                }
                // 数组越界，计算下次遍历开始坐标
                if (row < row_count) {
                    column = column + 1;
                } else {
                    row = row - 1;
                    column = column + 2;
                }
            }
        }
        return result;
    }
}
```



#### 【5】两数之和

> - **题目：**给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。
> - **思路：**事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。
> - **复杂度：**时间：O（n），空间O（n）

```java
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];//【要找的】
        if (map.containsKey(complement)) {
            return new int[] { map.get(complement), i };
        }
        map.put(nums[i], i);//【将当前的放入】
    }
    throw new IllegalArgumentException("No two sum solution");
}
```



#### 【15】[三数之和](https://leetcode-cn.com/problems/3sum/)

```
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

示例：
给定数组 nums = [-1, 0, 1, 2, -1, -4]，
满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {// 总时间复杂度：O(n^2)
        List<List<Integer>> ans = new ArrayList<>();
        if (nums == null || nums.length <= 2) return ans;

        Arrays.sort(nums); // O(nlogn)

        for (int i = 0; i < nums.length - 2; i++) { // O(n^2)
            if (nums[i] > 0) break; // 第一个数大于 0，后面的数都比它大，肯定不成立了
            if (i > 0 && nums[i] == nums[i - 1]) continue; // 去掉重复情况
            int target = -nums[i];
            int left = i + 1, right = nums.length - 1;
            while (left < right) {
                if (nums[left] + nums[right] == target) {
                    ans.add(new ArrayList<>(Arrays.asList(nums[i], nums[left], nums[right])));
                    
                    // 现在要增加 left，减小 right，但是不能重复，
                    //比如: [-2, -1, -1, -1, 3, 3, 3], i = 0, 
                    //left = 1, right = 6, [-2, -1, 3] 的答案加入后，需要排除重复的 -1 和 3
                    left++; right--; // 首先无论如何先要进行加减操作
                    while (left < right && nums[left] == nums[left - 1]) left++;
                    while (left < right && nums[right] == nums[right + 1]) right--;
                } else if (nums[left] + nums[right] < target) {
                    left++;
                } else {  // nums[left] + nums[right] > target
                    right--;
                }
            }
        }
        return ans;
    }
}
```



#### 【5+】数组中相加为0的三元组

- [niuke](https://www.nowcoder.com/practice/345e2ed5f81d4017bbb8cc6055b0b711?tpId=117&&tqId=34975&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking)

```
题目描述
给出一个有n个元素的数组S，S中是否有元素a,b,c满足a+b+c=0？找出数组S中所有满足条件的三元组。
注意：
三元组（a、b、c）中的元素必须按非降序排列。（即a≤b≤c）
解集中不能包含重复的三元组。
例如，给定的数组 S = {-10 0 10 20 -10 -40},解集为(-10, 0, 10) (-10, -10, 20)

```

```java
public class Solution {
    public ArrayList<ArrayList<Integer>> threeSum(int[] num) {
        Arrays.sort(num);
        ArrayList<ArrayList<Integer>> result=new ArrayList<ArrayList<Integer>>();
        //我再负数区 选一个则，必须在 正数区选一个，或者选两个
        for(int i=0;i<num.length;i++){
            if(num[i]>0){
                //非正数选完代表选完
                break;
            }
            if(i!=0&&num[i]==num[i-1]){
                //去重
                continue;
            }
            //两数求和

            int start=i+1;
            int end=num.length-1;
            while(start<end){
                //先左移 因为排序原因 start 为 相对于 i 第二小值
                while(start<end&&num[i]+num[start]+num[end]>0){
                    end--;
                }
                if(start<end&&num[i]+num[start]+num[end]==0){
                     ArrayList<Integer> item=new ArrayList<Integer>();
                     item.add(num[i]);
                     item.add(num[start]);
                     item.add(num[end]);
                     result.add(item);
                     //右移去重
                    while(start<end&&item.get(1)==num[start]){
                        start++;
                    }
                }else{
                    //右移增大整体数
                    start++;
                }
            }

        }

        return result;
    }
}
```





#### 【6】删除排序数组中的重复项

> - **题目：**删除排序数组中的重复项，返回数组的长度
> - **思路：**利用快慢指针法
> - **复杂度：**时间：O（n），空间O（1）

```java
public int removeDuplicates(int[] nums) {
    if (nums.length == 0) return 0;
    int i = 0;
    //开始条件 i=0；j=1；
    for (int j = 1; j < nums.length; j++) {
        //之前一直都是相等的，突然遇到个不是相等的
        //如果二者不等，说明需要前移数字了
        if (nums[j] != nums[i]) {
            //注意先i++，再移动数字
            i++;
            nums[i] = nums[j];
        }
    }
    //返回值是数组长度
    return i + 1;
}
```



#### 【7】买股票的最佳时机

> - **题目：**给定一个数组，它的第 *i* 个元素是一支给定股票第 *i* 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票
>
> - **示例 1:**
>
>   ```java
>   输入: [7,1,5,3,6,4]
>   输出: 5
>   解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
>        注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
>   ```
>
>   **示例 2:**
>
>   ```java
>   输入: [7,6,4,3,1]
>   输出: 0
>   解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
>   ```
>
> - **思路：**
>
>   - 暴力法：不推荐
>   - 一次遍历：加入将给定的数组绘制成折线图，使我们感兴趣的点是上图中的峰和谷。**我们需要找到最小的谷之后的最大的峰。** 我们可以维持两个变量——minprice 和 maxprofit，它们分别对应迄今为止所得到的最小的谷值和最大的利润（卖出价格与最低价格之间的最大差值）
>
> - **复杂度：**时间：O（n），空间O（1）

```java
public class Solution {
    public int maxProfit(int prices[]) {
        int minprice = Integer.MAX_VALUE;
        int maxprofit = 0;
        for (int i = 0; i < prices.length; i++) {
            //遇到最小值那么就替换最小值
            if (prices[i] < minprice)
                minprice = prices[i];
            //如果是更低峰谷则替换峰谷，否则计算利润
            else if (prices[i] - minprice > maxprofit)
                maxprofit = prices[i] - minprice;
        }
        return maxprofit;
    }
}
```



#### 【8】买股票的最佳时机II

> - **题目：**
>
>   - > 区别于1就是可以多次买入一只股票
>
>     给定一个数组，它的第 *i* 个元素是一支给定股票第 *i* 天的价格。
>
>     设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
>
>     **注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
>
> - **示例 1:**
>
>   ```java
>   输入: [7,1,5,3,6,4]
>   输出: 7
>   解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
>        随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
>   ```
>
>   **示例 2:**
>
>   ```java
>   输入: [1,2,3,4,5]
>   输出: 4
>   解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
>        注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
>        因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
>   ```
>
>   **示例 3:**
>
>   ```java
>   输入: [7,6,4,3,1]
>   输出: 0
>   解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
>   ```
>
> - **思路：**
>
>   - 暴力法：不推荐
>   - 简单的一次遍历：每两个点计算折线图高度差想加
>
> - **复杂度：**时间：O（n），空间O（1）

```java
//简单的一次遍历
class Solution {
    public int maxProfit(int[] prices) {
        int maxprofit = 0;
        for (int i = 1; i < prices.length; i++) {
            //比较相邻两个点的高度差
            if (prices[i] > prices[i - 1])
                //累加利润
                maxprofit += prices[i] - prices[i - 1];
        }
        return maxprofit;
    }
}
```



#### 【X】盛水容器问题(双指针)

- [LeetCode](https://leetcode-cn.com/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution/)

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm1l9zbumaj30bh09674c.jpg" alt="img" style="zoom:50%;" />

```java
题目描述
给定一个整形数组arr，已知其中所有的值都是非负的，将这个数组看作一个容器，请返回容器能装多少水。
具体请参考样例解释
示例1
输入
[3,1,2,5,2,4]
返回值
5
  
暴力求解法
开始时想到了暴力求解法，最差情况下是O(nn)的时间复杂度，很不幸，超时了。
但至少在面试的时候，可以在有限的时间内给出一个基本解法，思路是这样的：
1 在数组arr(left, right)中找出最大和第二大的数的位置pos1和pos2；这样就将arr划分成了3段：
left,..., pos1, ..., pos2, ..., right
2 arr(pos1~pos2)直接的容量s可以直接计算出来；
3 那么s(arr, left, right) = s + s(arr, left, pos1) + s(arr, pos2, right)
最优情况下，每次能对半划分，这个时间复杂度就是nlog(n)。
这个程序很容易写出来。

双指针法
这个确实很难想，基本思路就是将arr(left, right)内的总容积，通过每次移除一个边界元素的方式逐步计算出来，也就是：
s(arr, left, right) = x1 + s(arr, left+1, right)，1) 或者：
s(arr, left, right) = x2 + s(arr, left, right-1)，2)
假设arr[left] < arr[right]，那么具体用1)还是2)呢，也就是应该移除left，还是right呢？
1 如果移除小的那个，我们可以保证：max(arr[left], arr[right]) >= set(已移除左元素）
当再移除arr[left]时，显然可以立刻得到left上能容纳的最大容量，如下：
min(max(set(已移除左元素)), arr[right]) - arr[left] = max(set(已移除左元素) - arr[left]
而这个已移除左元素的max值，我们只需要使用一个lmax记录就可以了。
2 如果移除大的那个，我们在移除的时间点无法确定它能容纳的最大容量，因为我们无法确定剩余元素的最小值。
这样通过逐步移除较小的那个边界元素，我们就可以计算出最终的容量。
```

```java
public class Solution {
    public int maxArea(int[] height) {
        int l = 0, r = height.length - 1;
        int ans = 0;
        while (l < r) {
            int area = Math.min(height[l], height[r]) * (r - l);
            ans = Math.max(ans, area);
            if (height[l] <= height[r]) {
                ++l;
            }
            else {
                --r;
            }
        }
        return ans;
    }
}
```



#### 【9】排序数组数字出现的次数

> 记住两个关键的判断条件
>
> - //判断是不是第一个K，前一个不等于K，就是第一个K
>   if (middleIndex > 0 && array[middleIndex - 1] != k || middleIndex == 0) {
> - //判断是不是最后一个K，后一个不等于K，就是最后一个K
>   if (middleIndex < array.length - 1 && array[middleIndex + 1] != k || middleIndex == array.length - 1)

```java
//如果数组中全是同一个数就会退化成O(n)，还是要两边都二分的,难道二分就不是？？？来自LeetCode的一条评论
class Solution {
    public int search(int[] nums, int target) {
        int left =0,right = nums.length-1;
        int count = 0;
        while(left<right){
            int mid = (left+right)/2;
            if(nums[mid] >= target)
                right=mid;
            if(nums[mid]<target)
                left = mid+1;
        }
        while(left<nums.length && nums[left]==target)
          	left++
            count++;
        return count;
    }
}

//也可以用双指针

//------------------------------------------------------------------------

public int GetNumberOfK(int [] array , int k) {
      int num = 0;
        if (array != null && array.length > 0) {
            int firstKIndex = getFirstK(array, k, 0, array.length - 1);
            int lastKIndex = getLastK(array, k, 0, array.length - 1);
            if (firstKIndex > -1 && lastKIndex > -1)
                num = lastKIndex - firstKIndex + 1;
        }
        return num;
    }

    /*
    * 找到第一个出现的数字的下标
    */
    public  int getFirstK(int[] array, int k, int start, int end) {
        if (start > end)
            return -1;
        int middleIndex = start + (end - start) / 2;
        int middleData = array[middleIndex];
        //先判断中间的值是否等于k
        if (middleData == k) {
        //判断是不是第一个K，前一个不等于K，就是第一个K
            if (middleIndex > 0 && array[middleIndex - 1] != k || middleIndex == 0) {
                return middleIndex;
            } else
                end = middleIndex - 1;
        } else if (middleData > k) {
            end = middleIndex - 1;
        } else
            start = middleIndex + 1;
        return getFirstK(array, k, start, end);
    }

     /*
    * 找到最后一个出现的数字的下标
    */
    public  int getLastK(int array[], int k, int start, int end) {
        if (start > end) {
            return -1;
        }
        int middleIndex = (start + end) / 2;
        int middleData = array[middleIndex];
        if (middleData == k) {
         //判断是不是最后一个K，后一个不等于K，就是最后一个K
            if (middleIndex < array.length - 1 && array[middleIndex + 1] != k || middleIndex == array.length - 1)
                return middleIndex;
            else
                start = middleIndex + 1;
        } else if (middleData < k) {
            start = middleIndex + 1;
        } else
            end = middleIndex - 1;
       return getLastK(array, k, start, end);
    }
```



#### 【10】最小的K个数

输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。

冒泡排序拍k次

```java
import java.util.*;
public class Solution {
    public ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {
        int temp=0;
        	ArrayList<Integer> result;= new ArrayList<Integer>();
        if (k>input.length)
            return result;
        	for (int i =0 ; i<k ; i++) {
        		for (int j=i;j<input.length;j++) {
        			if (input[i]> input[j])
        			{
        				temp=input[i];
        				input[i]=input[j];
        				input[j]=temp;
        			}
        		}
        		result.add(input[i]);
        	}
        	return result;;
    }
}
```



#### 【11】寻找第K大

有一个整数数组，请你根据快速排序的思路，找出数组中第K大的数。

给定一个整数数组a,同时给定它的大小n和要找的K(K在1到n之间)，请返回第K大的数，保证答案存在。

```java
public class Finder {
    public int findKth(int[] a, int n, int K) {
        // write code here
        return findKth(a, 0, n - 1, K);
    }
    
    public int findKth(int[] a, int low, int high, int k) {
        int part = partition(a, low, high);
        if(k == part - low + 1) {
            return a[part];
        }
        else if(k > part - low) {
            return findKth(a, part + 1, high, k - part + low - 1);
        } else {
            return findKth(a, low, part - 1, k);
        }
    }
    
    public int partition(int[] a, int low, int high) {
        int key = a[low];
        while(low < high) {
            while(low < high && a[high] <= key) high--;
            a[low] = a[high];
            while(low < high && a[low] >= key) low++;
            a[high] = a[low];
        }
        a[low] = key;
      	//直接判断K是不是等于low，然后再递归两边查找就行了，是的话就return。
        return low;
    }
}
```



#### ***【12】子数组最大累加和

给定一个数组arr，返回子数组的最大累加和

例如，arr = [1, -2, 3, 5, -2, 6, -1]，所有子数组中，[3, 5, -2, 6]可以累加出最大的和12，所以返回12.

[要求]

时间复杂度为O(n)*O*(*n*)，空间复杂度为O(1)*O*(1)

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int res = nums[0];
        for(int i = 1; i < nums.length; i++) {
          	//之前的比0大就加上否则加0
            nums[i] = nums[i] + Math.max(nums[i - 1], 0);
          	//加和后的东西和最大值做对比
            res = Math.max(res, nums[i]);
        }
        return res;
    }
}
//
class Solution {
    public int maxSubArray(int[] nums) {
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        int max = dp[0];
        for(int i=1;i < nums.length;i++){
            dp[i] = Math.max(dp[i-1] + nums[i],nums[i]);
            max = Math.max(max,dp[i]);
          //两次求最大值
        }
        return max;
    }
}
```



#### 【153】[寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)[二分]-以right为target

```
假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] 。
请找出其中最小的元素。

示例 1：
输入：nums = [3,4,5,1,2]
输出：1
示例 2：
输入：nums = [4,5,6,7,0,1,2]
输出：0
示例 3：
输入：nums = [1]
输出：1
```

```java
【3，3，1，3】
class Solution {
    public int minArray(int[] numbers) {
        int l = 0, r = numbers.length - 1;
        while (l < r) {
            int mid = (r + l) / 2;
            //只要右边比中间大，那右边一定是有序数组
            if (numbers[r] > numbers[mid]) {
                r = mid;
            } else if (numbers[r] < numbers[mid]) {
                l = mid + 1;
             //【去重】
            } else r--;
        }
        return numbers[l];
    }
}
//可能稍微有点问题
class Solution {
    public int findMin(int[] nums) {
        int left = 0, right = nums.length - 1;
        while (left < right) {
            int middle = (left + right) / 2;
            if (nums[middle] < nums[right]) {
                // middle可能是最小值
                right = middle;
            } else {
                // middle肯定不是最小值
                left = middle + 1;
            }
        }
        return nums[left];
    }
}
```

#### 【33】[搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)[不是最小值]

```java
思路：如果中间的数小于最右边的数，则右半段是有序的，若中间数大于最右边数，则左半段是有序的，我们只要在有序的半段里用首尾两个数组来判断目标值是否在这一区域内，这样就可以确定保留哪半边了

class Solution {
    public int search(int[] nums, int target) {
        int len = nums.length;
        int left = 0, right = len-1;
        while(left <= right){
            int mid = (left + right) / 2;
            if(nums[mid] == target)
                return mid;
            else if(nums[mid] < nums[right]){
                if(nums[mid] < target && target <= nums[right])
                    left = mid+1;
                else
                    right = mid-1;
            }
            else{
                if(nums[left] <= target && target < nums[mid])
                    right = mid-1;
                else
                    left = mid+1;
            }
        }
        return -1;
    }
}
```



#### 【35】[搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

```
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
你可以假设数组中无重复元素。

示例 1:
输入: [1,3,5,6], 5
输出: 2
示例 2:
输入: [1,3,5,6], 2
输出: 1
示例 3:
输入: [1,3,5,6], 7
输出: 4
示例 4:
输入: [1,3,5,6], 0
输出: 0
```

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int zuo=0;
        int you=nums.length;
        while(zuo<you){
            int mid=(zuo+you)/2;
            if(nums[mid]>=target){you=mid;}
            else{zuo=mid+1;}
        }
        return zuo;
    }
}
```



#### 【14】在两个长度相等的排序数组中找到上中位数

```java
[1,2,3,4],[3,4,5,6]
返回值
3
说明:总共有8个数，上中位数是第4小的数，所以返回3。
```

```java
public class Solution {
    public int findMedianinTwoSortedAray (int[] arr1, int[] arr2) {
        // write code here
        int n = arr1.length;
        int left = 0;
        int right = n;
        while(left<right){
            int i = left + ((right-left)>>1);
            int j = n - i;
            if(arr1[i] < arr2[j-1]){
                left = i+1;
            }else{
                right = i;
            }
        }
        int bound1 = left;
        int bound2 = n - left;
        if(bound1 == n){
            return arr1[n-1];
        }
        if(bound2 == n){
            return arr2[n-1];
        }
        return Math.max(arr1[bound1-1], arr2[bound2-1]);
    }
}
```

#### 【15】合并区间

```java
给出一组区间，请合并所有重叠的区间。
示例1
输入
[[10,30],[20,60],[80,100],[150,180]]
返回值
[[10,60],[80,100],[150,180]]
```

```java
import java.util.*;
/**
 * Definition for an interval.
 * public class Interval {
 *     int start;
 *     int end;
 *     Interval() { start = 0; end = 0; }
 *     Interval(int s, int e) { start = s; end = e; }
 * }
 */
public class Solution {
    public ArrayList<Interval> merge(ArrayList<Interval> intervals) {
         ArrayList<Interval> list=new ArrayList<Interval>();
        if(intervals.size()==0||intervals==null)
            return list;
        intervals.sort(new Comparator<Interval>(){
            public int compare(Interval o1,Interval o2){
                if(o1.start<o2.start){
                    return -1;
                }
                else if(o1.start==o2.start){
                    return 0;
                }else{
                    return 1;
                }
            }
        });
       for(int i=1;i<intervals.size();i++){
           if(intervals.get(i).start<=intervals.get(i-1).end){
               intervals.get(i).start=intervals.get(i-1).start;
               intervals.get(i).end=Math.max(intervals.get(i).end,intervals.get(i-1).end);
           }
           else{
               list.add(intervals.get(i-1));
           }
       }
        list.add(intervals.get(intervals.size()-1));
        return list;
    }
}
```

#### 【16】数组未出现的最小正数

```java
给定一个无序数组arr，找到数组中未出现的最小正整数
例如arr = [-1, 2, 3, 4]。返回1
arr = [1, 2, 3, 4]。返回5
[要求]
时间复杂度为O(n)O(n)，空间复杂度为O(1)O(1)
输入
[-1,2,3,4]
返回值
1
```

```java
public class Solution {
    public int minNumberdisappered (int[] arr) {
        // write code here
        Arrays.sort(arr);
        int x = 0;
        for(int i = 0; i < arr.length; i++){
            if(arr[i]<=0){
                continue;
            }
            x = x+1;
            if(arr[i]!= x){
                return x;
            }
        }
        return x+1;
    }
}
```

#### 【88】[合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

```
给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。

说明：
初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。
你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。

示例：
输入：
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3
输出：[1,2,2,3,5,6]
```

```java
//双指针、从后往前
class Solution {
  public void merge(int[] nums1, int m, int[] nums2, int n) {
    // two get pointers for nums1 and nums2
    int p1 = m - 1;
    int p2 = n - 1;
    // set pointer for nums1
    int p = m + n - 1;

    // while there are still elements to compare
    while ((p1 >= 0) && (p2 >= 0))
      // compare two elements from nums1 and nums2 
      // and add the largest one in nums1 
      nums1[p--] = (nums1[p1] < nums2[p2]) ? nums2[p2--] : nums1[p1--];

    // add missing elements from nums2
    System.arraycopy(nums2, 0, nums1, 0, p2 + 1);
  }
}
```



#### 【349】[两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)[双指针]

```
给定两个数组，编写一个函数来计算它们的交集。
示例 1：
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
示例 2：
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
```

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        int length1 = nums1.length, length2 = nums2.length;
        int[] intersection = new int[length1 + length2];
        int index = 0, index1 = 0, index2 = 0;
        while (index1 < length1 && index2 < length2) {
            int num1 = nums1[index1], num2 = nums2[index2];
            if (num1 == num2) {
                // 保证加入元素的唯一性
                if (index == 0 || num1 != intersection[index - 1]) {
                    intersection[index++] = num1;
                }
                index1++;
                index2++;
            } else if (num1 < num2) {
                index1++;
            } else {
                index2++;
            }
        }
        return Arrays.copyOfRange(intersection, 0, index);
    }
}
```





#### 【18】[移除元素](https://leetcode-cn.com/problems/remove-element/)

```
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

示例 1:

给定 nums = [3,2,2,3], val = 3,

函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。

你不需要考虑数组中超出新长度后面的元素。
示例 2:

给定 nums = [0,1,2,2,3,0,4,2], val = 2,

函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

注意这五个元素可为任意顺序。

你不需要考虑数组中超出新长度后面的元素。
```

```java
//思路

既然问题要求我们就地删除给定值的所有元素，我们就必须用 O(1)O(1) 的额外空间来处理它。如何解决？我们可以保留两个指针 ii 和 jj，其中 ii 是慢指针，jj 是快指针。

//算法
当 nums[j]nums[j] 与给定的值相等时，递增 jj 以跳过该元素。只要 nums[j] \neq valnums[j] 
 =val，我们就复制 nums[j]nums[j] 到 nums[i]nums[i] 并同时递增两个索引。重复这一过程，直到 jj 到达数组的末尾，该数组的新长度为 ii。
该解法与 删除排序数组中的重复项 的解法十分相似。
```

```java
public int removeElement(int[] nums, int val) {
    int i = 0;
    for (int j = 0; j < nums.length; j++) {
        if (nums[j] != val) {
            nums[i] = nums[j];
            i++;
        }
    }
    return i;
}

//方法二：双指针 —— 当要删除的元素很少时
public int removeElement(int[] nums, int val) {
    int i = 0;
    int n = nums.length;
    while (i < n) {
        if (nums[i] == val) {
            nums[i] = nums[n - 1];
            // reduce array size by one
            n--;
        } else {
            i++;
        }
    }
    return n;
}
```



#### 【53】[最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

```
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

输入: [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int res = nums[0];
        int sum = 0;
      	//只要目前和大于零就一直累加
        for (int num : nums) {
            if (sum > 0)
                sum += num;
          	//否则重置sum
            else
                sum = num;
          	//看看累加后的sum是否变小了，变小了就用原来的res
            res = Math.max(res, sum);
        }
        return res;
    }
}
//动态规划
class Solution {
    public int maxSubArray(int[] nums) {
        int pre = 0, maxAns = nums[0];
        for (int x : nums) {
            pre = Math.max(pre + x, x);
            maxAns = Math.max(maxAns, pre);
        }
        return maxAns;
    }
}
```

```java
// class Solution {
//     public int maxSubArray(int[] nums) {
//         int res = nums[0];
//         for(int i = 1; i < nums.length; i++) {
//           	//之前的比0大就加上否则加0
//             nums[i] = nums[i] + Math.max(nums[i - 1], 0);
//           	//加和后的东西和最大值做对比
//             res = Math.max(res, nums[i]);
//         }
//         return res;
//     }
// }

class Solution {
    public int maxSubArray(int[] nums) {
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        int max = dp[0];
        for(int i=1;i < nums.length;i++){
            dp[i] = Math.max(dp[i-1] + nums[i],nums[i]);
            max = Math.max(max,dp[i]);
        }
        return max;
    }
}
```



#### 【56】[合并区间](https://leetcode-cn.com/problems/merge-intervals/)

```
给出一个区间的集合，请合并所有重叠的区间。

示例 1:

输入: intervals = [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
示例 2:

输入: intervals = [[1,4],[4,5]]
输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。
注意：输入类型已于2019年4月15日更改。 请重置默认代码定义以获取新方法签名。

```

```java
//时间换空间
//遍历一遍找出最小最大值，然后new数组
class Solution {
    public int[][] merge(int[][] intervals) {
        BitSet bitSet = new BitSet();
        int max = 0;
        for (int[] interval : intervals) {
            int temp = interval[1] * 2 + 1;
            bitSet.set(interval[0] * 2, temp, true);
            max = temp >= max ? temp : max;
        }

        int index = 0, count = 0;
        while (index < max) {
            int start = bitSet.nextSetBit(index);
            int end = bitSet.nextClearBit(start);

            int[] item = {start / 2, (end - 1) / 2};
            intervals[count++] = item;

            index = end;
        }
        int[][] ret = new int[count][2];
        for (int i = 0; i < count; i++) {
            ret[i] = intervals[i];
        }

        return ret;
    }
}
```



#### 【283】[移动零](https://leetcode-cn.com/problems/move-zeroes/)

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int n = nums.length, left = 0, right = 0;
        while (right < n) {
            if (nums[right] != 0) {
                //和我想的一样啊不为零就往前交换
                swap(nums, left, right);
                left++;
            }
            right++;
        }
    }

    public void swap(int[] nums, int left, int right) {
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
}
```

#### 【217】[存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)

```java
class Solution {
    public boolean containsDuplicate(int[] nums) {
        Set<Integer> set = new HashSet<Integer>();
        for (int x : nums) {
            if (!set.add(x)) {
                return true;
            }
        }
        return false;
    }
}
```



#### 【Offer21】[调整数组顺序使奇数位于偶数前面](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)

```java
//一次快排
class Solution {
    public int[] exchange(int[] nums) {
        int left = 0;
        int right = nums.length - 1;
        while (left < right) {
            while (left < right && nums[left] % 2 != 0) {
                left++;
            }
            while (left < right && nums[right] % 2 == 0) {
                right--;
            }
            if (left < right) {
                int temp = nums[left];
                nums[left] = nums[right];
                nums[right] = temp;
            }
        }
        return nums;
    }
}
```



#### 【Offer61】[扑克牌中的顺子](https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)

```
从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。

示例 1:
输入: [1,2,3,4,5]
输出: True

示例 2:
输入: [0,0,1,2,5]
输出: True
 
限制：
数组长度为 5 
数组的数取值为 [0, 13] .
```


```java
class Solution {
    //1. 排序；2. 统计 0 和 其他数字间的空隙大小；3. 当 0 的个数大于等于间隙大小的时候返回真。
    public boolean isStraight1(int[] nums) {
        Arrays.sort(nums);
        int zeroCnt=0,diff=0;
        for(int i=0;i<nums.length-1;i++){
            if(nums[i]==0){
                zeroCnt++;
            }else{
                if(nums[i]==nums[i+1]) return false;
                if(nums[i]+1!=nums[i+1]){
                    diff+=nums[i+1]-nums[i]-1;
                }
            }
        }
        return zeroCnt>=diff;
    }

    public boolean isStraight(int[] nums) {
        int[] bucket=new int[14];
        int min=14,max=-1;
        for(int i=0;i<nums.length;i++){
            if(nums[i]==0) continue;
            //有非0的对子,直接false
            if(bucket[nums[i]]==1) return false;
            bucket[nums[i]]++;
            //记录牌面最大和最小
            min=Math.min(min,nums[i]);
            max=Math.max(max,nums[i]);
        }
        //小于等于4就行,少的用0补
        return max-min<=4;
    }
}
```



#### 【Offer45】[把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)

```
输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。
示例 1:
输入: [10,2]
输出: "102"
示例 2:
输入: [3,30,34,5,9]
输出: "3033459"
```

```java
class Solution {
    public String minNumber(int[] nums) {
        String[] strs = new String[nums.length];
        for(int i = 0; i < nums.length; i++) 
            strs[i] = String.valueOf(nums[i]);
        //自定义比较规则
        Arrays.sort(strs, (x, y) -> (x + y).compareTo(y + x));
        
        StringBuilder res = new StringBuilder();
        for(String s : strs)
            res.append(s);
        return res.toString();
    }
}
```



#### 【Offer53】[0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)

```
一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。
示例 1:
输入: [0,1,3]
输出: 2
示例 2:
输入: [0,1,2,3,4,5,6,7,9]
输出: 8
```

```java
class Solution {
    public int missingNumber(int[] nums) {
    // 对于有序数组, 大小为i的数应当处于下标为i的位置上, 如果不在, 说明在该数字之前发生了错位
    int numsSize = nums.length;
    int left = 0, right = numsSize - 1;
    while (left < right) {
        int mid = (left + right) / 2;
        if (nums[mid] != mid) { 
            right = mid; 
        } else { 
            left = mid + 1;
        }
    }
    // 如果从0 ~ n - 1都不缺值, 则缺少的是n
    return left == numsSize - 1 && nums[left] == left ? left + 1 : left;
    }
}
```



#### 【Offer62】[圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

```java
class Solution {
    public int lastRemaining(int n, int m) {
        ArrayList<Integer> list = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            list.add(i);
        }
        int idx = 0;
        while (n > 1) {
            idx = (idx + m - 1) % n;
            list.remove(idx);
            n--;
        }
        return list.get(0);
    }
}
```



#### 【Offer49】[丑数](https://leetcode-cn.com/problems/chou-shu-lcof/)

```c
在已有的丑数序列上每一个数都必须乘2， 乘3， 乘5， 这样才不会漏掉某些丑数。假设已有的丑数序列为[1, 2, 3, ..., n1, n2], 如果单纯的让每个丑数乘2， 乘3， 乘5顺序排列的话肯定会有问题，

比如如果按照这样的顺序排列下去肯定有问题[1*2, 1*3, 1*5, 2*2, 2*3, 2*5, 3*2, 3*3, 3*5, ... , n1 *2, n1 * 3, n1 * 5, n2 * 2, n3* 3, n2 * 5]，因为后面乘2的数据可能会比前面乘3乘5的数据要小，那这个乘2的数应该排在他们的前面， 后面乘3的数据也可能比前面乘5的数据要小，那这个乘3的数应该排在他们的前面。

那怎么办呢，每个数都必须乘2， 乘3， 乘5这样才能保证求出所有的丑数，而且还要保证丑数的顺序，这个改如何同时实现呢？

通过观察网上的各个题解，终于找到了办法，那就是记录每个丑数是否已经被乘2， 乘3， 乘5了， 具体的做法是

设置3个索引a, b, c，分别记录前几个数已经被乘2， 乘3， 乘5了，比如a表示前(a-1)个数都已经乘过一次2了，下次应该乘2的是第a个数；b表示前(b-1)个数都已经乘过一次3了，下次应该乘3的是第b个数；c表示前(c-1)个数都已经乘过一次5了，下次应该乘5的是第c个数；

对于某个状态下的丑数序列，我们知道此时第a个数还没有乘2(有没有乘3或者乘5不知道）， 第b个数还没有乘3(有没有乘2或者乘5不知道），第c个数还没有乘5(有没有乘2或者乘3不知道), 下一个丑数一定是从第a丑数乘2， 第b个数乘3， 第c个数乘5中获得，他们三者最小的那个就是下个丑数。

求得下个丑数后就得判断这个丑数是谁，是某个数通过乘2得到的，还是某个数乘3得到的，又或是说某个数通过乘5得到的。我们可以比较一下这个新的丑数等于究竟是等于第a个丑数乘2, 还是第b个数乘3， 还是第c个数乘5， 通过比较我们肯定可以知道这个新的丑数到底是哪个数通过乘哪个数得到的。假设这个新的丑数是通过第a个数乘2得到的，说明此时第a个数已经通过乘2得到了一个新的丑数，那下个通过乘2得到一个新的丑数的数应该是第(a+1)个数，此时我们可以说前 a 个数都已经乘过一次2了，下次应该乘2的是第 （a+1） 个数, 所以a++；如果新的丑数是通过第b个数乘3得到的, 说明此时第 b个数已经通过乘3得到了一个新的丑数，那下个需要通过乘3得到一个新的丑数的数应该是第(b+1)个数，此时我们可以说前 b 个数都已经乘过一次3了，下次应该乘3的是第 （b+1） 个数, 所以 b++；同理，如果这个这个新的丑数是通过第c个数乘5得到的, 那么c++;

但是注意，如果第a个数乘2后等于第b个数乘3，或者等于第c个数乘5， 说明这个新的丑数是有两种或者三种方式可以得到，这时应该给得到这个新丑数的组合对应的索引都加一，比如新丑数是第a个数乘2后和第b个数乘3得到的，那么 a 和 b都应该加一， 因为此时第a个数已经通过乘2得到了一个新的丑数，第b个数已经通过乘3得到了一个新的丑数, 只不过这两个数相等而已。所以我们给计数器加一的时候不能使用 if else else if， 而应该使用if, if, if, 这样才不会把应该加一的计数器漏掉

经过n次循环，就能得到第n 个丑数了。
```

```java
class Solution {
    public int nthUglyNumber(int n) {
        int[]nums =new int[n];
        nums[0]=1;
        int index2=0,index3=0,index5=0;
        for(int i=1;i<nums.length;i++){
            nums[i]=Math.min(nums[index2]*2,Math.min(nums[index3]*3,nums[index5]*5));
            if(nums[i]==nums[index2]*2)
                index2++;
            if(nums[i]==nums[index3]*3)
                index3++;
            if(nums[i]==nums[index5]*5)
                index5++;
        }
        return nums[n-1];
    }
}

//---------------------------------------------------------------

class Solution {
    public int nthUglyNumber(int n) {
        int[] dp = new int[n];  // 使用dp数组来存储丑数序列
        dp[0] = 1;  // dp[0]已知为1
        int a = 0, b = 0, c = 0;    // 下个应该通过乘2来获得新丑数的数据是第a个， 同理b, c

        for(int i = 1; i < n; i++){
            // 第a丑数个数需要通过乘2来得到下个丑数，第b丑数个数需要通过乘2来得到下个丑数，同理第c个数
            int n2 = dp[a] * 2, n3 = dp[b] * 3, n5 = dp[c] * 5;
            dp[i] = Math.min(Math.min(n2, n3), n5);
            if(dp[i] == n2){
                a++; // 第a个数已经通过乘2得到了一个新的丑数，那下个需要通过乘2得到一个新的丑数的数应该是第(a+1)个数
            }
            if(dp[i] == n3){
                b++; // 第 b个数已经通过乘3得到了一个新的丑数，那下个需要通过乘3得到一个新的丑数的数应该是第(b+1)个数
            }
            if(dp[i] == n5){
                c++; // 第 c个数已经通过乘5得到了一个新的丑数，那下个需要通过乘5得到一个新的丑数的数应该是第(c+1)个数
            }
        }
        return dp[n-1];
    }
}
```



#### 【Offer57】[和为s的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)

```
输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。
序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

示例 1：

输入：target = 9
输出：[[2,3,4],[4,5]]
示例 2：

输入：target = 15
输出：[[1,2,3,4,5],[4,5,6],[7,8]]
```

```java
class Solution {
    public int[][] findContinuousSequence(int target) {
        List<int[]> list = new ArrayList<>();

        //🧠里要有一个区间的概念，这里的区间是(1, 2, 3, ..., target - 1)
        //套滑动窗口模板，l是窗口左边界，r是窗口右边界，窗口中的值一定是连续值。
        //当窗口中数字和小于target时，r右移; 大于target时，l右移; 等于target时就获得了一个解
        for (int l = 1, r = 1, sum = 0; r < target; r++) {
            //不会重置sum或者right
            sum = sum + r;
            while (sum > target) {
                //回退sum
                sum = sum - l;
                l++;
            }
            if (sum == target) {
                int[] temp = new int[r - l + 1];
                for (int i = 0; i < temp.length; i++) {
                    temp[i] = l + i;
                }
                list.add(temp);
            }
        }

        int[][] res = new int[list.size()][];
        for (int i = 0; i < res.length; i++) {
            res[i] = list.get(i);
        }
        return res;
    }
}
```



---

### 3、字符串

- [minmin的总结](https://www.jianshu.com/p/9648e8dd5bdb)

#### 【1】最长子串

> - 题目：从字符串中找出一个最长的不包含重复数字的子字符串的长度。例如在字符串中”arabcacfr”，最长非重复子字符串为“rabc”或”acfr”，长度为4
> - 思路：使用动态规划。先用长度为26的数组positions来存储当前字符上次出现的位置；再定义字符串长度的数组lines表示以当前字母为结尾的最长不含重复字符的子字符串的长度。依次遍历字符串中的字符：
>   - 若当前字符是第一次出现，说明可以直接添加到前一个非重复子字符串，因此lines[i]=lines[i-1]+1；
>   - 若当前字符非第一次出现，需计算当前字符与它上次出现位置之间的距离d：
>     - 若d大于lines[i-1]，说明前一个非重复子字符串中没有包含当前字符，可以添加当前字符到前一个非重复子字符串中，因此lines[i]=lines[i-1]+1；
>     - 若d小于或等于f(i-1)，说明如果加入当前字符会存在重复字符串，需要把上次出现的字符截开，因此lines[i] = d

```java
private int findLongestSubstringLength(String string){
        if (string == null || string.equals("")) {
            return 0;
        }
        int maxLength = 0;//最长不重复子字符串的长度
        int[] positions = new int[26];//存储当前字符上次出现的位置，-1表示没有出现过
        for (int i = 0; i < positions.length; i++){
            positions[i] = -1; 
        }
        int[] lines = new int[string.length()];//存储以当前字符为尾的最长不重复子字符串的长度
        lines[0]=1;
        positions[string.charAt(0) - 'a']=0;
        for (int i = 1; i < string.length(); i++){
            int prePosition = positions[string.charAt(i) - 'a'];
            if(prePosition>=0){//当前字符非第一次出现
                if((i-prePosition)>lines[i-1]){
                    lines[i]=lines[i-1]+1;
                }else{
                    lines[i]=i-prePosition;//若加入当前字符会出现重复，需要截断
                }
            }else{//当前字符是第一次出现
                lines[i]=lines[i-1]+1;
            }
            positions[string.charAt(i) - 'a'] = i;
            if(lines[i]>maxLength){
                maxLength=lines[i];
            }
        }
        return maxLength;
}
```



#### 【2】替换空格

```java
//replace函数
public static String replaceBlank(StringBuffer sb){
	for (int i = 0; i < sb.length(); i++) {
		char ch1 = sb.charAt(i);
		if(ch1 == ' '){
			sb.replace(i, i+1, "%20");
		}
	}
	return sb.toString();
}
//replaceAll函数
public static String replaceBlank2(String str){
	String str1 = str.replaceAll(" ", "%20");
	return str1;
}
```



#### 【3】第一次只出现一次的字符

> - **题目：**在字符串中找出第一个只出现一次的字符。如输入"abaccdeff"，则输出'b'.
> - **思路：**利用哈希表存储已经遍历过的字符串
> - **复杂度：**时间：O（n），空间O（n）

```java
public class Main {

    public static void main(String[] args) {
        String template = "wangjinmingchengkunfupengbigepangxianyuwangcheng";
        System.out.println(firstNotRepeatingChar(template));
    }

    public static Character firstNotRepeatingChar(String template) {
        if (template == null) {
            return null;
        }

        //注意是LinkedhashMap，要么遍历检验的时候遍历array不要遍历keySet
        //LinkedHashMap是根据插入顺序来保证有序的
        LinkedHashMap<Character, Integer> map = new LinkedHashMap<>();
        char[] array = template.toCharArray();
        for (char key : array) {
            if (map.containsKey(key)) {
                map.put(key, map.get(key) + 1);
            } else {
                map.put(key, 1);
            }
        }
        for (char key : map.keySet()) {
            if (map.get(key) == 1) {
                return key;
            }
        }
        return null;
    }
}
```



#### 【4】只出现一次的数字I、II、III

```java
//题目1------一个一次[2次中挑]
//思路：一直亦或[1^1=0 0^0=0 1^0=1 0^1=1 两者相等为0,不等为1]
给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
class Solution {
    public int singleNumber(int[] nums) {
        int len = nums.length;
        int result=0;
       for(int i=0;i<len;i++){
           result ^=nums[i];
       } 
        return result;
    }
}

//题目2-----一个一次[3次中挑]
给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
//思路：记录每位出现1的次数，如果能被3整除说明唯一存在的数在这一位上为1.
class Solution {
      public int singleNumber(int[] nums) {
        // 对每一位单独统计出现1的次数, 
        // 如果出现的次数不能整除3说明唯一存在的数在这一位上为1, 时间复杂度O(32N)
        int ret = 0;
        for(int i = 0; i < 32; ++i) {
            int bitnums = 0;
            int bit = 1 << i;
            for(int num : nums) {
                if((num&bit) != 0)
                    bitnums++;
            }
            if(bitnums % 3 != 0)
            	//改变result的位
                ret |= bit;
        }
        return ret;
    }
}

//题目3-----两个一次[2次中挑]
给定一个整数数组 `nums`，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。
你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？
//思路：
class Solution {
    public static int[] singleNumber2(int[] nums) {
        int result = 0;
        for (int i = 0; i < nums.length; i++) {
            result ^= nums[i];
        }
        List<Integer> listOne = new ArrayList<>();
        List<Integer> listTwo = new ArrayList<>();
        for (int i = 0; i < nums.length; i++) {
        }
        int[] ck = new int[0];
        return ck;
    }

    public static int[] singleNumber(int[] nums) {
        if (nums == null || nums.length == 0) return null;

        //得到第一次循环后端亦或结果
        int ck = 0;
        for (int num : nums) {
            ck ^= num;
        }

        List<Integer> listOne = new ArrayList<>();
        List<Integer> listTwo = new ArrayList<>();

        //分组条件
        int f = 1;
        while ((f & ck) != f) {
            f <<= 1;
        }

        //分组
        for (int num : nums) {
            if ((f & num) == f) {
                listOne.add(num);
            } else {
                listTwo.add(num);
            }
        }

        int[] resultOne = new int[listOne.size()];
        int[] resultTwo = new int[listTwo.size()];

        for (int i = 0; i < listOne.size(); i++) {
            resultOne[i] = listOne.get(i);
        }

        for (int i = 0; i < listTwo.size(); i++) {
            resultTwo[i] = listTwo.get(i);
        }

        //对两个小分组进行亦或
        for (int i = 1; i < listOne.size(); i++) {
            resultOne[0] ^= resultOne[i];
        }
        for (int i = 1; i < resultTwo.length; i++) {
            resultTwo[0] ^= resultTwo[i];
        }

        //返回两个小组亦或后的结果
        return new int[]{resultTwo[0], resultOne[0]};
    }
}
```



#### 【】数组最长子序列

- https://www.nowcoder.com/practice/eac1c953170243338f941959146ac4bf?tpId=188&&tqId=36701&rp=1&ru=/ta/job-code-high-week&qru=/ta/job-code-high-week/question-ranking

```
题目描述
给定无序数组arr，返回其中最长的【连续序列】的长度(要求值连续，位置可以不连续,例如 3,4,5,6为连续的自然数）
示例1
输入
[100,4,200,1,3,2]
返回值
4
示例2
输入
[1,1,1]
返回值
1
```

```java
public class Solution {
    public int MLS (int[] arr) {
        if (arr == null || arr.length == 0) {
            return 0;
        }

        int res = 1, sum = 1;
      	//【排序】
        Arrays.sort(arr);
        for (int i = 0; i < arr.length - 1; i++) {
            if (arr[i+1] == arr[i]) {
                continue;
            } else if (arr[i+1] == arr[i] + 1) {
                sum++;
                res = Math.max(res, sum);
            } else {
                sum = 1;
            }
        }
        
        return res;
    }
}
```

```java
import java.util.*;
public class Solution {
    public int MLS (int[] arr) {
        if(arr.length == 0)
            return 0;
        int n = arr.length;
        int max = 1;
        Set<Integer> set = new HashSet<>();
        for(int num:arr)
            set.add(num);   //先将数组中的值都存储在set集合中
        for(int num:arr){
            if(set.contains(num-1)) continue;  //如果集合中包含比当前值小1的，则结束本次循环

            int start = num;   //不存在比当前值小1的，则去寻找以当前值开始的连续子序列
            while(set.contains(start+1)){
                start++;
            }
            //得到较长的子序列
            max = Math.max(max,start-num+1);
        }
        return max;
    }
}



```

```java
1.排序数组
2.统计连续序列长度：遇到重复元素跳过；遇到不连续元素重置；遇到连续元素加一并更新max
public int longestConsecutive(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }

    Arrays.sort(nums);
    int max = 1;
    int continuousLength = 1;
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] == nums[i-1] + 1) {
            continuousLength++;
            max = Math.max(max, continuousLength);
        } else if (nums[i] == nums[i-1]) {
            continue;
        } else {
            continuousLength = 1;
        }
    }
    return max;
}
```

```java
1.HashMap保存每个连续序列中以左边界和右边界的值为key，序列长度为value的键值对
2.每次遇到新的元素x，检查HashMap中是否存在x-1和x+1的序列以及序列长度left和right；计算x所在的序列长度，并更新x、x-left（序列的左边界）、x+right（序列的右边界）的value为这个长度
3.循环的过程中持续更新max
  
public int longestConsecutive(int[] nums) {
    HashMap<Integer, Integer> map = new HashMap<>();
    int max = 0;
    for (int x : nums) {
        if (!map.containsKey(x)) {
            int left = map.getOrDefault(x - 1, 0);
            int right = map.getOrDefault(x + 1, 0);
            int sum = left + right + 1;
            map.put(x, sum);
            map.put(x - left, sum);
            map.put(x + right, sum);
            max = Math.max(max, sum);
        }
    }
    return max;
}
```



#### 【】字符串数组最长无重复子串

给定一个数组arr，返回arr的最长无的重复子串的长度(无重复指的是所有数字都不相同)。

```
输入
[2,3,4,5]

返回值
4

输入
[2,2,3,4,3]

返回值
3
```

```java
import java.util.*;
public class Solution {
    public int maxLength (int[] arr) {
    HashMap<Integer,Integer> map = new HashMap<>();
    int max = 1;
    for(int start = 0, end = 0; end<arr.length ; end++){
        if(map.containsKey(arr[end])){
            //重复了之后如果 在被重复的hashmap现有的下一个开始
            start = Math.max(start, map.get(arr[end])+1);
            //注意：这里一定要取最大的start，不然就错误了
            //为什么？ 因为重复数字的索引很可能比start小
        }
        max = Math.max(max , end-start+1);
        map.put(arr[end],end);
    }
    return max;
}
}
```



#### 【】无重复字符的最长子串

- https://blog.csdn.net/qq_36314960/article/details/82155380
- https://www.cnblogs.com/ariel-dreamland/p/8668286.html
- https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/solution/mian-shi-ti-48-zui-chang-bu-han-zhong-fu-zi-fu-d-9/

```java
示例 1:

输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:

输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
示例 3:

输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
示例 4:

输入: s = ""
输出: 0
```

```java
//双指针和哈希表
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> dic = new HashMap<>();
        int i = -1, res = 0;
        for(int j = 0; j < s.length(); j++) {
            if(dic.containsKey(s.charAt(j)))
                i = Math.max(i, dic.get(s.charAt(j))); // 更新左指针 i【取i和j坐标的最大值】
            dic.put(s.charAt(j), j); // 哈希表记录
            res = Math.max(res, j - i); // 更新结果
        }
        return res;
    }
}
```

```java
//滑动窗口
class Solution {
    public int lengthOfLongestSubstring(String s) {
        // 哈希集合，记录每个字符是否出现过
        Set<Character> occ = new HashSet<Character>();
        int n = s.length();
        // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
        int rk = -1, ans = 0;
        for (int i = 0; i < n; ++i) {
            if (i != 0) {
                // 左指针向右移动一格，移除一个字符
                occ.remove(s.charAt(i - 1));
            }
            while (rk + 1 < n && !occ.contains(s.charAt(rk + 1))) {
                // 不断地移动右指针
                occ.add(s.charAt(rk + 1));
                ++rk;
            }
            // 第 i 到 rk 个字符是一个极长的无重复字符子串
            ans = Math.max(ans, rk - i + 1);
        }
        return ans;
    }
}
```

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        // 记录字符上一次出现的位置
        int[] last = new int[128];
        for(int i = 0; i < 128; i++) {
            last[i] = -1;
        }
        int n = s.length();

        int res = 0;
        int start = 0; // 窗口开始位置
        for(int i = 0; i < n; i++) {
            int index = s.charAt(i);
            start = Math.max(start, last[index] + 1);
            res   = Math.max(res, i - start + 1);
            last[index] = i;
        }

        return res;
    }
}
```

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int res = 0;
        //滑动窗口，用set维护一个不重复的窗口
        Set<Character> set = new HashSet<>();
        for(int l = 0, r = 0; r < s.length(); r++) {
            char c = s.charAt(r);
            while(set.contains(c)) {
                set.remove(s.charAt(l++));
            }
            set.add(c);
            res = Math.max(res, r - l + 1);
        }

        return res;
    }
}

class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> dic = new HashMap<>();
        int i = -1, res = 0;
        for(int j = 0; j < s.length(); j++) {
            if(dic.containsKey(s.charAt(j)))
                i = Math.max(i, dic.get(s.charAt(j))); // 更新左指针 i
            dic.put(s.charAt(j), j); // 哈希表记录
            res = Math.max(res, j - i); // 更新结果
        }
        return res;
    }
}
```



####【647】[回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

```
给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。
具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。
示例 1：

输入："abc"
输出：3
解释：三个回文子串: "a", "b", "c"
示例 2：

输入："aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
```

```java
class Solution {
    int num = 0;
    public int countSubstrings(String s) {
        for (int i=0; i < s.length(); i++){
            count(s, i, i);//回文串长度为奇数
            count(s, i, i+1);//回文串长度为偶数
        }
        return num;
    }
    
  	//left和right才对
    public void count(String s, int start, int end){
        while(start >= 0 && end < s.length() && s.charAt(start) == s.charAt(end)){
            num++;
            start--;
            end++;
        }
    }
}
```



#### 【】最长回文子串

```
给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。

在构造过程中，请注意区分大小写。比如 "Aa" 不能当做一个回文字符串。

注意:
假设字符串的长度不会超过 1010。

示例 1:

输入:
"abccccdd"

输出:
7

解释:
我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。
```

```java
// 循环遍历字符串，以每一步为中心，开始向两边扩散
public class Palindrome {
    public int getLongestPalindrome(String A, int n) {
        // write code here
        if(n <= 0) return 0;
        if(n == 1) return 1;
        
        int max = 0;
        
        for(int i = 1; i < n; i++) {
            int low = i - 1;
            int high = i;
            
          	//第一种情况，没有中轴
            while(low >= 0 && high < n && A.charAt(low) == A.charAt(high)) {
                max = Math.max(high - low + 1, max);
                low--;
                high++;
            }
            
          	//检验是否当前第i个做了中轴
            low = i - 1;
            high = i + 1;
            
            while(low >= 0 && high < n && A.charAt(low) == A.charAt(high)) {
                max = Math.max(high - low + 1, max);
                low--;
                high++;
            }
        }
        
        return max;
    }
}
```

```java
//快手面试
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        //Scanner in = new Scanner(System.in);
        //int a = in.nextInt();
        //System.out.println(a);
        System.out.println("Hello World!");
        
    }
    3,4,5,6,7,8,7,6
    public int[] getXXX(int [] s){
        if(s==null){
            return null;
        }
        int[ ] result=[];
        int point1;
        int point2;
        int max=0;
        for (int i=1;i<s.length;i++){
            point1=i-1;
            point2=i;
            while(s[point1]==s[point2]){
                if(point1>1 && point2<s.length-1) {
                    point1--;
                    point2++;
                }
            }
            
            int temp0=point2-point1-2;
            if(temp0>max){
                max=temp0;
                result=Array.CopyOfRange(s,point1,point2);
            }
            
            point1=i-1;
            point2=i+1;
            
            while(point2<s.length && s[point1]==s[point2]){
                 if(point1>1 && point2<s.length-1) {
                    point1--;
                    point2++;
                }
            }
            
            int temp1=point2-point1-2;
             if(temp1>max){
                max=temp1;
                result=Array.CopyOfRange(s,point1,point2);
            }
            
              
        }
        return result;
        
              
    }
}
```



#### 【409】最长回文串

- [leetcode](https://leetcode-cn.com/problems/longest-palindrome/)

```
给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。
在构造过程中，请注意区分大小写。比如 "Aa" 不能当做一个回文字符串。
注意:
假设字符串的长度不会超过 1010。
示例 1:
输入:
"abccccdd"
输出:
7
解释:
我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。


首先 记录每个字母出现的次数 用Hashmap或者数组都行（开128是因为ASCII马映射数字就是0-128不包括128）。然后就是记录 每次出现的次数，是奇数-》剪一次再拿，是偶数直接拿，简练点的代码就是 v / 2 * 2 ，然后就是出现一次的只能算作一次，因为只能放在中间回文，可以在for-loop中直接查找所有偶次的就行，然后出去之后判断是否有一个单独的字符+1即可，但是官方给了个很舒服的写法。就是根据ans每次都是偶数（因为每次+=的都是偶数、;;;仔细想想）然后利用v % 2 == 1抓住奇数次（包含1和其他奇数）并且 ans % 2 == 0，第一次的时候 肯定ans是偶数，之后ans就是自增，第二次是v奇数的时候，ans早就是奇数了，然后就不会成立。这就是精妙所在
```

```java
class Solution {
    public int longestPalindrome(String s) {
        int count[] = new int[128];
        for (char c : s.toCharArray()) {
            count[c]++;
        }
        int ans = 0;
        for (int v : count) {
            ans += v / 2 * 2;
            if (v % 2 == 1 && ans % 2 == 0) {
                ans++;
            }
        }
        return ans;
    }
}
```



#### 【】最长公共子串

给定两个字符串str1和str2,输出两个字符串的最长公共子串，如果最长公共子串为空，输出-1。

```
"1AB2345CD","12345EF"
"2345"
```

```java
public class Solution {
    /**
     * longest common substring
     * @param str1 string字符串 the string
     * @param str2 string字符串 the string
     * @return string字符串
     */
    public static String LCS (String str1, String str2) {
        // write code here
        StringBuilder sb = new StringBuilder();
        int start = 0, end = 1;
        while (end < str1.length() + 1) {
            if (str2.contains(str1.substring(start, end))) {
                if (sb.length() < end - start) {
                    sb.delete(0, sb.length());
                    sb.append(str1, start, end);
                }
                end++;
            } else {
                start++;
            }
        }
        if (sb.length() == 0) {
            return "-1";
        }
        return sb.toString();
    }
}
```

#### 【】比较版本号

```
如果version1 > version2 返回1，如果 version1 < version2 返回-1，不然返回0.

输入的version字符串非空，只包含数字和字符.。.字符不代表通常意义上的小数点，只是用来区分数字序列。例如字符串2.5并不代表二点五，只是代表版本是第一级版本号是2，第二级版本号是5.

"0.1","1.1"
-1
```

```java
public class Solution {
    public int compare (String version1, String version2) {
        // write code here
        String[] v1 = version1.split("\\.");
        String[] v2 = version2.split("\\.");
        int n1 = v1.length;
        int n2 = v2.length;
        for(int i = 0, j = 0; i < n1 && j < n2;) {
            int a = Integer.parseInt(v1[i]);
            int b = Integer.parseInt(v2[j]);
            if(a < b) return -1;
            else if(a > b) return 1;
            else {
                i++;
                j++;
            }
        } 
        if(n1 > n2) return 1;
        else if(n1 < n2) return -1;
        else return 0;
    }
}
```

#### 【】最长公共子序列

```c
给定两个字符串str1和str2，输出连个字符串的最长公共子序列。如过最长公共子序列为空，则输出-1。
示例1
输入
"1A2C3D4B56","B1D23CA45B6A"
返回值
"123456"
说明
"123456"和“12C4B6”都是最长公共子序列，任意输出一个。
```

```java
public class Solution {
    /**
     * longest common subsequence
     * @param s1 string字符串 the string
     * @param s2 string字符串 the string
     * @return string字符串
     */
    public String LCS (String s1, String s2) {
        if(s1==null || s1.length()==0 || s2==null || s2.length()==0)return "-1";
        int s1L = s1.length();
        int s2L = s2.length();
        StringBuilder str = new StringBuilder();
        while(s1L != 0 && s2L !=0){
            if(s1.charAt(s1L-1)==s2.charAt(s2L-1)){
                str.append(s1.charAt(s1L-1));
                s1L--;
                s2L--;
            }else{
                if (s1L>=2 && s2L>=2) {
                    if (Math.max(s1.charAt(s1L - 2), s2.charAt(s2L - 1)) >= Math.max(s1.charAt(s1L - 1), s2.charAt(s2L - 2)))
                        s2L--;
                    else
                        s1L--;
                }else if (s1L==1){
                    s2L--;
                }else
                    s1L--;
            }
        }
        if(str.length()==0)return "-1";
        return str.reverse().toString();
    }
}
```



#### 【392】[判断子序列](https://leetcode-cn.com/problems/is-subsequence/)

```
给定字符串 s 和 t ，判断 s 是否为 t 的子序列。
字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

进阶：
如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

示例 1：
输入：s = "abc", t = "ahbgdc"
输出：true

示例 2：
输入：s = "axc", t = "ahbgdc"
输出：false
```
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm3e3o3abxj31780j4wj4.jpg" alt="image-20201228110427858" style="zoom: 50%;" />

```java
//
class Solution {
    public boolean isSubsequence(String s, String t) {
        int n = s.length(), m = t.length();
        int i = 0, j = 0;
        while (i < n && j < m) {
            if (s.charAt(i) == t.charAt(j)) {
                i++;
            }
            j++;
        }
        return i == n;
    }
}
```

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        char[] schar = s.toCharArray();
	char[] tchar = t.toCharArray();
	int sIndex = 0;
	int tIndex = 0;
	while (tIndex != tchar.length && sIndex != schar.length) {
                //子序列的字符等于父串的中的字符,子序列的下标sIndex+1
		if (schar[sIndex] == tchar[tIndex]) {
			sIndex++;
		}
		tIndex++;
	}
        //说明子序列已经完全匹配
	if (sIndex == schar.length) {
		return true;
	}
	return false;
    }
}
```



#### 【】[最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)

```
编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

示例 1:

输入: ["flower","flow","flight"]
输出: "fl"
示例 2:

输入: ["dog","racecar","car"]
输出: ""
解释: 输入不存在公共前缀。
```

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        if (strs == null || strs.length == 0) {
            return "";
        }
        int length = strs[0].length();
        int count = strs.length;
        for (int i = 0; i < length; i++) {
            char c = strs[0].charAt(i);
            for (int j = 1; j < count; j++) {
                if (i == strs[j].length() || strs[j].charAt(i) != c) {
                    return strs[0].substring(0, i);
                }
            }
        }
        return strs[0];
    }
}
```



#### 【】最长递增子序列

- [牛客](https://www.nowcoder.com/practice/9cf027bf54714ad889d4f30ff0ae5481?tpId=117)

```java
题目描述
给定数组arr，设长度为n，输出arr的最长递增子序列。（如果有多个答案，请输出其中字典序最小的）
示例1
输入
[2,1,5,3,6,4,8,9,7]
返回值
[1,3,4,8,9]
示例2
输入
[1,2,8,6,4]
返回值
[1,2,4]
说明
其最长递增子序列有3个，（1，2，8）、（1，2，6）、（1，2，4）其中第三个字典序最小，故答案为（1，2，4）
```



#### 【】数字字符串转化成IP地址（回溯）

```java
//回溯法插入'.'，每次可以插入到1个，2个或者3个字符后面，插入3次之后对得到的字符串进行验证
import java.util.*;


public class Solution {
    /**
     * 
     * @param s string字符串 
     * @return string字符串ArrayList
     */
    public ArrayList<String> restoreIpAddresses (String s) {
        // write code here
        ArrayList<String> list=new ArrayList<>();
        if(s.length()==0)return list;
        backTrack(s,0,3,list);
        return list;
    }
    //i:本次插入的起始位置 cnt:剩余可插入'.'的次数
    public void backTrack(String s,int i,int cnt,ArrayList<String> list){
        if(cnt==0){
            String[] strs=s.split("\\."); //'.'要转义
            if(strs.length<4)return ; //保证插入得到4个子串，不会出现多个'.'相连的情况
            for(String str:strs){
                if(str.length()>1&&str.charAt(0)=='0')return ; //排除有前导0的情况
                if(Integer.parseInt(str)<0||Integer.parseInt(str)>255)return ; //排除不在范围的情况
            }
            list.add(s);
            return ;
        }
        if(i>=s.length())return ; //没插完就结束的情况
        int n=s.length();
        backTrack(s.substring(0,i+1)+"."+s.substring(i+1,n),i+2,cnt-1,list); //插入到1个字符之后
        if(i+2<n)backTrack(s.substring(0,i+2)+"."+s.substring(i+2,n),i+3,cnt-1,list); //插入到2个字符之后
        if(i+3<n)backTrack(s.substring(0,i+3)+"."+s.substring(i+3,n),i+4,cnt-1,list); //插入到3个字符之后
    }
}
```

```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param s string字符串 
     * @return string字符串ArrayList
     */
    private ArrayList<String> res;

    public ArrayList<String> restoreIpAddresses (String s) {
        // write code here
        res = new ArrayList<>();
        int[] segments = new int[4];
        backtrace(s, 0, 0, segments);
        return res;
    }

    /**
     *
     * @param s 输入字符串 s
     * @param k 当前遍历的索引
     * @param digits 当前到达的位数
     * @param segments 分别存放IP的四个数
     */
    private void backtrace(String s, int k, int digits, int[] segments) {

        if (digits == 4) {
            if (k == s.length()) {
                StringBuilder sb = new StringBuilder();
                for (int i = 0; i < 3; i++) {
                    sb.append(segments[i]).append(".");
                }
                sb.append(segments[3]);
                res.add(sb.toString());
            }
            return;
        }

        // 提前遍历结束，直接return
        if (k == s.length()) return;


        // 对 0 开头的字符特殊处理
        if (s.charAt(k) == '0') {
            segments[digits] = 0;
            backtrace(s, k + 1, digits + 1, segments);
        }


        int tmp = 0;
        for (int i = k; i < s.length(); i++) {

            tmp = tmp * 10 + (s.charAt(i) - '0');

            if (tmp > 0 && tmp <= 255) {
                segments[digits] = tmp;
                backtrace(s, i + 1, digits + 1, segments);
            } else { // 直接返回，后面不需要处理，这种情况肯定不满足
                break;
            }
        }
    }
}
```



#### 【】验证IP地址

- [niuke](https://www.nowcoder.com/practice/55fb3c68d08d46119f76ae2df7566880?tpId=117&&tqId=35038&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking)

```java
import java.util.*;
public class Solution {
    public String solve (String IP) {
        // write code here
        if(isIpv4(IP)){
            return "IPv4";
        }else if(isIpv6(IP)){
            return "IPv6";
        }else{
            return "Neither";
        }
    }
    
    public boolean isIpv4(String IP){
        String[] parts = IP.split("\\.");
        if(parts.length != 4){
            return false;
        }
        for(int i = 0; i< parts.length;i++){
            String part = parts[i];
            if(part.startsWith("0") && part.length() > 1){
                return false;
            }
            try{
                int res = Integer.parseInt(part);
                if(res <0 || res > 255){
                    return false;
                }
            }catch(Exception e){
                return false;
            }
        }
        return true;
    }
    
    public boolean isIpv6(String IP){
        String[] parts = IP.split(":");
        if(parts.length!=8){
            return false;
        }
        for(int i = 0;i<parts.length;i++){
            String part = parts[i];
            if(part.length() > 4){
                return false;
            }
        }
        return true;
    }
}
```



#### 【6】[Z/N字形变换](https://leetcode-cn.com/problems/zigzag-conversion/)

```
将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 "LEETCODEISHIRING" 行数为 3 时，排列如下：

L   C   I   R
E T O E S I I G
E   D   H   N
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："LCIRETOESIIGEDHN"。

请你实现这个将字符串进行指定行数变换的函数：

string convert(string s, int numRows);
示例 1:

输入: s = "LEETCODEISHIRING", numRows = 3
输出: "LCIRETOESIIGEDHN"
示例 2:

输入: s = "LEETCODEISHIRING", numRows = 4
输出: "LDREOEIIECIHNTSG"
解释:

L     D     R
E   O E   I I
E C   I H   N
T     S     G
```

```java

```



#### 【13】[罗马数字转整数](https://leetcode-cn.com/problems/roman-to-integer/)

```
罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。

示例 1:
输入: "III"
输出: 3
示例 2:
输入: "IV"
输出: 4
示例 3:
输入: "IX"
输出: 9
示例 4:
输入: "LVIII"
输出: 58
解释: L = 50, V= 5, III = 3.
示例 5:
输入: "MCMXCIV"
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
```

```java
class Solution {
    public int romanToInt(String s) {
        s = s.replace("IV","a");
        s = s.replace("IX","b");
        s = s.replace("XL","c");
        s = s.replace("XC","d");
        s = s.replace("CD","e");
        s = s.replace("CM","f");
        
        int result = 0;
        for (int i=0; i<s.length(); i++) {
            result += which(s.charAt(i));
        }
        return result;
    }

    public int which(char ch) {
        switch(ch) {
            case 'I': return 1;
            case 'V': return 5;
            case 'X': return 10;
            case 'L': return 50;
            case 'C': return 100;
            case 'D': return 500;
            case 'M': return 1000;
            case 'a': return 4;
            case 'b': return 9;
            case 'c': return 40;
            case 'd': return 90;
            case 'e': return 400;
            case 'f': return 900;
        }
        return 0;
    }
}
//--------
class Solution {
    public int romanToInt(String s) {
        Map<String,Integer> map=new HashMap<>();
        map.put("I",1);
        map.put("V",5);
        map.put("X",10);
        map.put("L",50);
        map.put("C",100);
        map.put("D",500);
        map.put("M",1000);
        map.put("A",4);
        map.put("B",9);
        map.put("Q",40);
        map.put("P",90);
        map.put("E",400);
        map.put("F",900);
        s=s.replace("IV","A").
                replace("IX","B").
                replace("XL","Q").
                replace("XC","P").
                replace("CD","E").
                replace("CM","F");
        Integer result=0;
        for(int i=0;i<s.length();i++){
            String temp=s.substring(i,i+1);
            result+=map.get(temp);
        }
        return result;
    }
}
```



#### 【415】[字符串相加](https://leetcode-cn.com/problems/add-strings/)

```java
class Solution {
    public String addStrings(String num1, String num2) {
        int i = num1.length() - 1, j = num2.length() - 1, add = 0;
        StringBuffer ans = new StringBuffer();
        while (i >= 0 || j >= 0 || add != 0) {
            int x = i >= 0 ? num1.charAt(i) - '0' : 0;
            int y = j >= 0 ? num2.charAt(j) - '0' : 0;
            int result = x + y + add;
            ans.append(result % 10);
            add = result / 10;
            i--;
            j--;
        }
        // 计算完以后的答案需要翻转过来
        ans.reverse();
        return ans.toString();
    }
}
```



#### 【43】[字符串相乘](https://leetcode-cn.com/problems/multiply-strings/)

```java
给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。
示例 1:
输入: num1 = "2", num2 = "3"
输出: "6"
示例 2:
输入: num1 = "123", num2 = "456"
输出: "56088"
```

```java

```



#### 【389】[找不同](https://leetcode-cn.com/problems/find-the-difference/)

```
给定两个字符串 s 和 t，它们只包含小写字母。
字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。
请找出在 t 中被添加的字母。
示例 1：
输入：s = "abcd", t = "abcde"
输出："e"
解释：'e' 是那个被添加的字母。
```

```java
class Solution {
    public char findTheDifference(String s, String t) {
        int[] cnt = new int[26];
        for (int i = 0; i < s.length(); ++i) {
            char ch = s.charAt(i);
            cnt[ch - 'a']++;
        }
        for (int i = 0; i < t.length(); ++i) {
            char ch = t.charAt(i);
            cnt[ch - 'a']--;
            //计数法
            if (cnt[ch - 'a'] < 0) {
                return ch;
            }
        }
        return ' ';
    }
}
```



#### 【205】[同构字符串](https://leetcode-cn.com/problems/isomorphic-strings/)

```
给定两个字符串 s 和 t，判断它们是否是同构的。
如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。
所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。
示例 1:
输入: s = "egg", t = "add"
输出: true
示例 2:
输入: s = "foo", t = "bar"
输出: false
示例 3:
输入: s = "paper", t = "title"
输出: true
```

```java
class Solution {
    public boolean isIsomorphic(String s, String t) {
        Map<Character, Character> s2t = new HashMap<Character, Character>();
        Map<Character, Character> t2s = new HashMap<Character, Character>();
        int len = s.length();
        for (int i = 0; i < len; ++i) {
            char x = s.charAt(i), y = t.charAt(i);
            //关键判断语句
            if ((s2t.containsKey(x) && s2t.get(x) != y) 
                || (t2s.containsKey(y) && t2s.get(y) != x)) {
                return false;
            }
            s2t.put(x, y);
            t2s.put(y, x);
        }
        return true;
    }
}
```



---

### 4、链表

#### 【1】从尾到头打印链表

> - **题目：**输入一链表的头结点，从尾到头输出链表，注意是尾到头
> - **思路：**两种解法，递归和利用辅助栈
> - **复杂度：**
>   - 辅助栈：时间：O（n），空间O（n）
>   - 递归：时间：O（n），空间O（1），链表过长容易栈溢出

```java
//辅助栈
public class Main {
    Stack<Integer> stack = new Stack<>();

    private void showListFromTailToHead(ListNode head) {
        if (head == null) {
            System.out.println("链表为空");
        } else {
            ListNode tempNode = head;
            while (tempNode != null) {
                stack.push(tempNode.val);
                tempNode = tempNode.next;
            }
            while (!stack.empty()) {
                System.out.print(stack.pop() + " -> ");
            }
            stack = null;
        }
    }
}
//递归
	private  ArrayList<Integer> result=new ArrayList<>();
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        if (listNode != null) {
            printListFromTailToHead(listNode.next);
            result.add(listNode.val);
        }
        return result;
    }
```



#### 【2】翻转链表

> - **题目**：翻转链表
> - **思路：**三个节点：前、中、后
> - **复杂度：**时间：O（n），空间O（1）

```java
private ListNode reverseList(ListNode head) {
        //翻转时需要储存前中后三个节点的引用以及返回节点的
        ListNode resultHead = null;
        ListNode currnetNode = head;
        ListNode preNode = null;
        ListNode nextNode = null;
        while (currnetNode != null) {
            nextNode = currnetNode.next;
            if (nextNode == null) {//找到链表尾部
                resultHead = currnetNode;
            }
            currnetNode.next = preNode;//将当前节点next指向头一个节点
            preNode = currnetNode;//当前节点做头
            currnetNode = nextNode;//下一个节点做当前节点
        }
        return resultHead;
    }
```

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;
        while (curr != null) {
            ListNode nextTemp = curr.next;
            curr.next = prev;
            prev = curr;
            curr = nextTemp;
        }
        return prev;
    }
}
//递归
class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode p = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return p;
    }
}
```



#### 【25】[K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode dummy = new ListNode(0), prev = dummy, curr = head, next;
        dummy.next = head;
        int length = 0;
        while(head != null) {
            length++;
            head = head.next;
        }
        for(int i = 0; i < length / k; i++) {
            for(int j = 0; j < k - 1; j++) {
                next = curr.next;
                curr.next = next.next;
                next.next = prev.next;
                prev.next = next;
            }
          //连接链表
            prev = curr;
            curr = prev.next;
        }
        return dummy.next;
    }
}
```



```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode hair = new ListNode(0);
        hair.next = head;
        ListNode pre = hair;

        while (head != null) {
            ListNode tail = pre;
            // 查看剩余部分长度是否大于等于 k
            for (int i = 0; i < k; ++i) {
                tail = tail.next;
                if (tail == null) {
                    return hair.next;
                }
            }
            ListNode nex = tail.next;
            ListNode[] reverse = myReverse(head, tail);
            head = reverse[0];
            tail = reverse[1];
            // 把子链表重新接回原链表
            pre.next = head;
            tail.next = nex;
            pre = tail;
            head = tail.next;
        }

        return hair.next;
    }

    public ListNode[] myReverse(ListNode head, ListNode tail) {
        ListNode prev = tail.next;
        ListNode p = head;
        while (prev != tail) {
            ListNode nex = p.next;
            p.next = prev;
            prev = p;
            p = nex;
        }
        return new ListNode[]{tail, head};
    }
}
```



#### 【3】区间翻转

```java
public class Solution {
    public ListNode reverseBetween (ListNode head, int m, int n) {
        // write code here
        if(head == null) return null;
        ListNode res = new ListNode(-1);
        res.next = head; // -1->1->2->3->4->5
        ListNode pre = res; //备份指针
        //移动指针，找到m之前的位置
        for(int i = 1; i<m; i++){
            pre = pre.next; //指向1
        }
        //创建当前指针
        ListNode cur = pre.next; //指向2
        //反转链表，从m这个位置开始到n
        for(int i = m; i < n; i++){
            ListNode temp = cur.next;
            cur.next = temp.next;
            temp.next = pre.next;
            pre.next = temp;
        }
        return res.next;
    }
}
```

```java
//递归方式
public Node reverse(Node head){
        /*
        LinkedList:  head->1->2
        1> 第一层递归
           temp=head.next (temp=1)
           newHead=reverse(1)
        2> 第二层递归
           temp=head.next (temp=2)
           newHead=reverse(2) 返回2
           2.next=head (1)  后面的结点的next等于前面的结点
           head.next=null    删除前面结点的指向
           return newHead (2)
        3> 回到第一层递归
           newHead=2
           1.next=head    后面的结点的next等于前面的结点
           head.next=null    删除前面结点的指向
           return newHead  此时的newHead为新的头结点
         */
        if (head==null || head.next==null){
            return head;
        }
        Node temp=head.next;
        Node newHead=reverse(head.next);
        temp.next=head;
        head.next=null;
        return newHead;
    }
  public ListNode reverseList(ListNode head) {
 
    if(head == null || head.next == null){
      return head;
    }
    // 遍历到链表尾部
    ListNode newHead = reverseList(head.next);
    // 反转
    head.next.next = head;
    head.next = null;
 
    return newHead;
  }
```



#### 【3】判断链表有环

> - 题目：如何判断一个链有环，**请找出该链表的环的入口结点**，否则输出null
> - 思路：用p1、p2指向链表头部，然后p1每次走一步、p2每次走两步；显然，当p1和p2第一次相遇时，p2正好比p1多走了一个环；设p2此时走了2x步，p1走了x步，则环长=2x-x=x，因此p1和p2相遇点正好是环的入口点，只要找到p1==p2时的节点即可

```java
class Solution {
    public static LinkNode entryNodeOfLoop(LinkNode head) {
        //判断链表长度大于等于3
        if (head == null || head.next == null || head.next.next == null) {
            return null;
        }
        LinkNode fast = head.next.next;
        LinkNode slow = head.next;
        //找到相遇点，将快节点置为头，再次相遇即为头
        while (fast != slow) {
            //记住if条件
            if (fast.next!=null && fast.next.next != null ) {
                fast = fast.next.next;
                slow = slow.next;
            } else {
                return null;
            }
        }
        //快指针变为头，一次走一步
        fast = head;
        while (fast != slow) {
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }
}
```



#### 【4】如何判断两条链表交叉

> - **题目：**编写一个程序，找到两个单链表相交的起始节点
> - **思路：**如果两个单向链表有公共的结点，也就是说两个链表从某一结点开始，它们的m_pNext都指向同一个结点。但由于是单向链表的结点，每个结点只有一个m_pNext，因此从第一个公共结点开始，之后它们所有结点都是重合的，不可能再出现分叉。所以，两个有公共结点而部分重合的链表，拓扑形状看起来像一个Y，而不可能像X。


```java
//解法4
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        /**
        定义两个指针, 第一轮让两个到达末尾的节点指向另一个链表的头部, 最后如果相遇则为交点(在第一轮移动中恰好抹除了长度差)
        两个指针等于移动了相同的距离, 有交点就返回, 无交点就是各走了两条指针的长度
        **/
        if(headA == null || headB == null) return null;
        ListNode pA = headA, pB = headB;
        // 在这里第一轮体现在pA和pB第一次到达尾部会移向另一链表的表头, 而第二轮体现在如果pA或pB相交就返回交点, 不相交最后就是null==null
        while(pA != pB) {
            //pA==null耗时pA.next==null都没有影响
            pA = pA == null ? headB : pA.next;
            pB = pB == null ? headA : pB.next;
        }
        return pA;
    }
}
```



#### 【5】删除排序链表重复节点

> - 题目：在一个排好序的链表中存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，并返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5。
> - 思路：

```java
public class Solution {
    public ListNode deleteDuplicates(ListNode head) {
    ListNode current = head;
    //因为要调用到current.next.next所以要保证current.next!=null
    while (current != null && current.next != null) {
        if (current.next.val == current.val) {
            //如果值相等就指向下下个
            current.next = current.next.next;
        } else {
            //否则current往后移动
            current = current.next;
        }
    }
    return head;
	}
}
```



#### 【6】倒数第k个节点[找到与删除]

> 注意循环都是从1开始的,一个是< 一个是<=

> - 题目：输入一个链表，输出该链表中倒数第k个结点
> - 思路：用p1、p2指向链表头部，先让p1走(k-1)步到达第k个节点，此时p1和p2相隔k个节点；然后p1、p2同时往后移动，当p1到达链尾时，p2所在位置正是倒数第k个节点

```java
//删除倒数第k节点
public ListNode removeNthFromEnd(ListNode head, int n) {
    //防止个数为1的时候的空指针异常
    ListNode result = new ListNode(0);
    result.next = head;
    //这样是为了避免删除第一个节点的时候造成空指针异常
    ListNode first = result;
    ListNode second = result;
    // 注意i< = n
    for (int i = 1; i <= n ; i++) {
        first = first.next;
    }
    // 注意是first.next ！=null
    while (first.next != null) {
        first = first.next;
        second = second.next;
    }
    second.next = second.next.next;
    return result.next;
}
//找到倒数第k节点
public ListNode FindKthToTail(ListNode head,int k) {
        if(head==null||k<=0){
            return null;
        }
        ListNode pre=head;
        ListNode last=head; 
    	//注意不要从0开始，从1开始，然后走k-1步
        for(int i=1;i<k;i++){
            if(pre.next!=null){
                pre=pre.next;
            }else{
                return null;
            }
        }
        while(pre.next!=null){
            pre = pre.next;
            last=last.next;
        }
        return last;
    }
```



#### 【7】合并有序链表

> - 题目：输入两个单调递增的链表，输出两个链表合成后的链表，并保证满足单调不减规则。
> - 思路：每次都取俩链表中最靠前的俩元素中的更小元素到重组链表中，被取走元素的旧链表后移一个元素继续进行“车轮战”；注意如果只剩一条未结束链表要记得全部插入到重组链表的最后

```java
//方法1:非递归
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        //新建一个头节点，用来存合并的链表
        ListNode head=new ListNode(-1);
        head.next=null;
        ListNode result=head;
        while(list1!=null&&list2!=null){
            if(list1.val<list2.val){
                head.next=list1;
                head=list1;//其实就是head=head.next下面同理
                list1=list1.next;
            }else{
                head.next=list2;
                head=list2;
                list2=list2.next;
            }
        }
        //把未结束的链表连接到合并后的链表尾部
        if(list1!=null){
            head.next=list1;
        }
        if(list2!=null){
            head.next=list2;
        }
        return result.next; 
    }
}
//方法2:递归
public class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode result;
        if (l1 == null && l2 == null) {
            return null;
        } else if (l1 == null) {
            return l2;
        } else if (l2 == null) {
            return l1;
        }
        if (l1.val < l2.val) {
            result = l1;
            result.next = mergeTwoLists(l1.next, l2);
        } else {
            result = l2;
            result.next = mergeTwoLists(l1, l2.next);
        }
        return result;
    }
}
```

#### 【7】合并K个有序链表

> 两两合并

```java
public class Solution {
    public ListNode mergeKLists(ArrayList<ListNode> lists) {
    if(lists==null || lists.size() < 1) return null;
    if(lists.size()==1) return lists.get(0);
    if(lists.size()%2!=0) lists.add(null);
        ArrayList<ListNode> sum = new ArrayList<>();
        for(int i=0;i<lists.size();i+=2)
        {
            sum.add(mergeTwoLists(lists.get(i),lists.get(i+1)));
        }
        return mergeKLists(sum);

}
        public ListNode mergeTwoLists (ListNode l1, ListNode l2) {
        
        ListNode l3=new ListNode(0);
        ListNode l4=l3;
        while(l1!=null&&l2!=null){
            if(l1.val<l2.val){
               l3.next=l1; 
               l1=l1.next; 
            }else{
               l3.next=l2; 
               l2=l2.next; 
            }
                l3=l3.next;
        }
        l3.next=(l1==null)?l2:l1;
        return l4.next;
        // write code here
    }
}
```



#### 【8】链表相加

> - **题目：**给出两个 **非空** 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 **逆序** 的方式存储的，并且它们的每个节点只能存储 **一位** 数字。
>
>   如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
>
>   您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
>
> - **示例：**
>
>   ```java
>   输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
>   输出：7 -> 0 -> 8
>   原因：342 + 465 = 807
>   ```
>
> - **思路：**注意最后的进位，如果还有进位还需要new一个节点
>
> - **复杂度：**时间：O（n），空间O（n）

```java
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    //结果表的表头
    ListNode result = new ListNode(0);
    ListNode p = l1, q = l2, curr = result;
    //进位
    int carry = 0;
    //循环跳出条件，二者都为空
    while (p != null || q != null) {
        int x = (p != null) ? p.val : 0;
        int y = (q != null) ? q.val : 0;
        //和
        int sum = carry + x + y;
        //进位
        carry = sum / 10;
        curr.next = new ListNode(sum % 10);
        curr = curr.next;
        //注意空指针异常
        if (p != null) p = p.next;
        if (q != null) q = q.next;
    }
    if (carry > 0) {
        curr.next = new ListNode(carry);
    }
    return result.next;
}
```



【67】[二进制求和](https://leetcode-cn.com/problems/add-binary/)

```java
给你两个二进制字符串，返回它们的和（用二进制表示）。
输入为 非空 字符串且只包含数字 1 和 0。

示例 1:
输入: a = "11", b = "1"
输出: "100"
示例 2:
输入: a = "1010", b = "1011"
输出: "10101"
```

```java
class Solution {
    public String addBinary(String a, String b) {
        int i = a.length() - 1;
        int j = b.length() - 1;
        int carry = 0;
        StringBuilder builder = new StringBuilder();
        //循环相加两个字符串相同长度的低位数部分
        while (i >= 0 && j >= 0) {
            int sum = carry;
            sum += a.charAt(i--) - '0';
            sum += b.charAt(j--) - '0';
            carry = sum / 2;
            builder.append(sum % 2);
        }
        // 如果 a 还没遍历完成（a串比b串长），则继续遍历添加 a 的剩余部分
        while (i >= 0) {
            int sum = carry + a.charAt(i--) - '0';
            carry = sum / 2;
            builder.append(sum % 2);
        }
        // 如果 b 还没遍历完成（b串比a串长），则继续遍历添加 b 的剩余部分
        while (j >= 0) {
            int sum = carry + b.charAt(j--) - '0';
            carry = sum / 2;
            builder.append(sum % 2);
        }
        //如果 carry 不等于0 还有个进位数没加进去，需要补充
        if (carry == 1) {
            builder.append(carry);
        }
        //反转字符串获得正常结果
        return builder.reverse().toString();
    }
}
```



#### 【9】链表相加II

```java
//借住辅助栈然后套路如上
//再开一个栈用于存放链表
```



#### 【10】回文链表

> - **题目：**
> - **思路：**
> - **复杂度：**时间：O（），空间O（）

```java
//借住辅助链表
class Solution {
    public boolean isPalindrome(ListNode head) {
        List<ListNode> linkNodes = new LinkedList<>();

        if (head == null || head.next == null)
            return true;
        ListNode fast = head;
        ListNode slow = head;
        //记住判断关键语句
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        //入队
        slow = slow.next;
        while (slow != null) {
            linkNodes.add(new ListNode(slow.val));
            slow = slow.next;
        }
        //判断
        for (int i = linkNodes.size()-1; i >=0 ; i--) {
            if (linkNodes.get(i).val!=head.val){
                return false;
            }
            head=head.next;
        }
        return true;
    }
}

//翻转后半段链表
class Solution {
    public boolean isPalindrome(LinkNode head) {
        if (head == null || head.next == null)
            return true;
        LinkNode fast = head;
        LinkNode slow = head;
        //记住判断关键语句
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        //翻转链表
        LinkNode reverseHead = reverseList(slow.next);

        while (head != null && reverseHead != null) {
            if (head.data != reverseHead.data)
                return false;
            head = head.next;
            reverseHead = reverseHead.next;
        }
        return true;
    }
	
   //翻转链表
   private ListNode reverseList(ListNode head) {
        //翻转时需要储存前中后三个节点的引用以及返回节点的
        ListNode resultHead = null;
        ListNode currnetNode = head;
        ListNode preNode = null;
        ListNode nextNode = null;
        while (currnetNode != null) {
            nextNode = currnetNode.next;
            if (nextNode == null) {//找到链表尾部
                resultHead = currnetNode;
            }
            currnetNode.next = preNode;//将当前节点next指向头一个节点
            preNode = currnetNode;//当前节点做头
            currnetNode = nextNode;//下一个节点做当前节点
        }
        return resultHead;
    }
}
```



#### 【11】圆圈中最后剩下的数字

> - **题目：**0， 1，.....， n - 1这n个数字排成一个圆圈，从数字0开始每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字
> - **思路：**
>   - 只要移动m-1次就可以移动到下一个要删除的元素上
>   - 双节点,总保持last.next指向head
> - **复杂度：**时间：O（），空间O（）

```java

```



#### 【12】链表的中间节点

```java
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode slow = head, fast = head;
        //注意循环条件
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
}
```



#### 【13】链表排序

```java
public class Solution {
    public ListNode sortInList(ListNode head) {
        if(head == null) {
            return head;
        }
        
		ListNode p = head;
		ListNode q = head;
		ListNode t = head;
		int n = 0;
        

		while (p != null) {
			p = p.next;
			n++;
		}

		int[] arr = new int[n];

		for (int i = 0; i < arr.length; i++) {
			arr[i] = head.val;
			head = head.next;
		}

		Arrays.sort(arr);

		int i = 0;
		while (q != null) {
			q.val = arr[i++];
			q = q.next;
		}

		return t;
	}
}
```

```java
public class Solution {
    public ListNode sortInList (ListNode head) {
        // write code here
        if (null == head || head.next == null) {
            return head;
        }
        ListNode p1 = head;
        ListNode p2 = head.next;
        while (p2 != null && p2.next != null) {
            p1 = p1.next;
            p2 = p2.next.next;
        }
        ListNode p2Head = sortInList(p1.next);
        p1.next = null;
        ListNode p1Head = sortInList(head);
        ListNode pre = new ListNode(0);
        ListNode ansPre = pre;
        while (p1Head != null && p2Head != null) {
            if (p1Head.val < p2Head.val) {
                pre.next = p1Head;
                p1Head = p1Head.next;
            } else {
                pre.next = p2Head;
                p2Head = p2Head.next;
            }
            pre = pre.next;
        }
        pre.next = p1Head == null ? p2Head : p1Head;
        return ansPre.next;
    }
}
```



#### 【14】链表的奇偶重排

```
给定一个单链表，请设定一个函数，讲链表的奇数位节点和偶数位节点分别放在一起，重排后输出。
注意是节点的编号而非节点的数值。
输入
{1,2,3,4,5,6}
返回值
{1,3,5,2,4,6}
示例2
输入
{1,4,6,3,7}
返回值
{1,6,7,4,3}
```

```java
public class Solution {
    //leetcode 第328题
    //解题思路：将链表中的奇偶节点分别组成奇偶链表，再将偶数链表接在奇数链表之后
    public ListNode oddEvenList (ListNode head) {
           if(head == null){
               return head;
           }
           
           ListNode evenHead = head.next; //偶数位节点的头节点
           ListNode odd = head;   //奇数节点的指针
           ListNode even = evenHead; //偶数节点的指针
            
           while(even!=null && even.next!=null){
               odd.next = even.next;   
               odd = odd.next;
               
               even.next = odd.next;
               even = even.next;
           }
           odd.next = evenHead;   //将偶数链表接在奇数链表之后

           return head;
    }
}
```

```java
public class Solution {
    public ListNode oddEvenList (ListNode head) {
        if(head == null || head.next == null)  return head;
        ListNode oddHead = new ListNode(0);
        ListNode oddCur = oddHead;
        ListNode evenHead = new ListNode(0);
        ListNode evenCur = evenHead;
        while(head != null && head.next != null){
            oddCur.next = head;
            evenCur.next = head.next;
            oddCur = oddCur.next;
            evenCur = evenCur.next;
            head = evenCur.next;
        }
        if(head!=null){
            oddCur.next = head;
            oddCur = oddCur.next;
        }
        evenCur.next = null;
        oddCur.next = evenHead.next;
        return oddHead.next;
    }
}
```



#### 【15】[两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

- [题解](https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-91/)

![img](https://tva1.sinaimg.cn/large/0081Kckwly1glvkp46huwj30bq066aa7.jpg)

```
给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例 1：


输入：head = [1,2,3,4]
输出：[2,1,4,3]
示例 2：

输入：head = []
输出：[]
示例 3：

输入：head = [1]
输出：[1]
```

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode newHead = head.next;
        head.next = swapPairs(newHead.next);
        newHead.next = head;
        return newHead;
    }
}

class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummyHead = new ListNode(0);
        dummyHead.next = head;
        ListNode temp = dummyHead;
        while (temp.next != null && temp.next.next != null) {
            ListNode node1 = temp.next;
            ListNode node2 = temp.next.next;
            temp.next = node2;
            node1.next = node2.next;
            node2.next = node1;
            temp = node1;
        }
        return dummyHead.next;
    }
}
```

```java
	public ListNode reverseDoubleList(ListNode head) {
		if (head == null || head.next == null)
			return head;
 
		ListNode p = head;
		// 保存返回的链表头
		ListNode res = p.next;
 
		ListNode pre = null;
		ListNode pnextnext = null;
 
		while (p != null && p.next != null) {
			pnextnext = p.next.next;
			p.next.next = p;
 
			// 注意判断是否是第一次，第一次的pre不会自动向前走
			if (pre == null) {
				pre = p;
			} else {
				pre.next = p.next;
			}
			p.next = pnextnext;
 
			pre = p;
			p = p.next;
 
		}
		return res;
	}
```



#### 【16】链表冒泡排序

```java
//冒泡排序
    public static ListNode bubbleSort(ListNode head){
        if(head == null || head.next == null)  //链表为空或者仅有单个结点
            return head;

        ListNode cur = null, tail = null;

        cur = head;

        while(cur.next != tail){
            while(cur.next != tail){
                if(cur.val > cur.next.val){
                    int tmp = cur.val;
                    cur.val = cur.next.val;
                    cur.next.val = tmp;
                }
                cur = cur.next;
            }

            tail = cur;  //下一次遍历的尾结点是当前结点(仔细琢磨一下里面的道道)
            cur = head;     //遍历起始结点重置为头结点
        }

        return head;
    }
```

#### 【147】[对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list/)

```java
    public ListNode insertionSortList(ListNode head) {
        if(head == null || head.next == null) return head;

        ListNode newHead = new ListNode(0);
        ListNode node = head;
        while(node != null){
            ListNode next = node.next;
            //在排好序的链表中找到合适的位置, 插入
            ListNode prevNode = newHead;
            ListNode sortNode = newHead.next;
            while(sortNode != null){
                if(node.val > sortNode.val){
                    prevNode = sortNode;
                    sortNode = sortNode.next;
                }else{
                    break;
                }
            }
            prevNode.next = node;
            node.next = sortNode;

            node = next;
        }
        return newHead.next;
    }
```

```java
class Solution {
    public ListNode insertionSortList(ListNode head) {
        // 1. 首先判断给定的链表是否为空，若为空，则不需要进行排序，直接返回。
        if(head == null){
            return head;
        }

        // 2. 链表初始化操作
        ListNode dummyHead = new ListNode(0); // 引入哑节点
        dummyHead.next = head;                // 目的是在head之前插入节点
        ListNode lastSorted = head;           // 维护lastSorted为链表已经排好序的最后一个节点并初始化
        ListNode curr = head.next;            // 维护curr 为待插入的元素并初始化

        // 3. 插入排序
        while(curr != null){
            if(lastSorted.val <= curr.val){     // 说明curr应该位于lastSorted之后
                lastSorted = lastSorted.next;   // 将lastSorted后移一位,curr变成新的lastSorted
            }else{                              // 否则,从链表头结点开始向后遍历链表中的节点
                ListNode prev = dummyHead;      // 从链表头开始遍历 prev是插入节点curr位置的前一个节点
                while(prev.next.val <= curr.val){ // 循环退出的条件是找到curr应该插入的位置
                    prev = prev.next;
                }
                // 以下三行是为了完成对curr的插入（配合题解动图可以直观看出）
                lastSorted.next = curr.next;
                curr.next = prev.next;
                prev.next = curr;
            }
            curr = lastSorted.next; // 此时 curr 为下一个待插入的元素
        }
        // 返回排好序的链表
        return dummyHead.next;
    }
}
```

#### 【328】[奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/)

```java
给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。

请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。

示例 1:

输入: 1->2->3->4->5->NULL
输出: 1->3->5->2->4->NULL
示例 2:

输入: 2->1->3->5->6->4->7->NULL 
输出: 2->3->6->7->1->5->4->NULL
说明:

应当保持奇数节点和偶数节点的相对顺序。
链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。
```

```java
class Solution {
    public ListNode oddEvenList(ListNode head) {
        if (head == null) {
            return head;
        }
        ListNode evenHead = head.next;
        ListNode odd = head, even = evenHead;
        while (even != null && even.next != null) {
            odd.next = even.next;
            odd = odd.next;
            even.next = odd.next;
            even = even.next;
        }
        odd.next = evenHead;
        return head;
    }
}
```

#### 【61】[旋转链表](https://leetcode-cn.com/problems/rotate-list/)
```
给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。

示例 1:

输入: 1->2->3->4->5->NULL, k = 2
输出: 4->5->1->2->3->NULL
解释:
向右旋转 1 步: 5->1->2->3->4->NULL
向右旋转 2 步: 4->5->1->2->3->NULL
示例 2:

输入: 0->1->2->NULL, k = 4
输出: 2->0->1->NULL
解释:
向右旋转 1 步: 2->0->1->NULL
向右旋转 2 步: 1->2->0->NULL
向右旋转 3 步: 0->1->2->NULL
向右旋转 4 步: 2->0->1->NULL
```

```java
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if(head==null||k==0){
            return head;
        }
        ListNode cursor=head;
        ListNode tail=null;//尾指针
        int length=1;
        while(cursor.next!=null)//循环 得到总长度
        {
            cursor=cursor.next;
            length++;
        }
        int loop=length-(k%length);//得到循环的次数
        tail=cursor;//指向尾结点
        cursor.next=head;//改成循环链表
        cursor=head;//指向头结点
        for(int i=0;i<loop;i++){//开始循环
            cursor=cursor.next;
            tail=tail.next;
        }
        tail.next=null;//改成单链表
        return cursor;//返回当前头
    }
}
```



### 5、树

> - 递归结束条件
> - 递归操作-改变root节点
> - 对root和null敏感

#### 【1】二叉树的下一个节点

> - **题目：**给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，**同时包含指向父结点的指针**
>
> - **思路：**【右子树】中序遍历的下一个节点是右子树
>
>   - 有右子树：这种情况比较简单，右节点中序遍历就行，得到返回节点
>
>   - 该节点没有右子树：
>     - 该节点是父节点的左子节点：直接返回父节点
>     - 该节点是父节点的右子节点：
>       - 需要不断的向上移动，直到对应的节点不是父节点的右节点（即左节点），既然他是父节点的左节点，此时将这个节点父节点返回即可
>       - 遍历到了根节点，返回null
>
> - **复杂度**：最坏O（n），单腿二叉树

```java
class Solution {
    public TreeNode getNextNode(TreeNode pNode) {
        if(pNode == null){
            return null;
        }
        //有右子树
        if(pNode.right != null){
            //从右子树根节点一直往左下寻找，最左边最下边的就是要返回的节点
            pNode = pNode.right;
            while(pNode.left != null){
                pNode = pNode.left;
            }
            return pNode;
        }
        //没有右子树，往上找第一个节点是父节点左节点的节点
        while(pNode.parent != null){
            if(pNode.parent.left== pNode){
                return pNode.parent;
            }
            pNode = pNode.parent;
        }
        //没有后续返回null
        return null;
    }
}
```



#### 【2】递归遍历二叉树

```java
	/**
     * 先序遍历
     */
    public void preOrderTraverse(Node head) {
        if (head == null)
            return;
        System.out.print(head.data + " ");
        preOrderTraverse(head.leftChild);
        preOrderTraverse(head.rightChild);
    }

    /**
     * 中序遍历
     */
    public void inOrderTraverse(Node head) {
        if (head == null)
            return;
        inOrderTraverse(head.leftChild);
        System.out.print(head.data + " ");
        inOrderTraverse(head.rightChild);
    }

    /**
     * 后序遍历
     */
    public void postOrderTraverse(Node head) {
        if (head == null)
            return;
        postOrderTraverse(head.leftChild);
        postOrderTraverse(head.rightChild);
        System.out.print(head.data + " ");
    }
```



#### 【3】非递归遍历二叉树

> 关键是条件判断 while while if 模型
>
> -  while (current != null || !stack.empty()) {
>   -  while (current != null) {
>   -  if (!stack.empty()) {
> - 然后再是输出位置
> - 后序：【保存前一个节点】【栈非空开始循环】【如果当前节点左右子节点为空或上一个访问的结点(非空)为当前结点的子节点时，当前结点出栈】
>   -  while (!stack.empty()) {
>   - `if ((current.leftChild == null && current.rightChild == null) ||`
>     `(previous != null && (previous == current.leftChild || previous == current.rightChild))) {`

```java
 	/**
     * 先序非递归
     */
    public void preOrderTraverseByStack(Node head) {
        Stack<Node> stack = new Stack<>();
        Node current = head;
        while (current != null || !stack.empty()) {
            while (current != null) {
                System.out.print(current.data + " ");//先输出后push
                stack.push(current);
                current = current.leftChild;//左
            }
            if (!stack.empty()) {
                current = stack.pop();
                current = current.rightChild;//右
            }
        }
    }

    /**
     * 中序非递归
     */
    public void inOrderTraverseByStack(Node head) {
        Stack<Node> stack = new Stack<>();
        Node current = head;
        while (current != null || !stack.empty()) {
            while (current != null) {
                stack.push(current);
                current = current.leftChild;
            }
            if (!stack.empty()) {
                current = stack.pop();
                System.out.print(current.data + " ");//先pop后输出
                current = current.rightChild;
            }
        }
    }

    /**
     * 后序非递归
     */
    public void postOrderTraverseByStack(Node head) {
        Stack<Node> stack = new Stack<>();
        Node current;
        //上一个访问
        Node previous = null;
        stack.push(head);
        while (!stack.empty()) {
            //获得头节点值
            current = stack.peek();
            //如果当前节点左右子节点为空或上一个访问的结点为当前结点的子节点时，当前结点出栈
            if ((current.leftChild == null && current.rightChild == null) ||
                    (previous != null && (previous == current.leftChild || previous == current.rightChild))) {
                stack.pop();
                System.out.print(current.data + " ");
            } else {
                //先将右节点入栈，再将左节点入栈
                if (current.rightChild != null) {
                    stack.push(current.rightChild);
                }
                if (current.leftChild != null) {
                    stack.push(current.leftChild);
                }
            }
            previous = current;
        }
    }
//=====
   //后序遍历，非递归
    public static List<Integer> postOrder(TreeNode root){
        Stack<TreeNode> stack = new Stack<>();
        List<Integer> list = new ArrayList<>();
        TreeNode cur = root;
        TreeNode p = null;//用来记录上一节点
        while(!stack.isEmpty() || cur != null){
            while(cur != null){
                stack.push(cur);
                cur = cur.left;
            }
            cur = stack.peek();
//            后序遍历的过程中在遍历完左子树跟右子树cur都会回到根结点。
//          	所以当前不管是从左子树还是右子树回到根结点都不应该再操作了，应该退回上层。
//            如果是从右边再返回根结点，应该回到上层。
            //主要就是判断出来的是不是右子树，是的话就可以把根节点=加入到list了
            if(cur.right == null || cur.right == p){
                list.add(cur.val);
                stack.pop();
                p = cur;
                cur = null;
            }else{
                cur = cur.right;
            }

        }
        return list;
```



#### 【4】层序遍历二叉树

> - 题目：实现从上到下按层打印二叉树，同一层结点从左至右输出，每一层输出一行
> - 思路：BFS，队列

```java
	 queue.offer(head);
        while (!queue.isEmpty()) {
            current = queue.poll();
            if (current.leftChild != null) {
                queue.offer(current.leftChild);
            }
            if (current.rightChild != null) {
                queue.offer(current.rightChild);
            }
            System.out.print(current.data + " ");
        }
```

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    if(root == null)
        return new ArrayList<>();
    List<List<Integer>> res = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.add(root);
    while(!queue.isEmpty()){
        int count = queue.size();
        List<Integer> list = new ArrayList<Integer>();
        while(count > 0){
            TreeNode node = queue.poll();
            list.add(node.val);
            if(node.left != null)
                queue.add(node.left);
            if(node.right != null)
                queue.add(node.right);
            count--;
        }
        res.add(list);
    }
    return res;
}
```



#### 【5】从前序与中序遍历序列构造二叉树

> - **题目：**
>
>   前序遍历：左根右 6 4 2 5 3 1 7 
>   中序遍历：左根右 4 2 5 6 1 3 7 
>   后序遍历：左右根 5 2 4 1 7 3 6
>
> - **思路：**根据二叉树的遍历特点进行求解
>
> - **复杂度：**时间：O（n^2），空间O（n^2）从前序与中序遍历序列构造二叉树

```java
    /**
     * 剑指offer提供思路
     * copyOfRange[)左闭右开区间
     */
    public static TreeNode reConstructBinaryTree(int[] pre, int[] in) {
        if (pre.length == 0 || in.length == 0|| pre.length! = in.length) {
            return null;
        }
        TreeNode node = new TreeNode(pre[0]);
        //通过循环找到先根的头元素在中根数组中的位置
        for (int i = 0; i < in.length; i++) {
            if (pre[0] == in[i]) {
                node.left = reConstructBinaryTree(Arrays.copyOfRange(pre, 1, i + 1), Arrays.copyOfRange(in, 0, i));
                node.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i + 1, pre.length), Arrays.copyOfRange(in, i + 1, in.length));
            }
        }
        return node;
    }
```



#### 【6】树的子结构

> - **题目：**输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
> - **思路：**先找值相等的点来判断,递归判断值是否相等，控制好判断的时候的边界条件
> - 最坏情况就是遍历整个二叉树

```java
class Solution {
    public boolean isSubStructure(TreeNode A, TreeNode B) {
        if(A == null || B == null) return false;
        return dfs(A, B) 
          || isSubStructure(A.left, B) 
          || isSubStructure(A.right, B);
    }
    public boolean dfs(TreeNode A, TreeNode B){
        if(B == null) return true;
        if(A == null) return false;
        return A.val == B.val && dfs(A.left, B.left) && dfs(A.right, B.right);
    }
}
```

```java
class Solution {
    public boolean isSubtree(TreeNode s, TreeNode t) {
        return dfs(s, t);
    }

    public boolean dfs(TreeNode s, TreeNode t) {
        if (s == null) {
            return false;
        }
        return check(s, t) || dfs(s.left, t) || dfs(s.right, t);
    }

    public boolean check(TreeNode s, TreeNode t) {
        if (s == null && t == null) {
            return true;
        }
        if (s == null || t == null || s.val != t.val) {
            return false;
        }
        return check(s.left, t.left) && check(s.right, t.right);
    }
}
```

```java
class Solution {

    public static boolean hasSubTree(TreeNode headOne, TreeNode headTwo) {
        if (headOne == null || headTwo == null) {
            return false;
        }
        //先找值相等的点来判断
        boolean result = false;
        if (headOne.data == headTwo.data) {
            result = doesTree1HaveTree2(headOne, headTwo);
        }
        //递归
        if (!result) {
            result = hasSubTree(headOne.leftChild, headTwo);
        }
        //递归
        if (!result) {
            result = hasSubTree(headOne.rightChild, headTwo);
        }
        return result;
    }

    /**
     * 递归判断值是否相等
     */
    private static boolean doesTree1HaveTree2(TreeNode headOne, TreeNode headTwo) {
        //遍历结束
        if (headTwo == null) {
            return true;
        }
        if (headOne == null) {
            return false;
        }
        //值不相等
        if (headOne.data != headTwo.data) {
            return false;
        }
        //关键代码
        return (doesTree1HaveTree2(headOne.leftChild, headTwo.leftChild)
                && doesTree1HaveTree2(headOne.rightChild, headTwo.rightChild));
    }
}
```



#### 【7】对称二叉树

> - **题目：**请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的
> - **思路：**

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }
        return cmp(root.left, root.right);
    }

    private boolean cmp(TreeNode node1, TreeNode node2) {
        if (node1 == null && node2 == null) {
            return true;
        }
        if (node1 == null || node2 == null || node1.val != node2.val) {
            return false;
        }
        return cmp(node1.left, node2.right) && cmp(node1.right, node2.left);
    }
}

//迭代解法
public boolean isSymmetric(TreeNode root) {
    Queue<TreeNode> q = new LinkedList<>();
    q.add(root);
    q.add(root);
    while (!q.isEmpty()) {
        TreeNode t1 = q.poll();
        TreeNode t2 = q.poll();
        if (t1 == null && t2 == null) continue;
        if (t1 == null || t2 == null) return false;
        if (t1.val != t2.val) return false;
        //注意节点的加入顺序
        q.add(t1.left);
        q.add(t2.right);
        q.add(t1.right);
        q.add(t2.left);
    }
    return true;
}
```



#### 【8】二叉搜索树与双向链表

> 中序遍历为有序序列

```java
class Solution {

    static void tree2list(TreeNode head, LinkedList<TreeNode> list) {
        if (head == null) {
            return;
        }
		
        //向左下递归中序遍历
        if (head.leftChild != null) {
            tree2list(head.leftChild, list);
        }

        TreeNode last = null;
        if (list.size() > 0) {
            last=list.getLast();
            //链表中最后一个节点即最大节点，
            //该节点的next=头
            last.rightChild = head;
            //头的前节点=链表尾
            head.leftChild = last;
        }
        //将头结点入队
        list.add(head);

        if (head.rightChild != null) {
            tree2list(head.rightChild, list);
        }
    }
}
```

```java
		public Node preNode = null;
    public Node newHead = null;    
		public Node treeToDoublyList(Node root) {
        //边界条件
        if(root == null){
            return root;
        }
        middleOrder(root);
        //将处理后的双向链表的首尾相连
        newHead.left = preNode;
        preNode.right = newHead;
        return newHead;
    }

    //算法思路：因为二叉排序树的中序遍历的输出就是有序的列表，
    //我们改写中序遍历，通过定义一个preNode的全局变量保留当前节点的前一个节点。
    //preNode.right = curNode,curNode.left = preNode.
    public void middleOrder(Node root){
        //如果当前节点为null，则return null
        if(root == null){
            return ;
        }
        //中序遍历,
        middleOrder(root.left);
        //中序遍历，第一个遍历的节点就是最左下的最小节点。
        //即第一个访问的节点就为左下角节点。
        //如果出preNode，则指向此时root，即为最左下节点。用来第一次遍历时，初始化
        //第一次进入这里是最左子节点时，初始化所需节点指引。
        if(preNode == null){
            newHead = root;
            preNode = root;
        }//否则，
        else{
            //以preNode始终指向前一个节点，正好是比当前节点小的节点，
            //进行以下操作，将其转成双向链表。
            preNode.right = root;
            root.left = preNode;
            preNode = root;
        }
        middleOrder(root.right);
    }
```



#### 【9】判断二叉搜索树的后序遍历

> 找到左右子树的分界线，递归判断.

```java
class Solution {
    public boolean verifyPostorder(int [] sequence) {
        if(sequence.length<=1)  return true;
        return judge(sequence, 0, sequence.length-1);
    }
 
    private boolean judge(int[] sequence, int star, int end) {
        if(star>end) {
            return true;
        }
        int i=star;
        //找到左右子树的分界线
        while(sequence[i]<sequence[end]) {
            i++;
        }
        //判断后面的数字都是大于根节点的
        for(int j=i;j<end;j++) {
            if(sequence[j]<sequence[end]) {
                return false;
            }
        }
        //递归判断左子树与右子树
        return judge(sequence,star,i-1)&&judge(sequence,i,end-1);
    }
}
```



#### 【10】二叉搜索树第k大/小节点

> - 题目：给定一棵二叉搜索树，请找出其中的第k小的结点。例如（5，3，7，2，4，6，8）中第三小结点的值为4。
> - 思路：二叉搜索树的中序遍历结果正好是从小到大排序好的，按照中序遍历顺序找第k个节点

```java
//第k小
public class Solution {
  private int index = 0;
    public int kthSmallest(TreeNode root, int k) {
        int res = 0;
        if (root == null) {
            return res;
        }
        res = kthSmallest(root.left, k);
        if (index == k) {
            return res;
        }
        index++;
        if (index == k) {
            return root.val;
        }
        return kthSmallest(root.right, k);
    }
}

//---
public class Solution {
    int index=0;
    TreeNode KthNode(TreeNode pRoot, int k){
        if(pRoot==null){
            return null;
        }
        TreeNode node = KthNode(pRoot.left,k);
            if(node!=null){
                return node;
            }
            index++;
            if(k==index){
                return pRoot;
            }
            node = KthNode(pRoot.right,k);
            if(node!=null){
                return node;
            }
        return node;
    }
}
//---  
//第k大#########
class Solution {

    TreeNode getKthNode(TreeNode head, int k) {
        if (head == null || k == 0) {
            return null;
        }
        return kthNodeCore(head, k);
    }

    private TreeNode kthNodeCore(TreeNode head, int k) {
        TreeNode result = null;
        //中序遍历先到最左下
        if (head.leftChild != null) {
            result = kthNodeCore(head.leftChild, k);
        }
        //到了一个左孩子为空的节点，计数器减一
        if (result == null) {
            if (k == 1) {
                return head;
            }
            k--;
        }
        //head的左孩子为空，右孩子不为空
        if (result == null && head.rightChild != null) {
            result = kthNodeCore(head.rightChild, k);
        }
        return result;
    }

}
```

#### 【10+】[二叉树中第二小的节点](https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/)

```
给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。

更正式地说，root.val = min(root.left.val, root.right.val) 总成立。

给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。

示例 1：

输入：root = [2,2,5,null,null,5,7]
输出：5
解释：最小的值是 2 ，第二小的值是 5 。
示例 2：

输入：root = [2,2,2]
输出：-1
解释：最小的值是 2, 但是不存在第二小的值。
```

```java
class Solution {
   public int findSecondMinimumValue(TreeNode root) {
        if (root == null) return -1;
        return help(root, root.val);
    }

    private int help(TreeNode root, int min) {
        if (root == null) return -1;
        if (root.val > min) return root.val;
        int left = help(root.left, min);
        int right = help(root.right, min);
        if (left == -1) return right;
        if (right == -1) return left;
        return Math.min(left, right);
    }
}
```



#### 【11】二叉树深度

```java
class Solution {
    public int treeDepth(TreeNode root) {
        //跳出递归条件
        if (root == null) {
            return 0;
        }

        //对遍历代码稍做修改
        int nLeft = treeDepth(root.leftChild);
        int nRight = treeDepth(root.rightChild);
        return Math.max(nLeft,nRight)+1;
    }
}
```



#### 【111】[二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

```java
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }

        if (root.left == null && root.right == null) {
            return 1;
        }

        int min_depth = Integer.MAX_VALUE;
      
        if (root.left != null) {
            min_depth = Math.min(minDepth(root.left), min_depth);
        }
        if (root.right != null) {
            min_depth = Math.min(minDepth(root.right), min_depth);
        }

        return min_depth + 1;
    }
}
```



#### 【12】判断一棵树是否是平衡二叉树

> - 题目：输入一棵二叉树，判断该二叉树是否是平衡二叉树。
> - 思路：从下往上遍历，如果子树是平衡二叉树，则返回子树的高度，反之直接停止遍历，这样至多只对每个结点访问一次

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return getDepth(root) != -1;
    }
    private int getDepth(TreeNode root) {
        if (root == null) return 0;
        
        int left = getDepth(root.left);
        if (left == -1) return -1;
        int right = getDepth(root.right);
        if (right == -1) return -1;
        
        return Math.abs(left - right) > 1 ? -1 : 1 + Math.max(left, right);
    }
}
```

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return height(root) >= 0;
    }

    public int height(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftHeight = height(root.left);
        int rightHeight = height(root.right);
        if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) > 1) {
            return -1;
        } else {
            return Math.max(leftHeight, rightHeight) + 1;
        }
    }
}

```



#### 【12+】判断一棵树是否是完全二叉树 和 二叉搜索树

```java
public class Solution {
    /*
     * // 两个情况分别判断： // 二叉搜索树：每个节点左边节点小于右边节点，
             左子树的最大值一定小于根节点，小于右子树的最大值；通过中序遍历，严格递增 //
     * 完全二叉树：层序遍历，除了最后的一层，每层都是满的
     */
    public boolean[] judgeIt(TreeNode root) {
        boolean[] flag = new boolean[2];
        flag[0] = isBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
        flag[1] = isComplete(root);
        return flag;
    }
    /**
     * 二叉树搜索树， 做节点小于根节点  右节点大于根节点
     */
    public boolean isBST(TreeNode root, int min, int max) {
        if(root == null) {
            return true;
        }
        if(root.val <min || root.val > max) {
            return false;
        }
        return isBST(root.left, min, root.val) && isBST(root.right, root.val, max);
    }
    /**
     * 完全二叉树 一个节点 有左节点才能有右节点，
         如果 一个节点的子节点为空则下一level的这个子节点的右侧没有节点
     */
    public boolean isComplete(TreeNode node) {
             LinkedList<TreeNode> queue = new LinkedList<>();
             queue.offer(node);
             while(!queue.isEmpty()) {
                 TreeNode treeNode = queue.poll();
                 if(treeNode == null) {
                     break;
                 }
                 queue.offer(treeNode.left);
                 queue.offer(treeNode.right);
             }
             while(!queue.isEmpty()) {
                 TreeNode treeNode = queue.poll();
                 if(treeNode != null) {
                      
                     return false;
                 }
             }
             return true;
    }
}
```



#### 【98】[验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

```
给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。
示例 1:

输入:
    2
   / \
  1   3
输出: true
示例 2:

输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。
```

```java
class Solution {
	public boolean isValidBST(TreeNode root) {
        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }

    public boolean validate(TreeNode node, long min, long max) {
        if (node == null) {
            return true;
        }
        if (node.val <= min || node.val >= max) {
            return false;
        }
        return  validate(node.left, min, node.val) && validate(node.right, node.val, max);
    }
}
```



#### 【783】[二叉搜索树节点最小距离](https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/)

```
给定一个二叉搜索树的根节点 root，返回树中任意两节点的差的最小值。

示例：
输入: root = [4,2,6,1,3,null,null]
输出: 1
解释:
注意，root是树节点对象(TreeNode object)，而不是数组。

给定的树 [4,2,6,1,3,null,null] 可表示为下图:

          4
        /   \
      2      6
     / \    
    1   3  

最小的差值是 1, 它是节点1和节点2的差值, 也是节点3和节点2的差值。
 
注意：
二叉树的大小范围在 2 到 100。
二叉树总是有效的，每个节点的值都是整数，且不重复。
本题与 530：https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/ 相同
```

```java
//在二叉搜索树中，中序遍历会将树中节点按数值大小顺序输出。只需要遍历计算相邻数的差值，取其中最小的就可以了
//复杂度分析
时间复杂度：O(N)O(N)，其中 NN 为树中节点的个数。
空间复杂度：O(H)O(H)，其中 HH 为树的高度，其为递归调用 dfs 产生函数栈的大小。
class Solution {
    Integer prev, ans;
    public int minDiffInBST(TreeNode root) {
        prev = null;
        ans = Integer.MAX_VALUE;
        dfs(root);
        return ans;
    }

    public void dfs(TreeNode node) {
        if (node == null) return;
        dfs(node.left);
        if (prev != null)
            ans = Math.min(ans, node.val - prev);
        prev = node.val;
        dfs(node.right);
    }
}
```



#### 【13】二叉树的最近公共祖先

> - **题目：**
> - **思路：**做了一些二叉树的题，发现二叉树的查找问题一般都是从左右子树递归去解决，也往往都能得到答案，因此，这道题可以考虑是否能从左右子树进行递归去解决呢？
>   首先，要想通过递归来实现，就需要先确定临界条件，那么临界条件是什么呢？换句话说，临界条件就是递归中能够直接返回的特殊情况，第一点则是最常见的“判空”，判断根结点是否是空节点，如果是，那么肯定就可以马上返回了，这是一个临界条件；再来考虑题意，在以root为根结点的树中找到p结点和q结点的最近公共祖先，那么特殊情况是什么呢？很显然，特殊情况就是根结点就等于q结点或p结点的情况，想一下，如果根结点为二者之一，那么根结点就必定是最近公共祖先了，这时直接返回root即可。由此看来，这道题就一共有三种特殊情况，root == q 、root == p和root==null，这三种情况均直接返回root即可。
>   根据临界条件，实际上可以发现这道题已经被简化为查找以root为根结点的树上是否有p结点或者q结点，如果有就返回p结点或q结点，否则返回null。
>   这样一来其实就很简单了，从左右子树分别进行递归，即查找左右子树上是否有p结点或者q结点，就一共有4种情况：
>   第一种情况：左子树和右子树均找没有p结点或者q结点；（这里特别需要注意，虽然题目上说了p结点和q结点必定都存在，但是递归的时候必须把所有情况都考虑进去，因为题目给的条件是针对于整棵树，而递归会到局部，不一定都满足整体条件）
>   第二种情况：左子树上能找到，但是右子树上找不到，此时就应当直接返回左子树的查找结果；
>   第三种情况：右子树上能找到，但是左子树上找不到，此时就应当直接返回右子树的查找结果；
>   第四种情况：左右子树上均能找到，说明此时的p结点和q结点分居root结点两侧，此时就应当直接返回root结点了。
> - **复杂度：**时间：O（），空间O（）

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        //根是否已经递归到空
        if (root ==null){
            return null;
        }
        //是否根与p或q相等了，则说明此时root是二者的最近公共祖先
        if (root.val==p.val ||root.val==q.val){//if (root == p || root == q) {
            return root;
        }
        //left和right的意义是
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        //都不为null说明是root
        if (left != null && right != null) {
            return root;
        } else if (left != null) {
            return left;
        } else if (right != null) {
            return right;
        }
        return null;
    }
}
```



#### 【14】二叉搜索树的最近公共祖先

> - **题目：**给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先
> - **思路：**因为二叉搜索树的结构特性，通过p，q与根节点值进行比对变换根节点进行递归
> - **复杂度：**时间：O（），空间O（）

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root ==null){
            return null;
        }
        if(p.val>root.val && q.val>root.val){
            return lowestCommonAncestor(root.right,p,q);
        }
        if(p.val<root.val && q.val<root.val){
            return lowestCommonAncestor(root.left,p,q);
        }
        //注意返回值是root
        return root;
    }
}
```



#### 【530】[二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

```java
class Solution {
    private int res = Integer.MAX_VALUE;
    private int preVal = -1; //前一节点的值

    private void inorder(TreeNode root) {
        // 二叉搜索树的中序遍历是升序的，中序遍历时两两相邻的值的差值最小就是结果
        if(root == null) return;
        inorder(root.left);
        if(preVal < 0)
            preVal = root.val; //所有节点值是非负的，中序遍历的第一个节点值赋值给preVal
        else {
            int tmp = root.val - preVal; //当前值与前一节点值做差
            res = Math.min(tmp, res);
            preVal = root.val; //更新preVal
        }
        inorder(root.right);
    }
    public int getMinimumDifference(TreeNode root) {
        inorder(root);
        return res;
    }
}
```



#### 【15】二叉树展开为链表

> 给定一个二叉树，将它展开为链表
>
> 例如，给定二叉树，用2、3、4做例子就比较好理解了。
>
> ```java
>       1
>      / \
>     2   5
>   / \   \
> 3   4   6
> ```
>
> 将其展开为：
>
> ```java
> 1
>  \
>    2
>      \
>       3
>        \
>         4
>          \
>           5
>            \
>             6
> ```

```java
class Solution {
    public void flatten(TreeNode root) {
        if(root == null){
            return ;
        }
        
        //递归修改左右子树
        flatten(root.left);
        flatten(root.right);
        
        if(root.left != null){
            TreeNode right = root.right;//记录右节点
            root.right = root.left;
            root.left = null;//将左节点置空
            TreeNode node = root.right;//到左节点的最后一个节点
            while(node.right != null){
                node = node.right;
            }
            node.right = right; 
        }
    }
}
```



#### 【16】有序链表转换二叉搜索树

> 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。
>
> 本题中，一个高度平衡二叉树是指一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1。
>
> **示例:**
>
> ```java
> 给定的有序链表： [-10, -3, 0, 5, 9],
> 
> 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：
> 
>       0
>      / \
>    -3   9
>    /   /
>  -10  5
> ```

```java
class Solution {
   public TreeNode sortedListToBST(ListNode head){
        return buildTree(head,null);
    }
    
	//需要记录头和尾
    public TreeNode buildTree(ListNode head,ListNode tail){
        TreeNode res=null;
        if(head==tail)
            return res;
    	//双指针法
        ListNode fastNode=head;
        ListNode slowNode=head;
        //找到中间节点
        while(fastNode!=tail&&fastNode.next!=tail){
            slowNode=slowNode.next;
            fastNode=fastNode.next.next;
        }
        
        //递归构建左右子树
        res=new TreeNode(slowNode.val);
        res.left=buildTree(head,slowNode);
        res.right=buildTree(slowNode.next,tail);
        return res;
    }
}
```



#### 【17】和为某一值的路径

```java
class Solution {
    // pathList存所有可能路径
    // path用来保存路径的数据结构 这儿用ArrayList模拟了栈的数据结构
    private List<List<Integer>> pathList = new ArrayList<>();
    private List<Integer> path = new ArrayList<>();

    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        if (root == null)
            return pathList;
        path.add(root.val);
        sum -= root.val;
        // 路径值等于0，且当前节点是叶子节点 则找到一条路径
        if (sum == 0 && root.left == null && root.right == null)
            // 每次找到路径都需要添加一个新的path 不可以直接加path成员变量 这是个引用，
            //不然所有pathList的值都指向同一个path
            pathList.add(new ArrayList<Integer>(path));
        if (root.left != null)
            pathSum(root.left, sum);

        if (root.right != null)
            pathSum(root.right, sum);
        // 访问完当前节点 需要删除路径中最后一个节点，回退至父节点
        path.remove(path.size() - 1);
        return pathList;
    }
}
```

```java
//找一条
import java.util.*;
public class Solution {
    public boolean hasPathSum (TreeNode root, int sum) {
        if(root == null){
            return false;
        }
        if(root.left == null && root.right == null){
            return (sum - root.val == 0);
        }
        return hasPathSum(root.left,sum - root.val) || hasPathSum(root.right,sum - root.val);
    }
}
```



#### 【112】路径总和

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if (root == null) {
            return false;
        }
        if (root.left == null && root.right == null) {
            return sum - root.val == 0;
        }
        return hasPathSum(root.left, sum - root.val)
                || hasPathSum(root.right, sum - root.val);
    }
}
```



#### 【17】二叉树的最大路径和

给定一个二叉树，请计算节点值之和最大的路径的节点值之和是多少。
这个路径的开始节点和结束节点可以是二叉树中的任意节点
例如：
给出以下的二叉树，![img](https://tva1.sinaimg.cn/large/0081Kckwly1glvbchqvk2j305l04hq2w.jpg)

返回的结果为6

```
输入
{-2,1}
返回值
1
示例2
输入
{-2,#,-3}
返回值
-2
```

```java
public class Solution {
    int sum=Integer.MIN_VALUE;
	  public int maxPathSum (TreeNode root) {
	        // write code here
          if(root==null)
            return 0;
          PathSum(root);
          return sum;
          }
	 
	  public int PathSum (TreeNode root) {
	        // write code here
          if(root==null)
            return 0;
          int l=Math.max(PathSum(root.left), 0);
          int r=Math.max(PathSum(root.right), 0);
          sum=Math.max(sum, root.val+l+r);
          return root.val+Math.max(r, l);
	    }
}
```

####【17】根节点到叶子节点的所有路径和
给定一个仅包含数字 0−9 的二叉树，每一条从根节点到叶子节点的路径都可以用一个数字表示。
例如根节点到叶子节点的一条路径是1→2→3,那么这条路径就用123 来代替。
找出根节点到叶子节点的所有路径表示的数字之和
例如：

![img](https://tva1.sinaimg.cn/large/0081Kckwly1glvbjr08lvj305k04fq2w.jpg)

这颗二叉树一共有两条路径，
根节点到叶子节点的路径 1→2 用数字 12 代替
根节点到叶子节点的路径 1→3 用数字13 代替
所以答案为 12+13=25

```java
public class Solution {
    public int sumNumbers (TreeNode root) {
        // write code here
        if(root==null)
            return 0;
        ArrayList<ArrayList<Integer>> result=new ArrayList<ArrayList<Integer>>();
        ArrayList<Integer> list=new ArrayList<Integer>();
        solution(root,result,list);
        int sum=0,tmp=0;
        for(ArrayList<Integer> ls:result){
            tmp=0;
            for(int i:ls){
                tmp=tmp*10+i;
            }
            sum+=tmp;
        }
        return sum;
    }
    public void solution(TreeNode t,ArrayList<ArrayList<Integer>> result,ArrayList<Integer> list){
        list.add(t.val);
        if(t.left==null&&t.right==null){
            result.add(new ArrayList(list));
            return;
        }
        if(t.left!=null){
            solution(t.left,result,list);
            if(list.size()==0)
                return;
            else list.remove(list.size()-1);
        }
        if(t.right!=null){
            solution(t.right,result,list);
            if(list.size()==0)
                return;
            else list.remove(list.size()-1);
        }
    }
}
```

#### 【18】之字形打印二叉树

```java
给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

例如：
给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回锯齿形层序遍历如下：

[
  [3],
  [20,9],
  [15,7]
]
      
class Solution {
     public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
         Queue<TreeNode> queue = new LinkedList<>();
        List<List<Integer>> res = new ArrayList<>();
        if (root != null) {
            queue.offer(root);
        }
        List<Integer> list ;
        while (!queue.isEmpty()) {
            int size = queue.size(); //当前层，元素的数量
            list = new ArrayList<>();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll(); //按顺序弹出队列元素，加入集合
                list.add(node.val);
                if (node.left != null) {
                    queue.offer(node.left); //当前元素的左子树入队，即把下一层的元素加入队列
                }
                 if (node.right != null) {
                    queue.offer(node.right); //当前元素的右子树入队，即把下一层的元素加入队列
                }
            }
            if (res.size() % 2 == 1) { //本题中奇数层要翻转下
                Collections.reverse(list);
            }
            res.add(list);
        }
        return res;
    }
}
```

> 利用两个栈，注意进栈顺序，【s1先左后右，s2先右后左】

```java
class Solution {
    public  List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();

        if (root == null) {
            return result;
        }
        //存储奇层节点
        Stack<TreeNode> stackOne = new Stack<>();
        //存储偶层节点
        Stack<TreeNode> stackTwo = new Stack<>();
        stackOne.push(root);
        int level = 1;
        while (!stackOne.isEmpty() || !stackTwo.empty()) {
            ArrayList<Integer> temp = new ArrayList<>();
            if (level % 2 == 1) {//奇数层
                while (!stackOne.isEmpty()) {
                    TreeNode current = stackOne.pop();
                    if (current != null) {
                        temp.add(current.val);
                        //注意先左后右
                        stackTwo.push(current.left);
                        stackTwo.push(current.right);
                    }
                }
            } else {//偶数层
                while (!stackTwo.empty()) {
                    TreeNode current = stackTwo.pop();
                    if (current != null) {
                        temp.add(current.val);
                      	//注意先右后左
                        stackOne.push(current.right);
                        stackOne.push(current.left);
                    }
                }
            }
            if (!temp.isEmpty()) {
                result.add(temp);
                level++;
            }
        }

        return result;
    }
}
```



#### 【19】将二叉树变为其镜像

```java
二叉树的镜像定义：源二叉树 
    	    8
    	   /  \
    	  6   10
    	 / \  / \
    	5  7 9 11
    	镜像二叉树
    	    8
    	   /  \
    	  10   6
    	 / \  / \
    	11 9 7  5
public void Mirror(TreeNode node) {
        if (node == null) {
            return;
        }
        Mirror(node.left);
        Mirror(node.right);
        TreeNode temp = node.left;
        node.left = node.right;
        node.right = temp;
    }
```

#### 【226】[翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

```
输入：

     4
   /   \
  2     7
 / \   / \
1   3 6   9
输出：

     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root==null){
            return null;
        }
        //交换顺序无所谓
        TreeNode temp = root.right;
        root.right = root.left;
        root.left = temp;

        invertTree(root.left);
        invertTree(root.right);
        return root;
    }
}
```



#### 【20】二叉树左视图

```java
class Solution{
	public void leftView(ListNode root) {
		Queue<ListNode> qu1 = new LinkedList<>();
		Queue<ListNode> qu2 = new LinkedList<>();
		qu1.add(root);
		while (!qu1.isEmpty() || !qu2.isEmpty()) {
			Queue<ListNode> qu;
			Queue<ListNode> quTemp;
			if (qu1.isEmpty()) {
				qu = qu2;
				quTemp=qu1;
			} else {
				qu = qu1;
				quTemp=qu2;
			}
			System.out.println(qu.peek().val);
			while (!qu.isEmpty()) {
				ListNode temp = qu.poll();
				if (temp.left != null) {
					quTemp.add(temp.left);
				}
				if (temp.right != null) {
					quTemp.add(temp.right);
				}
			}
		}
	}
}
```



#### 【21】[验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

```
给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。
示例 1:

输入:
    2
   / \
  1   3
输出: true
示例 2:

输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。
```

```java
//递归
///要解决这道题首先我们要了解二叉搜索树有什么性质可以给我们利用，由题目给出的信息我们可以知道：如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。

class Solution {
    public boolean isValidBST(TreeNode root) {
        return helper(root, null, null);
    }

    public boolean helper(TreeNode node, Integer lower, Integer upper) {
        if (node == null) {
            return true;
        }

        int val = node.val;
        if (lower != null && val <= lower) {
            return false;
        }
        if (upper != null && val >= upper) {
            return false;
        }

        if (!helper(node.right, val, upper)) {
            return false;
        }
        if (!helper(node.left, lower, val)) {
            return false;
        }
        return true;
    }
}
```

```java
//中序遍历
class Solution {
    public boolean isValidBST(TreeNode root) {
        Deque<TreeNode> stack = new LinkedList<TreeNode>();
        double inorder = -Double.MAX_VALUE;

        while (!stack.isEmpty() || root != null) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
              // 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树
            if (root.val <= inorder) {
                return false;
            }
            inorder = root.val;
            root = root.right;
        }
        return true;
    }
}
```

#### 【22】[左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

```
计算给定二叉树的所有左叶子之和。

示例：

    3
   / \
  9  20
    /  \
   15   7

在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```

```java
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if(root == null) return 0;
        int res = 0;
        //判断节点是否是左叶子节点，如果是则将它的和累计起来
        if(root.left != null 
           && root.left.left == null 
           && root.left.right == null){
          
            res += root.left.val;
        }
        return sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right) + res;
    }
}
```

```java
//广度
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if (root == null) {
            return 0;
        }

        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.offer(root);
        int ans = 0;
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
          	//加的时候判断一下是不是叶子节点，然后是左节点的话就累加值
            if (node.left != null) {
                if (isLeafNode(node.left)) {
                    ans += node.left.val;
                } else {
                    queue.offer(node.left);
                }
            }
            if (node.right != null) {
                if (!isLeafNode(node.right)) {
                    queue.offer(node.right);
                }
            }
        }
        return ans;
    }

    public boolean isLeafNode(TreeNode node) {
        return node.left == null && node.right == null;
    }
}
```

#### 【23】[二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

```
给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

注意：两结点之间的路径长度是以它们之间边的数目表示。
```

```java
class Solution {
    int maxd=0;
    public int diameterOfBinaryTree(TreeNode root) {
        depth(root);
        return maxd;
    }
    public int depth(TreeNode node){
        if(node==null){
            return 0;
        }
        int Left = depth(node.left);
        int Right = depth(node.right);
        maxd=Math.max(Left+Right,maxd);//将每个节点最大直径(左子树深度+右子树深度)当前最大值比较并取大者
        return Math.max(Left,Right)+1;//返回节点深度
    }
}
```

#### 【24】[N 叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1glvk8ry2h3j30lp0dy0ta.jpg" alt="img" style="zoom:33%;" />

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1glvk8yj9c1j30gk0f1q3i.jpg" alt="img" style="zoom:39%;" />

```
给定一个 N 叉树，找到其最大深度。
最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。
N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。

示例 1：
输入：root = [1,null,3,2,4,null,5,6]
输出：3

示例 2：
输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出：5
```

```java
//递归
class Solution {
  public int maxDepth(Node root) {
    if (root == null) {
      return 0;
    } else if (root.children.isEmpty()) {
      return 1;  
    } else {
      List<Integer> heights = new LinkedList<>();
      for (Node item : root.children) {
        heights.add(maxDepth(item)); 
      }
      return Collections.max(heights) + 1;
    }
  }
}

//迭代
import javafx.util.Pair;
import java.lang.Math;

class Solution {
  public int maxDepth(Node root) {
    Queue<Pair<Node, Integer>> stack = new LinkedList<>();
    if (root != null) {
      stack.add(new Pair(root, 1));
    }

    int depth = 0;
    while (!stack.isEmpty()) {
      Pair<Node, Integer> current = stack.poll();
      root = current.getKey();
      int current_depth = current.getValue();
      if (root != null) {
        depth = Math.max(depth, current_depth);
        for (Node c : root.children) {
          stack.add(new Pair(c, current_depth + 1));    
        }
      }
    }
    return depth;
  }
};
```

#### 【25】[二叉树的坡度](https://leetcode-cn.com/problems/binary-tree-tilt/)

```java
public class Solution {
    int tilt=0;
    public int findTilt(TreeNode root) {
        traverse(root);
        return tilt;
    }
    public int traverse(TreeNode root)
    {
        if(root==null )
            return 0;
        int left=traverse(root.left);
        int right=traverse(root.right);
        tilt+=Math.abs(left-right);
        return left+right+root.val;
    }
}
```

#### 【26】[合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

```
给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

示例 1:

输入: 
	Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
输出: 
合并后的树:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7
注意: 合并必须从两个树的根节点开始。
```

```java
//深度
class Solution {
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        if (t1 == null) {
            return t2;
        }
        if (t2 == null) {
            return t1;
        }
        TreeNode merged = new TreeNode(t1.val + t2.val);
        merged.left = mergeTrees(t1.left, t2.left);
        merged.right = mergeTrees(t1.right, t2.right);
        return merged;
    }
}
```

#### 【27】[在每个树行中找最大值](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)

```
您需要在二叉树的每一行中找到最大的值。
示例：
输入: 

          1
         / \
        3   2
       / \   \  
      5   3   9 

输出: [1, 3, 9]
```

```java
class Solution {
    public List<Integer> largestValues(TreeNode root) {
        //LinkedList实现队列
        Queue<TreeNode> queue = new LinkedList<>();
        List<Integer> values = new ArrayList<>();
        if (root != null)
            queue.add(root);//入队
        while (!queue.isEmpty()) {
            int max = Integer.MIN_VALUE;
            int levelSize = queue.size();//每一层的数量
            for (int i = 0; i < levelSize; i++) {
                TreeNode node = queue.poll();//出队
                max = Math.max(max, node.val);//记录每层的最大值
                if (node.left != null)
                    queue.add(node.left);
                if (node.right != null)
                    queue.add(node.right);
            }
            values.add(max);
        }
        return values;
    }
}
```



#### 【28】完全二叉树插入

```java
题目：给一颗完全二叉树，要求插入一个节点后，依然是完全二叉树。
分析：利用完全二叉树的性质，找到要插入的位置，先判断左子树的最右结点与右子树的最左结点高度，如果相等，只需要插入到左子树即可，否则插入右子树。
```

```java
public static TreeNode insertBinary(TreeNode root, TreeNode node){
        if(root == null)
            return node;
        else if(node == null)
            return root;
        if(root.left == null){
            root.left = node;
            return root;
        }
        else if(root.right == null){
            root.right = node;
            return root;
        }

        int lrh = 0;
        int rrh = 0;
        TreeNode pNode = root.left;
        while(pNode != null){
            lrh++;
            pNode = pNode.right;
        }

        pNode = root.right;
        while(pNode != null){
            rrh++;
            pNode = pNode.left;
        }

        if(lrh != rrh){
            insertBinary(root.right, node);
        }
        else
            insertBinary(root.left, node);
        return root;
    }
```



#### 【897】[递增顺序查找树](https://leetcode-cn.com/problems/increasing-order-search-tree/)

```
给你一个树，请你 按中序遍历 重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。
示例 ：
输入：[5,3,6,2,4,null,8,1,null,null,null,7,9]
       5
      / \
    3    6
   / \    \
  2   4    8
 /        / \ 
1        7   9
输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]
 1
  \
   2
    \
     3
      \
       4
        \
         5
          \
           6
            \
             7
              \
               8
                \
                 9  
```

```java
class Solution {
    TreeNode cur;
    public TreeNode increasingBST(TreeNode root) {
        TreeNode ans = new TreeNode(0);
        cur = ans;
        inorder(root);
        return ans.right;
    }

    public void inorder(TreeNode node) {
        if (node == null) return;
        inorder(node.left);
        node.left = null;
        cur.right = node;
        cur = node;
        inorder(node.right);
    }
}
```



### 6、其他

#### 【1】7瓶水1瓶有毒3只老鼠，怎么找有毒的水，再加个条件，必须要求第二天出结果

> - 思路：若无时间限制，可采用类似二分查找的思路；若要求第二天出结果，用二进制编码的思路
> - 参考回答：
>   - 二分查找思路，每次均分两组，每组各取一滴水混合成新溶剂喂给老鼠，继续对导致老鼠死亡的一组水进行同上操作。假如是第1瓶有毒，过程演绎如下，第一只老鼠死于前一堆（mid=(0+6)/2=3，即服用了第1、2、3、4瓶的混合溶剂），第二只老鼠死于前一堆（mid=(0+3)/2=1，即服用了第1、2瓶的混合溶剂），第三只老鼠随意试一瓶，根据服用后状态即可判断有毒的水。
>   - 二进制编码思路，对每瓶水二进制编码，所需编码位数正好为三位，将第一位是1的水混为新溶剂喂给第一个老鼠，以此类推，看三只老鼠服用状态（死亡=1，存活=0）得出对应的编码，找到对应的水即可。假如是第1瓶有毒，编码之后，让第一只老鼠服用第4、5、6、7瓶的混合溶剂，第二只老鼠服用第2、3、6、7瓶的混合溶剂，第三只老鼠服用第1、3、5、7瓶的混合溶剂，最终第一只和第二只老鼠存活，第三只老鼠死亡，对应编码为001，对应的水是第一瓶，故此瓶有毒。
>     **
>      第一瓶水 001
>      第二瓶水 010
>      第三瓶水 011
>      第四瓶水 100
>      第五瓶水 101
>      第六瓶水 110
>      第七瓶水 111
>      **



#### 【2】不用加减乘除做加法

>  * 一.无进位的各个位相加得10010+111=10101；注意观察相加的结果值和  这两个数进行异或的值相等
>     * 二.进位是10010+111=100  求两数相加的进位，相当于两数做按位与运算后再左移一位
>      * 三.再用10101+100发现还有进位，用10101和100重复第一第二步骤，异或得10001
>      * 按位与后左移一位得 进位值是1000
>      * 此时10001+1000=11001 没有进位，相当于两数做异或运算
>      * 
>      * 所以编程时，只要写一个循环 对两个数反复做  异或和按位与后左移一位操作  直到没有进位后

- [Leetcode](https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/mian-shi-ti-65-bu-yong-jia-jian-cheng-chu-zuo-ji-7/)

```java
class Solution {
    public int add(int num1, int num2) {
       //看到不用 加减号的计算就第一时间想着异或和与就好了， 记住口诀: 异或保留，与进位, 与为空时就返回
        while (num2 != 0) {
            //不考虑进位
            int sum=num1^num2;
            //考虑进位
            int carry=(num1&num2)<<1;
            num1=sum;
            num2=carry;
        }
        return num1;
    }
}
```



#### 【3】n个骰子点数

> - **题目：**把n个骰子扔到地上，所有骰子朝上一面的点数之后为s. 输入n，打印出s所有可能的值出现的概率。（每个骰子6个面，点数从1到6）
>
> - **思路：**
>
>   - 总共出现6的n次幂种组合
>   - 最小的和是n
>   - 最大的和是6n
>   - 总共6n-n+1种可能
>
> - **解法：**
>
>   - 解法1：基于递归，时间效率不高(自顶向下分解)
>
>     - 递归的思想一般是分而治之，**把n个骰子分为第一个和剩下的n-1个**。先计算第一个骰子每个点数出现的次数，再计算剩余n-1个骰子出现的点数之和。求n-1个骰子的点数之的方法和前面讲的一样，即再次把n-1个骰子分成两堆------第一个和剩下的n-2个。n个骰子，每个骰子6个面，总共有6n个组合。这6n个组合之中肯定有重复的，我们知道其范围是n~6n,对于每种情况我们可以用缓存机制记录下来，每当其发生一次我们令其对应的单元加1。
>
>       我们定义一个长度为6n-n+1的数组，和为s的点数出现的次数保存到数组第s-n个元素里。为什么是6n-n+1呢？因为n个骰子的**和最少是n，最大是6n，**介于这两者之间的每一个情况都可能会发生，总共6n-n+1种情况。下面是java源码：
>
>       - n=1 循环次数6
>       - n=2 循环次数72
>       - n=3 循环次数468
>       - n=4 循环次数2844
>       - n=5 循环次数17160
>
>   - 解法2：基于循环，时间性能好
>
>     - **递归一般是自顶向下的分析求解**，而基于循环的方法则是自底向上。基于循环的一般需要更少的空间和更少的时间，性能较好，但是一般代码比较难懂。
>
>       开两行数组初始化为0，下一次投骰子的时候，假设第一个数组中的第n个数字表示骰子和为n出现的次数，那么此时和为n的骰子出现次数应该等于上一次循环中骰子点数和为**n-1,n-2,n-3,n-4,n-5,n-6**的次数总和，所以我们把**另一个数组**的第**n**个数字设为前一个数组对应的n-1,n-2,n-3,n-4,n-5,n-6之和
>
>       - 第j次掷骰子，和最小为j，小于j的情况是不可能发生的！所以另不可能发生的次数设置为0！
>       - 第j次掷骰子，和最小为j，最大为g_maxValue*j，做二层循环
>
> - **复杂度：**时间：O（），空间O（）

```java
//递归
public class ck {
    public static void main(String[] args) {
        PrintProbability(2);
    }

    //n是不变的，到时候可以把参数省略
    private static final int g_maxValue = 6;
    private static int count = 0;
    private static int[] result;

    //基于递归求骰子点数，时间效率不高
    public static void PrintProbability(int n) {
        if (n < 1) return;
        //最大的数字
        int maxSum = n * g_maxValue;
        //6n-n+1
        result = new int[maxSum - n + 1];
        //初始化，开始统计之前都为0次
        for (int i = n; i <= maxSum; i++) {
            result[i - n] = 0;
        }
        //总共有多少种组合
        double total = Math.pow(g_maxValue, n);
        //probability(number,result);
        probability(n, result);
        //这个函数计算n~6n每种情况出现的次数
        for (int i = n; i <= maxSum; i++) {
            double ratio = result[i - n] / total;
            System.out.println("i: " + i + " ratio: " + ratio);
        }
        System.out.println("次数" + count);
    }

    public static void probability(int n, int[] result) {
        for (int i = 1; i <= g_maxValue; i++) {
            //循环6次，改变sum的值从1~6
            probability(n, n, i);
        }
    }

    /**
     * @param n       总共有多少骰子
     * @param current 当前第几个由n递减到1
     * @param sum     current个骰子的和 6次循环值从1~6
     */
    public static void probability(int n, int current, int sum) {
        //current==1时走此路
        if (current == 1) {
            //sum-n
            count++;
            result[sum - n]++; 				//关键点1
        } else {
            //计算抛去一个后的n-1个的可能性
            for (int i = 1; i <= g_maxValue; i++) {
                probability(n, current - 1, sum + i);   	//关键点2
                count++;
            }
        }
    }
}
```

```java
//循环
//- 第j次掷骰子，和最小为j，小于j的情况是不可能发生的！所以另不可能发生的次数设置为0！
//- 第j次掷骰子，和最小为j，最大为g_maxValue*j，做二层循环
for (int j = 2; j <= n; j++) {
           //第j次掷骰子，和最小为j，小于j的情况是不可能发生的！所以另不可能发生的次数设置为0！
           for (int i = 0; i < j; i++) {
               result[1 - flag][i] = 0;
           }
           //第j次掷骰子，和最小为j，最大为g_maxValue*j
           for (int i = j; i <= g_maxValue * j; i++) {
               //初始化，因为这个数组要重复使用，上一次的值要清0
               result[1 - flag][i] = 0;
               for (int k = 1; k <= i && k <= g_maxValue; k++) {
                   //进行赋值的核心代码
                   result[1 - flag][i] += result[flag][i - k];
                   count++;
               }
           }
           //flag在0与1之间切换
           flag = 1 - flag;
       }
//########
public class ck {
    public static void main(String[] args) {
        probability(2);
    }

    private static int count = 0;
    private static int flag = 0;
    private static final int g_maxValue = 6;
    private static int[][] result;

    //基于循环求骰子点数
    public static void probability(int n) {
        if (n < 1) {
            return;
        }
        //初始化数组 2行6n+1列的数组,因为下面的i从1开始
        //两行数组来回切换用于省空间
        //每次都换一行数组做上一次
        result = new int[2][g_maxValue * n + 1];
        for (int i = 0; i < g_maxValue; i++) {
            result[0][i] = 0;
            result[1][i] = 0;
        }
        //当第一次抛掷骰子时，有6种可能，每种可能出现一次
        for (int i = 1; i <= g_maxValue; i++) {
            result[0][i] = 1;
        }
        // 从第二次开始掷骰子，假设第一个数组中的第n个数字表示骰子和为n出现的次数，
        // 在下一循环中，我们加上一个新骰子，此时和为n的骰子出现次数应该等于上一次循环中骰子点数和为
        // n-1,n-2,n-3,n-4,n-5，n-6的次数总和，
        // 所以我们把另一个数组的第n个数字设为前一个数组对应的n-1,n-2,n-3,n-4,n-5，n-6之和
        for (int j = 2; j <= n; j++) {
            //第j次掷骰子，和最小为j，小于j的情况是不可能发生的！所以另不可能发生的次数设置为0！
            for (int i = 0; i < j; i++) {
                result[1 - flag][i] = 0;
            }
            //第j次掷骰子，和最小为j，最大为g_maxValue*j
            for (int i = j; i <= g_maxValue * j; i++) {
                //初始化，因为这个数组要重复使用，上一次的值要清0
                result[1 - flag][i] = 0;
                for (int k = 1; k <= i && k <= g_maxValue; k++) {
                    //进行赋值的核心代码
                    result[1 - flag][i] += result[flag][i - k];
                    count++;
                }
            }
            //flag在0与1之间切换
            //1-flag是当前要计算的，flag是上次的
            flag = 1 - flag;
        }

        //计算最终结果
        double total = Math.pow(g_maxValue, n);
        for (int i = n; i <= g_maxValue * n; i++) {
            double ratio = result[flag][i] / total;
            System.out.println("sum: " + i + " ratio: " + ratio);
        }
        System.out.println("次数" + count);
    }
}
```



#### 【4】2的幂

> - **题目：**给定一个整数，编写一个函数来判断它是否是 2 的幂次方
> - **思路：**
>   - 2的幂形如 10000000
>   - 2的幂-1 形如0111111
>   - 二者&运算结果为0

```java
class Solution {
    public boolean isPowerOfTwo(int n) {
        if(n<=0){
            return false;
        }
        return (n&n-1)==0;
    }
}
```



#### 【5】二进制表示中1的个数

> 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

```java
//public int NumberOf1(int n) {
        int count = 0;
        int flag = 1;
        while(flag != 0){
            if((n & flag) != 0){
                count ++;
            }
            flag = flag << 1;
        }
        return count;
    }
//解法2
每次减少传进来的数对应的二进制的一个1： 如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。 举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1， 而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作
public class Solution {
    public int hammingWeight(int n) {
        int count = 0;
        while(n != 0){
            count ++;
            n = n & (n-1);
        }
        return count;
    }
}
//解法3
public class Solution {
    public int hammingWeight(int n) {
        return Integer.bitCount(n);
    }
}
```



#### 【6】Lru算法

题目描述

设计LRU缓存结构，该结构在构造时确定大小，假设大小为K，并有如下两个功能

- set(key, value)：将记录(key, value)插入该结构
- get(key)：返回key对应的value值

[要求]

1. set和get方法的时间复杂度为O(1)
2. 某个key的set或get操作一旦发生，认为这个key的记录成了最常使用的。
3. 当缓存的大小超过K时，移除最不经常使用的记录，即set或get最久远的。

若opt=1，接下来两个整数x, y，表示set(x, y)
若opt=2，接下来一个整数x，表示get(x)，若x未出现过或已被移除，则返回-1
对于每个操作2，输出一个答案

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1glk8imjgikj314w0q6n16.jpg" alt="image-20201211212534376" style="zoom: 50%;" />

```java
public class LRUCache {
    private class Node{
        Node prev;
        Node next;
        int key;
        int value;

        public Node(int key, int value) {
            this.key = key;
            this.value = value;
            this.prev = null;
            this.next = null;
        }
    }

    private int capacity;
    private HashMap<Integer, Node> hs = new HashMap<Integer, Node>();
    private Node head = new Node(-1, -1);
    private Node tail = new Node(-1, -1);

    public LRUCache(int capacity) {
        this.capacity = capacity;
        tail.prev = head;
        head.next = tail;
    }

    public int get(int key) {
        if( !hs.containsKey(key)) {    		//key找不到
            return -1;
        }

        // remove current
        Node current = hs.get(key);
        current.prev.next = current.next;
        current.next.prev = current.prev;

        // move current to tail
        move_to_tail(current);			//每次get，使用次数+1，【最近使用，放于尾部】

        return hs.get(key).value;
    }

    public void set(int key, int value) {			//数据放入缓存
        // get 这个方法会把key挪到最末端，因此，不需要再调用 move_to_tail
        if (get(key) != -1) {
            hs.get(key).value = value;
            return;
        }

        if (hs.size() == capacity) {		//超出缓存上限
            hs.remove(head.next.key);		//删除头部数据
            head.next = head.next.next;
            head.next.prev = head;
        }

        Node insert = new Node(key, value);		//新建节点
        hs.put(key, insert);
        move_to_tail(insert);					//放于尾部
    }

    private void move_to_tail(Node current) {    //移动数据至尾部
        current.prev = tail.prev;
        tail.prev = current;
        current.prev.next = current;
        current.next = tail;
    }
}
```

#### [LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)

```
方法一：哈希表 + 双向链表
算法

LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。

双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。

哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。

这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 O(1)O(1) 的时间内完成 get 或者 put 操作。具体的方法如下：

对于 get 操作，首先判断 key 是否存在：

如果 key 不存在，则返回 -1−1；

如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。

对于 put 操作，首先判断 key 是否存在：

如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；

如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。

上述各项操作中，访问哈希表的时间复杂度为 O(1)O(1)，在双向链表的头部添加节点、在双向链表的尾部删除节点的复杂度也为 O(1)O(1)。而将一个节点移到双向链表的头部，可以分成「删除该节点」和「在双向链表的头部添加节点」两步操作，都可以在 O(1)O(1) 时间内完成。

小贴士

在双向链表的实现中，使用一个伪头部（dummy head）和伪尾部（dummy tail）标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。

```

![img](https://tva1.sinaimg.cn/large/0081Kckwly1glvjrbgt2sj30zk0k0t9w.jpg)

```java
public class LRUCache {
    class DLinkedNode {
        int key;
        int value;
        DLinkedNode prev;
        DLinkedNode next;
        public DLinkedNode() {}
        public DLinkedNode(int _key, int _value) {key = _key; value = _value;}
    }

    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();
    private int size;
    private int capacity;
    private DLinkedNode head, tail;

    public LRUCache(int capacity) {
        this.size = 0;
        this.capacity = capacity;
        // 使用伪头部和伪尾部节点
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            return -1;
        }
        // 如果 key 存在，先通过哈希表定位，再移到头部
        moveToHead(node);
        return node.value;
    }

    public void put(int key, int value) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            // 如果 key 不存在，创建一个新的节点
            DLinkedNode newNode = new DLinkedNode(key, value);
            // 添加进哈希表
            cache.put(key, newNode);
            // 添加至双向链表的头部
            addToHead(newNode);
            ++size;
            if (size > capacity) {
                // 如果超出容量，删除双向链表的尾部节点
                DLinkedNode tail = removeTail();
                // 删除哈希表中对应的项
                cache.remove(tail.key);
                --size;
            }
        }
        else {
            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
            node.value = value;
            moveToHead(node);
        }
    }

    private void addToHead(DLinkedNode node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }

    private void removeNode(DLinkedNode node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    private void moveToHead(DLinkedNode node) {
        removeNode(node);
        addToHead(node);
    }

    private DLinkedNode removeTail() {
        DLinkedNode res = tail.prev;
        removeNode(res);
        return res;
    }
}
```

```java
package stone.scu.cd;

import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Map.Entry;

//实现LRU
//使用LinkedHashMap实现
//LinkedHashMap底层就是用的【HashMap 加 双链表】实现的，而且本身已经实现了按照访问顺序的存储。
//此外，LinkedHashMap中本身就实现了一个方法removeEldestEntry用于判断是否需要移除最不常读取的数，
//方法默认是直接返回false，不会移除元素，所以需要重写该方法,即当缓存满后就移除最不常用的数。

public class LRU<K,V> {
	private LinkedHashMap<K, V> map;
	private int cacheSize;
	
	public LRU(int cacheSize)
	{
		this.cacheSize = cacheSize;
		map = new LinkedHashMap<K,V>(16,0.75F,true){
			
			@Override
			protected boolean removeEldestEntry(Entry eldest) {
				if(cacheSize + 1 == map.size()){
					return true;
				}else{
					return false;
				}
			}
		};  //end map
	}
	
	public synchronized V get(K key) {
		return map.get(key);
	}
	public synchronized void put(K key,V value) {
		map.put(key, value);
	}
	public synchronized void clear() {
		map.clear();
	}
	public synchronized int usedSize() {
		return map.size();
	}
	public void print() {
		for (Map.Entry<K, V> entry : map.entrySet()) {
			System.out.print(entry.getValue() + "--");
		}
		System.out.println();
	}
	
	public static void main(String[] args) {
		LRU<String, Integer> LRUMap = new LRU<>(3);
		LRUMap.put("key1", 1);
		LRUMap.put("key2", 2);
		LRUMap.put("key3", 3);
		LRUMap.print();
		System.out.println();
		LRUMap.put("key4", 4);
		LRUMap.print();
	}
}
//-----------------------------------------------------------------------------
//设置容量为10
    private static LRUCache<String, Integer> cache = new LRUCache<>(10);

    public static void main(String[] args) {
        //存入10个数据，之后cache满了
        for (int i = 0; i < 10; i++) {
            cache.put("Test" + i, i);   // 键值对
        }
        System.out.println("目前所有缓存：" + cache);
        cache.get("Test3");
        System.out.println("拿了Test3后的缓存：" + cache);
        cache.get("Test4");
        System.out.println("拿了Test4后的缓存：" + cache);
        cache.get("Test5");
        System.out.println("拿了Test5后的缓存：" + cache);
        cache.get("Test5");
        System.out.println("再拿了Test5后的缓存：" + cache);

        cache.put("Test" + 10, 10);  //cache已经满了，则会将最长没用的删除
        System.out.println("添加新元素10后的缓存(此时缓存已满)：" + cache);
    }

    private static class LRUCache<K, V> extends LinkedHashMap<K, V> {
        private int cacheSize;

        //使用指定的初始容量、装载因子和排序模式构造一个空的LinkedHashMap实例
        //true表示访问顺序，false表示插入顺序
        public LRUCache(int cacheSize) {
            super(16, (float) 0.75, true);
            this.cacheSize = cacheSize;
        }

        //如果不重写这个 会导致在新put数据时，不会删除最久没使用的，而是会新增到后边
        @Override
        protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
            //如果添加数据后，size()大于所要求的容量，则返回true，代表进行LRU删除
            return size() > cacheSize;  //size()返回此映射中的键值映射数
        }
    }

```





#### 【7】3升和5升的杯子，怎么得到4升水

```
第一，3升杯子里到bai满du水，在把里面的水到入5升杯zhi子里;
第二，dao再盛满3升杯子zhuan，里面的水也到入shu5升杯子里，这时候5升杯子里原来有3升水，再到2升就满了，所以，3升杯子就剩下1升水了;
第三，把5升杯子里的水倒掉，再把3升杯子里剩下的1升水到入5升杯子里;
第四，3升杯子再到满水，然后再到入5升杯子里，就得到4升水了。
```



#### 【8】进制转换

```
题目描述
给定一个十进制数M，以及需要转换的进制数N。将十进制数M转化为N进制数
示例1
输入
7,2
返回值
"111"
备注:
M是32位整数，2<=N<=16.
```

```java
public class Solution {
    /**
     * 进制转换
     * @param M int整型 给定整数
     * @param N int整型 转换到的进制
     * @return string字符串
     */
    public String solve (int M, int N) {
        if(M == 0){
            return "0";
        }
        boolean flag = true;
        if(M < 0){
            M = - M;
            flag = false;
        }
        // write code here
        String hex = "0123456789ABCDEF";
        StringBuilder sb = new StringBuilder();
      	//控制循环的条件
        while(M > 0){
            sb.append(hex.charAt(M%N));
            M = M/N;
        }
        return flag? sb.reverse().toString():"-" + sb.reverse().toString();
        
    }
}
```



#### 【Offer44】[数字序列中某一位的数字](https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/)

```
数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。

请写一个函数，求任意第n位对应的数字。

示例 1：

输入：n = 3
输出：3
示例 2：

输入：n = 11
输出：0
```

```java
/* 数字范围    数量  位数    占多少位
    1-9        9      1       9
    10-99      90     2       180
    100-999    900    3       2700
    1000-9999  9000   4       36000  ...

    例如 2901 = 9 + 180 + 2700 + 12 即一定是4位数,第12位   n = 12;
    数据为 = 1000 + (12 - 1)/ 4  = 1000 + 2 = 1002
    定位1002中的位置 = (n - 1) %  4 = 3    s.charAt(3) = 2;
*/
class Solution {
    public int findNthDigit(int n) {
        int digit = 1;   // n所在数字的位数
        long start = 1;  // 数字范围开始的第一个数
        long count = 9;  // 占多少位
        while(n > count){
            n -= count;
            digit++;
            start *= 10;
            count = digit * start * 9;
        }
        long num = start + (n - 1) / digit;
        return Long.toString(num).charAt((n - 1) % digit) - '0';
    }
}
```



---

### 7、多线程

#### 【1114】[按序打印](https://leetcode-cn.com/problems/print-in-order/)

```java
//【】
class Foo {
    private volatile int flag = 1;
    private ReentrantLock reentrantLock = new ReentrantLock();
    public Foo() {
    }

    public void first(Runnable printFirst) throws InterruptedException {
        for (;;) {
            if (flag == 1) {
                reentrantLock.lock();
                break;
            }
        }
        printFirst.run();
        flag = 2;
        reentrantLock.unlock();
    }

    public void second(Runnable printSecond) throws InterruptedException {
        for (;;) {
            if (flag == 2) {
                reentrantLock.lock();
                break;
            }
        }
        printSecond.run();
        flag = 3;
        reentrantLock.unlock();
    }

    public void third(Runnable printThird) throws InterruptedException {
        for (;;) {
            if (flag == 3) {
                reentrantLock.lock();
                break;
            }
        }
        printThird.run();
        reentrantLock.unlock();
    }
}
//【】
class Foo {
    private Object object = new Object();
    private volatile int flag = 1;
    public Foo() {
    }

    public void first(Runnable printFirst) throws InterruptedException {
        synchronized (object) {
            while (flag != 1) {
                object.wait();
            }
            printFirst.run();
            flag = 2;
            object.notifyAll();
        }
    }

    public void second(Runnable printSecond) throws InterruptedException {
        synchronized (object) {
            while (flag != 2) {
                object.wait();
            }
            printSecond.run();
            flag = 3;
            object.notifyAll();
        }
    }

    public void third(Runnable printThird) throws InterruptedException {
        synchronized (object) {
            while (flag != 3) {
                object.wait();
            }
            printThird.run();
            object.notifyAll();
        }
    }
}
//【】
import java.util.concurrent.CountDownLatch;
class Foo {
    private CountDownLatch second = new CountDownLatch(1);
    private CountDownLatch third = new CountDownLatch(1);
    public Foo() {
    }

    public void first(Runnable printFirst) throws InterruptedException {
        printFirst.run();
        second.countDown();
    }

    public void second(Runnable printSecond) throws InterruptedException {
        second.await();
        printSecond.run();
        third.countDown();
    }

    public void third(Runnable printThird) throws InterruptedException {
        third.await();
        printThird.run();
    }
}
//【】
import java.util.concurrent.Semaphore;
class Foo {
    public Semaphore seam_first_two = new Semaphore(0);
    
    public Semaphore seam_two_second = new Semaphore(0);
    
    public Foo() {
        
    }

    public void first(Runnable printFirst) throws InterruptedException {
        printFirst.run();
        seam_first_two.release();
    }

    public void second(Runnable printSecond) throws InterruptedException {
        seam_first_two.acquire();
        printSecond.run();
        seam_two_second.release();
    }

    public void third(Runnable printThird) throws InterruptedException {
        seam_two_second.acquire();
        printThird.run();
    }
}
```



---

### 链接

- 《剑指Offer》
- LeetCode

- https://www.jianshu.com/p/9648e8dd5bdb





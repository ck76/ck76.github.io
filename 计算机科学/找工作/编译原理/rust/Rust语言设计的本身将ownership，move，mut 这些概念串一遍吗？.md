https://www.zhihu.com/tardis/sogou/qus/41984859

刚接触rust，也了解过并行语言比起类C语言更难编写，rust语言本身中的mut、ownership难道是为了增加内存，减少锁，进而换取速度的吗？

---

设计方面Rust比较强调的就是所有权，所有权的意思是你对一块数据里的所有指针负责，因此当你销毁的时候编译器就知道所有这些指针该失效了。而当你移动的时候就知道从前的那些指针也应当无法访问了。当所有权不明确的时候就必须要用裸指针处理了，这些就是unsafe的领域。
所以我想说，有些人觉得unsafe就是Rust的禁区，这纯粹是误解。unsafe就是在所有权模糊的时候用的，意思是：类型系统无法得出这些代码内存安全的结论，但是你知道该怎么做来使得所有权不被非法侵犯。希望将来社区能出版一些高质量的普及读物，讲清楚这些内容。

除了所有权，Rust里面主要的技术就是从类型入手保证指针的有效性。具体来说就是提供内建的引用类型，对一个类型T可以分出&T和&mut T两种引用，分别是借出共享的所有权和独占的所有权。共享的情况下你可以借出多个引用。有点像读写锁，只不过是静态的。另外Rust有时候讲一个叫仿射类型的概念，那些没实现Copy特征的类型就是仿射类型，从这个角度来说&T不是仿射的，&mut T是仿射的。不过&mut T有一个reborrow的概念使得&mut T经常看上去不是仿射的。哦当然了，引用你也有需要设置失效的时候，这个时候就用到代数数据类型。具体来说就是Option<T>这样一个类型。当T是一个引用类型，你就能知道T不需要额外判断是否为空指针；而需要判断是否为空指针的位置类型会被设为Option<T>也就是会强迫你判断。

另外在Rust中模式匹配位置常常都会发生变量绑定（具体来说就是for-in，match， while let，if let，let，还有非extern的方法/函数实现处的实际参数这些位置），在这个绑定处（或者说匹配处）会限制说对一个类型T的绑定能不能借出&mut T，能的话就在匹配位加一个mut关键字，否则就不能。不过Rust里面绑定是完全局部化的，所以这个写起来也灵活，并不是一个很强力的约束，只是哪些地方需要借出&mut T相对更容易看清楚了。

最后，并不是并行语言更难写……而是正确编写并行的代码比较困难。
多数Rust的使用者其实都是从头到尾写单线程、堵塞的程序的，写并行程序的最多也就一半左右。
Rust也不增加内存，就比如说上面提到的Option<T>来保护空指针的技术，不仅能静态检查代码，帮助你写出更富语义的程序，还减少了运行时的CPU开销而内存占用量不变，完全是净收入。
至于说减少锁，Rust只不过在类型系统里能检查出数据竞争，它并不能减少锁，只是让你能写对代码而已。就算你用Rust重新实现系统后锁少了，只能说明你之前写错了。

mut其实不是一个概念= = （这个上面有说

---

学习一门新语言，我的做法是先从它的设计哲学开始，把该语言的所有概念串起来，这些概念不可能是零散的，尤其是对一门高度一致性的语言来说。如果这些概念没有形成体系，我就无法开始对这门语言的编程实践，因为心里没底。

我们来看一下Rust官网的介绍：Rust 是一门高性能、内存安全，并保证线程安全的系统编程语言。

一门语言的语言特性，是为它的设计目标服务的。

那么第一个目标：高性能，是如何实现的呢？基于LLVM，无GC，低运行时开销，零成本抽象，Rust有个强大的编译器。

后二个目标： 内存安全。在我学习的过程中，一度以为用Rust写代码，就肯定是安全代码了，也一度以为，Rust只有所有权机制是为这个目标服务的。到后来才发现自己的认识是错误的。首先内存安全这个概念很大，我现在认为它包含了四点：



1. 内存安全。基于所有权机制，但也并非只有所有权，还有Copy/Clone等行为；以及内存布局默认在栈上分配内存，而把堆分配做为可选；生命周期避免了悬空指针；RAII机制来保证分配的内存在出了作用域就得到自动释放；这些相关语言特性都是来保证内存安全。
2. 没有绝对的安全。Rust为你提供安全机制，也为你提供不安全的分界线。所有权机制是有界限的，也就是说安全是有界限的，Rust允许你把安全和不安全的代码分开，这样更容易保证安全。比如当你调用FFI、解构裸指针等。
3. 类型安全。强大的Trait，可以静态分发，也可动态分发；以及基于Trait的泛型机制，ADT/模式匹配的支持，Option/Result类型安全的错误模式；严格的编译器类型检查。
4. 并发安全。基于所有权机制，Rust只保证并发中的内存安全，而不保证避免数据竞争的条件之类的并发问题。而Rust里保证线程安全的两个记号Trait，Sender和Sync都是基于unsafe trait实现的。


我们也知道Rust是一门多范式语言。刚开始学的时候，我有个疑问：多范式语言，那么平时编程的时候侧重哪种范式呢？后来发现我的问题是多余的。多范式语言只是一些语言特性，它的目标还是为内存安全目标服务。

基于Struct和Impl，加上方法调用语法，可以写出面向对象范式的代码。比如可以写出像Ruby的链式调用代码。而基于Trait的唯一接口方式，简化了所谓的多态，也为类型系统提供了方便。

Rust也支持了函数式语言特性，包含高阶函数、闭包、强大的模式匹配等机制。

Rust的元编程能力也是非常棒的，最常用的是普通宏 macro_rule!， 这其实是一个特殊的函数，依赖强大的模式匹配，帮助你进行语法扩展。你所要做的，就是写出你要实现的宏的分词规则。另外一种就是procedural macro，可以用来实现编译器插件，它是直接操作AST，但是这个宏感觉不如Lisp系语言那种直接暴露AST操作起来爽。据说未来版本还会增强procedural macro的能力。

再一个就是智能指针系列，说实话，我对这部分内容还是不太理解，只知道它是Rust所有权机制的补充，为了满足更多的编程需求。

Rust的另一个特点就是工程化工具很棒，Cargo，可以快速帮你构建一个工程。不过至今我还没有写过一个完整的工程，我的下一步学习计划，就是仔细阅读一个完整的rust项目。初步定为Mio，希望下次可以分享。

最终，我的脑中就串起了图中这些的概念结构，我认为现在Rust对我来说一点都不神秘了。我终于可以心里有底的踏出下一步了。

概念图Github地址：[https://github.com/RustStudy/learn_rust_roadmap](https://link.zhihu.com/?target=https%3A//github.com/RustStudy/learn_rust_roadmap)





![img](https://tva1.sinaimg.cn/large/0081Kckwly1glodq3r0b1j30u00wtdjh.jpg)
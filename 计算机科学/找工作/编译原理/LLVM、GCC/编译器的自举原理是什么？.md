https://www.zhihu.com/question/28513473

```
早期的Pascal编译器都是围绕着由Niklaus Wirth提供的一组工具构造出来的，这些工具包括：
1、一个用Pascal语言编写的编译器，它生成P代码形式的输出（P代码是一种基于栈的语言，与现代Java编译器的字节码类似）；
2、同一个编译器，但已经被翻译成了P代码；
3、一个P代码解释器，也是用Pascal编写的。

——出自《程序设计语言-实践之路》

问题有三：
这三个工具间是如何协作将Pascal编译成汇编或者机器码的？
既然需要依赖其他语言写的编译器，不能完全叫自举吧？
既然是早期的编译器，那现代编译器自举又是如何工作的？
```

你想创造一门V语言而且用V语言来写V编译器的话，你得按照下面的方法做：

1、用C++把那个编译器（A）写出来，顺便留下很多测试用例。

2、用V语言把那个编译器写（B）出来，用A.exe来编译B，修改直到所有测试用例都通过为止。

3、B.exe来编译B自己得到B2.exe，修改直到B2.exe所有测试用例都通过为止。这是为了保证，就算B本身有很多bug，至少编译自己是没有bug的，从而你就可以走到第四步。

4、当你觉得有信心了，用A.exe把B编译一遍，就得到了B.exe。然后A的代码和A.exe都在也不需要存在了，删掉他们。以后你就不断的用B.exe来编译下一个版本的B就好了。就自举了。

---


编译器自举一般都是编译器开发的一个里程碑事件，你所举的例子Pascal编译器，其第一版编译器是用Fortran写的，而这也是常见的编译器自举过程的几乎必走的一条路，即最开始使用X语言（如Fortran）实现Y语言（如Pascal）的编译器，即解决鸡与蛋的问题，所以你的问题二是不正确的，因为我们先要使用其它语言构建出我们的第一版编译器，之后成熟以后，就可以完全使用已经生成好的编译器来编译出我们的新编译器。

而其实疑惑自举大部分就在鸡与蛋问题上，为什么可以自己可以编译自己，上面 

[@vczh](https://www.zhihu.com/people/0970f947b898ecc0ec035f9126dd4e08)

基本上概括了语言的鸡与蛋问题。而鸡与蛋问题还包括了跨体系结构，即在X结构上有一个C编译器，而Y结构没有这样的C编译器，那么这时候要使用的话，使用的就是交叉编译，而C与Free Pascal都是这样的。而支持新的语言特性其实也算，即使用C++98写支持C++11的C++编译器。而等待时机成熟后，就又可以使用C++11来写支持C++14的C++编译器，随后可以使用C++14来写支持C++1z的C++编译器......这就是现代编译器支持新的语言特性的自举方式了，所以你看Clang就开始使用C++11的语法来开发新版本的C++编译器了。



最后再来说你的第一个问题，你说的P代码其实就是中间代码输出形式，类似LLVM IR，而这个是编译器后端可以识别的形式，而编译器后端吃进去这样的中间代码，又会开始解析，然后根据体系结构的不同开始输出不同体系结构的汇编指令了，如X86，PPC等，输出这样的汇编指令后，就可以交给汇编器等更低级的工具去进行下一步骤了。

---

有一件事情是肯定的，那就是自举的第一步。任何一种语言（Machine code除外）的首个compiler肯定是用其他语言写出来的，然后在其基础上再演进才能开始自举。如果要把所有的所有计算机语言的自举都回溯到历史最初状态，那必然是会回推到Machine code。而Machine code本身是和计算机硬件相关的，再往前推，那就是物理和电气工程的范畴了

---

问题1：
用3（P代码解释器）解释运行2（P代码的编译器），然后用这个2来编译1（生成P代码的编译器）。总之就可以得到一个1的P版本，然后自己编译自己。不过整个的自举都是建立在P的解释器上的。一般来说是能够直接运行在机器上的，才叫纯正的编译器。

问题2：
前面的人都说了，总归高级语言都是需要翻译成机器语言的，所以开始的过程要么手焊机器码，要不然就借助其他语言工具。自举的意思是说整个编译器（有时候包含库）的代码都是自己编译自己，换句话说，编译器自己的机器码和初始构建工具彻底无关。

问题3：
现代的编译器自举，基本上就是用一个已经存在的编译器（包含其他的工具链）编译目标编译器，也许包括一些库，然后用得到的编译器和工具链的其他部分组合再次构建。默认GCC就是这么构建的，它还会再来一次，确认和上一次得到的结果是一样的（也就是该结果GCC和初始工具的特性无关）

最后，最初用来启动的编译器及工具链是不要实现任何优化的，并且需要的特性可能比要自举的编译器低（例如自举C++14的编译器大概不需要已经支持C++14的编译器来启动，或者不需要该特性的运行库）。
总归编译器里面的大部分代码都是和优化有关的，所以初始编译器被用到的部分其实不多。最后编译器本身也算是一个测试吧，如果他是NATIVE的话。
相对于NATIVE，交叉编译器产生的目标代码和自己的运行平台是不一致的，也就没办法自举。
不过有例外，像LLVM本身是包含多平台的，所以不但可以自举，而且还可能用一种更复杂的方式启动，例如在X86平台用GCC来编译LLVM，用得到的LLVM编译ARM上的LLVM，然后用最后的ARM上的LLVM自举（或者蛋疼的，可以回来构造一个X86的GCC）（另外，这里面的平台有时候单指指令集，有时候也包含操作系统的区别）。

补充，很多语言其实不一定要自举，运行库也可能是其他语言例如C++写的，但是有可能编译器和工具链的一部分还是需要自己来编译（这样有可能比较方便）。

---

轮子哥讲的挺好。
第一个问题无非是 源程序->编译器->中间程序->解释器->目标程序
第二个问题通过轮子哥的这种方法，其实已经摆脱了原有的语言，如果你是通过C写的，虽然你写的编译器A是C编译过来的。但是你用的不是A，你用的是B编译过来的编译器。B编译器是用你自己语言写的。

---

比如你是马云，没身份证(编译器)之前怎么证明自己是马云。

那你得弄来一张名为马云的身份证（编译器）。

问题来了，这张身份证怎么来呢？

你去找你爸要了户口本（其他语言的编译器）去派出所填写了自己的资料（自己编译器源码）办理身份证，因为户口本上你的名字是马云，派出所给了一张名为马云的身份证。

从此，你不用户口本，只用自己的身份证证明了你是马云(自己编译自己）。

从此，你可以用这个身份证去开花呗，信用卡，住酒店，去名为会所的地狱的三楼，凶神恶煞的女鬼们纷纷叫你马云老板，爸爸，生活缤纷多彩。

这就**自举，self-referencing**。

直到后来你举不动了，不举了。就被淘汰了，参照basic。

---

![image-20201219122612969](https://tva1.sinaimg.cn/large/0081Kckwly1glt1vwr3d5j315w0r2wpn.jpg)

---

0.拿 c 写一个 go 语言的编译器 C0, 这时候你就能编译 go 代码了
1.用 go 语言写了个编译器, 用 C0 编译成一个可执行的文件, 这个就是 C1
2.有了 C1,就可以把 C0 抛弃了, 这时候就算实现了自举

---

Rust 编译器最开始是 OCaml 写的——得到”OCaml 写的 Rust 编译器“，为简洁我们把这个编译器称为 P
注意 P 不需要做的非常完善，也不需要实现所有计划中的语言特性，只要能编译一些基本的程序就行，我们把 P 所实现的”原始版本的 Rust 语言”称为 R0

等 P 做到能用的程度，就用 R0 来写 R0 自己的编译器，我们把这个编译器的源码称为 S0，S0 可以直接使用 P 编译得到 E’（注意这里我们把源码和编译器分开了）

由于 E’ 也实现了 R0 语言，因此可以用 E’ 编译 S0，得到 E0

这时我们说 R0 实现了自举。
注意虽然一般默认 OCaml 是 AOT 编译的，但是 OCaml 也可以解释执行，P 也可以使用 JavaScript 等纯解释的语言实现，虽然 JavaScript 是比 Rust 更高层的语言，但是 P 仅用于实现 bootstrap，具体用什么语言实现不重要

在得到 E0 之后，P 就可以不要了，之后的开发全部在 S0 上进行（你现在去 Rust 的 GitHub 翻历史还能找到早期的 OCaml 编译器，不过在 bootstrap 之后早就被删了），之后编译器的第 n 个迭代版本的源码和可执行文件我们称为 Sn/En

注意此时 R0 依然是一个原始版本的语言，在完善语言设计和编译器实现的过程中会加入新特性或做出破坏兼容性的修改，而编译器的代码 Sn 本身可能也会使用到新特性，这时必须保证 E(n-1) 能够编译 Sn，也就是你不能一边实现新特性，一边在新特性的实现代码中使用新特性

---


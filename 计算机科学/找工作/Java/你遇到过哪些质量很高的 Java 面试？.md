[TOC]

，结合自己近一年在工作上又有些新的领悟，决定在原文章基础上增添一些内容，和大家分享下，如有时间再单独写一篇罢。

1. **技术上深度与广度兼顾**，计算机核心课程：计算机网络、数据结构、计算机组成原理、计算机操作系统，这几门课需要深入理解（重点），jdk源码、挑一些框架深入看一下（如Spring，Netty）、常用设计模式、一些中间件，如MQ、ES 、数据库：mysql、redis等，以上说的这些都是基本功，学习时可先实践，然后反向去看下相关理论知识，把这些东西搞得明明白白，并在工程上变现。
2. **业务相关** 你当下在做的东西技术栈怎样？其中优缺点？如果从零开始，能不能重新将其实现？当前系统的使用方是谁？用户量多大？用户集中使用的时间点？系统落下了哪些数据？这些数据的使用方是谁？系统依赖方是谁？这些最好自己能从技术、产品、业务角度去画下相关流程图，不然无论是面试还是平时工作，和不同方去对需求、乃至从技术去实现相关功能等，方方面面都会非常被动。
3. **和不同角色打交道注重技巧** 这一点自己也在总结之中，和产品、业务、运营、技术打交道，要知道自己职责边界，弄清楚哪些是需要自己做的，哪些是该其它方做的，交流起来不卑不亢。这一点涉及核心竞争力，哪天单独写一篇吧！

近来一直在面试，但半年时间，部门只进了三个人，和其它同事交流，总结下这些面试者一些共性，最想和他们讲的一句话就是：好好的把基础东西看看！过去在其它公司，主要注重的是工程业务能力，可以这么说：将业务代码写好绩效说不定就可以了，但在阿里是远远不够的，写好业务代码，绩效只能及格，其它KPI就看业务之外做了什么？据说Dubbo框架就是阿里员工为了KPI做出来的（只是听说）

太晚，有时间接着写。

未完待续...

--我觉得自己可以在头部再加上一句，一年时间，从java零基础到某一线互联网公司java资深工程师，回头一定和大家好好分享下学习路线。

--2019/3/1更新

因为本回答阅读量较大，作者觉得很有必要在开始加上一段话：下面写的内容（原回答）只是java非常基础的部分，java只是一个工具，作为工程师，要对整个计算机体系有相当程度掌握；其次要立足于工程需求，思考解决方案，即使面试java岗位，脱离java要问的还有很多：数据结构（数组，链表，树，图，排序...）、算法、缓存应用、mysql数据库底层原理、spring源码（至少AOP和IOC部分）、消息队列设计与使用，以及分布式环境下这些中间件的部署问题...

以上都熟悉后，还要认识到：科学分为基础科学和应用科学，工程师要深入理解应用的技术底层实现原理，其实从个人发展来说，应用必不可少，但是基础是远远重于应用的，只是对于公司来讲需要迅速产出，在互联网发展的风口，一般公司都首选熟练工，但以后，其实这段时间寒冬已经看出来了，招人比以前严格多了，公司更加注重面试者的基础知识，预计以后对基础知识考察会越来越严格。

**上面的话就是为了提醒大家：java只是一个工具；应用必不可少，但是基础知识是安身立命以及决定自己上限的东西。**

**--以下为原回答**

自己当初找工作时参加过众多一线互联网公司的Java研发面试，这段时间处于寒冬，然而前几天跳槽找工作，两天面了3家，已经拿了两个offer，觉得可以和大家分享下：

下面为拼多多、饿了么、蚂蚁金服、哈啰出行、携程、饿了么、2345、百度等公司给我留下较深印象的一些java面试题

1. private修饰的方法可以通过反射访问，那么private的意义是什么
2. Java类初始化顺序
3. 对方法区和永久区的理解以及它们之间的关系
4. 一个java文件有3个类，编译后有几个class文件
5. 局部变量使用前需要显式地赋值，否则编译通过不了，为什么这么设计
6. ReadWriteLock读写之间互斥吗
7. Semaphore拿到执行权的线程之间是否互斥
8. 写一个你认为最好的单例模式
9. B树和B+树是解决什么样的问题的，怎样演化过来，之间区别
10. 写一个生产者消费者模式
11. 写一个死锁
12. cpu 100%怎样定位
13. String a = "ab"; String b = "a" + "b"; a == b 是否相等，为什么
14. int a = 1; 是原子性操作吗
15. 可以用for循环直接删除ArrayList的特定元素吗？可能会出现什么问题？怎样解决
16. 新的任务提交到线程池，线程池是怎样处理
17. AQS和CAS原理
18. synchronized底层实现原理
19. volatile作用，指令重排相关
20. AOP和IOC原理
21. Spring怎样解决循环依赖的问题
22. dispatchServlet怎样分发任务的
23. mysql给离散度低的字段建立索引会出现什么问题，具体说下原因

其它经常问的HashMap底层实现原理，常规的多线程问题考的太多了，没什么新意就不写了

**平时不能光抱着应用Java的目的去学习，要深入了解每个知识点背后底层实现原理，为什么这么设计，比如问烂的HashMap 既然有hash进行排位还需要equals()作用是什么？就这个问题照样能问倒一些人，所以一定要抠细节，真的把每个知识点搞懂**

一时记起来的就是这23个吧，其它想起来后续补充，答案我这几天写个大纲吧

------

--2019.1.23更新（加上了：写在前面的话；问题解答大纲；一些新面试题；）

**转载请注明出处**，今天发现居然有人复制我的题目到其他网站，这本倒是没什么，关键是复制的题目当时我还没作答，看到里面存在明显错误的解答，这可能会给初学者带来困扰。

**感谢各位知友的关注，尤其感谢有人在评论区还作出有心的回答！**

**写在前面的话：**

1.面试主要分为两块：一块是考查工程师对基础知识（包括了技术广度、深度、对技术的热情度等）的掌握程度，因为**基础知识决定了一个技术人员发展的上限**；另一块是考察工程师的工程能力，比如：做过哪些项目？遇到最难的问题怎样解决的？说说最有成就感的一项任务？**工程能力是考察工程师当下能为公司带来的利益**。其它考核方面：抗压性、合作能力...暂且不说。

2.Java只是一门语言，即使是Java工程师也不能局限于Java，要从面向对象语言本身，甚至从整个计算机体系，从工程实际出发看Java。

3.很多知识在一般公司的开发中是用不到的，常有人戏称：“面试造火箭，工作拧螺丝”，但这只是通常情况下公司对程序员的标准——迅速产出，完成任务。个人观点：工程师为了自己职业的发展不能局限于公司对自己的要求，不能停留在应用层面，要能够很好地掌握基础知识，要多看源码，自己多实践，学成记得产出，比如多为开源社区贡献代码，帮助初学者指路等。

有没有发现一个有意思的事情：“面试造火箭，工作拧螺丝”的背后其实是考察者内心深处普遍都认可基础知识的重要性（这一点仅为个人观点，不展开讲哈）。

--**以下为解答大纲，部分作了扩展**

\1. 这题是一道思想题目，天天会碰到private，有没有想过这个问题？谈谈对java设计的认识程度，主要抓住两点：1.java的private修饰符并不是为了绝对安全性设计的，更多是对用户常规使用java的一种约束；2.从外部对对象进行常规调用时，能够看到清晰的类结构。

\2. 先说结论： 基类静态代码块，基类静态成员字段（并列优先级，按照代码中出现的先后顺序执行，且只有第一次加载时执行）——>派生类静态代码块，派生类静态成员字段（并列优先级，按照代码中出现的先后顺序执行，且只有第一次加载时执行）——>基类普通代码块，基类普通成员字段（并列优点级，按代码中出现先后顺序执行）——>基类构造函数——>派生类普通代码块，派生类普通成员字段（并列优点级，按代码中出现先后顺序执行）——>派生类构造函数

代码验证：

```java
class Log {
    public static String initLog(String log) { System.out.println(log);return null; }
}

/**
 *  基类
*/

class Base {
    static { System.out.println("Base Static Block 1"); }

    private static String staticValue = Log.initLog("Base Static Fiels");

    static { System.out.println("Base Static Block 2"); }

    { System.out.println("Base Normal Block 1"); }

    private String value = Log.initLog("Base Normal Field");

    { System.out.println("Base Normal Block 2"); }

    Base() { System.out.println("Base Constructor"); }
}

/**
 *  派生类
 */
public class Derived extends Base {
    static { System.out.println("Static Block 1"); }

    private static String staticValue = Log.initLog("Static Fiels");

    static { System.out.println("Static Block 2"); }

    { System.out.println("Normal Block 1"); }

    private String value = Log.initLog("Normal Field");

    { System.out.println("Normal Block 2"); }

    Derived() { System.out.println("Derived Constructor"); }

/**
 *  主线程
 */

public static void main(String[] args) {
    Derived derived = new Derived();
}
```

控制台结果输出：

```java
Base Static Block 1
Base Static Fiels
Base Static Block 2
Static Block 1
Static Fiels
Static Block 2
Base Normal Block 1
Base Normal Field
Base Normal Block 2
Base Constructor
Normal Block 1
Normal Field
Normal Block 2
Derived Constructor
```

第2题之前的回答欠妥，现已改正，在此非常感谢提出质疑的知友！

\3. 方法区是jvm规范里要求的，永久区是Hotspot虚拟机对方法区的具体实现，**前者是规范，后者是实现方式**。jdk1.8作了改变。本题看看对方在思想层面对jvm的理解程度，很基础的一个题目。

\4. 文件中有几个类编译后就有几个class文件。

\5. 成员变量是可以不经初始化的，在类加载过程的准备阶段即可给它赋予默认值，但局部变量使用前需要显式赋予初始值，javac不是推断不出不可以这样做，而是没有这样做，对于成员变量而言，其赋值和取值访问的先后顺序具有不确定性，对于成员变量可以在一个方法调用前赋值，也可以在方法调用后进行，这是运行时发生的，编译器确定不了，交给jvm去做比较合适。而对于局部变量而言，其赋值和取值访问顺序是确定的。**这样设计是一种约束**，尽最大程度减少使用者犯错的可能（假使局部变量可以使用默认值，可能总会无意间忘记赋值，进而导致不可预期的情况出现）。

\6. ReadWriteRock 读写锁，使用场景可分为读/读、读/写、写/写，除了读和读之间是共享的，其它都是互斥的，接着会讨论下怎样实现互斥锁和同步锁的， 想了解对方对AQS，CAS的掌握程度，技术学习的深度。

\7. Semaphore拿到执行权的线程之间是否互斥，Semaphore、CountDownLatch、CyclicBarrier、Exchanger 为java并发编程的4个辅助类，面试中常问的 CountDownLatch CyclicBarrier之间的区别，面试者肯定是经常碰到的， 所以问起来意义不大，Semaphore问的相对少一些，有些知识点如果没有使用过还是会忽略，Semaphore可有多把锁，可允许多个线程同时拥有执行权，这些有执行权的线程如并发访问同一对象，会产生线程安全问题。

\8. 写一个你认为最好的单例模式， 这题面试者都可能遇到过，也算是工作中最常遇到的设计模式之一，想考察面试者对经常碰到的题目的理解深度，单例一共有几种实现方式：饿汉、懒汉、静态内部类、枚举、双检锁，要是写了简单的懒汉式可能就会问：要是多线程情况下怎样保证线程安全呢，面试者可能说双检锁，那么聊聊为什么要两次校验，接着会问光是双检锁还会有什么问题，这时候基础好的面试者就会说了:对象在定义的时候加上volatile关键字，接下来会继续引申讨论下原子性和可见性、java内存模型、类的加载过程。

其实没有最好，枚举方式、静态内部类、双检锁都是可以的，就想听下对不同的单例写法认识程度，写个双检锁的方式吧：

```java
public class Singleton {
    private Singleton() {
    }

    private volatile static Singleton instance;

    public static Singleton getInstance() {
        if (null == instance) {
            synchronized (Singleton.class) {
                if (null == instance) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }

}
```

\9. B树和B+树，这题既问mysql索引的实现原理，也问数据结构基础，首先从二叉树说起，因为会产生退化现象，提出了平衡二叉树，再提出怎样让每一层放的节点多一些来减少遍历高度，引申出m叉树，m叉搜索树同样会有退化现象，引出m叉平衡树，也就是B树，这时候每个节点既放了key也放了value，怎样使每个节点放尽可能多的key值，以减少遍历高度呢（访问磁盘次数），可以将每个节点只放key值，将value值放在叶子结点，在叶子结点的value值增加指向相邻节点指针，这就是优化后的B+树。然后谈谈数据库索引失效的情况，为什么给离散度低的字段（如性别）建立索引是不可取的，查询数据反而更慢，如果将离散度高的字段和性别建立联合索引会怎样，有什么需要注意的？

\10. 生产者消费者模式，synchronized锁住一个LinkedList，一个生产者，只要队列不满，生产后往里放，一个消费者只要队列不空，向外取，两者通过wait()和notify()进行协调，写好了会问怎样提高效率，最后会聊一聊消息队列设计精要思想及其使用。

\11. 写一个死锁，觉得这个问题真的很不错，经常说的死锁四个条件，背都能背上，那写一个看看，思想为：定义两个ArrayList,将他们都加上锁A,B，线程1,2，1拿住了锁A ，请求锁B，2拿住了锁B请求锁A，在等待对方释放锁的过程中谁也不让出已获得的锁。

```java
public class DeadLock {
    public static void main(String[] args) {
        final List<Integer> list1 = Arrays.asList(1, 2, 3);
        final List<Integer> list2 = Arrays.asList(4, 5, 6);
        new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (list1) {
                    for (Integer i : list1) {
                        System.out.println(i);
                    }
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    synchronized (list2) {
                        for (Integer i : list2) {
                            System.out.println(i);
                        }
                    }
                }
            }
        }).start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (list2) {
                    for (Integer i : list2) {
                        System.out.println(i);
                    }
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    synchronized (list1) {
                        for (Integer i : list1) {
                            System.out.println(i);
                        }
                    }
                }
            }
        }).start();

    }
}
```

\12. cpu 100%怎样定位，这题是一个应用性题目，网上搜一下即可，比较常见，说实话，把这题放进来有点后悔。

\13. String a = "ab"; String b = "a" + "b"; a ，b 是相等的（各位要写代码验证一下，我看到有人写了错误答案）。常规的问法是new一个对象赋给变量，问：这行表达式创建了几个对象，但这样的题目太常见。

\14. int a = 1; 是原子性操作。

\15. for循环直接删除ArrayList中的特定元素是错的，不同的for循环会发生不同的错误，泛型for会抛出 ConcurrentModificationException，普通的for想要删除集合中重复且连续的元素，只能删除第一个。

错误原因：打开JDK的ArrayList源码，看下ArrayList中的remove方法（注意ArrayList中的remove有两个同名方法，只是入参不同，这里看的是入参为Object的remove方法）是怎么实现的，一般情况下程序的执行路径会走到else路径下最终调用faseRemove方法,会执行System.arraycopy方法，导致删除元素时涉及到数组元素的移动。针对普通for循环的错误写法，在遍历第一个字符串b时因为符合删除条件，所以将该元素从数组中删除，并且将后一个元素移动（也就是第二个字符串b）至当前位置，导致下一次循环遍历时后一个字符串b并没有遍历到，所以无法删除。针对这种情况可以倒序删除的方式来避免

解决方案：用 Iterator。

```java
 List<String> list = new  ArrayList(Arrays.asList("a", "b",  "b" , "c", "d"));
 Iterator<String> iterator = list.iterator();
       while(iterator.hasNext()) {
           String element = iterator.next();
           if(element.equals("b")) {
               iterator.remove();
           }
```

将本问题扩展一下，下面的代码可能会出现什么问题？

```java
ArrayList<String> array = new ArrayList<String>();
array.add(1,"hello world");
```

--2019.2.7更新（写了16 - 23题解答大纲）

\16. 第一步 ：线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则执行第二步。

第二步 ：线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里进行等待。如果工作队列满了，则执行第三步。

第三步 ：线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。

\17. 抽象队列同步器AQS（AbstractQueuedSychronizer），如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，ReentrantLock、CountDownLatch、Semaphore等都用到了它。AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。

比较并替换CAS(Compare and Swap)，假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false，整个比较并替换的操作是一个原子操作。CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的相应值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，下面永远都不可能成功。

CAS虽然比较高效的解决了原子操作问题，但仍存在三大问题。

- 循环时间长开销很大。
- 只能保证一个共享变量的原子操作。
- ABA问题。

\18. synchronized (this)原理：涉及两条指令：monitorenter，monitorexit；再说同步方法，从同步方法反编译的结果来看，方法的同步并没有通过指令monitorenter和monitorexit来实现，相对于普通方法，其常量池中多了ACC_SYNCHRONIZED标示符。

JVM就是根据该标示符来实现方法的同步的：当方法被调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。

这个问题会接着追问：java对象头信息，偏向锁，轻量锁，重量级锁及其他们相互间转化。

\19. 理解volatile关键字的作用的前提是要理解Java内存模型，volatile关键字的作用主要有两点：

- 多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据
- 代码底层执行不像我们看到的高级语言—-Java程序这么简单，它的执行是Java代码–>字节码–>根据字节码执行对应的C/C++代码–>C/C++代码被编译成汇编语言–>和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率

从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。

\20. AOP 和 IOC是Spring精华部分，AOP可以看做是对OOP的补充，对代码进行横向的扩展，通过代理模式实现，代理模式有静态代理，动态代理，Spring利用的是动态代理，在程序运行过程中将增强代码织入原代码中。IOC是控制反转，将对象的控制权交给Spring框架，用户需要使用对象无需创建，直接使用即可。AOP和IOC最可贵的是它们的思想。

\21. 什么是循环依赖，怎样检测出循环依赖，Spring循环依赖有几种方式，使用基于setter属性的循环依赖为什么不会出现问题，接下来会问：Bean的生命周期。



\22. 上一张图，从这张图去理解

![img](https://pic2.zhimg.com/v2-976a59b61d42ddbf93ceb26aa3ba44e6_r.jpg?source=1940ef5c)

具体流程：

1）. 用户发请求-->DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制。

2）.DispatcherServlet-->HandlerMapping，HandlerMapping将会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器,多个HandlerInterceptor拦截器)。

3）.DispatcherServlet-->HandlerAdapter,HandlerAdapter将会把处理器包装为适配器，从而支持多种类型的处理器。

4）.HandlerAdapter-->处理器功能处理方法的调用，HandlerAdapter将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理，并返回一个ModelAndView对象(包含模型数据，逻辑视图名)

5）.ModelAndView的逻辑视图名-->ViewResolver，ViewResoler将把逻辑视图名解析为具体的View。

6）.View-->渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构

7）.返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户。

\23. 先上结论：重复性较强的字段，不适合添加索引。mysql给离散度低的字段，比如性别设置索引，再以性别作为条件进行查询反而会更慢。

一个表可能会涉及两个数据结构(文件)，一个是表本身，存放表中的数据，另一个是索引。索引是什么？它就是把一个或几个字段（组合索引）按规律排列起来，再附上该字段所在行数据的物理地址（位于表中）。比如我们有个字段是年龄，如果要选取某个年龄段的所有行，那么一般情况下可能需要进行一次全表扫描。但如果以这个年龄段建个索引，那么索引中会按年龄值根据特定数据结构建一个排列，这样在索引中就能迅速定位，不需要进行全表扫描。为什么性别不适合建索引呢？因为访问索引需要付出额外的IO开销，从索引中拿到的只是地址，要想真正访问到数据还是要对表进行一次IO。假如你要从表的100万行数据中取几个数据，那么利用索引迅速定位，访问索引的这IO开销就非常值了。但如果是从100万行数据中取50万行数据，就比如性别字段，那你相对需要访问50万次索引，再访问50万次表，加起来的开销并不会比直接对表进行一次完整扫描小。

当然如果把性别字段设为表的聚集索引，那么就肯定能加快大约一半该字段的查询速度了。聚集索引指的是表本身数据按哪个字段的值来进行排序。因此，聚集索引只能有一个，而且使用聚集索引不会付出额外IO开销。当然你得能舍得把聚集索引这么宝贵资源用到性别字段上。

可以根据业务场景需要，将性别和其它字段建立联合索引，比如时间戳，但是建立索引记得把时间戳字段放在性别前面。

感谢各位知友，作者这段时间在构思写一个**Java知识精要系列，**将java知识点全部串起来，适用于各个层次的java学习者，有兴趣可以关注下。

------

后加

1. jvm gc 复制算法是怎样实现的
2. 注解的原理
3. 进程间通信的方式有哪些
4. ReentrantLock 是可重入锁，什么是可重入锁
5. 线程执行过程中遇到异常会发生什么，怎样处理
6. HashMap put()元素产生冲突，为什么用LinkedList（拉链法）而不用ArrayList解决，产生冲突时key值不等，新元素怎样加入链表，为什么这么设计（jdk1.8之前）
7. 双检锁写一个单例模式，为什么要用volatile修饰对象，Object object = new Object(); object为null吗？为什么
8. Object object = new Object(); 初始化的顺序是什么在jvm各区域做了什么
9. 线程怎样按顺序执行
10. true or false ?

```java
ArrayList<Integer> list1 = new ArrayList<>(); 
ArrayList<String> list2 = new ArrayList<>();  
System.out.print(list1.getClass() == list2.getClass); 
```

\11. 修饰类的锁和修饰方法的锁的区别

\12. 下面代码中的method()方法会互斥访问吗，为什么

```java
class A {
    public synchronized void method() {/**/}
}

new Thread(() -> { A a = new A();a.method(); }).start();
 new Thread(() -> { A b = new A();b.method(); }).start();
```

\13. synchronized在1.7以后的版本作了什么优化提升效率

14.CAS底层是怎样实现原子性的

15.java线程池实现的原理

\16. 算法题：各大排序算法（尤其是快排和堆排序），查找（二分），树的遍历，DFS和BFS...

后加的16个题目只能说是常规题型，网上解答都有，在此不写答案了，腾出时间最近一直想写个java知识精要系列。

参考资料：

*《java编程思想》*

*《Effective Java 第三版》*

*《深入理解java虚拟机》*

*《高性能Mysql》*

*《Spring实战》*

*《数据结构-使用C++语言描述》*



----

这份面试清单是我从 2015 年做 TeamLeader 之后开始收集的，一方面是给公司招聘用，另一方面是想用它来挖掘我在 Java 技术栈中的技术盲点，然后修复和完善它，以此来提高自己的技术水平。虽然我从 2009 年就开始参加编程工作了，但依旧觉得还有很多东西要学，当然学习的过程也给我带来了很多成就感，这些成就感也推动我学习更多的技术知识。

说实话刚开始的时候还是比较犹豫的，首先我会觉得这么做会不会有点帮人“作弊”的嫌疑，最后我想通了，这是一件值得去做的事儿。

- 第一：让更多的人因此而学到了更多的知识，这是一件大好事。
- 第二：这只是经验的高度提炼，让那些原本就掌握了技术却不知道怎么表达的人，学会如何在面试中展示自己。
- 第三：如果只是死记硬背这些面试题，只要面试官再深入问纠一下，也可对这个人有一个准确的认识，之前说的“帮人作弊”的事就不存在了。
- 第四：学习有很多种方式，但只有好学者才会临池学书。如果是不想学的人，提供再多再好的资料放在他们的面前，他们也会视而不见↓↓↓

【小白必备】免费领取Java入门课程，大佬带你做实战项目



就像之前听过的一个故事，为什么在美国有些企业只要看你是哈佛的学历就直接录取？并不是哈佛有多么厉害，当然教学质量也是其中原因之一，但更多的是在美国上大学还是挺贵的，首先你能上的起哈佛，说明你的家庭条还不错，从小应该就有很多参加更好教育的机会；

其次，你能进入哈佛，也说明你脑子不笨，能考的上哈佛；最后才是哈佛确实能给你提供一个，相对不错的教育环境。综合以上特质，所以这些企业才敢直接聘请那些有哈佛学历的人。

对应到我们这份面试题其实也一样，首先你如果能记住其中大部分的答案说明，第一，你很聪明并且记性还很好；第二，说明你有上进心，也愿意学习；第三，有了这份面试题做理论支撑之后，即使你的实践经验没有那么多，但懂得原理的你，做出来的程序也一定不会太差。

所以如果您是面试官，恰好又看到这里，如果条件允许的话，请多给这样愿意学又很聪明的年轻人多一些机会。

> 作者：老王 原文出自：gitchat

**01**

## **面试题模块介绍**

说了这么多，下面进入我们本文的主题，我们这份面试题，包含的内容了十九了模块：Java 基础、容器、多线程、反射、对象拷贝、Java Web 模块、异常、网络、设计模式、Spring/Spring MVC、Spring Boot/Spring Cloud、Hibernate、Mybatis、RabbitMQ、Kafka、Zookeeper、MySql、Redis、JVM 。如下图所示：



![img](https://pic4.zhimg.com/v2-8fedf3ba70c40eba09b1c6659e272c4c_r.jpg?source=1940ef5c)

可能对于初学者不需要看后面的框架和 JVM 模块的知识，读者朋友们可根据自己的情况，选择对应的模块进行阅读。

**适宜阅读人群**

- 需要面试的初/中/高级 java 程序员
- 想要查漏补缺的人
- 想要不断完善和扩充自己 java 技术栈的人
- java 面试官

## **02**

## **具体面试题**

下面一起来看 208 道面试题，具体的内容。

**一、Java 基础**

1.JDK 和 JRE 有什么区别？

2.== 和 equals 的区别是什么？

3.两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？

4.final 在 java 中有什么作用？

5.java 中的 Math.round(-1.5) 等于多少？

6.String 属于基础的数据类型吗？

7.java 中操作字符串都有哪些类？它们之间有什么区别？

8.String str="i"与 String str=new String(“i”)一样吗？

9.如何将字符串反转？

10.String 类的常用方法都有那些？

11.抽象类必须要有抽象方法吗？

12.普通类和抽象类有哪些区别？

13.抽象类能使用 final 修饰吗？

14.接口和抽象类有什么区别？

15.java 中 IO 流分为几种？

16.BIO、NIO、AIO 有什么区别？

17.Files的常用方法都有哪些？

**二、容器**

18.java 容器都有哪些？

19.Collection 和 Collections 有什么区别？

20.List、Set、Map 之间的区别是什么？

21.HashMap 和 Hashtable 有什么区别？

22.如何决定使用 HashMap 还是 TreeMap？

23.说一下 HashMap 的实现原理？

24.说一下 HashSet 的实现原理？

25.ArrayList 和 LinkedList 的区别是什么？

26.如何实现数组和 List 之间的转换？

27.ArrayList 和 Vector 的区别是什么？

28.Array 和 ArrayList 有何区别？

29.在 Queue 中 poll()和 remove()有什么区别？

30.哪些集合类是线程安全的？

31.迭代器 Iterator 是什么？

32.Iterator 怎么使用？有什么特点？

33.Iterator 和 ListIterator 有什么区别？

34.怎么确保一个集合不能被修改？

**三、多线程**

35.并行和并发有什么区别？

36.线程和进程的区别？

37.守护线程是什么？

38.创建线程有哪几种方式？

39.说一下 runnable 和 callable 有什么区别？

40.线程有哪些状态？

41.sleep() 和 wait() 有什么区别？

42.notify()和 notifyAll()有什么区别？

43.线程的 run()和 start()有什么区别？

44.创建线程池有哪几种方式？

45.线程池都有哪些状态？

46.线程池中 submit()和 execute()方法有什么区别？

47.在 java 程序中怎么保证多线程的运行安全？

48.多线程锁的升级原理是什么？

49.什么是死锁？

50.怎么防止死锁？

51.ThreadLocal 是什么？有哪些使用场景？

52.说一下 synchronized 底层实现原理？

53.synchronized 和 volatile 的区别是什么？

54.synchronized 和 Lock 有什么区别？

55.synchronized 和 ReentrantLock 区别是什么？

56.说一下 atomic 的原理？

**四、反射**

57.什么是反射？

58.什么是 java 序列化？什么情况下需要序列化？

59.动态代理是什么？有哪些应用？

60.怎么实现动态代理？

**五、对象拷贝**

61.为什么要使用克隆？

62.如何实现对象克隆？

63.深拷贝和浅拷贝区别是什么？

**六、Java Web**

64.jsp 和 servlet 有什么区别？

65.jsp 有哪些内置对象？作用分别是什么？

66.说一下 jsp 的 4 种作用域？

67.session 和 cookie 有什么区别？

68.说一下 session 的工作原理？

69.如果客户端禁止 cookie 能实现 session 还能用吗？

70.spring mvc 和 struts 的区别是什么？

71.如何避免 sql 注入？

72.什么是 XSS 攻击，如何避免？

73.什么是 CSRF 攻击，如何避免？

**七、异常**

74.throw 和 throws 的区别？

75.final、finally、finalize 有什么区别？

76.try-catch-finally 中哪个部分可以省略？

77.try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？

78.常见的异常类有哪些？

**八、网络**

79.http 响应码 301 和 302 代表的是什么？有什么区别？

80.forward 和 redirect 的区别？

81.简述 tcp 和 udp的区别？

82.tcp 为什么要三次握手，两次不行吗？为什么？

83.说一下 tcp 粘包是怎么产生的？

84.OSI 的七层模型都有哪些？

85.get 和 post 请求有哪些区别？

86.如何实现跨域？

87.说一下 JSONP 实现原理？

**九、设计模式**

88.说一下你熟悉的设计模式？

89.简单工厂和抽象工厂有什么区别？

**十、Spring/Spring MVC**

90.为什么要使用 spring？

91.解释一下什么是 aop？

92.解释一下什么是 ioc？

93.spring 有哪些主要模块？

94.spring 常用的注入方式有哪些？

95.spring 中的 bean 是线程安全的吗？

96.spring 支持几种 bean 的作用域？

97.spring 自动装配 bean 有哪些方式？

98.spring 事务实现方式有哪些？

99.说一下 spring 的事务隔离？

100.说一下 spring mvc 运行流程？

101.spring mvc 有哪些组件？

102.@RequestMapping 的作用是什么？

103.@Autowired 的作用是什么？

**十一、Spring Boot/Spring Cloud**

104.什么是 spring boot？

105.为什么要用 spring boot？

106.spring boot 核心配置文件是什么？

107.spring boot 配置文件有哪几种类型？它们有什么区别？

108.spring boot 有哪些方式可以实现热部署？

109.jpa 和 hibernate 有什么区别？

110.什么是 spring cloud？

111.spring cloud 断路器的作用是什么？

112.spring cloud 的核心组件有哪些？

**十二、Hibernate**

113.为什么要使用 hibernate？

114.什么是 ORM 框架？

115.hibernate 中如何在控制台查看打印的 sql 语句？

116.hibernate 有几种查询方式？

117.hibernate 实体类可以被定义为 final 吗？

118.在 hibernate 中使用 Integer 和 int 做映射有什么区别？

119.hibernate 是如何工作的？

120.get()和 load()的区别？

121.说一下 hibernate 的缓存机制？

122.hibernate 对象有哪些状态？

123.在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？

124.hibernate 实体类必须要有无参构造函数吗？为什么？

**十三、Mybatis**

125.mybatis 中 #{}和 ${}的区别是什么？

126.mybatis 有几种分页方式？

127.RowBounds 是一次性查询全部结果吗？为什么？

128.mybatis 逻辑分页和物理分页的区别是什么？

129.mybatis 是否支持延迟加载？延迟加载的原理是什么？

130.说一下 mybatis 的一级缓存和二级缓存？

131.mybatis 和 hibernate 的区别有哪些？

132.mybatis 有哪些执行器（Executor）？

133.mybatis 分页插件的实现原理是什么？

134.mybatis 如何编写一个自定义插件？

**十四、RabbitMQ**

135.rabbitmq 的使用场景有哪些？

136.rabbitmq 有哪些重要的角色？

137.rabbitmq 有哪些重要的组件？

138.rabbitmq 中 vhost 的作用是什么？

139.rabbitmq 的消息是怎么发送的？

140.rabbitmq 怎么保证消息的稳定性？

141.rabbitmq 怎么避免消息丢失？

142.要保证消息持久化成功的条件有哪些？

143.rabbitmq 持久化有什么缺点？

144.rabbitmq 有几种广播类型？

145.rabbitmq 怎么实现延迟消息队列？

146.rabbitmq 集群有什么用？

147.rabbitmq 节点的类型有哪些？

148.rabbitmq 集群搭建需要注意哪些问题？

149.rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？

150.rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？

151.rabbitmq 对集群节点停止顺序有要求吗？

**十五、Kafka**

152.kafka 可以脱离 zookeeper 单独使用吗？为什么？

153.kafka 有几种数据保留的策略？

154.kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？

155.什么情况会导致 kafka 运行变慢？

156.使用 kafka 集群需要注意什么？

**十六、Zookeeper**

157.zookeeper 是什么？

158.zookeeper 都有哪些功能？

159.zookeeper 有几种部署模式？

160.zookeeper 怎么保证主从节点的状态同步？

161.集群中为什么要有主节点？

162.集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？

163.说一下 zookeeper 的通知机制？

**十七、MySql**

164.数据库的三范式是什么？

165.一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？

166.如何获取当前数据库版本？

167.说一下 ACID 是什么？

168.char 和 varchar 的区别是什么？

169.float 和 double 的区别是什么？

170.mysql 的内连接、左连接、右连接有什么区别？

171.mysql 索引是怎么实现的？

172.怎么验证 mysql 的索引是否满足需求？

173.说一下数据库的事务隔离？

174.说一下 mysql 常用的引擎？

175.说一下 mysql 的行锁和表锁？

176.说一下乐观锁和悲观锁？

177.mysql 问题排查都有哪些手段？

178.如何做 mysql 的性能优化？

**十八、Redis**

179.redis 是什么？都有哪些使用场景？

180.redis 有哪些功能？

181.redis 和 memecache 有什么区别？

182.redis 为什么是单线程的？

183.什么是缓存穿透？怎么解决？

184.redis 支持的数据类型有哪些？

185.redis 支持的 java 客户端都有哪些？

186.jedis 和 redisson 有哪些区别？

187.怎么保证缓存和数据库数据的一致性？

188.redis 持久化有几种方式？

189.redis 怎么实现分布式锁？

190.redis 分布式锁有什么缺陷？

191.redis 如何做内存优化？

192.redis 淘汰策略有哪些？

193.redis 常见的性能问题有哪些？该如何解决？

**十九、JVM**

194.说一下 jvm 的主要组成部分？及其作用？

195.说一下 jvm 运行时数据区？

196.说一下堆栈的区别？

197.队列和栈是什么？有什么区别？

198.什么是双亲委派模型？

199.说一下类加载的执行过程？

200.怎么判断对象是否可以被回收？

201.java 中都有哪些引用类型？

202.说一下 jvm 有哪些垃圾回收算法？

203.说一下 jvm 有哪些垃圾回收器？

204.详细介绍一下 CMS 垃圾回收器？

205.新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？

206.简述分代垃圾回收器是怎么工作的？

207.说一下 jvm 调优的工具？

208.常用的 jvm 调优的参数都有哪些？



----

这里的大部分题目我都被问到过，一部分来源网上的面试，一部分来源自己的总结，如果有问题欢迎评论区讨论下～希望可以帮助到师弟师妹们

整理了一些之前本人或者同学面试被问到的问题~~

**1. java基础以及多个“比较”**

1.**Collections.sort排序内部原理**

在Java 6中Arrays.sort()和Collections.sort()使用的是MergeSort，而在Java 7中，内部实现换成了[TimSort](https://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/Timsort)，其对对象间比较的实现要求更加严格

**2.hashMap原理，java8做的改变**

从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的。HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全。ConcurrentHashMap线程安全。解决碰撞：当出现冲突时，运用拉链法，将关键词为同义词的结点链接在一个单链表中，散列表长m，则定义一个由m个头指针组成的指针数组T，地址为i的结点插入以T(i)为头指针的单链表中。Java8中，冲突的元素超过限制（8），用红黑树替换链表。

**3.String 和 StringBuilder 的区别**

1）可变与不可变：String不可变，每一次执行“+”都会新生成一个新对象，所以频繁改变字符串的情况中不用String，以节省内存。

2）是否多线程安全：StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。StringBuffer和String均线程安全。

**4.Vector 与 Array 的区别**

1）ArrayList在内存不够时默认是扩展50% + 1个，Vector是默认扩展1倍。

2）Vector属于线程安全级别的，但是大多数情况下不使用Vector，因为线程安全需要更大的系统开销。

**5.HashMap 与 Hashtable 的区别**

1） 历史原因: Hashtable继承Dictonary类, HashMap继承自abstractMap

2） HashMap允许空的键值对, 但最多只有一个空对象，而HashTable不允许。

3） HashTable同步，而HashMap非同步，效率上比HashTable要高

**6.ConncurrentHashMap和hashtable比较**，**两个线程并发访问map中同一条链，一个线程在尾部删除，一个线程在前面遍历查找，问为什么前面的线程还能正确的查找到后面被另一个线程删除的节点**）

ConcurrentHashMap融合了hashtable和hashmap二者的优势。hashtable是做了同步的，即线程安全，hashmap未考虑同步。所以hashmap在单线程情况下效率较高。hashtable在的多线程情况下，同步操作能保证程序执行的正确性。但是hashtable是阻塞的，每次同步执行的时候都要锁住整个结构，ConcurrentHashMap正是为了解决这个问题而诞生的，

ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术（一个Array保存多个Object，使用这些对象的锁作为分离锁，get/put时随机使用任意一个）。它使用了多个锁来控制对hash表的不同部分进行的修改。在JDK 1.6中，有HashEntry结构存在，每次插入将新添加节点作为链的头节点（同HashMap实现），而且每次删除一个节点时，会将删除节点之前的所有节点拷贝一份组成一个新的链，而将当前节点的上一个节点的next指向当前节点的下一个节点，从而在删除以后有两条链存 在，因而可以保证即使在同一条链中，有一个线程在删除，而另一个线程在遍历，它们都能工作良好，因为遍历的线程能继续使用原有的链。

Java8中，采用volatile HashEntry保存数据，table元素作为锁；从table数组+单向链表加上了红黑树。红黑树是一种特别的二叉查找树，特性为：1.节点为红或者黑 2.根节点为黑 3.叶节点为黑 4.一节点为红，则叶节点为黑 5.一节点到其子孙节点所有路径上的黑节点数目相同。

**7.ArrayList
与 LinkedList 的区别？**

最明显的区别是
ArrrayList 底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构书链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。LinkedList是双向链表

**8.Java 中，Comparator 与
Comparable 有什么不同？**

Comparable 接口用于定义对象的自然顺序，是排序接口，而 comparator 通常用于定义用户定制的顺序，是比较接口。我们如果需要控制某个类的次序，而该类本身不支持排序(即没有实现Comparable接口)，那么我们就可以建立一个“该类的比较器”来进行排序。Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。

**9.抽象类是什么？它与接口有什么区别？你为什么要使用过抽象类？**

抽象类是指不允许被实例化的类；一个类只能使用一次继承关系。但是，一个类却可以实现多个interface。

abstract class和interface所反映出的设计理念不同。其实abstract class表示的是"is-a"关系，interface表示的是"like-a"关系

实现抽象类和接口的类必须实现其中的所有方法。抽象类中可以有非抽象方法。接口中则不能有实现方法。但在Java8中允许接口中有静态默认的方法。

```text
接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值。抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以重新赋值。
子类中实现父类中的抽象方法时，可见性可以大于等于父类中的；而接口实现类中的接口 方法的可见性只能与接口中相同（public）。
```

用抽象类是为了重用。减少编码量，降低耦合性。

**10.描述 Java 中的重载和重写？**

重载和重写都允许你用相同的名称来实现不同的功能，但是重载是编译时活动，而重写是运行时活动。你可以在同一个类中重载方法，但是只能在子类中重写方法。重写必须要有继承

**重写：**1、在子类中可以根据需要对从基类中继承来的方法进行重写。2、重写的方法和被重写的方法必须具有相同方法名称、参数列表和返回类型。3、重写方法不能使用比被重写的方法更严格的访问权限。

**重载**的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。

**11.
Collection与Collections的区别是什么？**

Collection<E>是Java集合框架中的基本接口；

Collections是Java集合框架提供的一个工具类，其中包含了大量用于操作或返回集合的静态方法。

**12.
Java中多态的实现原理**

所谓多态，指的就是父类引用指向子类对象，调用方法时会调用子类的实现而不是父类的实现。多态的实现的关键在于“动态绑定”。

**13.
object中定义了哪些方法？**

clone(), equals(), hashCode(), toString(), notify(), notifyAll(),
wait(), finalize(), getClass()

**14. Java泛型和类型擦除**

泛型即参数化类型，在创建集合时，指定集合元素的类型，此集合只能传入该类型的参数。类型擦除：java编译器生成的字节码不包含泛型信息，所以在编译时擦除：1.泛型用最顶级父类替换；2.移除。

**15.说出 5 个 JDK 1.8 引入的新特性？**

Java 8 在 Java 历史上是一个开创新的版本，下面 JDK 8 中 5 个主要的特性：
Lambda 表达式；允许像对象一样传递匿名函数 Stream API，充分利用现代多核 CPU，可以写出很简洁的代码 ；Date 与 Time API，最终，有一个稳定、简单的日期和时间库可供你使用 扩展方法，现在，接口中可以有静态、默认方法； 重复注解，现在你可以将相同的注解在同一类型上使用多次。

**16.java中public，private，protected以及默认关键字的访问范围：**

Protected可在包内及包外子类访问，default只能同一包内访问，prvate只能同一类

**17. 常用数据结构：**

集合，线性结构（数组，队列，链表和栈），树形结构，图状结构

**18.Java 中的 TreeMap 是采用什么树实现的？(答案)**

Java 中的 TreeMap 是使用红黑树实现的。

**19. 匿名内部类是什么？如何访问在其外面定义的变量？**

匿名内部类也就是没有名字的内部类，匿名内部类只能使用一次，它通常用来简化代码编写。

匿名内部类只能访问外部类的Final变量. Java 8更加智能：如果局部变量被匿名内部类访问，那么该局部变量相当于自动使用了final修饰。

**20. 如何创建单例模式？说了双重检查，他说不是线程安全的。如何高效的创建一个线程安全的单例？**

一种是通过枚举，一种是通过静态内部类。

**21.poll() 方法和 remove() 方法的区别？**

poll() 和
remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。

**22.写一段代码在遍历 ArrayList 时移除一个元素**

**使用迭代器**。

Iterator itr = list.iterator();

while(itr.hasNext()) {if(...) { itr.remove();} }



**2. JVM**



**1.JVM如何加载一个类的过程，双亲委派模型中有哪些方法**

类加载过程：加载、验证（验证阶段作用是保证Class文件的字节流包含的信息符合JVM规范，不会给JVM造成危害）、准备（准备阶段为变量分配内存并设置类变量的初始化）、解析（解析过程是将常量池内的符号引用替换成直接引用）、初始化。

**双亲委派模型中方法：**双亲委派是指如果一个类收到了类加载的请求，不会自己先尝试加载，先找父类加载器去完成。当顶层启动类加载器表示无法加载这个类的时候，子类才会尝试自己去加载。当回到最开的发起者加载器还无法加载时，并不会向下找，而是抛出ClassNotFound异常。

方法：启动（Bootstrap）类加载器，标准扩展（Extension）类加载器，应用程序类加载器（Application ），上下文(Custom)类加载器。意义是防止内存中出现多份同样的字节码 。

**2.GC算法（什么样的对象算是可回收对象，可达性分析），CMS收集器**

jvm是如何判断一个对象已经变成了可回收的“垃圾”，一般是两个方法：引用记数法和根搜索算法。引用记数法没办法解决循环引用的问题，所以用根搜索。从一系列的”GC Roots“对象开始向下搜索，搜索走过的路径称为引用链。当一个对象到”GC Roots“之间没有引用链时，被称为引用不可达。引用不可到的对象被认为是可回收的对象。

```text
         几种垃圾收集器：1，Serial New/Serial Old(串行)，2，Parrallel New (并行)，3，Parrallel Scavenge，4，Parrallel Old，5，CMS（CMS收集器是一个以获得最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是Mark-sweep算法。），6，G1（是一款并行与并发收集器，并且可建立可预测的停顿时间模型，整体上是基于标记清理，局部采用复制）
```

**3.JVM分为哪些区，每一个区干吗的？**

1）方法区(method)：被所有的线程共享。方法区包含所有的类信息和静态变量。

2）堆(heap)：被所有的线程共享，存放对象实例以及数组，Java堆是GC的主要区域。

3）栈(stack)：每个线程包含一个栈区，栈中保存一些局部变量等。

4）程序计数器：是当前线程执行的字节码的行指示器。

**4.JVM新生代，老年代，持久代，都存储哪些东西？**

持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。所有新生成的对象首先都是放在年轻代的，年老代中存放的都是一些生命周期较长的对象。

**5.内存溢出和内存泄漏：**

内存溢出：程序申请内存时，没有足够的内存，out of memory；内存泄漏值垃圾对象无法回收，可以使用memory analyzer工具查看泄漏。

**6.进程与线程：**

进程值运行中的程序（独立性，动态性，并发性），线程指进程中的顺序执行流。区别是：1.进程间不共享内存 2.创建进程进行资源分配的代价要大得多，所以多线程在高并发环境中效率高。

**7.序列化与反序列化：**

序列化指将java对象转化为字节序列，反序列化相反。主要是为了java线程间通讯，实现对象传递。只有实现了Serializable或Externalizable接口类对象才可被序列化。

**8.64 位 JVM 中，int 的长度是多数？**

Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。

**9.Java 中 WeakReference 与 SoftReference的区别？**

Java中一共有四种类型的引用。StrongReference、 SoftReference、 WeakReference 以及 PhantomReference。

StrongReference 是 Java 的默认引用实现, 它会尽可能长时间的存活于 JVM 内，当没有任何对象指向它时将会被GC回收

WeakReference，顾名思义, 是一个弱引用, 当所引用的对象在
JVM 内不再有强引用时, 将被GC回收

虽然 WeakReference 与 SoftReference 都有利于提高 GC 和 内存的效率，但是 WeakReference ，一旦失去最后一个强引用，就会被 GC 回收，而 SoftReference 会尽可能长的保留引用直到 JVM 内存不足时才会被回收(虚拟机保证), 这一特性使得
SoftReference 非常适合缓存应用

**10.解释 Java 堆空间及 GC？**

当通过 Java 命令启动
Java 进程的时候，会为它分配内存。内存的一部分用于创建堆空间，当程序中创建对象的时候，就从对空间中分配内存。GC 是 JVM 内部的一个进程，回收无效对象的内存用于将来的分配。

**11.Java 中堆和栈有什么区别？**

JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。

**3. 并发，锁**



**1.volatile关键字， Lock**

并发编程中：原子性问题，可见性问题，有序性问题。

volatile关键字能保证可见性，字能禁止指令重排序，但是不能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。在生成的会变语句中加入Lock关键字和内存屏障。

Lock 实现提供了比使用synchronized 方法和语句可获得的更广泛的锁定操作，它能以更优雅的方式处理线程同步问题。用sychronized修饰的方法或者语句块在代码执行完之后锁自动释放，而用Lock需要我们手动释放锁

**2.MYSQL常用优化（sql优化，表结构优化等）**

SQL优化、表机构优化、索引优化、缓存参数优化

**3.java每改一点都需要重新编译打包部署，有没有更好的方法**

可以使用热加载

**4.进程间通信有哪几种方式？**

1）管道（Pipe），2）命名管道（named pipe），3）信号（Signal），4）消息（Message）队列，5）共享内存，6）内存映射（mapped memory），7）信号量（semaphore），8）套接口（Socket）

**5.Sychronized修饰静态方法，锁定类本身而不是实例，非静态方法锁定实例。**

**6. 操作系统什么情况下会死锁？**

所谓死锁：是指多个进程在运行过程中因争夺资源而造成的一种僵局。产生的原因：竞争资源：当系统中多个进程使用共享资源，并且资源不足以满足需要，会引起进程对资源的竞争而产生死锁。进程间推进的顺序非法：请求和释放资源的顺序不当，也同样会导致产生进程死锁

**7.产生死锁的四个条件：**

1.互斥条件（进程独占资源）2.请求与保持（进程因请求资源而阻塞时，对已获得的资源保持不放） 3.不剥夺条件（进程已获得的资源，在末使用完之前，不能强行剥夺） 4.循环等待（若干进程之间形成一种头尾相接的循环等待资源关系）

**8. 如何理解分布式锁？**

由于在平时的工作中，线上服务器是分布式多台部署的，经常会面临解决分布式场景下数据一致性的问题，那么就要利用分布式锁来解决这些问题。

**9. 线程同步与阻塞的关系？同步一定阻塞吗？阻塞一定同步吗？**

线程同步与否 跟 阻塞非阻塞没关系，同步是个过程，阻塞是线程的一种状态。多个线程操作共享变量时可能会出现竞争。这时需要同步来防止两个以上的线程同时进入临界区内，在这个过程中后进入临界区的线程将阻塞，等待先进入的线程走出临界区。

**10. 同步和异步有什么区别？**

同步和异步最大的区别就在于。一个需要等待，一个不需要等待。同步可以避免出现死锁，读脏数据的发生，一般共享某一资源的时候用，如果每个人都有修改权限，同时修改一个文件，有可能使一个人读取另一个人已经删除的内容，就会出错，同步就会按顺序来修改。

**11. 线程池**

根据系统自身的环境情况，有效的限制执行线程的数量，使得运行效果达到最佳。线程主要是通过控制执行的线程的数量，超出数量的线程排队等候，等待有任务执行完毕，再从队列最前面取出任务执行

**12. 如何调用 wait（）方法？使用 if 块还是循环？为什么？**

wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。

wait()，notify（）和notifyall（）方法是java.lang.Object类为线程提供的用于实现线程间通信的同步控制方法。等待或者唤醒

**13. 实现线程的几种方法**

(1)继承Thread类，重写run函数 (2)实现Runnable接口，重写run函数 (3)实现Callable接口，重写call函数

**14. 什么是多线程环境下的伪共享（false
sharing）？**

伪共享是多线程系统（每个处理器有自己的局部缓存）中一个众所周知的性能问题。缓存系统中是以缓存行（cache line）为单位存储的。缓存行是2的整数幂个连续字节，一般为32-256个字节。最常见的缓存行大小是64个字节。当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。



**4. 网络、数据库**



**1.TCP如何保证可靠传输？三次握手过程？**

在TCP的连接中，数据流必须以正确的顺序送达对方。TCP的可靠性是通过顺序编号和确认（ACK）来实现的。TCP 连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。第一次是客户端发起连接；第二次表示服务器收到了客户端的请求；第三次表示客户端收到了服务器的反馈。

**2. Linux下你常用的命令有哪些？**

```text
                 1. cd命令用来改变所在目录。cd /  转到根目录中cd ~  转到用户目录下 
                 2. ls命令用来查看目录的内容。
                 3. cp命令用来拷贝文件cp <source filename> <target filename>
                 4.mv命令 mv t.txt Document    把文件t.txt 移动到目录Document中。 
```

**3. 常用的hash算法有哪些？**

1.加法hash：所谓的加法Hash就是把输入元素一个一个的加起来构成最后的结果。

2.位运算hash：这类型Hash函数通过利用各种位运算（常见的是移位和异或）来充分的混合输入元素

3.乘法hash：33*hash + key.charAt(i)

**4. 什么是一致性哈希？**

设计目标是为了解决因特网中的热点(Hot spot)问题，一致性hash算法提出了在动态变化的Cache环境中，判定哈希算法好坏的四个定义：1、平衡性(Balance) 2、单调性(Monotonicity) 3、分散性(Spread) 4、负载(Load)

**5. 数据库中的范式有哪些？**

第一范式----数据库中的表(所有字段值)都是不可分割的原子数据项。

第二范式----数据库表中的每一列都和主键相关，而不能只和主键的某一部分相关。

第三范式----数据库表中每一列数据都和主键直接相关，不能间接相关。范式是为了减小数据冗余。

**6. 数据库中的索引的结构？什么情况下适合建索引？**

数据库中索引的结构是一种排序的数据结构，数据库索引是通过B树和变形的B+树实现的。什么情况下不适合建立索引：1.对于在查询过程中很少使用或参考的列；对于那些只有很少数据值的列；对于那些定义为image，text和bit数据类型的列；当修改性能远大于检索性能。

根据系统自身的环境情况，有效的限制执行线程的数量，使得运行效果达到最佳。线程主要是通过控制执行的线程的数量，超出数量的线程排队等候，等待有任务执行完毕，再从队列最前面取出任务执行

**7. concurrent包下面，都用过什么？**

java.util.concurrent、java.util.concurrent.atomic和java.util.concurrent.lock

**8. 常用的数据库有哪些？redis用过吗？**

Orcale，MySQL，DB2

**9. 你知道的开源协议有哪些？**

GPL （GNU General Public License） ：GNU通用公共许可协议

LGPL （GNU Lesser General Public License） ：GNU宽通用公共许可协议

BSD
(Berkeley Software Distribution) :伯克利软件分发许可协议

MIT （Massachusetts Institute of Technology）：MIT之名源自麻省理工学院

Apache （Apache License） ：Apache许可协议

MPL （Mozilla Public License） ：Mozilla公共许可协议

**10.表单提交中，get和post区别**

1.get从服务器获取信息，post向服务器传信息 2.get传送数据量比较小，post可以比较大 3.get安全性比较低

**11. TCP 协议与 UDP 协议有什么区别？(answer答案)**

TCP（Tranfer Control Protocol）的缩写，是一种面向连接的保证传输的协议，在传输数据流前，双方会先建立一条虚拟的通信道。可以很少差错传输数据。


UDP(User DataGram Protocol)的缩写，是一种无连接的协议，使用UDP传输数据时，每个数据段都是一个独立的信息，包括完整的源地址和目的地，在网络上以任何可能的 路径传到目的地，因此，能否到达目的地，以及到达目的地的时间和内容的完整性都不能保证。

所以TCP必UDP多了建立连接的时间。相对UDP而言，TCP具有更高的安全性和可靠性。

TCP协议传输的大小不限制，一旦连接被建立，双方可以按照一定的格式传输大量的数据，而UDP是一个不可靠的协议，大小有限制，每次不能超过64K。





---

让我们开始吧。

### **说说进程和线程的区别？**

进程是程序的一次执行，是系统进行资源分配和调度的独立单位，他的作用是是程序能够并发执行提高资源利用率和吞吐率。

由于进程是资源分配和调度的基本单位，因为进程的创建、销毁、切换产生大量的时间和空间的开销，进程的数量不能太多，而线程是比进程更小的能独立运行的基本单位，他是进程的一个实体，可以减少程序并发执行时的时间和空间开销，使得操作系统具有更好的并发性。

线程基本不拥有系统资源，只有一些运行时必不可少的资源，比如程序计数器、寄存器和栈，进程则占有堆、栈。

### **知道synchronized原理吗？**

synchronized是java提供的原子性内置锁，这种内置的并且使用者看不到的锁也被称为**监视器锁**，使用synchronized之后，会在编译之后在同步的代码块前后加上monitorenter和monitorexit字节码指令，他依赖操作系统底层互斥锁实现。他的作用主要就是实现原子性操作和解决共享变量的内存可见性问题。

执行monitorenter指令时会尝试获取对象锁，如果对象没有被锁定或者已经获得了锁，锁的计数器+1。此时其他竞争锁的线程则会进入等待队列中。

执行monitorexit指令时则会把计数器-1，当计数器值为0时，则锁释放，处于等待队列中的线程再继续竞争锁。

synchronized是排它锁，当一个线程获得锁之后，其他线程必须等待该线程释放锁后才能获得锁，而且由于Java中的线程和操作系统原生线程是一一对应的，线程被阻塞或者唤醒时时会从用户态切换到内核态，这种转换非常消耗性能。

从内存语义来说，加锁的过程会清除工作内存中的共享变量，再从主内存读取，而释放锁的过程则是将工作内存中的共享变量写回主内存。

*实际上大部分时候我认为说到monitorenter就行了，但是为了更清楚的描述，还是再具体一点*。

如果再深入到源码来说，synchronized实际上有两个队列waitSet和entryList。

1. 当多个线程进入同步代码块时，首先进入entryList
2. 有一个线程获取到monitor锁后，就赋值给当前线程，并且计数器+1
3. 如果线程调用wait方法，将释放锁，当前线程置为null，计数器-1，同时进入waitSet等待被唤醒，调用notify或者notifyAll之后又会进入entryList竞争锁
4. 如果线程执行完毕，同样释放锁，计数器-1，当前线程置为null

![img](https://pic1.zhimg.com/v2-9cb535d55d21dfe67c629f768df50883_r.jpg?source=1940ef5c)

### **那锁的优化机制了解吗？**

从JDK1.6版本之后，synchronized本身也在不断优化锁的机制，有些情况下他并不会是一个很重量级的锁了。优化机制包括自适应锁、自旋锁、锁消除、锁粗化、轻量级锁和偏向锁。

锁的状态从低到高依次为**无锁->偏向锁->轻量级锁->重量级锁**，升级的过程就是从低到高，降级在一定条件也是有可能发生的。

**自旋锁**：由于大部分时候，锁被占用的时间很短，共享变量的锁定时间也很短，所有没有必要挂起线程，用户态和内核态的来回上下文切换严重影响性能。自旋的概念就是让线程执行一个忙循环，可以理解为就是啥也不干，防止从用户态转入内核态，自旋锁可以通过设置-XX:+UseSpining来开启，自旋的默认次数是10次，可以使用-XX:PreBlockSpin设置。

**自适应锁**：自适应锁就是自适应的自旋锁，自旋的时间不是固定时间，而是由前一次在同一个锁上的自旋时间和锁的持有者状态来决定。

**锁消除**：锁消除指的是JVM检测到一些同步的代码块，完全不存在数据竞争的场景，也就是不需要加锁，就会进行锁消除。

**锁粗化**：锁粗化指的是有很多操作都是对同一个对象进行加锁，就会把锁的同步范围扩展到整个操作序列之外。

**偏向锁**：当线程访问同步块获取锁时，会在对象头和栈帧中的锁记录里存储偏向锁的线程ID，之后这个线程再次进入同步块时都不需要CAS来加锁和解锁了，偏向锁会永远偏向第一个获得锁的线程，如果后续没有其他线程获得过这个锁，持有锁的线程就永远不需要进行同步，反之，当有其他线程竞争偏向锁时，持有偏向锁的线程就会释放偏向锁。可以用过设置-XX:+UseBiasedLocking开启偏向锁。

**轻量级锁**：JVM的对象的对象头中包含有一些锁的标志位，代码进入同步块的时候，JVM将会使用CAS方式来尝试获取锁，如果更新成功则会把对象头中的状态位标记为轻量级锁，如果更新失败，当前线程就尝试自旋来获得锁。

整个锁升级的过程非常复杂，我尽力去除一些无用的环节，简单来描述整个升级的机制。

简单点说，偏向锁就是通过对象头的偏向线程ID来对比，甚至都不需要CAS了，而轻量级锁主要就是通过CAS修改对象头锁记录和自旋来实现，重量级锁则是除了拥有锁的线程其他全部阻塞。

![img](https://pic1.zhimg.com/v2-a04036ccc8906893955e06a47e97d38b_r.jpg?source=1940ef5c)

### **那对象头具体都包含哪些内容？**

在我们常用的Hotspot虚拟机中，对象在内存中布局实际包含3个部分：

1. 对象头
2. 实例数据
3. 对齐填充

而对象头包含两部分内容，Mark Word中的内容会随着锁标志位而发生变化，所以只说存储结构就好了。

1. 对象自身运行时所需的数据，也被称为Mark Word，也就是用于轻量级锁和偏向锁的关键点。具体的内容包含对象的hashcode、分代年龄、轻量级锁指针、重量级锁指针、GC标记、偏向锁线程ID、偏向锁时间戳。
2. 存储类型指针，也就是指向类的元数据的指针，通过这个指针才能确定对象是属于哪个类的实例。

*如果是数组的话，则还包含了数组的长度*

![img](https://pic2.zhimg.com/v2-bb7e2989c375f870122a61fcf8b9cf79_r.jpg?source=1940ef5c)

### **对于加锁，那再说下ReentrantLock原理？他和synchronized有什么区别？**

相比于synchronized，ReentrantLock需要显式的获取锁和释放锁，相对现在基本都是用JDK7和JDK8的版本，ReentrantLock的效率和synchronized区别基本可以持平了。他们的主要区别有以下几点：

1. 等待可中断，当持有锁的线程长时间不释放锁的时候，等待中的线程可以选择放弃等待，转而处理其他的任务。
2. 公平锁：synchronized和ReentrantLock默认都是非公平锁，但是ReentrantLock可以通过构造函数传参改变。只不过使用公平锁的话会导致性能急剧下降。
3. 绑定多个条件：ReentrantLock可以同时绑定多个Condition条件对象。

ReentrantLock基于AQS(**AbstractQueuedSynchronizer 抽象队列同步器**)实现。别说了，我知道问题了，AQS原理我来讲。

AQS内部维护一个state状态位，尝试加锁的时候通过CAS(CompareAndSwap)修改值，如果成功设置为1，并且把当前线程ID赋值，则代表加锁成功，一旦获取到锁，其他的线程将会被阻塞进入阻塞队列自旋，获得锁的线程释放锁的时候将会唤醒阻塞队列中的线程，释放锁的时候则会把state重新置为0，同时当前线程ID置为空。

![img](https://pic4.zhimg.com/v2-b4ff47cd91144a6c0301511312bb72ff_r.jpg?source=1940ef5c)

### **CAS的原理呢？**

CAS叫做CompareAndSwap，比较并交换，主要是通过处理器的指令来保证操作的原子性，它包含三个操作数：

1. 变量内存地址，V表示
2. 旧的预期值，A表示
3. 准备设置的新值，B表示

当执行CAS指令时，只有当V等于A时，才会用B去更新V的值，否则就不会执行更新操作。

### **那么CAS有什么缺点吗？**

CAS的缺点主要有3点：

**ABA问题**：ABA的问题指的是在CAS更新的过程中，当读取到的值是A，然后准备赋值的时候仍然是A，但是实际上有可能A的值被改成了B，然后又被改回了A，这个CAS更新的漏洞就叫做ABA。只是ABA的问题大部分场景下都不影响并发的最终效果。

Java中有AtomicStampedReference来解决这个问题，他加入了预期标志和更新后标志两个字段，更新时不光检查值，还要检查当前的标志是否等于预期标志，全部相等的话才会更新。

**循环时间长开销大**：自旋CAS的方式如果长时间不成功，会给CPU带来很大的开销。

**只能保证一个共享变量的原子操作**：只对一个共享变量操作可以保证原子性，但是多个则不行，多个可以通过AtomicReference来处理或者使用锁synchronized实现。

### **好，说说HashMap原理吧？**

HashMap主要由数组和链表组成，他不是线程安全的。核心的点就是put插入数据的过程，get查询数据以及扩容的方式。JDK1.7和1.8的主要区别在于头插和尾插方式的修改，头插容易导致HashMap链表死循环，并且1.8之后加入红黑树对性能有提升。

**put插入数据流程**

往map插入元素的时候首先通过对key hash然后与数组长度-1进行与运算((n-1)&hash)，都是2的次幂所以等同于取模，但是位运算的效率更高。找到数组中的位置之后，如果数组中没有元素直接存入，反之则判断key是否相同，key相同就覆盖，否则就会插入到链表的尾部，如果链表的长度超过8，则会转换成红黑树，最后判断数组长度是否超过默认的长度*负载因子也就是12，超过则进行扩容。

![img](https://pic1.zhimg.com/v2-f441cfcab32180cb06cc3a4bdbc16900_r.jpg?source=1940ef5c)

**get查询数据**

查询数据相对来说就比较简单了，首先计算出hash值，然后去数组查询，是红黑树就去红黑树查，链表就遍历链表查询就可以了。

**resize扩容过程**

扩容的过程就是对key重新计算hash，然后把数据拷贝到新的数组。

### **那多线程环境怎么使用Map呢？ConcurrentHashmap了解过吗？**

多线程环境可以使用Collections.synchronizedMap同步加锁的方式，还可以使用HashTable，但是同步的方式显然性能不达标，而ConurrentHashMap更适合高并发场景使用。

ConcurrentHashmap在JDK1.7和1.8的版本改动比较大，1.7使用Segment+HashEntry分段锁的方式实现，1.8则抛弃了Segment，改为使用CAS+synchronized+Node实现，同样也加入了红黑树，避免链表过长导致性能的问题。

**1.7分段锁**

从结构上说，1.7版本的ConcurrentHashMap采用分段锁机制，里面包含一个Segment数组，Segment继承与ReentrantLock，Segment则包含HashEntry的数组，HashEntry本身就是一个链表的结构，具有保存key、value的能力能指向下一个节点的指针。

实际上就是相当于每个Segment都是一个HashMap，默认的Segment长度是16，也就是支持16个线程的并发写，Segment之间相互不会受到影响。

![img](https://pic1.zhimg.com/v2-be077914a69cff759444a713e3384b1e_r.jpg?source=1940ef5c)

**put流程**

其实发现整个流程和HashMap非常类似，只不过是先定位到具体的Segment，然后通过ReentrantLock去操作而已，后面的流程我就简化了，因为和HashMap基本上是一样的。

1. 计算hash，定位到segment，segment如果是空就先初始化
2. 使用ReentrantLock加锁，如果获取锁失败则尝试自旋，自旋超过次数就阻塞获取，保证一定获取锁成功
3. 遍历HashEntry，就是和HashMap一样，数组中key和hash一样就直接替换，不存在就再插入链表，链表同样

![img](https://pic1.zhimg.com/v2-731ade899fc27f0ef88bc84c52c07bdb_r.jpg?source=1940ef5c)

**get流程**

get也很简单，key通过hash定位到segment，再遍历链表定位到具体的元素上，需要注意的是value是volatile的，所以get是不需要加锁的。

**1.8CAS+synchronized**

1.8抛弃分段锁，转为用CAS+synchronized来实现，同样HashEntry改为Node，也加入了红黑树的实现。主要还是看put的流程。

![img](https://pic1.zhimg.com/v2-71e0edc0ddd7cdfdbcf21a80584168fb_r.jpg?source=1940ef5c)

**put流程**

1. 首先计算hash，遍历node数组，如果node是空的话，就通过CAS+自旋的方式初始化
2. 如果当前数组位置是空则直接通过CAS自旋写入数据
3. 如果hash==MOVED，说明需要扩容，执行扩容
4. 如果都不满足，就使用synchronized写入数据，写入数据同样判断链表、红黑树，链表写入和HashMap的方式一样，key hash一样就覆盖，反之就尾插法，链表长度超过8就转换成红黑树

![img](https://pic1.zhimg.com/v2-19e6a0bde9ec6a4a22c4b1046e3d2d79_r.jpg?source=1940ef5c)

**get查询**

get很简单，通过key计算hash，如果key hash相同就返回，如果是红黑树按照红黑树获取，都不是就遍历链表获取。

### **volatile原理知道吗？**

相比synchronized的加锁方式来解决共享变量的内存可见性问题，volatile就是更轻量的选择，他没有上下文切换的额外开销成本。使用volatile声明的变量，可以确保值被更新的时候对其他线程立刻可见。volatile使用内存屏障来保证不会发生指令重排，解决了内存可见性的问题。

我们知道，线程都是从主内存中读取共享变量到工作内存来操作，完成之后再把结果写会主内存，但是这样就会带来可见性问题。举个例子，假设现在我们是两级缓存的双核CPU架构，包含L1、L2两级缓存。

1. 线程A首先获取变量X的值，由于最初两级缓存都是空，所以直接从主内存中读取X，假设X初始值为0，线程A读取之后把X值都修改为1，同时写回主内存。这时候缓存和主内存的情况如下图。

![img](https://pic2.zhimg.com/v2-5d13d1d458bcaa84af429a3fc7c9aef6_r.jpg?source=1940ef5c)

1. 线程B也同样读取变量X的值，由于L2缓存已经有缓存X=1，所以直接从L2缓存读取，之后线程B把X修改为2，同时写回L2和主内存。这时候的X值入下图所示。
   那么线程A如果再想获取变量X的值，因为L1缓存已经有x=1了，所以这时候变量内存不可见问题就产生了，B修改为2的值对A来说没有感知。

![img](https://pic2.zhimg.com/v2-38e8b03e3ef612411a9b384bd32de0c1_r.jpg?source=1940ef5c)

那么，如果X变量用volatile修饰的话，当线程A再次读取变量X的话，CPU就会根据缓存一致性协议强制线程A重新从主内存加载最新的值到自己的工作内存，而不是直接用缓存中的值。

再来说内存屏障的问题，volatile修饰之后会加入不同的内存屏障来保证可见性的问题能正确执行。这里写的屏障基于书中提供的内容，但是实际上由于CPU架构不同，重排序的策略不同，提供的内存屏障也不一样，比如x86平台上，只有StoreLoad一种内存屏障。

1. StoreStore屏障，保证上面的普通写不和volatile写发生重排序
2. StoreLoad屏障，保证volatile写与后面可能的volatile读写不发生重排序
3. LoadLoad屏障，禁止volatile读与后面的普通读重排序
4. LoadStore屏障，禁止volatile读和后面的普通写重排序

![img](https://pic1.zhimg.com/v2-bcac12c0945049a72b37fa1279b80ae2_r.jpg?source=1940ef5c)

### **那么说说你对JMM内存模型的理解？为什么需要JMM？**

本身随着CPU和内存的发展速度差异的问题，导致CPU的速度远快于内存，所以现在的CPU加入了高速缓存，高速缓存一般可以分为L1、L2、L3三级缓存。基于上面的例子我们知道了这导致了缓存一致性的问题，所以加入了缓存一致性协议，同时导致了内存可见性的问题，而编译器和CPU的重排序导致了原子性和有序性的问题，JMM内存模型正是对多线程操作下的一系列规范约束，因为不可能让陈雇员的代码去兼容所有的CPU，通过JMM我们才屏蔽了不同硬件和操作系统内存的访问差异，这样保证了Java程序在不同的平台下达到一致的内存访问效果，同时也是保证在高效并发的时候程序能够正确执行。

![img](https://pic1.zhimg.com/v2-3053e047b418aa1e2362d581c37ba224_r.jpg?source=1940ef5c)

**原子性**：Java内存模型通过read、load、assign、use、store、write来保证原子性操作，此外还有lock和unlock，直接对应着synchronized关键字的monitorenter和monitorexit字节码指令。

**可见性**：可见性的问题在上面的回答已经说过，Java保证可见性可以认为通过volatile、synchronized、final来实现。

**有序性**：由于处理器和编译器的重排序导致的有序性问题，Java通过volatile、synchronized来保证。

**happen-before规则**

虽然指令重排提高了并发的性能，但是Java虚拟机会对指令重排做出一些规则限制，并不能让所有的指令都随意的改变执行位置，主要有以下几点：

1. 单线程每个操作，happen-before于该线程中任意后续操作
2. volatile写happen-before与后续对这个变量的读
3. synchronized解锁happen-before后续对这个锁的加锁
4. final变量的写happen-before于final域对象的读，happen-before后续对final变量的读
5. 传递性规则，A先于B，B先于C，那么A一定先于C发生

### **说了半天，到底工作内存和主内存是什么？**

主内存可以认为就是物理内存，Java内存模型中实际就是虚拟机内存的一部分。而工作内存就是CPU缓存，他有可能是寄存器也有可能是L1\L2\L3缓存，都是有可能的。

### **说说ThreadLocal原理？**

ThreadLocal可以理解为线程本地变量，他会在每个线程都创建一个副本，那么在线程之间访问内部副本变量就行了，做到了线程之间互相隔离，相比于synchronized的做法是用空间来换时间。

ThreadLocal有一个静态内部类ThreadLocalMap，ThreadLocalMap又包含了一个Entry数组，Entry本身是一个弱引用，他的key是指向ThreadLocal的弱引用，Entry具备了保存key value键值对的能力。

弱引用的目的是为了防止内存泄露，如果是强引用那么ThreadLocal对象除非线程结束否则始终无法被回收，弱引用则会在下一次GC的时候被回收。

但是这样还是会存在内存泄露的问题，假如key和ThreadLocal对象被回收之后，entry中就存在key为null，但是value有值的entry对象，但是永远没办法被访问到，同样除非线程结束运行。

但是只要ThreadLocal使用恰当，在使用完之后调用remove方法删除Entry对象，实际上是不会出现这个问题的。

![img](https://pic3.zhimg.com/v2-e4e764bb5e8f3bf666ac73d3847ad80c_r.jpg?source=1940ef5c)

### **那引用类型有哪些？有什么区别？**

引用类型主要分为强软弱虚四种：

1. 强引用指的就是代码中普遍存在的赋值方式，比如A a = new A()这种。强引用关联的对象，永远不会被GC回收。
2. 软引用可以用SoftReference来描述，指的是那些有用但是不是必须要的对象。系统在发生内存溢出前会对这类引用的对象进行回收。
3. 弱引用可以用WeakReference来描述，他的强度比软引用更低一点，弱引用的对象下一次GC的时候一定会被回收，而不管内存是否足够。
4. 虚引用也被称作幻影引用，是最弱的引用关系，可以用PhantomReference来描述，他必须和ReferenceQueue一起使用，同样的当发生GC的时候，虚引用也会被回收。可以用虚引用来管理堆外内存。

### **线程池原理知道吗？**

首先线程池有几个核心的参数概念：

1. 最大线程数maximumPoolSize
2. 核心线程数corePoolSize
3. 活跃时间keepAliveTime
4. 阻塞队列workQueue
5. 拒绝策略RejectedExecutionHandler

当提交一个新任务到线程池时，具体的执行流程如下：

1. 当我们提交任务，线程池会根据corePoolSize大小创建若干任务数量线程执行任务
2. 当任务的数量超过corePoolSize数量，后续的任务将会进入阻塞队列阻塞排队
3. 当阻塞队列也满了之后，那么将会继续创建(maximumPoolSize-corePoolSize)个数量的线程来执行任务，如果任务处理完成，maximumPoolSize-corePoolSize额外创建的线程等待keepAliveTime之后被自动销毁
4. 如果达到maximumPoolSize，阻塞队列还是满的状态，那么将根据不同的拒绝策略对应处理

![img](https://pic1.zhimg.com/v2-fa9b1e08fff8730bcd0ad42a73feb129_r.jpg?source=1940ef5c)

### **拒绝策略有哪些？**

主要有4种拒绝策略：

1. AbortPolicy：直接丢弃任务，抛出异常，这是默认策略
2. CallerRunsPolicy：只用调用者所在的线程来处理任务
3. DiscardOldestPolicy：丢弃等待队列中最近的任务，并执行当前任务
4. DiscardPolicy：直接丢弃任务，也不抛出异常

---


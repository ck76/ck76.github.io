##### [字节顺序：高位优先(big-endian)和低位优先(little-endian)](https://www.cnblogs.com/dreign/p/3487956.html)

> 　　网络字节序: MSB 高字节前存法 Most Significant Bit  (Big Edian) 
>
> 　　主机字节序: LSB 低字节前存法 Lest Significant Bit (Little Edian) 

　　字节顺序是指占内存多于一个字节类型的数据在内存中的存放顺序，通常有小端、大端两种字节顺序。小端字节序指低字节数据存放在内存低地址处，高字节数据存放在内存高地址处；大端字节序是高字节数据存放在低地址处，低字节数据存放在高地址处。基于X86平台的PC机是小端字节序的（[原文参考](http://www.cppblog.com/aaxron/archive/2011/02/28/140786.html)）。在跨系统处理二进制数据流时，要注意这个问题。我就是在处理++服务端的BML（Binary Markup Language）二进制标记数据流时碰到了这个问题。

　　因为现行的计算机都是以八位一个字节为存储单位，那么一个16位的整数，也就是C语言中的short，在内存中可能有两种存储顺序big-endian和litte-endian。考虑一个short整数0x3132(0x32是低位，0x31是高位)，把它赋值给一个short变量，那么它在内存中的存储可能有两种不同的方式。

- https://www.jianshu.com/p/0ebdf779cab5

这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个`如何将多个字节安排`的问题。因此就导致了`大端存储模式`和`小端存储模式`。
  例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。

## **那什么是大端和小端呢？**

• Little-Endian：低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。示例数字0x12 34 56 78在内存中的表示形式：
  *内存  低地址 -----------------> 高地址*
  *0x78  |  0x56  |  0x34  |  0x12 \*
\*  低位子节 -----------------> 高位子节*

• Big-Endian：高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。示例数字0x12 34 56 78在内存中的表示形式：
  *内存  低地址 -----------------> 高地址*
      *0x12  |  0x34  |  0x56  |  0x78*
  *高位子节 -----------------> 低位子节*

可见，大端模式和字符串的存储模式类似。但是也有各自的特点：
 *• 小端模式 ：强制转换数据不需要调整字节内容，1、2、4字节的存储方式一样。
 • 大端模式 ：符号位的判定固定为第一个字节，容易判断正负。*

**则可以通过以下方式判断机器的子节序**



```objectivec
BOOL IsBigEndian()
{
    int a = 0x1234;//如果要存在至数组中，大端应为 arr[0] =a&0xff00 > 16= 0x12,arr[1]=a&0xff=0x34;
    char b =  *(char *)&a;  // 通过将int强制类型转换成char单字节，通过判断起始存储位置。即等于 取b等于a的低地址部分;
    if( b == 0x12)// 如果是大端模式，则a的低地址内存存放的应该是高位子节0x12
    {
        return TRUE;
    }
    return FALSE;
} 
```

或者 利用联合体union成员的存放顺序都是从低地址开始的特性来做判断。



```objectivec
BOOL IsBigEndian()
{
    union NUM
    {
        int a;
        char b;
    }num;
    num.a = 0x1234;
    if( num.b == 0x12 )
    {
        return TRUE;
    }
    return FALSE;
}
```

## 大小端转换示例



```cpp
//16位字节：
#define BigtoLittle16(A)   (( ((uint16)(A) & 0xff00) >> 8)    | \
                                       (( (uint16)(A) & 0x00ff) << 8))

//32位子节：
#define BigtoLittle32(A)   ((( (uint32)(A) & 0xff000000) >> 24) | \
                                       (( (uint32)(A) & 0x00ff0000) >> 8)   | \
                                       (( (uint32)(A) & 0x0000ff00) << 8)   | \

#define ntohs(n)     //16位数据类型网络字节顺序到主机字节顺序的转换
#define htons(n)     //16位数据类型主机字节顺序到网络字节顺序的转换
#define ntohl(n)      //32位数据类型网络字节顺序到主机字节顺序的转换
#define htonl(n)      //32位数据类型主机字节顺序到网络字节顺序的转换
```

## 借用一个 实际中的例子



```css
   虽然很多时候，字节序的工作已由编译器完成了，但是在一些小的细节上，仍然需要去仔细揣摩考虑，尤其是在以太网通讯、MODBUS通讯、软件移植性方面。这里，举一个MODBUS通讯的例子。在MODBUS中，数据需要组织成数据报文，该报文中的数据都是大端模式，即低地址存高位，高地址存低位。假设有一16位缓冲区m_RegMW[256]，因为是在x86平台上，所以内存中的数据为小端模式：m_RegMW[0].low、m_RegMW[0].high、m_RegMW[1].low、m_RegMW[1].high……
```

为了方便讨论，假设m_RegMW[0] = 0x3456; 在内存中为0x56、0x34。
 现要将该数据发出，如果不进行数据转换直接发送，此时发送的数据为0x56,0x34。而Modbus是大端的，会将该数据解释为0x5634而非原数据0x3456，此时就会发生灾难性的错误。所以，在此之前，需要将小端数据转换成大端的，即进行高字节和低字节的交换，此时可以调用步骤五中的函数BigtoLittle16(m_RegMW[0])，之后再进行发送才可以得到正确的数据。



作者：starmier
链接：https://www.jianshu.com/p/0ebdf779cab5
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
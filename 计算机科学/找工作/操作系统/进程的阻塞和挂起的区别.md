操作系统中挂起和阻塞的区别如下：
一：挂起是一种主动行为，因此恢bai复也应该要主动完成，而阻塞则是一种被动行为，是在等待事件或资源时任务的表现，你不知道他什么时候被阻塞(pend)，也就不能确切 的知道他什么时候恢复阻塞。而且挂起队列在操作系统里可以看成一个，而阻塞队列则是不同的事件或资源（如信号量）就有自己的队列；
二：阻塞（pend）就是任务释放CPU，其他任务可以运行，一般在等待某种资源或信号量的时候出现。挂起（suspend）不释放CPU，如果任务优先级高就永远轮不到其他任务运行，一般挂起用于程序调试中的条件中断，当出现某个条件的情况下挂起，然后进行单步调试；
三：pend是task主动去等一个事件,或消息.suspend是直接悬挂task,以后这个task和你没任何关系,任何task间的通信或者同步都和这个suspended task没任何关系了,除非你resume task;
四：任务调度是操作系统来实现的，任务调度时，直接忽略挂起状态的任务，但是会顾及处于pend下的任务，当pend下的任务等待的资源就绪后，就可以转为ready了。ready只需要等待CPU时间，当然，任务调度也占用开销，但是不大，可以忽略。可以这样理解，只要是挂起状态，操作系统就不在管理这个任务了；
五：挂起是主动的，一般需要用挂起函数进行操作，若没有resume的动作，则此任务一直不会ready。而阻塞是因为资源被其他任务抢占而处于休眠态。两者的表现方式都是从就绪态里“清掉”，即对应标志位清零，只不过实现方式不一样。



---

线程与进程的阻塞

   线程在运行的过程中因为某些原因而发生阻塞，阻塞状态的线程的特点是：**该线程放弃CPU的使用，暂停运行**，只有等到导致阻塞的原因消除之后才回复运行。或者是被其他的线程中断，该线程也会退出阻塞状态，同时抛出InterruptedException。

​    正在执行的进程由于发生某时间（如I/O请求、申请缓冲区失败等）暂时无法继续执行。此时引起进程调度，OS把处理机分配给另一个就绪进程，而让受阻进程处于暂停状态，一般将这种状态称为阻塞状态。

进程的挂起

   [挂起](http://baike.baidu.com/view/1451210.htm)进程在操作系统中可以定义为暂时被淘汰出内存的进程，机器的资源是有限的，在资源不足的情况下，操作系统对在内存中的程序进行合理的安排，其中有的进程被暂时调离出内存，当条件允许的时候，会被操作系统再次调回内存，重新进入等待被执行的状态即就绪态，系统在超过一定的时间没有任何动作

共同点： 
      \1. 进程都暂停执行 
      \2. 进程都释放CPU，即两个过程都会涉及上下文切换

不同点： 
      \1. 对系统资源占用不同：虽然都释放了CPU，但阻塞的进程仍处于内存中，而挂起的进程通过“对换”技术被换出到外存（磁盘）中。 
      \2. 发生时机不同：阻塞一般在进程等待资源（IO资源、信号量等）时发生；而挂起是由于用户和系统的需要，例如，终端用户需要暂停程序研究其执行情况或对其进行修改、OS为了提高内存利用率需要将暂时不能运行的进程（处于就绪或阻塞队列的进程）调出到磁盘 
      \3. 恢复时机不同：阻塞要在等待的资源得到满足（例如获得了锁）后，才会进入就绪状态，等待被调度而执行；被挂起的进程由将其挂起的对象（如用户、系统）在时机符合时（调试结束、被调度进程选中需要重新执行）将其主动激活
 

阻塞的原因：线程中的阻塞、Socket客户端的阻塞、Socket服务器端的阻塞。

一般线程中的阻塞：

​    A、线程执行了Thread.sleep(int millsecond);方法，当前线程放弃CPU，睡眠一段时间，然后再恢复执行

​    B、线程执行一段同步代码，但是尚且无法获得相关的同步锁，只能进入阻塞状态，等到获取了同步锁，才能回复执行。

​    C、线程执行了一个对象的wait()方法，直接进入阻塞状态，等待其他线程执行notify()或者notifyAll()方法。

​    D、线程执行某些IO操作，因为等待相关的资源而进入了阻塞状态。比如说监听system.in，但是尚且没有收到键盘的输入，则进入阻塞状态。

Socket客户端的阻塞：

​    A、请求与服务器连接时，调用connect方法，进入阻塞状态，直至连接成功。

​    B、当从Socket输入流读取数据时，在读取足够的数据之前会进入阻塞状态。比如说通过BufferedReader类使用readLine()方法时，在没有读出一行数据之前，数据量就不算是足够，会处在阻塞状态下。

​    C、调用Socket的setSoLinger()方法关闭了Socket延迟，当执行Socket的close方法时，会进入阻塞状态，知道底层Socket发送完所有的剩余数据

Socket服务器的阻塞：

​    A、线程执行ServerSocket的accept()方法，等待客户的连接，直到接收到客户的连接，才从accept方法中返回一个Socket对象

​    B、从Socket输入流读取数据时，如果输入流没有足够的数据，就会进入阻塞状态

​    D、线程向Socket的输出流写入一批数据，可能进入阻塞状态

​    当程序阻塞时，会降低程序的效率，于是人们就希望能引入非阻塞的操作方法。   

​    所谓非阻塞方法，就是指当线程执行这些方法时，如果操作还没有就绪，就立即返回，不会阻塞着等待操作就绪。Java.nio 提供了这些支持非阻塞通信的类。

**挂起的原因**

（1）终端用户的请求。当终端用户在自己的程序运行期间发现有可疑问题时，希望暂停使自己的程序静止下来。亦即，使正在执行的进程暂停执行；若此时用户进程正处于就绪状态而未执行，则该进程暂不接受调度，以便用户研究其执行情况或对程序进行修改。我们把这种静止状态成为“挂起状态”。

（2）父进程的请求。有时父进程希望挂起自己的某个子进程，以便考察和修改子进程，或者协调各子进程间的活动。
（3）负荷调节的需要。当实时系统中的工作负荷较重，已可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统能正常运行。
（4）操作系统的需要。操作系统有时希望挂起某些进程，以便检查运行中的资源使用情况或进行记账。
（5）对换的需要。为了缓和内存紧张的情况，将内存中处于阻塞状态的进程换至外存上。

操作系统中睡眠、阻塞、挂起的区别形象解释：


   首先这些术语都是对于线程来说的。对线程的控制就好比你控制了一个雇工为你干活。你对雇工的控制是通过编程来实现的。

   挂起线程的意思就是你对主动对雇工说：“你睡觉去吧，用着你的时候我主动去叫你，然后接着干活”。

   使线程睡眠的意思就是你主动对雇工说：“你睡觉去吧，某时某刻过来报到，然后接着干活”。

   线程阻塞的意思就是，你突然发现，你的雇工不知道在什么时候没经过你允许，自己睡觉了，但是你不能怪雇工，因为本来你让雇工扫地，结果扫帚被偷了或被邻居家借去了，你又没让雇工继续干别的活，他就只好睡觉了。至于扫帚回来后，雇工会不会知道，会不会继续干活，你不用担心，雇工一旦发现扫帚回来了，他就会自己去干活的。因为雇工受过良好的培训。这个培训机构就是操作系统。



https://blog.csdn.net/hqy1719239337/article/details/100543307



---

## 基本概念

- 创建状态：指进程因资源尚未满足，创建工作未完成，不能执行的状态
- 终止状态：指进程终止不再执行，系统删除该进程，将PCB清零，回收PCB
- 挂起操作：将进程从主存中移至外存中
- 激活操作：将进程从外存中移到内存中
- 活动就绪：指进程在内存中一旦获得处理器就可以执行的状态
- 静止就绪：指进程在外存中不能被直接调度的就绪状态，只有当主存中没有活跃就绪态进程，或者是挂起态进程具有更高的优先级，系统将把挂起就绪态进程调回主存并转换为活跃就绪。
- 活跃阻塞：指进程在内存中等待的事件发生的状态，一旦事件发生便进入活跃就绪状态。
- 静止阻塞：指进程因挂起操作在外存中等待事件发生的状态，一旦等待的事件产生，便进入静止就绪状态。
  ![在这里插入图片描述](https://tva1.sinaimg.cn/large/0081Kckwly1glk7xeyo5mj308704r0t0.jpg)

## 挂起和阻塞的区别？

- 挂起是一个**行为**，而阻塞是进程的一种**状态**
- 进程存放的**位置不同**：挂起是**将进程移到外存**中，而处于阻塞状态的进程还是在**内存**中
- 原因不同：导致进程被挂起的原因一般是**内存不足**或者是系统、用户的请求，协调、修改进程，研究进程的状态等，进程阻塞是进程正在**等待某一事件发生**，可能是等待资源或者响应等（eg.等待I/O完成等）而暂时停止运行
- 挂起对应的行为是**激活**，将外存中的进程调入内存中。而处于阻塞状态的进程需要其他进程或系统**唤醒**
- 挂起是**被动**的行为，进程被迫从内存中移至外存中。而进入阻塞可以看成是一个**主动**的行为（eg.进程I/O时，进程在等待I/O设备完成时，进程主动进入阻塞状态，I/O完成，进程被激活）

## 创建进程时内存不足，进程处于什么状态？

进程处于**创建态**或者**静止就绪态**。当进程完成创建，因内存不足及其他一些原因（系统或用户的请求）而移到外存中去，此时进程就处于**静止就绪状态**。如果进程创建过程中因内存不足（未初始化PCB），未完成进程的创建，此时则处于**创建状态**。关键在于此时的进程**是否完成创建**。


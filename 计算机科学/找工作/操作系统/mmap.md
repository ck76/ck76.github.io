##### 共享内存的原理

- https://blog.csdn.net/weixin_49298931/article/details/109275536
- https://www.cnblogs.com/linhaostudy/p/13467118.html

```
mmap将一个文件或者其它对象映射进内存。文件被映射到多个页上，如果文件的大小不是所有页的大小之和，最后一个页不被使用的空间将会清零。mmap在用户空间映射调用系统中作用很大。
```

内存，外存，虚拟内存，物理内存，高速缓存。

举例一些I/O操作的例子
操作系统是如何快加IO读写的
异步IO是如何现实的

# mmap基础概念

mmap, 函数名为memory map, 即地址的映射, 是一种内存映射文件的方法,将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。如下图所示：
![在这里插入图片描述](https://tva1.sinaimg.cn/large/0081Kckwly1glokttk3tkj30k60b2ac6.jpg)
由上图可以看出，进程的虚拟地址空间，由多个虚拟内存区域构成。虚拟内存区域是进程的虚拟地址空间中的一个同质区间，即具有同样特性的连续地址范围。上图中所示的text数据段（代码段）、初始数据段、BSS数据段、堆、栈和内存映射，都是一个独立的虚拟内存区域。而为内存映射服务的地址空间处在堆栈之间的空余部分。

linux内核使用**vm_area_struct**结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个**vm_area_struct**结构来分别表示不同类型的虚拟内存区域。各个**vm_area_struct**结构使用链表或者树形结构链接，方便进程快速访问，如下图所示：
![在这里插入图片描述](https://tva1.sinaimg.cn/large/0081Kckwly1gloktroryyj30ia0czgmk.jpg)
**vm_area_struct**结构中包含区域起始和终止地址以及其他相关信息，同时也包含一个vm_ops指针，其内部可引出所有针对这个区域可以使用的系统调用函数。这样，进程对某一虚拟内存区域的任何操作需要用要的信息，都可以从vm_area_struct中获得。mmap函数就是要创建一个新的vm_area_struct结构，并将其与文件的物理磁盘地址相连。

# mmap内存映射原理

mmap内存映射的实现过程，总的来说可以分为三个阶段：

（一）进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域

1、进程在用户空间调用库函数mmap，原型：void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);

2、在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址

3、为此虚拟区分配一个vm_area_struct结构，接着对这个结构的各个域进行了初始化

4、将新建的虚拟区结构（vm_area_struct）插入进程的虚拟地址区域链表或树中

（二）调用内核空间的系统调用函数mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系

5、为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。

6、通过该文件的文件结构体，链接到file_operations模块，调用内核函数mmap，其原型为：int mmap(struct file *filp, struct vm_area_struct *vma)，不同于用户空间库函数。

7、内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。

8、通过remap_pfn_range函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到主存中。
（三）进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝

注：前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时。

9、进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页面上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。

10、缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。

11、调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。

12、之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。

注：修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用msync()来强制同步, 这样所写的内容就能立即保存到文件里了。

# 为什么使用 mmap()

Linux通过内存映像机制来提供用户程序对内存直接访问的能力。内存映像的意思是把内核中特定部分的内存空间映射到用户级程序的内存空间去。也就是说，用户空间和内核空间共享一块相同的内存。这样做的直观效果显而易见：内核在这块地址内存储变更的任何数据，用户可以立即发现和使用，根本无须数据拷贝。举个例子理解一下，使用mmap方式获取磁盘上的文件信息，只需要将磁盘上的数据拷贝至那块共享内存中去，用户进程可以直接获取到信息，而相对于传统的write/read　IO系统调用, 必须先把数据从磁盘拷贝至到内核缓冲区中(页缓冲)，然后再把数据拷贝至用户进程中。两者相比，mmap会少一次拷贝数据，这样带来的性能提升是巨大的。

# mmap相关函数

**函数原型**

void *mmap(void *start, size_t length, int prot, int flags,int fd, off_t offset);

**返回说明**

成功执行时，mmap()返回被映射区的指针。失败时，mmap()返回MAP_FAILED[其值为(void *)-1]，error被设为以下的某个值：

EACCES：访问出错
EAGAIN：文件已被锁定，或者太多的内存已被锁定
EBADF：fd不是有效的文件描述词
EINVAL：一个或者多个参数无效
ENFILE：已达到系统对打开文件的限制
ENODEV：指定文件所在的文件系统不支持内存映射
ENOMEM：内存不足，或者进程已超出最大内存映射数量
EPERM：权能不足，操作不允许
ETXTBSY：已写的方式打开文件，同时指定MAP_DENYWRITE标志
SIGSEGV：试着向只读区写入
SIGBUS：试着访问不属于进程的内存区

**参数**

start：映射区的开始地址

length：映射区的长度

prot：期望的内存保护标志，不能与文件的打开模式冲突。是以下的某个值，可以通过or运算合理地组合在一起

PROT_EXEC：页内容可以被执行

PROT_READ：页内容可以被读取

PROT_WRITE：页可以被写入

PROT_NONE：页不可访问

flags：指定映射对象的类型，映射选项和映射页是否可以共享。它的值可以是一个或者多个以下位的组合体

MAP_FIXED //使用指定的映射起始地址，如果由start和len参数指定的内存区重叠于现存的映射空间，重叠部分将会被丢弃。如果指定的起始地址不可用，操作将会失败。并且起始地址必须落在页的边界上。
MAP_SHARED //与其它所有映射这个对象的进程共享映射空间。对共享区的写入，相当于输出到文件。直到msync()或者munmap()被调用，文件实际上不会被更新。
MAP_PRIVATE //建立一个写入时拷贝的私有映射。内存区域的写入不会影响到原文件。这个标志和以上标志是互斥的，只能使用其中一个。
MAP_DENYWRITE //这个标志被忽略。
MAP_EXECUTABLE //同上
MAP_NORESERVE //不要为这个映射保留交换空间。当交换空间被保留，对映射区修改的可能会得到保证。当交换空间不被保留，同时内存不足，对映射区的修改会引起段违例信号。
MAP_LOCKED //锁定映射区的页面，从而防止页面被交换出内存。
MAP_GROWSDOWN //用于堆栈，告诉内核VM系统，映射区可以向下扩展。
MAP_ANONYMOUS //匿名映射，映射区不与任何文件关联。
MAP_ANON //MAP_ANONYMOUS的别称，不再被使用。
MAP_FILE //兼容标志，被忽略。
MAP_32BIT //将映射区放在进程地址空间的低2GB，MAP_FIXED指定时会被忽略。当前这个标志只在x86-64平台上得到支持。
MAP_POPULATE //为文件映射通过预读的方式准备好页表。随后对映射区的访问不会被页违例阻塞。
MAP_NONBLOCK //仅和MAP_POPULATE一起使用时才有意义。不执行预读，只为已存在于内存中的页面建立页表入口。

fd：有效的文件描述词。如果MAP_ANONYMOUS被设定，为了兼容问题，其值应为-1

offset：被映射对象内容的起点

**相关函数**

int munmap( void * addr, size_t len )

成功执行时，munmap()返回0。失败时，munmap返回-1，error返回标志和mmap一致；

该调用在进程地址空间中解除一个映射关系，addr是调用mmap()时返回的地址，len是映射区的大小；

当映射关系解除后，对原来映射地址的访问将导致段错误发生。

int msync( void *addr, size_t len, int flags )

一般说来，进程在映射空间的对共享内容的改变并不直接写回到磁盘文件中，往往在调用munmap（）后才执行该操作。

可以通过调用msync()实现磁盘上文件内容与共享内存区的内容一致。

int msync( void *addr, size_t len, int flags )

一般说来，进程在映射空间的对共享内容的改变并不直接写回到磁盘文件中，往往在调用munmap（）后才执行该操作。

可以通过调用msync()实现磁盘上文件内容与共享内存区的内容一致。

# mmap 优缺点

## 优点

1. 减少了数据的拷贝次数，用内存读写取代 I/O 读写，提高了文件读取效率。
2. 实现了用户空间和内核空间的高效交互（映射）方式。各自的空间修改操作都会直接反映在共享（Shared）区域内，从而被对方空间及时捕捉到。
3. 提供不同进程间共享内存及相互通信的方式。无论是父子进程，还是无亲缘关系的进程之间，都可以将自身的用户空间映射到同一个文件或匿名映射到同一片区域。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的。例如：进程 A、B 都映射了区域 Z，当 A 第一次读取 C 时，通过缺页机制从磁盘中复制文件页到共享内存；当 B 再读 C 的相同页面时，虽然也会产生缺页异常，但是不再需要从磁盘中复制文件过来，而可直接使用已经保存在内存中的文件数据。
4. 可用于实现高效的大规模数据传输。通常的，内存空间不足是制约大数据操作的一个方面，解决方案可以是借助硬盘空间协助操作，补充内存空间的不足。但是也会进一步的造成了大量的文件 I/O 操作，极大的影响了执行效率。这个问题可以通过 mmap 映射很好的解决，但凡需要用磁盘空间代替内存的时候，mmap 都可以发挥其功效。

## 缺点

1. 对变长文件不适合.
2. 如果更新文件的操作很多，mmap避免两态拷贝的优势就被摊还，最终还是落在了大量的脏页回写及由此引发的随机IO上.　所以在随机写很多的情况下，mmap方式在效率上不一定会比带缓冲区的一般写快.

# 为什么mmap效率高于read/write？

常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制。这样造成读文件时需要先将文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址，所以还需要将页缓存中数据页再次拷贝到内存对应的用户空间中。这样，通过了两次数据拷贝过程，才能完成进程对文件内容的获取任务。写操作也是一样，待写入的buffer在内核空间不能直接访问，必须要先拷贝至内核空间对应的主存，再写回磁盘中（延迟写回），也是需要两次数据拷贝。

而使用mmap操作文件中，创建新的虚拟内存区域和建立文件磁盘地址和虚拟内存区域映射这两步，没有任何文件拷贝操作。而之后访问数据时发现内存中并无数据而发起的缺页异常过程，可以通过已经建立好的映射关系，只使用一次数据拷贝，就从磁盘中将数据传入内存的用户空间中，供进程使用。

即常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。而mmap操控文件，只需要从磁盘到用户主存的一次数据拷贝过程。因此mmap效率更高。

# 示例

1.创建文件zz，并用test.c代码向文件中写入数据。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201026135834202.png#pic_center)
![在这里插入图片描述](https://tva1.sinaimg.cn/large/0081Kckwly1gloktnwmezj30ed0agt9n.jpg)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201026135850503.png#pic_center)
2.分别指定不同大小的字符数写入，比较操作时长。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201026135856424.png#pic_center)
![在这里插入图片描述](https://tva1.sinaimg.cn/large/0081Kckwly1gloktlnzm1j30iz03qmxf.jpg)

## 总结

read和write执行了更多的系统调用，并做了更多的复制。read和write将数据从内核缓冲区中复制到应用缓冲区，然后再把数据从应用缓冲区复制到内核缓冲区。而mmap则直接把数据从映射到地址空间的一个内核缓冲区复制到另一个内核缓冲区。当引用尚不存在的内存页时，这样的复制过程就会作为处理页错误的结果而出现（每次错页读发生一次错误，每次错页写发生一次错误）。mmap的优势在于通过把文件的某一块内容映射到用户空间上，用户可以直接向内核缓冲池读写这一块内容，这样一来就少了内核与用户空间的来回拷贝所以通常更快。但 mmap方式只适用于更新、读写一块固定大小的文件区域而不能做像诸如不断的写内容进入文件导到文件增长这类的事。

---

# [mmap概述](https://www.cnblogs.com/linhaostudy/p/13467118.html)

mmap/munmap接口是用户空间的最常用的一个系统调用接口，无论是在用户程序中分配内存、读写大文件，链接动态库文件，还是多进程间共享内存，都可以看到mmap/munmap的身影。mmap/munmap函数声明如下：

```
#include <sys/mman.h>
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
int munmap(void *addr, size_t length);
```

- addr：用于指定映射到进程空间的起始地址，为了应用程序的可移植性，一般设置为NULL，让内核来选择一个合适的地址。
- length：表示映射到进程地址空间的大小
- prot：用于设置内核映射区域的读写属性等。
- flags：用于设置内存映射的属性，例如共享映射、私有映射等。
- fd：表示这个是一个文件映射，fd是打开文件的句柄。
- offset:在文件映射时，表示文件的偏移量。

prot参数通常表示映射页面的的读写权限，可以有如下参数组合：

- PROT_EXEC：表示映射的页面是可以执行的。
- PROT_READ：表示映射的页面是可以读取的。
- PROT_WRITE：表示映射的页面是可以写入的。
- PROT_NONE：表示映射的页面是不可访问的。

flags参数也是一个重要的参数，有如下常见的参数：

- MAP_SHARED：创建一个共享映射的区域。多个进程可以通过共享映射方式来映射一个文件，这样其他进程也可以看到映射内容的改变，修改后的内容会同步到磁盘文件中。
- MAP_PRIVATE：创建一个私有的写时复制的映射。多个进程可以通过私有映射的方式来映射一个文件，这样其他进程不会看到映射内容的改变，修改后的内容也不会同步到磁盘文件中。
- MAP_ANONYMOUS：创建一个匿名映射，即没有关联到文件的映射。
- MAP_FIXED：使用参数addr创建映射，如果内核无法映射指定地址addr，那么mmap会返回失败，参数addr要求按页对齐。如果addr和length指定的进程地址空间和已有的VMA区域重叠，那么内核会调用do_munmap()函数把这段重叠区域销毁，然后重新映射新的内容。
- MAP_POPULATE：对于文件映射来说，会提前预读文件内容到映射区域，该特性只支持私用映射。

参数fd可以看出mmap映射是否和文件相关联，因此Linux内核中映射可以分为匿名映射和文件映射。

- 匿名映射：没有映射对应的相关文件，这种映射的内存区域的内容会被初始化为0。
- 文件映射：映射和实际文件相关联，通常是把文件的内容映射到进程地址空间，这样应用程序就可以像操作进程地址空间一样读写文件。

最后根据文件关联性和映射区域是否共享等属性，又可以分为如下4种，见表2.1。

 mmap映射类型

|          | 映射类型                        | 映射类型                                    |
| :------- | :------------------------------ | :------------------------------------------ |
|          | 私有映射                        | 共享映射                                    |
| 匿名映射 | 私有匿名映射-通常用于内存分配   | 共享匿名映射-通常用于进程间共享内存         |
| 文件映射 | 私有文件映射-通常用于加载动态库 | 共享文件映射-通常用于内存映射IO，进程间通信 |

1. 私有匿名映射

当使用参数fd=-1且flags=MAP_ANONYMOUS | MAP_PRIVATE时，创建的mmap映射是私有匿名映射。私有匿名映射最常见的用途是在glibc分配大块内存中，当需要的分配的内存大于MMAP_THREASHOLD(128KB)时，glibc会默认使用mmap代替brk来分配内存。

1. 共享匿名映射

当使用参数fd=-1且flags=MAP_ANONYMOUS | MAP_SHARED。在这种情况下，创建共享匿名映射。共享匿名映射让相关进程共享一块内存区域，通常用于父子进程的之间通信。

创建共享匿名映射有如下两种方式：

（1）fd=-1且flags= MAP_ANONYMOUS|MAP_SHARED。在这种情况下，do_mmap_pgoff()->mmap()函数最终调用shmem_zero_setup()来打开一个"/dev/zero"特殊的设备文件。

（2）另外一个是直接打开"/dev/zero"设备文件，然后使用这个文件句柄来创建mmap。

1. 私有文件映射

私有文件映射时flags的标志位被设置为MAP_PRIVATE，那么就会创建私有文件映射。

私有文件映射的最常用的场景是加载动态共享库。

1. 共享文件映射

创建文件映射时flags的标志位被设置为MAP_SHARED，那么就会创建共享文件映射。如果prot参数指定了PROT_WRITE，那么打开文件需要制定O_RDWR标志位。共享文件映射通常有如下场景：

（1）读写文件：

把文件内容映射到进程地址空间，同时对映射的内容做了修改，内核的回写机制（writeback）最终会把修改的内容同步到磁盘中。

（2）进程间通信：

进程之间的进程地址空间相互隔离，一个进程不能访问到另外一个进程的地址空间。如果多个进程都同时映射到一个相同的文件，就实现了多进程间的共享内存的通信。如果一个进程对映射内容做了修改，那么另外的进程是可以看到的。
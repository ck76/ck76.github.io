[TOC]

（一）请分别简单说一说进程和线程以及它们的区别。

- 进程是具有一定功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源调度和分配的一个独立单位。
- 线程是进程的实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。
- 一个进程可以有多个线程，多个线程也可以并发执行

如果你对进程或者线程不太熟悉，建议阅读：[进程与线程的一个简单解释](http://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2013/04/processes_and_threads.html)

（二）线程同步的方式有哪些？

- 互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。
- 信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。
- 事件（信号）：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。

经两位大大的指正，现已删除临界区。感谢：[@真姬酱](http://www.zhihu.com/people/f8734eaa80bed7a0ddd5396faba9678d)[@安阳](http://www.zhihu.com/people/6db4cb9ef1838676f87e5961daa708ed)

如果你对线程同步的方式不太熟悉，建议阅读：[线程同步的几种方式](http://link.zhihu.com/?target=http%3A//www.cnblogs.com/lebronjames/archive/2010/08/11/1797702.html)

（三）进程的通信方式有哪些？

主要分为：管道、系统**IPC**（包括消息队列、信号量、共享存储）、**SOCKET**

管道主要分为：普通管道**PIPE** 、流管道（**s_pipe**）、命名管道（**name_pipe**）

- 管道是一种**半双工**的通信方式，数据只能单项流动，并且只能在具有亲缘关系的进程间流动，进程的亲缘关系通常是父子进程
- 命名管道也是**半双工**的通信方式，它允许无亲缘关系的进程间进行通信
- 信号量是一个计数器，用来控制多个进程对资源的访问，它通常作为一种锁机制。
- 消息队列是消息的链表，存放在内核中并由消息队列标识符标识。
- 信号是一种比较复杂的通信方式，用于通知接收进程**某个事件已经发生。**
- 共享内存就是映射一段能被其它进程访问的内存，这段共享内存由一个进程创建，但是多个进程可以访问。

如果你对进程的通信方式不太熟悉，建议阅读： [进程间的几种通信方式](http://link.zhihu.com/?target=http%3A//blog.csdn.net/yufaw/article/details/7409596)

（四）什么是缓冲区溢出？有什么危害？其原因是什么？

缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。

危害有以下两点：

- 程序崩溃，导致拒绝额服务
- 跳转并且执行一段恶意代码

造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。

如果你想深入了解缓冲区溢出，推荐阅读：[缓冲区溢出攻击](http://link.zhihu.com/?target=http%3A//www.cnblogs.com/fanzhidongyzby/archive/2013/08/10/3250405.html)

（五）什么是死锁？死锁产生的条件？

在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。

死锁产生的四个条件（有一个条件不成立，则不会产生死锁）

- 互斥条件：一个资源一次只能被一个进程使用
- 请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放
- 不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺
- 循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系

如果对死锁还不是太熟悉，建议阅读：[死锁产生的原因和解锁的方法](http://link.zhihu.com/?target=http%3A//www.cnblogs.com/Jessy/p/3540724.html)

（六）进程有哪几种状态？

- 就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源
- 运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数
- 阻塞状态： 进程等待某种条件，在条件满足之前无法执行

如果你对进程的几种状态以及中间的装换不太了解，建议阅读：[进程的三种状态及转换](http://link.zhihu.com/?target=http%3A//blog.chinaunix.net/uid-23883288-id-3028968.html)

（七）分页和分段有什么区别？

- 段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。
- 段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定
- 段向用户提供二维地址空间；页向用户提供的是一维地址空间
- 段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。

如果你对分页和分段还不太了解，建议阅读：[分段和分页](http://link.zhihu.com/?target=http%3A//blog.csdn.net/wangrunmin/article/details/7967293)

（八） 操作系统中进程调度策略有哪几种？

FCFS(先来先服务)，优先级，时间片轮转，多级反馈

如果你想深入的了解这几种调度策略，推荐阅读：[几个常用的操作系统进程调度算法](http://link.zhihu.com/?target=http%3A//blog.csdn.net/luyafei_89430/article/details/12971171)

（九）说一说进程同步有哪几种机制。

原子操作、信号量机制、自旋锁管程、会合、分布式系统

如果你想深入的了解这几种机制，推荐阅读：[ 进程同步的几种机制](http://link.zhihu.com/?target=http%3A//www.cnblogs.com/sonic4x/archive/2011/07/05/2098036.html)

（十）说一说死锁的处理基本策略和常用方法。

解决死锁的基本方法如下：

预防死锁、避免死锁、检测死锁、解除死锁

解决四多的常用策略如下：

鸵鸟策略、预防策略、避免策略、检测与解除死锁

如果你对死锁的处理策略不是太熟悉，推荐阅读：[产生死锁的原因和必要条件+解决死锁的基本方法](http://link.zhihu.com/?target=http%3A//blog.csdn.net/bxyill/article/details/8237339)

本文参考文献和文章：



「1」[操作系统常见面试题总结 - youngchang的开发博客](http://link.zhihu.com/?target=http%3A//blog.csdn.net/youngchang06hpu/article/details/8009947)

「2」 [操作系统面试题 - iWan](http://link.zhihu.com/?target=http%3A//www.cnblogs.com/memewry/archive/2012/08/25/2656966.html)

「3」[进程间的几种通信方式](http://link.zhihu.com/?target=http%3A//blog.csdn.net/yufaw/article/details/7409596)

「4」[操作系统各大公司笔试题汇总](http://link.zhihu.com/?target=http%3A//blog.csdn.net/hackbuteer1/article/details/6787354)

「5」[解决死锁的基本方法](http://link.zhihu.com/?target=http%3A//blog.csdn.net/bxyill/article/details/8237339)



https://zhuanlan.zhihu.com/p/23755202?refer=passer



---

### 1.进程的常见状态？以及各种状态之间的转换条件？

- 就绪：进程已处于准备好运行的状态，即进程已分配到除CPU外的所有必要资源后，只要再获得CPU，便可立即执行。
- 执行：进程已经获得CPU，程序正在执行状态。
- 阻塞：正在执行的进程由于发生某事件（如I/O请求、申请缓冲区失败等）暂时无法继续执行的状态。

​     ![img](https://tva1.sinaimg.cn/large/0081Kckwly1glgj3mrma9j308v050mxm.jpg)

### 2.进程同步

进程同步的主要任务：是对多个相关进程在执行次序上进行协调，以使并发执行的诸进程之间能有效地共享资源和相互合作，从而使程序的执行具有可再现性。

　　同步机制遵循的原则：

　　（1）空闲让进；

　　（2）忙则等待（保证对临界区的互斥访问）；

　　（3）有限等待（有限代表有限的时间，避免死等）；

　　（4）让权等待，（当进程不能进入自己的临界区时，应该释放处理机，以免陷入忙等状态）。

### 3.进程的通信方式有哪些？

　　进程通信，是指进程之间的信息交换（信息量少则一个状态或数值，多者则是成千上万个字节）。因此，对于用信号量进行的进程间的互斥和同步，由于其所交换的信息量少而被归结为低级通信。

　　所谓高级进程通信指：用户可以利用操作系统所提供的一组通信命令传送大量数据的一种通信方式。操作系统隐藏了进程通信的实现细节。或者说，通信过程对用户是透明的。

　　高级通信机制可归结为三大类：

　　（1）共享存储器系统（存储器中划分的共享存储区）；实际操作中对应的是“剪贴板”（剪贴板实际上是系统维护管理的一块内存区域）的通信方式，比如举例如下：word进程按下ctrl+c，在ppt进程按下ctrl+v，即完成了word进程和ppt进程之间的通信，复制时将数据放入到剪贴板，粘贴时从剪贴板中取出数据，然后显示在ppt窗口上。

　　（2）消息传递系统（进程间的数据交换以消息（message）为单位，当今最流行的微内核操作系统中，微内核与服务器之间的通信，无一例外地都采用了消息传递机制。应用举例：邮槽（MailSlot）是基于广播通信体系设计出来的，它采用无连接的不可靠的数据传输。邮槽是一种单向通信机制，创建邮槽的服务器进程读取数据，打开邮槽的客户机进程写入数据。

　　（3）管道通信系统（管道即：连接读写进程以实现他们之间通信的共享文件（pipe文件，类似先进先出的队列，由一个进程写，另一进程读））。实际操作中，管道分为：匿名管道、命名管道。匿名管道是一个未命名的、单向管道，通过父进程和一个子进程之间传输数据。匿名管道只能实现本地机器上两个进程之间的通信，而不能实现跨网络的通信。命名管道不仅可以在本机上实现两个进程间的通信，还可以跨网络实现两个进程间的通信。

- **管道**：**管道是单向的、先进先出的、无结构的、固定大小的字节流，它把一个进程的标准输出和另一个进程的标准输入连接在一起。**写进程在管道的尾端写入数据，读进程在管道的道端读出数据。数据读出后将从管道中移走，其它读进程都不能再读到这些数据。管道提供了简单的流控制机制。进程试图读空管道时，在有数据写入管道前，进程将一直阻塞。同样地，管道已经满时，进程再试图写管道，在其它进程从管道中移走数据之前，写进程将一直阻塞。

​     **注1：无名管道只能实现父子或者兄弟进程之间的通信，有名管道（FIFO）可以实现互不相关的两个进程之间的通信。**

　　  **注2：用FIFO让一个服务器和多个客户端进行交流时候，每个客户在向服务器发送信息前建立自己的读管道，或者让服务器在得到数据后再建立管道。使用客户的进程号（pid）作为管道名是一种常用的方法。客户可以先把自己的进程号告诉服务器，然后再到那个以自己进程号命名的管道中读取回复。**

- **信号量**：**信号量是一个计数器，可以用来控制多个进程对共享资源的访问。**它常作为一种锁机制，防止某进程正在访问共享资源时，其它进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
- **消息队列**：**是一个在系统内核中用来保存消 息的队列，它在系统内核中是以消息链表的形式出现的。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点**。
- **共享内存**：共享内存允许两个或多个进程访问同一个逻辑内存。**这一段内存可以被两个或两个以上的进程映射至自身的地址空间中**，一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取读出，从而实现了进程间的通信**。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。**共享内存是最快的IPC方式，它是针对其它进程间通信方式运行效率低而专门设计的。它往往与其它通信机制（如**信号量**）配合使用，来实现进程间的同步和通信。
- **套接字**：套接字也是一种进程间通信机制，与其它通信机制不同的是，它可用于不同机器间的进程通信。

### 4.上下文切换

对于单核单线程CPU而言，在某一时刻只能执行一条CPU指令。上下文切换(Context Switch)是一种**将CPU资源从一个进程分配给另一个进程的机制**。从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。**在切换的过程中，操作系统需要先存储当前进程的状态(包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。**

### **5.**进程与线程的区别和联系？

- **进程**是具有一定独立功能的程序关于某个数据集合上的一次运行活动，**进程**是系统进行资源分配和调度的一个独立单位。
- **线程**是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。

**进程和线程的关系**

（1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程是操作系统可识别的最小执行和调度单位。

（2）资源分配给进程，同一进程的所有线程共享该进程的所有资源。 同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。

（3）处理机分给线程，即真正在处理机上运行的是线程。

（4）线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。

**进程与线程的区别？**

（1）进程有自己的独立地址空间，线程没有

（2）进程是资源分配的最小单位，线程是CPU调度的最小单位

（3）进程和线程通信方式不同(线程之间的通信比较方便。同一进程下的线程共享数据（比如全局变量，静态变量），通过这些数据来通信不仅快捷而且方便，当然如何处理好这些访问的同步与互斥正是编写多线程程序的难点。而进程之间的通信只能通过[进程通信](http://baike.baidu.com/view/549640.htm)的方式进行。)

（4）进程上下文切换开销大，线程开销小

（5）一个进程挂掉了不会影响其他进程，而线程挂掉了会影响其他线程

（6）对进程进程操作一般开销都比较大，对线程开销就小了 

 **为什么进程上下文切换比线程上下文切换代价高？**

进程切换分两步：

1.切换页目录以使用新的地址空间

2.切换内核栈和硬件上下文

对于linux来说，线程和进程的最大区别就在于地址空间，对于线程切换，第1步是不需要做的，第2是进程和线程切换都要做的。

切换的性能消耗：

1、线程上下文切换和进程上下问切换一个最主要的区别是线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出。

**2、另外一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲（processor's Translation Lookaside Buffer (TLB)）或者相当的神马东西会被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题。**

 

转自知乎：**进程和线程的区别**

链接：https://www.zhihu.com/question/25532384/answer/81152571

首先来一句概括的总论：**进程和线程都是一个时间段的描述，是CPU工作时间段的描述。**

**下面细说背景**：
CPU+RAM+各种资源（比如显卡，光驱，键盘，GPS, 等等外设）构成我们的电脑，但是电脑的运行，实际就是CPU和相关寄存器以及RAM之间的事情。

**一个最最基础的事实**：CPU太快，太快，太快了，寄存器仅仅能够追的上他的脚步，RAM和别的挂在各总线上的设备完全是望其项背。那当多个任务要执行的时候怎么办呢？轮流着来?或者谁优先级高谁来？不管怎么样的策略，一句话就是在CPU看来就是轮流着来。

**一个必须知道的事实**：执行一段程序代码，实现一个功能的过程介绍 ，当得到CPU的时候，相关的资源必须也已经就位，就是显卡啊，GPS啊什么的必须就位，然后CPU开始执行。这里除了CPU以外所有的就构成了这个程序的执行环境，也就是我们所定义的程序上下文。当这个程序执行完了，或者分配给他的CPU执行时间用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去的最后一步工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存。

**串联起来的事实**：前面讲过在CPU看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：***先加载程序A的上下文，然后开始执行A，保存程序A的上下文，调入下一个要执行的程序B的程序上下文，然后开始执行B,保存程序B的上下文\*。。。\*。

\*========= 重要的东西出现了========
**进程和线程*就是这样的背景出来的****，两个名词不过是对应的CPU时间段的描述，名词就是这样的功能。
\***

- **进程就是包换上下文切换的程序执行时间总和** = **CPU加载上下文+CPU执行+CPU保存上下文**

***线程是什么呢？
\***进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：

程序A得到CPU =》CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。

这里a，b，c的执行是共享了A的上下文，CPU在执行的时候没有进行上下文切换的。这**里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。

到此全文结束，再一个总结：
**
**进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。** 

- 进程(process)与线程(thread)最大的区别是**进程拥有自己的地址空间，某进程内的线程对于其他进程不可见，即进程A不能通过传地址的方式直接读写进程B的存储区域**。进程之间的通信需要通过进程间通信(Inter-process communication，IPC)。与之相对的，**同一进程的各线程间之间可以直接通过传递地址或全局变量的方式传递信息**。
- **进程作为操作系统中拥有资源和独立调度的基本单位，可以拥有多个线程。**通常操作系统中运行的一个程序就对应一个进程。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换，如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。**相比进程切换，线程切换的开销要小很多。线程于进程相互结合能够提高系统的运行效率。**

**线程可以分为两类：**

- **用户级线程(user level thread)**：对于这类线程，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。在应用程序启动后，操作系统分配给该程序一个进程号，以及其对应的内存空间等资源。应用程序通常先在一个线程中运行，该线程被成为主线程。在其运行的某个时刻，可以通过调用线程库中的函数创建一个在相同进程中运行的新线程。**用户级线程的好处是非常高效，不需要进入内核空间，但并发效率不高。**
- **内核级线程(kernel level thread)**：对于这类线程，有关线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只能调用内核线程的接口。内核维护进程及其内部的每个线程，调度也由内核基于线程架构完成。内核级线程的好处是，**内核可以将不同线程更好地分配到不同的CPU，以实现真正的并行计算。**

**事实上，在现代操作系统中，往往使用组合方式实现多线程，即线程创建完全在用户空间中完成，并且一个应用程序中的多个用户级线程被映射到一些内核级线程上，相当于是一种折中方案。**

### 6.进程调度

**调度种类**

- **高级调度**：(High-Level Scheduling)又称为作业调度，它决定把后备作业调入内存运行；
- **低级调度**：(Low-Level Scheduling)又称为进程调度，它决定把就绪队列的某进程获得CPU；
- **中级调度**：(Intermediate-Level Scheduling)又称为在虚拟存储器中引入，在内、外存对换区进行进程对换。

**非抢占式调度与抢占式调度**

- **非抢占式**：分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或发生进程调度进程调度某事件而阻塞时，才把处理机分配给另一个进程。
- **抢占式**：操作系统将正在运行的进程强行暂停，由调度程序将CPU分配给其他就绪进程的调度方式。

**调度策略的设计**

- **响应时间**: 从用户输入到产生反应的时间
- **周转时间**: 从任务开始到任务结束的时间

CPU任务可以分为**交互式任务**和**批处理任务**，调度最终的目标是**合理的使用CPU，使得交互式任务的响应时间尽可能短，用户不至于感到延迟，同时使得批处理任务的周转时间尽可能短，减少用户等待的时间。**

**调度算法：**

**FIFO或First Come, First Served (FCFS)先来先服务**

- 调度的顺序就是任务到达就绪队列的顺序。
- 公平、简单(FIFO队列)、非抢占、不适合交互式。
- 未考虑任务特性，平均等待时间可以缩短。

**Shortest Job First (SJF)**

- 最短的作业(CPU区间长度最小)最先调度。
- SJF可以保证最小的平均等待时间。

**Shortest Remaining Job First (SRJF)**

- SJF的可抢占版本，比SJF更有优势。
- SJF(SRJF): 如何知道下一CPU区间大小？根据历史进行预测: 指数平均法。

**优先权调度**

- 每个任务关联一个优先权，调度优先权最高的任务。
- 注意：优先权太低的任务一直就绪，得不到运行，出现“饥饿”现象。

**Round-Robin(RR)轮转调度算法**

- 设置一个时间片，按时间片来轮转调度（“轮叫”算法）
- 优点: 定时有响应，等待时间较短；缺点: 上下文切换次数较多；
- 时间片太大，响应时间太长；吞吐量变小，周转时间变长；当时间片过长时，退化为FCFS。

**多级队列调度**

- 按照一定的规则建立多个进程队列
- 不同的队列有固定的优先级（高优先级有抢占权）
- 不同的队列可以给不同的时间片和采用不同的调度方法
- 存在问题1：没法区分I/O bound和CPU bound；
- 存在问题2：也存在一定程度的“饥饿”现象；

**多级反馈队列**

- **在多级队列的基础上，任务可以在队列之间移动，更细致的区分任务。**
- **可以根据“享用”CPU时间多少来移动队列，阻止“饥饿”。**
- **最通用的调度算法，多数OS都使用该方法或其变形，如UNIX、Windows等。**

**多级反馈队列调度算法描述:**

![clipboard.png](https://tva1.sinaimg.cn/large/0081Kckwly1gl8edsm9uvj308c05v0th.jpg)

- 进程在进入待调度的队列等待时，**首先进入优先级最高的Q1等待。**
- **首先调度优先级高的队列中的进程。若高优先级中队列中已没有调度的进程，则调度次优先级队列中的进程。**例如：Q1,Q2,Q3三个队列，只有在Q1中没有进程等待时才去调度Q2，同理，只有Q1,Q2都为空时才会去调度Q3。
- **对于同一个队列中的各个进程，按照时间片轮转法调度。**比如Q1队列的时间片为N，那么Q1中的作业在经历了N个时间片后若还没有完成，则进入Q2队列等待，若Q2的时间片用完后作业还不能完成，一直进入下一级队列，直至完成。
- **在低优先级的队列中的进程在运行时，又有新到达的作业，那么在运行完这个时间片后，CPU马上分配给新到达的作业（抢占式）。**

**一个简单的例子**
假设系统中有3个反馈队列Q1,Q2,Q3，时间片分别为2，4，8。现在有3个作业J1,J2,J3分别在时间 0 ，1，3时刻到达。而它们所需要的CPU时间分别是3，2，1个时间片。

- - **时刻0** J1到达。 于是进入到队列1 ，运行1个时间片 ，时间片还未到，此时J2到达。
  - **时刻1** J2到达。 由于时间片仍然由J1掌控，于是等待。J1在运行了1个时间片后，已经完成了在Q1中的2个时间片的限制，于是J1置于Q2等待被调度。现在处理机分配给J2。
  - **时刻2** J1进入Q2等待调度，J2获得CPU开始运行。
  - **时刻3** J3到达，由于J2的时间片未到，故J3在Q1等待调度，J1也在Q2等待调度。
  - **时刻4** J2处理完成，由于J3，J1都在等待调度，但是J3所在的队列比J1所在的队列的优先级要高，于是J3被调度，J1继续在Q2等待。
  - **时刻5** J3经过1个时间片，完成。
  - **时刻6** 由于Q1已经空闲，于是开始调度Q2中的作业，则J1得到处理器开始运行。 J1再经过一个时间片，完成了任务。于是整个调度过程结束。

###  7.死锁的条件？以及如何处理死锁问题？

**定义**:如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件,那么该组进程就是死锁的。或者在两个或多个并发进程中，如果每个进程持有某种资源而又都等待别的进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗地讲，就是两个或多个进程被无限期地阻塞、相互等待的一种状态。

产生死锁的必要条件：

- **互斥条件(Mutual exclusion)**：资源不能被共享，只能由一个进程使用。
- **请求与保持条件(Hold and wait)**：已经得到资源的进程可以再次申请新的资源。
- **非抢占条件(No pre-emption)**：已经分配的资源不能从相应的进程中被强制地剥夺。
- **循环等待条件(Circular wait)**：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。

**如何处理死锁问题：**

- **忽略该问题**。例如鸵鸟算法，该算法可以应用在极少发生死锁的的情况下。为什么叫鸵鸟算法呢，因为传说中鸵鸟看到危险就把头埋在地底下，可能鸵鸟觉得看不到危险也就没危险了吧。跟掩耳盗铃有点像。
- **检测死锁并且恢复。**
- 仔细地对资源进行动态分配，使系统始终处于安全状态以**避免死锁**。
- **通过破除死锁四个必要条件之一，来防止死锁产生。**

### **8.临界资源**

- 在操作系统中，进程是占有资源的最小单位（线程可以访问其所在进程内的所有资源，但线程本身并不占有资源或仅仅占有一点必须资源）。但**对于某些资源来说，其在同一时间只能被一个进程所占用。这些一次只能被一个进程所占用的资源就是所谓的临界资源**。典型的临界资源比如物理上的打印机，或是存在硬盘或内存中被多个进程所共享的一些变量和数据等(如果这类资源不被看成临界资源加以保护，那么很有可能造成丢数据的问题)。
- **对于临界资源的访问，必须是互斥进行。**也就是当临界资源被占用时，另一个申请临界资源的进程会被阻塞，直到其所申请的临界资源被释放。**而进程内访问临界资源的代码被成为临界区。**

### 9.一个程序从开始运行到结束的完整过程（四个过程）

1、预处理：条件编译，头文件包含，宏替换的处理，生成.i文件。

2、编译：将预处理后的文件转换成汇编语言，生成.s文件

3、汇编：汇编变为目标代码(机器代码)生成.o的文件

4、链接：连接目标代码,生成可执行程序

[链接](https://blog.csdn.net/wqx521/article/details/52625408)

### 10.内存池、进程池、线程池。(c++程序员必须掌握)

 　　首先介绍一个概念“池化技术 ”。池化技术就是：提前保存大量的资源，以备不时之需以及重复使用。池化技术应用广泛，如内存池，线程池，连接池等等。内存池相关的内容，建议看看Apache、Nginx等开源web服务器的内存池实现。
 　　由于在实际应用当做，分配内存、创建进程、线程都会设计到一些系统调用，系统调用需要导致程序从用户态切换到内核态，是非常耗时的操作。因此，当程序中需要频繁的进行内存申请释放，进程、线程创建销毁等操作时，通常会使用内存池、进程池、线程池技术来提升程序的性能。

 　　**线程池**：线程池的原理很简单，类似于操作系统中的缓冲区的概念，它的流程如下：先启动若干数量的线程，并让这些线程都处于睡眠状态，当需要一个开辟一个线程去做具体的工作时，就会唤醒线程池中的某一个睡眠线程，让它去做具体工作，当工作完成后，线程又处于睡眠状态，而不是将线程销毁。

 　　**进程池**与线程池同理。

 　　**内存池**：内存池是指程序预先从操作系统申请一块足够大内存，此后，当程序中需要申请内存的时候，不是直接向操作系统申请，而是直接从内存池中获取；同理，当程序释放内存的时候，并不真正将内存返回给操作系统，而是返回内存池。当程序退出(或者特定时间)时，内存池才将之前申请的内存真正释放。

### 11.动态链接库与静态链接库的区别

**静态库**

- 静态库是一个外部函数与变量的集合体。静态库的文件内容，通常包含一堆程序员自定的变量与函数，其内容不像动态链接库那么复杂，在编译期间由编译器与链接器将它集成至应用程序内，并制作成目标文件以及可以独立运作的可执行文件。而这个可执行文件与编译可执行文件的程序，都是一种程序的静态创建（static build）。

![img](https://tva1.sinaimg.cn/large/0081Kckwly1gl8edpebw1j30jg0ebtc3.jpg)

**动态库**

- 静态库很方便，但是如果我们只是想用库中的某一个函数，却仍然得把所有的内容都链接进去。一个更现代的方法则是使用共享库，避免了在文件中静态库的大量重复。
- 动态链接可以在首次载入的时候执行(load-time linking)，这是 Linux 的标准做法，会由动态链接器ld-linux.so 完成，比方标准 C 库(libc.so) 通常就是动态链接的，这样**所有的程序可以共享同一个库，而不用分别进行封装。**
- 动态链接也可以在程序开始执行的时候完成(run-time linking)，在 Linux 中使用 dlopen()接口来完成（会使用函数指针），通常用于分布式软件，高性能服务器上。而且共享库也可以在多个进程间共享。
- **链接使得我们可以用多个对象文件构造我们的程序。可以在程序的不同阶段进行（编译、载入、运行期间均可），理解链接可以帮助我们避免遇到奇怪的错误**。

![img](https://tva1.sinaimg.cn/large/0081Kckwly1gl8ednp87gj30jg0hujx1.jpg)

区别：

1. 使用静态库的时候，静态链接库要参与编译，在生成执行文件之前的链接过程中，要将静态链接库的全部指令直接链接入可执行文件中。而动态库提供了一种方法，使进程可以调用不属于其可执行代码的函数。函数的可执行代码位于一个.dll文件中，该dll包含一个或多个已被编译，链接并与使用它们的进程分开储存的函数。
2. 静态库中不能再包含其他动态库或静态库，而在动态库中还可以再包含其他动态或者静态库。
3. 静态库在编译的时候，就将库函数装在到程序中去了，而动态库函数必须在运行的时候才被装载，所以使用静态库速度快一些。

[链接](http://www.cnblogs.com/gaoyihan/p/4723332.html)

### 12.虚拟内存？优缺点？

定义：具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充得一种存储器系统。其逻辑容量由内存之和和外存之和决定。

与传统存储器比较虚拟存储器有以下三个主要特征：

- 多次性，是指无需在作业运行时一次性地全部装入内存，而是允许被分成多次调入内存运行。
- 对换性，是指无需在作业运行时一直常驻内存，而是允许在作业的运行过程中，进行换进和换出。
- 虚拟性，是指从逻辑上扩充内存的容量，使用户所看到的内存容量，远大于实际的内存容量。

虚拟内存的实现有以下两种方式：

- 请求分页存储管理。
- 请求分段存储管理。

### 13.页面置换算法

操作系统将内存按照页面进行管理，在需要的时候才把进程相应的部分调入内存。当产生缺页中断时，需要选择一个页面写入。如果要换出的页面在内存中被修改过，变成了“脏”页面，那就需要先写会到磁盘。页面置换算法，就是要选出最合适的一个页面，使得置换的效率最高。页面置换算法有很多，简单介绍几个，重点介绍比较重要的LRU及其实现算法。

**一、最优页面置换算法**

最理想的状态下，我们给页面做个标记，挑选一个最远才会被再次用到的页面调出。当然，这样的算法不可能实现，因为不确定一个页面在何时会被用到。

**二、先进先出页面置换算法（FIFO）及其改进**

这种算法的思想和队列是一样的，该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予淘汰。实现：把一个进程已调入内存的页面按先后次序链接成一个队列，并且设置一个指针总是指向最老的页面。缺点：对于有些经常被访问的页面如含有全局变量、常用函数、例程等的页面，不能保证这些不被淘汰。

**三、最近最少使用页面置换算法LRU（Least Recently Used）**

根据页面调入内存后的使用情况做出决策。LRU置换算法是选择最近最久未使用的页面进行淘汰。

1.为每个在内存中的页面配置一个移位寄存器。（P165）定时信号将每隔一段时间将寄存器右移一位。最小数值的寄存器对应页面就是最久未使用页面。

2.利用一个特殊的栈保存当前使用的各个页面的页面号。每当进程访问某页面时，便将该页面的页面号从栈中移出，将它压入栈顶。因此，栈顶永远是最新被访问的页面号，栈底是最近最久未被访问的页面号。

[链接：分页内存管理（把虚拟内存空间和物理内存空间均划分为大小相同的页面等内容）](https://www.cnblogs.com/edisonchou/p/5094066.html)

[链接：分段内存管理](http://www.cnblogs.com/edisonchou/p/5115242.html)

### 14.中断与系统调用

**所谓的中断就是在计算机执行程序的过程中，由于出现了某些特殊事情，使得CPU暂停对程序的执行，转而去执行处理这一事件的程序。等这些特殊事情处理完之后再回去执行之前的程序。**中断一般分为三类：

- 由计算机硬件异常或故障引起的中断，称为**内部异常中断**；
- 由程序中执行了引起中断的指令而造成的中断，称为**软中断**（这也是和我们将要说明的系统调用相关的中断）；
- 由外部设备请求引起的中断，称为**外部中断**。简单来说，对中断的理解就是对一些特殊事情的处理。

与中断紧密相连的一个概念就是**中断处理程序**了。当中断发生的时候，系统需要去对中断进行处理，对这些中断的处理是由操作系统内核中的特定函数进行的，这些处理中断的特定的函数就是我们所说的中断处理程序了。

另一个与中断紧密相连的概念就是**中断的优先级**。中断的优先级说明的是当一个中断正在被处理的时候，处理器能接受的中断的级别。中断的优先级也表明了中断需要被处理的紧急程度。**每个中断都有一个对应的优先级，当处理器在处理某一中断的时候，只有比这个中断优先级高的中断可以被处理器接受并且被处理。**优先级比这个当前正在被处理的中断优先级要低的中断将会被忽略。

**典型的中断优先级如下所示：**

- **机器错误 > 时钟 > 磁盘 > 网络设备 > 终端 > 软件中断**

 

在讲系统调用之前，先说下**进程的执行在系统上的两个级别**：用户级和核心级，也称为**用户态和系统态(user mode and kernel mode)**。

​      **用户空间就是用户进程所在的内存区域**，相对的，**系统空间就是操作系统占据的内存区域**。用户进程和系统进程的所有数据都在内存中。**处于用户态的程序只能访问用户空间，而处于内核态的程序可以访问用户空间和内核空间。**

**用户态切换到内核态的方式如下：**

- **系统调用**：程序的执行一般是在用户态下执行的，但当程序需要使用操作系统提供的服务时，比如说打开某一设备、创建文件、读写文件（这些均属于系统调用）等，就需要向操作系统发出调用服务的请求，这就是系统调用。
- **异常**：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如**缺页异常。**
- **外围设备的中断：**当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

**用户态和核心态(内核态）之间的区别是什么呢？**

​    **权限不一样。**

- **用户态的进程能存取它们自己的指令和数据，但不能存取内核指令和数据（或其他进程的指令和数据）**。
- **核心态下的进程能够存取内核和用户地址某些机器指令是特权指令，在用户态下执行特权指令会引起错误。**在系统中内核并不是作为一个与用户进程平行的估计的进程的集合。

### 15.C++多线程，互斥，同步

#### 同步和互斥

当有多个线程的时候，经常需要去**同步(注：同步不是同时刻)**这些线程以访问同一个数据或资源。例如，假设有一个程序，其中一个线程用于把文件读到内存，而另一个线程用于统计文件中的字符数。当然，在把整个文件调入内存之前，统计它的计数是没有意义的。但是，由于每个操作都有自己的线程，操作系统会把两个线程当作是互不相干的任务分别执行，这样就可能在没有把整个文件装入内存时统计字数。为解决此问题，你必须使两个线程**同步**工作。

所谓**同步**，是指在不同进程之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。如果用对资源的访问来定义的话，同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。

所谓**互斥**，是指散布在不同进程之间的若干程序片断，当某个进程运行其中一个程序片段时，其它进程就不能运行它们之中的任一程序片段，只能等到该进程运行完这个程序片段后才可以运行。如果用对资源的访问来定义的话，互斥某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。

#### 多线程同步和互斥有几种实现方法

线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。

用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。

内核模式下的方法有：事件，信号量，互斥量。

1、临界区:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。 
2、互斥量:为协调共同对一个共享资源的单独访问而设计的。 
3、信号量:为控制一个具有有限数量用户资源而设计。 
4、事 件:用来通知线程有一些事件已发生，从而启动后继任务的开始。

### 16.逻辑地址 Vs 物理地址 Vs 虚拟内存

- **所谓的逻辑地址，是指计算机用户(例如程序开发者)，看到的地址。**例如，当创建一个长度为100的整型数组时，操作系统返回一个逻辑上的连续空间：指针指向数组第一个元素的内存地址。由于整型元素的大小为4个字节，故第二个元素的地址时起始地址加4，以此类推。事实上，**逻辑地址并不一定是元素存储的真实地址，即数组元素的物理地址(在内存条中所处的位置)，并非是连续的，只是操作系统通过地址映射，将逻辑地址映射成连续的，这样更符合人们的直观思维**。
- 另一个重要概念是虚拟内存。操作系统读写内存的速度可以比读写磁盘的速度快几个量级。但是，内存价格也相对较高，不能大规模扩展。于是，**操作系统可以通过将部分不太常用的数据移出内存，“存放到价格相对较低的磁盘缓存，以实现内存扩展**。操作系统还可以通过算法预测哪部分存储到磁盘缓存的数据需要进行读写，提前把这部分数据读回内存。**虚拟内存空间相对磁盘而言要小很多，因此，即使搜索虚拟内存空间也比直接搜索磁盘要快。唯一慢于磁盘的可能是，内存、虚拟内存中都没有所需要的数据，最终还需要从硬盘中直接读取。**这就是为什么内存和虚拟内存中需要存储会被重复读写的数据，否则就失去了缓存的意义。现代计算机中有一个专门的**转译缓冲区(Translation Lookaside Buffer，TLB)**，用来实现虚拟地址到物理地址的快速转换。

**与内存／虚拟内存相关的还有如下两个概念：**
**1) Resident Set**

- 当一个进程在运行的时候，操作系统不会一次性加载进程的所有数据到内存，只会加载一部分正在用，以及预期要用的数据。其他数据可能存储在虚拟内存，交换区和硬盘文件系统上。**被加载到内存的部分就是resident set。**

**2) Thrashing**

- 由于resident set包含预期要用的数据，理想情况下，进程运行过程中用到的数据都会逐步加载进resident set。但事实往往并非如此：**每当需要的内存页面(page)不在resident set中时，操作系统必须从虚拟内存或硬盘中读数据，这个过程被称为内存页面错误(page faults)。当操作系统需要花费大量时间去处理页面错误的情况就是thrashing。**

**参考链接：**https://blog.csdn.net/newcong0123/article/details/52792070

### **17.内部碎片与外部碎片**

在内存管理中，**内部碎片**是已经被分配出去的的内存空间大于请求所需的内存空间。

**外部碎片**是指还没有分配出去，但是由于大小太小而无法分配给申请空间的新进程的内存空间空闲块。

固定分区存在内部碎片，可变式分区分配会存在外部碎片；

**页式虚拟存储**系统存在**内部碎片**；**段式虚拟存储**系统，存在**外部碎片**

为了有效的利用内存，使内存产生更少的碎片，要对内存分页，内存以页为单位来使用，最后一页往往装不满，于是形成了内部碎片。

为了共享要分段，在段的换入换出时形成外部碎片，比如5K的段换出后，有一个4k的段进来放到原来5k的地方，于是形成1k的外部碎片。

### 18.同步和互斥的区别

​    当有多个线程的时候，经常需要去同步这些线程以访问同一个数据或资源。例如，假设有一个程序，其中一个线程用于把文件读到内存，而另一个线程用于统计文件中的字符数。当然，在把整个文件调入内存之前，统计它的计数是没有意义的。但是，由于每个操作都有自己的线程，操作系统会把两个线程当作是互不相干的任务分别执行，这样就可能在没有把整个文件装入内存时统计字数。为解决此问题，你必须使两个线程同步工作。

   所谓**同步**，是指散步在不同进程之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。如果**用对资源的访问来定义的话，同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。**

   所谓**互斥**，是指散布在不同进程之间的若干程序片断，当某个进程运行其中一个程序片段时，其它进程就不能运行它们之中的任一程序片段，只能等到该进程运行完这个程序片段后才可以运行。如果**用对资源的访问来定义的话，互斥某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。**

### 19.什么是线程安全

如果多线程的程序运行结果是可预期的，而且与单线程的程序运行结果一样，那么说明是“线程安全”的。

### 20.同步与异步

### 同步：

- 同步的定义：是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么，这个进程将会一直等待下去，直到收到返回信息才继续执行下去。
- 特点：

1. 同步是阻塞模式；
2. 同步是按顺序执行，执行完一个再执行下一个，需要等待，协调运行；

### 异步：

- 是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。
- 特点：

1. 异步是非阻塞模式，无需等待；
2. 异步是彼此独立，在等待某事件的过程中，继续做自己的事，不需要等待这一事件完成后再工作。线程是异步实现的一个方式。

### 同步与异步的优缺点：

- 同步可以避免出现死锁，读脏数据的发生。一般共享某一资源的时候，如果每个人都有修改权限，同时修改一个文件，有可能使一个读取另一个人已经删除了内容，就会出错，同步就不会出错。但，同步需要等待资源访问结束，浪费时间，效率低。
- 异步可以提高效率，但，安全性较低。

### 21.系统调用与库函数的区别

- **系统调用(System call)是程序向系统内核请求服务的方式。**可以包括硬件相关的服务(例如，访问硬盘等)，或者创建新进程，调度其他进程等。系统调用是程序和操作系统之间的重要接口。
- **库函数：把一些常用的函数编写完放到一个文件里，编写应用程序时调用，这是由第三方提供的，发生在用户地址空间**。
- 在**移植性方面**，不同操作系统的系统调用一般是不同的，移植性差；而在所有的ANSI C编译器版本中，C库函数是相同的。
- 在**调用开销方面**，系统调用需要在用户空间和内核环境间切换，开销较大；而库函数调用属于“过程调用”，开销较小。

### 22.守护、僵尸、孤儿进程的概念

- **守护进程**：运行在后台的一种特殊进程，**独立于控制终端并周期性地执行某些任务**。
- **僵尸进程**：一个进程 fork 子进程，子进程退出，而父进程没有wait/waitpid子进程，那么**子进程的进程描述符仍保存在系统中**，这样的进程称为僵尸进程。
- **孤儿进程**：一个**父进程退出，而它的一个或多个子进程还在运行**，这些子进程称为孤儿进程。（孤儿进程将由 init 进程收养并对它们完成状态收集工作）

```
> 孤儿进程，指的是在父进程退出的时候，它的子进程（线程）因为各种原因还在运行，这种进程就被成为孤儿进程，孤儿进程会被init_task进程收养，由init_task代替退出的父进程对它们进行状态收集。

> 僵尸进程，则是指的那种被fork出来的子进程已经退出，但是父进程并没有调用 wait 函数或者 waitpid 函数获取子进程的状态信息，导致子进程的进程描述符仍然保存在操作系统中，这种实际上已经退出但是在操作系统上还能看到的进程就被称为僵尸进程。

> 这两种进程都涉及到进程退出的概念。进程如何退出呢，前面没有介绍。linux 中进程退出的机制是，进程接收到操作系统发出的退出信号，内核释放该进程的所有资源，包括内存和打开的文件，但仍然保存进程号和退出状态等信息，直到父进程通过 wait 或者 waitpid 函数来采集才会释放。联系到孤儿进程和僵尸进程，实际上孤儿进程对用户的可见性较低，因为孤儿进程会被init_task进程收养，init_task可以做到安全退出孤儿进程，僵尸进程则不然，它们会占用进程号等稀缺资源，当一个系统产生大量僵尸进程的时候，则无法创建新进程。
```

### 23.Semaphore(信号量) Vs Mutex(互斥锁)

- 当用户创立多个线程／进程时，如果不同线程／进程同时读写相同的内容，则可能造成读写错误，或者数据不一致。此时，需要通过加锁的方式，控制临界区(critical section)的访问权限。对于semaphore而言，在初始化变量的时候可以控制允许多少个线程／进程同时访问一个临界区，其他的线程／进程会被堵塞，直到有人解锁。
- Mutex相当于只允许一个线程／进程访问的semaphore。此外，根据实际需要，人们还实现了一种读写锁(read-write lock)，它允许同时存在多个阅读者(reader)，但任何时候至多只有一个写者(writer)，且不能于读者共存。

### 24.IO多路复用

**IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：**

- 当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用I/O复用。
- 当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。
- 如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。
- 如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。
- 如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。
- 与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。

### 25.线程安全

如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和[单线程](https://baike.baidu.com/item/单线程)运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。或者说:一个类或者程序所提供的接口对于线程来说是[原子操作](https://baike.baidu.com/item/原子操作)或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。

线程安全问题都是由[全局变量](https://baike.baidu.com/item/全局变量)及[静态变量](https://baike.baidu.com/item/静态变量)引起的。

若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑[线程同步](https://baike.baidu.com/item/线程同步)，否则的话就可能影响线程安全。

 

### 26.线程共享资源和独占资源问题

[参考链接](https://www.cnblogs.com/baoendemao/p/3804677.html)

一个进程中的所有线程共享该进程的地址空间，但它们有各自独立的（/私有的）栈(stack)，Windows线程的缺省堆栈大小为1M。堆(heap)的分配与栈有所不同，一般是一个进程有一个C运行时堆，这个堆为本进程中所有线程共享，windows进程还有所谓进程默认堆，用户也可以创建自己的堆。 
用操作系统术语，线程切换的时候实际上切换的是一个可以称之为线程控制块的结构（TCB）,里面保存所有将来用于恢复线程环境必须的信息，包括所有必须保存的寄存器集，线程的状态等。

**堆：**　是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。

**栈：**是个线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，因此，栈是　thread safe的。操作系统在切换线程的时候会自动的切换栈，就是切换　ＳＳ／ＥＳＰ寄存器。栈空间不需要在高级语言里面显式的分配和释放。

![img](https://tva1.sinaimg.cn/large/0081Kckwly1gl8edjevx6j30id05sdfs.jpg)



https://www.cnblogs.com/inception6-lxc/p/9073983.html



---

##### [什么是线程？什么是进程？为什么要有线程？有什么关系与区别？](https://www.cnblogs.com/ConstXiong/p/11680304.html)

**进程：**

- 程序执行时的一个实例
- 每个进程都有独立的内存地址空间
- 系统进行资源分配和调度的基本单位
- 进程里的堆，是一个进程中最大的一块内存，被进程中的所有线程共享的，进程创建时分配，主要存放 new 创建的对象实例
- 进程里的方法区，是用来存放进程中的代码片段的，是线程共享的
- 在多线程 OS 中，进程不是一个可执行的实体，即一个进程至少创建一个线程去执行代码

**为什么要有线程？**

   每个进程都有自己的地址空间，即进程空间。一个服务器通常需要接收大量并发请求，为每一个请求都创建一个进程系统开销大、请求响应效率低，因此操作系统引进线程。    
**线程：**

- 进程中的一个实体
- 进程的一个执行路径
- CPU 调度和分派的基本单位
- 线程本身是不会独立存在
- 当前线程 CPU 时间片用完后，会让出 CPU 等下次轮到自己时候在执行
- 系统不会为线程分配内存，线程组之间只能共享所属进程的资源
- 线程只拥有在运行中必不可少的资源(如程序计数器、栈)
- 线程里的程序计数器就是为了记录该线程让出 CPU 时候的执行地址，待再次分配到时间片时候就可以从自己私有的计数器指定地址继续执行
- 每个线程有自己的栈资源，用于存储该线程的局部变量和调用栈帧，其它线程无权访问    
  **关系：**

- 一个程序至少一个进程，一个进程至少一个线程，进程中的多个线程是共享进程的资源
- Java 中当我们启动 main 函数时候就启动了一个 JVM 的进程，而 main 函数所在线程就是这个进程中的一个线程，也叫做主线程
- 一个进程中有多个线程，多个线程共享进程的堆和方法区资源，但是每个线程有自己的程序计数器，栈区域

如下图
![img](https://tva1.sinaimg.cn/large/0081Kckwly1glokquefrtj30fh0asjro.jpg)
**区别：**

-  本质：进程是操作系统资源分配的基本单位；线程是任务调度和执行的基本单位
-  内存分配：系统在运行的时候会为每个进程分配不同的内存空间，建立数据表来维护代码段、堆栈段和数据段；除了 CPU 外，系统不会为线程分配内存，线程所使用的资源来自其所属进程的资源
- 资源拥有：进程之间的资源是独立的，无法共享；同一进程的所有线程共享本进程的资源，如内存，CPU，IO 等
-  开销：每个进程都有独立的代码和数据空间，程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行程序计数器和栈，线程之间切换的开销小
- 通信：进程间 以IPC（管道，信号量，共享内存，消息队列，文件，套接字等）方式通信 ；同一个进程下，线程间可以共享全局变量、静态变量等数据进行通信，做到同步和互斥，以保证数据的一致性
- 调度和切换：线程上下文切换比进程上下文切换快，代价小
- 执行过程：每个进程都有一个程序执行的入口，顺序执行序列；线程不能够独立执行，必须依存在应用程序中，由程序的多线程控制机制控制
- 健壮性：每个进程之间的资源是独立的，当一个进程崩溃时，不会影响其他进程；同一进程的线程共享此线程的资源，当一个线程发生崩溃时，此进程也会发生崩溃，稳定性差，容易出现共享与资源竞争产生的各种问题，如死锁等
- 可维护性：线程的可维护性，代码也较难调试，bug 难排查


**进程与线程的选择：**

- 需要频繁创建销毁的优先使用线程。因为进程创建、销毁一个进程代价很大，需要不停的分配资源；线程频繁的调用只改变 CPU 的执行
- 线程的切换速度快，需要大量计算，切换频繁时，用线程
- 耗时的操作使用线程可提高应用程序的响应
- 线程对 CPU 的使用效率更优，多机器分布的用进程，多核分布用线程
- 需要跨机器移植，优先考虑用进程
- 需要更稳定、安全时，优先考虑用进程
- 需要速度时，优先考虑用线程
- 并行性要求很高时，优先考虑用线程

Java 编程语言中线程是通过 java.lang.Thread 类实现的。

Thread 类中包含 tid（线程id）、name（线程名称）、group（线程组）、daemon（是否守护线程）、priority（优先级） 等重要属性。

---



##### 进程间的通信方式/使用共享内存时如何进行同步

```
进程间的通信方式
1.管道
管道是一种半双工通信方式，一次只能向一边传输，而且使用的进程必须具有亲缘关系
2.命名管道
也是一种半双工的通信方式，但可以在不具有亲缘关系的进程中使用
3.信号
通知接收线程某一事件已经发生，用于不同进程间或者同一进程间的不同线程
4.信号量
是一个计数器，用于限制线程对某一共享资源的访问，比如某一线程正在访问某一共享资源，其他线程不能访问
5.消息队列
消息队列是消息的链表，存放于内核中，一个消息队列由唯一一个队列id
客服了信号传递信息少，管道只能承载无格式字节流(无格式字节流：没有边界，没有结束标识，上一条和下一条无法区分)以及缓冲区小的的缺点
6.共享内存
指两个或者多个进程共享一个给定的存储区
7.套接字
也是一种通信机制，用于不同进程之间的进程通信


进程通信的目的：
1.数据传输
一个进程要将它的数据发送给另一个进程
2.资源共享
多个进程之间共享资源
3.通知事件
一个进程需要通知另一个进程某一个事件已经发生
4.进程控制
有些进程希望控制另一个进程的执行（如Debug进程），此时控制进程希望拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变
```



##### 栈和堆在内存上的实现方式？/堆和栈区别、为什么要分堆和栈/为什么堆上面效率高

```
答：高到低、低到高；存一般的数据结构、存对象和手动分配的内存；性能不同，栈销毁只需要移动指针，堆需要手动销毁
问：为什么要这样做？（字符串等放在栈，对象和手动分配的放堆里）
答：感觉和作用域有关吧，作用域是线性的，然后进出作用域的时候销毁起来方便，也更快
问：还有其他原因吗
勘误：栈拓展起来更方便
```



##### 某个线程崩溃，进程会不会崩溃

```
1. 每个进程拥有完全不同的虚拟地址空间，操作系统内核通Address Translation技术映射到物理地址空间（X86处理器体系架构采用段表+页表进行映射，页表有2级和4级之分，32位系统采用2级页表，64位系统采用4级页表），这让进程有一种幻觉即独占整个内存空间。进程与进程之间是完全隔离的，进程A崩溃了完全不会影响到进程B，所以现在很多浏览器都采用多进程的方式来实现，打开一个网页对应fork一个进程来执行。

2. 一个进程内的所有线程共享同一内存空间，线程与线程之间是没有隔离的，虽说每个线程有自己的工作栈空间，但是线程A去访问线程B的工作栈空间也是可以做到的。某个线程的行为可能影响到进程内其他的线程。

3. 在java里面，某个线程抛出异常没有捕获，对应的线程会崩溃，但是对应进程（JVM虚拟机）并不会随之崩溃。这样既有好处也有坏处，好处是：其他线程不受影响，坏处是：若没有外围的监控，很难察觉到对应的线程是否已经崩溃。
```



##### 解释一下中断？

```
答：大概解释了下一个程序正在运行的时候遇到中断，先检测有没有关中断，如果没有的话就把上下文保存起来，然后切换到中断服务程序，运行完之后再回到当前，把上下文复原，这样...

中断是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。 [1]

勘误：关中断和开中断还可以再详细一点
问：中断分为哪些？
答：硬中断和软中断吧，硬中断主要是硬件产生的中断，比如【按键盘啊之类的】，软中断主要就是软件产生的中断吧。
	硬件中断（Hardware Interrupt） [3]  ：
可屏蔽中断（maskable interrupt）。硬件中断的一类，可通过在中断屏蔽寄存器中设定位掩码来关闭。
非可屏蔽中断（non-maskable interrupt，NMI）。硬件中断的一类，无法通过在中断屏蔽寄存器中设定位掩码来关闭。典型例子是时钟中断（一个硬件时钟以恒定频率—如50Hz—发出的中断）。
处理器间中断（interprocessor interrupt）。一种特殊的硬件中断。由处理器发出，被其它处理器接收。仅见于多处理器系统，以便于处理器间通信或同步。
伪中断（spurious interrupt）。一类不希望被产生的硬件中断。发生的原因有很多种，如中断线路上电气信号异常，或是中断请求设备本身有问题。
	软件中断（Software Interrupt） [3]  ：
软件中断。是一条CPU指令，用以自陷一个中断。由于软中断指令通常要运行一个切换CPU至内核态（Kernel Mode/Ring 0）的子例程，它常被用作实现【系统调用】（System call）。
```

```
现代计算机中采用中断系统的主要目的是 [4]  ：
①提高计算机系统效率。计算机系统中处理机的工作速度远高于外围设备的工作速度。通过中断可以协调它们之间的工作。当外围设备需要与处理机交换信息时，由外围设备向处理机发出中断请求，处理机及时响应并作相应处理。不交换信息时，处理机和外围设备处于各自独立的并行工作状态。
②维持系统可靠正常工作。现代计算机中，程序员不能直接干预和操纵机器，必须通过中断系统向操作系统发出请求，由操作系统来实现人为干预。主存储器中往往有多道程序和各自的存储空间。在程序运行过程中，如出现越界访问，有可能引起程序混乱或相互破坏信息。为避免这类事件的发生，由存储管理部件进行监测，一旦发生越界访问，向处理机发出中断请求，处理机立即采取保护措施。
③满足实时处理要求。在实时系统中，各种监测和控制装置随机地向处理机发出中断请求，处理机随时响应并进行处理。
④提供故障现场处理手段。处理机中设有各种故障检测和错误诊断的部件，一旦发现故障或错误，立即发出中断请求，进行故障现场记录和隔离，为进一步处理提供必要的依据。
```

```
中断过程编辑
按照事件发生的顺序，中断过程包括 [4]  ：
①中断源发出中断请求;
②判断当前处理机是否允许中断和该中断源是否被屏蔽;
③优先权排队;
④处理机执行完当前指令或当前指令无法执行完，则立即停止当前程序，保护断点地址和处理机当前状态，转入相应的中断服务程序;
⑤执行中断服务程序;
⑥恢复被保护的状态，执行“中断返回”指令回到被中断的程序或转入其他程序。
上述过程中前四项操作是由硬件完成的，后两项是由软件完成的。
```



##### 编码

```
1. 说下ASCII和unicode的区别
2. unicode一个汉字占多少字节？字母呢？
3. utf-8的优势？
```



##### 单CPU能实现多任务并行吗

```
因为一个CPU一次只能执行一条指令，所以如果CPU是单核的，使用多线程或者多进程任务，这些任务其实是并发执行的，操作系统会不断的切换多个任务，因此单核CPU是不能够实现并行的，虽然并发最终的结果可能和并行一样，但是真实的并行只可能出现在多核CPU的系统中。
超线程
```



Java相关

1、线程池介绍，任务队列如果满了怎么办；

参考：https://www.cnblogs.com/dolphin0520/p/3932921.html

2、CAS介绍，CAS有什么问题，Java是否有解决方法；

参考：https://www.cnblogs.com/qjjazry/p/6581568.html

3、HashMap介绍，equals和hashCode函数；

参考：https://blog.csdn.net/woshimaxiao1/article/details/83661464

4、final关键字，final常量存储位置，常量池的好处；

参考：https://www.cnblogs.com/dolphin0520/p/3736238.html

https://www.jianshu.com/p/c7f47de2ee80

网络相关

1、HTTPS介绍；

参考：https://www.jianshu.com/p/14cd2c9d2cd2

2、TCP三次握手和四次挥手；

参考：https://yuanrengu.com/2020/77eef79f.html



#### sp寄存器的作用

https://blog.csdn.net/qq_36588941/article/details/89873633

https://blog.csdn.net/a15651035561/article/details/102874666?utm_medium=distribute.pc_relevant.none-task-blog-baidulandingword-6&spm=1001.2101.3001.4242

https://blog.csdn.net/huaxiaolunan/article/details/97914504?utm_medium=distribute.pc_relevant.none-task-blog-baidulandingword-2&spm=1001.2101.3001.4242

https://blog.csdn.net/qq_33574890/article/details/97932620?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.control

```

```



##### 了解汇编吗，讲一讲、C++的编译过程讲一讲

```
//你在那些平台上写过汇编程序
```

http://www.ruanyifeng.com/blog/2014/11/compiler.html

https://www.runoob.com/w3cnote/working-process-of-the-compiler.html



##### 文件I/O的过程，尽可能详细；进程内部和进程之间如何处理同一个文件

```

```



##### 能解释下什么是野指针吗？

答：就是一个指针指向了未知地址，比如一个内存被回收了，但是指向它的指针没有被置空



##### 操作系统如何实现系统调用

- https://www.cnblogs.com/yongheng20/p/4947702.html

```
1. 什么是系统调用

　　在计算机中，系统调用（英语：system call），又称为系统呼叫，指运行在使用者空间的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供了用户程序与操作系统之间的接口（即系统调用是用户程序和内核交互的接口）。

　　操作系统中的状态分为管态（核心态）和目态（用户态）。大多数系统交互式操作需求在内核态执行。如设备IO操作或者进程间通信。特权指令：一类只能在核心态下运行而不能在用户态下运行的特殊指令。不同的操作系统特权指令会有所差异，但是一般来说主要是和硬件相关的一些指令。用户程序只在用户态下运行，有时需要访问系统核心功能，这时通过系统调用接口使用系统调用。

　　翻来覆去也就是这几句话：

　　应用程序有时会需要一些危险的、权限很高的指令，如果把这些权限放心地交给用户程序是很危险的(比如一个进程可能修改另一个进程的内存区，导致其不能运行)，但是又不能完全不给这些权限。于是有了系统调用，危险的指令被包装成系统调用，用户程序只能调用而无权自己运行那些危险的指令。另外，计算机硬件的资源是有限的，为了更好的管理这些资源，所有的资源都由操作系统控制，进程只能向操作系统请求这些资源。操作系统是这些资源的唯一入口，这个入口就是系统调用。


2. 系统调用实现方法概述

　　在Xv6中增加系统调用的方法为：

　　　　1） 在 sysproc.c 文件中，添加要增加的系统调用的实现函数；

　　　　2） 在 syscall.h 文件中，定义指向实现函数的系统调用向量（system call vector）的位置；

　　　　3） 在 user.h 文件中，定义可以在 shell 中调用的函数；

　　　　4） 在 syscall.c 文件中，外部定义（external define）一个链接内核和 shell 的函数，使用“步骤2）”中的位置将此函数添加到系统调用向量；

　　　　5） 在 usys.S 文件中，使用 macro 连接 用户的调用请求 和 实现函数；

　　　　6） 在 defs.h 文件中，为自己添加的系统调用增加一个前台声明。
```



##### 信号量和锁有什么区别？

```
1. 互斥bai量用于线程du的互斥，信号量zhi用于线程的同步dao。
这是互斥量zhuan和信号量的根本区别，也就是互斥和同步之间的区别。
互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限shu访问者对资源的访问顺序，即访问是无序的。
同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源
2. 互斥量值只能为0/1，信号量值可以为非负整数。
也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。
3. 互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。
```



引用能不能为空

```c
引用与指针最主要的三个区别：
1、引用必须初始化
2、引用不能为空
3、引用指向一个变量后，他指向的对象不会再发生改变

举例如下：
1
int& a;//错误，必须初始化
int n;
int& b = n;//正确

2
char* p = NULL;
char& q = *p;//错误，引用不能为空

3
int a;
int b;
int& m = a;
m = b;//此时m仍然指向a，m = b相当于a = b，a的值被修改
```



LRU用了哈希表+双向链表



详细讲讲ThreadPoolExecutor线程池

https://www.nowcoder.com/discuss/447791



##### 链接器如何做的重定向

- https://blog.csdn.net/weixin_34313182/article/details/88754351

```
那你刚刚说编译好的目标文件有data 和text段他们两者有啥区别
```



##### 详解信号量和互斥锁之间的区别和联系

- https://blog.csdn.net/leikun153/article/details/81515186



##### X86汇编的特定寄存器了解多少



##### 怎么理解面向对象和面向过程

```
面向过程
优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。
缺点：没有面向对象易维护、易复用、易扩展

面向对象
优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护
缺点：性能比面向过程低
```



《程序设计实践》里，这对术语并没有翻译为“大端”和小端，而是“高尾端”和“低尾端”，这就好理解了：如果把一个数看成一个字符串，比如11223344看成"11223344"，末尾是个'\0'，'11'到'44'个占用一个存储单元，那么它的尾端很显然是44，前面的高还是低就表示尾端放在高地址还是低地址，它在内存中的放法非常直观，如下图：

![img](https://tva1.sinaimg.cn/large/0081Kckwly1glokcg1tm4j30jm0ax0sr.jpg)

　　“高/低尾端”比“大/小端”更不容易让人迷惑。但是根据个人经验，在市面上的书籍、网络上的各种资料中，很遗憾，前者已经很少见了，多见的是后者。好在这两对形容词中，恰好“高”和“大”对应，“低”和“小”对应；既然高尾端对应的是大端，低尾端对应的是小端，那么当你再见到大端和小端这一对术语，就可以在脑中把它们转化成高尾端和低尾端，这时凭着之前的理解，甚至不用回忆，想着高低的字面含义就能回想起它们的含义。但是很奇怪的是，同样是裘宗燕翻译的《编程原本》（Elements of Programming），却把big-endian翻译成大尾格式（第一章）。

　　理解之后，总结一下，记忆的方法是：

> 　　　　（数据看成字符串）**大端——高尾端，小端——低尾端**

　　稍一思索什么是“高”、什么是"低"，"尾端"又是什么，问题迎刃而解，再不用担心被“大端”和“小端”迷惑。用这种方式，是时候放弃原先的死记硬背和容易把自己绕进去而发生迷惑的理解了



##### B树B+树、[红黑树](https://www.nowcoder.com/jump/super-jump/word?word=红黑树)

- https://blog.csdn.net/herr_kun/article/details/80550652
- https://blog.csdn.net/qq_31443653/article/details/87283443
- https://www.cnblogs.com/yfzhou/p/10290006.html
- https://www.cnblogs.com/fvsfvs123/p/4362581.html

```
概念即可

```



##### 同步异步

```
定义：同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)。同步，就是调用某个东西是，调用方得等待这个调用返回结果才能继续往后执行。异步，和同步相反  调用方不会理解得到结果，而是在调用发出后调用者可用继续执行后续操作，被调用者通过状体来通知调用者，或者通过回掉函数来处理这个调用
```



##### 阻塞和非阻塞

```
阻塞和非阻塞 强调的是程序在等待调用结果（消息，返回值）时的状态.  阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。 对于同步调用来说，很多时候当前线程还是激活的状态，只是从逻辑上当前函数没有返回而已，即同步等待时什么都不干，白白占用着资源。

同步和异步强调的是消息通信机制 (synchronous communication/ asynchronous communication)。所谓同步，就是在发出一个"调用"时，在没有得到结果之前，该“调用”就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由“调用者”主动等待这个“调用”的结果。而异步则是相反，"调用"在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在"调用"发出后，"被调用者"通过状态、通知来通知调用者，或通过回调函数处理这个调用
```


[TOC]

### 一、基础知识

#### 1、汇编语言基本概念

- 汇编指令就是一堆助记符，汇编指令的集合构成了汇编语言，汇编语言既便于程序员编写程序，又保留了机器语言可以迅速地控制机器的长处，可以说，汇编语言是控制计算机工作的最简便的语言
- 汇编语言又三种指令形式：汇编指令、伪指令和宏指令。
  - 汇编指令：可以翻译成二进制的机器指令代码
  - 伪指令和宏指令不能，他们是在汇编期间为汇编程序提供相关信息用的
  - 总而言之，程序必须要包含汇编指令和伪指令，宏指令按序指定
- 在汇编语言中涉及的概念有：数的表示、寄存器、存储单元、指令格式、语法规则等

#### 2、计算机中数的表示

- 汇编中最常用的就是二进制（B）、十进制（D）和十六进制(H)

- **二进制：**

  - 二进制转十进制：整数小数通用：X2^0+X2^1+X2^2….

  - 二进制转十六进制：四位一转

    ```java
    101101.1B  -> 0010 1101 . 1000 = 2d.8H
    ```

  - 十进制转二进制

    - 整数：一路除

    - 小数逐次乘以2

      ```java
      0.125 -> 0.001B
      ```

  - 十六进制与上面二进制和十进制的同理

- 在计算机中二进制显得冗长，十六进制与二进制转换关系简单，所以需要掌握二进制的加、减、乘运算

- 二进制运算加减乘除还是类似于现实生活中的加减乘除

- **数的表示：**

  - 原码：对于带符号数，0表示 + ，1表示 -，并规定最高位是符号位
  - 反码：
    - 正数：与原码一样
    - 负数：符号位为1，数值位在原来的基础上取反
  - 补码：
    - 正数：与原码一样
    - 负数：**符号位为1**，数值位在原码的基础上取反加1
  - 移码【快速判断数之间大小关系】
    - 补码与移码只差一个符号位

- **用公式求补码**

  ```java
      [x]补=2^n-|x|
      n: 二进制的位数
  例：n = 8, 求[-5]补，[-128]补
  [-5]补 = 28-5 =100000000B-101B
            =11111011B = FBH
  [-128]补 = 28-128 = 10000000B = 80H
  ```

- **求补运算：**

  - 求补运算得到的是补码
    - 对正数的补码求补运算得到负数的补码，对负数的补码求补运算得到的是正数的补码

  - **求补运算**和求补码是不同的

  - **对补码连同符号位一起求反加1.**

  ```java
         [x]补      <-->求补    [-x]补
  例：01100011B——10011101B
           10011110B——01100010B
          [+7]补=00000111B=07H，求补：11111001B=F9H
          [-7]补=11111001B=F9H
  ```

- **从补码求真值：**

  - 对负数的补码的数值位再次求反加1，且符号变为-，就得到其真值

- **数的表示范围：**

  - 带符号：-2^15  ~ +2^15-1(一位给0)
  - 无符号：0~65535举例

- **补码计算：**

  ```java
  [x-y]补 = [x]补 + [-y]补
  ```

  ```java
  //例1
  例1 已知x=13，y=6，用补码计算x－y
  步骤如下：
  	（1）先将x和y分别用8位二进制表示：
  		x =00001101B，y =00000110B       
  	 （2）求出正数的补码
  			 [x]补=0,0001101B
  	     [y]补=0,0000110B 
  	（3）根据补码运算规则
  	        	[x-y]补=[x]补+[-y]补
  	（4）计算-y的补码，即对+y的补码再求补
  			[-y]补=1,1111010B
  	（5）减法运算变为补码的加法
  	          [x] 补 =  0,0001101B
  	        +[-y] 补 =  1,1111010B
  	        [x-y] 补 =1 0,0000111B 
  	           丢掉符号进位
  	          求得 x－y = 0,0000111B 
  ```

- **压缩BCD码和非压缩BCD码**

  ```java
  //BCD码又可以表示成压缩的 BCD 码和非压缩的BCD码，可根据需要选定。 
  （1）压缩的BCD码
  用1字节二进制数表示两个8421码，则称为压缩的BCD码。例如：85D = 10000101BCD
             364D = 00000011 01100100BCD
  （2）非压缩的BCD码
  1字节二进制数只表示一个8421码，则称为非压缩的BCD码。
  例如：85D = 00001000 00000101BCD
             364D = 00000011 00000110 00000100BCD
  ```

- **数的正确表示**

  ```java
  由于两个数都是补码，可以直接相加 
  			  10010111B
  		  +	01101110B
  		  1 00000101B
  		  
  从结果看出：
  （1）最高位有进位（模），应该丢掉；
  （2）符号位为0，表示结果为正数，即两数相加等于+5；
  （3）由于是一个负数和一个正数相加，结果为正数，因此不溢出。
  最高位的进位会舍掉，像日常生活一样，若以12小时为单位，13点就是下午一点，减掉的12就是“模”；8位的二进制模就是2^8
  
  两个数都是补码，直接相加 
  			  10010111B
  		  +	11101110B
  		  1 10000101B  //不溢出
  
  两个数都是补码，直接相加 
  			  00010111B
  		  +	01101110B
  		 	  10000101B  //溢出因为正正+得到了负值
  ```

- 7FH（127）

- 任何数，无论是原码，反码还是补码，当把他除以2时，只需要向右移一位即可

- 如果是乘以2，那么只需要左移一位就可以，后面无论是正数还是负数，全部补0,乘以4，左移两位，以此类推。除法亦是这样

  ```java
  已知[X]补=98H，则[X]补/2=____H
  
  任何数，无论是原码，反码还是补码，当把他除以2时，只需要向右移一位即可
  此时，设计到右移的时候左边到底补0还是补1的问题。很简单，
  如果这个数是正数，那么右移的时候左边补0。
  如果这个数时负数，那么右移的时候左边补1。
  题目说X的补码是98H，显然大于7FH（127），所以一定是负数，这样的话，右移的时候要补1。
  因此，98H=1001 1000B，右移一位，补1，得到：CCH=1100 1100B。
  这是简便的做法，也是计算机的做法，你可以手工算，将98H求补，再十进制除以2，结果再转成16进制，并再求补，也可以到CCH
  ```

- **字扩展和字节扩展**
  - 字节扩展为字，8位扩展到16位(CBW)
  - 字扩展，16位扩展到32位(CWD)
  - 正数符号位之前补0，负数符号位之前补1

-----



### 二、计算机基本原理

#### 1、冯诺依曼计算机

- **微型计算机机构**

![微型计算机机构](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/ZldrWPiFuTUs6R9axY3b6ywXrC2SovI.o4RzjNZN2ks!/r/dMEAAAAAAAAA)

- **基本结构：**

  计算机由运算器、控制器、存储器、输入设备出设备五大部件组成。**运算器和控制器合称为中央处理器（CPU）**

- **CPU**

  - 中央处理器（CPU）是计算机硬件系统的核心部件，是计算机系统接受命令并按命令完成对应操作的间指中心和运算中心
  - CPU 主要由算术和逻辑运算单元 ALU 地址发生和控制单元、指令译码单元、数据寄存器单元、总线驱动单元、时序控制单元等组成。

- **存储器**

  - 存储器用来存储在计算机系统中**运行的程序，程序处理的原始数据，中间数据及最终结果的设备**。存储器分为内存和外存。
  - 内存又称主存，用于存储计算机当前正在运行的程序正在处理的原始数据，中间数据及最终结果的存储器。
  - 内存按功能可分为两种：只读存储器 ROM (Read Only Memory）和随机存取存储器 RAM (Random Access Memory）。

- **输入输出设备**

- **总线**

  - 计算机总线：分为内部总线和外部总线。
  - 内部总线指的是 CPU 内部各个部件之间的连线。
  - 外部总线又称为系统总线，是连接计算机主板上各种芯片以及各个接口部件的总线。
  - **系统总线分为地址总线、数据总线、控制总线三大类**

- **接口**

  - 外部设备和计算机主机之间必须有一个中间介质作为缓冲部件，该部件称为接口（nterface)
  - 外部设备通过连在外部总线上的接口与 CPU 相连。接口又分为并行接口和串行接口。
  - 并行接口：同时并行地传送多位数据，例如 8 位数据用 8 根数据线做并行传输
  - 串行接口：数据是一位接位传输的，只需一根数据线

- **冯·诺依曼计算机的基本特点**

  - 采用存储程序方式，即程序和数据放在同一个存储器中程序指令和数据都用二进制表示，两者都可以送到 CPU 执行和运算
  - 存储器是**按地址访问的**，每个存储单元的位数是固定的存储单元采用线性编址方式，按顺序取出指令
  - **指令由操作码和地址码构成**。根据指令含义发出控制信号控制计算机的操作
  - 机器以运算器为中心，输入输出设备都要经过 CPU 与存储器间进行数据传送

#### 2、微型计算机系统

- **微型计算机系统概念**

![微型计算机系统概念](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/DTBWA39X25QkexCZdzHfIU6CMYX*tCOqpzkNvrpO*sM!/r/dL8AAAAAAAAA)

- **微处理器**
  - 微处理器分为执行部件 EU 和总线接口部件 BIU
  - **EU：**
    - 运算器的算术逻辑运算单元 ALU
    - 通用寄存器组
    - 标志寄存器 FLAGS
    - EC 单元控制系统等
  - **BIU**
    - 段寄存器组（CS、DS、ES、SS) 
    - 指令指针寄存器 IP 
    - 指令队列单元
    - 地址加法器
    - 总线控制系统等

![微处理器](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/FMHJ9jH8JmnjUGRz0IdmSXksqh*OTrwlgAlhQ0wiXP4!/r/dDEBAAAAAAAA)

#### 3、80X86寄存器

- **8086寄存器组**

![8086寄存器组](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/LQyh4wSQv2glYFzmMEb4WGXv6W3SUxY5VEKsfS*JAus!/r/dE8BAAAAAAAA)

- **数据寄存器**

  数据寄存器：包括 AX、BX、CX、DX 四个 16 位的通用寄存器。

  - AX (Accumulator）：作为累加器用，算术运算的主要寄存器

  - BX (Base）：基址寄存器

  - CX (Count）：计数器

  - DX (Data）：双精度运算时与 A 以 X 一起存放双操作数
  - 其中 DX 存放高字（高 16 位）, AX 存放低字（低 16 位）
  - 数据寄存器中每个寄存器又可以分为 **2 个 8 位的寄存器**：分别为 AH、AL, BH、BL, CH CL, DH、DL。**AH 为高字节（高 8 位）寄存器、AL 为低字节（低 8 位）寄存器**

![数据寄存器](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/FDwK.UQ*.YV9Ql05I.nZCK6vu0MiW1I4mmL3EfGPXeQ!/r/dL8AAAAAAAAA)

```java
//用DX、AX寄存器保存双精度数23456789H
表示为(DX)=2345H，(AX)=6789H，存放形式为:
DX 23|25  AX 67|89

用AX寄存器存放一个字1234H，表示为(AX)=1234H，存放形式为：
AX 12|34
```

- **地址寄存器**

  - 包括指针和变址寄存器 SI、Dl、SP、BP 四个 16 位寄存器。顾名思义，它们可用来存放**存储器的偏移地址**。另外，它们也可以作为通用寄存器用。严格地说，用来存放存储器偏移地址的寄存器都应该叫地址寄存器，如 BⅨ基址寄存器、IP 指令指针寄存器
  - Sl (Source Index）源变址寄存器，可用于存放**源缓冲区**的偏移地址。
  - DI (Destination Index）目的变址寄存器可用于存放**目的缓冲区**的偏移地址。
  - SP (Stack Pointer）堆栈指针寄存器，用于指出堆栈区的栈顶的偏移地址。
  - BP (Base Pointer）基址指针寄存器，用于指出堆栈区的某个单元的偏移地址

- **段寄存器**

  - CS (Code Segment）代码段寄存器，用于指出存放程序的代码段的段地址。
  - DS (Data Segment）数据段寄存器，用于指出存放数据的数据段的段地址
  - ES (Extra Segment）附加段寄存器，用于指出存放附加数据的附加段的段地址。
  - SS (Stack Segment）堆栈段寄存器，用于指出堆栈区的堆栈段的段地址。

- **控制寄存器**

  - 作用：
    - 用来**存储相关指令的某些执行结果**；
    - 用来**为CPU执行相关指令提供行为依据**；
    - 用来**控制CPU的相关工作方式**。
  - 8086CPU的标志寄存器有16位，其中存储的信息通常被称为**程序状态字PSW（标志位）**，简称flag。flag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义
- **IP 指令指针寄存器：**用来存放代码段中的偏移地址，指出当前正在执行指令的下一条指令所在单元的偏移地址。
  
  - FLAGS 标志寄存器：其中的某位代表 CPU 的一个标元最低位为 D0, 最高位为 D15。8086 CPU 的标志寄存器共有 9 个标志，分别为 6 条件码标志和 3 控制标志。其含义如下
  
- **运算结果标志位：**

  - ZF标志（ZeroFlag）：
    零位标志位，它记录相关指令执行后的结果是否为0，如果是0，那么ZF=1，如果结果不为0，那么ZF=0。
  - PF标志（ParityFlag）：
    奇偶标志位，它记录相关指令执行后，其结果的所有二进制位中1个个数是否为偶数，如果是偶数，PF=1，反之为0。
  - SF标志（SignFlag）：
    符号标志位，它记录相关指令执行后，其结果是否为负，如果结果为负，SF=1，如果非负，SF=0。
  - CF标志（Carry进位，Flag标志）：
    进位标志位，一般情况，进行无符号运算时，它记录运算结果的最高位向更高位的进位值，或从更高位的借位值，如果运算结果的最高位产生了一个进位或借位，那么其值为1，否则其值为0。
  - OF标志（Overflow溢出，Flag标志）：
    溢出标志位，在进行有符号数运算的时候，如果结果超出了机器所能表示的范围称为溢出，OF的值被置为1，否则OF的值为0。

- **状态控制标志位：**

  - TF标志（TrapFlag）：
    追踪标志位，当追踪标志被置为1时，CPU进入单步执行方式，即每执行一条指令产生一个单步中断请求，这中方式主要用于程序的调试。

  - IF标志（Interrupt-enable Flag）：
    中断允许标志位，用来决定CPU是否响应CPU外部的可屏蔽中断发出的中断请求，但不管该标志为何值，CPU都必须响应CPU外部的不可屏蔽中断所发出的中断请求，以及CPU内部产生的中断请求。
    当IF=1时，CPU可以相应CPU外部的可屏蔽中断发出的中断请求。

    当IF=0时，CPU不响应CPU外部的可屏蔽中断发出的中断请求。

    CPU的指令系统中也有专门的指令来改变标志位IF的值。
  
- 控制寄存器图

![控制寄存器](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/GOzGp5LJstblH9mhbFd4sHC6H5d.qVdS8BLzG69NLrs!/r/dL8AAAAAAAAA)

---

- **80X86**寄存器组 
  - **Intel 8086**、**80286**都是**16**位的寄存器。从**80386**开始，寄存器扩展为**32**位。

![**80X86**寄存器组 ](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/G8iRLlJye4yrXY4chJktIZG.5fGMy.vL2HE64JOSgY0!/r/dL8AAAAAAAAA)



#### 4、内存储器

- **存储单元**

  - 存储器被划分为若干个存储单元，每个存储单元从0开始顺序编号；例如：一个存储器有128个存储单元，编号从0~127。
  - 在汇编语言中，把存储单元分为字节单元、字单元、双字单元等，**称为存储单元的属性**。 
  - 存储单元中的数据称为存储单元内容，存储单元的**地址和内容**的表示形式为**用括号将地址括起来**以代表单元的内容。 	

  ```java
  如（3075AH）=12H
  	表示3075AH号单元中的内容是12H 
  	  （3075BH）=34H
  	表示3075BH号单元中的内容是34H 
  	若（37692H）=5678H
  	表示37692H单元和37693H单元一起存放5678H 
  	//注意A、B 、还是AB一起使用
  ```

  - 在存储的时候，高字节放在高地址单元，低字节放在低地址单元 。如图所示

  - 存储单元的地址和内容 

  ![存储单元的地址和内容 ](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/Y9xRk0jIxGuCVJFbEEPNiAyfYC6dx5jciG1**LzlGf0!/r/dMEAAAAAAAAA)

  - 存储单元还分为偶地址单元和奇地址单元。例如上图中的字节单元3075AH和字单元37692H都是偶地址单元，而字节单元3075BH是奇地址单元。

  - 由于字单元是由两个相邻的字节单元构成的，那么对于同一个地址而言，它既可以看成字节单元，又可以看成字单元。 

    - 如把上图中的字节单元**3075AH**看成是字单元，则：

    ​		（**3075AH**）**=3412H**

- **CPU对存储器的读写**

  - CPU要想进行数据的读写，必须和外部器件（标准的说法是芯片）进行三类信息的交互：

  - - 存储单元的地址（地址信息）
    - 器件的选择，读或写命令（控制信息）
    - 读或写的数据（数据信息）

  - 在计算机中专门有连接CPU和其他芯片的导线，通常称为总线。

  - - 物理上：一根根导线的集合；

    - 逻辑上划分为： 

      - 地址总线

      - 数据总线
      - 控制总线

  - 总线在逻辑上划分

  ![总线在逻辑上划分](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/3vMw*ZBTqx29VaC0*v6ggrtLNcL8d60fhSz0YMuWU3k!/r/dLYAAAAAAAAA)

  ```java
  //对于8086CPU，下面的机器码能够完成从3号单元读数据：
  机器码： 101000000000001100000000
  含义：从3号单元读取数据送入寄存器AX
  CPU接收这条机器码后将完成上面所述的读写工作。
  //机器码难于记忆，用汇编指令来表示，情况如下：
  机器码：101000000000001100000000
  对应的汇编指令：MOV AX,[3]
  含义：传送3号单元的内容到AX
  ```

  - **地址总线：**

    - CPU是通过地址总线来**指定存储单元的。**
    - **地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。**

    - 地址总线发送地址信息演示
    -  一个CPU有**N根地址总线**，则可以说这个CPU的地址**总线的宽度为N。**
    - 这样的CPU最多可以寻找**２的N次方个**内存单元。
    - CPU与内存或**其它器件之间的数据传送**是通过**数据总线**来进行的。
    - 数据总线的**宽度决定**了CPU和外界的**数据传送速度**。
    - 我们来分别看一下它们向内存中写入数据89D8H时，是如何通过数据总线传送数据的：

  ![地址总线发送地址信息演示](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/fNhgZwsKH3BDmOfQm*bWjui9Exs3QTRcFYX5bwBXoio!/r/dD4BAAAAAAAA)

  - **控制总线：**

    - CPU对外部器件的控制是通过控制总线来进行的。在这里控制总线是个**总称**，控制总线是一些不同**控制线的集合**。

    - 有多少根控制总线，就意味着CPU提供了对外部器件的**多少种控制**。

    - 所以，控制总线的宽度决定了CPU对外部器件的控制能力。

    - 前面所讲的内存读或写命令是由几根控制线综合发出的：

    - - 其中有一根名为读信号输出控制线负责由CPU 向外传送读信号，CPU 向该控制线上输出低电平表示将要读取数据；
      - 有一根名为写信号输出控制线负责由CPU向外传送写信号。

- **物理地址与逻辑地址**
  
  - CPU 对内存的访问是通过地址总线进行的，地址总线的每一个二进制组态对应一个存储单元，可作为该存储单元的地址
  
  - 在 80 X86 系统中一个实际的存储单元只存放 8 位二进制数，称为字节单元地址位数与存储空间有如下的关系
  
    - 若系统只有 1 根地址线 AO：则 AO 上有两个不同的信号 0 和 1, 可以表示 0 号和 1 号两个存储单
    - 若系统有 2 根地址线 A1、AO：则有四个不同的信号组合 00、01、10、11, 可以表示 0 号~3 号四个存储单元。
    - 若系统有 10 根地址线 A9~AO：则有 0 号~1023 号不同组合，可以表示 1024 个存储单元，寻址空间达到 1 KB。B (Byte）表示字节单元
    - 可以看出，若**地址位数为** n，则地址空间的大小为 **2^n** 个存储单元
  
  - **物理地址：**
  
    - 物理地址是内存**单元的真实地址**。存储单元的**物理地址是唯一**的
    - Intels8086 cpU 有 20 根地址线，因此其存储空间可达 20=1 M 字节单元。在 20 位地址线的存储空间中采用十六进制表示的物理地址范是 00000H~FFFFFH
  
  - **逻辑地址：**
  
    - 逻辑地址是用户编程时使用的地址，分为**段地址**和**偏移地址**两部分。
    - 在**8086**汇编语言中，把内存地址空间划分为若干逻辑段，每段由一些存储单元构成。
    - 用**段地址指出是哪一段**，**偏移地址标明是该段中的哪个单元**。段地址和偏移地址都是16位二进制数。 
    - 逻辑地址的形式：段地址:偏移地址
  
    ```java
    用十六进制分别表示的三个逻辑地址如下： 
    	3020:055AH
    	3021:054AH
    	2C43:432AH 
    ```
  
- **逻辑地址与物理地址的转换** 

  - 用户编程时采用的逻辑地址在**CPU**执行程序时都要转换成实际的物理地址，这个转换过程是由**CPU**中的地址加法器自动完成的。 
  - 转换公式为：**物理地址=段地址×10H+偏移地址** 

  ```java
  //例
  若逻辑地址为3020:055AH，其物理地址=3020H×10H+055AH=3075AH。
  ```

- **存储器分段**

  - **分段的概念** 

    - **8086CPU**的地址寄存器只有**16**位，如果直接从地址寄存器中发出地址信号，所能访问的存储空间就只有2^16=64KB**，达不到**20位地址线所提供的地址范围
    - 将存储器划分为若干逻辑段，每段最大**64K**字节单元。
    - 逻辑段的大小可变，每段最少**16**个字节单元，也可以**100**个、**1000**个到最大可达**65536**个字节单元。
    - 段地址和偏移地址构成逻辑地址。

    ​		例如：逻辑地址为1200:2650H。  

  - **段的类型**

    - **8086**汇编语言中把逻辑段分为四种类型，分别是代码段、数据段、附加段和堆栈段。 

         各段的逻辑地址对应表： 

    | 段名   | 段寄存器 | 偏移地址               |
    | ------ | -------- | ---------------------- |
    | 代码段 | CS       | IP                     |
    | 数据段 | DS       | BX、SI、DI等地址寄存器 |
    | 附加段 | ES       | BX、SI、DI等地址寄存器 |
    | 堆栈段 | SS       | SP或BP                 |

    ```java
    //段寄存器与其偏移地址如下，写出其相应的物理地址及含义。
     CS=1896H，IP=1655H
    当前要执行的指令的物理地址=18960H+1655H=19FB5H        
     DS=2896H，EA=1655H
    当前要访问的数据的物理地址=28960H+1655H=29FB5H
     ES=1896H，EA=2655H
    当前要访问的数据的物理地址=18960H+2655H=1AFB5H
     SS=1896H，SP=3655H
    当前要访问的堆栈的物理地址=18960H+3655H=1BFB5H
    ```

  - **段寄存器与内存的分段情况如图**

  ![段寄存器与内存的分段情况如图](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/0k2B7vwkRVPEIoZEnjXH1KWGXvKnUiyhZIQpxBSSzmg!/r/dL8AAAAAAAAA)

---



### 三、指令系统与寻址方式

```wiki
汇编指令是什么？
机器如何去寻指？
指令中的操作数在哪儿存放机器又是如何去寻数？
为什么要有寻址方式？
```

#### 1、汇编语言指令

- **机器指令**

  - 机器指令也称作代码指令。它是计算机能识別的一组二进制代码。

  ```java
  例 1 用机器指令实现将 7 加 3 的结果存入 5 号字节单元的操作。
  1011000000000111 B
  B007 H
  把数“7”送到 AL 中。
  0000010000000011 B
  0403 H
  把数“3"与 AL 内容相加，结果放在 AL 中
  101000100101000000000000 B
  A25000 H
  把 AL 中的内容送到地址为 5 的存储单元中。共需要三条机器指令实现。
  ```
  - 机器指令可以用二进制表示也可以用十六进制表示，指令的长度也可以不一样。如前两条指令的长度为 2 字节，第三条指令的长度为 3 字节
  
  ```java
  //用汇编指令实现将 7 加 3 的结果存入 5 号字节单元的操作
  
  MOV AL, 7
  ADD AL, 3
  MOV DS: 5], AL
  ```
  
- **汇编指令**

  - **指令格式**

    汇编指令由操作码字段和操作数字段构成。

    ```java
    操作码字段  操作数字段
    
    //例 1 单操作数指令（一地址指令）
    INC AX；加 1 指令 
    INC BL；加 1 指令 
    PUSH AX；进栈指令。
    JMP LA1; 无条件转移指令
    
    //例 2 双操作数指令（两地址指令）
    MOV AX, 5 传送指令。
    ADD AX, BX；加法指令{AX是目的操作数，BX是源操作数}
    目的操作数源操作数
    
    //例 3 三操作数指令（三地址指令）
    IMUL EBX, [ESI],7; 乘法指令。（80386 机器指令）
    
    //例 4 无操作数指令（零地址指令）
    CBW；字节转换为字指令 
    CLC；进位标志 CF 清零
    NOP；不操作指令
    HLT；停机指令
    ```

  - **指令属性：**

    (1) 指令长度ー一根据指令的**功能不同，指令的长度也不ー样**（以字节为单位）。分为单字节指令、双字节、三字节、四字节和多字节指令等。

     (2) 指令的执行时间一一**指令的执行时间**（以 CPU 时钟周期为单位）也是一个重要的属性。它影响程序的执行速度，因此采用较少执行时间的指令可提高程序的运行速度

- **指令系统：**

  计算机所能执行的各种代码指令的集合。

  - **指令的分类**：8086 的指令共分为六大类。分别是
    - 数据传送指令
    - 算术运算指令
    - 逻辑运算指令
    - 字符串处理指令
    - 控制与转移指令
    - 处理机控制指令

- **指令存取：**

  ```java
  指令在什么地方？
  指令和数据有区别吗？
  怎么取下一条指令？
  怎么取数据？
  ```

  - **CS 和 IP**

    是 8086 cPU 中最关键的寄存器，它们指示了 CPU 当前要读取指令的地址。

    - CS 代码段寄存器

      存放代码的**段地址**

    - P 指令指针寄存器

      存放代码的**偏移地址**

  - **8086CPU取指过程**

    (1) 从 CS: IP 指向内存单元读取指令，读取的指令进入指令缓冲器

     (2) IP=P+所读取指令的长度从而指向下一条指令

     (3) 执行指令。转到步骤（1），重复这个过程。

  - **关于CS和IP**

    - 内存中指令和数据没有任何区别，都是二进制信息，CPU 在工作的时候把有的信息看作指令，有的信息看作数据。
    - CPU 根据什么将内存中的信息看作指令？
    - CPU 将 CS: IP **指向的内存单元中的内容**看作指令。
    - CPU 将 CS、IP 中的内容当作指令的段地址和偏移地址，用它们合成指令的物理地址，到内存中读取指令码，执行

  - **修改CS、IP的指令**

    - 在 CPU 中，程序员能够用指令读写的**部件只有寄存器**，程序员可以**通过改变寄存器中的内容**实现对 CPU 的控制。
    - CPU 从何处执行指令是由 CS、IP 中的内容决定的，程序员可以通过改变 CS IP 中的内容来控制 CPU 执行目标指令
    - **我们如何改变 CS、IP 的值呢？**
    - 8086 CPU 必须提供相应的指令
    - 先回想我们如何修改 AX 中的值？
    - mov 指令不能用于设置 CS、IP 的值 8086 CPU 没有提供这样的功能
    - **8086 CPU 为 CS、P 提供了另外的指令来改变它们的值：转移指令**

    ```java
    //Jmp 指令
    跳转指令，同时修改 CS、IP 的内容。
    
    //格式：
    jmp 段地址：偏移地址
    
    //例如：
    jmp 2 AE3: 3 
    Jmp 3: 0 B16
    
    //功能
    用指令中给出的段地址修改 CS，偏移地址修改 IP
    
    ######################################
    
    //Jmp 指令：
    仅修改 IP 的内容：
    
    //格式
    jmp 某一合法寄存器例如：
    
    //例如
    Jmp ax（类似于 mov IP, ax)
    jmp bx
    
    //功能：
    用寄存器中的值修改 IP。
    ```

  - **修改CS、IP的指令的例子：**

  ![修改CS、IP的指令的例子：](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/wLmPouzOLDdmHqmR7wrZzospmwOqXUs8IleA3Z3*SSU!/r/dLsAAAAAAAAA)



- **代码存放的地方-代码段**

  - 对于 8086 PC 机，在编程时，可以根据需要，**将组内存单元定义为一个段**

  - 可以将长度为 **N (N≤64 KB）**的一组代码，存在组地址连续、**起始地址为 16 的倍数**的内存单元中，这段内存是**用来存放代码的，从而定义了一个代码段**

  ```java
  //例如
  
  mov ax,0000  (B80000)
  
  add ax,0123  (052301)
  
  mov bx、aX   (8B D8)
  
  jmp bx       (FF E3)
  
  这段长度为 10 字节的指令，存在从 123 B0 H-123 B9 H 的一组内存单元中，我们就可以认为，123B0H-123B9 H 这段内存单元是用来存放代码的，是一个代码段，它的段地址为 123BH
  ```

  - **如何使得代码段中的指令被执行呢？**

    将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU 并不会由于这种安排，就自动地将我们定义得代码段中的指令当作指令来执行

    **CPU 只认被 CS: IP 指向的内存单元中的内容为指令**。所以要将 CS: IP 指向所定义的代码段中的第一条指令的首地址

    **CS=123BH    IP=0000H**

- **数据存取：**

  ```java
  例子：我们要读取 10000어单元的内容可以用如下程序段进行
  
  mov bx,1000H
  mov ds ,bx 
  mov al, [0]
  上面三条指令将 10000H (1000:0) 中的数据读到 al 中
  ```

  ```java
  //指令 mov al , []
  已知的 mov 指令可完成的两种传送功能
   (1) 将数据直接送入寄存器
   (2) 将一个寄存器中的内容送入另一个寄存器中。
  **mov 指令还可以将一个内存单元中的内容送入一个寄存器
  
  //从哪个内存单元送到哪个寄存器中呢？
  mov 指令的格式
  mov 寄存器名，内存单元地址
  
  “[...]”表示一个内存单元，“[...]”中的 0 表示内存单元的偏移地址。
  那么内存单元的段地址是多少呢？
  执行指令时，8086 cPU 自动取 DS 中的数据为内存单元的段地址。
  
  //如何用 mov 指令从 100000H中读取数据？
  10000 H 表示为 10000:0（段地址：偏移地址）
  将段地址 1000 H 放入 ds
  用 mov al,[0]完成传送
  （mov 指令中[]说明操作对象是一个内存单元，[]中的 0 说明这个内存单元的偏移地址是 0, 它的段地址默认放在 ds 中）
  
  //如何把 1000 H 送入 ds?
  传送指令 mov ax,1
  相似的方式 mov ds,1000 H? 
  8086 CPU 不支持将数据直接送入段寄存器的操作，ds 是一个段寄存
  （硬件设计的问题）mov ds,1000 H 是非法的
  
  数据 → 一般的寄存器 → 段寄存器
  ```

----

**停止到ppt26页**

**开始于88页**

----

#### 2、指令的寻址方式

---

- 对于数据操作数而言，可能存放在**内存中**，也可能存放在**CPU的寄存器**当中，还有可能**直接写在指令当中**。如果不在内存中存放，**操作数就没有逻辑地址的概念**，CPU**不用访问存储器**就能直接得到操作数，如果操作数在内存中，那么操作数的偏移地址以**有效地址(EA)**表示

- 寻址方式：**指令中提供操作数或操作数地址的方式**

  - 有效地址 EA (Effective Address）： 操作数的偏移地址

  - 操作数的物理地址=段地址 x10H+**EA**

  -  **寻址方式的分类**

    - 与**转移地址有关**的寻址方式

    - 与**数据有关**的寻址方式(三类)
      -  **立即寻址方式**
      - **寄存器寻址方式**
      - **第三类：**
        - 直接寻址方式
        - 寄存器间接寻址方式
        - 寄存器相对寻址方式
        - 基址变址寻址方式
        - 相对基址变址寻址方式

  - **立即寻址方式**

  ![立即寻址方式](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/X42WOoclSqqoODwfhv1PD51ekBr92dLUdF279w4YnD8!/r/dLYAAAAAAAAA)

  ```java
  //例 :
  MOV  AX，3060H
  MOV  AL，5
  MOV  BL，0FFH 
  MOV  BX，0A46DH
  MOV  CH，23
  ```

  - **寄存器寻址方式**

  ```java
  8 位寄存器：AH、AL, BH、BL
  	CH、CL, DH、DL
  
  16 位寄存器：AX、BX、CX、DX
  	SI、DI、BP、SP
  
  例 1 MOV AX, BX；两个操作数（16 位都是寄存器寻址
  执行前：(AX) =0000H (BX) =1234 H 
  执行后：(AX) =1234 H (BX) =1234 H
  ```

  - **直接寻址方式**#######往下都是存储器寻址方式

    - 存储器读操作

    ![存储器读操作](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/YTmtq13RcevuvjNl6wO82AegOYsQfZIe42j*AB.UqKE!/r/dLYAAAAAAAAA)

    - 存储器写操作

    ![存储器写操作](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/FX2AfjVVtRyxlsy0dNctdYUwfM9Dl42uRliEPYMEV1E!/r/dIMAAAAAAAAA)

    - 符号地址
    
    ```java
    //例 3 MOV AX, VALUE
    MOV AX, VALUE
    有效地址：EA= VALUE=1000 H
    设 VALUE=1000 H
    物理地址= (DS) ×10 H+EA
    设（DS) =1500 H=15000 H+1000 H=16000 H 若（16000 H) =5678 H 
    执行指令后：(AX) =5678 H
    ```
    
    - 段超越
    
    ```java
    //例 4 VALUE EQU1000 H
    MOV AX, DS: VALUE MOV AX, ES VALUE
    若已知（ES) =3600 H, EA= VALUE=1000어 则指令源操作数的物理地址计算为
    物理地址= (ES) x10 H+EA
    36000 H+1000 H=37000 H
    若（37000H) =9091 H
    执行第二条指令后：(AX) =9091 H
    ```

  - **寄存器间接寻址方式**

![寄存器间接寻址方式](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/bCm.u72KFzgPNzZcZljAl2ZVyz6DXDRj2o9geq*V.8A!/r/dFQBAAAAAAAA)

- **寄存器相对寻址方式**

![寄存器相对寻址方式](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/TJv0kQUDWpqXnrAgZAKXX5GgrCU4lGLvheOgNSqdfvU!/r/dL4AAAAAAAAA)

  - **基址变址寻址方式 **

    操作数的物理地址	**=(DS)×10H**＋**(BX) + ( SI )** 

     			**=(DS)×10H**＋**(BX) + ( DI )**                                 

     			**=(SS)×10H**＋**(BP) + ( SI )** 

    ​			**=(SS)×10H**＋**(BP) + ( DI )**

    ```java
    例1  MOV AX，[BX+DI]
    执行前：（DS）=2100H，（BX）=0158H
                   （DI）=10A5H，（AX）=0FFFFH
    		（221FD）=34H，（221FE）=12H
    有效地址：
         EA=（BX）+（DI）= 0158+10A5 =11FDH
    物理地址 =21000+11FD =221FDH
    执行后：（AX）=1234H
    ```

- **相对基址变址寻址方式** 

  操作数的物理地址

  **=(DS)×10H**＋**(BX) + ( SI ) + 8**位（**16**位）位移量

  **=(DS)×10H**＋**(BX) + ( DI ) + 8**位（**16**位）位移量                                

  **=(SS)×10H**＋**(BP) + ( SI ) + 8**位（**16**位）位移量

  **=(SS)×10H**＋**(BP) + ( DI ) + 8**位（**16**位）位移量 

  ```java
  例1  MOV AX，MASK[BX][SI]
  或  MOV AX，[MASK+BX+SI]
  或  MOV AX，[BX+SI].MASK
  有效地址：EA=MASK+（BX）+（SI）
  物理地址= （DS）×10H+EA 
  ```

- **例题**

  ```java
  //已知(DS)=1500H，(SS)=2500H， (ES)=4350H，
  TABLE=4780H，VALUE=7567H，(BX)=4080H
  指出下列指令的寻址方式，并求操作数的物理地址。
  
  MOV  AX,105
  MOV  AL,BH
  MOV  AX,DS:[1250]
  MOV  AX,TABLE
  MOV  AX,[BX]
  MOV  CX,[VALUE]
  MOV  DS:[3A47H], AH
  MOV  DL，ES:[TABLE]
  MOV  [VALUE]，BH
  MOV  AX，SS:[BX]
  MOV  AX，3040H
  MOV  AX，CX
  
  //已知(DS)=1500H，(SS)=2500H，(ES)=4350H，(BX)=4080H，(BP)=7567H，(SI)=9578H，(DI)=8456H，COUNT=2345H，TOP=6930H，指出下列指令的寻址方式，并求操作数的有效地址EA和物理地址。
  MOV  TOP[BX][SI]，AX
  MOV  AH，ES:[BX]
  MOV  [SI+BP]，CX
  MOV DX, COUNT [DI]
  
  //指出下列指令的错误
   MOV AX, [BX][BP]
   ADD AL, SS:[DX].1200H
   MOV DH, 256
   MOV AX, CL
   SUB [CX], VALUE
   MOV TOP[SI][DI], BX
   MOV ES:[SI], [BX]
  ```

- **寻址方式选择：**
  - 常用的寻址方式有7种之多,其中**立即寻址**和**寄存器寻址**无论从指令长度和指令执行时间都比存储器寻址要好，但是也要根据具体情况选用。
  - 学会使用寻址方式是理解指令作用的关键，也是掌握程序设计技巧的一种途径。 

### 四、汇编语言程序设计

- [了解“预编译、编译、汇编、链接”这四个过程](http://m.elecfans.com/article/663750.html)

```java
C语言的编译链接过程要把我们编写的一个c程序（源代码）转换成可以在硬件上运行的程序（可执行代码），需要进行编译和链接。编译就是把文本形式源代码翻译为机器语言形式的目标文件的过程。链接是把目标文件、操作系统的启动代码和用到的库文件进行组织形成最终生成可执行代码的过程

从图上可以看到，整个代码的编译过程分为编译和链接两个过程，编译对应图中的大括号括起的部分，其余则为链接过程。

过程图解如下：

编译过程又可以分成两个阶段：编译和汇编。
编译

编译是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码，源文件的编译过程包含两个主要阶段：

第一个阶段是预处理阶段，在正式的编译阶段之前进行。预处理阶段将根据已放置在文件中的预处理指令来修改源文件的内容。如#include指令就是一个预处理指令，它把头文件的内容添加到.cpp文件中。这个在编译之前修改源文件的方式提供了很大的灵活性，以适应不同的计算机和操作系统环境的限制。一个环境需要的代码跟另一个环境所需的代码可能有所不同，因为可用的硬件或操作系统是不同的。在许多情况下，可以把用于不同环境的代码放在同一个文件中，再在预处理阶段修改代码，使之适应当前的环境。

主要是以下几方面的处理：

（1）宏定义指令，如 #define a  b

对于这种伪指令，预编译所要做的是将程序中的所有a用b替换，但作为字符串常量的 a则不被替换。还有 #undef，则将取消对某个宏的定义，使以后该串的出现不再被替换。

（2）条件编译指令，如#ifdef，#ifndef，#else，#elif，#endif等。

这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预编译程序将根据有关的文件，将那些不必要的代码过滤掉。

（3） 头文件包含指令，如#include "FileName"或者#include 等。

在头文件中一般用伪指令#define定义了大量的宏（最常见的是字符常量），同时包含有各种外部符号的声明。采用头文件的目的主要是为了使某些定义可以供多个不同的C源程序使用。因为在需要用到这些定义的C源程序中，只需加上一条#include语句即可，而不必再在此文件中将这些定义重复一遍。预编译程序将把头文件中的定义统统都加入到它所产生的输出文件中，以供编译程序对之进行处理。包含到c源程序中的头文件可以是系统提供的，这些头文件一般被放在 /usr/include目录下。在程序中#include它们要使用尖括号（< >）。另外开发人员也可以定义自己的头文件，这些文件一般与c源程序放在同一目录下，此时在#include中要用双引号（""）。

（4）特殊符号，预编译程序可以识别一些特殊的符号。

例如在源程序中出现的LINE标识将被解释为当前行号（十进制数），FILE则被解释为当前被编译的C源程序的名称。预编译程序对于在源程序中出现的这些串将用合适的值进行替换。

预编译程序所完成的基本上是对源程序的“替代”工作。经过此种替代，生成一个没有宏定义、没有条件编译指令、没有特殊符号的输出文件。这个文件的含义同没有经过预处理的源文件是相同的，但内容有所不同。下一步，此输出文件将作为编译程序的输出而被翻译成为机器指令。

第二个阶段编译、优化阶段，经过预编译得到的输出文件中，只有常量；如数字、字符串、变量的定义，以及c语言的关键字，如main,if,else,for,while,{,}, +,-,*,\等等。

编译程序所要作得工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。

优化处理是编译系统中一项比较艰深的技术。它涉及到的问题不仅同编译技术本身有关，而且同机器的硬件环境也有很大的关系。优化一部分是对中间代码的优化。这种优化不依赖于具体的计算机。另一种优化则主要针对目标代码的生成而进行的。

对于前一种优化，主要的工作是删除公共表达式、循环优化（代码外提、强度削弱、变换循环控制条件、已知量的合并等）、复写传播，以及无用赋值的删除，等等。

后一种类型的优化同机器的硬件结构密切相关，最主要的是考虑是如何充分利用机器的各个硬件寄存器存放的有关变量的值，以减少对于内存的访问次数。另外，如何根据机器硬件执行指令的特点（如流水线、RISC、CISC、VLIW等）而对指令进行一些调整使目标代码比较短，执行的效率比较高，也是一个重要的研究课题。

汇编

汇编实际上指把汇编语言代码翻译成目标机器指令的过程。对于被翻译系统处理的每一个C语言源程序，都将最终经过这一处理而得到相应的目标文件。目标文件中所存放的也就是与源程序等效的目标的机器语言代码。目标文件由段组成。通常一个目标文件中至少有两个段：

代码段：该段中所包含的主要是程序的指令。

该段一般是可读和可执行的，但一般却不可写。

数据段：主要存放程序中要用到的各种全局变量或静态的数据。一般数据段都是可读，可写，可执行的。

UNIX环境下主要有三种类型的目标文件：

（1）可重定位文件

其中包含有适合于其它目标文件链接来创建一个可执行的或者共享的目标文件的代码和数据。

（2）共享的目标文件

这种文件存放了适合于在两种上下文里链接的代码和数据。第一种是链接程序可把它与其它可重定位文件及共享的目标文件一起处理来创建另一个 目标文件；第二种是动态链接程序将它与另一个可执行文件及其它的共享目标文件结合到一起，创建一个进程映象。

（3）可执行文件

它包含了一个可以被操作系统创建一个进程来执行之的文件。汇编程序生成的实际上是第一种类型的目标文件。对于后两种还需要其他的一些处理方能得到，这个就是链接程序的工作了。

链接过程

由汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。

例如，某个源文件中的函数可能引用了另一个源文件中定义的某个符号（如变量或者函数调用等）；在程序中可能调用了某个库文件中的函数，等等。所有的这些问题，都需要经链接程序的处理方能得以解决。

链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够诶操作系统装入执行的统一整体。

根据开发人员指定的同库函数的链接方式的不同，链接处理可分为两种：

（1）静态链接

在这种链接方式下，函数的代码将从其所在地静态链接库中被拷贝到最终的可执行程序中。这样该程序在被执行时这些代码将被装入到该进程的虚拟地址空间中。静态链接库实际上是一个目标文件的集合，其中的每个文件含有库中的一个或者一组相关函数的代码。

（2） 动态链接

在此种方式下，函数的代码被放到称作是动态链接库或共享对象的某个目标文件中。链接程序此时所作的只是在最终的可执行程序中记录下共享对象的名字以及其它少量的登记信息。在此可执行文件被执行时，动态链接库的全部内容将被映射到运行时相应进程的虚地址空间。动态链接程序将根据可执行程序中记录的信息找到相应的函数代码。

对于可执行文件中的函数调用，可分别采用动态链接或静态链接的方法。使用动态链接能够使最终的可执行文件比较短小，并且当共享对象被多个进程使用时能节约一些内存，因为在内存中只需要保存一份此共享对象的代码。但并不是使用动态链接就一定比使用静态链接要优越。在某些情况下动态链接可能带来一些性能上损害。

我们在Linux使用的gcc编译器便是把以上的几个过程进行捆绑，使用户只使用一次命令就把编译工作完成，这的确方便了编译工作，但对于初学者了解编译过程就很不利了，下图便是gcc代理的编译过程：

从上图可以看到：

//预编译
将.c 文件转化成 .i文件
使用的gcc命令是：gcc –E
对应于预处理命令cpp

//编译
将.c/.h文件转换成.s文件
使用的gcc命令是：gcc –S
对应于编译命令   cc –S

//汇编
将.s 文件转化成 .o文件
使用的gcc 命令是：gcc –c
对应于汇编命令是  as

//链接
将.o文件转化成可执行程序
使用的gcc 命令是： gcc
对应于链接命令是  ld

总结起来编译过程就上面的四个过程：预编译、编译、汇编、链接。了解这四个过程中所做的工作，对我们理解头文件、库等的工作过程是有帮助的，而且清楚的了解编译链接过程还对我们在编程时定位错误，以及编程时尽量调动编译器的检测错误会有很大的帮助的。
```
- **编译过程**

![编译过程](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/ks96ysOGhZtIqcZiQWywg1.E.V1N2bI9DVG9CFQAN3Y!/r/dLYAAAAAAAAA)

- **GCC总程序控制**

![GCC总程序控制](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/fKfD47MrRxgsLYvUgwuCGuoCeSleUWa6Tr9XXG0UZJ4!/r/dMAAAAAAAAAA)



```java
1. 为什么要有伪指令？
2. 程序是怎么运行和加载的,运算结果怎样显示在屏幕上？
3. 含有键盘输入的程序如何编写？
4. 完整的汇编语言程序都有哪些要求？
5. 简化的程序格式是不是更方便？
```

#### 1、汇编语言程序设计初步

- **第一个汇编语言程序**

```java
	编写一个汇编语言程序，实现下列公式计算。  
       假设X=4，Y=5   
      Z=  [(X＋Y)×8－X]/ 2
    
设计思路一：
（1）设公式中出现的三个变量X、Y、Z是8位带符号数；
（2）用算术运算指令实现加减乘除运算；
（3）指令顺序按照运算顺序书写。 

程序段：
	MOV AL,X		；AL←X
	ADD AL,Y		；AL←X+Y      加法
	MOV BL,8		；BL←8
	IMUL BL		；AX←AL×8    乘法
	MOV BL,X		；BL←X
	MOV BH,0		；BH←0
	SUB AX,BX		；AX←AX－X    减法
	MOV BL,2		；BL←2
	IDIV BL     ；AX÷2 除法，商在				    AL，余数在AH中
	MOV Z,AL		；Z←商
	MOV Z1,AH		；Z1←余数
	
///////###########////////

设计思路二：
（1）公式中出现的三个变量X、Y、Z是带符号数，在数据段中定义；
（2）用算术运算指令实现加减运算；
（3）将操作数左移3位二进制位数代替乘以8运算，操作数右移1位相当于除以2；
（4）指令在代码段中，指令顺序按照运算顺序书写。

完整的程序如下：
；abc.asm  公式计算

DATA  SEGMENT       ；数据段定义伪指令
	X DW 4		        ；定义X为字单元，值为4
	Y DW 5
	Z DW ?		        ；定义Z为空单元
DATA  ENDS	        ；数据段结束   

CODE  SEGMENT 		   ；代码段定义伪指令
ASSUME CS:CODE,DS:DATA    ；指定段寄存器与对应段名
START:MOV  AX,DATA 
	MOV  DS,AX	        ；将数据段段地址送入DS
	MOV  BX, X 
	MOV  AX, Y
	ADD  AX,BX	        ；加法
	MOV  CL,3
	SAL  AX,CL	        ；算术左移3次，相当于乘以8
	SUB  AX,X	          ；减法
	SAR  AX,1	          ；算术右移1次，相当于除以2
	MOV  Z,AX
	MOV  AH,4CH	        ；此两句为结束程序，返回DOS
	INT  21H   
  CODE  ENDS	       	；代码段结束
  END  START	        ；整个程序结束伪指令
```



#### 2、伪指令

- **段定义伪指令**

  - 段定义伪指令可用来定义各种类型的段。

    格式如下：    段名  **SEGMENT  [**类型参数**]**

    ​                                    **……**

    ​                       段名  **ENDS**

    **SEGMENT**和**ENDS**必须成对使用，表示段的开始和结束

  - **类型参数：**

    **（1）定位类型**

    ​	PARA    该段的起始地址必须为小段的首地址，即段地址的十 

    ​             六进制数最低位为0

    ​	BYTE    该段可以从任意地址开始

    ​	WORD   该段必须从字边界开始，即段的起始地址为偶数

    ​	DWORD  该段必须从双字边界开始，即段地址的十六进制数最

    ​                 低位应为4的倍数

    ​	PAGE   该段必须从页边界开始，即段地址的十六进制数最低两

    ​             位为00（能被256整除）

    如果不指出定位类型，系统默认为PARA。

    **（2）组合类型**

    ​	PRIVATE   该段为私有段，连接时不与其他同名段合并

    ​	PUBLIC     连接时可与其他模块中的同名段按顺序连接成一个段

    ​	COMMON  表示该段与其他模块中的同名段有相同的起始地址，

    ​                     如果连接将产生覆盖；连接后段的长度为同名段中

    ​                    的最长者

    ​	STACK       表示该段为堆栈段

    ​	AT 表达式   该段直接定位在表达式指出的位置上如果不指定组

    ​                  合类型，系统默认为PRIVATE。

    **（3）类别标识**

    ​      在引号中给出段的类型名，在连接时，类别标识相同的段放

    在连续的存储区中。

    例如，用’STACK’来标识该段为堆栈段 

- **ASSUME**伪指令 

  - **ASSUME**伪指令用于指明**段寄存器与段的对应关系**，格式为：

    **ASSUME** 段寄存器：段名，**[**段寄存器：段名，**…]**

    如果不使用**ASSUME**伪指令，系统就无法获知用户定义的段都有哪些，**进而就不能正确地划分段。**

- **数据定义伪指令格式为：**

  [存储单元名]  DB（或DW、DD等伪指令） 操作数

  其中：

  （1）存储单元可以起名也可以不要名字

  （2）数据定义伪指令

  ​		DB   	定义字节单元

  ​		DW  	定义字单元

  ​		DD  	定义双字单元

  ​		DQ  	定义四字单元

  ​		DT  	定义十字节单元

  （3）操作数用于指出存储单元的内容即该单元的值。  

  ​	一条数据定义伪指令可以给多个存储单元赋值。

  ​    需要说明的是确定存储单元的内容时要与存储单元的属性一致。 

- **其它伪指令**

  - **赋值伪指令**

    在程序中多次出现同一个表达式时，可以用**EQU**定义一个符号来代表表达式，以简化书写。与**EQU**伪操作相似，等号**=**伪操作也可以给表达式赋值，且允许对一个符号多次重复定义；而**EQU**则不允许。

  ```java
  例：CONT  EQU  125*3.14
         STR   EQU  ‘ RIGHT’
         SUM  EQU  0
         BUFF=56
         PASS=2034H
         BUFF=56H
  ```

  - **模块定义伪指令** 

    在汇编语言中，可以将程序设为多个模块，每个模块完成独立的功能。因此，每个模块可用模块定义伪指令定义名称和结束标识。格式为：

    ​                  **[NAME** 模块名**]**

       			**……**

    ​			**END**  起始标号

    其中，**NAME**伪指令可以缺省。如果缺省，则以该模块的源程序名作为模块名。

    ​        **END**伪指令不能缺省。其后的起始标号可以是程序的第一条汇编指令的标号**START**，或者是主过程名。

  - **地址计数器** 

    地址计数器**$**表示当前的偏移地址值。

    如果用在数据段的存储单元定义中，可写成：

       **ABC  DW  1**，**2**，**$+3**，**4**

    实际存储显示：

    如果用在转移指令中：

      **JMP  $+5**

    则无条件跳转到当前指令的偏移地址**+5**单元继续执行。 

  - **设置偏移地址伪指令**

    当前的偏移地址可以用ORG伪指令定义。

    如果用在数据段中，该指令可以确定存储单元的偏移地址，例如将X单元的偏移地址定义为0020H，该单元的内容为5，即(DS：0020H)=5。伪指令如下：

    ​	DATA  SEGMENT

     		ORG  0020H

    ​	  	 X  DW  5

    ​	DATA  ENDS

    如果用在代码段中，可从指定的单元开始存放并执行指令。

    ```java
    例如从代码段的100H开始执行：
      	          ORG  100H
    START: MOV AX,X	；标号START设置为100H
    		   MOV BX,Y
    		   ADD AX,BX
    ```

  - **操作符**

    在汇编指令中可以使用一些操作符，汇编程序编译时将这些操作符变为相应的数值回送或者定义属性。

    （1）回送偏移地址值OFFSET

    ​		MOV BX, OFFSET X           

    ​         ；将X单元的偏移地址传送给BX

    ​		MOV AX, OFFSET START   

    ​       ；将标号START的偏移地址传送给AX

    （2）回送段地址值SEG

    ​		MOV BX,SEG X	        

    ​          ；将X单元的段地址传送给BX

    ​		MOV AX, SEG START	       

    ​        ；将标号START的段地址传送给AX

    （3）类型回送操作符TYPE

    ​		MOV BX,TYPE X  

    ​            ；如果X是字节单元，则回送值为1，即  BX←1；                                   

    若是字单元，值为2，双字单元，值为4

    （4）属性操作符PTR

    ​		MOV BYTE PTR [BX],10	   

    ​            ；定义目的操作数为字节单元

    ​		MOV WORD PTR [SI],20	   

    ​          ；定义目的操作数为字单元

    （5）类型操作符LABEL

    ​		X  LABEL BYTE       

    ​        ；X单元的类型定义为BYTE字节型，也可以定 义为 WORD字型、DWORD双字型等 

  - **注释伪指令**

    - 分号“；”后面的内容为注释。
    - 编写程序时最好加入注释，便于以后的阅读和修改。

#### 3、基本汇编指令

-   **数据、栈及查表**

  - **MOV**传送指令

     **MOV**传送指令是双操作数指令，**SRC**为源操作数、**DST**为目的操作数。要求两个操作数的属性必须一致。

    格式：**MOV    DST**，**SRC**

    ​             目的操作数，源操作数

  - **数据交换指令XCHG**

    XCHG指令是双操作数指令，指令的功能是将两个操作数的内容互换。要求必须有一个操作数是寄存器，而且两个操作数的属性必须一致。操作数不能为立即数。

    格式：**XCHG  OPR1**，**OPR2**

    ```java
     	XCHG  AX，BX    ；寄存器AX和BX的内容互换
    	XCHG  [BX]，AL  ；AL寄存器的内容和字节型 
                      存储单元的内容互换
    	XCHG  CX，X[SI]  ；CX寄存器的内容和字型存
                       储单元的内容互换
    ```

  - **进栈和出栈指令**

    ```java
    （1）PUSH进栈指令   
    格式：  PUSH  SRC
    执行操作：（SP）←（SP）-2
    		        ((SP)+1，(SP))←(SRC)
    先将堆栈指针SP减2，再将操作数SRC入栈。要求SRC必须是字。
            		PUSH  AX      
    （2）POP出栈指令   
    格式： POP  DST
    执行操作：(DST) ←((SP)+1，(SP))  
              	      （SP）←（SP）+2
    将堆栈指针所指字单元的内容弹到操作数DST中，再将SP加2。
           		POP  AX
           		
    //例已知(AX)=95E3H，(BX)=1986H，(SP)=0010H，(SS)=1250H，将AX、BX压栈保存。画出入栈过程。
         执行指令：   PUSH  AX
    			   				PUSH  BX
    入栈过程示意：
    ```

    

---



### 五、分支程序设计

```java
1．分支程序结构有哪几种？
2．都有哪些指令可以实现分支？
3．可以对二进制的某一位操作的指令有哪些？
4. 菜单程序如何设计?
//重点
分支结构的概念
位运算的分支程序
深入分析转移特征
走向分支
```

#### 1、分支的概念

- **分支的结构**

  **1**．两路分支结构

  **2**．多级分支结构

  **3**．多路分支结构

```java
//示例5-1 设计分支程序，
//实现下列公式计算。
//X、Y为字型。假设X单元中保存三个数：9，-6，34，分别作判断和计算。
      X^2    	 X＜0
 Y=   2X+3 	   0≤X＜10
	    X/6      X≥10	
	    
//思路
（1）在数据段中定义2个变量X、Y，均为带符号数；
（2）在X单元中分别取出三个字作判断，根据X的大小作分支转移；
（3）采用寄存器相对寻址方式(MOV AX, X[SI])分别取出X的三个值；
（4）标号OUT1是各路分支的公共出口。

//程序
;5-1.asm  用正常程序格式编写分支程序
data segment
  x dw 9,-6,34
  y dw 3 dup(?)
data ends
code segment 
assume cs:code,ds:data
start:
mov ax,data
mov ds,ax
mov cx,3			；循环三次
mov si,0				
let0:
mov ax,x[si]			；取出X
cmp ax,0			；X ≥0 ？
jge let1				；是，转到let1
mov bx,ax			；否，计算X*X
imul bx				
jmp out1			；跳到公共出口out1
let1:
cmp ax,10			；X ≥10 ？
jge let2				；是，转到let2
sal ax,1			；否，计算2X+3
add ax,3
jmp out1			；跳到公共出口out1
let2:
mov bl,6			；计算X/6
idiv bl				；商在al，余数在ah
out1:
mov y[si],ax			；保存Y
add si,2
dec cx				；CX-1
cmp cx,0				
jnz let0				；CX≠0转移到let0
mov ah,4ch			；CX=0，程序结束
int 21h
code ends
end start
```

- **分支程序框图**

![分支程序框图](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/sW35Pl*HfseqKXZ3n4eJ2EXfGfAdYDIR5ZF7UjXEcEw!/r/dL4AAAAAAAAA)

#### 2、与分支有关的指令

- **转移地址的寻址**

  - 段内转移
    - 段内直接转移
    - 段内间接转移

  - 段间转移
    - 段间直接转移
    - 段间间接转移

#### 3、位操作的分支程序

39页

#### 4、深入分析转移特征

---



### 六、循环程序设计

#### 1、循环的概念

#### 2、循环指令

#### 3、串处理

#### 4、多重循环



---



### 七、子程序设计

#### 1、子程序的概念

#### 2、调用和返回

#### 3、过程定义

#### 4、现场保护

#### 5、子程序参数传递

#### 6、嵌套与递归





### @####################

### 弃了。。PPT上东西太多了。。整理不过来

### 也没去听课，gg

### @####################



---



### 链接

- [阮一峰](http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html)
- [慕课手记](https://m.imooc.com/article/246889)
- [寄存器博主的系列](https://blog.csdn.net/qq_37340753/article/list/2?)
- [寄存器](https://blog.csdn.net/qq_37340753/article/details/80935423)
- [汇编入门](https://blog.csdn.net/godloveyuxu/article/details/76559323)

- [汇编所有指令](https://blog.csdn.net/baishuiniyaonulia/article/details/78504758)
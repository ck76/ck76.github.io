[toc]

## 1.1. scheme十戒

1. 当对一个原子列表进行递归时，要注意两个问题：(null? lat) and else。

   当对一个数字进行递归时，要注意两个问题：(zero? n) and else。

   当对一个S表达式列表进行递归时，要注意三个问题：(null? l), (atom? (car l)) 和 else。

2. 使用cons来创建列表。

3. 当创建一个列表时，先描述第一个元素，然后用cons来将它和递归连接在一起

4. 递归时，至少要改变一个参数。 例如：递归一个原子列表使用(cdr lat)；递归一个数字使用(sub1 n)；

   递归一个S表达式时，如果这个表达式即不(null? l)，也不(atom? (car l))， 那么使用(car l) 和 (cdr l)。

   并且该参数必须要越来越接近终止元素。在终止条件里面必须要对正在变化的参数进行检查：

   - 当使用cdr时，终止条件使用null?
   - 当使用sub1时，终止条件使用zero?

5. 当你使用+来创建一个值时，必须总要用0来作为终止，0加上任何值都不会改变原来的值。

   当你使用*来创建一个值时，必须总要用1来作为终止，1乘以任务值都不会改变原来的值。

   当你使用cons来创建一个值时，必须总要用()来作为终止。

6. 当函数运行正确后再考虑简化函数。

7. 当一个对象的子对象是与其本身表现一致时，这时候可用递归操作。比如：

   - 一个列表的子列表
   - 一个算术表达式的子表达式

8. 使用辅助函数来简化表述。

9. 使用新的函数来抽象公共模式。

10. 创建连续函数时，尽量能够一次性获取更多的值。

## 1.2. scheme五律

1. car函数最初只是用在非空列表上的。
2. cdr函数最初只是用在非空列表上的，(cdr non-null-list)的结果是另一个列表。
3. cons函数最初只接受两个参数，第二个参数必须是一个列表，它返回的结果也是一个列表。
4. null?函数只对列表有用。
5. eq?函数只接受两个参数，两个参数必须都是非数字的原子。

---

## Scheme 五法

### Scheme 五法之第一法 —— car 之法则

基本元件 *car* 仅定义为针对非空列表。

### Scheme 五法之第二法 —— cdr 之法则

基本元件 *cdr* 仅定义为针对非空列表。任意非空列表的 *cdr* 总是另一个列表。

### Scheme 五法之第三法 —— cons 之法则

基本元件 *cons* 需要两个参数。第二个参数必须是一个列表。结果是一个列表。

### Scheme 五法之第四法 —— Null? 之法则

基本元件 *null?* 仅定义为针对列表。

### Scheme 五法之第五法 —— eq? 之法则

基本元件 *eq?* 需要两个参数。每个参数都必须是一个非数字的原子。



## Scheme十诫

### 第一诫

当对一个原子列表 *lat* 进行递归调用时，询问两个有关 *lat* 的问题：*(null? lat)* 和 **else**。

当对一个数字 *n* 进行递归调用时，询问两个有关 *n* 的问题：*(zero? n)* 和 **else**。

当对一个S-表达式列表 *l* 进行递归调用时，询问三个有关 *l* 的问题：*(null? lat)*、*(atom? (car l))* 和 **else**。

### 第二诫

使用 *cons* 来构建列表。

### 第三诫

构建一个列表的时候，描述第一个典型元素，之后 *cons* 该元素到一般性递归（natural recursion）上。

### 第四诫

在递归时总是改变至少一个参数。当对一个原子列表 *lat* 进行递归调用时，使用 *(cdr lat)*。当对数字 *n* 进行递归调用时，使用 *(sub1 n)*。当对一个S-表达式 *l* 进行递归调用时，只要是 *(null? l)* 和 *(atom? (car l))* 都不为 true，那么就同时使用 *(car l)* 和 *(cdr l)*。

在递归时改变的参数，必须向着不断接近结束条件而改变。改变的参数必须在结束条件中得以测试：
当使用 *cdr* 时，用 *null?* 测试是否结束；
当使用 *sub1* 时,用 *zero?* 测试是否结束。

### 第五诫

当用 ➕ 构建一个值时，总是使用 0 作为结束代码行的值，因为加上 0 不会改变加法的值。

当用 ✖ 构建一个值时，总是使用 1 作为结柬代码行的值，因为乘以 1 不会改变乘法的值。

当用 *cons* 构建一个值时，总是考虑把 0 作为结束代码行的值。

### 第六诫

简化工作只在功能正确之后开展。

### 第七诫

对具有相同性质的 *subparts*（子部件）进行递归调用：

- 列表的子列表。
- 算术表达式的子表达式。

### 第八诫

使用辅助函数来抽象表示方式。

### 第九诫

用函数来抽象通用模式。

### 第十诫

构建函数,一次收集多个值。
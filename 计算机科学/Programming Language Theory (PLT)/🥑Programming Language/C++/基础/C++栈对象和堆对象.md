在C++中类的对象建立分为两种，一种是静态建立，如`A a`；另一种是动态建立，如`A* p=new A()，A*p=(A*)malloc()；`

- 静态建立一个类对象，是由编译器为对象在**栈空间**中分配内存，通过直接移动栈顶指针挪出适当的空间，然后在这片内存空间上调用构造函数形成一个栈对象。
- 动态建立类对象，是使用`new`运算符将对象建立在**堆空间**中，在**栈中只保留了指向该对象的指针**。栈是由编译器自动分配释放 ，存放函数的参数值，局部变量的值，对象的引用地址等。其操作方式类似于数据结构中的栈，通常都是被调用时处于存储空间中，调用完毕立即释放。堆中通常保存程序运行时动态创建的对象，C++堆中存放的对象需要由程序员分配释放，它存在程序运行的整个生命期，直到程序结束由OS释放。而在java中通常类的对象都分配在堆中，对象的回收由虚拟机的GC垃圾回收机制决定。

```c++
#include<iostream>
#include<string>
using namespace std;
class  student
{
public:
    string name;
    int age;
    void sayhello();
    student();
    ~student();
};

student::~student()
{
    cout<<this->name<<":gameover"<<endl;
}

student::student()
{
    cout<<"constructor"<<endl;
}

void student::sayhello()
{
    cout<<"my name is: "+this->name+" I am: "<<this->age;
    cout<<"\n";
}
student setname(string name)
{
    student stu;
    stu.age=12;
    stu.name=name;
    return stu;
}
int main()
{
    student stu=setname("jim");
    stu.sayhello();
    return 0;
}
//程序运行结果：my name is: jim I am: 12;
```

程序定义了一个student类，在setname函数中定义一个局部对象作为返回值。程序第18行静态构建了一个student对象stu，它在栈上分配空间，在函数调用结束后就销毁了，函数返回的类对应在内存中的值应该不存在啊？其实原来C++在用类作为函数的返回值时调用了**类的拷贝构造函数**，而且该拷贝构造函数是在**堆上分配存储空间**

```c++
student* setname(string name)
{
    student stu;
    stu.age=12;
    stu.name=name;
    return &stu;
}

//显然这里会出现问题，对象指针返回的是栈上的对象，
//在函数调用结束后已经销毁了，对象指针即为野指针，
//故程序在编译时会提示：warning C4172: returning address of local variable or temporary。
//解决这个问题我们自然想到把该对象构建在堆上即可。修改setname函数为下：
student* setname(string name)
 {
    student* stu= new student();
    stu->age=12;
    stu->name=name;
    return  stu;
 }

//上面输出结果并没有调用析构函数，在setname调用后，
//在main函数结束后也没有调用。在对上的对象需要程序员自己delete释放，将main改为如下：
int main()
{
    student* p=setname("tom");
    p->sayhello();
    delete p;
    return 0;
}
```



```c++
//malloc版本[出错]
student* setname(string name)
 {
    student* stu=(student*)malloc(sizeof(student));
    stu->age=12;
    stu->name=name;
    return  stu;
 }

//上面的程序执行到第5行会出错，原因是没有调用构造函数，stu->name根本就没有被初始化
//（string的构造函数没有被调用），所以不能赋值 。具体的解释是： 
//因为malloc只是分配堆内存（不会调用构造函数）它并不知道内存里要存的是什么。
//为此用new即可，将第3行代码改为：student* stu=new student;
//即程序调用了构造函数。若非要用malloc来申请内存可以将setname函数改为如下：
student* setname(string name)
 {
    student* stu=(student*)malloc(sizeof(student));
    new(stu) student;
    stu->age=12;
    stu->name=name;
    return  stu;
 }
//即加入了第4行程序正常运行，调用了构造函数。
//第4行大概可以理解为new了一个student对象，赋值转换为student的指针stu。
//既然这样可以把第3行直接改为：student* stu；即
student* setname(string name)
 {
    //student*stu= new student;
    student* stu;
    new(stu) student;
    stu->age=12;
    stu->name=name;
    return  stu;
 }
```



在C++中，类的对象建立分为两种，一种是静态建立，如A a；另一种是动态建立，如A* ptr=new A；这两种方式是有区别的。

1、静态建立类对象：是由编译器为对象在栈空间中分配内存，是通过直接移动栈顶指针，挪出适当的空间，然后在这片内存空间上调用构造函数形成一个栈对象。使用这种方法，直接调用类的构造函数。

2、动态建立类对象，是使用new运算符将对象建立在堆空间中。这个过程分为两步，第一步是执行operator new()函数，在堆空间中搜索合适的内存并进行分配；第二步是调用构造函数构造对象，初始化这片内存空间。这种方法，间接调用类的构造函数。

初始化两种方法：
 第一种初始化方法：ClassName object(初始化参数)；

第二种初始化方法：ClassName object=new ClassName();

两种初始化方法的区别：

第一种初始化方法：在Stack栈里面分配空间，自动释放。

第二种初始化方法：在heap堆里面分配空间，要手动释放。

什么时候该用 Object object;

什么时候该用 Object *object;
 object=new Object();
 栈对象的优势是在适当的时候自动生成，又在适当的时候自动销毁，不需要程序员操心；而且栈对象的创建速度一般较堆对象快，因为分配堆对象时，会调用 operator new操作，operator new会采用某种内存空间搜索算法，而该搜索过程可能是很费时间的，产生栈对象则没有这么麻烦，它仅仅需要移动栈顶指针就可以了。但是要注意的是，通常栈空间容量比较小，一般是1MB～2MB，所以体积比较大的对象不适合在栈中分配。特别要注意递归函数中最好不要使用栈对象，因为随着递归调用深度的增加，所需的栈空间也会线性增加，当所需栈空间不够时，便会导致栈溢出，这样就会产生运行时错误。

堆对象，其产生时刻和销毁时刻都要程序员精确定义，也就是说，程序员对堆对象的生命具有完全的控制权。我们常常需要这样的对象，比如，我们需要创建一个对象，能够被多个函数所访问，但是又不想使其成为全局的，那么这个时候创建一个堆对象无疑是良好的选择，然后在各个函数之间传递这个堆对象的指针，便可以实现对该对象的共享。另外，相比于栈空间，堆的容量要大得多。实际上，当物理内存不够时，如果这时还需要生成新的堆对象，通常不会产生运行时错误，而是系统会使用虚拟内存来扩展实际的物理内存。

那么如何限制类对象只能在堆或者栈上建立呢？下面分别进行讨论。

1、只能在堆上分配类对象，就是不能静态建立类对象，即不能直接调用类的构造函数。

容易想到将构造函数设为私有。在构造函数私有之后，无法在类外部调用构造函数来构造类对象，只能使用new运算符来建立对象。然而，前面已经说过，new运算符的执行过程分为两步，C++提供new运算符的重载，其实是只允许重载operator new()函数，而operatornew()函数只用于分配内存，无法提供构造功能。因此，这种方法不可以。

当对象建立在栈上面时，是由编译器分配内存空间的，调用构造函数来构造栈对象。当对象使用完后，编译器会调用析构函数来释放栈对象所占的空间。编译器管理了对象的整个生命周期。如果编译器无法调用类的析构函数，情况会是怎样的呢？比如，类的析构函数是私有的，编译器无法调用析构函数来释放内存。所以，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。因此，将析构函数设为私有，类对象就无法建立在栈上了。代码如下：

```cpp
class A
{
public:
    A(){}
    void destory(){delete this;}
private:
    ~A(){}
};
```

试着使用A a;来建立对象，编译报错，提示析构函数无法访问。这样就只能使用new操作符来建立对象，构造函数是公有的，可以直接调用。类中必须提供一个destory函数，来进行内存空间的释放。类对象使用完成后，必须调用destory函数。
 上述方法的缺点：

一、无法解决继承问题。如果A作为其它类的基类，则析构函数通常要设为virtual，然后在子类重写，以实现多态。因此析构函数不能设为private。还好C++提供了第三种访问控制，protected。将析构函数设为protected可以有效解决这个问题，类外无法访问protected成员，子类则可以访问。

二、类的使用很不方便，使用new建立对象，却使用destory函数释放对象，而不是使用delete。（使用delete会报错，因为delete对象的指针，会调用对象的析构函数，而析构函数类外不可访问）这种使用方式比较怪异。为了统一，可以将构造函数设为protected，然后提供一个public的static函数来完成构造，这样不使用new，而是使用一个函数来构造，使用一个函数来析构。代码如下，类似于单例模式：

```cpp
class A
{
protected:
    A(){}
    ~A(){}
public:
    static A* create()
    {
        return new A();
    }
    void destory()
    {
        delete this;
    }
};
```

这样，调用create()函数在堆上创建类A对象，调用destory()函数释放内存。

2、只能在栈上分配类对象

只有使用new运算符，对象才会建立在堆上，因此，只要禁用new运算符就可以实现类对象只能建立在栈上。虽然你不能影响new operator的能力（因为那是C++语言内建的），但是你可以利用一个事实：new operator 总是先调用 operator new,而后者我们是可以自行声明重写的。因此，将operator new()设为私有即可禁止对象被new在堆上。代码如下：

```cpp
class A
{
private:
    void* operator new(size_t t){}     // 注意函数的第一个参数和返回值都是固定的
    void operator delete(void* ptr){} // 重载了new就需要重载delete
public:
    A(){}
    ~A(){}
};
```





栈对象的优势是在适当的时候自动生成，又在适当的时候自动销毁，不需要程序员操心；而且栈对象的创建速度一般较堆对象快，因为分配堆对象时，会调用operator new操作，operator new会采用某种内存空间搜索算法，而该搜索过程可能是很费时间的，产生栈对象则没有这么麻烦，它仅仅需要移动栈顶指针就可以了。但是要注意的是，通常栈空间容量比较小，一般是1MB～2MB，所以体积比较大的对象不适合在栈中分配。特别要注意递归函数中最好不要使用栈对象，因为随着递归调用深度的增加，所需的栈空间也会线性增加，当所需栈空间不够时，便会导致栈溢出，这样就会产生运行时错误。

堆对象，其产生时刻和销毁时刻都要程序员精确定义，也就是说，程序员对堆对象的生命具有完全的控制权。我们常常需要这样的对象，比如，我们需要创建一个对象，能够被多个函数所访问，但是又不想使其成为全局的，那么这个时候创建一个堆对象无疑是良好的选择，然后在各个函数之间传递这个堆对象的指针，便可以实现对该对象的共享。另外，相比于栈空间，堆的容量要大得多。实际上，当物理内存不够时，如果这时还需要生成新的堆对象，通常不会产生运行时错误，而是系统会使用虚拟内存来扩展实际的物理内存。

接下来看看static对象。

　　首先是全局对象。全局对象为类间通信和函数间通信提供了一种最简单的方式，虽然这种方式并不优雅。一般而言，在完全的面向对象语言中，是不存在全局对象的，比如C#，因为全局对象意味着不安全和高耦合，在程序中过多地使用全局对象将大大降低程序的健壮性、稳定性、可维护性和可复用性。C++也完全可以剔除全局对象，但是最终没有，我想原因之一是为了兼容C。

　　其次是类的静态成员，上面已经提到，基类及其派生类的所有对象都共享这个静态成员对象，所以当需要在这些class之间或这些class objects之间进行数据共享或通信时，这样的静态成员无疑是很好的选择。

　　接着是静态局部对象，主要可用于保存该对象所在函数被屡次调用期间的中间状态，其中一个最显著的例子就是递归函数，我们都知道递归函数是自己调用自己的函数，如果在递归函数中定义一个nonstatic局部对象，那么当递归次数相当大时，所产生的开销也是巨大的。这是因为nonstatic局部对象是栈对象，每递归调用一次，就会产生一个这样的对象，每返回一次，就会释放这个对象，而且，这样的对象只局限于当前调用层，对于更深入的嵌套层和更浅露的外层，都是不可见的。每个层都有自己的局部对象和参数。

　　在递归函数设计中，可以使用static对象替代nonstatic局部对象（即栈对象），这不仅可以减少每次递归调用和返回时产生和释放nonstatic对象的开销，而且static对象还可以保存递归调用的中间状态，并且可为各个调用层所访问。




- <https://www.cnblogs.com/xiaoxiaoqiang001/p/5557704.html>
- <https://www.jianshu.com/p/d3938c548f7e
- https://blog.csdn.net/carlhelen/article/details/81535482>
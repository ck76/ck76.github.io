[toc]

在 **Homotopy Type Theory (HoTT)** 中，**higher inductive types (HITs)** 是用于定义具有更复杂的结构或约束的类型的工具。通常，普通的代数数据类型 (ADT) 会有明确的归纳原理 (induction principle)，这些原理可以帮助我们构造消去器 (eliminator)，即我们可以通过递归或归纳地对类型进行模式匹配并推导出结果。

对于普通的归纳类型来说，类型消去器（也叫 eliminator）是从一个类型中“剖析”出我们感兴趣的值或信息的一种方式。例如，对于自然数类型 `Nat`，其消去器就是标准的模式匹配：零 (`Zero`) 和继承 (`Succ`) 两种情况。

然而，在 **HoTT** 中，**higher inductive types (HITs)** 不仅可以包含常规的构造器（如点），还可以包含“路径构造器”（path constructors）。这些路径构造器允许定义更高阶的同伦信息，例如两点之间的路径、路径之间的路径等。因此，HITs 包含了更多的同伦结构，不仅仅是值，还包括了不同层次的等价信息。

因为这些路径构造器的存在，传统的归纳原理 (induction principle) 并不能完全捕捉 HIT 的全部结构。因此，**HoTT 书** 中所描述的 **HIT 的归纳原理**（induction principle）通常只是一个描述性的工具，它给出了如何通过构造器（包括路径构造器）来定义一个函数，但是它并没有直接提供一个明确的类型消去器（eliminator）。这意味着我们可以利用归纳原理构建函数，但这个过程需要依赖于 HIT 的结构，尤其是同伦路径的部分，消去器不总是那么直接。

总而言之，**HoTT 中的 higher inductive types 的归纳原理**可以用来描述如何递归地定义函数，但它往往是描述性的，因为这些类型涉及同伦路径构造器。因此，相较于传统归纳类型，**HIT 的类型消去器 (eliminator)** 更复杂，HoTT 书上并没有给出一种完全明确、机械化的写法，它更多是依赖于归纳原理的一个抽象过程来构建函数。



**Higher Inductive-Inductive Types (HIITs)** 是一种比 **Higher Inductive Types (HITs)** 更加复杂的类型构造，它结合了 **归纳类型 (inductive types)** 和 **高阶归纳类型 (higher inductive types)** 的特点。为了理解为什么它被称为 **higher inductive-inductive type**，我们可以分别从两个方面来进行解释：

### 1. **Inductive Type (归纳类型) 的含义**
归纳类型是一类常见的类型，它通过列举有限的构造器定义出一个类型。常见的例子包括自然数类型 `Nat`，它可以用以下方式定义：

- $0 : \texttt{Nat}$ （零是自然数的基本构造器）
- $\texttt{Succ} : \texttt{Nat} \to \texttt{Nat}$ （继承者，表示一个自然数的后继）

这些构造器描述了如何生成该类型的所有值，并且归纳原理允许我们通过递归定义函数对这些类型进行消解（消去器）。

### 2. **Higher Inductive Type (高阶归纳类型) 的含义**
**Higher Inductive Types (HITs)** 扩展了传统的归纳类型，允许类型中除了点构造器（类似于 `Nat` 的 $0$ 和 `Succ$）之外，还可以包含路径构造器（path constructors）。路径构造器允许我们在类型中定义某种“等同性”或“同伦”的结构。例如，`$S^1$`（圆）可以通过一个点构造器和一个路径构造器定义，路径构造器表明圆上有一条闭合路径。

HITs 因此可以在同伦层面上定义类型，不仅仅是点（值），还可以定义值之间的等价路径，这种路径结构是 HoTT 中的关键。

### 3. **Inductive-Inductive Type 的含义**
**Inductive-Inductive Types** 是指在定义类型的时候，某个归纳定义的类型依赖于另一个归纳定义的类型。例如，我们可以同时定义两个类型，其中一个类型的构造器依赖于另一个类型的定义。这允许我们构造依赖类型层级之间的复杂相互关系。

举例来说，假设我们定义类型 `A` 和 `B`，其中 `B` 的构造器依赖于 `A` 的值。这就形成了 **inductive-inductive** 结构，因为两个类型 `A` 和 `B` 是同时归纳定义的，且它们的构造互相依赖。

### 4. **Higher Inductive-Inductive Types (HIITs)** 的综合
在 **Higher Inductive-Inductive Types (HIITs)** 中，不仅有 **inductive-inductive type** 的结构，也有 **higher inductive type** 的结构。换句话说，HIITs 是在 **归纳-归纳类型 (inductive-inductive types)** 的基础上，进一步允许包含同伦路径的构造器（即 **higher inductive type** 的路径构造器），因此它具备更高阶的复杂性。

在这种情况下，HIITs 可以同时定义多个类型，这些类型的构造不仅相互依赖，还包含路径等价的信息。这使得 HIITs 能够表达非常复杂的类型结构，特别是涉及同伦等价和高阶归纳结构的场景。

### 为什么叫 "higher inductive-inductive type"？
它之所以叫 **higher inductive-inductive type** 是因为它同时具备了两种特性：

1. **Inductive-inductive**：类型之间通过归纳的方式相互定义并依赖。
2. **Higher**：这些类型中除了普通的点构造器，还有路径构造器，用于定义同伦路径等价的信息。

因此，**HIITs** 就是**高阶归纳-归纳类型**，它不仅能定义相互依赖的归纳类型，还可以引入同伦路径构造器，使得这些类型能够表达高阶的等价关系和同伦结构。

### -----------------------------------

在 **Homotopy Type Theory (HoTT)** 中，**higher inductive types (HITs)** 的消去器 (eliminator) 确实比普通归纳类型复杂得多。这主要是因为 HITs 引入了同伦路径构造器 (path constructors)，这使得它不仅仅涉及构造点，还涉及同伦等价关系，从而给消去规则带来了更多层次的复杂性。

您提到的 **圆 (Circle)** 的消去器 (eliminator) 是一个非常典型的例子。为了更好地理解为什么 HIT 的消去器更加复杂，我们先从普通的归纳类型的消去器说起。

### 1. **普通归纳类型的消去器 (Inductive Types Eliminator)**

对于普通的归纳类型，例如自然数 `Nat`，其消去器非常直接。我们有基本的构造器，如 $0$ 和 $Succ$，因此我们可以对这些构造器进行递归操作，定义递归函数，例如：

```haskell
Nat_elim : (P : Nat -> Type) (b : P 0) (s : (n : Nat) -> P n -> P (Succ n)) -> (n : Nat) -> P n
```

这表明我们可以通过一个基本情况 `P 0` 和递归情况 `P n -> P (Succ n)` 来递归定义函数。

### 2. **Higher Inductive Types 的消去器**

在 **HITs** 中，除了点构造器（类似于 `base : Circle`），还可能包含路径构造器（如 `loop : base = base`），这些路径构造器会显著增加消去器的复杂性。因为这些路径构造器表示了类型中的“等价关系”或“路径”，因此消去器不仅需要处理点构造器，还需要处理路径构造器中定义的等价关系。

对于 **圆** 的消去器，HoTT 书上给出了归纳原理（induction principle），如您提到的：

$$
(P : \text{Circle} \to \text{Type}) \to (b : P(\text{base})) \to (p : b = \text{transport}(P, \text{loop}, b)) \to (\forall x: \text{Circle}, P(x))
$$

这里的 `P` 是一个依赖于圆 `Circle` 的类型族，`b` 是在圆的基础点 `base` 上的一个元素，`p` 是描述在 `loop` 路径上传输这个元素的等同性。

#### **解构圆的消去器**
这个消去器表明，若我们想定义一个依赖类型族 `P` 的函数：

1. 首先要指定 `P` 在 `base` 处的值（即 `P(base)` 的元素 `b`）。
2. 然后我们需要指定路径上的约束 `p`，也就是 `b` 需要保持一致，在路径 `loop` 中传输时的等价性。
3. 最后，消去器返回了一个函数，它可以作用于整个 `Circle`，并为 `P(x)` 中的每一个 `x` 构造相应的值。

这与自然数或其他归纳类型的消去器不同的是，它不仅依赖于基本构造器 `base`，还依赖于路径构造器 `loop` 的等价关系。在处理路径构造器时，我们需要使用传输 (transport) 或者路径的相应消去规则。

### 3. **为什么 HIT 的消去器复杂？**

HIT 的消去器的复杂性来源于其路径构造器，导致我们不仅需要处理点的结构，还需要处理路径之间的等价关系。相较于普通的归纳类型（只处理点构造器），HIT 必须包含路径层次的同伦信息。

具体来说，在 **HIT 的消去器** 中，除了普通的消去规则：

- **点构造器**：像普通归纳类型那样处理构造器。
- **路径构造器**：需要确保在路径上传递信息时保持等价性。也就是说，必须处理通过路径传输 (transport) 的同伦等价。

正如您提到的，给出一个通用的消去器描述是非常复杂的。事实上，即使对于简单的归纳类型来说，给出完整的消去器也需要仔细处理递归情况。而对于 HIT 来说，情况更为复杂，因为它还涉及路径构造和同伦层次的信息，这使得消去器的定义变得更加繁琐。

### 4. **总结：HIT 的消去器的关键点**

- **消去器的构造**：必须处理路径构造器定义的同伦等价。
- **复杂性**：普通的归纳类型的消去器相对简单，只处理点构造器，而 HIT 的消去器不仅处理点构造器，还处理路径构造器和路径上传递的等价性。
- **圆的消去器示例**：圆的消去器展示了这种复杂性，我们需要处理路径构造器 `loop`，这导致我们必须确保在 `loop` 中传递信息时保持一致。

因此，HIT 的消去器比普通归纳类型的消去器更复杂，但它的描述可以理解为归纳原理的一种扩展，这种扩展需要处理更多层次的同伦等价。

### --------------------------------------

**Inductive types** 和 **W-types (well-founded trees)** 的确有紧密联系，特别是在处理递归结构时，**W-types** 可以看作是归纳类型的某种泛化。的确，许多归纳类型可以通过 W-types 来表达，比如自然数、列表等。但正如你所提到的，W-types 并不能完全表达所有 **inductive types** 或 **higher inductive types (HITs)**，尤其是在没有 **K 公理** 或 **函数外延性** 的情况下，等式理论会发生变化。

### 1. **W-types 与 Inductive types 的关系**
W-types 是一种通用的构造，用来定义具有递归结构的类型。给定一个家庭 $A$ 和一个家庭函数 $B : A \to Type$，W-type 定义了一棵树，其中每个节点来自 $A$，并且每个节点有一组子节点，子节点的类型由 $B(a)$ 决定。

在类型论中，W-types 可以表示自然数、列表、二叉树等结构，特别是在 **依赖类型论** 中，W-types 是表达递归数据类型的一个强大工具。W-types 的通用性允许我们定义复杂的递归结构，并且它们与归纳原理有紧密的关系。

### 2. **W-types 的局限性**
虽然 W-types 能够很好地表达许多归纳类型，但它们并不能表达所有类型，尤其是在没有 **K 公理** 或 **函数外延性** 的情况下：

- **没有 K 公理 (no K axiom)**：K 公理表明，所有路径都是根据反射性确定的。在没有 K 公理的情况下，类型中可能存在更多的等式结构，W-types 不能充分捕捉这种同伦层次。
- **函数外延性 (functional extensionality)**：如果没有函数外延性，函数等式的处理会变得更加复杂，而 W-types 本身并没有设计来处理这样的等式。

这些限制使得 W-types 不能表达所有的归纳类型，特别是涉及复杂路径或等价关系的情况。

### 3. **Higher Inductive Types (HITs) 与 W-types 的差异**
**Higher Inductive Types (HITs)** 是一种比传统归纳类型更强大的工具，它不仅能定义值构造器（点构造器），还允许定义路径构造器。路径构造器可以定义同伦路径，使得类型中包含关于值之间的等价关系。

HITs 的一个关键特点就是它们可以表达复杂的等价结构，而这些等价结构是 W-types 无法表达的。例如：

- **圆 (Circle)**：圆可以通过一个基本点 `base` 和一个路径构造器 `loop : base = base` 定义，路径构造器描述了从 `base` 到 `base` 的等价路径。这种结构是 W-types 无法捕捉的。
- **区间 (Interval)**：区间也可以通过两个基本点和一个路径构造器定义，类似于圆，但具有两个不同的端点。
- **悬垂 (Suspension)**：悬垂是将一个类型悬垂到高维上，这通常涉及复杂的路径结构，而这些也是 W-types 无法直接表达的。

HITs 的重要性在于它们能表达丰富的同伦结构，而不仅仅是点的递归构造。W-types 只能处理点构造，但无法处理这些路径构造。

### 4. **W-types 适用的情况：特别简单的 HITs**
正如你提到的，只有对于特别简单的 **HITs**，我们才能使用 W-types 进行表达。例如，对于一些不涉及复杂路径等价关系的 HIT，W-types 的递归结构可能足够。例如：
- 一些基本的递归数据结构，如自然数、列表等，可以通过 W-types 来表达。
- 在具有有限层次等价关系的情况下，某些 HIT 可以通过 W-types 进行有限度的表达。

但是，对于像圆、区间、悬垂这样更复杂的结构，特别是涉及到同伦路径和等价关系的场景，W-types 就显得不足了。

### 5. **实际应用中，圆、区间、悬垂足够常用**
虽然理论上可以构造出非常复杂的 **HITs**，但在实践中，许多应用并不需要特别复杂的 HITs。圆、区间、悬垂等常见的结构在很多场景下已经足够：

- **圆 (Circle)** 和 **区间 (Interval)** 经常用于表示基础的同伦等价结构，例如在拓扑学和同伦类型论中的应用。
- **悬垂 (Suspension)** 则用于处理高维结构和等价关系。

这些简单的 HIT 足以覆盖大多数实际应用，不需要定义特别复杂的 HIT。因此，在大部分实际场景下，使用这些常见的 HIT 就已经能够满足需求。

### 总结
虽然 **W-types** 可以表达许多简单的归纳类型，但它们并不能完全表达所有的 **inductive types** 或 **higher inductive types**，特别是在没有 **K 公理** 或 **函数外延性** 的情况下。W-types 主要适用于特别简单的 HIT，对于像圆、区间、悬垂这样更复杂的类型，我们需要依赖 HIT 来表达其同伦路径和等价关系。实际上，圆、区间、悬垂这些常见的 HIT 已经足够应用于许多实际工作场景，不需要构造过于复杂的 HIT。

### ------------------------------------------

要理解 **W-types**、**外延性** 和 **K 公理** 的概念，我们需要分别讨论它们在类型论中的定义和意义，并且进一步探讨它们在 **同伦类型论 (HoTT)** 中的作用。以下是对这三个概念的详细解释：

---

### 1. **W-types (Well-Founded Trees)**
**W-types** 是一种递归类型的构造，表示树状结构，广泛用于定义归纳类型。在类型论中，W-types 提供了一种通用方式来定义具有递归结构的数据类型，如自然数、列表和树。

#### W-types 的定义：
W-types 可以通过依赖类型构造。假设我们有一个集合 $A$ 以及一个类型族 $B : A \to \text{Type}$，其中 $A$ 表示节点的标签，而 $B(a)$ 表示节点 $a$ 的子节点的类型。我们可以构造 W-type $W(A, B)$，表示从根节点开始递归构造的树结构，其中每个节点标签属于 $A$，并且子节点的类型由 $B(a)$ 决定。

用形式化的语言来描述：

- W-type 是所有树的集合，其中树的每个节点有一个标签来自 $A$，且每个节点可以有多个子节点，子节点的类型由 $B(a)$ 决定。
  
- 通常的表示为：
  $$ W(A, B) = \{(a, f) \mid a \in A, f : B(a) \to W(A, B)\} $$
  这里，$a$ 是节点标签，$f$ 是从子节点的类型映射到另一个 W-type 的函数。

#### W-types 的例子：
1. **自然数**：
   自然数可以被定义为 W-type，其中 $A = 1$ 是一个单元素集合，$B(1) = 0 + 1$ 表示一个递归结构：
   - $0$ 对应自然数的零。
   - $1$ 表示递归地定义继承者（即 $Succ(n)$ 表示自然数 $n$ 的后继）。

2. **列表**：
   列表可以通过 W-type 定义，假设 $A = 1$ 表示列表的构造，$B(1)$ 表示列表中的元素类型。W-type 可以递归定义为：
   - 空列表 (nil)。
   - 列表的扩展 (cons)，即在现有的列表前添加一个元素。

#### W-types 的意义：
W-types 是处理递归数据类型的一种通用方式，能够帮助我们表达复杂的树形递归结构。在类型论中，W-types 提供了一个框架，使得许多常见的数据结构（自然数、列表、树等）都可以通过递归的方式构造。

然而，W-types 的局限性在于它们无法处理更高阶的同伦结构。例如，W-types 只能处理树的点结构，而不能表达路径或同伦等价的概念。为了处理更复杂的同伦结构，我们需要更高阶的工具，如 **higher inductive types (HITs)**。

---

### 2. **外延性 (Extensionality)**
**外延性 (extensionality)** 在类型论中指的是某种同一性原则，即两个对象如果在所有情况下表现一致，那么它们是相同的。在不同的上下文中，外延性有不同的具体表现，主要有函数外延性和同伦外延性。

#### 1. **函数外延性 (Function Extensionality)**：
函数外延性指的是两个函数如果在所有输入上都返回相同的输出，那么这两个函数是相同的。在形式化的类型论中，函数外延性可以表述为：
$$ f = g \iff \forall x, f(x) = g(x) $$
这意味着如果两个函数对每个输入 $x$ 都返回相同的值，那么它们是相等的。

**函数外延性的重要性**：
- 在传统的类型论中，函数外延性可能不是自动成立的，必须通过额外的公理来假定。在 **同伦类型论 (HoTT)** 中，函数外延性是自然成立的，因为 HoTT 将类型视为同伦空间，其中等价关系（路径）成为基本元素。
- 函数外延性是证明两个函数相等的基础，它使得我们可以推导出更复杂的函数等式。

#### 2. **同伦外延性 (Homotopy Extensionality)**：
同伦外延性是一种更高阶的外延性，它不仅关注对象在所有点上的表现是否一致，还关注对象之间的路径是否相同。在 HoTT 中，类型之间的等价关系是通过同伦路径来表示的，因此同伦外延性是决定类型等价的重要原则。

外延性在 HoTT 中是一个关键的概念，特别是同伦外延性，它允许我们将类型等价看作同伦空间中的路径等价。这使得 HoTT 的等价理论比传统的类型论更加灵活和丰富。

---

### 3. **K 公理**
**K 公理** 也叫做 **路径不依赖性 (Uniqueness of Identity Proofs, UIP)**。它是类型论中的一个等式原则，简单来说，K 公理的含义是：如果两个元素之间有一条同一性路径，那么这条路径是唯一的。

#### K 公理的具体表述：
对于类型 $A$ 中的元素 $x$ 和 $y$，如果存在一个等式证明 $p : x = y$，那么在 K 公理的框架下，我们可以假设 $p$ 是唯一的。这意味着两个元素之间的同一性（等式证明）是确定的，只有一条路径。

在类型论的某些版本中，K 公理自动成立，它表明等式证明是简单的，唯一的。然而，在 **同伦类型论 (HoTT)** 中，K 公理并不总是成立的。HoTT 中的类型被视为同伦空间，元素之间的等价可以通过多条路径来证明，因此在 HoTT 中，同一性证明不再是唯一的，K 公理不再适用。

#### K 公理的意义：
- **K 公理成立的情况下**：类型中的同一性证明是唯一的，这简化了许多类型论中的推导过程。等式关系变得更加简单和可操作。
- **K 公理不成立的情况下**：在 HoTT 中，K 公理不成立，允许多条路径来证明等价。这给类型赋予了更丰富的结构，使得我们可以处理更复杂的同伦等价关系。

---

### 4. **W-types、外延性与 K 公理的关系**
- **W-types**：是定义递归数据类型的一种强大工具，但它们无法处理复杂的路径或同伦结构。W-types 依赖于基础的递归原理，而非复杂的同伦等价，因此它们的表达能力在高阶场景中受到限制。
  
- **外延性**：在传统的类型论中，外延性是一个重要的原则，尤其是函数外延性。然而，在没有外延性公理的框架下（如 HoTT），函数等价变得更加复杂。同伦外延性在 HoTT 中变得更加自然，因为类型等价由路径来表示。
  
- **K 公理**：K 公理在传统类型论中是默认成立的，但在 HoTT 中，K 公理被放弃，以允许类型之间存在多条路径证明等价。这使得 HoTT 的类型系统更加灵活，能够处理更高阶的同伦结构。

---

### 总结
- **W-types** 是处理递归结构的强大工具，常用于表达简单的归纳类型。
- **外延性** 在类型论中表示两个对象在所有情况下表现一致时即相等，尤其是函数外延性在 HoTT 中的特殊处理使得等价关系更具灵活性。
- **K 公理** 表示等式证明的唯一性，但在 HoTT 中被放弃，使得类型等价可以通过多条路径来表示，丰富了类型系统的结构。

这些概念在类型论和同伦类型论中扮演了重要角色，它们决定了类型等价和递归结构的表示方式。

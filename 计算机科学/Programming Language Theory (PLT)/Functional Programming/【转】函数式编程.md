[TOC]

## 函数式编程

熟悉Java的人好像很容易学会Kotlin，甚至会感觉Kotlin不像一门新语言。但语法只是让我们**能用Kotlin**，要想**用好Kotlin**，就必须理解Kotlin背后的函数式编程理念。

一个用惯了锤子的人，看什么都像是钉子，我们必须先扔掉锤子，再去理解函数式编程。

我们先重新理解一下什么是计算机，什么是编程：

1. **计算机：**人发明计算机是为了计算数据（二战期间为了把炮弹打得更准，需要解大量的微积分，就造了台计算机帮忙，我们知道第一台通用计算机叫做ENIAC，这名字不是它的昵称绰号，就是它的功能，ENIAC的全称为Electronic Numerical Integrator And Computer，即电子数字积分计算机），直到现在，计算机程序在底层硬件电路上仍然是0和1的计算问题。
2. **计算：**计算机很笨，它其实只会计算0和1；但是人很聪明，人发现只要能把问题转换成0和1的运算，就可以丢给计算机去处理了，然后，几乎所有的问题，都可以设法转换成0和1的计算问题。
3. **程序：**一次或几次0和1的计算，几乎不能解决任何问题，需要很多次，步骤很复杂，过程很详细的0和1的计算才行，这种专为计算机提供的复杂而详细的计算步骤，就是计算机程序（为了向计算机传递程序，早期用打孔的纸带，后来用磁带，再后来用软盘，再后来是硬盘、光盘、闪存什么的...）。
4. **编程：**编程就是编写计算机程序，目的是把具体问题转换成0和1的运算问题，然后交给计算机去处理。
5. **语言：**编写计算机程序是给计算机用的，所以早期用的都是机器语言（全是0和1）。这样写出来的程序全是0和1，人自己反而看不懂，所以就抽象出汇编语言，就像把英文翻译成中文一样，这样人比较容易看懂。但是汇编语言描述的是底层电路的运算过程（把数据从内存的这里搬到那里，寄存器里的一个数据减去1，另一个数据乘以2），具体的输入、输出以及运算的目的都很难识别出来，所以又抽象出高级语言（C、BASIC等），不用再写底层电路如何操作（高级语言需要先经过编译器生成对应的汇编语言，再交给计算机去操作底层电路），只关心如何实现真实世界的业务逻辑。


![编程语言和现实世界](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/xKhVKkXWvzKH9A4zijOuhimadCZGy39Ai27v9tSNRPg!/r/dL4AAAAAAAAA)

6. **抽象：**编程的目的是把具体问题转成0和1的计算问题，在高级语言里不用再考虑0和1了，我们可以更自由地把真实世界抽象为某种模型以便编写代码，这种抽象建模的过程，就是我们编程的核心能力

7. **流派：**关于如何对真实世界进行抽象，是有不同流派的，面向对象是和面向过程对应的，函数式编程是和命令式编程对应的

8. **面向过程和面向对象：**计算机的使命是用来计算，所有的计算都是有具体过程的，这样就会很自然地把真实世界映射为计算的过程，对真实世界的建模就是直接建出一个个业务的流程，然后去运转而已。但是日益复杂的流程会变成一团乱麻，难以理解，难以修复，难以扩展；

   在面向对象中，不再纠结于流程本身，而是抽象出了对象的概念，把业务中的相关要素抽象为互相独立又互相调用的对象，对象和对象之间的关系（继承、封装、多态）成为核心，由于对象的概念更贴近人对于真实世界的理解，而且对象之间的关系也比整条复杂的流程简单，修改或者扩展起来的波及范围也小，容易理解/分解/修改/组合/扩展，所以面向对象非常适合大型的软件工程

![面向过程和面向对象](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/wbHA3Kzsv.tBUhlirrwZRqsASZmDps*5T*bRsz*SdnI!/r/dL8AAAAAAAAA)

9. **命令式编程和函数式编程：**换个角度来看，在计算机中实现业务逻辑有两种书写方式，一种是像输入命令一样，一步一步告诉计算机如何处理业务逻辑（还记得吗，计算机很笨，只会做它懂的事情），这就是命令式编程。如果命令有误，就是处理失败，如果要修改业务，就要把整个业务相关的命令都去检查和修改一遍。

   另一种是告诉计算机，我需要什么，不去详细地告诉它要怎么做，由于计算机不可能理解我们的需求，所以我们把函数拼接到一起，让数据按照我们设想的方式流动，我们只要在数据流的最前面输入参数，等数据自己流完整个处理过程，就能得到我们需要的数据。如果数据有误或者需要修改业务，我们就去调整这个数据流，将它里面的数据流动调整为我们需要的方式。

![命令式和函数式](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/vypoduiVhanyIWPNKhMT0n7fqakvsVd33cliv3No2v4!/r/dL4AAAAAAAAA)

​		我们看到，函数式编程的运算过程是高度抽象的，能节省大量运算细节的代码编写和debug工作。

10. **区别：**面向对象和函数式编程是有区别的，面向对象把真实世界抽象为类和对象，函数式编程则把真实世界抽象为函数；面向对象关心的是对象的行为，以及对象之间的关系，而函数式编程关心的是函数的行为，以及对函数的组合运用；面向对象只要对象不出错，对象关系不出错就可以，函数式编程只要奔涌在函数组合里的数据流按照预期进行转换就可以。

11. **选择：**在抽象建模的概念里，面向对象因为贴近真实世界，相对简单容易理解，工程上还容易扩展维护，所以很长一段时间以来，面向对象在软件工程领域备受欢迎。

12. **现实：**从时间上来看，函数式编程其实并不新潮，但是过去主要活跃在大学和实验室里，这几年突然变得火热，背后一定有现实的原因。

13. **硬件和并行：**这些年来，对计算机的应用越来越广泛，丢给计算机处理的问题越来越多，计算量越来越大，所以计算机CPU就越来越快，一开始还能每18个月翻一番（摩尔定律），到了这几年单核CPU逼近物理极限，提升有限，就开始着重搞多核，并行计算也越来越重要。

14. **数据的问题：**计算机的本质在于计算数据，而软件最大的问题则是计算错误（出bug），不巧的是，面向对象编程在并行计算里就特别容易出现bug，因为她的核心是各种独立而又互相调用的对象，当多个对象同时处理数据时，就很容易导致数据修改的不确定性，从而引发bug。

15. **混合：**编程的本质是把真实世界抽象映射到计算机的电路上，采用的抽象模式只是工具而已，我们没有必要排斥函数式编程，也不需要放弃面向对象，Kotlin也同时支持这两种方式，我们需要的是根据需要选用工具，用锤子，用扳手，或者两者都用。

    要更深入地理解函数式编程，有一篇[So You Want to be a Functional Programmer](https://link.jianshu.com?t=https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536)，写的非常好，在函数式编程里，我们需要用到纯函数、不变性、高阶函数、闭包等概念。



###  纯函数

开发者在学习编程之前，其实都学过数学，在数学的范畴里，函数的运算是不受干扰的，比如你算一个数字的平方根，只要参数确定，计算的过程永远是一致的，算出来的结果永远是一样的。

但是在学习编程（命令式编程）之后，函数就变了，变得“不纯洁”了，函数的运算会受到干扰，而且干扰无处不在，例如，我们可以在函数里使用一个会变化的全局变量，只要在任何位置/时间/线程里修改这个全局变量，函数就会输出不同的结果。

![函数会受到干扰](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/uTTIDaNvS0wXPpxR8AvUkrA*whNI4T54Htu3OanYQOY!/r/dMUAAAAAAAAA)



如果这种变化是开发者故意设计的，开发者就把它称为业务逻辑；如果这种变化不符合开发者的预期，开发者就把它称为——bug，悲剧的是，在命令式编程里，有无数的对象、时间点、线程可能对函数造成干扰。

在函数式编程里，重心是函数组合和数据流，更加不允许有干扰，所以要求我们编写纯函数。

不过，纯函数就像是编码规范，Kotlin鼓励而不是强制写出函数，毕竟，编程是为了与真实世界交互的，有时候必须使用一些“不纯洁”的函数，所以我们不要求彻底的纯函数化，只要求尽量写出纯函数



### 不变性

函数式编程不仅要求纯函数，还要求保存不变性（Kotlin用val和集合表示不变性，是的，集合默认是不可变的）

还是先回到数学上，在数学里，不允许这样的表达（我在刚学编程时，看到这个式子也是颠覆三观的）

> x = x + 1

在函数式编程里，这种表达也是非法的，也就是说，在函数式编程里，没有可变变量，一个变量一旦被赋值，就不可更改。

不变性有很多好处，这意味着程序运行的整个流程是固定可重现的，如果出了问题，只要跟着数据流走一遍就能找到出错点，再也不会有稀奇古怪的变化来为难我们。

不过，不变性最大的好处在于多线程安全，它可以完美地规避多个线程同时修改一个数据时的同步问题（变量不再允许修改，每个线程需要各自生成变量），这一点对于目前大量应用多线程的工程现状来说，特别有实际价值。

**可是，如果变量不可变，我们还要怎样去做业务逻辑呢，函数式编程给出的方式就是——用函数去返回一个复制的新对象，在这个新的对象里，改掉你想改的那个值。**

更彻底地说，函数式编程里，**没有变量**，一切都是函数（就像面向对象编程里，一切都是对象），变量实际上被函数取代了

![函数式编程里的变量也是函数](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/2q2bRuS7VreRjNCyGI4.8OYj6mVfE8xTWirvMb60md8!/r/dL8AAAAAAAAA)

所以，函数式编程里**只能新增变量，不能修改变量**，所以函数式编程**可能会非常耗内存（生成的变量太多了，而且业务不走完，变量不释放）**

另外，在函数式编程里还有一个特点——**没有循环**，因为for(i: i<9；i++)是非法的（当然，在Kotlin里你还可以这样写，因为Kotlin既支持函数式编程，又支持面向对象）



### 高阶函数

既然变量已经被函数取代了，那么函数里的参数和返回值呢？这些对象是不是也可以被替换成为函数呢？

在面向函数编程里，有个重要的概念，叫做“函数是一等公民”，核心就是，函数拥有和数据一样的地位，都可以作为参数和返回值，相应的就出现了高阶函数的概念，简单理解，高阶函数就是参数为函数，或者返回值为函数的函数。

![可以把函数作为输入输出](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/3ieaxxw49fAQSrWN1D.CMpJbrmF28h3T9BIEep3aTx8!/r/dL4AAAAAAAAA)

我们知道，在开发过程中，复用是非常重要的优化手段，说白了，**能用1个函数就别用多个函数**，不容易出错，出错也容易检查和修改

那么我们看下面这两个函数，要怎么优化？

```kotlin
fun getA(){
doA()
}

fun getB(){
doB()
}
```

在面向对象编程里，我们第一反应是用接口和类来解决问题，当然，那样就得好几个类和接口，然后层层嵌套

有了高阶函数的话，开头那段代码就可以这样优化了

```kotlin
fun getAB(doA()){

}
```

（在Kotlin里不能直接这么写，需要用Lambda表达式才行）

在Kotlin里，lambda还可以作为一种类型，可以被定义为val

```kotlin
val printMsg = {msg -> 
               println(msg)
               }
```

一个lambda的类型

调用这个lambda类型的“对象”，与调用函数无异

```kotlin
fun doPrint(msg:String){
  printMsg.invoke(msg)
}
```



### 闭包

前面说过，函数式编程里的函数是第一等公民，所以，一个val可以是一段代码，这就是一个闭包

```kotlin
val hint={
  val msg="hello"
  println(msg)
}
```

不过，闭包不是函数，闭包在逻辑上是封闭的，它使用自己内部的数据，用自己内部的逻辑进行处理，外部只能得到闭包的输出，无法输入，也无法干扰。

**在系统资源上，闭包是持久使用的，它会一直在系统里，不像函数那样会被系统注销掉。**

闭包在函数式编程里可以简化参数量、减少变量，会更加方便我们的开发。



### 其他

另外，函数式编程还有柯里化、inline、with、apply、let、run、it等概念，我们以后可以慢慢了解*。*

接下来，我们看看Kotlin里支撑起函数式编程的Lambda表达式、流式API等特性。



### Lambda表达式

为了写高阶函数和闭包，Kotlin支持我们使用Lambda表达式。

Lambda表达式也叫λ表达式，它看起来就是对匿名方法（如：回调、事件响应、Runnable等）的简化写法，目的是为了更贴近函数式编程把函数作为参数的思想。

Lambda表达式包括最外面的“{}”，用“()”来定义的参数列表，箭头->，以及一个表达式或语句块。

使用lambda表达式，我们就可以编写高阶函数，传递一个函数（或者一段代码）作为参数。



### 流式（Stream）API  

前面提过，函数式编程以数据流为中心，通过组合函数来整理一个数据流，通过调整这个函数组合得出需要的数据。

要让数据流在组合函数里流动起来，就需要使用流式API，流式API使我们更容易把函数组合起来，而且使整个数据流动过程更加直观。

![流式API的代码风格](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/ptlrG3*KGPfkBLEoWA5vPCdADUDvj3W6HaYADA2w0ck!/r/dDQBAAAAAAAA)



### 一些有趣的函数

Kotlin里提供了一些有趣的函数，包括it，let，apply，run，with，inline等

**1.it**

我们知道，用lambda表达式，我们可以把一些函数的写法简化成“输入参数->(运算)输出”，其中，如果只有一个参数时，写出来的代码就像是

```kotlin
val dints=ints.map{value->value*2}
```

对于这种单个参数的运算式，可以进一步简化，把参数声明和->都简化掉，只保留运算输出，不过这要用it来统一代替参数，代码就变成

```kotlin
val dints2=ints.map{ it*2}
```

这就是it的用法，进一步简化单参数的lambda表达式。

**2.let**

let能把更复杂的对象赋给it，比如

```kotlin
File("a.text").let{
    it.absoluteFile  //let把file对象赋给了it
}
```

这个特性可以稍微扩展一下，比如增加?检查

```kotlin
getVaraiable()?.let{
     it.length    // when not null
}
```

这样可以先检查返回值是否为空，不为空才继续进行

**3.apply**

apply可以操作一个对象的任意函数，再结合let返回该对象，例如

```kotlin
ints.apply{//拿到一个arraylist对象

    add(0,3)  //操作该对象的函数

}.let{ it.size} // 返回该对象（已被修改），继续处理
```

**4.run**

apply是操作一个对象，run则是操作一块儿代码

apply返回操作的对象，run的返回则是最后一行代码的对象

```kotlin
ints.run(){ //操作一个集合

	add(0,3) //操作该集合

	var a=Activity()

	a //会返回最后一行的对象

}.let{ it.actionBar}
```

**5.with**

with有点儿像apply，也是操作一个对象，不过它是用函数方式，把对象作为参数传入with函数，然后在代码块中操作，例如

```kotlin
with(ints){ //传入一个集合

    add(0,3) //操作该集合

    var a=Activity()

    a //会返回最后一行的对象

}.let{ it.actionBar}
```

但是返回像run，也是最后一行

**6.inline**

inline内联函数，其实相当于对代码块的一个标记，这个代码块将在编译时被放进代码的内部，相当于说，内联函数在编译后就被打散到调用它的函数里的，目的是得到一些性能上的优势。但是编译时间会变长。



- https://www.jianshu.com/p/bb53cba6c8f4
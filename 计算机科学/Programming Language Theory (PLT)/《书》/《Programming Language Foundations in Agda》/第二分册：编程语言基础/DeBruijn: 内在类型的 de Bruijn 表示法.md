[toc]



### DeBruijn: 内在类型的 de Bruijn 表示法

本节介绍了de Bruijn表示法以及内在类型的概念。在前两章中，我们使用了传统的带名字的变量形式化方法，并将项与类型分开定义。这种方法在逻辑和编程语言理论中被称为外在法（Extrinsic），而在本节中，我们使用内在法（Intrinsic），这两种方法分别与柯里法（Curry Style）和邱奇法（Church Style）相对应。

#### 概念解释：

1. **De Bruijn 因子 (de Bruijn Indices)**：
   - De Bruijn因子是一种不使用变量名而是用自然数来表示变量的方法。例如，用自然数$0$表示最近的约束，用$1$表示下一个约束，以此类推。
   - **解释**：在传统的λ演算中，变量的表示依赖于名字，如$"x"$、$"y"$等。而de Bruijn因子则使用数字来表示变量的位置，从而避免了变量名冲突的问题。例如，如果有一个项$\lambda x. \lambda y. x$，其中$y$在作用域内，而$x$在上一级作用域内，使用de Bruijn因子后，$x$可以表示为$1$，$y$可以表示为$0$。

2. **内在类型（Intrinsic Typing）**：
   - 内在类型法指的是将类型嵌入到项的定义中，项的类型在定义时已经固定，并且不会产生没有类型的无意义项。
   - **解释**：在外在法中，项和类型是分开定义的，一个项可以在没有被赋予类型的情况下存在，而内在法则在定义项时直接给出类型，这样可以确保每个项在定义时都符合其类型。

### De Bruijn表示法的优势

1. **唯一性**：
   - 使用de Bruijn因子，项的表示方式是唯一的，不存在像使用变量名时可能出现的$\alpha$-重命名问题。
   - **解释**：在传统方法中，两个名字不同但表示同一事物的项可能会被认为是不同的，例如$\lambda x. x$和$\lambda y. y$，它们只是名字不同而已。而在de Bruijn表示法中，$0$表示最近的变量，所以$\lambda 0. 0$在任何上下文中都是唯一的。

2. **避免变量名冲突**：
   - de Bruijn因子通过使用数字代替变量名，避免了变量名冲突的问题。
   - **解释**：在带名字的变量系统中，重命名和作用域的管理是非常复杂的，而使用de Bruijn因子后，数字的表示方式使得变量的管理变得更加简单和直观。

### 引入新的表示法

为了在Agda中实现这一表示法，我们使用了Thorsten Altenkirch 和 Bernhard Reus 提出的表示方法，并结合了Conor McBride提出的重命名和替换的方法。

### 导入的模块

```haskell
import Relation.Binary.PropositionalEquality as Eq
open Eq using (_≡_; refl)
open import Data.Empty using (⊥; ⊥-elim)
open import Data.Nat using (ℕ; zero; suc; _<_; _≤?_; z≤n; s≤s)
open import Relation.Nullary using (¬_)
open import Relation.Nullary.Decidable using (True; toWitness)
```

**模块解释**：
- 这些模块主要提供了自然数、空类型（Empty）、等式和其他基础数据类型和关系的定义，这些是后续定义类型和项的基础。

### 项的结构和其良类型推导的结构

- **良类型（Well-typedness）**：这是指项在某个上下文中符合其指定的类型。在内在类型法中，每一个项都自动保证是良类型的。
- **解释**：在内在类型法中，我们直接将类型信息嵌入到项的定义中，所以每一个项都已经符合其类型规则，不会产生没有类型的无意义项。

例如，下面是 Church法表示的二（用de Bruijn表示）：
$$
twoᶜ  :  ∅ ⊢ (\lambda x.\lambda y. \text{succ} (\text{succ} y)) ⇒  \text{Nat} ⇒ \text{Nat}
$$

对应的代码如下：

```haskell
twoᶜ  :  ∅ ⊢ Ch `ℕ
twoᶜ  =  ƛ ƛ (# 1 · (# 1 · # 0))
```

**解释**：在这里，`# 1`表示上一级的约束，即变量$s$，`# 0`表示当前约束的变量$z$。这种表示方法的好处在于，我们无需再考虑变量名的冲突问题。

#### **内在类型的语法**：

1. **类型**：
   - 类型的定义包括函数类型和自然数类型。代码如下：
   ```haskell
   data Type : Set where
     _⇒_ : Type → Type → Type
     `ℕ  : Type
   ```
   **解释**：`_⇒_`表示函数类型，例如`ℕ ⇒ ℕ`表示从自然数到自然数的函数类型，而`ℕ`表示自然数类型。

2. **语境（Context）**：
   - 语境可以看作是一个类型的列表，表示了当前环境中可以使用的变量和它们的类型。语境的形式化定义如下：
   ```haskell
   data Context : Set where
     ∅   : Context
     _,_ : Context → Type → Context
   ```
   **解释**：`∅`表示空语境，`Γ , A`表示在语境`Γ`的基础上增加了一个类型为`A`的变量。

#### **变量及查询判断**：

1. **变量的表示**：
   - 在de Bruijn表示法中，变量由一个自然数表示，表示该变量离当前作用域的距离。例如：
   ```haskell
   data _∋_ : Context → Type → Set where
     Z : ∀ {Γ A} → Γ , A ∋ A
     S_ : ∀ {Γ A B} → Γ ∋ A → Γ , B ∋ A
   ```
   **解释**：`Z`表示离当前最近的约束，`S_`表示离当前约束更远的变量。例如，`S Z`表示离当前作用域一步远的变量。

2. **查询判断**：
   - 查询判断用来检查一个变量是否在当前语境中。例如：
   ```haskell
   ∅ , `ℕ ⇒ `ℕ , `ℕ ∋ `ℕ
   ```
   **解释**：在这个语境中，`Z`表示最近的自然数类型，而`S Z`表示前一个函数类型。

### **项以及赋型判断**：

1. **项的定义**：
   - 项的定义和它的类型规则是紧密相连的。代码如下：
   ```haskell
   data _⊢_ : Context → Type → Set where
     `_ : ∀ {Γ A} → Γ ∋ A → Γ ⊢ A
     ƛ_  : ∀ {Γ A B} → Γ , A ⊢ B → Γ ⊢ A ⇒ B
     _·_ : ∀ {Γ A B} → Γ ⊢ A ⇒ B → Γ ⊢ A → Γ ⊢ B
     `zero : ∀ {Γ} → Γ ⊢ `ℕ
     `suc_ : ∀ {Γ} → Γ ⊢ `ℕ → Γ ⊢ `ℕ
     case : ∀ {Γ A} → Γ ⊢ `ℕ → Γ ⊢ A → Γ , `ℕ ⊢ A → Γ ⊢ A
     μ_ : ∀ {Γ A} → Γ , A ⊢ A → Γ ⊢ A
   ```
   **解释**：这些构造子对应着不同的操作，例如`_⊢_`表示一个项在某个语境中具有某种类型，`ƛ_`表示λ抽象，`_·_`表示函数应用，`case`表示分支，等等。

2. **赋型判断**：
   - 赋型判断表示一个项在某个语境中符合某种类型。例如：
   ```haskell
   ∅ , `ℕ ⇒ `ℕ , `ℕ ⊢ `ℕ
   ∅ , `ℕ ⇒ `ℕ , `ℕ ⊢ `ℕ ⇒ `ℕ
   ∅ , `ℕ ⇒ `ℕ , `ℕ ⊢ `ℕ
   ```
   **解释**：例如，在语境`∅ , `ℕ ⇒ `ℕ , `ℕ`中，变量`Z`的类型是`ℕ`，而`S Z`的类型是`ℕ ⇒ ℕ`。



### **内在类型的De Bruijn表示法：第二个例子**

在理解De Bruijn表示法后，进一步的例子有助于巩固这一概念。我们将看一个涉及到自然数相加的例子。

#### **示例项：plus**

```haskell
plus : Term
plus = μ "+" ⇒ ƛ "m" ⇒ ƛ "n" ⇒
         case ` "m"
           [zero ⇒ ` "n"
           | suc "m" ⇒ `suc (` "+" · ` "m" · ` "n") ]
```

**解释**：
- 这个代码定义了一个将两个自然数相加的项。`"m"` 和 `"n"`是两个自然数，`μ`定义了递归函数`"+"`，其中当`"m"`为0时，结果为`"n"`；当`"m"`为`succ m`时，结果为`succ (plus m n)`。

#### **赋型判断对应**

对应的赋型推导如下：

```haskell
⊢plus : ∅ ⊢ plus ⦂ `ℕ ⇒ `ℕ ⇒ `ℕ
⊢plus = ⊢μ (⊢ƛ (⊢ƛ (⊢case (⊢` ∋m) (⊢` ∋n)
         (⊢suc (⊢` ∋+ · ⊢` ∋m′ · ⊢` ∋n′)))))
  where
  ∋+  = (S′ (S′ (S′ Z)))
  ∋m  = (S′ Z)
  ∋n  = Z
  ∋m′ = Z
  ∋n′ = (S′ Z)
```

**解释**：
- 这里`⊢`表示赋型判断。比如，`⊢plus : ∅ ⊢ plus ⦂ `ℕ ⇒ `ℕ ⇒ `ℕ` 表示`plus`项在空语境`∅`中类型为`ℕ ⇒ ℕ ⇒ ℕ`。
- `∋+` 表示递归函数`"+"`在语境中的位置，其在语境中的位置通过自然数`(S′ (S′ (S′ Z)))`来表示。
- `∋m` 表示变量`m`，它是第一个lambda表达式中引入的。
- `∋n` 是第二个lambda表达式中引入的变量。
- `∋m′` 和 `∋n′` 是`case`表达式中处理的变量，分别表示匹配分支中的`m`和`n`。

#### **De Bruijn因子表示的plus**

在De Bruijn表示法中，以上代码可以用以下更简洁的表示方式来描述：

```haskell
plus : ∀ {Γ} → Γ ⊢ `ℕ ⇒ `ℕ ⇒ `ℕ
plus = μ ƛ ƛ case (# 1) (# 0) (`suc (# 3 · # 0 · # 1))
```

**解释**：
- `# 1`表示离当前作用域一个lambda的约束，即前一个lambda绑定的变量`m`。
- `# 0`表示当前lambda绑定的变量`n`。
- `# 3`表示函数`"+"`的位置，它的深度是3。

这里，`# 1 · (# 1 · # 0)` 表示的是相加操作的递归调用，它依赖于De Bruijn因子来表示变量的位置和作用域。

### **展示的顺序**

在本节中，使用内在类型的项要求我们在引入操作（如重命名或替换）时，证明它们保留了类型。因此，我们改变了展示的顺序：

1. **语法**：
   - 语法现在包含了它们的赋型规则。替换的定义变得更加深入，并包括之前证明中最棘手的部分，即替换保留了类型。
   - **解释**：这种方式使得每个操作都有明确的类型约束，避免了无类型操作导致的错误。

2. **归约的定义**：
   - 归约的定义现在包括了保型性，不再需要额外的证明。
   - **解释**：通过将归约规则嵌入到类型系统中，保证每一步操作都符合类型约束，不需要额外的证明来确认保型性。

### **语法：中缀声明**

在定义项之前，我们首先定义中缀声明：

```haskell
infix  4 _⊢_
infix  4 _∋_
infixl 5 _,_
infixr 7 _⇒_
infix  5 ƛ_
infix  5 μ_
infixl 7 _·_
infix  8 `suc_
infix  9 `_
infix  9 S_
infix  9 #_
```

**解释**：
- 这些中缀声明定义了不同运算符的优先级。例如，`_⊢_` 和 `_∋_` 分别用于赋型判断和变量查询；`_⇒_` 表示函数类型；`ƛ_` 表示lambda抽象，等等。

### **类型定义**

类型定义包括了函数类型和自然数类型：

```haskell
data Type : Set where
  _⇒_ : Type → Type → Type
  `ℕ  : Type
```

**解释**：
- `_⇒_` 定义了函数类型的构造子，例如 `A ⇒ B` 表示从类型 `A` 到类型 `B` 的函数类型。
- `ℕ` 表示自然数类型。

### **语境定义**

语境是类型的列表，表示在当前语境中有效的变量：

```haskell
data Context : Set where
  ∅   : Context
  _,_ : Context → Type → Context
```

**解释**：
- `∅` 表示空语境。
- `_,_` 表示扩展语境，例如 `Γ, A` 表示在语境 `Γ` 上添加了一个类型为 `A` 的变量。

### **查询判断和变量**

在de Bruijn表示法中，查询判断是通过自然数来表示的：

```haskell
data _∋_ : Context → Type → Set where
  Z : ∀ {Γ A} → Γ , A ∋ A
  S_ : ∀ {Γ A B} → Γ ∋ A → Γ , B ∋ A
```

**解释**：
- `Z` 表示语境中最内层的变量，即离当前作用域最近的变量。
- `S_` 表示语境中较外层的变量，通过递归定义，`S_` 可以表示更外层的变量。例如，`S Z` 表示语境中的第二个变量。

### **项和赋型判断**

在内在类型系统中，项和赋型判断是通过数据类型 `_⊢_` 来定义的：

```haskell
data _⊢_ : Context → Type → Set where
  `_ : ∀ {Γ A} → Γ ∋ A → Γ ⊢ A
  ƛ_  : ∀ {Γ A B} → Γ , A ⊢ B → Γ ⊢ A ⇒ B
  _·_ : ∀ {Γ A B} → Γ ⊢ A ⇒ B → Γ ⊢ A → Γ ⊢ B
  `zero : ∀ {Γ} → Γ ⊢ `ℕ
  `suc_ : ∀ {Γ} → Γ ⊢ `ℕ → Γ ⊢ `ℕ
  case : ∀ {Γ A} → Γ ⊢ `ℕ → Γ ⊢ A → Γ , `ℕ ⊢ A → Γ ⊢ A
  μ_ : ∀ {Γ A} → Γ , A ⊢ A → Γ ⊢ A
```

**解释**：
- 这些构造子表示不同的操作：`_⊢_` 表示赋型判断，`ƛ_` 表示lambda抽象，`_·_` 表示函数应用，`case` 表示分支操作，`μ_` 表示递归操作。

例如，赋型判断 `Γ ⊢ A` 表示在语境 `Γ` 中，项的类型为 `A`。例如：

```haskell
∅ , `ℕ ⇒ `ℕ , `ℕ ⊢ `ℕ
```

**解释**：在这个语境中，`Z` 表示最近的自然数类型，`S Z` 表示上一级语境中的函数类型`ℕ ⇒ ℕ`。

### **简化De Bruijn因子**

为了更方便的计算De Bruijn因子，可以定义以下函数：

```haskell
length : Context → ℕ
length ∅        =  zero
length (Γ , _)  =  suc (length Γ)
```

**解释**：
- `length` 函数计算语境的长度，以便确定某个De Bruijn因子是否在语境范围内。

我们可以用这个函数来查询某个自然数对应的类型

：

```haskell
lookup : {Γ : Context} → {n : ℕ} → (p : n < length Γ) → Type
lookup {(_ , A)} {zero}    (s≤s z≤n)  =  A
lookup {(Γ , _)} {(suc n)} (s≤s p)    =  lookup p
```

**解释**：
- `lookup` 函数用于查找语境中某个自然数对应的类型。例如，`lookup p` 表示在语境 `Γ` 中，查询自然数 `n` 对应的类型。

结合上述，我们可以引入一个变量的简略表示方法：

```haskell
#_ : ∀ {Γ}
  → (n : ℕ)
  → {n∈Γ : True (suc n ≤? length Γ)}
    --------------------------------
  → Γ ⊢ lookup (toWitness n∈Γ)
#_ n {n∈Γ}  =  ` count (toWitness n∈Γ)
```

**解释**：
- `#_` 函数用于简化变量表示，例如，`# 0` 表示当前作用域的第一个变量，`# 1` 表示上一级语境中的变量。

通过这个简化方法，我们可以更简洁地表示项。例如，Church法表示的二：

```haskell
_ : ∅ ⊢ (`ℕ ⇒ `ℕ) ⇒ `ℕ ⇒ `ℕ
_ = ƛ ƛ (# 1 · (# 1 · # 0))
```

**解释**：
- 在这个例子中，`# 1` 表示前一个lambda绑定的变量，`# 0` 表示当前lambda绑定的变量。这个项表示了函数`λs. λz. s (s z)`，即Church法表示的二。

这是对De Bruijn因子和内在类型表示法的深入解释。希望这些详细的解释有助于理解这一复杂的概念。如果需要进一步解释或具体的例子，可以继续讨论。







# ---------------------------------------

好的，我将按照原文的结构，一小节一小节地讲解每个部分涉及的概念，并在适当的地方使用公式来帮助解释。

### 导入部分

在这一部分，导入了 Agda 中需要使用的模块和操作符。这些模块和操作符将用于定义变量、类型、项、以及它们之间的关系。具体导入了以下内容：

- **Relation.Binary.PropositionalEquality**：用于处理等式，导入了 `_≡_` 表示等式，`refl` 表示等式反射性。
- **Data.Empty**：导入了 `⊥` 和 `⊥-elim`，用于表示不可能的情况。
- **Data.Nat**：用于处理自然数 `ℕ` 及其相关操作，如 `zero` (0), `suc` (后继), `_<_` (小于)。
- **Relation.Nullary**：导入了 `¬_` 表示否定命题。
- **Relation.Nullary.Decidable**：导入了 `True` 和 `toWitness`，用于处理可判定的命题。

这些导入为后续的形式化定义奠定了基础，特别是在等式推理和自然数操作方面。

### 简介

在简介部分，作者提出了两种表示 λ 演算的方法，并介绍了本章将采用的 de Bruijn 表示法和内在类型系统。

#### 概念1：外在法和内在法
- **外在法（Extrinsic Style）**：这种方法先定义项，然后通过赋型规则为项赋予类型。在这种方法中，项与类型是分离的，项的类型通过独立的规则来确定。
- **内在法（Intrinsic Style）**：这种方法先定义类型，再定义项。项和类型紧密结合，项的结构和其类型的推导是相互依赖的。内在法避免了无类型的项的存在，因为每个项在定义时就已经包含了其类型信息。

#### 概念2：de Bruijn 表示法
- **de Bruijn 表示法**：用自然数（称为 de Bruijn 因子）代替变量名来表示变量。这个自然数表示变量在当前上下文中距离其绑定位置的深度。例如，`#0` 表示最内层的绑定变量，`#1` 表示次内层的绑定变量，以此类推。这样每个项都有唯一的表示形式，避免了变量名的冲突。

### 第二个例子

在这个部分，作者通过一个将两个自然数相加的例子来展示 de Bruijn 表示法的具体应用。

#### 概念1：变量屏蔽效应
- **变量屏蔽效应**：在 λ 演算中，当一个变量在一个范围内重新绑定时，该变量的原有绑定会被屏蔽。例如，在 `ƛ "m" ⇒ ƛ "n" ⇒` 中，`n` 被新的绑定覆盖，原有的 `n` 不能再被访问。使用 de Bruijn 表示法时，这种屏蔽效应通过自然数来自动处理。

#### 例子解析
在例子中，作者给出了如下项表示一个自然数加法：

```agda
plus : Term
plus = μ "+" ⇒ ƛ "m" ⇒ ƛ "n" ⇒
         case ` "m"
           [zero⇒ ` "n"
           |suc "m" ⇒ `suc (` "+" · ` "m" · ` "n") ]
```

其对应的 de Bruijn 表示法如下：

```agda
plus : ∀ {Γ} → Γ ⊢ `ℕ ⇒ `ℕ ⇒ `ℕ
plus = μ ƛ ƛ case (# 1) (# 0) (`suc (# 3 · # 0 · # 1))
```

其中，`#0` 表示当前上下文中最内层的变量（即 `n`），`#1` 表示次内层的变量（即 `m`），`#3` 表示第三层外的变量（即 `+`）。

### 展示的顺序

作者在此部分指出，由于使用了内在类型系统，在定义语法和项时，需要改变展示的顺序。

#### 概念1：语法与推导规则的紧密结合
- **语法和推导规则的结合**：内在类型系统的项不仅包含语法结构，还包含类型信息。这意味着在定义项时，类型推导规则已经被包含在其中。比如一个 λ 项的定义同时也是一个赋型判断。

### 语法

在这一部分，作者正式定义了项、类型和上下文的语法规则。由于采用了内在类型系统，项的定义包含了类型信息。

#### 概念1：类型和上下文的定义
- **类型**：定义了函数类型 `A ⇒ B` 和自然数类型 `ℕ`。形式化定义为：
  ```agda
  data Type : Set where
    _⇒_ : Type → Type → Type
    `ℕ  : Type
  ```

- **上下文**：上下文是一个类型的列表，表示变量的绑定顺序。形式化定义为：
  ```agda
  data Context : Set where
    ∅   : Context
    _,_ : Context → Type → Context
  ```

#### 概念2：变量的定义
- **变量**：变量由 de Bruijn 因子表示，这些因子对应于上下文中的位置。查询判断由一个数据类型表示，如下：
  ```agda
  data _∋_ : Context → Type → Set where
    Z : ∀ {Γ A} → Γ , A ∋ A
    S_ : ∀ {Γ A B} → Γ ∋ A → Γ , B ∋ A
  ```

其中，`Z` 表示最近绑定的变量，`S_` 表示向外移动一步的变量。

### 项及其赋型判断

在这一部分，作者定义了内在类型系统中的项和赋型判断。由于项和类型是紧密结合的，项的定义已经包含了其类型信息。

#### 概念1：项的定义
- **项**：项的定义不仅仅是语法结构，还包含了类型信息。每个项都是一个赋型判断。例如：
  ```agda
  data _⊢_ : Context → Type → Set where
    `_ : ∀ {Γ A} → Γ ∋ A → Γ ⊢ A
    ƛ_  : ∀ {Γ A B} → Γ , A ⊢ B → Γ ⊢ A ⇒ B
    _·_ : ∀ {Γ A B} → Γ ⊢ A ⇒ B → Γ ⊢ A → Γ ⊢ B
    `zero : ∀ {Γ} → Γ ⊢ `ℕ
    `suc_ : ∀ {Γ} → Γ ⊢ `ℕ → Γ ⊢ `ℕ
  ```

这些定义表明了项的结构和其类型推导的紧密关系。例如，`ƛ_` 定义了一个 λ 抽象，其类型为 `A ⇒ B`。

#### 概念2：de Bruijn 因子计算
- **de Bruijn 因子计算**：在上下文中选择一个类型并确定变量位置的过程。通过计算上下文的长度，de Bruijn 因子指示了变量在上下文中的位置。

接下来会详细解释“重命名”、“替换”、“归约”等关键操作，以及这些操作在内在类型系统中的实现。由于内容较长，我将分多次生成。

### 重命名（Renaming）

在这一部分，作者介绍了**重命名**的概念，以及如何在内在类型系统中实现重命名。

#### 概念1：重命名的必要性
- **重命名**：重命名是将一个项从一个上下文中“转移”到另一个上下文中的过程。在此过程中，项中的变量必须根据新的上下文进行调整。对于内在类型系统，重命名操作必须保持项的类型不变。

例如，考虑如下项：
$$
M = \lambda z. \, s \, (s \, z)
$$
在上下文 $\Gamma = \{s : \mathbb{N} \to \mathbb{N}, z : \mathbb{N}\}$ 中，变量 $s$ 的 de Bruijn 因子为 1，$z$ 的因子为 0。如果我们将此项映射到一个新的上下文 $\Delta = \{s : \mathbb{N} \to \mathbb{N}, n : \mathbb{N}, z : \mathbb{N}\}$ 中，变量 $z$ 的因子将变为 1，而 $s$ 的因子变为 2。这种调整就需要通过**重命名**来实现。

#### 概念2：扩充映射（Extension）
- **扩充映射（Extension）**：在重命名操作中，当引入新的变量时，映射需要扩充以适应新的上下文。扩充映射的过程对应于将上下文扩展，并相应地调整项中的变量。

例如，对于上下文 $\Gamma = \{A_1, A_2, \dots, A_n\}$，扩充后的上下文为 $\Gamma, B$。扩充映射 $\rho$ 的定义如下：
$$
\text{ext}(\rho) \, Z = Z
$$
$$
\text{ext}(\rho) \, (S \, x) = S \, (\rho \, x)
$$
其中，$Z$ 表示最内层的变量，$S$ 表示向外扩展的变量。

#### 概念3：重命名操作
- **重命名**：重命名操作的定义如下：
```agda
rename : ∀ {Γ Δ}
  → (∀ {A} → Γ ∋ A → Δ ∋ A)
  -----------------------
  → (∀ {A} → Γ ⊢ A → Δ ⊢ A)
rename ρ (` x)          =  ` (ρ x)
rename ρ (ƛ N)          =  ƛ (rename (ext ρ) N)
rename ρ (L · M)        =  (rename ρ L) · (rename ρ M)
rename ρ (`zero)        =  `zero
rename ρ (`suc M)       =  `suc (rename ρ M)
rename ρ (case L M N)   =  case (rename ρ L) (rename ρ M) (rename (ext ρ) N)
rename ρ (μ N)          =  μ (rename (ext ρ) N)
```
这个操作递归地应用在项的各个部分，根据上下文的变化调整项中的变量。重命名过程中保持项的类型不变，因为映射 $\rho$ 已经确保了这一点。

### 替换（Substitution）

这一部分讲解了**替换**操作，即将一个项中的变量替换为另一个项的过程。

#### 概念1：替换的定义
- **替换**：替换操作是将上下文中的一个变量替换为另一个项，并在项的结构中保持类型一致性的过程。广义的替换不仅限于替换单个变量，还可以将多个变量映射到不同的项。

例如，考虑一个上下文 $\Gamma = \{x: \mathbb{N}, y: \mathbb{N}\}$ 和一个项 $M = x + y$。如果我们将 $x$ 替换为 $z$，并将 $y$ 替换为 2，这可以形式化为：
$$
M[z/x, 2/y] = z + 2
$$

#### 概念2：扩充映射的替换版本
- **扩充映射**：类似于重命名，替换操作也需要扩充映射。当遇到新的上下文时，扩充映射生成一个从扩充后的上下文到原始上下文的映射。

```agda
exts : ∀ {Γ Δ}
  → (∀ {A} →       Γ ∋ A →     Δ ⊢ A)
    ---------------------------------
  → (∀ {A B} → Γ , B ∋ A → Δ , B ⊢ A)
exts σ Z      =  ` Z
exts σ (S x)  =  rename S_ (σ x)
```
在这个定义中，$σ$ 是从 $\Gamma$ 中的变量映射到 $\Delta$ 中的项的映射。`exts` 通过递归扩展了这个映射，以适应新的上下文。

#### 概念3：替换操作
- **替换操作**：替换的具体定义如下：
```agda
subst : ∀ {Γ Δ}
  → (∀ {A} → Γ ∋ A → Δ ⊢ A)
    -----------------------
  → (∀ {A} → Γ ⊢ A → Δ ⊢ A)
subst σ (` x)          =  σ x
subst σ (ƛ N)          =  ƛ (subst (exts σ) N)
subst σ (L · M)        =  (subst σ L) · (subst σ M)
subst σ (`zero)        =  `zero
subst σ (`suc M)       =  `suc (subst σ M)
subst σ (case L M N)   =  case (subst σ L) (subst σ M) (subst (exts σ) N)
subst σ (μ N)          =  μ (subst (exts σ) N)
```
这个定义中，替换操作递归地应用在项的各个部分。通过扩充映射 `exts`，确保替换操作保持项的类型不变。

#### 概念4：单个替换
- **单个替换**：单个替换是广义替换的特殊情况，即仅替换一个变量。其定义如下：
```agda
_[_] : ∀ {Γ A B}
  → Γ , B ⊢ A
  → Γ ⊢ B
    ---------
  → Γ ⊢ A
_[_] {Γ} {A} {B} N M =  subst {Γ , B} {Γ} σ {A} N
  where
  σ : ∀ {A} → Γ , B ∋ A → Γ ⊢ A
  σ Z      =  M
  σ (S x)  =  ` x
```
这个定义中，替换项 $M$ 替换了上下文 $\Gamma, B$ 中的最后一个变量。在替换过程中，其它变量保持不变。

### 归约（Reduction）

这一部分介绍了**归约**的概念，即如何将复杂的项简化为更基本的项。

#### 概念1：归约的定义
- **归约**：归约规则定义了项如何一步步简化为更简单的项。这些规则包括应用规则（将函数应用于参数）和匹配规则（处理自然数的 `case` 表达式）。归约保持类型一致性，即归约后的项与归约前的项具有相同的类型。

例如，考虑一个应用表达式 $(\lambda x. M) \, N$ 的 β-归约：
$$
(\lambda x. M) \, N \rightarrow M[N/x]
$$
在这个过程中，表达式 $N$ 替换了 $M$ 中的变量 $x$。

#### 概念2：兼容性规则与简化规则
- **兼容性规则（ξ 规则）**：这些规则处理项的各个部分，确保项的整体结构在归约过程中保持一致。比如：
  ```agda
  ξ-·₁ : ∀ {Γ A B} {L L′ : Γ ⊢ A ⇒ B} {M : Γ ⊢ A}
    → L —→ L′
      ---------------
    → L · M —→ L′ · M
  ```

- **简化规则（β 规则）**：这些规则将构造子和解构子配对，通过匹配表达式和函数应用进行简化。例如，`β-ƛ` 规则对应于 λ 项的应用：
  ```agda
  β-ƛ : ∀ {Γ A B} {N : Γ , A ⊢ B} {W : Γ ⊢ A}
    → Value W
      --------------------
    → (ƛ N) · W —→ N [ W ]
  ```

### 自反传递闭包（Reflexive Transitive Closure）

这一部分介绍了如何构建归约的自反传递

闭包，即在多步归约过程中跟踪项的变化。

### 自反传递闭包（Reflexive Transitive Closure）

#### 概念1：自反传递闭包的定义
- **自反传递闭包**：自反传递闭包（Reflexive Transitive Closure）允许我们在多步归约过程中跟踪项的变化。通过这种闭包，我们能够表达一个项如何经过多步归约从一个状态变为另一个状态。自反传递闭包的定义确保归约的路径是自反且传递的，这意味着我们可以在任何数量的步骤中从一项推导出另一项。

定义如下：
```agda
data _—↠_ {Γ A} : (Γ ⊢ A) → (Γ ⊢ A) → Set where
  _∎ : (M : Γ ⊢ A)
      ------
    → M —↠ M

  step—→ : (L : Γ ⊢ A) {M N : Γ ⊢ A}
    → M —↠ N
    → L —→ M
      ------
    → L —↠ N
```

- **自反性**：如果项 $M$ 自身没有变化，它可以归约为自身。这个通过 `_∎` 构造子来表达。

  公式表示为：
  $$
  M —↠ M
  $$

- **传递性**：如果项 $L$ 可以在一步内归约为 $M$，而 $M$ 又可以通过若干步归约为 $N$，那么 $L$ 可以通过若干步归约为 $N$。这一过程通过 `step—→` 构造子来表示。

  公式表示为：
  $$
  L —→ M \quad \text{且} \quad M —↠ N \quad \Rightarrow \quad L —↠ N
  $$

#### 概念2：模式匹配与构造闭包
在定义了自反传递闭包后，我们可以利用它来表达复杂归约路径。以下模式匹配用于简化归约路径的表示：

```agda
pattern _—→⟨_⟩_ L L—→M M—↠N = step—→ L M—↠N L—→M
```

- 通过 `begin_` 函数，我们可以简化表达式并构造归约路径：
```agda
begin_ : ∀ {Γ A} {M N : Γ ⊢ A}
  → M —↠ N
    ------
  → M —↠ N
begin M—↠N = M—↠N
```

### 归约例子（Reduction Examples）

#### 示例1：Church 数表示的二的应用
考虑将 Church 数表示的二应用于后继函数和零的例子。这一过程展示了如何通过多个步骤进行归约，最终得出结果。

- 初始项：
$$
twoᶜ · sucᶜ · `zero
$$

- 归约路径：
```agda
_ : twoᶜ · sucᶜ · `zero {∅} —↠ `suc `suc `zero
_ =
  begin
    twoᶜ · sucᶜ · `zero
  —→⟨ ξ-·₁ (β-ƛ V-ƛ) ⟩
    (ƛ (sucᶜ · (sucᶜ · # 0))) · `zero
  —→⟨ β-ƛ V-zero ⟩
    sucᶜ · (sucᶜ · `zero)
  —→⟨ ξ-·₂ V-ƛ (β-ƛ V-zero) ⟩
    sucᶜ · `suc `zero
  —→⟨ β-ƛ (V-suc V-zero) ⟩
   `suc (`suc `zero)
  ∎
```

每一步归约都通过模式匹配和递归调用来简化项，最终得出 Church 数 2 的表达式，即 `suc (suc zero)`，即自然数 2。

#### 示例2：二加二的归约
接下来看另一个例子，展示如何将两个自然数二相加。

- 初始项：
$$
plus \cdot two \cdot two
$$

- 归约路径：
```agda
_ : plus {∅} · two · two —↠ `suc `suc `suc `suc `zero
_ =
    plus · two · two
  —→⟨ ξ-·₁ (ξ-·₁ β-μ) ⟩
    (ƛ ƛ case (` S Z) (` Z) (`suc (plus · ` Z · ` S Z))) · two · two
  —→⟨ ξ-·₁ (β-ƛ (V-suc (V-suc V-zero))) ⟩
    (ƛ case two (` Z) (`suc (plus · ` Z · ` S Z))) · two
  —→⟨ β-ƛ (V-suc (V-suc V-zero)) ⟩
    case two two (`suc (plus · ` Z · two))
  —→⟨ β-suc (V-suc V-zero) ⟩
    `suc (plus · `suc `zero · two)
  —→⟨ ξ-suc (ξ-·₁ (ξ-·₁ β-μ)) ⟩
    `suc ((ƛ ƛ case (` S Z) (` Z) (`suc (plus · ` Z · ` S Z)))
      · `suc `zero · two)
  —→⟨ ξ-suc (ξ-·₁ (β-ƛ (V-suc V-zero))) ⟩
    `suc ((ƛ case (`suc `zero) (` Z) (`suc (plus · ` Z · ` S Z))) · two)
  —→⟨ ξ-suc (β-ƛ (V-suc (V-suc V-zero))) ⟩
    `suc (case (`suc `zero) (two) (`suc (plus · ` Z · two)))
  —→⟨ β-suc V-zero) ⟩
    `suc (`suc (plus · `zero · two))
  —→⟨ ξ-suc (ξ-suc (ξ-·₁ (ξ-·₁ β-μ))) ⟩
    `suc (`suc ((ƛ ƛ case (` S Z) (` Z) (`suc (plus · ` Z · ` S Z)))
      · `zero · two))
  —→⟨ ξ-suc (ξ-suc (ξ-·₁ (β-ƛ V-zero))) ⟩
    `suc (`suc ((ƛ case `zero (` Z) (`suc (plus · ` Z · ` S Z))) · two))
  —→⟨ ξ-suc (ξ-suc (β-ƛ (V-suc (V-suc V-zero)))) ⟩
    `suc (`suc (case `zero (two) (`suc (plus · ` Z · two))))
  —→⟨ ξ-suc (ξ-suc β-zero) ⟩
   `suc (`suc (`suc (`suc `zero)))
  ∎
```

通过一系列的递归和模式匹配，最终得出加法的结果，即 `suc (suc (suc (suc zero)))`，即自然数 4。

### 归约是确定的（Confluence）

在完成了归约规则和路径的定义后，我们可以讨论归约的确定性问题，即任何良类型的项如果能够归约，那么它最终将得到唯一的归约结果。

#### 概念1：归约的确定性
- **确定性（Confluence）**：归约的确定性保证了无论采用哪种归约路径，最终都能得到相同的结果。换句话说，归约过程不依赖于特定的顺序，所有合法的归约路径最终都将合并到同一个结果上。

#### 概念2：归约是确定的证明
虽然在这部分的具体实现中，作者省略了归约是确定的证明，但在理论上，我们可以通过构建自反传递闭包，并结合先前的归约规则，来证明这一性质。

---

通过上述讲解，我们可以看出本文探讨了如何利用 de Bruijn 因子和内在类型的 λ 演算在 Agda 中进行表达式的重命名、替换和归约操作。这些操作通过递归和模式匹配实现了项的简化和路径跟踪，展示了如何构建一个具有良好类型系统的归约路径和归约的确定性。在后续部分，还可以通过练习来更好地理解这些概念的具体实现。

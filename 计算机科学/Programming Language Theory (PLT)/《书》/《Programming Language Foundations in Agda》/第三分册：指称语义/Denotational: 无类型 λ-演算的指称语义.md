[toc]

### Denotational: 无类型 λ-演算的指称语义

本章主要探讨了无类型 λ-演算的指称语义，并逐步构建了其基本概念和证明。

#### 1. 导入

本节引入了各种基础库和类型，如 `Data.Nat`, `Data.Product`, `Data.Sum`, `Data.Vec`，这些库在定义和操作 λ-演算的指称语义时会被频繁使用。

#### 2. 值 (Value)

**概念**：
- **值 (Value)**：值数据类型表示函数的一部分，它们通常可以看作是输入-输出映射的有限序对集合。具体地，它们被定义为二叉树结构，内部节点表示并集运算符，叶子节点表示单个映射或空集。

**公式与解释**：
- 值类型的定义如下：
  $$
  \text{data Value : Set where}\\
  \quad \bot : Value \\
  \quad \_↦\_ : Value → Value → Value \\
  \quad \_⊔\_ : Value → Value → Value
  $$
  其中，$⊥$ 表示空值，$v ↦ w$ 表示输入 $v$ 映射到输出 $w$，$v ⊔ w$ 表示并集。

- **关系 ⊑**：将子集概念适配到 Value 数据类型上，用于实现自我应用。其定义如下：
  $$
  \text{data } _⊑_ : Value → Value → Set where \\
  \quad ⊑-bot : \forall {v} → ⊥ ⊑ v \\
  \quad ⊑-conj-L : \forall {u v w} → v ⊑ u → w ⊑ u → (v ⊔ w) ⊑ u \\
  \quad \dots
  $$
  该定义通过一系列规则来描述何时可以将一个值视为另一个值的子集。具体来说，规则 ⊑-fun 刻画了函数的逆变与协变性质，规则 ⊑-dist 则用于合并条目。

- **自反性**：
  $$
  ⊑-refl : \forall {v} → v ⊑ v
  $$
  该性质表明每个值都是其自身的子集。

- **并运算的单调性**：
  $$
  ⊔⊑⊔ : \forall {v w v' w'} → v ⊑ v' → w ⊑ w' → (v ⊔ w) ⊑ (v' ⊔ w')
  $$
  并集运算保留子集关系，即如果两个值分别是另两个值的子集，那么它们的并集也是子集关系。

#### 3. 环境 (Env)

**概念**：
- **环境 (Env)**：环境是一个将变量映射到值的函数，用于给项中的自由变量赋予意义。

**公式与解释**：
- 环境的定义如下：
  $$
  \text{Env : Context → Set} \\
  \text{Env Γ = ∀ (x : Γ ∋ ★) → Value}
  $$
  其中，$Γ$ 表示上下文，$Env Γ$ 表示将上下文中的每个变量映射到一个值。

- 环境可以是空的，也可以通过添加新的值进行扩展：
  $$
  `∅ : Env ∅ \\
  _`,_ : ∀ {Γ} → Env Γ → Value → Env (Γ , ★)
  $$

- 环境的扩展可以恢复到之前的环境，并通过连接操作符连接多个环境，保留逐点扩展的性质。

#### 4. 指称语义 (Denotational Semantics)

**概念**：
- **指称语义**：指称语义使用形如 $ρ ⊢ M ↓ v$ 的判断来定义，其中 $ρ$ 是环境，$M$ 是程序，$v$ 是结果值。该定义类似于大步语义，但存在一些重要区别。

### 指称语义 (Denotational Semantics)（续）

#### 4. 指称语义的规则

**概念**：
- **变量规则 (var)**：在环境 $γ$ 中，变量 $x$ 的指称语义是 $γ$ 中与 $x$ 对应的值。
- **函数应用规则 (↦-elim)**：如果在环境 $γ$ 中，$L$ 的指称语义是一个函数 $v ↦ w$，并且 $M$ 的指称语义是 $v$，那么函数应用 $L · M$ 的指称语义就是 $w$。
- **函数抽象规则 (↦-intro)**：如果在扩展环境 $γ`, $v$ 中，$N$ 的指称语义是 $w$，那么函数抽象 $\lambda N$ 的指称语义就是 $v ↦ w$。
- **底值引入规则 (⊥-intro)**：如果某个表达式在环境 $γ$ 中没有确定的值（即发散），则其指称语义为 $⊥$。
- **并集引入规则 (⊔-intro)**：如果某个表达式在环境 $γ$ 中可以产生两个值 $v$ 和 $w$，则其指称语义为 $v ⊔ w$。
- **子集规则 (sub)**：如果 $v$ 是 $w$ 的子集，并且在环境 $γ$ 中，$M$ 的指称语义是 $v$，那么 $M$ 的指称语义也可以是 $w$。

**公式与解释**：

- **变量规则**：
  $$
  \text{var : ∀ {Γ} {γ : Env Γ} {x}} \\
  \quad \text{---------------} \\
  \quad \text{γ ⊢ (` x) ↓ γ x}
  $$
  该规则表明，$γ$ 中的变量 $x$ 直接映射到它在环境中的值。

- **函数应用规则**：
  $$
  \text{↦-elim : ∀ {Γ} {γ : Env Γ} {L M v w}} \\
  \quad \text{γ ⊢ L ↓ (v ↦ w)} \\
  \quad \text{γ ⊢ M ↓ v} \\
  \quad \text{----------------} \\
  \quad \text{γ ⊢ (L · M) ↓ w}
  $$
  当 $L$ 表示一个函数并且 $M$ 表示该函数的输入时，函数应用 $L · M$ 结果为该函数的输出 $w$。

- **函数抽象规则**：
  $$
  \text{↦-intro : ∀ {Γ} {γ : Env Γ} {N v w}} \\
  \quad \text{γ `, v ⊢ N ↓ w} \\
  \quad \text{-------------------} \\
  \quad \text{γ ⊢ (ƛ N) ↓ (v ↦ w)}
  $$
  该规则表明，$\lambda$ 表达式的语义是一个函数，它将参数 $v$ 映射到结果 $w$。

- **底值引入规则**：
  $$
  \text{⊥-intro : ∀ {Γ} {γ : Env Γ} {M}} \\
  \quad \text{---------} \\
  \quad \text{γ ⊢ M ↓ ⊥}
  $$
  如果 $M$ 表示一个发散的程序，那么它的指称语义是 $⊥$。

- **并集引入规则**：
  $$
  \text{⊔-intro : ∀ {Γ} {γ : Env Γ} {M v w}} \\
  \quad \text{γ ⊢ M ↓ v} \\
  \quad \text{γ ⊢ M ↓ w} \\
  \quad \text{----------------} \\
  \quad \text{γ ⊢ M ↓ (v ⊔ w)}
  $$
  当 $M$ 可以产生多个值时，它的指称语义是这些值的并集。

- **子集规则**：
  $$
  \text{sub : ∀ {Γ} {γ : Env Γ} {M v w}} \\
  \quad \text{γ ⊢ M ↓ v} \\
  \quad \text{w ⊑ v} \\
  \quad \text{---------} \\
  \quad \text{γ ⊢ M ↓ w}
  $$
  如果 $w$ 是 $v$ 的子集，那么 $M$ 的指称语义也可以是 $w$。

#### 5. 指称语义的例子

**恒等函数**：

恒等函数 $\lambda x. x$ 是 λ-演算中的一个基本示例。该函数的指称语义表明它将任何输入映射到其自身。

- **恒等函数的定义**：
  $$
  \text{id : ∅ ⊢ ★} \\
  \quad \text{id = ƛ # 0}
  $$

- **恒等函数的指称语义**：
  $$
  \text{denot-id1 : ∀ {γ} → γ ⊢ id ↓ ⊥ ↦ ⊥} \\
  \quad \text{denot-id1 = ↦-intro var}
  $$
  该证明表明，在空环境下，恒等函数将 $⊥$ 映射到 $⊥$。

#### 6. 自应用和发散

**自应用**：

λ-演算中的自应用是指一个函数被应用到它自身的情形，如 $\Delta = λ x. (x x)$。这种情况下，函数的输入和输出都涉及到它自身的映射。

- **自应用的定义**：
  $$
  \text{Δ : ∅ ⊢ ★} \\
  \quad \text{Δ = (ƛ (# 0) · (# 0))}
  $$

- **自应用的指称语义**：
  $$
  \text{denot-Δ : ∀ {v w} → `∅ ⊢ Δ ↓ ((v ↦ w ⊔ v) ↦ w)} \\
  \quad \text{denot-Δ = ↦-intro (↦-elim (sub var (⊑-conj-R1 ⊑-refl)) (sub var (⊑-conj-R2 ⊑-refl)))}
  $$
  该证明展示了自应用的函数如何将其自身较小的版本映射到结果值。

**发散**：

经典的发散程序如 $\Omega = \Delta · \Delta$，表示为一个函数自应用于自身。这种情况下，程序的语义是 $⊥$，表示程序不会停止。

- **发散程序的定义**：
  $$
  \text{Ω : ∅ ⊢ ★} \\
  \quad \text{Ω = Δ · Δ}
  $$

- **发散程序的指称语义**：
  $$
  \text{denot-Ω : `∅ ⊢ Ω ↓ ⊥} \\
  \quad \text{denot-Ω = ↦-elim denot-Δ (⊔-intro (↦-intro ⊥-intro) ⊥-intro)}
  $$
  该证明展示了 $\Omega$ 程序的指称语义如何发散到 $⊥$。

#### 7. 函数小于关系的反演

**概念**：

在指称语义中，函数之间的小于关系是 λ-演算的一个重要性质。通过定义值的成员关系与包含关系，可以精确描述函数的反演性，即一个较小的函数如何包含在另一个较大的函数中。

**公式与解释**：

- **值的成员关系**：
  $$
  \text{_∈_ : Value → Value → Set} \\
  \text{u ∈ ⊥ = u ≡ ⊥} \\
  \text{u ∈ v ↦ w = u ≡ v ↦ w} \\
  \text{u ∈ (v ⊔ w) = u ∈ v ⊎ u ∈ w}
  $$
  成员关系用于判断一个值是否是另一个值的元素。

- **值的包含关系**：
  $$
  \text{_⊆_ : Value → Value → Set} \\
  \text{v ⊆ w = ∀{u} → u ∈ v → u ∈ w}
  $$
  包含关系表示一个值的所有元素是否都在另一个值中。

- **函数小于的反演法则**：
  $$
  \text{factor u u' v w = all-funs u' × u' ⊆ u × ⨆dom u' ⊑ v × w ⊑ ⨆cod u'}
  $$
  反演法则表明，如果

 $v ↦ w ⊑ u$，那么 $u$ 包含了一个函数值的集合，这些函数的定义域小于 $v$，陪域大于 $w$。

### 8. 总结

本章中，通过构建无类型 λ-演算的指称语义，展示了如何使用有限的表格来表示函数，并通过放宽表的查找实现自我应用。随后通过定义各种关系和规则，证明了指称语义的可组合性和反演性，最终为后续章节的研究奠定了基础。
[toc]

### Soundness: 指称语义归约的可靠性

#### 简介

本章的目标是证明指称语义的归约语义是可靠的。具体来说，我们希望证明对于任意项 $L$，如果 $L$ 通过多步归约序列最终归约到一个 $\lambda$ 抽象 $ƛ N$，那么 $L$ 的指称语义 $ℰ L$ 等价于 $ƛ N$ 的指称语义 $ℰ (ƛ N)$。

这个可靠性可以通过对归约序列进行归纳证明。主引理涉及到单个归约步骤，我们需要证明如果某个项 $M$ 归约到项 $N$，那么 $M$ 的语义和 $N$ 的语义是相等的。

**主要概念**：
- **归约序列**：指一系列从一个表达式到另一个表达式的变换步骤，直到不能再简化。
- **语义等价**：两个表达式的语义等价表示它们在任何环境下的求值结果相同。

这个证明过程分为两个方向进行。一个方向类似于类型保留性（type preservation）的证明，另一个方向类似于反向归约（即展开）的保型性证明。需要注意的是，类型保留性有时被称为主体归约（subject reduction），而反向的保型性通常称为主体展开（subject expansion）。大多数类型化 $\lambda$-演算并不满足主体展开的条件。

#### 导入

为了证明归约语义的可靠性，我们引入一些必要的模块和定义。这些模块帮助我们在 Agda 中进行形式化的推理。

```agda
open import Relation.Binary.PropositionalEquality
  using (_≡_; _≢_; refl; sym; cong; cong₂; cong-app)
open import Data.Product using (_×_; Σ; Σ-syntax; ∃; ∃-syntax; proj₁; proj₂)
  renaming (_,_ to ⟨_,_⟩)
open import Agda.Primitive using (lzero)
open import Relation.Nullary using (¬_)
open import Relation.Nullary.Negation using (contradiction)
open import Data.Empty using (⊥-elim)
open import Relation.Nullary using (Dec; yes; no)
open import Function using (_∘_)
open import plfa.part2.Untyped
     using (Context; _,_; _∋_; _⊢_; ★; Z; S_; `_; ƛ_; _·_;
            subst; _[_]; subst-zero; ext; rename; exts;
            _—→_; ξ₁; ξ₂; β; ζ; _—↠_; _—→⟨_⟩_; _∎)
open import plfa.part2.Substitution using (Rename; Subst; ids)
open import plfa.part3.Denotational
     using (Value; ⊥; Env; _⊢_↓_; _`,_; _⊑_; _`⊑_; `⊥; _`⊔_; init; last; init-last;
            ⊑-refl; ⊑-trans; `⊑-refl; ⊑-env; ⊑-env-conj-R1; ⊑-env-conj-R2; up-env;
            var; ↦-elim; ↦-intro; ⊥-intro; ⊔-intro; sub;
            rename-pres; ℰ; _≃_; ≃-trans)
open import plfa.part3.Compositional using (lambda-inversion; var-inv)
```

**主要概念**：
- **关系模块**（Relation Modules）：提供了等式和不等式的基本关系操作。
- **产品类型**（Product Types）：用于组合多个类型和对应的值。
- **上下文**（Context）：定义了表达式的上下文环境，包含类型信息。
- **值环境**（Value Environment）：定义了一个项在特定环境下的值。

这些导入的模块和定义提供了基础的语义操作和关系，它们在后续证明中扮演重要角色。

#### 向前归约保持指称不变

本节的目标是证明归约过程不会改变表达式的语义。具体来说，如果 $M$ 通过一步归约到 $N$，那么 $M$ 的语义和 $N$ 的语义是相等的。这一过程类似于之前类型保留性的证明，但这里是从语义的角度进行的。

##### 同时代换保持指称不变

我们首先证明的是**同时代换**在语义上保持不变。换句话说，如果 $M$ 在某个环境 $γ$ 中的求值结果是 $v$，那么对 $M$ 进行代换 $σ$ 后，在新的环境 $δ$ 中的求值结果仍然是 $v$。

**主要概念**：
- **同时代换**（Simultaneous Substitution）：对表达式中的多个变量同时进行替换。
- **环境**（Environment）：映射变量到其值的上下文。

定义一个关系来描述同时代换的语义保持不变：

$$
_`⊢_↓_ : ∀{Δ Γ} → Env Δ → Subst Γ Δ → Env Γ → Set
_`⊢_↓_ {Δ}{Γ} δ σ γ = (∀ (x : Γ ∋ ★) → δ ⊢ σ x ↓ γ x)
$$

这个关系表示，如果在环境 $γ$ 中的变量 $x$ 求值为 $v$，那么代换 $σ$ 应用后在新的环境 $δ$ 中，变量 $x$ 也应该求值为 $v$。

为了证明这个关系，我们需要一个扩展引理（Extension Lemma），即当我们扩展代换到一个更大的环境时，新的代换仍然保持语义的等价性。

##### 扩展引理证明

接下来，我们证明扩展引理 `subst-ext`。这个引理表明，应用扩展代换到一个新的变量上，仍然保持语义不变：

```agda
subst-ext : ∀ {Γ Δ v} {γ : Env Γ} {δ : Env Δ}
  → (σ : Subst Γ Δ)
  → δ `⊢ σ ↓ γ
   --------------------------
  → δ `, v `⊢ exts σ ↓ γ `, v
subst-ext σ d Z = var
subst-ext σ d (S x′) = rename-pres S_ (λ _ → ⊑-refl) (d x′)
```

**主要概念**：
- **de Bruijn 索引**：一种无名变量表示法，用数字表示变量的相对位置。
- **扩展引理**：扩展环境和代换的过程中，语义保持不变。

这个证明基于对 de Bruijn 索引 $x$ 进行的情况分析：
- 如果 $x = Z$，我们需要证明 $δ , v ⊢ \# 0 ↓ v$，这是通过 `var` 规则直接得出的。
- 如果 $x = S x′$，我们需要证明 $δ , v ⊢ rename S_ (σ x′) ↓ γ x′$，这是通过 `rename-pres` 引理证明的。

扩展引理证明了，当我们扩展代换和环境时，语义保持一致。利用这个引理，我们可以进一步证明同时代换保持语义不变。

##### 同时代换保持语义不变

我们利用扩展引理证明同时代换保持语义不变。具体来说，如果 $M$ 在环境 $γ$ 中的求值结果为 $v$，那么通过代换 $σ$ 得到的表达式 $subst σ M$ 在新的环境 $δ$ 中的求值结果仍然是 $v$：

```agda
subst-pres : ∀ {Γ Δ v} {γ : Env Γ} {δ : Env Δ} {M : Γ ⊢ ★}
  → (σ : Subst Γ Δ)
  → δ `⊢ σ ↓ γ
  → γ ⊢ M ↓ v
    ------------------
  → δ ⊢ subst σ M ↓ v
subst-pres σ s (var {x = x}) = s x
subst-pres σ s (↦-elim d₁ d₂) =
  ↦-elim (subst-pres σ s d₁) (subst-pres σ s d₂)
subst-pres σ s (↦-intro d) =
  ↦-intro (subst-pres (λ {A} → exts σ) (subst-ext σ s) d)
subst-pres σ s ⊥-intro = ⊥-intro
subst-pres σ s (⊔-intro d₁ d₂) =
  ⊔-intro (subst-pres σ s d₁) (subst-pres σ s d₂)
subst-pres σ s (sub d lt) = sub (subst-pres σ s d) lt
```

**主要概念**：
- **变量**：在特定环境下有一个确定的语义值。
- **$\lambda$-抽象**：可以通过扩展代换进行归纳推导。

通过对 $M$ 的语义进行归纳

，结合代换规则，我们证明了同时代换保持语义不变。

##### 单一代换保持指称不变

接下来我们需要证明**单一代换**的语义不变性。这对于处理 $\beta$-归约非常关键。假设我们有一个 $\beta$-归约 $(ƛ N) · M —→ N [ M ]$，我们需要证明当用 $M$ 代换 $N$ 中的 de Bruijn 索引 $0$ 时，语义保持不变。

通过反演规则 `↦-elim` 和 `↦-intro`，我们得出以下情况：
- $γ , v ⊢ M ↓ w$
- $γ ⊢ N ↓ v$

我们需要证明 $γ ⊢ M [ N ] ↓ w$，也就是证明 $γ ⊢ subst (subst-zero N) M ↓ w$：

```agda
substitution : ∀ {Γ} {γ : Env Γ} {N M v w}
   → γ `, v ⊢ N ↓ w
   → γ ⊢ M ↓ v
     ---------------
   → γ ⊢ N [ M ] ↓ w
substitution{Γ}{γ}{N}{M}{v}{w} dn dm =
  subst-pres (subst-zero M) sub-z-ok dn
  where
  sub-z-ok : γ `⊢ subst-zero M ↓ (γ `, v)
  sub-z-ok Z = dm
  sub-z-ok (S x) = var
```

**主要概念**：
- **单一代换**：将表达式中的某个特定变量替换为另一个表达式。
- **$\beta$-归约**：在 $\lambda$ 演算中，应用函数到某个值的过程。

单一代换的证明是通过代换引理和对 $M$ 语义的归纳推导完成的。这个引理是我们后续证明 $\beta$-归约保持语义不变的关键。

##### 归约保持指称不变

最后，我们利用上述的代换引理，证明归约保持指称不变。也就是说，如果 $M$ 通过一步归约到 $N$，那么 $M$ 和 $N$ 的语义是相等的：

```agda
preserve : ∀ {Γ} {γ : Env Γ} {M N v}
  → γ ⊢ M ↓ v
  → M —→ N
    ----------
  → γ ⊢ N ↓ v
preserve (var) ()
preserve (↦-elim d₁ d₂) (ξ₁ r) = ↦-elim (preserve d₁ r) d₂
preserve (↦-elim d₁ d₂) (ξ₂ r) = ↦-elim d₁ (preserve d₂ r)
preserve (↦-elim d₁ d₂) β = substitution (lambda-inversion d₁) d₂
preserve (↦-intro d) (ζ r) = ↦-intro (preserve d r)
preserve ⊥-intro r = ⊥-intro
preserve (⊔-intro d d₁) r = ⊔-intro (preserve d r) (preserve d₁ r)
preserve (sub d lt) r = sub (preserve d r) lt
```

**主要概念**：
- **归约步骤**：表达式从一种形式变为另一种更简单形式的过程。
- **语义等价**：证明两个表达式在任何环境下的求值结果相同。

这个证明通过对 $M$ 的语义进行归纳，并对归约过程进行详细的情况分析来完成。如果 $M$ 是变量，无需归约；如果是应用，归约可能涉及合同性（ξ₁ 或 ξ₂）或 $\beta$-归约。每种情况都需要结合之前的引理进行证明。

---

这部分内容已经覆盖了章节的前几个部分，剩余部分包括反向归约反映指称不变、单一代换的反映性等。若需要进一步细分解释，可以继续为你讲解后续部分。



### 归约反映了指称不变

#### 重命名反映了含义不变

在本节中，我们首先需要证明重命名在语义上保持不变，即如果我们对表达式进行重命名操作，那么在新的环境下，重命名后的表达式的求值结果与原始表达式的求值结果是相等的。这个过程在证明反向归约时非常关键。

**主要概念**：
- **重命名**（Renaming）：在表达式中替换变量的名称，但不改变表达式的结构或语义。
- **指称等价**（Denotational Equivalence）：两个表达式在任意环境下具有相同的语义。

我们首先定义了一个扩展引理 `ext-`⊑`，该引理说明当我们扩展重命名映射时，语义保持不变：

$$
ext-`⊑ : ∀ {Γ Δ v} {γ : Env Γ} {δ : Env Δ}
  → (ρ : Rename Γ Δ)
  → (δ ∘ ρ) `⊑ γ
    ------------------------------
  → ((δ `, v) ∘ ext ρ) `⊑ (γ `, v)
$$

这个引理表示，如果在环境 $γ$ 中对变量进行重命名 $ρ$，产生的新环境 $δ ∘ ρ$ 保持语义等价，那么扩展后的新环境 $((δ `, v) ∘ ext ρ)$ 也保持与扩展后的 $γ$ 等价。

接着，我们证明了重命名反映语义不变的主要引理 `rename-reflect`：

```agda
rename-reflect : ∀ {Γ Δ v} {γ : Env Γ} {δ : Env Δ} { M : Γ ⊢ ★}
  → {ρ : Rename Γ Δ}
  → (δ ∘ ρ) `⊑ γ
  → δ ⊢ rename ρ M ↓ v
    ------------------------------------
  → γ ⊢ M ↓ v
```

**主要概念**：
- **重命名反射性**（Renaming Reflection）：如果对表达式 $M$ 进行重命名后的求值结果是 $v$，那么原始表达式 $M$ 在原环境下的求值结果也是 $v$。

证明过程涉及对 $M$ 的结构进行归纳：

1. 如果 $M$ 是一个变量，我们使用引理 `var-inv` 进行反演，得出 $v ⊑ δ (ρ x)$。将前提实例化，我们有 $δ (ρ x) ⊑ γ x$，即通过 `var` 规则得出 $γ ⊢ x ↓ v$。
   
2. 如果 $M$ 是 $\lambda$ 抽象 $ƛ N$，重命名后结果是 $ƛ (rename (ext ρ) N)$。根据归纳假设，我们证明了扩展的重命名映射保持语义不变。

3. 对于应用表达式 $L · M$，我们通过对 $δ ⊢ (rename ρ L) · (rename ρ M) ↓ v$ 进行归纳推导来证明。这种情况的证明是通过对所有可能的归约情况进行分析。

在以后的应用中，重命名通常是增量函数（incremental function），因此我们在这里为这些特殊情况证明以下推论：

```agda
rename-inc-reflect : ∀ {Γ v′ v} {γ : Env Γ} { M : Γ ⊢ ★}
  → (γ `, v′) ⊢ rename S_ M ↓ v
    ----------------------------
  → γ ⊢ M ↓ v
rename-inc-reflect d = rename-reflect `⊑-refl d
```

这个推论表示，如果对一个表达式 $M$ 进行增量重命名，且结果在扩展后的环境下求值为 $v$，那么原始表达式 $M$ 在原环境下的求值结果也是 $v$。

#### 代换反映了指称不变：变量的情况

在证明反向归约时，**代换**的反映性也非常关键。我们首先从最简单的情况开始，即当 $M$ 是一个变量时，证明代换反映了指称不变。

假设我们有一个代换 $σ$ 和环境 $γ$，并且知道 $γ ⊢ σ x ↓ v$。我们需要证明存在某个环境 $δ$ 使得 $γ ⊢ σ ↓ δ$ 并且 $δ ⊢ ` x ↓ v$。

**主要概念**：
- **代换**（Substitution）：将表达式中的某个变量替换为另一个表达式的过程。
- **变量的情况**：当表达式是一个变量时，代换的语义反映性如何影响整个表达式的语义。

为了实现这个证明，我们定义了一个环境 `const-env x v`，它将变量 $x$ 映射到值 $v$，并将其他变量映射到 $\perp$。我们利用这个环境来证明代换的反映性：

```agda
const-env : ∀{Γ} → (x : Γ ∋ ★) → Value → Env Γ
const-env x v y with x var≟ y
...             | yes _       = v
...             | no _        = ⊥
```

这个定义中，`var≟` 是一个用于比较两个变量是否相等的函数。如果变量相等，则映射到 $v$，否则映射到 $\perp$。

我们接下来证明，当 $x ≡ y$ 时，有 $γ ⊢ σ y ↓ v$；当 $x ≢ y$ 时，有 $γ ⊢ σ y ↓ ⊥$，从而完成了代换反映性的证明：

```agda
subst-reflect-var : ∀ {Γ Δ} {γ : Env Δ} {x : Γ ∋ ★} {v} {σ : Subst Γ Δ}
  → γ ⊢ σ x ↓ v
    -----------------------------------------
  → Σ[ δ ∈ Env Γ ] γ `⊢ σ ↓ δ  ×  δ ⊢ ` x ↓ v
subst-reflect-var {Γ}{Δ}{γ}{x}{v}{σ} xv
  rewrite sym (same-const-env {Γ}{x}{v}) =
    ⟨ const-env x v , ⟨ const-env-ok , var ⟩ ⟩
  where
  const-env-ok : γ `⊢ σ ↓ const-env x v
  const-env-ok y with x var≟ y
  ... | yes x≡y rewrite sym x≡y | same-const-env {Γ}{x}{v} = xv
  ... | no x≢y rewrite diff-const-env {Γ}{x}{y}{v} x≢y = ⊥-intro
```

这个引理证明了，对于任意变量 $x$，代换操作保持语义不变。在后续的更复杂的情况下，这个引理是一个基础。

#### 代换与环境的构造

为了进一步证明复杂表达式下的语义不变性，我们还需要证明代换与环境的构造性。具体来说，每一个代换都能产生一些可求值为 $\perp$ 的项。

```agda
subst-⊥ : ∀{Γ Δ}{γ : Env Δ}{σ : Subst Γ Δ}
    -----------------
  → γ `⊢ σ ↓ `⊥
subst-⊥ x = ⊥-intro
```

此外，如果代换产生的项在两个环境 $γ₁$ 和 $γ₂$ 中都有值，那么这些项的求值结果在联合环境 $γ₁ `⊔ γ₂$ 中也是有值的：

```agda
subst-⊔ : ∀{Γ Δ}{γ : Env Δ}{γ₁ γ₂ : Env Γ}{σ : Subst Γ Δ}
           → γ `⊢ σ ↓ γ₁
           → γ `⊢ σ ↓ γ₂
             -------------------------
           → γ `⊢ σ ↓ (γ₁ `⊔ γ₂)
subst-⊔ γ₁-ok γ₂-ok x = ⊔-intro (γ₁-ok x) (γ₂-ok x)
```

这个引理表示，当两个环境中的代换项分别有值时，它们的联合环境中的代换项也有值。这是对更复杂的归约情况进行反映性证明的基础。

#### $\lambda$ 构造子是单射的

我们需要一个辅助引理来处理 $\lambda$ 抽象的情况。具体来说，$\lambda$ 构造子是单射的，也就是说，如果 $ƛ M ≡ ƛ N$，那么 $M ≡ N$：

```agda
lambda-inj : ∀ {Γ} {M N : Γ , ★ ⊢ ★ }
  → _≡_ {A = Γ ⊢ ★} (ƛ M) (ƛ N)
    ---------------------------
  → M ≡ N
lambda-inj refl = refl
```

这个引理说明了 $\lambda$

 抽象的唯一性，为后续的反映性证明提供了必要的工具。

#### 同时代换反映了指称相等

接下来，我们要证明同时代换反映指称相等。也就是说，如果 $γ ⊢ subst σ M ↓ v$，那么存在一个环境 $δ$ 使得 $δ ⊢ M ↓ v$，并且 $γ `⊢ σ ↓ δ$。

这个引理是通过对 $γ ⊢ subst σ M ↓ v$ 的归纳推导证明的。

**主要概念**：
- **同时代换的反映性**：代换操作的结果在新的环境中保持语义不变。

```agda
subst-reflect : ∀ {Γ Δ} {δ : Env Δ} {M : Γ ⊢ ★} {v} {L : Δ ⊢ ★} {σ : Subst Γ Δ}
  → δ ⊢ L ↓ v
  → subst σ M ≡ L
    ---------------------------------------
  → Σ[ γ ∈ Env Γ ] δ `⊢ σ ↓ γ  ×  γ ⊢ M ↓ v
```

证明过程首先处理 $M$ 是变量的情况，这部分已经通过前面的 `subst-reflect-var` 引理解决。接下来我们需要处理 $M$ 是应用或 $\lambda$ 抽象的情况。这些情况的证明是基于先前的推论和引理的组合。

---

这部分内容已经进一步讲解了章节中的核心概念和证明方法，剩余部分包括反映性的证明、归约反映指称不变、归约蕴含指称等价等。如果需要更深入的解释或继续后续内容，请告诉我！



#### 单一代换反映了指称不变

前面我们已经证明了同时代换反映指称不变，但在特定的归约情况下，我们可能只需要处理单一代换。单一代换（Substitution）是在表达式中只替换一个变量的情况。具体来说，我们要证明，当一个表达式 $N[M]$ 经过单一代换后，如果它的求值结果是 $v$，那么必定存在一个值 $w$，使得 $M$ 的求值结果是 $w$，并且 $N$ 的求值结果也是 $v$，在环境被扩展后的情况下。

**主要概念**：
- **单一代换**：用一个表达式替换另一个表达式中的单一变量。
- **代换的反映性**：如果一个代换后的表达式能求值为某个值，那么原表达式的某些部分在合适的环境下也应该能求值为相同或相关的值。

我们首先定义了一个关于 `subst-zero` 的引理，即如果我们使用代换 `subst-zero M` 替换掉一个表达式中的变量，那么这个表达式的求值结果与原始表达式的求值结果是相等的：

```agda
subst-zero-reflect : ∀ {Δ} {δ : Env Δ} {γ : Env (Δ , ★)} {M : Δ ⊢ ★}
  → δ `⊢ subst-zero M ↓ γ
    ----------------------------------------
  → Σ[ w ∈ Value ] γ `⊑ (δ `, w) × δ ⊢ M ↓ w
```

**主要概念**：
- **`subst-zero` 代换**：特指用 $M$ 替换掉 $N$ 中的一个特定变量（通常是第一个变量）。

这个引理的证明是基于一个简单的选择：$w$ 是 $γ$ 中的最后一个值。根据这个引理，我们可以找到一个值 $w$，使得当用 $M$ 替换掉 $N$ 的变量时，整个表达式的求值结果保持不变。

接下来，我们正式证明单一代换的反映性：

```agda
substitution-reflect : ∀ {Δ} {δ : Env Δ} {N : Δ , ★ ⊢ ★} {M : Δ ⊢ ★} {v}
  → δ ⊢ N [ M ] ↓ v
    ------------------------------------------------
  → Σ[ w ∈ Value ] δ ⊢ M ↓ w  ×  (δ `, w) ⊢ N ↓ v
```

**证明思路**：
- 我们首先应用前面的 `subst-reflect` 引理，将代换后的表达式 $N[M]$ 转化为标准形式。
- 接着应用 `subst-zero-reflect` 引理，找到一个值 $w$，并证明原始表达式 $M$ 在合适的环境下的求值结果也是 $w$。

这样，我们得出了一个推论：在某个扩展的环境下，$N$ 的求值结果是 $v$，并且 $M$ 的求值结果是 $w$。

#### 归约反映了指称不变

利用前面已经证明的代换反映性，我们可以更容易地证明归约（Reduction）操作也拥有类似的性质：即如果一个表达式 $M$ 通过归约规则转化为 $M'$，且 $M'$ 在某个环境下的求值结果是 $v$，那么 $M$ 在同一个环境下的求值结果也是 $v$。

**主要概念**：
- **归约**：在 $\lambda$ 演算中，将一个复杂的表达式逐步简化成更简单的形式，最终得到最简形式（标准形式）的过程。
- **反映性**：在归约的过程中，表达式的语义（指称）不会改变。

我们首先证明特定的 $\beta$-规约的反映性：

```agda
reflect-beta : ∀{Γ}{γ : Env Γ}{M N}{v}
    → γ ⊢ (N [ M ]) ↓ v
    → γ ⊢ (ƛ N) · M ↓ v
reflect-beta d
    with substitution-reflect d
... | ⟨ v₂′ , ⟨ d₁′ , d₂′ ⟩ ⟩ = ↦-elim (↦-intro d₂′) d₁′
```

在这个引理中，如果我们已经知道 $N[M]$ 的求值结果是 $v$，那么我们可以通过 `substitution-reflect` 引理找到 $M$ 和 $N$ 的求值结果，并利用 $\lambda$ 规约规则推导出整个表达式的求值结果也是 $v$。

接下来，我们定义了一个更一般的 `reflect` 引理，用于处理任何归约规则：

```agda
reflect : ∀ {Γ} {γ : Env Γ} {M M′ N v}
  → γ ⊢ N ↓ v  →  M —→ M′  →   M′ ≡ N
    ---------------------------------
  → γ ⊢ M ↓ v
```

**证明思路**：
- 首先对不同的归约规则进行归纳推导，考虑 $M$ 和 $M'$ 的结构。
- 对每一个可能的归约步骤，都证明在相同的环境下，$M$ 和 $M'$ 的求值结果是相同的。

例如：
- 对于 `β-归约`，我们利用前面的 `reflect-beta` 引理。
- 对于其他归约规则，如应用规则（`ξ₁` 和 `ξ₂`），我们分别应用反映性推导。

这样，通过归纳推导和结合已经证明的推论和引理，我们证明了归约反映了指称不变。

#### 归约蕴含指称等价

最后，我们将所有前面的结果结合在一起，证明了归约操作实际上蕴含了指称等价。换句话说，如果一个表达式 $M$ 通过归约转化为 $N$，那么 $M$ 和 $N$ 的指称（语义）是等价的。

```agda
reduce-equal : ∀ {Γ} {M : Γ ⊢ ★} {N : Γ ⊢ ★}
  → M —→ N
    ---------
  → ℰ M ≃ ℰ N
```

**主要概念**：
- **指称等价**：两个表达式在所有环境下的求值结果是相同的。
- **归约的可靠性**（Soundness）：如果一个表达式可以通过一系列归约操作转化为另一个表达式，那么这两个表达式在语义上是等价的。

在这个引理中，利用前面已经证明的归约保持性和反映性，我们得出如果 $M$ 通过归约转化为 $N$，那么它们的指称是等价的。

#### 归约的可靠性

最终，我们得出了归约的可靠性（Soundness Property）。即如果一个表达式 $M$ 经过多步归约到一个 $\lambda$-抽象 $ƛ N$，那么 $M$ 和 $ƛ N$ 的指称是等价的：

```agda
soundness : ∀{Γ} {M : Γ ⊢ ★} {N : Γ , ★ ⊢ ★}
  → M —↠ ƛ N
    -----------------
  → ℰ M ≃ ℰ (ƛ N)
```

这个证明通过逐步应用前面所有的引理和推论得出，证明了 $M$ 和 $ƛ N$ 的指称等价。归约的可靠性意味着，在 $\lambda$ 演算的语义中，多步归约操作不会改变表达式的语义。

---

通过对这一章的逐步讲解，我们已经详细解释了归约反映性和保持性的概念，并通过证明这些性质，最终得出了归约操作的可靠性。如果你对其中的某个具体部分有疑问或者需要进一步深入理解，随时告诉我！

### -----------------------------


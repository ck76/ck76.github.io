[toc]

以下是本章节涉及的所有数理逻辑相关概念及其解释：

### 1. **命题即类型（Propositions as Types）**
   - 这是一个核心的思想，即逻辑命题可以被解释为类型，证明可以被解释为类型的实例。通过这种观点，逻辑运算符对应于类型运算符。

### 2. **合取（Conjunction, $A \times B$）**
   - 合取是一个逻辑运算符，对应于两个命题 $A$ 和 $B$ 的同时成立。其类型表示为 $A \times B$，即两个类型的积。
   - 在计算机科学中，这对应于记录类型或笛卡尔积。
   - **构造子**: $\langle x, y \rangle$ 表示合取成立，其中 $x$ 是 $A$ 成立的证明，$y$ 是 $B$ 成立的证明。
   - **解构子**: $proj_1$ 和 $proj_2$ 分别提取合取的第一部分和第二部分。

### 3. **析取（Disjunction, $A \uplus B$ 或 $A \oplus B$）**
   - 析取是一个逻辑运算符，对应于两个命题 $A$ 和 $B$ 中至少一个成立。其类型表示为 $A \uplus B$，即两个类型的和。
   - 在计算机科学中，这对应于变体记录类型或不交并。
   - **构造子**: $inj_1(x)$ 和 $inj_2(y)$ 分别表示 $A$ 成立或者 $B$ 成立。
   - **解构子**: $case\_⊎$ 用于对析取类型进行模式匹配，从而得到具体的结论。

### 4. **真（True, $\top$）**
   - 真命题对应的类型是单元类型 $\top$，它表示恒真命题，总是成立。
   - 在类型论中，$\top$ 是只有一个值（$tt$）的类型。
   - **构造子**: $tt$ 表示真命题成立。

### 5. **假（False, $\bot$）**
   - 假命题对应的类型是空类型 $\bot$，它表示恒假命题，从不成立。
   - 在类型论中，$\bot$ 是没有任何值的类型。
   - **消去规则**: $\bot\_elim$，从假命题中可以推出任何命题。

### 6. **蕴涵（Implication, $A \rightarrow B$）**
   - 蕴涵表示命题 $A$ 蕴涵命题 $B$，即如果 $A$ 成立，那么 $B$ 也成立。其类型表示为 $A \rightarrow B$，对应于函数类型。
   - **构造子**: $\lambda (x : A) \rightarrow N$ 表示从 $A$ 到 $B$ 的函数。
   - **解构子**: 通过函数应用，可以从 $A \rightarrow B$ 的证明和 $A$ 的证明推导出 $B$。

### 7. **函数空间（Function Space, $A \rightarrow B$）**
   - 函数空间对应于从一个类型 $A$ 到另一个类型 $B$ 的映射，形式化为 $A \rightarrow B$，即蕴涵的类型对应。
   - 如果 $A$ 有 $m$ 个不同的成员，$B$ 有 $n$ 个不同的成员，那么 $A \rightarrow B$ 有 $n^m$ 个不同的成员。

### 8. **积（Product, $A \times B$）**
   - 积是两个类型的乘积，对应于合取的类型。类型 $A \times B$ 的成员是所有 $A$ 和 $B$ 成员的有序对。
   - 积满足交换律和结合律，但在同构意义下。

### 9. **和（Sum, $A \uplus B$ 或 $A \oplus B$）**
   - 和是两个类型的和集，对应于析取的类型。类型 $A \uplus B$ 的成员是 $A$ 或 $B$ 的成员。
   - 和满足交换律和结合律，但在同构意义下。

### 10. **单元类型（Unit Type, $\top$）**
   - 单元类型是只有一个值的类型，通常用来表示真命题。在数理逻辑中，$\top$ 对应于逻辑恒真。
   - 它是积的幺元，在同构意义下，满足 $\top \times A \cong A$。

### 11. **空类型（Empty Type, $\bot$）**
   - 空类型是没有值的类型，通常用来表示假命题。在数理逻辑中，$\bot$ 对应于逻辑恒假。
   - 它是和的幺元，在同构意义下，满足 $\bot \uplus A \cong A$。

### 12. **外延性（Extensionality）**
   - 外延性断言了如果两个函数在所有输入下的输出相同，那么这两个函数相等。
   - 在类型论中，外延性常作为假设用于证明函数空间的性质。

### 13. **η-等式（Eta-equality）**
   - η-等式是指，如果一个函数在所有输入下的行为和某个已知函数相同，那么这两个函数被认为是相等的。对于积和和类型，也有类似的 η-等式。

### 14. **柯里化（Currying）**
   - 柯里化是指将多参数函数转换为嵌套的一元函数，或者反过来，将嵌套的一元函数转换为多参数函数。柯里化本质上是函数空间的同构 $A \rightarrow (B \rightarrow C) \cong (A \times B) \rightarrow C$。

### 15. **分配律（Distributive Laws）**
   - 在同构意义下，积和和之间满足分配律。例如，$A \times (B \uplus C) \cong (A \times B) \uplus (A \times C)$。
   - 另一个分配律是 $A \uplus (B \times C) \preceq (A \uplus B) \times (A \uplus C)$，但这是一个嵌入（$\preceq$），而不是同构。

这些概念在数理逻辑和类型论中是基本的，通过这些概念，我们能够构建和理解复杂的逻辑推理和计算结构。



### ---------------------

### Connectives: 合取、析取与蕴涵

#### 概述

本章节介绍了一些基础的逻辑运算符，并将这些运算符与数据类型对应起来。这种方法基于“命题即类型（Propositions as Types）”的原理，在计算机科学和逻辑学中有广泛应用。具体而言，以下是本章节要探讨的内容：

- **合取（Conjunction）**：对应积（Product）
- **析取（Disjunction）**：对应和（Sum）
- **真（True）**：对应单元类型（Unit Type）
- **假（False）**：对应空类型（Empty Type）
- **蕴涵（Implication）**：对应函数空间（Function Space）

这些概念在逻辑中有着深刻的含义，并且可以通过类型系统中的结构得到形式化和解释。

### 导入

在讨论这些逻辑运算符之前，我们需要导入一些相关模块，以便在 Agda 代码中使用必要的功能：

```agda
import Relation.Binary.PropositionalEquality as Eq
open Eq using (_≡_; refl)
open Eq.≡-Reasoning
open import Data.Nat using (ℕ)
open import Function using (_∘_)
open import plfa.part1.Isomorphism using (_≃_; _≲_; extensionality; _⇔_)
open plfa.part1.Isomorphism.≃-Reasoning
```

### 合取即是积

#### 概念：合取

**合取**是指两个命题 $A$ 和 $B$ 的同时成立。在逻辑中，合取运算符通常表示为 $A \land B$。在类型系统中，合取对应的结构是积类型（Product Type）。我们用积类型表示 $A \land B$，其成立意味着 $A$ 和 $B$ 都成立。

##### 形式化定义

合取在类型系统中的形式化定义如下：

```agda
data _×_ (A B : Set) : Set where
  ⟨_,_⟩ : A → B → A × B
```

这里的 $A \times B$ 类型表示 $A$ 和 $B$ 的同时成立。构造子 $\langle M, N \rangle$ 代表了 $A \times B$ 的一个实例，其中 $M$ 是 $A$ 成立的证明，$N$ 是 $B$ 成立的证明。

#### 概念：消去

**消去**规则用于从合取 $A \times B$ 的成立中分别提取出 $A$ 和 $B$ 的成立。

##### 形式化定义

消去规则可以通过以下方式定义：

```agda
proj₁ : ∀ {A B : Set} → A × B → A
proj₁ ⟨ x , y ⟩ = x

proj₂ : ∀ {A B : Set} → A × B → B
proj₂ ⟨ x , y ⟩ = y
```

这里，`proj₁` 函数返回合取中的第一个元素，即 $A$ 的证明；`proj₂` 函数返回第二个元素，即 $B$ 的证明。

#### 概念：引入与消去

引入和消去是合取的两个核心操作：

- **引入**操作用于构造合取的证明，通过构造子 $\langle M, N \rangle$ 实现。
- **消去**操作用于从合取中提取信息，通过解构子 `proj₁` 和 `proj₂` 实现。

这些操作的对应规则可以总结如下：

- **引入规则（×-I）**：描述了在什么条件下可以构造一个合取。
- **消去规则（×-E₁ 和 ×-E₂）**：描述了如何从合取中提取出具体的证明。

#### 概念：η-等式

**η-等式**表明，如果我们先使用解构子从合取中提取出元素，再使用这些元素重建合取，得到的将是原来的合取。

##### 形式化定义

```agda
η-× : ∀ {A B : Set} (w : A × B) → ⟨ proj₁ w , proj₂ w ⟩ ≡ w
η-× ⟨ x , y ⟩ = refl
```

通过模式匹配，我们可以将 $w$ 替换为 $\langle x, y \rangle$，从而使等式的两边化简为相同的值。

#### 概念：合取的优先级

合取的优先级设定为与除了析取之外的其他运算符结合得不紧密。这样可以确保表达式在解析时不会产生歧义。

##### 形式化定义

```agda
infixr 2 _×_
```

例如，表达式 $m \leq n \times n \leq p$ 将被解析为 $(m \leq n) \times (n \leq p)$。

#### 概念：作为记录类型的合取

合取也可以通过记录类型来表示，这种表示形式有时更为方便，尤其是在处理 η-等式时。

##### 形式化定义

```agda
record _×′_ (A B : Set) : Set where
  constructor ⟨_,_⟩′
  field
    proj₁′ : A
    proj₂′ : B
open _×′_
```

- **η-等式在记录类型中的表现**：对于记录类型，η-等式可以直接通过定义来成立，而不需要通过模式匹配来证明。

```agda
η-×′ : ∀ {A B : Set} (w : A ×′ B) → ⟨ proj₁′ w , proj₂′ w ⟩′ ≡ w
η-×′ w = refl
```

#### 概念：积的性质

积类型在集合论中被称为笛卡尔积（Cartesian Product），在计算机科学中对应记录类型。其性质如下：

- **交换律**：$A \times B$ 与 $B \times A$ 之间存在同构。
- **结合律**：$(A \times B) \times C$ 与 $A \times (B \times C)$ 之间存在同构。

这些性质在类型系统中有着广泛的应用和重要的理论意义。

---

这个部分主要介绍了合取的定义、消去、引入、η-等式以及合取的性质。如果你想继续深入了解其他部分，比如析取、真、假或蕴涵等内容，请告诉我，我可以进一步讲解。

### 析取即是和

#### 概念：析取

**析取**是指两个命题 $A$ 和 $B$ 中至少有一个成立。在逻辑中，析取运算符通常表示为 $A \lor B$。在类型系统中，析取对应的结构是和类型（Sum Type）。我们用和类型表示 $A \lor B$，其成立意味着 $A$ 成立或 $B$ 成立。

##### 形式化定义

析取在类型系统中的形式化定义如下：

```agda
data _⊎_ (A B : Set) : Set where
  inj₁ : A → A ⊎ B
  inj₂ : B → A ⊎ B
```

这里的 $A \sqcup B$ 类型表示 $A$ 或 $B$ 的成立。`inj₁ M` 表示 $A$ 成立，而 `inj₂ N` 表示 $B$ 成立。

#### 概念：消去

**消去**规则用于从析取 $A \sqcup B$ 的成立中得出某个命题 $C$ 成立。换句话说，如果我们知道 $A \rightarrow C$ 和 $B \rightarrow C$ 都成立，并且 $A \sqcup B$ 成立，那么我们可以得出 $C$ 成立。

##### 形式化定义

消去规则可以通过以下方式定义：

```agda
case-⊎ : ∀ {A B C : Set}
  → (A → C)
  → (B → C)
  → A ⊎ B
  → C
case-⊎ f g (inj₁ x) = f x
case-⊎ f g (inj₂ y) = g y
```

在这个定义中，`case-⊎` 是一个消去规则：它接受两个函数 $f : A \rightarrow C$ 和 $g : B \rightarrow C$，并将 $A \sqcup B$ 的成立映射到 $C$ 的成立。

#### 概念：引入与消去

引入和消去是析取的两个核心操作：

- **引入**操作用于构造析取的证明，通过构造子 `inj₁` 和 `inj₂` 实现。
- **消去**操作用于从析取中得出结论，通过解构子 `case-⊎` 实现。

这些操作的对应规则可以总结如下：

- **引入规则（⊎-I₁ 和 ⊎-I₂）**：描述了在什么条件下可以构造一个析取。
- **消去规则（⊎-E）**：描述了如何从析取中得出一个结论。

#### 概念：η-等式

**η-等式**表明，如果我们先使用解构子从析取中提取出元素，再使用这些元素重建析取，得到的将是原来的析取。

##### 形式化定义

```agda
η-⊎ : ∀ {A B : Set} (w : A ⊎ B) → case-⊎ inj₁ inj₂ w ≡ w
η-⊎ (inj₁ x) = refl
η-⊎ (inj₂ y) = refl
```

这里，通过模式匹配，我们可以证明对构造子的消去不会改变原来的值。

#### 概念：析取的优先级

析取的优先级设定为与其他逻辑运算符结合得不紧密。这样可以确保表达式在解析时不会产生歧义。

##### 形式化定义

```agda
infixr 1 _⊎_
```

例如，表达式 $A \times C \sqcup B \times C$ 将被解析为 $(A \times C) \sqcup (B \times C)$。

#### 概念：和的性质

和类型在集合论中被称为不交并（Disjoint Union），在计算机科学中对应变体记录类型。其性质如下：

- **交换律**：$A \sqcup B$ 与 $B \sqcup A$ 之间存在同构。
- **结合律**：$(A \sqcup B) \sqcup C$ 与 $A \sqcup (B \sqcup C)$ 之间存在同构。

这些性质在类型系统中有着广泛的应用和重要的理论意义。

#### 练习：⊎-comm 和 ⊎-assoc

练习可以帮助理解析取的交换律和结合律。你可以尝试证明：

1. **⊎-comm**：证明和类型在同构意义下满足交换律。
2. **⊎-assoc**：证明和类型在同构意义下满足结合律。

---

### 真即是单元类型

#### 概念：真

**真**（True）是指一个命题恒为真。在逻辑中，真命题通常表示为 $\top$。在类型系统中，真命题对应的结构是单元类型（Unit Type）。我们用单元类型表示 $\top$，其成立意味着真命题恒为真。

##### 形式化定义

真命题在类型系统中的形式化定义如下：

```agda
data ⊤ : Set where
  tt : ⊤
```

这里的 $\top$ 类型只有一个成员 `tt`，表示命题恒为真。

#### 概念：引入与消去

引入和消去是真命题的两个核心操作：

- **引入**操作用于构造真命题的证明，通过构造子 `tt` 实现。
- **消去**操作并不存在，因为从真命题中我们无法得出任何新的信息。

#### 概念：η-等式

**η-等式**表明，任何单元类型的值都等于 `tt`，因为 $\top$ 类型只有一个成员 `tt`。

##### 形式化定义

```agda
η-⊤ : ∀ (w : ⊤) → tt ≡ w
η-⊤ tt = refl
```

这里，通过模式匹配，我们可以证明任意单元类型的值都等于 `tt`。

#### 概念：单元类型的性质

在类型系统中，单元类型 $\top$ 对应于积的幺元。换句话说，单元类型与任意类型 $A$ 组合，结果仍为 $A$：

- **左幺元**：$\top \times A$ 与 $A$ 同构。
- **右幺元**：$A \times \top$ 与 $A$ 同构。

##### 形式化定义

```agda
⊤-identityˡ : ∀ {A : Set} → ⊤ × A ≃ A
⊤-identityˡ = 
  record
    { to = λ{ ⟨ tt , x ⟩ → x }
    ; from = λ x → ⟨ tt , x ⟩
    ; from∘to = λ{ ⟨ tt , x ⟩ → refl }
    ; to∘from = λ x → refl
    }

⊤-identityʳ : ∀ {A : Set} → (A × ⊤) ≃ A
⊤-identityʳ {A} = 
  ≃-begin
    (A × ⊤)
  ≃⟨ ×-comm ⟩
    (⊤ × A)
  ≃⟨ ⊤-identityˡ ⟩
    A
  ≃-∎
```

这些性质反映了单元类型在逻辑中的重要性和普遍性。

---

### 假即是空类型

#### 概念：假

**假**（False）是指一个命题永远不成立。在逻辑中，假命题通常表示为 $\bot$。在类型系统中，假命题对应的结构是空类型（Empty Type）。我们用空类型表示 $\bot$，其成立意味着假命题永远不成立。

##### 形式化定义

假命题在类型系统中的形式化定义如下：

```agda
data ⊥ : Set where
  -- 没有构造子
```

这里的 $\bot$ 类型没有成员，表示假命题没有任何可能的证明。

#### 概念：消去

**消去**规则表明，从假命题的成立中我们可以得出任何结论。这是逻辑中的基本原理之一，称为“从假中得真”（ex falso quodlibet）。

##### 形式化定义

消去规则可以通过以下方式定义：

```agda
⊥-elim : ∀ {A : Set} → ⊥ → A
⊥-elim ()
```

这里的 `⊥-elim` 函数表明，给定一个假命题的证明，我们可以得出任何类型 $A$ 成立的结论。

#### 概念：空类型的性质

在类型系统中，空类型 $\bot$ 对应于和的幺元。换句话说，空类型与任意类型 $A$ 组合，结果仍为 $A$：

- **左幺元**：$\bot \sqcup A

$ 与 $A$ 同构。
- **右幺元**：$A \sqcup \bot$ 与 $A$ 同构。

你可以通过练习来验证这些性质：

- **⊥-identityˡ**：证明空类型在同构意义下是和的左幺元。
- **⊥-identityʳ**：证明空类型在同构意义下是和的右幺元。

---

### 蕴涵即是函数

#### 概念：蕴涵

**蕴涵**是指命题 $A$ 和 $B$ 之间的逻辑关系，即 $A$ 成立则 $B$ 必然成立。在逻辑中，蕴涵通常表示为 $A \rightarrow B$。在类型系统中，蕴涵对应的结构是函数类型（Function Type）。我们用函数类型表示 $A \rightarrow B$，其成立意味着可以通过一个函数将 $A$ 的证明转换为 $B$ 的证明。

##### 形式化定义

蕴涵在类型系统中的形式化定义如下：

```agda
→-elim : ∀ {A B : Set} → (A → B) → A → B
→-elim L M = L M
```

这里，$A \rightarrow B$ 表示一个从 $A$ 到 $B$ 的函数，其对应于 $A \rightarrow B$ 的证明。

#### 概念：引入与消去

引入和消去是蕴涵的两个核心操作：

- **引入**操作用于定义一个从 $A$ 到 $B$ 的函数，通过 Lambda 抽象实现。
- **消去**操作用于应用这个函数，从 $A$ 的证明得出 $B$ 的证明。

#### 概念：η-等式

**η-等式**表明，如果我们先使用一个函数从 $A$ 得到 $B$，再使用这个结果重新构造一个函数，得到的将是原来的函数。

##### 形式化定义

```agda
η-→ : ∀ {A B : Set} (f : A → B) → (λ (x : A) → f x) ≡ f
η-→ f = refl
```

通过模式匹配，我们可以证明这个函数的重新构造不会改变其原始定义。

#### 概念：函数空间的性质

在类型系统中，函数空间 $A \rightarrow B$ 表示从 $A$ 到 $B$ 的映射。其性质如下：

- **柯里化（Currying）**：$A \rightarrow (B \rightarrow C)$ 与 $(A \times B) \rightarrow C$ 之间存在同构。
- **分配律**：函数与和、积运算之间满足类似分配律的关系。

##### 形式化定义

这些性质在类型系统中通过同构来表示：

```agda
currying : ∀ {A B C : Set} → (A → B → C) ≃ (A × B → C)
currying =
  record
    { to = λ{ f → λ{ ⟨ x , y ⟩ → f x y }}
    ; from = λ{ g → λ{ x → λ{ y → g ⟨ x , y ⟩ }}}
    ; from∘to = λ{ f → refl }
    ; to∘from = λ{ g → extensionality λ{ ⟨ x , y ⟩ → refl }}
    }
```

这些同构表明了函数空间在类型系统中的核心作用，并揭示了其在逻辑推理中的应用。

---

这个部分介绍了析取、真、假和蕴涵的定义、性质和相应的形式化表示。每个概念在逻辑和类型系统中都有重要的意义，如果你想继续深入了解这些概念或有其他问题，请告诉我，我会继续解释。

### 分配律

#### 概念：分配律

分配律是数学和逻辑中的一个重要性质，它描述了两个运算符之间的关系。在类型系统中，我们可以定义分配律并验证其在类型之间的同构性。具体来说，分配律有两种形式：

1. **积对和的分配律**：$(A \times B) \sqcup (A \times C) \equiv A \times (B \sqcup C)$。
2. **和对积的分配律**：$(A \sqcup B) \times C \equiv (A \times C) \sqcup (B \times C)$。

这些定律表示了不同类型之间的等价关系，通过这些关系，我们可以在类型系统中实现灵活的构造与转换。

##### 形式化定义：积对和的分配律

积对和的分配律在类型系统中的形式化表示如下：

```agda
×-distrib-⊎ : ∀ {A B C : Set} → (A × (B ⊎ C)) ≃ ((A × B) ⊎ (A × C))
×-distrib-⊎ =
  record
    { to      = λ{ ⟨ x , inj₁ y ⟩ → inj₁ ⟨ x , y ⟩
                 ; ⟨ x , inj₂ z ⟩ → inj₂ ⟨ x , z ⟩
                 }
    ; from    = λ{ inj₁ ⟨ x , y ⟩ → ⟨ x , inj₁ y ⟩
                 ; inj₂ ⟨ x , z ⟩ → ⟨ x , inj₂ z ⟩
                 }
    ; from∘to = λ{ ⟨ x , inj₁ y ⟩ → refl
                 ; ⟨ x , inj₂ z ⟩ → refl
                 }
    ; to∘from = λ{ inj₁ ⟨ x , y ⟩ → refl
                 ; inj₂ ⟨ x , z ⟩ → refl
                 }
    }
```

在这里，`×-distrib-⊎` 定义了积对和的分配律的同构性：通过 `to` 函数，我们将 $A \times (B \sqcup C)$ 转换为 $(A \times B) \sqcup (A \times C)$；通过 `from` 函数，我们可以逆向操作。

##### 形式化定义：和对积的分配律

和对积的分配律在类型系统中的形式化表示如下：

```agda
⊎-distrib-× : ∀ {A B C : Set} → (A ⊎ B) × C ≃ (A × C) ⊎ (B × C)
⊎-distrib-× =
  record
    { to      = λ{ inj₁ x × z → inj₁ (x × z)
                 ; inj₂ y × z → inj₂ (y × z)
                 }
    ; from    = λ{ inj₁ (x × z) → inj₁ x × z
                 ; inj₂ (y × z) → inj₂ y × z
                 }
    ; from∘to = λ{ inj₁ (x × z) → refl
                 ; inj₂ (y × z) → refl
                 }
    ; to∘from = λ{ inj₁ (x × z) → refl
                 ; inj₂ (y × z) → refl
                 }
    }
```

在这个定义中，`⊎-distrib-×` 证明了 $(A \sqcup B) \times C$ 与 $(A \times C) \sqcup (B \times C)$ 之间的同构关系。和积的分配律在类型系统中也可以通过同构证明来实现。

#### 练习：⊎-weak-×

为了更深入理解这些分配律的性质，你可以尝试解决以下练习：

- **练习 ⊎-weak-×**：证明如下性质成立：

```agda
postulate
  ⊎-weak-× : ∀ {A B C : Set} → (A ⊎ B) × C → A ⊎ (B × C)
```

这被称为弱分配律（Weak Distributive Law）。尝试给出这个定理的证明，并解释它与之前定义的分配律的关系。

#### 练习：⊎×-implies-×⊎

另外一个有趣的练习是证明合取的析取蕴涵了析取的合取：

```agda
postulate
  ⊎×-implies-×⊎ : ∀ {A B C D : Set} → (A × B) ⊎ (C × D) → (A ⊎ C) × (B ⊎ D)
```

反命题是否成立？如果成立，给出证明；如果不成立，尝试找到一个反例。

### 标准库中的定义

Agda 的标准库中包含了与本章节内容相似的定义。使用这些标准库中的定义可以简化证明过程，并且增强代码的可读性和可维护性。以下是标准库中相应定义的导入方法：

```agda
import Data.Product using (_×_; proj₁; proj₂) renaming (_,_ to ⟨_,_⟩)
import Data.Unit using (⊤; tt)
import Data.Sum using (_⊎_; inj₁; inj₂) renaming ([_,_] to case-⊎)
import Data.Empty using (⊥; ⊥-elim)
import Function.Equivalence using (_⇔_)
```

这些库提供了更为通用和优化的类型定义，与之前介绍的自定义定义有所不同。例如，标准库使用 `_,_` 构造数据对，而不是自定义的 `⟨_,_⟩`。在不同的上下文中，选择合适的库和符号是至关重要的。

---

这一节的内容深入探讨了分配律及其在类型系统中的形式化表示，此外还引入了 Agda 标准库中的一些相关定义。如果你对这些概念或代码有任何疑问，请随时告诉我，我会继续为你解释。
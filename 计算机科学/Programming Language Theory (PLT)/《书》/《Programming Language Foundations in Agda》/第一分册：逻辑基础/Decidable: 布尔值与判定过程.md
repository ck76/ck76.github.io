[toc]

以下是本章节涉及的所有数理逻辑相关概念及其解释：

### 1. **证据与计算（Evidence vs Compute）**
   - 证据（Evidence）：表示一个关系成立的证明，通常使用归纳数据类型来定义。例如，$m \leq n$ 的证明可以用归纳数据类型 $m ≤ n$ 来构造。
   - 计算（Compute）：使用布尔函数来计算两个数之间的关系是否成立，例如 $m \leqᵇ n$ 返回一个布尔值 $true$ 或 $false$，表示 $m$ 是否小于或等于 $n$。

### 2. **布尔类型（Boolean Type, Bool）**
   - 布尔类型只有两个值：$true$ 和 $false$。在逻辑和计算中，布尔类型用于表示命题的真值。

### 3. **类型转换函数 $T$**
   - 函数 $T$ 将布尔值映射到类型世界。$T \ true$ 映射为 $\top$（单元类型），而 $T \ false$ 映射为 $\bot$（空类型）。$T$ 函数用于将布尔值与逻辑命题的证明联系起来。

### 4. **可判定类型（Decidable Type, Dec）**
   - $Dec \ A$ 类型表示命题 $A$ 的可判定性。一个 $Dec \ A$ 类型的值要么是 $yes \ x$，其中 $x$ 是 $A$ 成立的证明；要么是 $no \ ¬x$，其中 $¬x$ 是 $A$ 的否定。

### 5. **可判定性函数（Decidable Functions）**
   - 用于判定某个命题是否成立的函数。例如，函数 $m ≤? n$ 返回一个 $Dec \ (m ≤ n)$ 类型的值，表示 $m$ 是否小于等于 $n$ 的可判定性。

### 6. **合取（Conjunction, ×-dec）**
   - 对于两个可判定的命题 $A$ 和 $B$，其合取 $A × B$ 的可判定性由 $×-dec$ 函数来判定。$×-dec$ 函数返回一个 $Dec \ (A × B)$ 类型的值，当 $A$ 和 $B$ 都成立时，它返回 $yes \ ⟨x, y⟩$，否则返回 $no$。

### 7. **析取（Disjunction, ⊎-dec）**
   - 对于两个可判定的命题 $A$ 和 $B$，其析取 $A ⊎ B$ 的可判定性由 $⊎-dec$ 函数来判定。$⊎-dec$ 函数返回一个 $Dec \ (A ⊎ B)$ 类型的值，当 $A$ 或 $B$ 成立时，它返回 $yes$，否则返回 $no$。

### 8. **否定（Negation, ¬?）**
   - 否定运算符 $¬?$ 作用于一个可判定的命题 $A$，返回 $¬A$ 的可判定性。它将 $yes \ x$ 转换为 $no \ ¬¬x$，将 $no \ ¬x$ 转换为 $yes \ ¬x$。

### 9. **蕴涵（Implication, →-dec）**
   - 蕴涵 $A → B$ 的可判定性表示当 $A$ 成立时，$B$ 也成立。$→-dec$ 函数判定两个命题 $A$ 和 $B$ 的蕴涵关系。

### 10. **擦除（Erasure, ⌊_⌋）**
   - 函数 $⌊\_⌋$ 将 $Dec \ A$ 类型的值擦除为一个布尔值 $Bool$。$yes \ x$ 被映射为 $true$，$no \ ¬x$ 被映射为 $false$。

### 11. **布尔运算符与可判定值的关系**
   - $∧-×$、$∨-⊎$ 和 $not-¬$：这些关系将布尔运算符（合取、析取、否定）与可判定值之间的操作联系起来，并证明它们的擦除操作是等价的。

### 12. **互映证明（Proof by Reflection）**
   - 互映证明是一种技术，使用计算结果（如 $n ≤? m$ 的结果）来简化类型检查，自动为命题提供证明。通过隐式参数将计算结果转换为类型证明，Agda 可以在类型检查阶段自动完成推理。

### 13. **True 和 False 类型**
   - $True$ 是单元类型 $\top$ 的同义词，$False$ 是空类型 $\bot$ 的同义词。它们用于表示命题的真与假，通常用于类型系统中。

这些概念结合了逻辑、计算和类型理论，通过使用可判定性，我们可以在类型系统中精确地表示和推理关于命题成立与否的逻辑关系。这种方法在构造证明、验证算法正确性时非常有效。

### ----------------------------------

### 证据与计算的关系

在本章中，我们探讨了两种表示关系的方式：一种是通过构建关系成立的证明（即证据），另一种是通过计算该关系是否成立的函数。我们首先使用布尔值来表示关系，但发现可判定性（Decidability）记法更为灵活和有用。

#### 证据的表示

我们在前面的章节中，定义了自然数之间小于或等于关系的证据。这个证据可以通过递归的数据类型来表示：
```agda
data _≤_ : ℕ → ℕ → Set where
  z≤n : ∀ {n : ℕ} → zero ≤ n
  s≤s : ∀ {m n : ℕ} → m ≤ n → suc m ≤ suc n
```
这段代码定义了两种形式的证据：
- $z≤n$：表示 $zero \leq n$，即零总是小于等于任何自然数。
- $s≤s$：表示如果 $m \leq n$ 成立，那么 $suc\ m \leq suc\ n$ 也成立。

通过这些规则，我们可以构建如 $2 ≤ 4$ 的证据：
```agda
2≤4 : 2 ≤ 4
2≤4 = s≤s (s≤s z≤n)
```
并且证明如 $4 ≤ 2$ 不成立：
```agda
¬4≤2 : ¬ (4 ≤ 2)
¬4≤2 (s≤s (s≤s ()))
```

#### 计算的表示

与证据的表示相比，我们也可以用计算的方式来判断关系是否成立。我们定义了一个布尔函数来判断两个自然数之间的比较关系：
```agda
_≤ᵇ_ : ℕ → ℕ → Bool
zero ≤ᵇ n       =  true
suc m ≤ᵇ zero   =  false
suc m ≤ᵇ suc n  =  m ≤ᵇ n
```
这里，我们定义了布尔值函数来表示小于等于的关系。函数会返回 $true$ 或 $false$ 来表示关系是否成立。

例如，可以计算 $2 ≤ᵇ 4$ 和 $4 ≤ᵇ 2$：
```agda
_ : (2 ≤ᵇ 4) ≡ true
_ : (4 ≤ᵇ 2) ≡ false
```

#### 证据与计算的对应关系

我们希望能够将这两种表示联系起来。为此，我们定义了一个函数 $T$，它将布尔值映射到证据的世界中：
```agda
T : Bool → Set
T true   =  ⊤
T false  =  ⊥
```
这里，$⊤$ 是表示真理的单元类型，而 $⊥$ 是表示矛盾的空类型。

我们进一步定义了 $T$ 和布尔值之间的等价性证明：
```agda
T→≡ : ∀ (b : Bool) → T b → b ≡ true
T→≡ true tt   =  refl
T→≡ false ()
```
以及反向证明：
```agda
≡→T : ∀ {b : Bool} → b ≡ true → T b
≡→T refl  =  tt
```

#### 从计算到证据的转换

我们还定义了从计算形式（布尔值）到证据形式的转换函数：
```agda
≤ᵇ→≤ : ∀ (m n : ℕ) → T (m ≤ᵇ n) → m ≤ n
≤ᵇ→≤ zero    n       tt  =  z≤n
≤ᵇ→≤ (suc m) zero    ()
≤ᵇ→≤ (suc m) (suc n) t   =  s≤s (≤ᵇ→≤ m n t)
```
这里，我们通过递归的方式，将布尔值的判断转换为对应的证据。

#### 可判定性（Decidability）

相比于直接使用布尔值表示关系，我们发现使用可判定性的类型更加优雅和强大。我们定义了一个可判定性的类型 $Dec$，它可以同时包含证据和计算的结果：
```agda
data Dec (A : Set) : Set where
  yes : A → Dec A
  no  : ¬ A → Dec A
```
这个类型可以表示一个命题 $A$ 的成立或不成立的证据。我们接着定义了一个函数来判定两个自然数之间的关系：
```agda
_≤?_ : ∀ (m n : ℕ) → Dec (m ≤ n)
zero  ≤? n                   =  yes z≤n
suc m ≤? zero                =  no ¬s≤z
suc m ≤? suc n with m ≤? n
...               | yes m≤n  =  yes (s≤s m≤n)
...               | no ¬m≤n  =  no (¬s≤s ¬m≤n)
```
这个函数直接返回一个包含证据的可判定性结果，使得我们能够更加方便地进行逻辑推理和计算。

### 总结

在这一章中，我们探讨了如何将布尔值的计算和逻辑证明相结合。通过定义可判定性的数据类型，我们能够在同一框架下处理计算和证明，从而使得程序更为灵活和强大。

如果需要进一步探讨如何使用这些概念进行逻辑推理或编写证明，请告诉我。

### ---------------------------

### 导入部分 (Imports)

本章节开始于一些必要的模块导入，这些模块为后续的逻辑推导提供了基础工具。导入的模块包括等式模块 `Relation.Binary.PropositionalEquality`，自然数模块 `Data.Nat`，以及空类型和单位类型模块 `Data.Empty` 和 `Data.Unit`。这些模块的导入使得我们可以使用基本的自然数运算、判定逻辑操作以及处理等式推导。

### 证据 vs 计算

这一小节讨论了两种不同的关系表示方式：一种是通过构建关系成立的证明（即证据），另一种是通过计算关系是否成立的函数。具体来说，这一节讨论了自然数之间的“小于等于”关系，并分别以证据形式和布尔值形式进行表示。

#### 证据的表示

首先，我们定义了自然数之间“小于或等于”的关系，并将其表示为一个归纳数据类型：
```agda
data _≤_ : ℕ → ℕ → Set where
  z≤n : ∀ {n : ℕ} → zero ≤ n
  s≤s : ∀ {m n : ℕ} → m ≤ n → suc m ≤ suc n
```
- 这里的 $z≤n$ 构造子表示 $zero \leq n$，即零总是小于或等于任何自然数 $n$。
- 而 $s≤s$ 构造子则表示，如果 $m \leq n$，那么 $suc\ m \leq suc\ n$ 也成立。

这种表示法提供了一个结构化的证据链，每个证据都可以解释为什么某个自然数小于或等于另一个自然数。例如，2 ≤ 4 的证据如下：
```agda
2≤4 : 2 ≤ 4
2≤4 = s≤s (s≤s z≤n)
```
这个定义使用了两次 $s≤s$ 和一次 $z≤n$ 来构造一个完整的证据链。

#### 计算的表示

与证据表示不同，我们可以使用布尔函数来表示“计算”出自然数之间的关系。这个布尔函数的定义如下：
```agda
_≤ᵇ_ : ℕ → ℕ → Bool
zero ≤ᵇ n       =  true
suc m ≤ᵇ zero   =  false
suc m ≤ᵇ suc n  =  m ≤ᵇ n
```
- $zero ≤ᵇ n$ 返回 $true$，表示零总是小于或等于任何自然数。
- $suc\ m ≤ᵇ zero$ 返回 $false$，表示任何大于零的自然数都不可能小于或等于零。
- $suc\ m ≤ᵇ suc\ n$ 返回 $m ≤ᵇ n$ 的计算结果，通过递归的方式继续比较前缀。

通过这个布尔函数，我们可以直接计算两个自然数之间的关系是否成立，而不需要通过构造证据。例如：
```agda
_ : (2 ≤ᵇ 4) ≡ true
_ : (4 ≤ᵇ 2) ≡ false
```
这两个例子分别计算了 $2 \leq 4$ 和 $4 \leq 2$ 的布尔结果，前者为 $true$，后者为 $false$。

### 证据与计算的对应关系

在这一部分中，我们探索了如何将布尔值与证据链相互映射。为此，我们定义了一个类型转换函数 $T$，将布尔值转换为相应的证据类型：
```agda
T : Bool → Set
T true   =  ⊤
T false  =  ⊥
```
- $T\ true$ 对应的是单位类型 $⊤$，表示该布尔值为 $true$ 时的证据。
- $T\ false$ 对应的是空类型 $⊥$，表示该布尔值为 $false$ 时无证据可提供。

接着，我们定义了两个互逆的函数，分别将布尔值转换为证据，并从证据推导出布尔值：
```agda
T→≡ : ∀ (b : Bool) → T b → b ≡ true
T→≡ true tt   =  refl
T→≡ false ()

≡→T : ∀ {b : Bool} → b ≡ true → T b
≡→T refl  =  tt
```
- $T→≡$ 函数说明了如果我们有 $T\ b$ 的证据，则 $b$ 必定为 $true$。
- $≡→T$ 函数则说明如果我们有 $b ≡ true$ 的证明，则 $T\ b$ 的证据也存在。

通过这两个函数，我们可以在证据和计算之间建立明确的对应关系。

### 从计算到证据的转换

这一部分进一步扩展了计算与证据之间的关系，定义了从布尔值计算形式到证据形式的转换函数：
```agda
≤ᵇ→≤ : ∀ (m n : ℕ) → T (m ≤ᵇ n) → m ≤ n
≤ᵇ→≤ zero    n       tt  =  z≤n
≤ᵇ→≤ (suc m) zero    ()
≤ᵇ→≤ (suc m) (suc n) t   =  s≤s (≤ᵇ→≤ m n t)
```
- 这个函数递归地将布尔值转换为证据链，通过匹配每种可能的情况来构建证据。

#### 可判定性（Decidability）

这一部分引入了可判定性（Decidability）的概念，通过定义一个新的数据类型 $Dec$，将布尔值和证据合并在一起。$Dec$ 类型包含两个构造子：
```agda
data Dec (A : Set) : Set where
  yes : A → Dec A
  no  : ¬ A → Dec A
```
- $yes\ x$ 表示 $A$ 成立并提供其证明 $x$。
- $no\ ¬x$ 表示 $A$ 不成立，并提供一个证据 $¬x$，即 $A$ 成立时可以推导出矛盾。

通过 $Dec$ 类型，我们可以在同一个框架内处理布尔值计算和逻辑证明。接着，我们定义了一个函数来判定两个自然数之间的关系：
```agda
_≤?_ : ∀ (m n : ℕ) → Dec (m ≤ n)
zero  ≤? n                   =  yes z≤n
suc m ≤? zero                =  no ¬s≤z
suc m ≤? suc n with m ≤? n
...               | yes m≤n  =  yes (s≤s m≤n)
...               | no ¬m≤n  =  no (¬s≤s ¬m≤n)
```
- 该函数在不同情况下返回 $Dec\ (m ≤ n)$ 类型的结果，通过递归的方式处理复杂情况。

### 小结

本章中，我们从基本的自然数比较关系入手，逐步引入了证据链和布尔值的表示方法，最终扩展到可判定性的框架。通过可判定性类型，我们能够统一处理布尔值和逻辑证明，既能享受计算的高效性，又能保持逻辑证明的严谨性。

如果需要进一步细化或详细讲解特定部分，请告诉我！

- https://agda-zh.github.io/PLFA-zh/

[toc]

## 第一分册：逻辑基础

### 1. **Naturals: 自然数**

自然数就是我们从小学习的数字：0、1、2、3……它们是最基本的数字，用于计数和基本的数学运算。在计算机科学中，自然数也常被用作计数器、索引和其他基本操作的基础。

### 2. **Induction: 归纳证明**
归纳证明是一种数学证明方法，尤其适用于证明自然数相关的命题。它的核心思想是：如果某个命题对于自然数0成立，并且对于任意一个自然数 n ，如果该命题对 n 成立，那么对 n+1 也成立，那么我们就可以断定这个命题对于所有自然数都成立。

### 3. **Relations: 关系的归纳定义**
关系是指两个或多个对象之间的一种特定关联或连接。比如，大于、小于、等于就是自然数之间的关系。归纳定义是一种定义方法，通过基本情况和递归情况定义复杂结构。在逻辑中，我们可以通过归纳定义来描述和证明各种关系的性质。

### 4. **Equality: 相等性与等式推理**
相等性（Equality）是指两个对象在某种意义上是相同的。在数学和逻辑中，等式推理就是通过已知的等式（如 a = b）来推导出新的等式（如 b = c，则 a = c）。这种推理方式在证明中非常常见和重要。

### 5. **Isomorphism: 同构与嵌入**
同构（Isomorphism）指的是两个结构在某种意义上是完全相同的，尽管它们可能在外表上不同。例如，两个不同的集合，如果它们的元素可以一一对应，并且这种对应关系保持了所有结构（比如运算、关系等），那么这两个集合就是同构的。嵌入（Embedding）则是将一个结构嵌入到另一个结构中，使得原有的结构在新结构中得到保留。

### 6. **Connectives: 合取、析取与蕴涵**
合取、析取和蕴涵是逻辑运算的基本连接词：
- **合取（∧，AND）**：两个命题同时为真时，整个表达式才为真。
- **析取（∨，OR）**：只要有一个命题为真，整个表达式就为真。
- **蕴涵（→，IMPLIES）**：如果前一个命题为真，那么后一个命题也必须为真；否则整个表达式为假。

### 7. **Negation: 直觉逻辑与命题逻辑中的否定**
否定（Negation）就是将一个命题的真值取反。直觉逻辑与命题逻辑中的否定处理方式略有不同：
- **命题逻辑**：否定运算非常简单，直接取反。例如，“A 为真”在逻辑中表示为“非 A 为假”。
- **直觉逻辑**：更为严格，它要求我们必须有理由去否定一个命题，即需要证明其假才能断言“非 A 为真”。

### 8. **Quantifiers: 全称量词与存在量词**
量词是逻辑中的符号，用来表达命题在对象集上的范围：
- **全称量词（∀，For All）**：表示“对所有对象都成立”。例如，“对于所有 x，x 都大于 0”。
- **存在量词（∃，There Exists）**：表示“存在某个对象使得命题成立”。例如，“存在一个 x，x 大于 0”。

### 9. **Decidable: 布尔值与判定过程**
判定过程是指能够确定某个命题是真还是假的过程。布尔值（Boolean Values）是计算机中的一种数据类型，只有两个值：真（True）或假（False）。如果一个问题是可判定的，那么我们可以设计一个算法，输入任意数据，经过有限步计算后能够给出该问题的布尔值答案。

### 10. **Lists: 列表与高阶函数**
列表是一种基本的数据结构，用于存储有序的元素集合。例如，`[1, 2, 3, 4]` 就是一个包含四个元素的列表。高阶函数（Higher-order Functions）是指可以接受其他函数作为参数或将函数作为结果返回的函数。列表和高阶函数在函数式编程中非常常用，能够方便地处理复杂的数据操作。





## 第二分册：编程语言基础

### 1. **Lambda: λ-演算简介**
λ-演算（Lambda Calculus）是数学和计算机科学中的一种形式系统，用来定义函数和进行函数计算。它是许多编程语言（特别是函数式编程语言）的理论基础。在 λ-演算中，函数的定义、应用和变量的绑定是通过一种非常简洁的符号系统来表示的。可以说，λ-演算是描述和研究计算过程的一种纯粹的数学方法。

### 2. **Properties: 可进性与保型性**
可进性和保型性是编程语言中非常重要的两个性质：
- **可进性（Progress）**：这是指在程序执行的每一步中，要么程序已经计算出最终结果，要么程序可以继续执行。可进性确保了程序不会突然“卡住”或陷入某种不确定状态。
- **保型性（Preservation）**：保型性是指在程序的执行过程中，程序的类型保持不变。也就是说，如果一个程序在开始时具有某种类型，那么在执行过程中，这种类型将一直保持正确。这确保了程序不会在执行中途出现类型错误。

### 3. **DeBruijn: 内在类型的 de Bruijn 表示法**
de Bruijn 表示法是一种表示 λ-演算中变量的方法，旨在避免变量名冲突的问题。通常，变量是通过名字来表示的，但在 de Bruijn 表示法中，变量通过它们的“深度”或“索引”来表示。这样做的好处是，在进行变量替换（如函数应用）时，不会因为变量名的重复而产生歧义。内在类型则指的是在 λ-演算中使用这种索引来管理变量的类型。

### 4. **More: 简单类型 λ-演算的更多构造**
简单类型 λ-演算（Simply Typed Lambda Calculus）是 λ-演算的一种扩展，它在 λ-演算的基础上引入了类型的概念，确保程序的某些形式上的正确性。这一部分讨论了在简单类型 λ-演算中的更多构造，可能包括更复杂的类型、类型多态性、类型运算等。

### 5. **Bisimulation: 联系不同的归约系统**
归约系统是指如何一步一步地将复杂表达式简化为更简单的形式。不同的归约系统可能有不同的规则。**互模拟（Bisimulation）** 是一种方法，用来证明两个归约系统之间的等价性。换句话说，互模拟帮助我们理解和证明在不同规则下执行的计算是否产生相同的结果。

### 6. **Inference: 双向类型推理**
双向类型推理是一种确定程序中表达式类型的方法。这种方法同时考虑从表达式到类型的推导和从类型到表达式的检查。它的主要优势在于，它可以提供更强的类型检查能力，同时减少程序员的工作量，使类型系统既灵活又强大。

### 7. **Untyped: 完全正规化的无类型 λ-演算**
无类型 λ-演算（Untyped Lambda Calculus）是 λ-演算的最基本形式，它没有类型的概念，所有的表达式都是 λ-表达式。在无类型 λ-演算中，**完全正规化** 是指任何 λ-表达式都可以通过一系列归约步骤简化为最简单的形式（正常形式），如果这个正常形式存在的话。无类型 λ-演算展示了计算的基本机制，但由于缺少类型，可能会导致一些问题（例如，程序的安全性无法保证）。

### 8. **Confluence: 无类型 λ-演算的合流性**
合流性（Confluence）是 λ-演算中的一个重要性质。它意味着，无论你选择什么顺序来执行 λ-演算的归约操作，只要能够最终归约到一个正常形式，那么不同的归约路径最终都会收敛到同一个结果。这一性质保证了程序的确定性和一致性。

### 9. **BigStep: 无类型 λ-演算的大步语义**
大步语义（Big-step Semantics）是 λ-演算的一种解释方式，与之相对的是小步语义（Small-step Semantics）。在大步语义中，我们直接将表达式解释为最终结果，而不关注中间的每一步操作。这种方式更适合描述高层次的程序行为，而不需要过多关注执行的每个细节步骤。

这些主题是编程语言理论的核心，它们帮助我们理解如何构造、分析和解释程序语言。这些概念在设计安全、可靠和高效的编程语言时尤其重要。通过理解这些基础，你将能够更深入地理解编程语言的设计原则以及它们背后的理论依据。



## 第三分册：指称语义

第三分册的内容涉及 **指称语义**（Denotational Semantics），这是编程语言理论中的一个重要概念，用于为编程语言的构造提供数学意义。这一分册探讨了无类型 λ-演算的指称语义及其相关性质。下面是对这些主题的通俗解释。

### 1. **Denotational: 无类型 λ-演算的指称语义**
**指称语义**（Denotational Semantics）是编程语言的一种数学表示方法，用于将程序映射到某种数学对象（如函数、集合等）上。对于无类型 λ-演算，指称语义提供了一种方式，将 λ-表达式映射到数学函数上。这种语义描述了 λ-表达式的行为，而不关心具体的计算过程。

通俗地说，指称语义就像是为程序中的每个表达式分配一个“意义”或“值”，这个意义是独立于具体的计算步骤的。通过指称语义，我们可以从一个更抽象的角度理解程序的行为。

### 2. **Compositional: 指称语义的可组合性**
**可组合性**（Compositionality）是指称语义的一个重要性质。它意味着复杂表达式的意义可以通过其子表达式的意义来确定。换句话说，程序的整体行为是其各个部分行为的组合。对于编程语言的设计者来说，这种可组合性非常重要，因为它确保了我们可以通过分析程序的组成部分来理解整个程序的行为。

在指称语义中，可组合性允许我们递归地定义程序的语义。例如，如果你知道两个子表达式的意义，那么你就可以确定它们组合而成的表达式的意义。

### 3. **Soundness: 指称语义归约的可靠性**
**可靠性**（Soundness）是指称语义的一个重要特性，它确保了指称语义和实际计算过程（如归约系统）之间的一致性。具体来说，如果一个程序在指称语义中具有某种性质（如类型安全性），那么在实际运行时也应当具有这种性质。

这意味着指称语义为程序行为提供的数学模型是可靠的，可以信赖的。它保证了当你从数学角度分析程序时，得出的结论在实际计算中也是成立的。

### 4. **Adequacy: 指称语义相对于操作语义的充分性**
**充分性**（Adequacy）是指称语义的另一个重要性质。它确保指称语义模型足够准确地反映程序的实际计算行为（通常由操作语义描述）。具体来说，充分性保证了，如果两个程序在指称语义中是相等的，那么它们在实际计算中表现出相同的行为。

简单来说，充分性是指称语义和操作语义之间的一种正确匹配，它确保了数学模型不会遗漏或扭曲程序的行为。

### 5. **ContextualEquivalence: 指称相等蕴含语境等价**
**语境等价**（Contextual Equivalence）是指当两个程序在任何语境下都表现出相同的行为时，它们是语境等价的。在指称语义中，如果两个程序具有相同的指称（即它们映射到相同的数学对象上），那么我们可以推断它们在所有语境下都是等价的。

这意味着指称相等是语境等价的充分条件。换句话说，如果两个表达式在指称语义中是相等的，那么无论把它们放在什么程序上下文中，它们都将产生相同的效果。

指称语义为我们提供了一种将程序语言与数学模型联系起来的方法，使我们能够在更抽象的层次上理解和分析程序的行为。通过探讨指称语义的可组合性、可靠性、充分性以及与语境等价性的关系，这一分册帮助我们更深入地理解编程语言的数学基础和语义学分析。这些概念对于编程语言理论、编译器设计以及程序验证都非常重要。
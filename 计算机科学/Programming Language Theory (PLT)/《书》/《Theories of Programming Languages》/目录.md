- 《Theories of Programming Languages》.



<img src="https://p.ipic.vip/gn2qhd.jpg" alt="img" style="zoom:25%;" />

**第1章 谓词逻辑** (Chapter 1: Predicate Logic)  
1.1 抽象语法 (Abstract Syntax)  
1.2 谓词逻辑的指称语义 (Denotational Semantics of Predicate Logic)  
1.3 有效性与推理 (Validity and Inference)  
1.4 绑定与代换 (Binding and Substitution)  

**第2章 简单命令式语言** (Chapter 2: The Simple Imperative Language)  
2.1 语法 (Syntax)  
2.2 简单命令式语言的指称语义 (Denotational Semantics)  
2.3 域与连续函数 (Domains and Continuous Functions)  
2.4 最小不动点定理 (The Least Fixed-Point Theorem)  
2.5 变量声明与代换 (Variable Declarations and Substitution)  
2.6 语法糖：for命令 (Syntactic Sugar: The for Command)  
2.7 算术错误 (Arithmetic Errors)  
2.8 完备性与完全抽象 (Soundness and Full Abstraction)  

**第3章 程序规范及其证明** (Chapter 3: Program Specifications and Their Proofs)  
3.1 规范的语法与语义 (Syntax and Semantics of Specifications)  
3.2 推理规则 (Inference Rules)  
3.3 赋值和顺序组合的规则 (Rules for Assignment and Sequential Composition)  
3.4 while命令的规则 (Rules for while Commands)  
3.5 进一步的规则 (Further Rules)  
3.6 计算斐波那契数列 (Computing Fibonacci Numbers)  
3.7 快速幂 (Fast Exponentiation)  
3.8 复杂性与局限性 (Complications and Limitations)  

**第4章 数组** (Chapter 4: Arrays)  
4.1 抽象语法 (Abstract Syntax)  
4.2 数组的指称语义 (Denotational Semantics)  
4.3 二分搜索 (Binary Search)  
4.4 数组的推理规则 (Inference Rules for Arrays)  
4.5 关于数组的高阶断言 (Higher-Order Assertions About Arrays)  

**第5章 失败、输入输出与续延** (Chapter 5: Failure, Input-Output, and Continuations)  
5.1 fail命令 (The fail Command)  
5.2 中间输出与序列域 (Intermediate Output and a Domain of Sequences)  
5.3 连续性的物理论据 (The Physical Argument for Continuity)  
5.4 域的积与不相交并 (Products and Disjoint Unions of Predomains)  
5.5 递归域同构 (Recursive Domain Isomorphisms)  
5.6 中间输入与续延域 (Intermediate Input and a Domain of Resumptions)  
5.7 续延语义 (Continuation Semantics)  
5.8 扩展的续延语义 (Continuation Semantics of Extensions)  

**第6章 转换语义** (Chapter 6: Transition Semantics)  
6.1 配置与转换关系 (Configurations and the Transition Relation)  
6.2 简单语言的推理规则 (Inference Rules for the Simple Language)  
6.3 fail命令的转换语义 (Transition Semantics of fail)  
6.4 输入与输出 (Input and Output)  

**第7章 不确定性与守护命令** (Chapter 7: Nondeterminism and Guarded Commands)  
7.1 语法与转换语义 (Syntax and Transition Semantics)  
7.2 有界不确定性与幂域 (Bounded Nondeterminism and Powerdomains)  
7.3 语义方程 (Semantic Equations)  
7.4 程序规范与证明 (Program Specification and Proof)  
7.5 最弱前提条件 (Weakest Preconditions)  

**第8章 共享变量并发** (Chapter 8: Shared-Variable Concurrency)  
8.1 并发组合 (Concurrent Composition)  
8.2 临界区 (Critical Regions)  
8.3 互斥与条件临界区 (Mutual Exclusion and Conditional Critical Regions)  
8.4 死锁 (Deadlock)  
8.5 公平性 (Fairness)  
8.6 续延语义 (Resumption Semantics)  
8.7 转换轨迹 (Transition Traces)  
8.8 吞吐与卡壳 (Stuttering and Mumbling)  

**第9章 通信顺序进程** (Chapter 9: Communicating Sequential Processes)  
9.1 语法 (Syntax)  
9.2 转换语义 (Transition Semantics)  
9.3 可能的限制 (Possible Restrictions)  
9.4 示例 (Examples)  
9.5 死锁 (Deadlock)  
9.6 公平性 (Fairness)  

**第10章 λ演算** (Chapter 10: The Lambda Calculus)  
10.1 语法 (Syntax)  
10.2 归约 (Reduction)  
10.3 正常序求值 (Normal-Order Evaluation)  
10.4 急切求值 (Eager Evaluation)  
10.5 指称语义 (Denotational Semantics)  
10.6 λ演算中的编程 (Programming in the Lambda Calculus)  

**第11章 一个急切函数式语言** (Chapter 11: An Eager Functional Language)  
11.1 具体语法 (Concrete Syntax)  
11.2 求值语义 (Evaluation Semantics)  
11.3 定义、模式与递归 (Definitions, Patterns, and Recursion)  
11.4 列表 (Lists)  
11.5 示例 (Examples)  
11.6 直接指称语义 (Direct Denotational Semantics)  
11.7 动态绑定 (Dynamic Binding)  

**第12章 函数式语言中的续延** (Chapter 12: Continuations in a Functional Language)  
12.1 续延语义 (Continuation Semantics)  
12.2 续延作为值 (Continuations as Values)  
12.3 作为编程技术的续延 (Continuations as a Programming Technique)  
12.4 推导一阶语义 (Deriving a First-Order Semantics)  
12.5 一阶语义总结 (First-Order Semantics Summarized)  
12.6 关联一阶与续延语义 (Relating First-Order and Continuation Semantics)  

**第13章 类Iswim语言** (Chapter 13: Iswim-like Languages)  
13.1 别名、引用与状态 (Aliasing, References, and States)  
13.2 求值语义 (Evaluation Semantics)  
13.3 续延语义 (Continuation Semantics)  
13.4 一些语法糖 (Some Syntactic Sugar)  
13.5 一阶语义 (First-Order Semantics)  
13.6 示例 (Examples)  
13.7 异常 (Exceptions)  
13.8 回溯 (Backtracking)  
13.9 输入与输出 (Input and Output)  
13.10 一些复杂性 (Some Complications)  

**第14章 一个正常序语言** (Chapter 14: A Normal-Order Language)  
14.1 求值语义 (Evaluation Semantics)  
14.2 语法糖 (Syntactic Sugar)  
14.3 示例 (Examples)  
14.4 直接指称语义 (Direct Denotational Semantics)  
14.5 归约再访 (Reduction Revisited)  
14.6 惰性求值 (Lazy Evaluation)  

**第15章 简单类型系统** (Chapter 15: The Simple Type System)  
15.1 类型、上下文与判断 (Types, Contexts, and Judgements)  
15.2 推理规则 (Inference Rules)  
15.3 显式类型化 (Explicit Typing)  
15.4 类型的外在意义 (The Extrinsic Meaning of Types)  
15.5 内在观点 (The Intrinsic View)  
15.6 集合论语义 (Set-Theoretic Semantics)  
15.7 递归类型 (Recursive Types)  

**第16章 子类型与交叉类型** (Chapter 16: Subtypes and Intersection Types)  
16.1 子类型的推理规则 (Inference Rules for Subtyping)  
16.2 命名的乘积与和 (Named Products and Sums)  
16.3 交叉类型 (Intersection Types)  
16.4 外在语义 (Extrinsic Semantics)  
16.5 泛型操作符 (Generic Operators)  
16.6 内在语义 (Intrinsic Semantics)  

**第17章 多态性** (Chapter 17: Polymorphism)  
17.1 语法与推理规则 (Syntax and Inference Rules)  
17.2 多态编程 (Polymorphic Programming)  
17.3 外在语义 (Extrinsic Semantics)  

**第18章 模块规范** (Chapter 18: Module Specification)  
18.1 类型定义 (Type Definitions)

18.2 存在量化与模块 (Existential Quantification and Modules)  
18.3 通过另一个抽象来实现一个抽象 (Implementing One Abstraction in Terms of Another)  
[toc]



### **第七章 增强类型理论 (Augmenting Type Theory)**

#### **概述：**

本章探讨了在类型理论（Type Theory，简称 TT）中添加新构造的各种提议。尽管理论上 TT 系统具有高度的表达能力，但是否以自然或高效的方式表达所需内容仍存在疑问。本章将讨论系统可能的增强方式，以及这些增强对系统的影响。

在开始之前，需要强调的是，每个添加的构造虽然在某种程度上增加了系统的能力，但也使得系统更加复杂，无论是从用户的角度，还是从基础理论的角度，例如可能导致强归约性（Strong Normalization）的丧失。我们将逐节讨论每个提议的利弊，并在本书的结论中对此主题进行更多讨论。

---

#### **中心主题：**

- **子集类型 (Subset Type)：**

  - 子集类型是与存在类型 (Existential Type) 不同的类型，其成员仅是满足特定性质的基类型元素，而不是与证明该性质的证据配对的对象。

- **计算相关性 (Computational Relevance)：**

  - 一些表达式的部分似乎仅具有逻辑作用，而不影响计算过程的结果。
  - 我们将讨论捕获这一直觉的两种方法，并探讨其与惰性求值 (Lazy Evaluation) 的联系。

---

#### **7.1 背景 (Background)**

本节探讨了在 TT 中引入子集类型的背景，在讨论如何实现之前，首先审视其必要性。

---

##### **7.1.1 什么是规范？(What is a specification?)**

- **讨论：**

  - 为了将讨论置于正确的背景中，我们首先回顾在 TT 中规范 (Specification) 的确切性质。
  - 当我们在第六章讨论波兰国旗问题的案例研究时，首次审视了这一主题。
  - 在文献中，对于 TT 中规范的精确定义存在一些混淆，我们希望在此澄清这一问题。

- **规范在类型理论中的角色：**

  - 在类型理论中，规范通常以类型的形式表达。
  - 根据 Curry-Howard 同构，类型可以被视为命题，程序（即类型的居住者）可以被视为证明。
  - 因此，规范就是一个类型，满足规范的程序就是该类型的居住者。

- **示例：**

  - 在波兰国旗问题中，我们需要一个函数，将一个由红色和白色项组成的序列，重新排列为所有红色项在白色项之前。
  - 我们可以通过存在类型或全称存在类型来表达规范，但需要仔细考虑哪种方式更适合。

---

##### **7.1.2 计算相关性；惰性求值 (Computational Irrelevance; Lazy Evaluation)**

- **计算相关性：**

  - 在类型理论的表达式中，有些部分仅用于逻辑证明，对计算过程的结果没有贡献。
  - 这种“计算无关”的部分在实际计算中是可以忽略的。

- **捕获计算无关性的两种方法：**

  1. **明确标记计算无关的部分：**

     - 使用特殊的语法或类型，标记那些仅用于逻辑目的的部分。

  2. **利用惰性求值：**

     - 采用惰性求值策略，只有在需要时才计算某些表达式，从而自动避免了不必要的计算。

- **与惰性求值的联系：**

  - 采用惰性求值的实现方式，可以减少对系统复杂度的需求，因为计算无关的部分不会对性能产生负面影响。

- **讨论：**

  - 任何关于计算相关性或效率的讨论，都必须相对于某种求值策略进行。
  - 我们认为，在使用惰性求值的情况下，许多为提高计算效率而提出的复杂类型系统的理由都变得不那么重要。

---

#### **7.2 子集类型 (The Subset Type)**

##### **7.2.1 外延理论 (The Extensional Theory)**

- **引入子集类型的朴素定义：**

  - 子集类型的成员是那些满足特定性质的基类型元素。
  - 与存在类型不同，子集类型的成员不包含证明该性质的证据。

- **理论上的缺陷：**

  - 在朴素的子集类型定义中，可能会出现理论上的问题，例如违反强归约性或一致性。
  - 我们需要仔细检查这些缺陷，确保系统的可靠性。

- **示例问题：**

  - 考虑在 TT 中引入子集类型可能导致的技术问题，例如类型检查的复杂度增加，或可能破坏系统的元性质。

---

#### **7.3 命题不是类型 (Propositions not Types)**

- **讨论：**

  - 很多关于子集类型的动机，都是为了在类型理论中实现逻辑和计算方面的分离。
  - 在传统的 TT 中，命题和类型是统一的，这被称为“命题即类型”原则。

- **解决方案：**

  - 为了正确地表达子集类型，我们需要一个系统，其中命题和类型不再被视为同一事物。
  - 这意味着需要引入一个逻辑层，与类型层分离。

---

##### **7.3.1 '压缩'类型 ('Squash' Types)**

- **定义：**

  - '压缩'类型是一种特殊的类型，用于表示某个命题是否可证，而不关心其证明的具体内容。

- **作用：**

  - 通过引入 '压缩' 类型，我们可以在类型中包含逻辑信息，但在计算时忽略其内容。

---

##### **7.3.2 子集理论 (The Subset Theory)**

- **构建子集类型的系统：**

  - 引入一个新的类型构造，用于表示满足特定性质的元素的子集。
  - 在这个系统中，我们需要定义子集类型的形成规则、引入规则和消解规则。

- **注意事项：**

  - 需要确保新系统的性质，例如强归约性、一致性和可判定性。

---

##### **7.3.3 哥德尔解释 (Gödel Interpretation)**

- **内容：**

  - 讨论如何使用哥德尔的解释，将逻辑系统嵌入到类型理论中。
  - 探索逻辑和类型之间的关系，以及如何在保持系统一致性的情况下，引入新的逻辑构造。

---

#### **7.4 子集类型是必要的吗？(Are Subsets Necessary?)**

- **观点：**

  - 我们认为，文献中关于子集类型的所有示例，都可以在 TT 中顺利处理，而无需引入新的类型。

- **方法：**

  - 通过使用惰性实现（Lazy Implementation）和在规范中明智地选择类型，我们可以避免对子集类型的需求。
  - 例如，我们可以通过断言函数的存在性来指定函数，而不是使用全称存在公式。

- **示例：**

  - 提供了一些一般和具体的示例，说明如何在现有的 TT 中处理需要子集类型的情况。

---

#### **7.5 商类型或同余类型 (Quotient or Congruence Types)**

- **动机：**

  - 原始的 W 类型构造了自由数据类型，但在某些情况下，一个抽象对象最好用一组具体项来表示，例如用列表表示集合。

- **商类型的作用：**

  - 通过形成等价类，创建一个商类型，方便对类型进行推理和编程。

---

##### **7.5.1 同余类型 (Congruence Types)**

- **定义：**

  - 同余类型是将类型的元素按照某种等价关系进行划分，形成的等价类类型。

- **作用：**

  - 使我们能够在类型中表达抽象的数据结构，例如集合、商群等。

- **注意事项：**

  - 引入商类型或同余类型需要谨慎，确保不会破坏类型系统的性质。

---

#### **7.6 案例研究——实数 (Case Study – The Real Numbers)**

- **内容：**

  - 实数分析是构造性数学的一个重要应用领域。
  - 本节提供了对该主题的初步处理，也作为一个案例研究，检验子集类型和商类型的实用性。

- **讨论：**

  - 在构造实数时，需要处理等价类和无穷过程，这涉及到商类型和子集类型的应用。
  - 通过该案例，我们可以评估这些类型在实际数学建模中的作用。

---

#### **7.7 加强的规则；多态性 (Strengthened Rules; Polymorphism)**

- **背景：**

  - 在消解规则中，已经显示出各种不合适之处。
  - 本节通过强消解规则的方式，探讨了克服这些问题的提议。

- **多态类型 (Polymorphic Types)：**

  - 介绍了 Backhouse 等人的多态类型，这是对强消解规则的推广。

- **影响：**

  - 这样的添加可能导致没有正常形式（normal form）的项，甚至没有弱头部正常形式（weak head normal form），从而在增强的系统中出现真正的非终止。

- **警示：**

  - 这强调了以临时方式对系统进行“合理”扩展可能导致意想不到的情况。
  - 我们必须确保任何添加都不会破坏比其增加的内容更重要的性质。

---

##### **7.7.1 一个示例 (An Example)**

- **内容：**

  - 提供了一个具体的示例，展示了加强规则和多态性如何应用，以及可能引发的问题。

---

##### **7.7.2 强消解规则和假设规则 (Strong and Hypothetical Rules)**

- **讨论：**

  - 强消解规则允许在类型消解时，使用更多的信息。
  - 假设规则涉及在证明中引入假设，扩展了系统的推理能力。

---

##### **7.7.3 多态类型 (Polymorphic Types)**

- **定义：**

  - 多态类型允许类型参数化，即类型可以依赖于其他类型的参数。

- **作用：**

  - 增强了类型系统的表达能力，允许定义更通用的函数和数据结构。

---

##### **7.7.4 非终止 (Non-termination)**

- **问题：**

  - 在增强的系统中，可能会引入非终止的项，这违反了类型理论的强归约性。

- **讨论：**

  - 需要谨慎地设计增强的规则，避免破坏系统的基本性质。

---

#### **7.8 良基递归 (Well-founded Recursion)**

- **概念：**

  - 良基递归是最一般的终止递归形式。

- **内容：**

  - 首先在集合论的背景下讨论了良基递归的概念。

- **作用：**

  - 良基递归允许定义基于更一般的结构（而非简单的自然数或列表）的递归函数。

---

#### **7.9 类型理论中的良基递归 (Well-founded Recursion in Type Theory)**

##### **7.9.1 构造递归操作符 (Constructing Recursion Operators)**

- **目标：**

  - 将良基递归添加到类型理论中，提供一种通用的递归定义方式。

- **方法：**

  - 构造一次性的递归原则，使得在上一章的证明开发过程中推导出的具体案例（如快速排序）可以通过这种通用机制获得。

---

##### **7.9.2 可达元素 (The Accessible Elements)**

- **定义：**

  - 可达元素是那些可以通过有限步骤达到的元素，确保递归过程终止。

- **作用：**

  - 在定义良基递归时，需要识别这些可达元素，以确保递归的正确性。

---

##### **7.9.3 结论 (Conclusions)**

- **总结：**

  - 讨论了在类型理论中引入良基递归的可行性和方法，以及其对程序开发的影响。

---

#### **7.10 归纳类型 (Inductive Types)**

##### **7.10.1 归纳定义 (Inductive Definitions)**

- **概念：**

  - 归纳定义允许定义具有一般归纳原则的类型。

- **作用：**

  - 通过归纳类型，可以更自然地表示许多数学和计算概念。

---

##### **7.10.2 类型理论中的归纳定义 (Inductive Definitions in Type Theory)**

- **内容：**

  - 讨论了如何在类型理论中引入归纳类型，以及它们与 W 类型的关系。

- **结论：**

  - 我们认为 W 类型可以用于表示归纳类型，因此可能不需要额外的构造。

---

#### **7.11 余归纳 (Co-inductions)**

- **新颖性：**

  - 余归纳类型是从编程角度来看的一种新颖概念，它们是某些类型方程的最大解。

- **示例：**

  - 解决描述列表的方程，最小解包含有限元素，最大解也包含无限元素。

- **应用：**

  - 在惰性函数式编程中，无限列表并不令人惊讶，但值得注意的是不存在部分列表。

---

##### **7.11.1 流 (Streams)**

- **定义：**

  - 流是无限列表，可以用余归纳类型来表示。

- **讨论：**

  - 使用流作为通信过程之间的通信模型时，在类型理论中可以确保递归给出完全定义的列表，排除了死锁的可能性。

---

#### **7.12 部分对象和类型 (Partial Objects and Types)**

- **问题：**

  - 如果允许部分对象存在于每个类型中，TT 作为一个逻辑系统的一致性将会丧失，因为未定义的元素将是每个类型的成员，从逻辑角度来看，这意味着每个定理都是可证明的。

- **解决方案：**

  - 可以通过其他方式添加部分对象，而不牺牲 Curry-Howard 同构或逻辑系统的一致性。

- **内容：**

  - 本节提供了一个将部分对象表示纳入类型理论的提议。

---

#### **7.13 建模 (Modelling)**

- **扩展的另一种可能性：**

  - 可以通过添加一组新的规则，来模拟特定类型的对象，例如半群（Semigroup）。

- **方法：**

  - 与在理论中显式构建类型的方式形成对比，这种方法不局限于半群，可以用于任何特定的应用领域。

- **讨论：**

  - 强调了 Martin-Löf 所说的系统的开放性，以及如何在类型理论中引入新的概念。

---

### **总结**

在本章中，我们探讨了在类型理论中添加新构造的各种提议，包括子集类型、商类型、良基递归、归纳和余归纳类型等。我们讨论了这些增强的动机、实现方法以及对系统的影响。

尽管这些增强可以增加系统的表达能力，但也可能导致系统复杂度的增加，甚至可能破坏系统的重要性质，如强归约性和一致性。因此，在引入新构造时，需要谨慎权衡其利弊。

通过深入研究这些提议，我们可以更好地理解类型理论的潜力和局限性，为其在程序开发和数学建模中的应用提供更坚实的基础。

如果您对上述内容有任何疑问，或者希望进一步深入了解某个主题，请随时告诉我！

### ---------------------------

### **第七章 增强类型理论 (Augmenting Type Theory)**

#### **概述**

本章探讨了在类型理论（Type Theory，简称 TT）中添加新构造的各种提议。尽管我们已经看到理论上的系统具有高度的表达能力，但仍存在系统是否以自然或高效的方式表达所需内容的问题。本章将详细讨论系统可能被增强的方式，以及这些增强对系统的影响。

在开始之前，需要强调的是，每个添加的构造虽然在某种程度上增加了系统的能力，但也使得系统更加复杂。这种复杂性可能来自用户的角度，增加了学习和使用的难度；也可能来自基础理论的角度，例如可能导致**强归约性**（Strong Normalization）的丧失。我们将逐节讨论每个提议的利弊，并在本书的结论中对此主题进行更多的探讨。

---

#### **核心主题：子集类型 (Subset Type)**

这些提议的核心是**子集类型**的概念。子集类型与存在类型（Existential Type）不同，其成员仅是满足特定性质的基类型元素，而不是与证明该性质的证据配对的对象。

为了将讨论置于适当的背景中，我们在**第 7.1 节**开始，回顾了**规范的精确性质**。这是我们在讨论波兰国旗问题的案例研究时首次探讨的主题。在文献中，对于类型理论中规范的精确定义存在一些混淆，我们希望在此澄清这一问题。

另一个与引入子集类型相关的普遍主题是**计算相关性**（Computational Relevance）：表达式的某些部分似乎仅具有纯粹的逻辑作用，而不对计算过程的结果做出贡献。我们讨论了捕获这种直觉的两种方法，并探讨了它与**惰性求值**（Lazy Evaluation）的联系。需要注意的是，关于计算相关性或效率的任何论证，都必须相对于某种求值方案进行。我们认为，许多基于计算效率提出的更复杂类型系统的理由，在系统使用惰性求值的情况下是无关紧要的。

---

### **7.1 背景 (Background)**

本节在我们继续讨论如何引入子集类型，以及是否有必要这样做之前，探讨了在 TT 中引入子集类型的背景。

#### **7.1.1 什么是规范？ (What is a specification?)**

**规范的定义：**

在类型理论中，**规范**是对程序或函数所需行为的精确定义。根据 **Curry-Howard 同构**，类型和命题被视为等价，因此规范可以用类型来表达。具体来说，一个程序满足规范，就意味着它是某个特定类型的居住者（inhabitant）。

**规范的表达方式：**

- **存在类型 (Existential Type)：** 使用存在量词，表示存在一个满足特定性质的对象，以及证明该对象确实满足该性质的证据。形式上，可以表示为：
  
  $$
  (\exists x : A).\ P(x)
  $$
  
  其中，$A$ 是类型，$P(x)$ 是关于 $x$ 的性质。

- **子集类型 (Subset Type)：** 定义为满足某个性质的所有元素组成的类型，不需要携带证明该性质的证据。形式上，可以表示为：
  
  $$
  \{ x : A \mid P(x) \}
  $$

**两种方法的区别：**

- **存在类型**需要程序返回一个对象以及证明该对象满足性质的证据。这增加了程序的复杂性，因为需要处理证明部分。
- **子集类型**仅要求程序返回满足性质的对象，不需要提供证明。这使得程序更加简洁，专注于计算本身。

**规范在波兰国旗问题中的应用：**

- 在波兰国旗问题中，我们需要一个函数，重新排列红色和白色元素的列表，使得所有红色元素位于白色元素之前。
- 使用存在类型来表达规范，意味着我们需要返回重新排列的列表以及证明该列表满足规范的证据。
- 使用子集类型，我们可以直接定义满足排列条件的列表类型，函数只需返回一个属于该子集类型的列表。

**文献中的混淆：**

- 在类型理论的文献中，对于如何准确地在系统中表达规范存在一些争论。
- 有些观点认为，规范必须包含证明部分，这增加了程序的复杂性和执行开销。
- 其他观点认为，可以通过引入子集类型，避免携带证明，从而简化程序。

**我们在此澄清：**

- 规范的核心是对程序行为的精确定义，而不是关于程序如何实现或证明的细节。
- 通过合理地选择表达规范的方式，可以在不增加系统复杂性的情况下，满足程序开发的需求。

---

#### **7.1.2 计算相关性；惰性求值 (Computational Irrelevance; Lazy Evaluation)**

**计算相关性的问题：**

- **计算无关性 (Computational Irrelevance)：** 在类型理论中，某些表达式或其部分仅用于逻辑证明，对计算结果没有影响。例如，存在类型中的证明部分在程序执行时可能是不必要的。
- 这种计算无关的部分可能会增加程序的复杂性和执行时间，尤其是在严格求值（Strict Evaluation）的环境下。

**捕获计算无关性的两种方法：**

1. **显式标记计算无关的部分：**

   - **引入特殊的类型或标记：** 在类型系统中引入专门的构造，标记那些仅用于逻辑目的的部分。
   - **类型检查器的作用：** 类型检查器可以识别这些标记，并在类型检查过程中验证逻辑部分的正确性，但在程序执行时忽略它们。
   - **优点：** 明确区分计算相关和计算无关的部分，提高程序的可读性和维护性。
   - **缺点：** 需要对类型系统进行扩展，增加了系统的复杂性。

2. **利用惰性求值 (Lazy Evaluation)：**

   - **延迟计算：** 在惰性求值中，表达式只有在其值被需要时才会被计算。
   - **自动忽略未使用的部分：** 计算无关的部分由于从未被调用，因此不会被计算。
   - **无需扩展类型系统：** 程序员不需要显式地标记计算无关的部分，减少了程序的复杂性。
   - **依赖于执行环境：** 惰性求值需要语言或编译器的支持。

**惰性求值的优势：**

- **提高性能：** 避免了对计算无关部分的计算，减少了不必要的开销。
- **简化程序：** 程序员可以专注于程序的逻辑，而不需要关注哪些部分会被计算。
- **灵活性：** 惰性求值可以与其他优化技术结合，提高程序的整体性能。

**求值方案的重要性：**

- 关于计算相关性或效率的讨论，必须基于特定的求值方案。
- **严格求值 (Strict Evaluation)：** 所有表达式在其被绑定到变量时立即求值。计算无关的部分仍然会被计算，可能导致性能下降。
- **惰性求值 (Lazy Evaluation)：** 表达式的求值被推迟到其值被需要的时候，可以避免对计算无关部分的求值。
- **选择合适的求值策略：** 根据程序的特点和需求，选择合适的求值策略，可以在不增加系统复杂性的情况下，提高程序的效率。

**结论：**

- **计算相关性与系统复杂性：** 如果我们能够通过求值策略（如惰性求值）来处理计算无关的部分，就不需要在类型系统中引入额外的复杂性。
- **对类型系统的影响：** 我们认为，基于计算效率提出的更复杂的类型系统，在惰性求值的情况下，其理由可能并不充分。

---

### **小结**

在本节中，我们探讨了在类型理论中引入子集类型的背景，重点讨论了以下几个方面：

- **规范的本质和表达方式：** 通过理解规范在类型理论中的角色，明确了存在类型和子集类型在表达规范时的区别。
- **计算相关性的问题：** 认识到计算无关的部分可能对程序的性能产生影响，探讨了处理这些部分的两种方法。
- **惰性求值的作用：** 强调了惰性求值在处理计算无关部分时的优势，认为在这种求值策略下，可能不需要对类型系统进行复杂的扩展。

通过对这些问题的深入分析，我们为后续章节的讨论奠定了基础。接下来，我们将详细探讨子集类型的定义、理论缺陷，以及在类型理论中引入子集类型的必要性。

---

### **后续章节预览**

- **7.2 子集类型 (The Subset Type)：** 我们将引入子集类型的朴素定义，并分析其理论上的缺陷。
- **7.3 命题不是类型 (Propositions not Types)：** 探讨在命题和类型不再被视为同一事物的系统中，如何正确地表达子集类型。
- **7.4 子集类型的必要性 (Are Subsets Necessary?)：** 回顾各种提议，论证在现有类型理论中是否有必要引入子集类型。

---

### **总结**

本章的开头部分为我们引入了在类型理论中添加新构造的动机和背景。通过对规范的本质、计算相关性以及惰性求值的讨论，我们开始理解为什么人们会提议添加子集类型，以及这可能带来的问题和解决方案。

在后续章节中，我们将继续深入探讨这些问题，审视各种提议的利弊，并讨论如何在不增加系统复杂性的情况下，实现所需的功能。这对于理解类型理论的扩展，以及在程序开发中如何有效地利用类型系统，具有重要的意义。

### ----------------------------

### **第七章 增强类型理论 (Augmenting Type Theory)**

#### **7.1 背景 (Background)**

在深入讨论如何在类型理论（Type Theory，简称 TT）中引入子集类型（Subset Type）以及是否有必要之前，本节将探讨引入子集类型的背景和动机。

---

#### **7.1.1 什么是规范？ (What is a specification?)**

**初探规范的问题：**

我们在 **第 6.6 节**讨论波兰国旗问题（Polish National Flag Problem）的案例研究时，首次探讨了这个问题。现在，我们从更一般的角度重新审视这个问题。

**类型判断的含义：**

在类型理论中，**类型判断** $a : A$ 可以被理解为：

- **逻辑层面：** “$a$ 证明了命题 $A$”；
- **编程层面：** “$a$ 是类型 $A$ 的一个对象”。

然而，在一些文献中，例如 [ML85] 和 [PS85]，类型判断被建议解读为：

> **$a$ 是满足规范 $A$ 的程序。** (†)

**质疑这种解读：**

这种解读并不普遍适用于所有类型判断 $a : A$。举个例子，考虑一个对列表进行排序的函数 $f$，其类型为：

$$
f : [A] \Rightarrow [A]
$$

那么，我们是否可以说它满足规范 $[A] \Rightarrow [A]$ 呢？**确实如此**，但同样地，**恒等函数**（identity function）和**反转函数**（reverse function）也满足这个类型。显然，**函数的类型只是其规范的一个方面**，规范应该描述输入和输出之间的关系。

**规范的完整描述：**

对于排序函数 $f$，更完整的规范应该是：

- **$f(l)$ 是有序的，并且是列表 $l$ 的一个排列。**

我们可以将这个性质记为 $S(f)$。为了断言某个实现可以满足这个规范，我们可以写成：

$$
(\exists x : [A] \Rightarrow [A]).\ S(x)
$$

**对象的形式：**

属于该类型的对象是**对** $(f, p)$，其中：

- $f : [A] \Rightarrow [A]$
- $p$ 是一个证明，表明 $f$ 具有性质 $S(f)$

**对 (†) 的混淆：**

因此，(†) 中的混淆在于，**对象 $a$ 不仅包含满足规范的程序，还包含证明该程序满足规范的证明**。这意味着程序和证明被混合在一起了。

**规范的建议形式：**

鉴于上述讨论，我们可以建议将**规范**理解为形式 $(\exists o : T).\ P$ 的语句，其中：

- $o$ 是类型 $T$ 的对象；
- $P$ 是关于 $o$ 的性质。

那么，形式化的断言：

$$
(o, p) : (\exists o : T).\ P
$$

可以解读为：

> **对象 $o$（类型为 $T$）被证明满足规范 $P$，证明对象为 $p$。**

这种解读优雅地结合了语言的逻辑和编程解释。对于**构造主义者**来说，这很明显，他们会认为只有在拥有适当的证据（即证明对象）时，我们才能断言 (†)。

**在证明 $(\exists o : T).\ P$ 的过程中：**

- 我们构造一个**对** $(o, p)$，其中：
  - $o$ 是类型 $T$ 的对象；
  - $p$ 是 $o$ 具有性质 $P$ 的证明。

这种对将**计算部分**和**逻辑部分**分开，因此我们可以直接提取计算部分，只需选择对的第一个元素 $o$。

---

**规范的另一种形式：**

在 [NPS90] 中提到，在 **第 6.6 节**中讨论过，建议函数的规范应该具有如下形式：

$$
(\forall x : A).\ (\exists y : B).\ P(x, y) \quad \text{(7.1)}
$$

**该类型的元素：**

是函数 $F$，使得对于所有 $x : A$，

$$
F\ x : (\exists y : B).\ P(x, y)
$$

每个这样的值都是一个对 $(y_x, p_x)$，其中：

- $y_x : B$
- $p_x : P(x, y_x)$

**程序与证明的混合：**

这个对包含了**值**和**证明**的信息，表明在这种方法下，**程序和其验证不可避免地混合在一起**。

**避免混合的方法：**

有人认为，唯一能够实现这种分离的方法是用**子集类型**取代内部的存在类型，从而移除证明信息 $p_x$。**确实可以这样做**，但实际上，**无需扩展系统也可以避免这种混合**。

**使用选择公理：**

我们只需给预期的函数一个名字。一般来说，这种命名可以通过**选择公理**实现，选择公理表明：

$$
(\forall x : A).\ (\exists y : B).\ P(x, y) \Rightarrow (\exists f : A \Rightarrow B).\ (\forall x : A).\ P(x, f(x))
$$

将这个公理与 (7.1) 应用**假言推理**（modus ponens），我们可以得到一个如上所述的“存在”规范。

**逻辑等价性：**

需要注意的是，选择公理的逆命题很容易推导出来，使得两种形式的规范在逻辑上是等价的。

---

**规范形式对程序开发方法的影响：**

- **使用 $\exists \forall$ 形式：** 我们将函数和其证明作为**独立的实体**开发，可以分开或一起开发。
- **使用 $\forall \exists$ 形式：** 我们从一个**证明中提取函数**，事后完成。

**对规范的分析：**

这种分析使得我们清楚，当我们寻求满足规范的程序时，我们在寻找**存在类型**的成员的**第一个组成部分**；第二个部分证明程序满足规范中的约束部分。

只要我们认识到这一点，我们的系统是否包含**第一个组成部分的类型**（即子集类型）似乎并不重要。

**引入子集类型的其他理由：**

尽管如此，仍有其他理由支持引入子集类型，我们将在后续讨论中回顾这些理由。

---

#### **练习**

**7.1.** 你将如何为自然数 $\mathbb{N}$ 上的运算 $+$ 和 $\times$ 指定规范？一般来说，你如何为那些自然规范是其原始递归定义的函数指定规范？

**解答提示：**

- 你需要指定 $+$ 和 $\times$ 的输入和输出类型，以及它们满足的性质。
- 可以使用存在类型或全称存在类型的形式来表示规范。

---

**7.2.** 你将如何为列表上的函数 **head**、**tail**、连接 $++$、长度 **length** 和排序函数指定规范？

**解答提示：**

- 考虑列表的结构，以及这些函数的作用。
- 例如，**head** 函数只适用于非空列表，其规范需要反映这一点。

---

**7.3.** 当我们讨论快速排序时，我们通过使用谓词 **perm** 指定了排列，该谓词使用了自然数类型 $\mathbb{N}$ 上的等式函数 **eqN**。请给出一个不依赖于等式函数存在的排列定义，从而可以用于任何类型的列表。

**解答提示：**

- 需要定义一个通用的排列概念，不依赖于特定类型的等式。
- 可以考虑使用列表的元素的排列方式来定义。

---

**7.4.** 讨论如何使用全称和存在量词使规范模块化。

**解答提示：**

- 模块化规范有助于分解复杂的问题。
- 考虑使用量词来定义函数的输入、输出和性质，从而使规范更具可重用性和清晰性。

---

#### **7.1.2 计算无关性；惰性求值 (Computational Irrelevance; Lazy Evaluation)**

**回顾 'head' 函数的定义：**

在 **第 6.1 节**中，我们讨论了列表上的 **head** 函数。它仅在那些有头部的列表（即非空列表）上定义。我们定义：

$$
\text{nelist } A \equiv_{\text{df}} (\exists l : [A]).\ (\text{nonempty } l)
$$

其中，谓词 **nonempty** 有以下归纳定义：

$$
\begin{cases}
\text{nonempty } [\ ] \equiv_{\text{df}} \bot \\
\text{nonempty } (a :: x) \equiv_{\text{df}} \top
\end{cases}
$$

**'head' 函数的定义：**

$$
\begin{cases}
\text{hd} : (\text{nelist } A) \Rightarrow A \\
\text{hd} ([\ ], p) \equiv_{\text{df}} \text{abort}_A\ p \\
\text{hd} ((a :: x), p) \equiv_{\text{df}} a
\end{cases}
$$

- 这里，$\text{abort}_A\ p$ 表示当 $p$ 是一个矛盾（即 $\bot$）的证明时，无法构造类型 $A$ 的元素。

**计算过程中证明信息的作用：**

考虑一个应用：

$$
\text{hd}\ ((2 :: \dots),\ \dots)
$$

在这种情况下，**计算结果为 2，可以在没有关于被省略部分的任何信息的情况下进行**。特别地，**证明信息对于计算过程来说并不是必要的**。

然而，**证明信息在类型检查中至关重要**，它确保应用是正确类型的；我们不能将函数应用于一个裸列表，因为该列表可能是空的。

**动态和静态部分的张力：**

这体现了语言中通常被认为的**动态部分（计算过程）**和**静态部分（类型系统）**之间的张力。特别地，人们认为如果没有实现分离，那么程序的效率将受到它们携带的大量无关信息的影响——参见 [BCMS89] 的第 3.4 节和 [C+86a] 的第 10.3 节（第 213 页）。

---

**求值机制对效率的影响：**

关于对象或程序的效率的任何结论都基于所考虑系统的**求值机制**。我们现在论证，**惰性求值**（lazy evaluation）或**最外层优先策略**具有不计算计算无关部分的优势，这是我们在 **第 6.2 节**末首次讨论的主题。

**强归约性和 Church-Rosser 性质：**

回顾 **第 5.6 节**的结果，由于系统是**强归约的**（strongly normalizing），任何归约序列都会导致结果。由于我们还具有 **Church-Rosser 性质**，每个归约序列都会导致相同的结果。因此，我们可以选择如何对表达式进行求值。

---

**两种求值策略：**

1. **严格求值（Strict Evaluation）：**

   - 是命令式语言和许多函数式语言（例如 Standard ML，[Har86]）的常见策略。
   - 在这种策略下，对于一个应用：

     $$
     f\ a_1\ \dots\ a_n
     $$

     **参数 $a_i$ 在整个表达式求值之前被完全求值**。
   - 如果参数 $a_k$ 在计算上是无关的，那么对其进行求值将降低程序的效率。

2. **正常序求值（Normal Order Evaluation）：**

   - **开始对整个表达式进行求值，在参数求值之前**。
   - 如果参数的值是不必要的，那么它就不会被求值。

**定义 7.1：**

> **总是选择最左最外层的重写 (redex) 进行求值的策略称为**正常序求值（normal order evaluation）。如果此外我们确保没有重写被多次求值，那么这种求值被称为**惰性求值（lazy evaluation）**。

---

**结构化数据的求值：**

在具有**结构化数据**（如对和列表）的语言中，还有一个补充说明：

- 当一个参数被求值时，**不需要将其求值到正常形式**（normal form）；它只需被求值到计算能够继续进行的程度。
- 通常意味着它被求值到**弱头部正常形式**（weak head normal form）。
- 例如，对于类型 $A \land B$ 的参数，将其简化为对 $(a, b)$，其中子表达式 $a$ 和 $b$ 尚未被求值。它们可能在后续计算中被求值，也可能不被求值。

---

**惰性求值的优势：**

- **避免不必要的计算：** 计算上无关的对象或结构化对象的组件将被忽略，因此不会产生额外的计算开销。
- **提高效率：** 程序只计算必要的部分，避免了对证明信息等无关部分的求值。
- **适用于类型理论的实现：** 最近的研究表明，对像 Miranda 这样的函数式语言进行高效的惰性实现是可行的，因此同样的技术可以用于 TT 的实现。

**建议阅读：**

- 有关惰性求值和函数式编程的更多信息，读者可以参考 [Pey87]，这是一部优秀的入门书籍。

---

**计算无关性的另一种观点：**

还有另一种可能的方法来处理**计算相关性**，涉及检查类型（即命题）可以采取的不同形式。

- **对于类型 $\bot$（假）：** 没有闭合的正常形式。
- **对于类型 $\top$（真）：** 只有平凡的 $\text{Triv}$。
- **因此，对这些类型的对象的计算永远不会重要**。

关键在于，**在任何特定情况下，重要的是类型是否可居住（inhabited）**。

---

**在 'head' 函数中的应用：**

这正是这些类型在 **'head'** 函数定义中发挥的作用，我们应当回顾：

$$
\text{nelist } A \equiv_{\text{df}} (\exists l : [A]).\ (\text{nonempty } l)
$$

其中，

$$
\begin{cases}
\text{nonempty } [\ ] \equiv_{\text{df}} \bot \\
\text{nonempty } (a :: x) \equiv_{\text{df}} \top
\end{cases}
$$

**应用 'head' 函数：**

- 只有当我们能够将列表 $l$ 与一个证明 $p$（表明 $l$ 是非空的）配对时，才能将 $\text{hd}$ 应用于列表 $l$。
- **证明在进一步的计算中没有贡献**，它通过语言的类型系统确保了应用是对非空列表的。

---

**计算无关性的保留：**

- 可以论证，当使用连接词 $\land$、$\Rightarrow$ 和 $\forall$ 进行组合时，这种计算无关性得以保留。
- 在 [BCMS89] 的第 3.4 节中，针对扩展理论 [ML85] 的上下文，从不同的角度讨论了这一主题。

---

#### **练习**

**7.5.** 使用上述讨论的惰性求值策略，计算表达式 $\text{hd} ((2 :: a), b)$ 的结果。

**解答：**

- 由于惰性求值策略，参数 $a$ 和证明 $b$ 不会被求值，因为计算不需要它们。
- 直接得到结果 $2$。

---

**7.6.** 讨论为什么使用连接词 $\land$、$\Rightarrow$ 和 $\forall$ 组合公式可以保留计算无关性。

**解答提示：**

- 这些连接词在逻辑上不会引入新的计算内容，仅组合了现有的命题。
- 组合后，如果其中的部分是计算无关的，整体也将保持计算无关。

---

**7.7.** 检查上一章的示例，找到计算无关性的案例。

**解答提示：**

- 回顾上一章中的函数和证明，寻找那些在计算过程中不需要的证明部分。
- 例如，在快速排序的证明中，可能存在这样的部分。

---

### **总结**

在本节中，我们深入探讨了在类型理论中引入子集类型的背景和动机，重点关注以下几个方面：

1. **规范的本质：**
   - 通过分析类型判断 $a : A$ 的含义，明确了程序和证明在规范中的角色。
   - 强调了在构造规范时，将程序和证明作为独立的实体可以更好地理解和处理。

2. **规范的不同表达形式：**
   - 比较了 $\forall \exists$ 和 $\exists \forall$ 两种形式的规范，以及它们对程序开发方法的影响。
   - 通过选择公理，说明了这两种形式在逻辑上是等价的。

3. **计算无关性与惰性求值：**
   - 讨论了在计算过程中，证明信息等计算无关的部分可能导致效率问题。
   - 引入了惰性求值策略，展示了如何避免对计算无关部分的求值，从而提高程序效率。

4. **类型的角色：**
   - 分析了类型 $\bot$ 和 $\top$ 在计算中的作用，强调了类型是否可居住的重要性。
   - 说明了在使用连接词组合命题时，如何保持计算无关性。

通过对这些问题的深入分析，我们了解到在类型理论中，程序和证明的分离，以及计算无关性的处理，是构建高效且可验证程序的关键。

---

### **后续讨论**

在接下来的章节中，我们将继续讨论在类型理论中引入子集类型的具体方法，以及它们可能带来的理论和实践问题。我们还将探讨其他增强类型理论的提议，如商类型、良基递归、归纳类型和余归纳类型等。

这些讨论将帮助我们更全面地理解类型理论的扩展，以及在程序开发和形式化验证中的应用。

---

### **如果您有任何疑问，或者希望深入了解某个主题，请随时告诉我！**

### ---------------------------

### **第七章 增强类型理论 (Augmenting Type Theory)**

#### **7.2 子集类型 (The Subset Type)**

---

##### **引言**

在类型理论中，我们经常需要表示具有某种性质 $B$ 的类型 $A$ 的对象的集合。那么，我们应该如何表示这些对象的集合呢？根据**完整表示原则**（principle of complete presentation），我们可以构造类型：

$$
(\exists x : A).\ B
$$

该类型由对象和证明它们具有性质 $B$ 的证明对组成。这是我们在前面的讨论中处理这种类型的方式。然而，还有另一种方法，即构建**子集类型**（subset type）：

$$
\{ x : A \mid B \}
$$

其成员由 $A$ 中满足性质 $B$ 的那些元素 $a$ 组成，即那些类型 $B[a/x]$ 可居住（inhabited）的 $a$。

---

##### **子集类型的影响**

引入子集类型后，会产生一个重要的后果：**我们在系统 $TT$ 中失去了类型的唯一性**。也就是说，一个对象 $a$ 将成为每个 $B$ 是其性质的子集类型 $\{ x : A \mid B \}$ 的成员。这意味着同一个对象可以属于多个不同的子集类型。

---

##### **子集类型的形式规则**

现在，我们来讨论子集类型的正式规则。这些规则最初由 [NP83] 提出，并在 [C+86a] 第 167 页和 [BCMS89] 第 3.4.2 节中使用。

###### **子集类型的形成规则 (Formation Rule for Set)**

形成规则是完全标准的：

$$
\frac{
  A\ \text{是一个类型} \quad [x : A] \quad B\ \text{是一个类型}
}{
  \{ x : A \mid B \}\ \text{是一个类型}
} \quad \text{(SetF)}
$$

- **解释：**
  - 如果 $A$ 是一个类型，并且在 $x : A$ 下 $B$ 是一个类型，那么我们可以形成子集类型 $\{ x : A \mid B \}$。

---

###### **子集类型的引入规则 (Introduction Rule for Set)**

对象的引入如下：

$$
\frac{
  a : A \quad p : B[a/x]
}{
  a : \{ x : A \mid B \}
} \quad \text{(SetI)}
$$

- **解释：**
  - 如果 $a$ 是类型 $A$ 的对象，并且 $p$ 是 $B[a/x]$ 的证明，那么 $a$ 就属于子集类型 $\{ x : A \mid B \}$。

---

###### **子集类型的消解规则 (Elimination Rule for Set)**

我们应该如何消解一个子集类型呢？如果我们知道 $a : \{ x : A \mid B \}$，那么我们当然知道 $a : A$，并且 $B[a/x]$ 成立。但是，我们没有具体的证明 $B[a/x]$ 的对象，那么我们如何封装这个信息呢？

我们可以修改存在量词的消解规则 $(\exists E)$，使得假设判断 $c : C$ 是在假设某个 $y : B[a/x]$ 的情况下推导的，但 $c$ 和 $C$ **不能依赖于这个 $y$**。我们使用 $B[a/x]$ 是可证明的这一事实，但不能依赖于证明 $y$ 本身。

具体的消解规则如下：

$$
\frac{
  a : \{ x : A \mid B \} \quad [x : A; y : B]
  \quad \vdots \quad
  c(x) : C(x)
}{
  c(a) : C(a)
} \quad \text{(SetE)}
$$

- **解释：**
  - 假设我们有 $a : \{ x : A \mid B \}$。
  - 在假设 $x : A$ 和 $y : B$ 的情况下，我们可以推导 $c(x) : C(x)$。
  - 然后，我们可以得到 $c(a) : C(a)$。
  - **重要的是，$c$ 和 $C$ 不能依赖于 $y$**。

---

###### **子集类型的计算规则**

由于消解规则没有引入新的操作符，因此子集类型没有计算规则。这使得这些规则与类型理论中的其他规则不同。这一点也可以从它们不满足第 8.4 节的**反演原则**（inversion principle）中看出。

---

##### **系统 $TT^S_0$ 与 $TT_0$ 的关系**

我们将带有上述子集类型规则的系统记为 $TT^S_0$。那么，$TT_0$ 和 $TT^S_0$ 之间是什么关系呢？在 [Chi88a] 中证明了以下定理。

---

###### **定理 7.2**

**命题：** 从在 $TT^S_0$ 中的推导 $d$（证明 $p : (\exists x : A).\ B$）中，可以构造一个推导 $\text{fst}\ p : \{ x : A \mid B \}$，并且使用相同的假设集。

**证明：**

- 使用子集类型的引入规则 $(SetI)$。
- 具体而言，$p$ 是一个对 $(a, q)$，其中 $a : A$ 且 $q : B$。
- 根据 $(SetI)$，有 $a : \{ x : A \mid B \}$。
- 因此，$\text{fst}\ p = a$ 属于 $\{ x : A \mid B \}$。

**证毕。** □

---

###### **定理 7.3**

**命题：** 如果在 $TT^S_0$ 中，我们可以从假设 $\Gamma$ 推导 $p : \{ x : A \mid B \}$，那么从这个推导中，我们可以对于某个 $q : B$，构造一个在 $TT_0$ 中的推导 $(p, q) : (\exists x : A).\ B$，并且假设集为 $\Gamma'$。假设集 $\Gamma'$ 是通过将 $\Gamma$ 中形式为 $y : \{ y : C \mid D \}$ 的假设替换为 $y : C; y' : D$ 得到的，其中 $y'$ 是一个新的变量。

**证明：**

- **思路：** 对于推导 $p : \{ x : A \mid B \}$，我们可以通过归纳其推导的大小来证明。
- **步骤：**
  1. **基础情况：** 如果推导的深度为 1，那么 $p$ 是由引入规则 $(SetI)$ 得到的 $a : \{ x : A \mid B \}$，其中 $a : A$ 且 $p' : B[a/x]$。
     - 在 $TT_0$ 中，我们可以构造 $(a, p') : (\exists x : A).\ B$。
  2. **归纳假设：** 假设对于推导深度小于 $n$ 的情况，命题成立。
  3. **归纳步骤：** 对于推导深度为 $n$ 的 $p$，我们检查其推导树的最后一步，可能是应用了某个规则。
     - 如果最后一步是应用了引入规则 $(SetI)$，则与基础情况类似。
     - 如果最后一步是应用了其他规则，我们需要根据这些规则，利用归纳假设，构造所需的推导。
- **处理假设集 $\Gamma$：**
  - 对于 $\Gamma$ 中的每个假设 $y : \{ y : C \mid D \}$，我们将其替换为 $y : C$ 和 $y' : D$，其中 $y'$ 是新的变量。
  - 这样，所有涉及子集类型的假设都被展开为类型和性质的组合。

**结论：**

- 因此，我们可以在 $TT_0$ 中构造所需的推导 $(p, q) : (\exists x : A).\ B$。

**证毕。** □

---

**解释：**

- **定理 7.2** 表明，从存在类型的推导，我们可以得到子集类型的元素。
- **定理 7.3** 表明，如果我们能够推导一个对象属于子集类型，那么在这个推导中隐含了一个证明，即该对象具有所需的性质。通过检查推导，我们可以提取出这个证明对象。

---

##### **子集类型规则的局限性**

另一方面，Smith 和 Salvesen 通过扩展 Martin-Löf 的**归约性证明**（参见第 5.6 节和 [ML75b]）表明：

---

###### **定理 7.4**

**命题：** 如果在 $TT^S_0$ 中，可以推导判断：

$$
t : (\forall x : \{ z : A \mid P(z) \}).\ P(x) \quad \text{(7.2)}
$$

并且 $A$ 和 $P$ 不包含子集类型，那么存在某个项 $t_0$，使得：

$$
t_0 : (\forall x : A).\ P(x) \quad \text{(7.3)}
$$

可以被推导。

**证明：**

- 见 [SS89]。

**证毕。** □

---

**含义：**

- 这表明子集类型的规则非常弱。
- 在判断 (7.2) 中，项 $t$ 见证了子集类型中对象的性质 $P$。
- 结果说明，只有当 (7.3) 可被推导时，我们才能提取这个信息。换句话说，**只有当类型 $A$ 的所有元素都具有性质 $P$ 时**，我们才能从子集类型中提取出性质 $P$。
- **问题的关键在于子集类型规则的弱点。**

---

##### **子集类型规则的弱点分析**

**检查消解规则 (SetE)：**

- 消解规则的假设部分：

  $$
  [x : A; y : B] \quad \vdots \quad c(x) : C(x)
  $$

- 我们被允许使用假设 $y : B$，**但 $y$ 不能在 $c$ 或 $C$ 中自由出现**。
- **在 $TT_0$ 的规则中**，如果任何规则包含一个变量在未解除的假设中自由出现，那么这个变量将自由地出现在结论中。
- 换句话说，如果我们使用了某个假设，并且它没有被解除，那么它将自由地出现在结论中。

---

##### **定理 7.4 的影响**

- **定理 7.4** 表明，许多函数在 $TT^S_0$ 中是不可导出的。
- **举例：**

  - 考虑列表，我们假设可以导出函数：

    $$
    \text{head}_0 : \{ l : [A] \mid \text{nonempty } l \} \Rightarrow A
    $$

    $$
    \text{tail}_0 : \{ l : [A] \mid \text{nonempty } l \} \Rightarrow [A]
    $$

  - 满足对于非空列表 $l$：

    $$
    l = (\text{head}_0\ l) :: (\text{tail}_0\ l)
    $$

- **推导矛盾：**

  - 从上述，我们可以构造一个 $\text{nonempty } l$ 的证明。
  - 这对应于假设 (7.2)，因此我们可以推导：

    $$
    (\forall l : [A]).\ (\text{nonempty } l)
    $$

  - 这导致了矛盾，因为这意味着**所有列表都是非空的**，这显然不成立。

---

#### **7.2.1 扩展理论 (The Extensional Theory)**

**情况不同之处：**

- 在 [ML85] 的**扩展理论**（extensional theory）中，情况有所不同。
- **证明规则 $(IE_{ext})$**（在第 170 页引入）以及规则 $(II)$ 允许从 $e : I(A, a, b)$ 推导出 $r(a) : I(A, a, b)$，对于任何表达式 $e$。
- 由于 $r(a)$ 是一个常数，这导致了一个类型为 $I(A, a, b)$ 的证明对象，其中不包含自由变量。

**影响：**

- 这使得我们可以推导出一个**证明对象**，其假设中包含多个变量，但这些变量不自由地出现在证明对象中。
- **这个条件正是应用消解规则 $(SetE)$ 所需要的**。

---

**示例：**

- 在 [Sal89a] 中，有以下推导：

  $$
  (\forall x : [\mathbb{N}]).\ (\forall n : \{ z : \mathbb{N} \mid (z\ \text{in}\ x) \}).\ (n\ \text{in}\ x)
  $$

- 其中，$n\ \text{in}\ x$ 是一个归纳定义的命题，表示 $n$ 是列表 $x$ 的一个成员。
- **这个推导并不简单**，它在本质上使用了类型 $U_0$ 和类型替换规则。

---

##### **稳定公式 (Stable Formulas)**

###### **定义 7.5**

**定义：** 对于 $A$ 上的一个公式 $P$，如果满足：

$$
(\forall x : A).\ (\lnot\lnot P \Rightarrow P)
$$

则称 $P$ 是**稳定的**。

---

**结果：**

- Salvesen 和 Smith 表明，对于所有稳定的公式，在类型理论的扩展版本中，可以推导：

  $$
  (\forall x : \{ z : A \mid P(z) \}).\ P(x)
  $$

---

**关于稳定公式的讨论：**

- **Harrop** 在 [Har60] 中首次给出了稳定公式的句法刻画。
- 关于计算无关公式的类似刻画可以在 [BCMS89] 中找到。
- 需要注意的是，**当存在宇宙 (universe) 时，识别稳定公式变得更加困难**，因为可以借助宇宙引入非规范的类型表达式（参见 [Sal89a]）。

---

**限制性结果：**

- 关于稳定公式的结果在某种意义上是最好的可能结果。
- 同时，在 [SS89] 中也证明了，对于所有公式，$(\forall x : \{ z : A \mid P(z) \}).\ P(x)$ 并不总是可证明的。
- 他们的证明基于 Troelstra 的一个想法，用于在扩展环境中反驳 Church 论题。

---

##### **结论**

- **子集类型规则的弱点和限制**导致了 Göteborg 团队重新评估子集类型，并采用了不同的方法。
- 我们将在后续的 **第 7.3 节**中讨论他们的方法。

---

#### **练习**

**7.8.** 完成上述定理 7.3 的证明。

**解答：**

- **详见定理 7.3 的证明过程**：
  - **归纳步骤：**
    - 假设对于推导深度小于 $n$ 的情况，定理成立。
    - 对于推导深度为 $n$ 的 $p : \{ x : A \mid B \}$，我们需要考虑推导的最后一步。
    - 根据推导规则，最后一步可能是应用了某个规则 $R$，我们需要分析 $R$ 对 $p$ 的构造。
    - 我们根据 $R$ 的类型，以及使用归纳假设，构造 $(p, q) : (\exists x : A).\ B$ 的推导。

- **处理假设集的替换：**
  - 对于假设 $y : \{ y : C \mid D \}$，我们将其替换为 $y : C$ 和 $y' : D$。
  - 这样，我们可以在 $TT_0$ 中继续推导。

**结论：**

- 通过归纳，我们完成了定理 7.3 的证明。

---

**7.9.** 形式化上述关于存在函数 $\text{head}_0$ 和 $\text{tail}_0$ 导致不一致的论证。

**解答：**

- **假设：**

  - 存在函数：

    $$
    \text{head}_0 : \{ l : [A] \mid \text{nonempty } l \} \Rightarrow A
    $$

    $$
    \text{tail}_0 : \{ l : [A] \mid \text{nonempty } l \} \Rightarrow [A]
    $$

  - 满足对于非空列表 $l$：

    $$
    l = (\text{head}_0\ l) :: (\text{tail}_0\ l)
    $$

- **推导：**

  - 由此，我们可以构造一个 $\text{nonempty } l$ 的证明。
  - 由于 $l$ 可以是任意列表，这意味着我们对于所有列表 $l$ 都有 $\text{nonempty } l$。
  - 因此，推导出：

    $$
    (\forall l : [A]).\ (\text{nonempty } l)
    $$

  - 这与列表可以为空的事实相矛盾，导致不一致。

---

**7.10.** 上述类型理论的扩展版本中，函数 $\text{head}_0$ 和 $\text{tail}_0$ 可以被定义吗？

**解答：**

- **在扩展理论中：**

  - 由于扩展理论允许从 $e : I(A, a, b)$ 推导出 $r(a) : I(A, a, b)$，并且 $r(a)$ 是一个不包含自由变量的常数。
  - 这使得我们可以构造不依赖于证明对象的函数。
  - 因此，可能可以在扩展理论中定义 $\text{head}_0$ 和 $\text{tail}_0$。
- **需要详细的构造和证明**，以确保这些函数的定义不导致不一致。

---

**7.11.** 证明命题 $\mathbb{N}$、$N_n$ 是稳定的，并且如果 $A$ 上的等式可形式判定，那么 $x =_A y$ 是稳定的。证明如果 $A$ 和 $B$ 是稳定的，那么 $A \land B$、$A \Rightarrow B$ 和 $(\forall x : A).\ B$ 也是稳定的。

**解答：**

- **证明 $\mathbb{N}$ 是稳定的：**

  - 对于任何自然数 $n$，$\mathbb{N}$ 都是可居住的。
  - 因此，$\lnot\lnot \mathbb{N} \Rightarrow \mathbb{N}$ 成立。

- **证明 $N_n$ 是稳定的：**

  - $N_n$ 是关于自然数 $n$ 的性质，类似于 $n$ 是自然数。
  - 同样，$\lnot\lnot N_n \Rightarrow N_n$ 成立。

- **如果 $A$ 上的等式可形式判定，即对于任意 $x, y : A$，$x =_A y$ 是可判定的，那么 $x =_A y$ 是稳定的：**

  - 因为我们可以在有限步骤内确定 $x$ 是否等于 $y$。

- **如果 $A$ 和 $B$ 是稳定的，那么：**

  - **$A \land B$ 的稳定性：**

    - $\lnot\lnot (A \land B) \Rightarrow (A \land B)$。
    - 由于 $A$ 和 $B$ 都是稳定的，故成立。

  - **$A \Rightarrow B$ 的稳定性：**

    - $\lnot\lnot (A \Rightarrow B) \Rightarrow (A \Rightarrow B)$。
    - 由于 $A$ 和 $B$ 是稳定的，故成立。

  - **$(\forall x : A).\ B$ 的稳定性：**

    - $\lnot\lnot (\forall x : A).\ B \Rightarrow (\forall x : A).\ B$。
    - 由于 $B$ 对于所有 $x : A$ 都是稳定的，故成立。

---

**7.12.** 使用析取和存在量词，给出一些非稳定公式的例子。

**解答：**

- **非稳定公式的例子：**

  - **析取：** $P \lor Q$ 可能不是稳定的。
    - 例如，当 $P$ 和 $Q$ 都未知时，$\lnot\lnot (P \lor Q)$ 并不推出 $P \lor Q$。

  - **存在量词：** $(\exists x : A).\ P(x)$ 可能不是稳定的。
    - 例如，我们可能无法从 $\lnot\lnot (\exists x : A).\ P(x)$ 推出 $(\exists x : A).\ P(x)$，因为这需要找到具体的 $x$。

---

### **总结**

在本节中，我们深入探讨了**子集类型**在类型理论中的引入、形式规则以及其局限性。我们了解到：

- **子集类型的引入：** 提供了一种表示具有特定性质的类型元素集合的方法。
- **子集类型的规则：** 包括形成规则、引入规则和消解规则，但由于没有计算规则，使得这些规则与其他类型理论规则不同。
- **子集类型的弱点：** 由于消解规则的限制，许多函数在包含子集类型的系统中是不可导出的。这体现在定理 7.4 以及对函数 $\text{head}_0$ 和 $\text{tail}_0$ 的讨论中。
- **扩展理论的不同之处：** 在扩展理论中，通过额外的证明规则，可以绕过某些限制，使得子集类型的应用更为广泛。
- **稳定公式：** 介绍了稳定公式的概念，并讨论了在扩展理论中稳定公式的推导。

通过这些讨论，我们认识到在类型理论中引入子集类型需要谨慎考虑其规则和影响。在后续章节中，我们将继续探讨其他增强类型理论的方法。

---

### **如果您对上述内容有任何疑问，或者希望深入了解某个主题，请随时告诉我！**

### ----------------------------

### **第七章 增强类型理论 (Augmenting Type Theory)**

#### **7.3 命题不是类型 (Propositions not Types)**

---

在 **第 7.2 节** 中，我们介绍了子集类型的规则。然而，紧接着在 **定理 7.4** 中，我们发现这些规则并不令人满意。这引出了一个问题：我们如何改进类型理论中对子集的表示？

提出的所有解决方案都涉及将**命题**表示为与**类型**不同的实体。从直觉上讲，这是合理的；首先，逻辑的使用者更感兴趣的是**建立形如 “$A$ 为真” 的判断**，而不是展示特定的证明对象使得该命题为真。

---

#### **7.3.1 '压缩'类型 ('Squash' Types)**

**第一种**表示命题的方法是考虑所谓的 **'压缩'类型**（squash type），在 [C+86a] 中定义为：

$$
\ulcorner A \urcorner \equiv_{\text{df}} \{ t : \top \mid A \}
$$

- **解释：**
  - 这里，$\top$ 是逻辑真（True）的类型，只有一个元素 $\text{Triv}$。
  - 子集类型 $\{ t : \top \mid A \}$ 包含的对象是满足 $A$ 的 $t$。
  - 因为 $\top$ 只有一个元素 $\text{Triv}$，所以这个子集类型要么包含 $\text{Triv}$，要么不包含，取决于 $A$ 是否可证明。

这被称为 **'压缩'类型**，因为**所有关于证明的信息都被“压缩”掉了**。它只关心 $A$ 是否可证明，而不关心 $A$ 的证明对象是什么。

**我们应该问**，判断：

$$
\text{Triv} : \ulcorner A \urcorner
$$

是否能合理地表示判断“$A$ 为真”。

**这意味着什么？**

我们希望，**当形式为 $b : B$ 的判断被替换为“$B$ 为真”**时，构造逻辑的所有规则（如在 $TT_0$ 中所呈现的）仍然成立。

**例如，我们应该有：**

$$
\begin{array}{c}
A\ \text{为真} \quad B\ \text{为真} \\
\hline
A \land B\ \text{为真} \quad \text{(7.4)}
\end{array}
$$

**我们可以证明这一点。**

---

**详细证明：**

**假设**，根据子集类型的消解规则 $(SetE)$（在 **第 7.2 节**中引入），我们有：

1. $x : \top$，$p : A$
2. $y : \top$，$q : B$

**从这些假设，我们可以推导：**

- $(p, q) : A \land B$
  - **解释：**
    - 我们将 $p : A$ 和 $q : B$ 结合，得到 $(p, q) : A \land B$。
- 根据子集类型的引入规则 $(SetI)$：

  $$
  \text{Triv} : \{ t : \top \mid A \land B \}
  $$

- **注意：**
  - 这个判断中，$p$ 和 $q$ 都不在自由变量中出现。
  - 这意味着，通过**两次**子集类型的消解，我们可以在假设：

    $$
    \text{Triv} : \{ t : \top \mid A \},\quad \text{Triv} : \{ t : \top \mid B \}
    $$

  下得到相同的结果。

- 这正是我们期望的 (7.4)。

---

**然而，当我们尝试证明以下内容时，问题出现了：**

$$
\begin{array}{c}
[x : A] \\
\vdots \\
B(x)\ \text{为真} \\
\hline
(\forall x : A).\ B(x)\ \text{为真} \quad \text{(7.5)}
\end{array}
$$

**很容易看出，对此进行推导会**与规则 (7.4) 矛盾；参见 [Sal89a] 的第 3 节。

**直观上，我们可以这样理解：**

- **知道 $B$ 在每个实例下为真，并不足以以统一的方式建立它在全局上为真。**

**这是唯一一个该标准失败的规则**，但它表明，如果我们要在类型理论中找到对判断“$A$ 为真”的恰当表示，就必须采用不同的方法。

---

#### **7.3.2 子集理论 (The Subset Theory)**

**为了在子集方面改进判断的表示**，希望系统能够验证如下规则：

$$
\frac{
  a : \{ x : A \mid P \} \quad [x : A,\ P\ \text{为真}] \quad \vdots \quad Q(x)\ \text{为真}
}{
  Q(a)\ \text{为真}
} \quad \text{(SetE}_0\text{)}
$$

- **该规则的结果是**，当设 $P = Q$ 时，我们有：

  $$
  \frac{
    a : \{ x : A \mid P \}
  }{
    P(a)\ \text{为真}
  }
  $$

**为了使这条规则有效，我们需要**转到一个**命题和类型是分开的系统**，因为正如 **定理 7.4** 所示，如果 $P$ 是一个类型，我们不能有这条规则。

---

**在 [NPS90] 中，Göteborg 团队**（“遵循 Martin-Löf 的思想”）引入了一个称为 **子集理论**（the subset theory）的系统，在该系统中添加了新的判断：

- $P\ \text{是命题}$（$P\ \text{prop}$）
- $P\ \text{为真}$（$P\ \text{is true}$）

并且引入了一组**逻辑连接词**，与他们的扩展版本的 $TT$ 中引入的类型构造操作符不同。

- 他们的系统使用符号 $\times, +, \Pi, \dots$ 表示类型构造操作符，保留 $\land, \lor, \forall, \dots$ 用于命题的操作。
- **这种区别使得命题和类型在符号和概念上分离开来。**

---

**他们引入的规则，以下面的逻辑全称量词 $\forall$ 为例：**

1. **命题的形成规则：**

   $$
   \frac{
     A\ \text{是命题} \quad [x : A] \quad \vdots \quad P(x)\ \text{是命题}
   }{
     (\forall x : A).\ P(x)\ \text{是命题}
   }
   $$

2. **命题的引入规则（证明命题为真）：**

   $$
   \frac{
     [x : A] \quad \vdots \quad P(x)\ \text{为真}
   }{
     (\forall x : A).\ P(x)\ \text{为真}
   }
   $$

3. **命题的消解规则（全称量词的消解）：**

   $$
   \frac{
     (\forall x : A).\ P(x)\ \text{为真} \quad a : A
   }{
     P(a)\ \text{为真}
   }
   $$

---

**此外，他们为子集类型给出了以下规则：**

1. **子集类型的形成规则：**

   $$
   \frac{
     A\ \text{是一个类型} \quad [x : A] \quad \vdots \quad P(x)\ \text{是命题}
   }{
     \{ x : A \mid P(x) \}\ \text{是命题}
   }
   $$

2. **子集类型的引入规则：**

   $$
   \frac{
     a : A \quad P(a)\ \text{为真}
   }{
     a : \{ x : A \mid P(x) \}
   }
   $$

3. **子集类型的第一种消解规则（用于类型）：**

   $$
   \frac{
     a : \{ x : A \mid P(x) \} \quad [x : A,\ P(x)\ \text{为真}] \quad \vdots \quad c(x) : C(x)
   }{
     c(a) : C(a)
   }
   $$

4. **子集类型的第二种消解规则（用于命题）：**

   $$
   \frac{
     a : \{ x : A \mid P(x) \} \quad [x : A,\ P(x)\ \text{为真}] \quad \vdots \quad Q(x)\ \text{为真}
   }{
     Q(a)\ \text{为真}
   }
   $$

- **注意：**
  - 这两条消解规则对应于我们之前讨论的规则，其中第二条消解规则就是我们希望有效的 $\text{(SetE}_0)$ 规则。

---

**这些规则可以看作满足了 **第 8.4 节** 的**反演原则**（Inversion Principle）。

---

**子集理论的一个优雅之处在于其合理性：**

- **它可以在“基本”类型理论中得到解释**，即沿着 [ML85] 的思路，在 $TT$ 的扩展版本中。

**具体而言：**

1. **类型**是基本理论中的**对 $(A, A')$**，其中：
   - $A$ 是理论中的类型；
   - $A'$ 是 $A$ 上的一个谓词。

2. **新理论中的命题**是命题，即旧理论中的类型，它们当然可能包含对新类型的量化，因此旧理论中的所有命题并不是新理论中的命题。

3. **解释是逐个构造地定义的（construct-by-construct）。**

**在这个解释下，所有关于命题的规则都可以在基本系统中导出，因此基本系统的一致性被提升到子集理论中。**

---

#### **7.3.3 哥德尔解释 (Gödel Interpretation)**

**第二种将命题表示为与类型不同的方法**由 [Sal89a] 的第 4 节给出。

- **动机：**
  - 基于 [SS89] 中关于 Harrop 公式的结果。
  - 命题被解释为某个特定的类型子类，通过在直觉主义逻辑中使用哥德尔的双重否定解释（Gödel double negation interpretation）从经典逻辑中产生；详见 [Dum77]。

**非正式地，解释如下：**

- **在每个存在量词、析取和等式类型前加上双重否定 $\lnot\lnot$**，从而削弱其构造性内容。

**在这种解释下，我们可以推导出类似于上述的规则，包括 $\text{(SetE}_0)$，以及经典逻辑中的定理：

$$
\frac{
  A\ \text{是命题}
}{
  A \lor \lnot A\ \text{为真}
}
$$

- **这需要在 $TT$ 中推导出 $\lnot\lnot (A \lor \lnot A)$。**

---

#### **练习**

---

**7.13.** 给出 (NE) 的无证明版本，并且证明如果我们使用判断 $\text{Triv} : \ulcorner A \urcorner$ 来表示 $A$ 为真，那么这个版本的规则是有效的。

**解答：**

- **(NE) 规则**通常涉及到消解一个存在类型，需要一个证明对象。

- **无证明版本的 (NE)：**

  - **在不涉及证明对象的情况下，规则应当只涉及命题的真假，而不涉及其证明。**

- **如果我们使用 $\text{Triv} : \ulcorner A \urcorner$ 来表示 $A$ 为真，那么 (NE) 的无证明版本是有效的。**

---

**7.14.** 展示 (7.5) 的有效性如何与定理 7.4 矛盾。

**解答：**

- **(7.5) 表示：**

  $$
  \begin{array}{c}
  [x : A] \\
  \vdots \\
  B(x)\ \text{为真} \\
  \hline
  (\forall x : A).\ B(x)\ \text{为真}
  \end{array}
  $$

- **定理 7.4 表明，如果在系统 $TT^S_0$ 中可以推导 $t : (\forall x : \{ z : A \mid P(z) \}).\ P(x)$，并且 $A$ 和 $P$ 不包含子集类型，那么可以推导 $t_0 : (\forall x : A).\ P(x)$。**

- **但是，如果 (7.5) 有效，那么即使 $B(x)$ 不是稳定的，我们也可以推导出 $(\forall x : A).\ B(x)$ 为真，这与定理 7.4 的限制相矛盾。**

- **因此，(7.5) 的有效性与定理 7.4 矛盾。**

---

**7.15.** 在 $TT_0$ 中推导结果 $\lnot\lnot (A \lor \lnot A)$。

**解答：**

- **目标：** 在 $TT_0$ 中证明 $\lnot\lnot (A \lor \lnot A)$。

- **证明思路：**

  1. **假设 $\lnot (A \lor \lnot A)$，推导矛盾。**

  2. **即，假设 $\lnot A$ 且 $\lnot \lnot A$，推导矛盾。**

- **详细证明：**

  - **假设 $\lnot (A \lor \lnot A)$，则 $\lnot A$ 且 $\lnot \lnot A$。**

  - **但是 $\lnot \lnot A$ 表示 $\lnot (\lnot A)$，所以我们同时有 $\lnot A$ 和 $\lnot (\lnot A)$，矛盾。**

  - **因此，假设 $\lnot (A \lor \lnot A)$ 导致矛盾，故 $\lnot\lnot (A \lor \lnot A)$ 为真。**

---

### **总结**

在本节中，我们探讨了**将命题表示为与类型不同的实体**的方法，重点讨论了以下内容：

1. **'压缩'类型 ('Squash' Types)：**

   - 通过定义 $\ulcorner A \urcorner \equiv_{\text{df}} \{ t : \top \mid A \}$，试图表示“$A$ 为真”这一判断。
   - 发现当处理合取 $A \land B$ 时，这种方法是可行的，但在处理全称量词 $\forall$ 时，遇到了困难。

2. **子集理论 (The Subset Theory)：**

   - Göteborg 团队提出了一种新的系统，其中**命题和类型是分开的**。
   - 引入了新的判断 $P\ \text{是命题}$ 和 $P\ \text{为真}$，以及与类型构造操作符不同的逻辑连接词。
   - 这种方法解决了之前的方法在处理全称量词时的问题。

3. **Gödel 解释 (Gödel Interpretation)：**

   - 通过在存在量词、析取和等式类型前添加双重否定 $\lnot\lnot$，削弱其构造性内容。
   - 使得可以在 $TT$ 中推导经典逻辑中的某些定理，例如 $A \lor \lnot A$。

---

通过这些讨论，我们了解到，在类型理论中，为了更好地表示命题，特别是在处理子集类型时，需要将命题和类型区分开来。这种区分可以通过引入新的判断和规则来实现，使得系统能够更好地表达逻辑推理，同时保持一致性和构造性。

---

### **如果您对上述内容有任何疑问，或者希望深入了解某个主题，请随时告诉我！**

### ---------------------------

### **第七章 增强类型理论 (Augmenting Type Theory)**

#### **7.4 子集类型是必要的吗？(Are Subsets Necessary?)**

---

##### **引言**

在类型理论（Type Theory）中，引入**子集类型**（Subset Type）是否对于构建可用的证明和程序开发系统是必要的？我们在 **第 7.1 节** 开始了对此问题的讨论，发现引入子集类型的主要论点是为了在某种程度上**分离系统的计算和逻辑方面**。这有些讽刺，因为类型理论最吸引人的方面之一就是**命题与类型、证明与程序的统一**。然而，有两个主要原因被用来支持引入子集类型的必要性：

1. **规范和函数由于存在证明理论信息而变得更加复杂。**

2. **许多知名函数的开发（如 **第 6.2 节** 中的快速排序）涉及将证明信息引入函数，与“纯粹的计算”版本相比，这会对函数的计算效率产生不利影响。**

---

##### **第一个论点：规范和函数的复杂性**

**详述：**

- **在 [NPS90] 第 125 页中指出**，类型

  $$
  (\forall x : A).\ (\exists y : B).\ P(x, y)
  $$

  的居住者应该是能够**解决如下问题的函数**：对于每个 $a \in A$，找到一个 $b \in B$，使得 $P(a, b)$ 成立。

- **然而，实际情况并非如此**。对于每个 $a$，我们将得到一个对 $(b, p_b)$，其中：

  - $b$ 是满足 $P(a, b)$ 的元素；
  - $p_b$ 是 $b$ 确实具有所需性质的证明。

- **使用子集类型**，即

  $$
  (\forall x : A).\ \{ y : B \mid P(x, y) \}
  $$

  我们可以获得一个仅提供 $b$ 的函数，而不包含证明信息 $p_b$。

---

##### **第二个论点：计算效率的影响**

**详述：**

- **在开发许多知名函数（如快速排序）时**，需要将证明信息引入函数。

- **这会对函数的计算效率产生不利影响**，因为相比于“纯粹的计算”版本，携带额外的证明信息可能增加计算开销。

---

##### **对第二个论点的反驳：**

- **关于效率的讨论**，如上所述的第二点，取决于**所设想的实现方式**。

- **我们主张**，正如在 **第 7.1.2 节** 中所讨论的，**类型理论的惰性实现**（Lazy Implementation）将只对计算上相关的信息进行求值。

- **因此，计算效率的问题可以通过惰性求值来缓解**，不需要引入子集类型。

---

##### **深入分析第一个论点**

**核心思想：**

- **希望能够从复杂的推导中准确地分离出计算上相关的部分**。

- **为此，提出通过将某些存在类型替换为子集类型**，从而**移除其中的证明信息**。

**我们的替代方案：**

- **我们认为有一个更好的方法，可以避免引入子集类型**，其优点有两点：

  1. **无需对类型理论系统进行任何扩充**。

  2. **允许在证明和计算之间进行更细致的区分**。

**具体方法：**

- **简单地为所需的操作和对象命名**。

- **在上述情况下，我们可以使用选择公理（Axiom of Choice）**，将规范更改为：

  $$
  (\exists f : A \Rightarrow B).\ (\forall x : A).\ P(x, f(x))
  $$

- **解释：**

  - **现在，类型的居住者是对 $(f, p)$**，其中：

    - $f : A \Rightarrow B$ 是所需的函数。

    - $p$ 是 $f$ 具有所需性质的证明。

- **通过为函数 $f$ 赋予一个显式的名称**（在逻辑上下文中称为**Skolem 化量词**），我们得到了一个更自然地表达需求的规范。

- **这种方法也适用于更复杂的规范**。

---

##### **示例：波兰/荷兰国旗问题**

**原始规范：**

- **来自 [NPS90] 的规范形式：**

  $$
  (\forall x : A).\ \{ y : \{ y' : B \mid C(y') \} \mid P(x, y) \}
  $$

  - **含义：** 对于每个 $a \in A$，我们需要找到一个 $b \in B$ 的子集 $\{ y' : B \mid C(y') \}$ 中的元素，使得 $P(a, b)$ 成立。

**使用存在类型替换子集类型：**

- **将子集类型替换为存在类型：**

  $$
  (\forall x : A).\ (\exists y : (\exists y' : B).\ C(y')).\ P(x, y)
  $$

- **逻辑等价转换为：**

  $$
  (\forall x : A).\ (\exists y : B).\ (C(y) \land P(x, y)) \quad \text{(7.6)}
  $$

- **应用选择公理（Axiom of Choice）：**

  $$
  (\exists f : A \Rightarrow B).\ (\forall x : A).\ (C(f(x)) \land P(x, f(x)))
  $$

- **结果：**

  - **得到的类型的居住者是函数 $f$ 及其正确性的证明 $p$**。

- **优点：**

  - **这种规范清晰地表达了原本基于集合的规范中隐含的内容**。

  - **存在类型的形成将数据和证明捆绑在一起**，而转换为 (7.6) 则明确了这种分离过程。

---

##### **另一个示例：依赖于证明的函数**

**问题描述：**

- **对于每个具有性质 $D(a)$ 的 $a \in A$**，我们需要找到一个 $b$，使得 $P(a, b)$ 成立。

**关键问题：**

- **$b$ 是否仅依赖于 $a$**，还是**同时依赖于 $a$ 和证明 $D(a)$ 成立的证明对象**？

---

**情况一：$b$ 依赖于 $a$ 和证明**

- **规范可以写成：**

  $$
  (\forall x : (\exists x' : A).\ D(x')).\ (\exists y : B).\ P(x, y)
  $$

- **Skolem 化量词：**

  $$
  (\exists f : (\exists x' : A).\ D(x') \Rightarrow B).\ (\forall x : (\exists x' : A).\ D(x')).\ P(x, f(x))
  $$

- **使用 Curry 等价（见 **第 4.6.1 节**，第 93 页）：**

  - **将函数类型的定义域中的存在量词替换掉**。

  - **得到：**

    $$
    (\exists f : (\forall z : A).\ (D(z) \Rightarrow B)).\ (\forall x' : A).\ (\forall p : D(x')).\ P((x', p), f(x', p))
    $$

  - **解释：**

    - **这里，函数 $f$ 现在明确地依赖于 $x'$ 和证明 $p$（即 $D(x')$ 的证明）**。

---

**情况二：$b$ 仅依赖于 $a$**

- **如果我们希望所求的对象 $b$ 不依赖于性质 $D$ 的证明，我们可以写出规范：**

  $$
  (\exists f : A \Rightarrow B).\ (\forall x' : A).\ (\forall p : D(x')).\ P((x', p), f(x'))
  $$

- **解释：**

  - **这里，$f(x')$ 在 $B$ 中，不依赖于证明对象 $p : D(x')$**。

- **注意：**

  - **性质 $P$ 仍然依赖于证明 $p$**。

- **如果我们使用子集类型来表达规范，我们会得到：**

  $$
  (\forall x' : \{ x' : A \mid D(x') \}).\ (\exists y : B).\ P_0(x', y)
  $$

  - **其中，$P_0(x', y)$ 关联了 $x' : A$ 和 $y : B$**。

- **这等价于规范：**

  $$
  (\exists f : A \Rightarrow B).\ (\forall x' : A).\ (\forall p : D(x')).\ P_0(x', f(x'))
  $$

  - **其中，$P_0$ 不能涉及证明对象 $p$**。

- **结论：**

  - **通过我们更为明确的方法，我们能够表达规范 (7.7)**。

  - **而在朴素的子集类型下，这种规范是无法表达的**。

---

##### **文献中的示例分析**

**1. 波兰国旗问题**

- **我们已经讨论过，使用子集类型并非必要**。

**2. 解析算法的推导（[Chi87]）**

- **发现子集类型并没有被本质地使用**。

- **解决方案呈现为类型的一个成员：**

  $$
  (\forall w : \text{Word}).\ (\text{Parse } w) \lor \lnot (\text{Parse } w)
  $$

  - **其中，**

    $$
    \text{Parse } w \equiv_{\text{df}} \{ pt : \text{PT} \mid w = \text{spell } pt \}
    $$

    - **$\text{PT}$** 是解析树的代数类型。

    - **$\text{spell}$ 是将解析树 $pt$ 拼写成单词 $w$ 的函数。**

- **在推导中，子集类型并没有在其他地方使用**。

- **此处使用子集类型只是因为 $w = \text{spell } pt$ 的证明对象可以被忽略**，因为它没有计算内容。

- **将集合替换为存在类型不会对推导产生影响：**

  $$
  (\exists pt : \text{PT}).\ (w = \text{spell } pt)
  $$

- **根据 **第 7.1.2 节** 中的讨论，这不会影响最终算法的效率**。

---

**3. 求函数的根**

- **在 [C+86a] 第 2.4 节中，提出了一个规范：**

  $$
  (\forall f : \{ f : \mathbb{N} \Rightarrow \mathbb{N} \mid (\exists n : \mathbb{N}).\ f(n) = 0 \}).\ ((\exists n : \mathbb{N}).\ f(n) = 0 )
  $$

  - **解读为：“给定一个存在根的函数，我们可以找到一个根。”**

- **根据 **定理 7.4**，该类型的对象的存在会导致矛盾**。

- **此外，这个规范似乎忽略了求根问题的重点**。

- **实际中使用的算法通常体现为以下形式的定理：**

  $$
  (\forall f : \mathbb{N} \Rightarrow \mathbb{N}).\ (C(f) \Rightarrow (\exists n : \mathbb{N}).\ f(n) = 0)
  $$

  - **解读为：“如果函数 $f$ 满足条件 $C(f)$，那么我们可以找到一个根。”**

- **许多数论和数值分析中最重要和最困难的定理正是这种类型**，并从中推导出算法。

- **相比之下，上述规范没有说明根存在的证明从何而来**。

---

##### **总结**

**对于计算上无关的信息，有两种处理方法：**

1. **忽略它，利用惰性求值。**

2. **将规范转换为使计算和验证分离的形式。**

   - **我们通过一系列简单的转换实现了这一点。**

   - **通常，只需命名我们要计算的函数，并以该函数为基础编写规范和推导。**

   - **这种方法似乎在不引入子集类型的情况下，实现了逻辑和计算之间适当程度的分离。**

- **我们在文献中没有找到不能用这种方法处理的示例。**

---

**使用子集类型来表示子集会带来问题：**

- **正如我们在前一节所看到的，在一般情况下，我们无法从子集类型中恢复证明信息，特别是在像 $TT$ 这样的内涵系统中。**

- **因此，在这些情况下，应该使用存在类型，保留证明信息。**

---

### **总结**

在本节中，我们深入探讨了**在类型理论中引入子集类型的必要性**。通过分析，我们发现：

- **引入子集类型的两个主要论点：**

  1. **规范和函数的复杂性：** 子集类型可以帮助消除证明信息，使规范和函数更简单。

  2. **计算效率的影响：** 携带证明信息的函数可能比“纯计算”版本效率低。

- **对于第一个论点，我们提出了替代方案：**

  - **通过命名适当的操作和对象，使用选择公理，将规范转换为更自然的形式。**

  - **这种方法无需扩充类型理论系统，并允许更细致地区分证明和计算。**

- **对于第二个论点，我们强调：**

  - **在惰性求值的实现下，计算上无关的信息不会影响效率。**

  - **因此，计算效率的问题可以通过实现策略来解决，而不需要引入子集类型。**

- **通过具体示例（如波兰国旗问题、解析算法、求根问题）验证了我们的观点：**

  - **在这些示例中，使用存在类型和适当的规范转换，可以避免引入子集类型。**

- **结论：**

  - **在类型理论中，引入子集类型并非必要。**

  - **通过适当的规范设计和惰性求值的实现，可以在不增加系统复杂性的情况下，达到预期的目的。**

  - **在一般情况下，使用存在类型保留证明信息，更有助于程序的正确性和完整性。**

---

### **如果您对上述内容有任何疑问，或者希望深入了解某个主题，请随时告诉我！**

### ----------------------------

### **第七章 增强类型理论 (Augmenting Type Theory)**

#### **7.5 商类型或同余类型 (Quotient or Congruence Types)**

---

##### **引言**

在编程和数学中，**定义对象类上的等价关系**是一个重要的工具。例如：

- **在数学中**，我们可能规定**两个只在绑定变量上不同的表达式被视为相同**。这在λ演算中很常见，其中α等价的表达式被视为相同。
  
- **在编程中**，我们可能选择用有限列表来表示有限集合，**将那些具有相同元素的列表视为相等**，而不考虑元素的重复次数或顺序。

在这些情况下，我们都通过对一个类型按等价关系取**商**（quotient）来定义一个新类型。**等价关系**是一个**自反、对称和传递**的关系。

---

##### **商类型的定义**

商类型（Quotient Type）是类型理论中的一种类型构造，它允许我们**在类型上施加一个等价关系**，从而形成一个新的类型，其中等价的元素被视为相等。

**在Nuprl系统**（[C+86a]）中，这些类型是其组成部分。在 [BCMS89] 的类型理论中，也出现了它们的一个变体，称为**同余类型**（Congruence Types）。

---

##### **商类型的形式规则**

我们先介绍适用于类型理论 $TT$ 的商类型规则，然后将其与同余类型进行比较。

由于以下规则中有许多假设，我们将它们**垂直列出**。

---

###### **商类型的形成规则 (Formation Rule for A // E<sub>x,y</sub>)**

$$
\frac{
  \begin{array}{l}
    A\ \text{是一个类型} \\
    x : A,\ y : A\ \vdash\ E\ \text{是一个类型} \\
    x : A\ \vdash\ r : E[x/x,\ x/y] \\
    x : A,\ y : A,\ r : E\ \vdash\ s : E[y/x,\ x/y] \\
    x : A,\ y : A,\ z : A,\ r : E,\ s : E[y/x,\ z/y]\ \vdash\ t : E[x/x,\ z/y]
  \end{array}
}{
  A // E_{x,y}\ \text{是一个类型}
} \quad \text{(QF)}
$$

- **解释：**

  - **第一行：** $A$ 是一个类型。

  - **第二行：** 在假设 $x : A$ 和 $y : A$ 下，$E$ 是一个类型。

  - **第三行：** 在假设 $x : A$ 下，$r : E[x/x,\ x/y]$，即 $E$ 在 $x$ 和 $y$ 都替换为 $x$ 时的证明对象 $r$。

  - **第四行：** 在假设 $x : A,\ y : A,\ r : E$ 下，$s : E[y/x,\ x/y]$，即 $E$ 在 $x$ 替换为 $y$，$y$ 替换为 $x$ 时的证明对象 $s$。

  - **第五行：** 在假设 $x : A,\ y : A,\ z : A,\ r : E,\ s : E[y/x,\ z/y]$ 下，$t : E[x/x,\ z/y]$，即 $E$ 在 $x$ 替换为 $x$，$y$ 替换为 $z$ 时的证明对象 $t$。

- **这些假设的目的：**

  - **验证 $E$ 是一个等价关系**，即验证**自反性、对称性和传递性**。

    - **自反性：** $r : E[x/x,\ x/y]$

    - **对称性：** $s : E[y/x,\ x/y]$

    - **传递性：** $t : E[x/x,\ z/y]$

- **注意：**

  - 在规则中，我们使用了假设判断，例如：

    $$
    [x : A,\ y : A] \quad \vdots \quad E\ \text{是一个类型}
    $$

    在此，我们将其写成横向形式：

    $$
    x : A,\ y : A\ \vdash\ E\ \text{是一个类型}
    $$

  - 在每种情况下，位于 $\vdash$ 左侧的假设在应用规则时被解除。

- **关于 $x$ 和 $y$ 的说明：**

  - 我们使用下标 $x, y$ 表示它们是自由变量，在类型构造中被绑定。

  - 当没有混淆的可能时，可以省略这些下标。

---

###### **商类型的引入规则 (Introduction Rule for A // E<sub>x,y</sub>)**

$$
\frac{
  a : A
}{
  a : A // E_{x,y}
} \quad \text{(QI)}
$$

- **解释：**

  - 任何 $A$ 中的元素 $a$ 都可以被引入到商类型 $A // E_{x,y}$ 中。

- **注意：**

  - **这打破了类型的唯一性**，因为 $a$ 现在既属于 $A$，也属于 $A // E_{x,y}$。

  - 为了避免混淆，可以通过某种方式“标记”变量，以指示它们属于哪个类型。

---

###### **商类型的消解规则 (Elimination Rule for A // E<sub>x,y</sub>)**

**动机：**

- **定义一个商类型上的函数时，需要确保对等价元素的值相等**，否则函数将不良定义，因为选择同一等价类的不同代表可能会导致不同的值。

- **因此，消解规则必须反映这一点**。

---

**规则描述：**

$$
\frac{
  a : A // E_{x,y} \quad
  [x : A] \quad \vdots \quad c(x) : C(x) \quad
  [x : A,\ y : A,\ p : E] \quad \vdots \quad t : I(C(x),\ c(x),\ c(y))
}{
  c(a) : C(a)
} \quad \text{(QE)}
$$

- **解释：**

  - **第一行：** 我们有 $a : A // E_{x,y}$。

  - **第二行：**

    - **假设 1：** $x : A$，我们构造 $c(x) : C(x)$。

    - **假设 2：** $x : A,\ y : A,\ p : E$，我们需要证明 $t : I(C(x),\ c(x),\ c(y))$。

      - **这里，$I(C(x),\ c(x),\ c(y))$** 表示 $c(x)$ 和 $c(y)$ 在类型 $C(x)$ 中相等。

  - **结论：** $c(a) : C(a)$。

- **这个规则确保了函数 $c$ 对等价元素给出相同的值**，即如果 $x \sim y$（即 $p : E$），那么 $c(x) = c(y)$。

---

###### **商类型的等式规则 (Equality Rule for A // E<sub>x,y</sub>)**

$$
\frac{
  a : A \quad b : A \quad p : E[a/x,\ b/y]
}{
  r(a) : I(A // E_{x,y},\ a,\ b)
} \quad \text{(Q=)}
$$

- **解释：**

  - 如果 $a : A$ 和 $b : A$，并且 $p : E[a/x,\ b/y]$（即 $a$ 和 $b$ 在 $E$ 下等价），那么我们有：

    - $r(a) : I(A // E_{x,y},\ a,\ b)$，即在商类型 $A // E_{x,y}$ 中，$a$ 和 $b$ 相等。

- **效果：**

  - **允许在涉及商类型 $A // E_{x,y}$ 的任何上下文中，将等价元素互相替换**。

  - **因此，通过此规则，我们在类型 $A // E_{x,y}$ 上定义了新的等式**。

- **注意：**

  - **并未断言 $I(A,\ a,\ b)$ 是可居住的**，因此我们不能在任何上下文中将 $b$ 替换为 $a$。

  - **替换仅限于那些可以安全执行替换的上下文**。

---

##### **商类型的使用**

**如果认为 $a$ 同时具有类型 $A$ 和 $A // E_{x,y}$ 令人困惑**，我们可以引入一个标签，以表明 $a$ 何时被视为商类型的元素。

- **一般来说，除非每个等价类都包含一个“规范的”成员，否则无法进行这种操作的逆过程**。

  - **例如：**

    - 对于关系 $|x - y| \mod k = 0$ 的等价类，其代表为 $0, 1, \dots, k - 1$。

---

##### **商类型的示例**

###### **示例 1：有理数**

- **表示：**

  - 有理数可以表示为**整数对 $(n, m)$**，其中 $n$ 是整数，$m$ 是正整数。

- **等价关系：**

  - **两个对 $(n, m)$ 和 $(n', m')$ 等价当且仅当：**

    $$
    n \times m' = n' \times m
    $$

- **加法定义：**

  - **两个有理数 $n / m$ 和 $p / q$ 的和定义为：**

    $$
    \frac{n \times q + p \times m}{m \times q}
    $$

- **验证加法的良定义：**

  - **需要验证加法定义尊重等价关系，即如果 $(n, m) \sim (n', m')$ 且 $(p, q) \sim (p', q')$，则：**

    $$
    \frac{n \times q + p \times m}{m \times q} \sim \frac{n' \times q' + p' \times m'}{m' \times q'}
    $$

- **练习：**

  - **读者可以验证加法确实尊重等价关系。**

- **“小于”关系的定义：**

  - **定义类似于第 6.1.2 节中 $\text{lt2}$ 在 $\mathbb{N}$ 上的定义：**

    $$
    (n, m) \prec (n', m') \quad \equiv_{\text{df}} \quad n \times m' < n' \times m
    $$

  - **需要验证该谓词是良定义的，即如果 $(n, m) \sim (n'', m'')$ 且 $(n', m') \sim (n''', m''')$，则 $(n, m) \prec (n', m')$ 当且仅当 $(n'', m'') \prec (n''', m''')$。**

- **注意：**

  - **在 Nuprl 系统的开发中（[C+86a], 第 210 页），由于采用了比这里更强的类型等式，这一性质并不成立。**

---

###### **示例 2：分母函数的定义**

- **直接定义失败：**

  - **尝试定义：**

    $$
    \text{denom}(n, m) \equiv_{\text{df}} m
    $$

  - **这个定义不良，因为它没有尊重等价关系。**

    - **例如，$(1, 2) \sim (2, 4)$，但 $\text{denom}(1, 2) = 2 \neq 4 = \text{denom}(2, 4)$。**

- **正确的定义：**

  - **基于有理数的规范代表 $(n \div g, m \div g)$，其中 $g = \gcd(n, m)$。**

  - **定义：**

    $$
    \text{denom}(n, m) \equiv_{\text{df}} \frac{m}{\gcd(n, m)}
    $$

  - **这样，等价的有理数具有相同的规范代表，分母函数也就良定义了。**

---

###### **示例 3：外延等式**

- **在第 5.8 节中，我们讨论了“'”作为一个**部分等价关系**。

  - **因为它不是一般的自反的，只有在那些自身是外延的函数上才是自反的。**

- **在消解规则中的替换检查意味着我们只在所谓的**外延命题**中进行替换。

- **我们的优势在于我们对命题的外延性有一个**句法标准**，无需每次都检查条件。

---

##### **商类型的优势**

**与直接定义等价关系并显式使用它相比，商类型有什么优势？**

- **主要优势是将替换等规则应用于等价关系**。

  - **当进行替换的公式对等价类的代表不敏感时，这种替换是安全的。**

- **通过商类型，我们可以在类型上定义新的等式，使得在涉及该类型的上下文中，可以将等价元素互相替换**。

---

##### **案例研究：实数**

- **我们将在 **第 7.6 节** 中将实数作为进一步的案例研究。

---

#### **7.5.1 同余类型 (Congruence Types)**

---

##### **引言**

- **在 [BCMS89] 的论文中，提出了一种类似的构造，称为**同余类型构造（Congruence Type Construction）。

- **当引入一个（自由）代数类型时，如有限列表类型，我们引入构造子 $[\ ]$ 和 $::$**。

  - **由这些构造子构建的对象是不同的，除非它们是相同的。**

- **如果我们想表示有限集（袋子，bag），我们可能选择有限列表作为表示，但我们需要将包含相同元素的不同顺序的列表视为相同**。

  - **这是一种等价关系，我们可以像之前那样写下等价关系并形成商类型。**

---

##### **同余类型的方法**

- **同余类型的方法略有不同，我们可以简单地声明如下的等式应该成立：**

  $$
  a \bullet b \bullet x = b \bullet a \bullet x \quad \text{(7.8)}
  $$

  - **其中，$\bullet$ 是此类型的（中缀）列表构造子。**

- **要求 (7.8) 比显式给出由该等式生成的等价关系要简单得多**。

  - **在消解规则中，要求尊重这样的等式的性质也更容易表达。**

- **除此之外，这些代数类型的规则与商类型的规则完全相同。**

---

##### **商类型与同余类型的比较**

- **我们能否通过这种方法表达一般的商类型 $A // E_{x,y}$？**

  - **确实可以，通过引入一个**平凡的构造子**，如 $?$。

- **形成规则：**

  $$
  \frac{
    A\ \text{是一个类型}
  }{
    \text{StarE}\ A\ \text{是一个类型}
  }
  $$

- **引入规则：**

  $$
  \frac{
    a : A
  }{
    ?\ a : \text{StarE}\ A
  }
  $$

- **消解规则：**

  $$
  \frac{
    s : \text{StarE}\ A \quad
    [a : A]\ \vdots\ c(a) : C(?\ a) \quad
    [x : A,\ y : A,\ p : E]\ \vdots\ t : I(C(?\ x),\ c(x),\ c(y))
  }{
    ?\text{-elim}_x(c,\ s) : C(s)
  }
  $$

- **计算规则：**

  $$
  ?\text{-elim}_x(c,\ ?\ a) \rightarrow c(a)
  $$

- **解释：**

  - **我们用一个一般的要求替换了等式，即消解引入的公式尊重关系 $E$。**

  - **这种方法的一个优势是元素被“标记”了构造子 $?$**，因此我们可以区分对象 $a : A$ 和其在同余类型中的等价类 $?\ a$。

---

##### **同余类型的示例**

- **二进制数的类型作为同余类型的实现，出现在 [BCMS89] 的第 5 节。**

---

##### **与编程语言的类比**

- **这种方法类似于早期 Miranda 语言版本中的**“定律”（laws）的概念。

  - **在通过构造子引入代数类型时，允许用户写下**重写规则**，这些规则将应用于该类型的任何表达式。

- **例如，要实现有序列表的类型，可以编写：**

  $$
  \text{Ocons}\ a\ (\text{Ocons}\ b\ x) \Rightarrow \text{Ocons}\ b\ (\text{Ocons}\ a\ x),\ \text{如果}\ a > b
  $$

  - **这会交换任何顺序错误的元素对。**

- **这种方法的限制：**

  - **等价可以写入的语言更简单。**

  - **每个规则必须是有方向的，重写只能在一个方向上进行。**

- **更多关于类型和可用于推理的技术的细节，可以在 [Tho86, Tho90] 中找到。**

---

##### **子集类型与同余类型的结合**

- **作为本次讨论的结尾，我们应该提到 [Chi88b]，其中显示了子集类型可以与同余类型一起使用，从而减少在检查消解规则的条件时产生的证明负担。**

- **作者展示了在使用和不使用子集类型的情况下，有限集合类型上的基数函数的推导之间的差异。**

- **选择的示例是等价关系下的等价类没有规范成员的情况，在这种情况下，这种优势最为明显。**

---

#### **练习**

---

**7.16.** 完成关于 $+$ 和 $\prec$ 在有理数上是良定义的论证。

**解答提示：**

- **验证加法 $+$ 的良定义：**

  - **需要证明如果 $(n, m) \sim (n', m')$ 且 $(p, q) \sim (p', q')$，则：**

    $$
    \frac{n \times q + p \times m}{m \times q} \sim \frac{n' \times q' + p' \times m'}{m' \times q'}
    $$

- **验证“小于”关系 $\prec$ 的良定义：**

  - **需要证明如果 $(n, m) \sim (n', m')$ 且 $(p, q) \sim (p', q')$，则 $(n, m) \prec (p, q)$ 当且仅当 $(n', m') \prec (p', q')$。**

---

**7.17.** 你将如何定义有理数上的除法函数？

**解答提示：**

- **定义除法 $\div$ 函数，使得对于非零有理数 $(p, q)$，有：**

  $$
  \frac{n}{m} \div \frac{p}{q} = \frac{n \times q}{m \times p}
  $$

  - **需要注意定义在 $p \neq 0$ 的情况下成立。**

- **验证该定义尊重等价关系。**

---

**7.18.** 给出由等式 (7.8) 生成的等价关系的显式定义。

**解答提示：**

- **等式 (7.8)：**

  $$
  a \bullet b \bullet x = b \bullet a \bullet x
  $$

- **等价关系的生成：**

  - **两个列表等价当且仅当它们可以通过有限次交换相邻元素 $a \bullet b \rightarrow b \bullet a$ 转换得到。**

- **这实际上定义了列表元素的排列（置换）生成的等价关系，即列表具有相同的元素，可能顺序不同。**

---

### **总结**

在本节中，我们深入探讨了**商类型**和**同余类型**在类型理论中的引入和应用，主要包括以下内容：

1. **商类型的定义和规则：**

   - **商类型允许我们在类型上施加等价关系，形成新的类型，其中等价的元素被视为相等。**

   - **形式规则包括形成规则、引入规则、消解规则和等式规则。**

   - **消解规则确保在定义商类型上的函数时，对等价元素给出相同的值。**

2. **商类型的示例：**

   - **有理数可以表示为整数对的商类型，定义了等价关系和运算，如加法和小于关系。**

   - **讨论了如何正确地定义函数，使其尊重等价关系，例如分母函数需要考虑规范代表。**

3. **同余类型：**

   - **同余类型提供了一种类似商类型的构造，但通过指定应该成立的等式来引入类型。**

   - **这种方法在表达复杂的等价关系时更为简洁，特别是在代数类型（如列表）的情况下。**

   - **示例包括实现二进制数类型，以及与编程语言（如早期的 Miranda 语言）中的重写规则的类比。**

4. **商类型与同余类型的比较：**

   - **两者都允许在类型上引入等价关系，但方法不同。**

   - **商类型更一般，需要验证等价关系的自反、对称和传递性。**

   - **同余类型通过指定应该成立的等式，更直接地表达了等价关系。**

5. **子集类型的结合：**

   - **子集类型可以与同余类型结合使用，减少证明负担，特别是在等价类没有规范成员的情况下。**

---

通过这些讨论，我们了解到在类型理论中，**商类型和同余类型为我们提供了强大的工具来处理等价关系**，从而在编程和数学中更灵活地表示和操作对象。这对于定义复杂的数据类型、实现抽象数据类型以及确保函数的良定义性至关重要。

---

### **如果您对上述内容有任何疑问，或者希望深入了解某个主题，请随时告诉我！**

### ---------------------------

### **第七章 增强类型理论 (Augmenting Type Theory)**

---

#### **7.6 案例研究——实数 (Case Study – The Real Numbers)**

---

##### **概览**

在本节中，我们将深入探讨**实数**在**经典数学**和**构造性数学**中的处理方式的差异。这种差异在实数和实分析的处理中表现得尤为明显。经典数学家通常将实数视为有理数的收敛（或柯西）序列的等价类，并在需要时选择等价类的任意代表。而构造性数学强调计算的可行性，要求构造性的定义和证明。我们将讨论如何在构造性设置下定义实数，以及如何定义实数之间的运算和等价关系。最后，我们将探讨在类型理论中处理实数的不同方法，包括使用子集类型和显式的存在类型。

---

##### **经典数学与构造性数学中的实数**

**经典数学中的实数处理：**

- **实数被视为有理数的收敛序列的等价类。**
  
  - 经典数学家接受使用等价类的任意代表。

- **非构造性原则的使用：**

  - 例如，**每个有理数的递增序列都有最小上界**。

  - 这涉及到**排中律**（Law of Excluded Middle）的使用。

- **对计算的关注主要在数值分析中**，而数值分析只能以非常间接的方式使用经典分析的结果。

**构造性数学中的实数处理：**

- **强调计算的可行性和证明的构造性**。

- **实数被定义为有理数的收敛序列**，并且需要提供关于序列收敛性的证明。

- **需要避免使用非构造性的原则，如排中律**。

---

##### **在构造性设置下定义实数**

**定义实数类型 $\text{RealC}$：**

- **设有理数的集合记为 $\mathbb{Q}$**。

- **实数被定义为有理数的收敛序列**。

- **具体定义：**

  $$
  \text{RealC} \equiv_{\text{df}} (\exists s : \mathbb{N} \rightarrow \mathbb{Q}).\ (\exists m : \mathbb{Q} \rightarrow \mathbb{N}).\ (\forall q : \mathbb{Q}).\ (\forall n : \mathbb{N}).\ (q > 0 \land n > m(q) \Rightarrow |s_n - s_{m(q)}| < q)
  $$

  - **解释：**

    - $s : \mathbb{N} \rightarrow \mathbb{Q}$ 是一个有理数序列。

    - $m : \mathbb{Q} \rightarrow \mathbb{N}$ 是 $s$ 的**连续性模量**（modulus of continuity）。

    - 对于任意正有理数 $q$ 和自然数 $n$，如果 $n > m(q)$，则序列的项 $s_n$ 与 $s_{m(q)}$ 之差的绝对值小于 $q$。

- **换言之，序列 $s$ 在 $n$ 足够大时收敛到某个极限值**。

**类型 $\text{RealC}$ 的元素形式：**

- 元组 $(s, (m, p))$，其中：

  - $s$ 是有理数序列 $s : \mathbb{N} \rightarrow \mathbb{Q}$。

  - $m$ 是连续性模量 $m : \mathbb{Q} \rightarrow \mathbb{N}$。

  - $p$ 是一个证明，证明 $s$ 满足上述收敛条件，即 $p$ 属于：

    $$
    (\forall q : \mathbb{Q}).\ (\forall n : \mathbb{N}).\ (q > 0 \land n > m(q) \Rightarrow |s_n - s_{m(q)}| < q)
    $$

- **注意：**

  - 在计算实数时，$p$（证明信息）在计算上是无关的，但仍然需要处理。

  - **当我们定义新的实数（即新的序列及其连续性模量）时，我们必须证明该连续性模量确实是有效的。**

---

##### **更简化的方法：使用固定的连续性模量**

**采用 [BB85] 等地方的方法：**

- **考虑具有固定连续性模量的序列，称为**“**正规序列**”（regular sequences）。

- **定义实数类型 $\text{Real}$：**

  $$
  \text{Real} \equiv_{\text{df}} (\exists s : \text{Seq}).\ \text{Reg}(s)
  $$

  - **其中，**

    - $\text{Seq} \equiv_{\text{df}} (\mathbb{N} \rightarrow \mathbb{Q})$，即有理数序列。

    - $\text{Reg}(s) \equiv_{\text{df}} (\forall m, n : \mathbb{N}).\ (|s_n - s_m| < \frac{1}{m + 1} + \frac{1}{n + 1})$。

- **类型 $\text{Real}$ 的元素形式：**

  - 对 $(s, p)$ 的对，其中：

    - $s$ 是序列 $s : \mathbb{N} \rightarrow \mathbb{Q}$。

    - $p$ 是证明 $s$ 是**正规序列**的证明。

- **优势：**

  - **固定了连续性模量，简化了定义和证明。**

  - **证明信息 $p$ 在计算上是无关的，但需要存在。**

---

##### **定义实数的加法**

**给定两个实数 $(s, p)$ 和 $(t, q)$**，我们希望定义它们的和。

**定义和序列 $x_n$：**

- **为了定义 $s$ 和 $t$ 的和，我们定义序列 $x_n$ 为：**

  $$
  x_n \equiv_{\text{df}} s_{2n+1} + t_{2n+1}
  $$

- **解释：**

  - 通过取序列 $s$ 和 $t$ 的奇数项（$2n + 1$），定义新的序列 $x_n$。

**证明序列 $x_n$ 是正规序列：**

- **需要证明 $x_n$ 满足正规序列的条件，即对于任意 $m, n \in \mathbb{N}$，有：**

  $$
  |x_n - x_m| < \frac{1}{m + 1} + \frac{1}{n + 1}
  $$

- **推导：**

  1. **计算 $|x_n - x_m|$：**

     $$
     |x_n - x_m| = |s_{2n+1} + t_{2n+1} - s_{2m+1} - t_{2m+1}| = |s_{2n+1} - s_{2m+1}| + |t_{2n+1} - t_{2m+1}|
     $$

     - 使用三角不等式。

  2. **利用 $s$ 和 $t$ 的正规性：**

     - 由于 $s$ 是正规序列，有：

       $$
       |s_{2n+1} - s_{2m+1}| < \frac{1}{2n + 1 + 1} + \frac{1}{2m + 1 + 1}
       $$

     - 同理，$t$ 也满足类似的不等式。

  3. **合并不等式：**

     $$
     |x_n - x_m| < \left( \frac{1}{2n + 2} + \frac{1}{2m + 2} \right) + \left( \frac{1}{2n + 2} + \frac{1}{2m + 2} \right) = \frac{1}{n + 1} + \frac{1}{m + 1}
     $$

- **结论：**

  - **序列 $x_n$ 满足正规序列的条件**。

- **因此，我们可以构造证明对象 $v$，证明 $x$ 是正规序列，得到实数 $(x, v)$。**

---

##### **定义加法函数**

- **基于上述推导，我们可以定义一个函数 \(\text{add0}\)：**

  $$
  \text{add0} : \text{Real} \rightarrow \text{Real} \rightarrow \text{Real}
  $$

- **注意：**

  - **这个定义混合了计算上相关和无关的部分**。

  - **我们既定义了序列的加法运算，也涉及了证明 $x$ 是正规序列的证明 $v$。**

---

##### **使用存在类型定义加法**

- **按照 Bishop 的方法，我们可以定义一个函数 \(\text{add}\)，类型为：**

  $$
  (\exists f : \text{Seq} \rightarrow \text{Seq} \rightarrow \text{Seq}).\ (\forall s, t : \text{Seq}).\ (\text{Reg}(s) \land \text{Reg}(t) \Rightarrow \text{Reg}(f\ s\ t))
  $$

  - **其中：**

    - **$f$ 是一个序列函数 $f : \text{Seq} \rightarrow \text{Seq} \rightarrow \text{Seq}$**。

    - **对于任意正规序列 $s$ 和 $t$，$f\ s\ t$ 也是正规序列。**

- **我们将之前定义的序列加法函数记为 $\text{addS}$**。

- **这种方法：**

  - **遵循我们早先的策略，通过适当地命名函数，而不是使用子集类型。**

  - **使得计算操作（序列的加法）和证明（序列的正规性）分离。**

---

##### **使用子集类型定义实数**

- **其他方法，如 [C+86b] 的第 11.5 节，定义实数为：**

  $$
  \text{RealSet} \equiv_{\text{df}} \{ s : \text{Seq} \mid \text{Reg}(s) \}
  $$

  - **这里使用了子集类型，将实数定义为所有正规序列的集合。**

- **比较：**

  - **在这种情况下，我们的方法（使用存在类型并显式地分离证明信息）似乎更合适。**

  - **因为它明确了证明，同时将它们与序列上的计算操作分开。**

---

##### **实数的等价关系**

- **实数类型 $\text{Real}$ 中的每个数都有无限多个代表。**

- **例如，零可以由以下序列表示：**

  1. **常数零序列 $s_n = 0$**。

  2. **序列 $z_n \equiv_{\text{df}} \frac{1}{k + 2n + 3}$，对于每个自然数 $k$**。

- **定义实数之间的等价关系 $\text{Eq}(s, t)$：**

  $$
  \text{Eq}(s, t) \equiv_{\text{df}} (\forall n : \mathbb{N}).\ (|s_n - t_n| < \frac{1}{2n + 1})
  $$

  - **解释：**

    - 如果两个序列 $s$ 和 $t$ 的对应项之差的绝对值在 $n$ 趋于无穷时趋于零，则认为它们表示相同的实数。

- **注意：**

  - **这个定义只依赖于序列 $s$ 和 $t$，而不依赖于证明信息 $p$ 和 $q$。**

- **验证：**

  - **可以证明上述等价关系是 $\text{Real}$ 上的等价关系。**

  - **零的所有代表序列都彼此等价。**

- **加法运算尊重等价关系：**

  - **即，如果 $\text{Eq}(s, s')$ 且 $\text{Eq}(t, t')$，则有：**

    $$
    \text{Eq}(\text{addS}\ s\ t,\ \text{addS}\ s'\ t')
    $$

---

##### **构造实数的商类型**

- **由于 $\text{Eq}$ 是 $\text{Real}$ 上的等价关系，我们可以考虑商类型：**

  $$
  \text{Real}_q \equiv_{\text{df}} \text{Real} // \text{Eq}_{s, t}
  $$

- **加法可以定义为：**

  $$
  \text{add}_q : \text{Real}_q \rightarrow \text{Real}_q \rightarrow \text{Real}_q
  $$

- **解释：**

  - **在商类型 $\text{Real}_q$ 上定义加法，即在等价类上进行操作。**

---

##### **选择实数的特定代表序列**

- **在许多应用中，我们需要为实数选择一个特定的代表序列。**

- **经典示例：**

  - **给定一个实数 $r$ 和一个正有理数 $x$，需要找到一个与 $r$ 相距小于 $x$ 的有理数。**

- **问题：**

  - **给定一个特定的代表序列，这很容易实现，但所选的有理数取决于具体的序列。不同的序列会给出不同的近似。**

- **结论：**

  - **对于实数的一般处理，我们需要使用类型 $\text{Real}$，而不是商类型 $\text{Real}_q$。**

  - **正如 [C+86b] 中所提到的，商类型 $\text{Real}_q$ 可以作为替换的有用框架，但不足以处理所有情况。**

---

##### **构造性方法与经典方法的差异**

- **我们的构造性方法侧重于有理数的收敛序列，与经典方法有很大不同。**

- **当我们计算“实数”时，我们确实在处理收敛的有理数序列。**

- **只有在经典数学的理想化框架中，我们才能处理无限序列的等价类等无限对象。**

- **进一步的材料：**

  - **建议读者参考 [C+86b]，该文进一步发展了理论。**

  - **还可以参考 [BB85]，该文以严格但非正式的方式重新发展了经典分析的许多内容。**

---

##### **练习**

**7.19.** 证明上述定义的等价关系是一个等价关系，并给出尊重该关系的减法、绝对值和乘法的定义。

**解答：**

- **证明等价关系的性质：**

  - **自反性：** 对于任意序列 $s$，有：

    $$
    |s_n - s_n| = 0 < \frac{1}{2n + 1}
    $$

    因此，$\text{Eq}(s, s)$ 成立。

  - **对称性：** 如果 $\text{Eq}(s, t)$，则对于任意 $n$：

    $$
    |s_n - t_n| < \frac{1}{2n + 1}
    $$

    因此，$|t_n - s_n| = |s_n - t_n| < \frac{1}{2n + 1}$，所以 $\text{Eq}(t, s)$ 成立。

  - **传递性：** 如果 $\text{Eq}(s, t)$ 且 $\text{Eq}(t, u)$，则对于任意 $n$：

    $$
    |s_n - u_n| \leq |s_n - t_n| + |t_n - u_n| < \frac{1}{2n + 1} + \frac{1}{2n + 1} = \frac{2}{2n + 1}
    $$

    由于 $\frac{2}{2n + 1} < \frac{1}{n}$，当 $n$ 足够大时，$|s_n - u_n|$ 趋于零。因此，$\text{Eq}(s, u)$ 成立。

- **定义尊重等价关系的运算：**

  - **减法：**

    - **定义序列减法：**

      $$
      (\text{subS}\ s\ t)_n = s_n - t_n
      $$

    - **证明：**

      - **需要证明如果 $\text{Eq}(s, s')$ 和 $\text{Eq}(t, t')$，则 $\text{Eq}(\text{subS}\ s\ t,\ \text{subS}\ s'\ t')$。**

      - **计算 $|(s_n - t_n) - (s'_n - t'_n)| = |(s_n - s'_n) - (t_n - t'_n)| \leq |s_n - s'_n| + |t_n - t'_n|$。**

      - **由于 $|s_n - s'_n| < \frac{1}{2n + 1}$，$|t_n - t'_n| < \frac{1}{2n + 1}$，所以总和小于 $\frac{2}{2n + 1}$。因此，$\text{Eq}(\text{subS}\ s\ t,\ \text{subS}\ s'\ t')$ 成立。**

  - **绝对值：**

    - **定义序列绝对值：**

      $$
      (\text{absS}\ s)_n = |s_n|
      $$

    - **证明类似，可以验证等价关系被尊重。**

  - **乘法：**

    - **定义序列乘法需要更谨慎，因为乘积可能会引入不良行为。**

    - **可以定义：**

      $$
      (\text{mulS}\ s\ t)_n = s_n \times t_n
      $$

    - **需要证明如果 $\text{Eq}(s, s')$ 和 $\text{Eq}(t, t')$，则 $\text{Eq}(\text{mulS}\ s\ t,\ \text{mulS}\ s'\ t')$。**

    - **这需要利用序列的收敛性和有界性来控制误差。**

---

**7.20.** 你将如何定义柯西实数类型 $\text{RealC}$ 上的等价关系和算术运算？在定义这些内容时，你将如何将计算部分与证明理论部分分离？

**解答：**

- **定义等价关系：**

  - **对于 $\text{RealC}$ 中的两个元素 $(s, (m_s, p_s))$ 和 $(t, (m_t, p_t))$，定义等价关系 $\text{EqC}(s, t)$ 为：**

    $$
    (\forall q > 0).\ (\exists N \in \mathbb{N}).\ (\forall n > N).\ |s_n - t_n| < q
    $$

  - **这表示 $s$ 和 $t$ 在极限意义上相等。**

- **定义算术运算：**

  - **加法、减法、乘法等可以类似地定义在序列上，如：**

    $$
    (\text{addC}\ s\ t)_n = s_n + t_n
    $$

  - **需要证明结果序列满足柯西序列的条件，并给出新的连续性模量 $m_{s+t}$ 及其证明 $p_{s+t}$。**

- **分离计算和证明：**

  - **将计算部分（序列的操作）和证明部分（连续性模量及其证明）分开处理。**

  - **使用存在类型，明确地表示函数和其满足的性质。**

---

**7.21.** 给出实数序列收敛的定义，以及函数的连续性的定义，并使用这些定义证明定理 3.2，即构造性的中值定理。

**解答：**

- **序列收敛的定义：**

  - **一个实数序列 $\{ r_n \}$ 收敛于实数 $r$，如果：**

    $$
    (\forall \epsilon > 0).\ (\exists N \in \mathbb{N}).\ (\forall n > N).\ |r_n - r| < \epsilon
    $$

- **函数连续性的定义：**

  - **函数 $f : \text{Real} \rightarrow \text{Real}$ 在点 $c$ 处连续，如果：**

    $$
    (\forall \epsilon > 0).\ (\exists \delta > 0).\ (\forall x \in \text{Real}).\ (|x - c| < \delta \Rightarrow |f(x) - f(c)| < \epsilon)
    $$

- **证明构造性的中值定理（定理 3.2）：**

  - **假设 $f$ 在区间 $[a, b]$ 上连续，且 $f(a) < 0$，$f(b) > 0$。**

  - **需要构造一个 $c \in [a, b]$，使得 $f(c) = 0$。**

  - **构造性证明需要给出具体的构造方法，例如使用二分法，逐步逼近零点。**

  - **每一步都需要提供逼近的误差估计和相应的证明。**

---

##### **总结**

在本节中，我们深入探讨了**构造性数学**中**实数的定义和处理**，以及与**经典数学**方法的差异。主要内容包括：

- **构造性定义实数：**

  - 使用有理数的收敛序列，并提供关于序列收敛性的证明。

  - 引入了正规序列和固定连续性模量的概念，简化了定义。

- **实数运算的定义：**

  - 详细讨论了如何定义实数的加法，以及证明结果序列的正规性。

  - 强调了计算部分（序列操作）和证明部分（序列正规性的证明）的分离。

- **实数的等价关系：**

  - 定义了实数序列之间的等价关系，基于序列项之间的误差趋于零。

  - 讨论了商类型 $\text{Real}_q$ 的构造，以及在等价类上定义运算的问题。

- **构造性方法的优势：**

  - 在构造性设置下，实数的定义和运算更加具体，可用于实际计算。

  - 经典方法处理无限序列的等价类，难以直接应用于计算。

- **建议阅读：**

  - 推荐读者参考 [C+86b] 和 [BB85]，以获得更多关于构造性实分析的详细信息。

---

通过本节的学习，我们理解了如何在类型理论中以构造性的方式定义实数，以及如何处理实数之间的运算和等价关系。这对于在形式化证明系统中处理实数，以及在计算机上实现实数的精确计算具有重要意义。

---

### **如果您对上述内容有任何疑问，或者希望深入了解某个主题，请随时告诉我！**

### ----------------------------

### **第七章 增强类型理论 (Augmenting Type Theory)**

---

#### **7.7 加强的规则与多态性 (Strengthened Rules; Polymorphism)**

---

##### **概览**

在类型理论的实践中，研究者们发现了一些证明步骤，虽然必要，但看起来不够直观。这促使了对类型理论规则的重新审视。本节将通过一个具体的例子，探讨如何加强类型理论的消解规则，以使证明过程更加简洁和直观。

我们将介绍 Dyckhoff 的**强消解规则**和 Backhouse 的**假设性假设**（hypothetical hypotheses）。随后，我们讨论 [MC88] 中定义的多态类型 $A \Rightarrow B$，这种类型可以看作是对本节中引入的其他规则的概括。

---

##### **7.7.1 一个示例**

在 [Dyc87] 中，提出了以下命题的证明：

$$
(\exists z : A \lor B).\ P(z) \Rightarrow \left( (\exists x : A).\ P(\text{inl}\ x) \lor (\exists y : B).\ P(\text{inr}\ y) \right) \quad (7.9)
$$

**目标：**

- 证明：如果存在 $z : A \lor B$ 且 $P(z)$ 成立，那么要么存在 $x : A$ 使得 $P(\text{inl}\ x)$ 成立，要么存在 $y : B$ 使得 $P(\text{inr}\ y)$ 成立。

**证明过程：**

1. **假设：**

   - $p : (\exists z : A \lor B).\ P(z)$

2. **目标：**

   - 证明：

     $$
     (\exists x : A).\ P(\text{inl}\ x) \lor (\exists y : B).\ P(\text{inr}\ y)
     $$

3. **使用存在量词的消解规则 (∃E)：**

   - 从 $p$ 中提取出 $z : A \lor B$ 和 $r : P(z)$。

   - 假设：

     $$
     z : A \lor B,\quad r : P(z) \quad (7.10)
     $$

4. **挑战：**

   - 我们希望对 $z : A \lor B$ 进行析取的情况分析（case analysis），即分别处理 $z$ 是 $\text{inl}\ x$ 还是 $\text{inr}\ y$ 的情况。

   - **问题在于：**

     - $r : P(z)$ 中的 $z$ 是自由变量，无法直接进行情况分析。

5. **解决方案：**

   - **将额外的假设转化为目标的前提：**

     - 将 $r : P(z)$ 作为一个假设，引入一个新的含有前提的目标 $Q(z)$：

       $$
       Q(z) \equiv_{\text{df}} P(z) \Rightarrow \left( (\exists x : A).\ P(\text{inl}\ x) \lor (\exists y : B).\ P(\text{inr}\ y) \right)
       $$

     - 现在，我们的目标是证明：

       $$
       [z : A \lor B] \vdash Q(z)
       $$

6. **证明 $Q(z)$：**

   - **对于 $z : A \lor B$，我们对 $z$ 进行情况分析：**

     - **情况 1：$z = \text{inl}\ x$**

       - **假设：**

         - $x : A$

         - $q : P(\text{inl}\ x)$（由于 $r : P(z)$ 和 $z = \text{inl}\ x$）

       - **推导：**

         - $(x, q) : (\exists x : A).\ P(\text{inl}\ x)$（存在量词的引入）

         - $\text{inl}\ (x, q) : (\exists x : A).\ P(\text{inl}\ x) \lor (\exists y : B).\ P(\text{inr}\ y)$（析取的引入）

       - **构造：**

         - $\lambda q.\ \text{inl}\ (x, q) : Q(\text{inl}\ x)$

     - **情况 2：$z = \text{inr}\ y$**

       - **类似地进行推导。**

   - **综合：**

     - 使用析取的消解规则，将两个情况的结果组合起来，得到 $Q(z)$。

7. **应用存在量词的消解规则 (∃E)：**

   - 将 $z$ 和 $r$ 带入 $Q(z)$，得到最终结果。

**问题：**

- **在上述证明中，我们引入了抽象 $\lambda q.$ 和对 $r$ 的应用，这被认为是多余的。**

- **这是由于我们需要将假设 $r : P(z)$ 转移到目标中，以便对 $z$ 进行情况分析。**

---

##### **7.7.2 强消解规则 (Strong and Hypothetical Rules)**

为了解决上述问题，我们可以采用**加强的析取消解规则**，使证明过程更加简洁。

###### **加强的析取消解规则：**

$$
\frac{
  p : A \lor B \quad
  [x : A,\ r : (p = \text{inl}\ x)] \vdash u : C[\text{inl}\ x / z] \quad
  [y : B,\ r : (p = \text{inr}\ y)] \vdash v : C[\text{inr}\ y / z]
}{
  \text{decide}_{x,y}\ p\ u\ v : C[p / z]
} \quad (\lor\text{SE})
$$

- **计算规则：**

  - $\text{decide}_{x,y}\ (\text{inl}\ a)\ u\ v \rightarrow u[a / x]$

  - $\text{decide}_{x,y}\ (\text{inr}\ b)\ u\ v \rightarrow v[b / y]$

- **解释：**

  - **引入了额外的假设 $r : (p = \text{inl}\ x)$ 和 $r : (p = \text{inr}\ y)$，表示 $p$ 是具体的左或右注入。**

  - **在每个情况下，我们可以使用 $r$ 对 $p$ 进行替换，使得 $p$ 替换为 $\text{inl}\ x$ 或 $\text{inr}\ y$。**

**应用于我们的示例：**

1. **假设：**

   - $p : A \lor B$

   - $r : P(p)$

2. **对 $p$ 进行情况分析：**

   - **情况 1：**

     - $x : A$

     - $r : (p = \text{inl}\ x)$

     - **替换：**

       - 由于 $r : (p = \text{inl}\ x)$，我们可以在 $r : P(p)$ 中替换 $p$ 为 $\text{inl}\ x$，得到 $r : P(\text{inl}\ x)$。

     - **推导：**

       - $(x, r) : (\exists x : A).\ P(\text{inl}\ x)$

       - $\text{inl}\ (x, r) : (\exists x : A).\ P(\text{inl}\ x) \lor (\exists y : B).\ P(\text{inr}\ y)$

   - **情况 2：**

     - 类似地处理。

3. **综合：**

   - 使用加强的析取消解规则，我们无需引入多余的抽象和应用，直接得到所需结果。

---

###### **假设性假设 (Hypothetical Hypotheses)**

另一种表达加强规则的方法是使用**假设性假设**。

- **定义：**

  - **假设性假设**表示在某些假设下可以推导出一个判断，而不是直接可推导。

- **表示法：**

  - 使用 [Bac87b] 中的符号：

    $$
    \{ J_1, J_2, \dots, J_k \vdash J \}
    $$

    表示在假设 $J_1, J_2, \dots, J_k$ 下，可以推导出 $J$。

- **假设性析取消解规则：**

  $$
  \frac{
    p : A \lor B \quad
    \{ v : A \lor B,\ w : C \vdash E\ \text{是一个类型} \} \quad
    \{ x : A,\ w : C[\text{inl}\ x / w] \vdash b : E[\text{inl}\ x / w] \} \quad
    \{ y : B,\ w : C[\text{inr}\ y / w] \vdash c : E[\text{inr}\ y / w] \} \quad
    \{ w : C[a / w] \vdash \text{when}_{x,y}\ a\ b\ c : E[a / w] \}
  }{
    \text{结论}
  } \quad (\lor\text{EH})
  $$

- **这种规则可以更一般地表示加强的消解规则，并在证明中减少多余的步骤。**

---

##### **7.7.3 多态类型 (Polymorphic Types)**

另一个可能导致多余抽象和应用的情况是关于列表的头部函数 $\text{head}$ 的类型问题。

- **理想情况下，我们希望 $\text{head}$ 的类型为：**

  $$
  \text{head} : \{ l : [A] \mid l \neq [\ ] \} \rightarrow A \quad (7.11)
  $$

  - **即，$\text{head}$ 接受一个非空列表，返回其头部元素。**

- **然而，在传统的类型理论中，我们只能得到：**

  $$
  \text{head} : (\forall l : [A]).\ (l \neq [\ ]) \Rightarrow A
  $$

  - **这意味着 $\text{head}$ 的类型是一个函数，从列表 $l$ 和一个证明 $l \neq [\ ]$ 映射到 $A$。**

  - **证明 $l \neq [\ ]$ 成为了函数的额外参数。**

**为了解决这个问题，我们引入了一种新的多态类型 $A \Rightarrow B$**。

###### **多态类型的定义：**

- **引入规则：**

  $$
  \frac{
    [x : A] \vdash b : B
  }{
    b : A \Rightarrow B
  } \quad (\Rightarrow I)
  $$

  - **要求：**

    - 在引入规则中，$b$ 和 $B$ **不含有**变量 $x$。

    - **即，虽然 $b$ 的定义依赖于假设 $x : A$，但 $b$ 的值实际上与 $x$ 无关。**

- **消解规则：**

  $$
  \frac{
    b : A \Rightarrow B \quad a : A
  }{
    b : B
  } \quad (\Rightarrow E)
  $$

- **解释：**

  - **$b$ 被视为一个多态常量，因为它在假设 $x : A$ 下定义，但实际上与 $x$ 的值无关。**

**应用于 $\text{head}$ 函数：**

- **在一个外延系统中，如 [ML85]，可以推导出：**

  $$
  \text{head}\ l : (l \neq [\ ]) \Rightarrow A \quad (7.12)
  $$

- **然后，根据消解规则，我们有：**

  $$
  \text{head}\ l : A
  $$

- **这样，我们就实现了理想的类型 (7.11)，而无需额外的证明参数。**

---

##### **7.7.4 非终止性 (Non-termination)**

**引入多态类型 $A \Rightarrow B$ 在外延系统中有一些后果。**

- **众所周知，在 [ML85] 中，并非每个项都有正常形（normal form）。**

- **例如，我们可以推导出：**

  $$
  (\lambda p : \bot).\ (\lambda x.\ xx)(\lambda x.\ xx) : \bot \Rightarrow A \quad (7.13)
  $$

  - **对于任意类型 $A$，都成立。**

- **推导过程：**

  1. **假设 $p : \bot$，我们可以推导出：**

     $$
     r : I(\text{Un},\ A,\ A \Rightarrow A)
     $$

     - **其中 $\text{Un}$ 是宇宙类型。**

  2. **然后，我们有：**

     $$
     A \leftrightarrow (A \Rightarrow A)
     $$

     - **即，$A$ 与 $A \Rightarrow A$ 等价。**

  3. **从 $x : A$ 推导出 $x : A \Rightarrow A$，因此 $(x x) : A$。**

  4. **进一步推导得到 (7.13)。**

- **然而，这个项没有规范形式，因为它会无限地自我应用，导致非终止性。**

- **因此，在包含多态类型的外延系统中，系统可能不终止。**

**在内涵系统（如 $TT$）中，引入多态类型不会有这种困难。**

- **但是，多态类型将包含更少的对象，因为如 [SS89] 所讨论的，$TT$ 中的规则不会丢失假设中提到的对象。**

---

##### **练习**

**7.22.** 给出存在量词的加强的消解规则，并举一个使用它简化证明对象的例子。

**解答：**

- **加强的存在量词消解规则：**

  $$
  \frac{
    p : (\exists x : A).\ P(x) \quad
    [x : A,\ r : (p = (x, q))] \vdash u : C[(x, q) / z]
  }{
    \text{exdecide}_x\ p\ u : C[p / z]
  }
  $$

  - **计算规则：**

    - $\text{exdecide}_x\ ((a, b))\ u \rightarrow u[a / x,\ b / q]$

- **示例：**

  - **假设我们要证明 $(\exists x : A).\ P(x) \Rightarrow Q$，使用加强的规则，可以直接得到 $x$ 和 $q : P(x)$，然后构造 $u : C$，避免额外的抽象和应用。**

---

**7.23.** 说明加强的析取消解规则是如何从假设性规则 (\(\lor\)EH) 推导出来的。

**解答：**

- **假设性规则 (\(\lor\)EH) 给出了更一般的形式，其中包含了假设性假设。**

- **通过具体化假设性假设，设置适当的 $E$ 和 $C$，可以得到加强的析取消解规则 (\(\lor\)SE)。**

- **具体来说，选择 $E = C[p / z]$，然后利用假设性假设中的推导，可以得到加强的规则。**

---

**7.24.** 给出存在量词和自然数消解的加强规则的“假设性”版本。

**解答：**

- **存在量词的假设性消解规则：**

  $$
  \frac{
    p : (\exists x : A).\ P(x) \quad
    \{ x : A,\ q : P(x) \vdash u : C[(x, q) / z] \}
  }{
    \text{when}_x\ p\ u : C[p / z]
  }
  $$

- **自然数的假设性消解规则：**

  $$
  \frac{
    n : \mathbb{N} \quad
    \{ \vdash u_0 : C[0 / n] \} \quad
    \{ k : \mathbb{N},\ u_k : C[k / n] \vdash u_{k+1} : C[(k+1) / n] \}
  }{
    \text{nat\_elim}\ n\ u_0\ u_{k+1} : C[n / n]
  }
  $$

---

**7.25.** 推导判断 (7.12)，并用它来说明 $\text{head}$ 可以被赋予类型 (7.11)。

**解答：**

- **从 $\text{head}\ l : (l \neq [\ ]) \Rightarrow A$ 开始，利用多态类型的引入规则，我们可以得到：**

  $$
  \text{head}\ l : (l \neq [\ ]) \Rightarrow A
  $$

- **根据消解规则，给定 $l : [A]$ 且 $l \neq [\ ]$，我们有 $\text{head}\ l : A$。**

- **因此，$\text{head}$ 的类型可以表示为 $\{ l : [A] \mid l \neq [\ ] \} \rightarrow A$。**

---

**7.26.** 完成判断 (7.13) 的推导。

**解答：**

- **从假设 $p : \bot$ 出发，$\bot$ 是空类型。**

- **根据类型 $\text{Un}$ 的性质，我们可以推导出 $A \leftrightarrow (A \Rightarrow A)$。**

- **因此，假设 $x : A$，我们有 $x : A \Rightarrow A$，所以 $(x x) : A$。**

- **定义：**

  $$
  f \equiv \lambda x.\ x x
  $$

- **那么 $f f$ 无法归约到规范形式，因为会导致无限递归。**

- **因此，我们得到：**

  $$
  (\lambda p : \bot).\ f f : \bot \Rightarrow A
  $$

---

##### **总结**

在本节中，我们探讨了如何加强类型理论中的消解规则，以使证明过程更加直观和简洁。通过引入**加强的析取和存在量词消解规则**，我们可以避免在证明中出现多余的抽象和应用，使推导更为直接。

此外，我们介绍了**多态类型 $A \Rightarrow B$**，这使得我们可以在不增加额外证明参数的情况下，定义诸如 $\text{head}$ 函数等具有更理想类型的函数。

然而，在外延系统中引入多态类型可能会导致系统的非终止性，这是需要注意的。在内涵系统中，这种问题不会出现，但多态类型包含的对象会更少。

通过这些讨论，我们认识到对类型理论规则的适当加强和扩展，可以在保持系统一致性的前提下，提高证明的简洁性和直观性。

---

### **如果您对上述内容有任何疑问，或者希望深入了解某个主题，请随时告诉我！**

### ---------------------------

### **第七章 增强类型理论 (Augmenting Type Theory)**

---

#### **7.8 良基递归 (Well-founded Recursion)**

---

##### **概览**

在编程和证明过程中，**递归**是一种强大的工具，允许我们基于“更简单”的输入来定义函数或证明性质。在类型理论系统 $TT$ 中，递归通常是**结构性的**，与数据类型的构造方式直接相关，如自然数 $\mathbb{N}$、列表、树和 W 类型。

然而，这种结构性递归存在限制，因为它仅基于对象的组成部分与整体之间的关系。本节的核心问题是：**是否存在更一般的“更简单”关系，使我们能够定义更广泛的递归函数和进行更灵活的归纳证明？**

答案是肯定的。本节将介绍**良基递归**（well-founded recursion）的概念，它允许我们在更一般的“更简单”关系上进行递归定义和归纳证明。我们还将探讨如何在类型理论中引入良基递归，以及扩展系统的递归能力。

---

##### **良基递归的引入**

**递归和证明的必要性：**

- 在函数定义和性质证明中，递归允许我们基于更简单的情况来构建复杂的结果。
- 传统上，递归在类型理论中是**结构性的**，与数据类型的构造方式密切相关。

**结构性递归的限制：**

- 只考虑对象的组成部分比整体更简单，例如，树的子节点比树本身更简单。
- 这种递归限制了我们在更一般的“更简单”关系上进行递归的能力。

**引入更一般的“更简单”关系：**

- 为了定义更广泛的递归函数和进行更灵活的归纳证明，我们需要一个更一般的“更简单”概念。
- 这个概念可以通过**良基递归**和**良基次序**（well-founded order）来实现。

---

##### **部分次序和良基次序**

为了正式化“更简单”关系，我们需要引入**部分次序**和**良基次序**的概念。

###### **定义 7.6：部分次序**

一个二元关系 $\prec$ 是一个**部分次序**，如果对于所有的 $x, y, z$，满足以下条件：

1. **反自反性（Irreflexivity）：**
   $$
   \forall x \in A,\ x \not\prec x
   $$
   
2. **传递性（Transitivity）：**
   $$
   \forall x, y, z \in A,\ (x \prec y \land y \prec z) \Rightarrow x \prec z
   $$

**解释：**

- **反自反性**确保没有元素比自身更简单。
- **传递性**确保如果 $x$ 比 $y$ 更简单，且 $y$ 比 $z$ 更简单，那么 $x$ 比 $z$ 更简单。
- 这使得“更简单”关系是有意义和一致的。

###### **无限下降链和递归失败的示例**

- **反例：** 考虑自然数上的关系 $n \prec m$ 定义为 $m < n$：
  $$
  \dots \prec n+1 \prec n \prec \dots \prec 1 \prec 0
  $$
  
- **递归失败：** 在此关系上尝试递归定义函数时，例如：
  $$
  f(n) \equiv f(n+1) - 1 \quad (7.14)
  $$
  
- **问题：**

  - 递归定义无法启动，因为总是依赖于“更大”的 $n$ 的值，没有最小元素作为基础。
  - 导致递归定义没有唯一解，例如，任何形式为 $f_k(n) = n + k$ 的函数都满足该递归定义。

###### **定义 7.7：良基次序**

一个部分次序 $\prec$ 是**良基的**，如果不存在**无限下降链** $\{ x_n \}$，使得：
$$
x_0 \succ x_1 \succ x_2 \succ \dots
$$

- **解释：**

  - **无限下降链**意味着存在一个无限序列，其中每个元素都比前一个元素更简单。
  - **良基次序**的要求确保这种无限下降链不存在，从而保证递归定义可以在某个“最小”元素处开始。

---

##### **良基递归的特性**

###### **定理 7.8：良基次序的等价性质**

一个部分次序 $\prec$ 是良基的，当且仅当对于所有集合 $Z$，以下性质成立：
$$
\left( \forall x \in A.\ \left( \forall y \in A.\ y \prec x \Rightarrow y \in Z \right) \Rightarrow x \in Z \right) \Rightarrow \forall x \in A.\ x \in Z \quad (7.15)
$$

- **解释：**

  - 这是一个**归纳原理**，用于证明某个性质对所有元素成立。
  - 如果对于每个元素 $x$，假设所有比 $x$ 更简单的元素都在 $Z$ 中，那么 $x$ 也在 $Z$ 中，那么可以得出 $A$ 中的所有元素都在 $Z$ 中。

**证明的意义：**

- 这个归纳原理允许我们通过“从下往上”的方式证明性质，即基于更简单的情况来证明复杂的情况。

###### **良基递归的定义**

**定义 7.12：良基递归函数**

如果函数 $f$ 满足以下形式，则称其为在关系 $\prec$ 上的良基递归定义：
$$
f(a) \equiv \text{根据所有 } a_i \prec a \text{ 的 } f(a_i) \text{ 来定义} \quad (7.16)
$$

- **解释：**

  - 函数 $f$ 的值在点 $a$ 处仅依赖于所有比 $a$ 更简单的元素的函数值。
  - 这种定义方式确保了递归过程能够终止，因为无法无限制地继续递归下去。

**例子：**

- **快速幂函数（pow）的定义：**

  - 在第 6.1.4 节中，我们定义了函数 $\text{pow} : \mathbb{N} \rightarrow \mathbb{N}$：
    $$
    \text{pow}(0) \equiv 1 \\
    \text{pow}(n) \equiv \left( \text{pow}\left( \left\lfloor \frac{n}{2} \right\rfloor \right) \right)^2 \times 2^{n \mod 2}
    $$

  - 这里，$\left\lfloor \frac{n}{2} \right\rfloor \prec n$，因为 $\left\lfloor \frac{n}{2} \right\rfloor < n$。
  - 这个定义基于自然数上的良基次序 $<$。

###### **定理 7.13：良基递归的正确性**

对于每个函数 $F$（基于更简单的元素定义的函数），存在唯一的函数 $f$ 满足：
$$
f(a) = F\left( f \downarrow a,\ a \right) \quad (7.17)
$$

- **其中：**

  - $f \downarrow a$ 表示函数 $f$ 在所有比 $a$ 更简单的元素上的限制。
  - 该定理表明，在良基次序上，递归定义的函数是良好定义的，并且是唯一的。

**证明思路：**

- 通过归纳法，根据良基次序的归纳原理，证明对于每个 $a$，函数 $f(a)$ 都可以唯一地确定。

---

##### **良基次序的例子**

**1. 由类型结构诱导的次序：**

- **自然数 $\mathbb{N}$：**

  - 使用标准次序 $<$ 作为良基次序。
  - 没有无限下降链，因为没有负数。

- **列表 [A]：**

  - 定义列表的长度函数 $\# : [A] \rightarrow \mathbb{N}$。
  - 定义次序：
    $$
    l \prec l' \equiv \# l < \# l'
    $$
  - 列表长度有限，因此没有无限下降链。

- **树（tree）：**

  - 对于树节点 $\text{Bnode}\ n\ u\ v$，其子树 $u$ 和 $v$ 被认为比树本身更简单：
    $$
    u \prec \text{Bnode}\ n\ u\ v \\
    v \prec \text{Bnode}\ n\ u\ v
    $$
  - 树的深度有限，因此没有无限下降链。

**2. 逆像次序（Inverse Image Order）：**

- **定义：**

  - 给定函数 $f : A \rightarrow B$ 和 $B$ 上的良基次序 $\prec_B$，可以定义 $A$ 上的次序 $\prec_A$：
    $$
    a \prec_A a' \equiv f(a) \prec_B f(a')
    $$
  - 这称为次序 $\prec_B$ 在 $f$ 下的**逆像**。

- **例子：**

  - 使用列表的长度函数 $\#$，定义列表上的次序：
    $$
    l \prec l' \equiv \# l < \# l'
    $$

**3. 次序的组合：**

- **子次序（Sub-ordering）：**

  - 如果 $\prec$ 是良基次序，且 $\prec' \subseteq \prec$，则 $\prec'$ 也是良基次序。

- **积次序（Product Order）：**

  - 对于 $A \times B$，定义次序：
    $$
    (a, b) \prec (a', b') \equiv a \prec a' \land b \prec b'
    $$
  - 如果 $A$ 和 $B$ 上的次序都是良基的，则积次序也是良基的。

- **字典序（Lexicographic Order）：**

  - 对于 $A \times B$，定义字典序：
    $$
    (a, b) \prec (a', b') \equiv (a \prec a') \lor (a = a' \land b \prec b')
    $$
  - 这是单词在字典中排序的方式。
  - 可以扩展到 $n$ 元组和列表。

- **和次序（Sum Order）：**

  - 对于直和类型 $A \lor B$，定义次序：
    $$
    \text{inl}\ a \prec \text{inl}\ a' \equiv a \prec a' \\
    \text{inr}\ b \prec \text{inr}\ b' \equiv b \prec b'
    $$
  - 不同类型的元素不可比较。

---

##### **在类型理论中引入良基递归**

**问题：**

- 我们希望将良基递归正式地引入到类型理论中，使其与现有的规则和性质兼容。

**解决方案：**

- **定义良基递归的形式规则和消解规则。**
- **确保在类型理论中表达良基次序和递归定义的方式是可行且一致的。**
- **考虑如何在不破坏系统重要性质（如强规范化）的情况下扩展递归能力。**

---

##### **练习**

**7.27.** 证明集合 $\text{Acc}(A, \prec)$ 是向下封闭的，即如果 $y \prec x$ 且 $x \in \text{Acc}(A, \prec)$，则 $y \in \text{Acc}(A, \prec)$。

**解答：**

- **假设 $x \in \text{Acc}(A, \prec)$，即不存在从 $x$ 开始的无限下降链。**
- **如果 $y \prec x$，假设存在从 $y$ 开始的无限下降链 $y \succ y_1 \succ y_2 \succ \dots$。**
- **那么我们可以在该链前加上 $x$，得到从 $x$ 开始的无限下降链 $x \succ y \succ y_1 \succ y_2 \succ \dots$，与 $x \in \text{Acc}(A, \prec)$ 矛盾。**
- **因此，$y$ 也在 $\text{Acc}(A, \prec)$ 中，证明了向下封闭性。**

**7.28.** 给出由列表和一般 W 类型的结构诱导的良基次序的明确定义。

**解答：**

- **对于列表 [A]：**

  - 列表的结构性良基次序定义如下：
    - 空列表 $[\ ]$ 没有前驱。
    - 非空列表 $l = a :: l'$ 的直接前驱是其尾部 $l'$：
      $$
      l' \prec l
      $$
    - 因为列表的长度有限，递归在长度减少的列表上进行。

- **对于一般的 W 类型：**

  - W 类型表示为：
    $$
    W_A B = \mu X.\ \sum_{a : A} (B(a) \rightarrow X)
    $$
  - 良基次序定义为：
    - 对于 $w = (\text{sup}\ a\ f)$，其直接前驱是所有 $f(b)$，其中 $b \in B(a)$：
      $$
      f(b) \prec w \quad \text{对于所有 } b \in B(a)
      $$
    - 因为 W 类型的构造是基于有限的层次结构，递归在更低层次的结构上进行。

**7.29.** 证明如果组成次序是良基的，则子次序、积次序、字典序和和次序都是良基的。

**解答：**

- **子次序：**

  - 子次序 $\prec' \subseteq \prec$ 不会引入新的无限下降链，因此仍然是良基的。

- **积次序：**

  - 假设 $\prec_A$ 和 $\prec_B$ 是良基的。
  - 如果存在从 $(a_0, b_0)$ 开始的无限下降链 $(a_0, b_0) \succ (a_1, b_1) \succ \dots$，那么投影到 $A$ 或 $B$ 上，将得到 $A$ 或 $B$ 中的无限下降链，与良基性矛盾。

- **字典序：**

  - 与积次序类似，字典序不会引入新的无限下降链。

- **和次序：**

  - 和次序中，不同类型的元素不可比较，次序仅在各自的类型内部。
  - 如果 $\prec_A$ 和 $\prec_B$ 是良基的，则和次序也是良基的。

**7.30.** 尝试发现第 6 章中定义的函数最自然地表达在哪些次序上。特别关注快速排序和 Ackermann 函数的例子。

**解答：**

- **快速排序（quicksort）：**

  - 递归地对列表进行排序，基于列表的长度或元素数量。
  - 次序可以定义为列表的长度递减：
    $$
    l' \prec l \equiv \# l' < \# l
    $$
  - 递归在更短的列表上进行，保证了递归过程的终止。

- **Ackermann 函数：**

  - Ackermann 函数是一个以自然数为参数的函数，其递归深度非常高。
  - 可以使用**字典序**定义 $(m, n)$ 上的良基次序：
    $$
    (m', n') \prec (m, n) \equiv (m' < m) \lor (m' = m \land n' < n)
    $$
  - 递归在 $m$ 或 $n$ 更小的情况下进行，保证了递归的良基性。

---

##### **总结**

本节深入探讨了**良基递归**的概念，展示了如何在更一般的“更简单”关系上进行递归定义和归纳证明。通过引入**良基次序**，我们能够定义基于更广泛关系的递归函数，超越了传统结构性递归的限制。

我们讨论了良基次序的定义、性质，以及如何在类型理论中引入和应用良基递归。此外，我们还提供了良基次序的多个示例，展示了如何在实际情况下构造和利用这些次序。

通过这些内容，我们认识到良基递归在扩展类型理论的递归能力方面具有重要作用，使我们能够处理更复杂的递归定义和证明，同时保持系统的重要性质，如强规范化。

---

### **如果您对上述内容有任何疑问，或者希望深入了解某个主题，请随时告诉我！**

### ----------------------------

### **第七章 增强类型理论 (Augmenting Type Theory)**

---

#### **7.9 类型理论中的良基递归 (Well-founded Recursion in Type Theory)**

---

##### **概览**

在上一节中，我们介绍了**良基递归**的概念，以及如何利用良基关系定义函数和进行归纳证明。本节将深入探讨如何将良基递归引入我们的类型理论系统 $TT$。我们将讨论两种主要的方法：

1. **Paulson 的方法**：基于类型理论中对良基性的刻画，将良基递归直接添加到系统中。
2. **Nordström 的方法**：允许在任意部分次序 $\prec$ 的可达元素（accessible elements）上进行递归，并通过类型理论规则来定义这些元素的集合。

我们将详细讨论这两种方法，以及它们在类型理论中的实现和差异。

---

##### **7.9.1 构造递归算子 (Constructing Recursion Operators)**

**目标：**

- 将良基性的刻画（定理 7.8）翻译到类型理论中。
- 确定哪些次序关系满足这种类型理论中的定义。
- 证明在上一节提到的所有良基次序都可以在类型理论的刻画下被证明为良基的。

---

**在类型理论中表达良基性：**

- **问题：** 如何在类型理论中表达“对于所有集合 $Z$”的量化？
  
- **解决方案：** 将其视为“对于所有性质 $P$”，其中 $P$ 是定义在 $A$ 上的谓词。

- **定义谓词：**
  
  - **谓词 $P(z)$**：对于每个 $a : A$，$P(a)$ 是一个命题。
  - **因此，谓词 $P$ 是类型 $A \rightarrow U_0$ 的元素**，其中 $U_0$ 是宇宙类型。

- **次序关系 $\prec$ 作为二元关系：**
  
  - **表示为函数 $\prec : A \rightarrow A \rightarrow U_0$**。
  - **在表达式中，我们继续使用中缀形式 $y \prec x$**。

---

**定义 7.14：类型理论中的良基次序**

一个二元关系 $\prec$ 在类型理论 $TT$ 中是**良基的**，当且仅当存在一个对象 $\Xi$，使得以下类型是可居住的（即存在这样的 $\Xi$）：

$$
(∀P : A \rightarrow U_0).\ \left( (∀x : A). \left( (∀y : A).\ (y \prec x \Rightarrow P\ y) \Rightarrow P\ x \right) \Rightarrow (∀x : A).(P\ x) \right) \quad (7.19)
$$

并且 $\Xi$ 满足以下性质：

$$
\Xi\ P\ F\ x = F\ (\lambda y.\ \lambda r.\ (\Xi\ P\ F\ y)) \quad (7.20)
$$

**解释：**

- **(7.19) 的含义：**

  - **对于所有谓词 $P : A \rightarrow U_0$，如果对于所有 $x : A$，假设对于所有 $y \prec x$，$P(y)$ 成立，则 $P(x)$ 成立，那么可以得出对于所有 $x$，$P(x)$ 成立。**

- **$\Xi$ 的作用：**

  - **$\Xi$ 是一个操作符，用于在良基次序上进行归纳证明或定义递归函数。**
  - **(7.20) 描述了 $\Xi$ 的递归特性，即 $\Xi\ P\ F\ x$ 的值是通过对所有 $y \prec x$ 的 $\Xi\ P\ F\ y$ 的值应用 $F$ 来计算的。**

**在类型理论中定义递归函数：**

- **使用 $\Xi$ 可以定义递归函数，形式为：**

  $$
  f\ a \equiv \text{基于所有 } a_i \prec a \text{ 的 } f(a_i) \text{ 来定义}
  $$

- **在递归定义中，我们需要确保对于每个 $a$，只依赖于比 $a$ 更简单的 $a_i$。**

---

**证明良基次序的例子：**

**定理 7.15：**

如果 $\prec_0$ 是 $B$ 上的一个良基次序，且 $f : A \rightarrow B$，则定义在 $A$ 上的次序 $\prec$：

$$
y \prec x \equiv f(y) \prec_0 f(x) \quad (7.21)
$$

是良基的。

**证明：**

1. **目标：**

   - 构造一个操作符 $\Xi$（满足 (7.19) 和 (7.20)），基于已知的 $\Xi_0$（$\prec_0$ 的良基性操作符）。

2. **已知条件：**

   - $\Xi_0$ 满足：

     $$
     (∀P_0 : B \rightarrow U_0).\ \left( (∀x_0 : B). \left( (∀y_0 : B).\ (y_0 \prec_0 x_0 \Rightarrow P_0\ y_0) \Rightarrow P_0\ x_0 \right) \Rightarrow (∀x_0 : B).(P_0\ x_0) \right) \quad (7.22)
     $$

3. **构造 $\Xi$：**

   - 假设我们有：

     - $P : A \rightarrow U_0$
     - $F : (∀x : A).\ ((∀y : A).\ (y \prec x \Rightarrow P\ y) \Rightarrow P\ x)$

   - 需要证明 $(∀x : A).(P\ x)$。

4. **定义 $P_0$：**

   - 定义 $P_0 : B \rightarrow U_0$ 为：

     $$
     P_0\ x_0 \equiv (∀x : A).\ (f(x) = x_0 \Rightarrow P\ x) \quad (7.23)
     $$

   - **解释：**

     - $P_0\ x_0$ 表示所有映射到 $x_0$ 的 $x$ 都满足 $P(x)$。

5. **利用 $\Xi_0$：**

   - 由于 $\Xi_0$ 的存在，我们可以得到 $(∀x_0 : B).(P_0\ x_0)$。

6. **推导 $(∀x : A).(P\ x)$：**

   - 由 $(∀x_0 : B).(P_0\ x_0)$ 可知：

     $$
     (∀x : A).(P_0(f(x))) \implies (∀x : A).(P\ x)
     $$

7. **构造 $\Xi$ 的定义：**

   - 定义 $\Xi\ P\ F \equiv \Xi_0\ P_0\ F_0$，其中 $F_0$ 根据 $F$ 构造。

8. **结论：**

   - 因此，定义在 $A$ 上的次序 $\prec$ 是良基的。

---

**进一步讨论：**

- **这个定理的重要性：**

  - 它不仅证明了特定的次序是良基的，还为良基次序提供了一个刻画。
  
- **定理 7.16：**

  - **一个次序 $\prec$ 在 $A$ 上是良基的，当且仅当存在某个 W 类型 $B$ 和一个函数 $\text{norm} : A \rightarrow B$，使得 $\prec$ 逻辑等价于 $\text{norm}$ 下的逆像次序。**

---

##### **7.9.2 可达元素 (The Accessible Elements)**

**介绍：**

- **Nordström 在 [Nor88] 中的方法：**

  - 通过在次序 $\prec$ 的可达元素（accessible elements）上进行递归来定义函数。
  - 需要在类型理论中定义可达元素的集合 $\text{Acc}(A, \prec)$。

- **挑战：**

  - 需要对成员关系 $b : B$ 进行推理，以正确地刻画 $\text{Acc}(A, \prec)$。
  - 这类似于通过“=”来内部表示等式，需要引入一个表示此判断的命题。

---

**Nordström 的规则：**

**1. 形成规则 (AccF)：**

$$
\frac{
  A\ \text{是一个类型} \quad
  [x : A,\ y : A] \vdash (x \prec y)\ \text{是一个类型}
}{
  \text{Acc}(A, \prec)\ \text{是一个类型}
}
$$

- **解释：**

  - 给定类型 $A$ 和次序 $\prec$，可以形成类型 $\text{Acc}(A, \prec)$。

**2. 引入规则 (AccI)：**

$$
\frac{
  a : A \quad
  [y : A,\ y \prec a] \vdash y : \text{Acc}(A, \prec)
}{
  a : \text{Acc}(A, \prec)
}
$$

- **解释：**

  - 要证明 $a \in \text{Acc}(A, \prec)$，需要对于所有 $y \prec a$，证明 $y \in \text{Acc}(A, \prec)$。

**3. 消解规则 (AccE)：**

$$
\frac{
  p : \text{Acc}(A, \prec) \quad
  \begin{cases}
    x : \text{Acc}(A, \prec) \\
    z : A,\ z \prec x \vdash (f\ z) : C(z)
  \end{cases} \vdash (e\ x\ f) : C(x)
}{
  \text{rec}\ e\ p : C(p)
}
$$

- **解释：**

  - 从 $p : \text{Acc}(A, \prec)$ 出发，通过递归地定义函数 $f$，可以得到 $C(p)$。

**4. 计算规则 (AccE)：**

$$
\text{rec}\ e\ p \rightarrow e\ p\ (\text{rec}\ e)
$$

- **解释：**

  - 计算时，递归调用展开为函数 $e$ 的应用。

---

**讨论：**

- **引入规则的挑战：**

  - 在 $\text{AccI}$ 中，需要在假设 $y : A,\ y \prec a$ 下，推导出 $y : \text{Acc}(A, \prec)$。
  - 这需要一个内部表示的成员关系 $y \in \text{Acc}(A, \prec)$，类似于内部表示的等式。

- **解决方案：**

  - 引入成员关系的内部形式 $y \in B$。
  - **成员关系的引入和消解规则：**

    - **引入规则 ($\in I$)：**

      $$
      b : B \implies (b \in B)
      $$

    - **消解规则 ($\in E$)：**

      $$
      c : (b \in B) \implies b : B
      $$

- **进一步简化：**

  - Saaman 和 Malcolm 在 [SM87] 中提出了简化的消解规则，无需显式讨论 $\in$ 类型。

  - **例如，自然数的消解规则 (SNE)：**

    $$
    \frac{
      n : \mathbb{N} \quad v[0/x] : C[0/x] \quad
      [i : \mathbb{N},\ v[i/x] : C[i/x]] \vdash v[\text{succ}\ i/x] : C[\text{succ}\ i/x]
    }{
      v[n/x] : C[n/x]
    }
    $$

  - **解释：**

    - 直接在表达式上进行适当的归约，无需显式使用 $\in$ 类型。

---

**良基次序的定义：**

- **一个关系 $\prec$ 在类型 $A$ 上是良基的，如果 $\text{Acc}(A, \prec)$ 是整个集合 $A$。**

- **Saaman 和 Malcolm 在 [SM87] 中对一些例子进行了推导，证明了 $\text{Acc}(A, \prec) = A$。**

---

##### **7.9.3 结论 (Conclusions)**

**比较两种方法：**

1. **Paulson 的方法（[Pau86]）：**

   - **在 $TT$ 中证明类型理论足够强大，可以定义许多良基关系上的递归算子。**
   - **优势：**

     - 不需要对系统进行任何更改。
     - 增加了系统的模块化性，因为无需为每个函数定义重复良基性的推导。

2. **Saaman 和 Chisholm 的方法（[SM87]）：**

   - **引入了一个新的谓词 $\in$，用于表示成员关系。**
   - **可能的影响：**

     - 对系统的终止性等性质产生不确定的影响。
   - **优势：**

     - 声称可以大大简化 Paulson 方法中给出的证明对象。
     - 允许定义一些特殊的程序，如根搜索程序。

---

**总结：**

通过以上讨论，我们看到了在类型理论中引入良基递归的两种主要方法。第一种方法利用了类型理论的内在力量，而第二种方法则引入了新的构造来扩展系统的能力。每种方法都有其优点和挑战，选择哪种方法取决于具体的应用需求和系统特性。

---

**练习：**

**7.31.** 检查自然数、列表、树等类型上的次序根据上述定义是良基的——这将涉及到以一种基本的方式使用递归算子。

**7.32.** 通过给出表达式 $\Xi$ 的显式定义并检查其满足性质 (7.20)，完成定理 7.15 的证明。

**7.33.** 证明前一节中定义的良基次序，包括积次序和字典序，满足定义 7.14。

**7.34.** 你能否定义一个在 $A$ 上的次序，使其对于谓词 $A \rightarrow U_0$ 是良基的，但对于 $A \rightarrow U_1$ 中的谓词不是？

---

### **如果您对上述内容有任何疑问，或者希望深入了解某个主题，请随时告诉我！**

### ---------------------------

### **第七章 增强类型理论**

---

#### **7.9 类型理论中的良基递归**

---

##### **概览**

在类型理论中，递归是定义函数和证明性质的重要工具。然而，传统的递归通常是**结构性的**，即基于数据类型的构造方式，例如自然数、列表和树等。本节探讨如何在类型理论系统 $TT$ 中引入**良基递归**，以允许在更一般的“更简单”关系上进行递归定义和归纳证明。

我们将讨论两种主要的方法：

1. **Paulson 的方法**：利用类型理论中对良基性的刻画，将良基递归直接添加到系统中，证明特定的次序关系是良基的。
2. **Nordström 的方法**：允许在任意部分次序 $\prec$ 的**可达元素**（accessible elements）上进行递归，并通过类型理论规则来定义这些元素的集合。

通过对这两种方法的深入探讨，我们将了解如何在类型理论中有效地引入良基递归，以及这对系统的性质和功能有何影响。

---

##### **7.9.1 构造递归算子**

**引入良基递归到类型理论**

在之前的讨论中，我们通过定理 7.8 的刻画，描述了次序 $\prec$ 的良基性：

$$
\forall x \left( \forall y (y \prec x \Rightarrow y \in z) \Rightarrow x \in z \right) \Rightarrow \forall x (x \in z) \quad (7.18)
$$

我们的目标是将此刻画翻译到类型理论中，并确定哪些次序关系满足这种定义。

**在类型理论中表达“对于所有集合”**

- **问题**：如何在类型理论中表达“对于所有集合 $z$”的量化？
- **解决方案**：将其视为“对于所有性质 $P$”，其中性质 $P$ 是定义在 $A$ 上的谓词。
  - **谓词 $P$**：对于每个 $a : A$，都有一个命题 $P(a)$。
  - **因此，$P$ 是类型 $A \rightarrow U_0$ 的元素**，其中 $U_0$ 是宇宙类型。

**次序关系的表示**

- **次序关系 $\prec$**：作为二元关系，可以表示为函数 $A \rightarrow A \rightarrow U_0$。
- **为了方便，我们继续使用中缀形式 $y \prec x$**。

**定义 7.14：类型理论中的良基次序**

一个二元关系 $\prec$ 在类型理论 $TT$ 中是**良基的**，当且仅当以下类型是可居住的（即存在这样的对象 $\Xi$）：

$$
(\forall P : A \rightarrow U_0). \left( (\forall x : A). \left( (\forall y : A). (y \prec x \Rightarrow P(y)) \Rightarrow P(x) \right) \Rightarrow (\forall x : A). P(x) \right) \quad (7.19)
$$

并且 $\Xi$ 满足：

$$
\Xi\ P\ F\ x = F\ (\lambda y.\ \lambda r.\ \Xi\ P\ F\ y) \quad (7.20)
$$

**深入理解 (7.19) 的前提**

- **前提含义**：对于所有 $x : A$，如果对于所有 $y \prec x$，$P(y)$ 成立，则 $P(x)$ 成立。
- **$\Xi$ 的作用**：给定这样的函数 $F$，$\Xi$ 可以生成一个定义在整个 $A$ 上的函数 $(\forall x : A). P(x)$。

**关于递归和归纳**

- **递归定义函数**：通过 (7.20) 中的等式，我们可以定义递归函数，其中 $\Xi\ P\ F\ x$ 的值由 $F$ 应用于所有前驱 $y \prec x$ 的 $\Xi\ P\ F\ y$ 来计算。
- **第二个参数的作用**：在 $F$ 中，第二个参数是证明 $y \prec x$ 的证据。

**使用 $\Xi$ 定义函数**

- **递归形式**：

  $$
  f(a) \equiv \text{基于所有 } a_i \prec a \text{ 的 } f(a_i) \text{ 来定义}
  $$

- **确保每个 $a$ 的定义仅依赖于比它更小的 $a_i$**。

**证明特定类型上的次序是良基的**

- **目标**：展示诸如列表、树和自然数等类型上的次序是良基的。
- **方法**：需要证明全值递归算子（course-of-values recursion operator）的定义，其中先前的值以 $(\forall y : A). (y \prec x \Rightarrow P(y))$ 的形式呈现。

**定理 7.15：**

如果 $\prec_0$ 是 $B$ 上的良基次序，且 $f : A \rightarrow B$，则定义在 $A$ 上的次序 $\prec$：

$$
y \prec x \equiv f(y) \prec_0 f(x) \quad (7.21)
$$

是良基的。

**证明：**

1. **构造 $\Xi$**
   - 假设已知 $\Xi_0$ 满足 $\prec_0$ 的良基性（类似于 (7.22) 的类型）。
   - 目标是构造满足 (7.19) 和 (7.20) 的 $\Xi$。

2. **假设**
   - $P : A \rightarrow U_0$
   - $F : (\forall x : A). ((\forall y : A). (y \prec x \Rightarrow P(y)) \Rightarrow P(x))$

3. **定义 $P_0$**
   - 定义 $P_0 : B \rightarrow U_0$：

     $$
     P_0(x_0) \equiv (\forall x : A). (f(x) = x_0 \Rightarrow P(x)) \quad (7.23)
     $$

   - **含义**：如果 $x$ 被映射到 $x_0$，则 $P(x)$ 成立。

4. **利用 $\Xi_0$**
   - 由于 $\Xi_0$ 的存在，我们可以得到 $(\forall x_0 : B). P_0(x_0)$。

5. **推导 $(\forall x : A). P(x)$**
   - 因为 $(\forall x : A). P_0(f(x))$，根据 (7.23)，得到 $(\forall x : A). P(x)$。

6. **构造 $\Xi$**
   - 定义 $\Xi\ P\ F = \Xi_0\ P_0\ F_0$，其中 $F_0$ 根据 $F$ 和上述推导构造。

7. **验证 (7.20)**
   - 需要验证 $\Xi$ 满足 (7.20) 中的等式。

**结论：**

- 因此，定义在 $A$ 上的次序 $\prec$ 是良基的。
- 这一证明展示了如何利用已知的良基次序和对应的递归算子，构造新的良基次序。

**进一步讨论**

- **积次序和字典序**：也可以通过类似的方法证明其良基性。
- **定理 7.16：**
  - 一个次序 $\prec$ 在 $A$ 上是良基的，当且仅当存在某个 W 类型 $B$ 和一个函数 $\text{norm} : A \rightarrow B$，使得 $\prec$ 逻辑等价于 $\text{norm}$ 下的逆像次序。

---

##### **练习**

**7.31.** 检查自然数、列表、树等类型上的次序根据上述定义是良基的——这将涉及到以一种基本的方式使用递归算子。

**7.32.** 通过给出表达式 $\Xi$ 的显式定义并检查其满足性质 (7.20)，完成定理 7.15 的证明。

**7.33.** 证明前一节中定义的良基次序，包括积次序和字典序，满足定义 7.14。

**7.34.** 你能否定义一个在 $A$ 上的次序，使其对于谓词 $A \rightarrow U_0$ 是良基的，但对于 $A \rightarrow U_1$ 中的谓词不是？

---

##### **7.9.2 可达元素**

**引入可达元素**

- **Nordström 的方法**：在 [Nor88] 中，通过在次序 $\prec$ 的可达元素集合上进行递归，来定义函数。
- **目标**：通过类型理论规则来定义可达元素的集合 $\text{Acc}(A, \prec)$。

**Nordström 的规则**

1. **形成规则（AccF）**

   $$
   \frac{
     A\ \text{是一个类型} \quad
     [x : A,\ y : A] \vdash (x \prec y)\ \text{是一个类型}
   }{
     \text{Acc}(A, \prec)\ \text{是一个类型}
   }
   $$

   - **解释**：给定类型 $A$ 和次序 $\prec$，可以形成类型 $\text{Acc}(A, \prec)$。

2. **引入规则（AccI）**

   $$
   \frac{
     a : A \quad
     [y : A,\ y \prec a] \vdash y : \text{Acc}(A, \prec)
   }{
     a : \text{Acc}(A, \prec)
   }
   $$

   - **解释**：为了证明 $a \in \text{Acc}(A, \prec)$，需要对于所有 $y \prec a$，证明 $y \in \text{Acc}(A, \prec)$。

3. **消解规则（AccE）**

   $$
   \frac{
     p : \text{Acc}(A, \prec) \quad
     \left\{
     \begin{array}{l}
       x : \text{Acc}(A, \prec) \\
       z : A,\ z \prec x \vdash (f\ z) : C(z)
     \end{array}
     \right.
     \vdash (e\ x\ f) : C(x)
   }{
     \text{rec}\ e\ p : C(p)
   }
   $$

   - **解释**：从 $p : \text{Acc}(A, \prec)$ 出发，通过递归地定义函数 $f$，可以得到 $C(p)$。

4. **计算规则**

   $$
   \text{rec}\ e\ p \rightarrow e\ p\ (\text{rec}\ e)
   $$

   - **解释**：递归调用展开为函数 $e$ 的应用。

**规则的讨论**

- **消解规则中的假设性假设**：在推导 $(e\ x\ f) : C(x)$ 时，第二个假设本身是一个假设性的；假设 $z$ 是 $x$ 的前驱，$f$ 在 $z$ 上有定义。
- **引入规则的挑战**：需要在假设 $y : A,\ y \prec a$ 下，推导 $y : \text{Acc}(A, \prec)$，这在直觉上并不明显。

**引入内部成员关系**

- **问题**：需要内部表示成员关系 $y \in \text{Acc}(A, \prec)$。
- **解决方案**：引入成员关系的内部形式，就像用“=”来内部表示等式一样。

**成员关系的引入和消解规则**

- **引入规则（$\in I$）**

  $$
  b : B \implies (b \in B)
  $$

- **消解规则（$\in E$）**

  $$
  c : (b \in B) \implies b : B
  $$

**简化的消解规则**

- **Saaman 和 Malcolm 的方法**：使用一组简化的消解规则，基于存在 $\in$ 类型的情况。
- **例如，自然数的消解规则（SNE）**

  $$
  \frac{
    n : \mathbb{N} \quad v[0/x] : C[0/x] \quad
    [i : \mathbb{N},\ v[i/x] : C[i/x]] \vdash v[\text{succ}\ i/x] : C[\text{succ}\ i/x]
  }{
    v[n/x] : C[n/x]
  }
  $$

- **解释**：这些规则可以看作是在表达式上执行适当的归约，而无需显式使用 $\in$ 类型。

**良基次序的定义**

- **良基次序的判定**：如果 $\text{Acc}(A, \prec) = A$，则关系 $\prec$ 在类型 $A$ 上是良基的。

---

##### **练习**

**7.35.** 证明在自然数上的次序“<”下，可达元素的集合就是自然数本身。

**7.36.** 给定 $A$ 和 $A'$ 上的次序 $\prec$ 和 $\prec'$，如何描述在积次序、字典序和和次序下，$A \wedge B$ 和 $A \vee B$ 中的可达元素？

---

##### **7.9.3 结论**

**两种方法的比较**

1. **Paulson 的方法（[Pau86]）**

   - **主要内容**：展示了类型理论 $TT$ 足够强大，可以定义许多良基关系上的递归算子。
   - **优势**：
     - 不需要对系统进行任何修改。
     - 增加了系统的模块化，因为无需为每个函数定义重复良基性的推导。

2. **Saaman 和 Chisholm 的方法（[SM87]）**

   - **主要内容**：引入了一个新的谓词“$\in$”，用于表示成员关系。
   - **潜在影响**：
     - 对系统的终止性等性质可能产生不确定的影响。
   - **优势**：
     - 声称可以大大简化 Paulson 方法中给出的证明对象。
     - 允许定义一些特殊的程序，例如根搜索程序。

---

##### **总结**

在本节中，我们探讨了如何在类型理论中引入**良基递归**。通过 Paulson 的方法，我们可以利用类型理论的内在力量，直接在系统中定义良基递归，而无需修改系统。这提高了系统的模块化和灵活性。

另一方面，Nordström 的方法通过引入可达元素的集合 $\text{Acc}(A, \prec)$，并使用类型理论规则来定义和处理这些元素。这种方法可能需要引入新的构造，如成员关系的内部表示，但也提供了定义函数和证明性质的新途径。

总的来说，这两种方法各有优劣，选择哪种方法取决于具体的应用需求和对系统性质的考虑。通过对它们的深入研究，我们可以更好地理解类型理论的扩展和应用，以及如何在不破坏系统关键性质的前提下，增强其表达能力。

---

### **如果您对上述内容有任何疑问，或者希望深入了解某个主题，请随时告诉我！**

### ----------------------------

### **第七章 增强类型理论**

---

#### **7.10 归纳类型**

---

##### **概览**

本节讨论了在类型理论中引入**归纳类型（Inductive Types）**的思想。归纳类型是通过**归纳定义（Inductive Definitions）**生成的类型，允许我们定义复杂的数据结构，如自然数、列表、树等。本节首先从非正式的角度介绍归纳定义，然后讨论如何在类型理论中形式化地处理这些定义。

我们将探讨两种主要的方法：

1. **集合论视角**：基于集合论的归纳定义，了解如何通过固定点（Fixed Point）构造最小解决方案。
2. **类型理论视角**：将归纳定义形式化为类型理论的规则，包括形成规则、引入规则和消解规则。

此外，我们还将讨论归纳定义与良基次序（Well-founded Orderings）之间的联系，以及如何在类型理论中验证归纳类型的单调性。

---

##### **7.10.1 归纳定义**

**非正式介绍**

我们以自然数的有限列表为例，来说明归纳类型的概念。

- **列表的非正式定义**：

  - 空列表 $[\ ]$ 是一个列表。
  - 如果 $n$ 是一个数字，$x$ 是一个列表，那么 $n :: x$ 也是一个列表。

- **解释**：

  - 类型 $L$ 包含 $[\ ]$，并且如果 $x \in L$，那么 $(n :: x) \in L$。
  - 我们的目标是构造最小的满足上述条件的集合 $L$。

**形式化定义**

- **固定点方程**：

  - 我们可以将 $L$ 定义为方程的最小解：

    $$
    L \equiv_{\text{df}} \{ [\ ] \} \lor (\mathbb{N} \land L)
    $$

  - 这里，$(\mathbb{N} \land L)$ 表示所有形如 $(n, x)$ 的元素，其中 $n \in \mathbb{N}$，$x \in L$。

- **说明**：

  - 我们将列表 $(n :: x)$ 表示为对 $(n, x)$。
  - 我们继续使用熟悉的记号 $(n :: x)$ 而不是对。

- **固定点操作符 $\Theta$**：

  - 定义操作符 $\Theta$ 为：

    $$
    \Theta T \equiv_{\text{df}} \{ [\ ] \} \lor (\mathbb{N} \land T)
    $$

  - 我们的目标是找到 $L$ 使得：

    $$
    L = \Theta L
    $$

**最小固定点**

- **单调性条件**：

  - 若 $\Theta$ 是单调的，即对于 $S \subseteq T$，有：

    $$
    \Theta S \subseteq \Theta T
    $$

  - 那么，方程 $T = \Theta T$ 存在最小解，即最小固定点。

- **构造最小固定点**：

  - 考虑集合序列：

    $$
    \Theta^0 \equiv_{\text{df}} \emptyset \\
    \Theta^{\alpha+1} \equiv_{\text{df}} \Theta (\Theta^\alpha)
    $$

  - 在某个极限序数 $\beta$ 处，我们有 $\Theta^{\beta+1} = \Theta^\beta$，此时 $\Theta^\beta$ 是 $\Theta$ 的最小固定点。

**归纳定义的意图**

- **目标**：

  - 我们希望 $L$ 是通过 $\Theta$ 操作符的迭代应用得到的最小集合。
  - 这意味着列表只能通过指定的方式生成，不能包含其他元素。

**构造递归函数**

- **定义递归函数**：

  - 为了定义一个函数 $\text{fix}\ g : \text{Fix}\ \Theta \rightarrow R$，我们需要一个函数：

    $$
    g : (T \rightarrow R) \rightarrow (\Theta T \rightarrow R)
    $$

  - 这个 $g$ 函数描述了如何从 $T$ 类型的元素的函数值，推导出 $\Theta T$ 类型的元素的函数值。

- **示例：求和函数**：

  - 定义函数 $\text{sum}$ 计算数值列表的和。

  - **定义 $g$**：

    $$
    g\ f\ [\ ] \equiv_{\text{df}} 0 \\
    g\ f\ (n, x) \equiv_{\text{df}} n + (f\ x)
    $$

  - **固定点函数 $\text{fix}\ g$** 满足：

    $$
    \text{fix}\ g\ [\ ] = 0 \\
    \text{fix}\ g\ (n, x) = n + (\text{fix}\ g\ x)
    $$

  - **计算规则**：

    $$
    (\text{fix}\ g) \rightarrow g\ (\text{fix}\ g)
    $$

**归纳定义与良基次序的联系**

- **元素的阶段**：

  - 定义元素进入集合的阶段：

    $$
    \| x \| \equiv_{\text{df}} \text{满足 } x \in \Theta^{\alpha+1} - \Theta^\alpha \text{ 的 } \alpha
    $$

- **定义次序**：

  - 定义 $x \prec y$ 当且仅当 $\| x \| < \| y \|$。

  - 该次序是良基的，因为它是序数上的次序的逆像。

- **解释**：

  - 这表明归纳定义的集合可以通过良基递归来表示，最终可以通过 W 类型来实现。

---

**练习**

**7.37.** 证明自然数的有限和无限列表的类型是方程 $L \equiv_{\text{df}} \{ [\ ] \} \lor (\mathbb{N} \land L)$ 的一个解。

- **解答**：

  - 无限列表包含了通过无限次应用 $\Theta$ 构造的元素，而最小固定点只包含有限次构造的元素，因此无限列表不满足最小固定点的要求。

**7.38.** 证明将 $T$ 映射为 $\{1\}$（如果 $0 \in T$）或 $\{0\}$（如果 $0 \notin T$）的操作符没有固定点。

- **解答**：

  - 因为操作符的输出仅取决于 $T$ 是否包含 $0$，无法找到一个 $T$ 使得 $T = \Theta T$。

**7.39.** 证明单调操作符的固定点集合的交集也是一个固定点，因此最小固定点存在。

- **解答**：

  - 设有一组固定点集合，其交集必然仍然满足 $T = \Theta T$，因此是最小固定点。

**7.40.** 给出自然数和树类型的固定点定义。

- **解答**：

  - **自然数**：

    $$
    \mathbb{N} \equiv_{\text{df}} \{ 0 \} \lor \text{succ}(\mathbb{N})
    $$

  - **树**：

    $$
    \text{Tree} \equiv_{\text{df}} \text{Leaf} \lor \text{Node}(\text{Tree}, \text{Tree})
    $$

**7.41.** 如何定义元素为自然数或列表本身的列表类型？

- **解答**：

  - 定义：

    $$
    L \equiv_{\text{df}} \{ [\ ] \} \lor (\mathbb{N} \lor L) \land L
    $$

**7.42.** 给出有限和可数序数的类型的固定点定义。

- **解答**：

  - 定义序数类型 $\text{Ord}$：

    $$
    \text{Ord} \equiv_{\text{df}} 0 \lor \text{succ}(\text{Ord}) \lor \text{lim}(\mathbb{N} \rightarrow \text{Ord})
    $$

---

##### **7.10.2 类型理论中的归纳定义**

**在类型理论中引入归纳类型**

- **条件**：当我们有一个单调的操作符 $\Theta : \text{Type} \rightarrow \text{Type}$ 时，可以构造归纳类型。

- **验证单调性的方法**：

  1. **语法限制法（[Dyb88]）**：

     - 如果 $T$ 在 $\Theta$ 中的出现是**正面的**，即 $T$ 不出现在任何函数或全称量化类型的**域**部分，那么操作符 $\Theta$ 是单调的。

     - 可以扩展到允许 $T$ 在域部分的**负面**出现。

  2. **显式验证法（[Men87b]）**：

     - 在规则中添加对单调性的显式检查，需要验证：

       $$
       T_1 \subseteq T_2 \implies \Theta[T_1 / T] \subseteq \Theta[T_2 / T]
       $$

     - 为此，需要在系统中添加新的判断形式 $T_1 \subseteq T_2$ 及其规则。

- **两种方法的关系**：它们是互补的，可以结合使用。

**归纳类型的规则**

1. **形成规则（IndF）**：

   $$
   \frac{
     \Theta\ \text{单调}
   }{
     \text{Fix}\ \Theta\ \text{是一个类型}
   }
   $$

   - **解释**：当 $\Theta$ 单调时，固定点 $\text{Fix}\ \Theta$ 是一个类型。

2. **类型等价规则（Type Equality Rule for Ind）**：

   $$
   \text{Fix}\ \Theta \rightarrow \Theta (\text{Fix}\ \Theta) \quad (7.26)
   $$

   - **解释**：固定点类型等价于应用操作符 $\Theta$ 于自身。

   - **应用**：这条规则足以给出通常的引入规则。例如，对于列表类型：

     - 由于 $[\ ] : \Theta (\text{Fix}\ \Theta)$，根据 (7.26)，$[\ ] : \text{Fix}\ \Theta$。

     - 类似地，如果 $n : \mathbb{N}$，$x : \text{Fix}\ \Theta$，那么 $(n :: x) : \text{Fix}\ \Theta$。

3. **消解规则（IndE）**：

   $$
   \frac{
     [ T \subseteq \text{Fix}\ \Theta ] \quad
     g : (\forall x : T). C \implies (\forall y : \Theta T). C[y / x]
   }{
     \text{fix}\ g : (\forall z : \text{Fix}\ \Theta). C[z / x]
   }
   $$

   - **解释**：为了定义函数 $\text{fix}\ g$，需要给出函数 $g$，它描述了如何从 $T$ 类型的元素的值推导出 $\Theta T$ 类型的元素的值。

4. **计算规则（Computation Rule for Ind）**：

   $$
   \text{fix}\ g \rightarrow g\ (\text{fix}\ g)
   $$

   - **解释**：递归函数的值通过应用 $g$ 于自身来计算。

**类型理论中的示例**

- **列表、树和 W 类型**：这些类型都可以通过上述归纳定义机制来定义。

- **参数化的定义（[Men87b]）**：

  - **意义**：允许通过**同时递归**来定义类型，可以将类型视为谓词。

  - **示例：根搜索程序**：

    - 定义：

      $$
      \text{Root}\ f\ n \equiv_{\text{df}} (f\ n = 0) \lor (\text{Root}\ f\ (n + 1))
      $$

    - **解释**：定义了一个关于 $n : \mathbb{N}$ 的类型族，表示函数 $f$ 在大于等于 $n$ 的某个位置有根。

    - **特点**：在定义中，谓词依赖于值 $n$，但不需要使用宇宙类型 $U_i$。

**传统引入和消解规则**

- **[Dyb88] 的观点**：

  - 在许多情况下，可以从操作符 $\Theta$ 中直接读出类型的传统引入和消解规则。

  - **例如**：如果 $\Theta$ 是表达式的积与和，那么它类似于 Miranda 等语言中的代数类型定义。

  - **形式**：

    ```
    ty ::= con1 t11 ... t1k |
           con2 t21 ... t2l |
           ...
    ```

  - **解释**：每个求和项对应一个构造器，每个构造器参数或乘积组件对应一个选择器。

**归纳类型的表示**

- **使用 W 类型表示**：

  - 可以在类型理论 $TT$ 中使用 W 类型来表示这些归纳定义的集合。

  - **结果**：如果类型理论具有外延等式，这种表示是同构的。

**潜在的问题**

- **类型等式的不可判定性**：

  - 引入这些类型后，类型之间的等式可能变得不可判定。

  - **解决方案**：可以采用更严格的等式概念，如名称等式（[Ten79]），但这可能与系统的其余部分冲突，因为系统中通常维护类型的结构等式。

---

**练习**

**7.43.** 根据 (IndE) 给出的列表的归纳规则是什么？与第 5.10 节中给出的规则进行比较。

- **解答**：

  - 根据 (IndE)，列表的归纳规则需要定义一个函数 $g$，并使用 $\text{fix}\ g$ 来定义递归函数。

  - 与第 5.10 节中的规则类似，但 (IndE) 更为通用，允许对任意归纳类型进行处理。

**7.44.** 使用第 7.2 节给出的集合规则，推导一个类型为 $\{ f : \mathbb{N} \rightarrow \mathbb{N} \mid (\exists n : \mathbb{N}). (\text{Root}\ f\ n) \} \rightarrow (\exists n : \mathbb{N}). I(\mathbb{N}, f n, 0)$ 的根搜索程序。

- **解答**：

  - 利用归纳定义的 $\text{Root}\ f\ n$ 以及子集类型，可以构造一个函数，找到使 $f n = 0$ 的最小 $n$。

**7.45.** 对于类型 $A$ 上的二元关系 $R$，给出其传递闭包和扩展 $R$ 的最小等价关系的归纳定义。

- **解答**：

  - **传递闭包 $R^+$**：

    - 定义为最小关系，使得：

      - 如果 $x R y$，则 $x R^+ y$。

      - 如果 $x R^+ y$ 且 $y R^+ z$，则 $x R^+ z$。

  - **最小等价关系 $E$**：

    - 定义为最小等价关系，使得：

      - 如果 $x R y$，则 $x E y$。

**7.46.** （对于逻辑学家）给定一阶算术的形式系统 $F$，给出系统中可证明的定理集合的归纳定义。解释如何在类型理论中给出该系统的解释，并写出在该解释下有效的 $F$ 的公式的归纳定义。

- **解答**：

  - **可证明定理的集合**：

    - 定义为包含公理，并闭合于推理规则下的最小集合。

  - **在类型理论中的解释**：

    - 将一阶算术的项、公式和证明映射到类型理论中的对应对象。

    - 使用归纳定义，定义公式的有效性，即在给定解释下成立的公式。

---

##### **总结**

在本节中，我们深入探讨了**归纳类型**在类型理论中的引入和形式化。归纳类型通过**归纳定义**生成，允许我们构造复杂的数据结构，并在类型理论中进行严格的处理。

主要内容包括：

- **归纳定义的形式化**：通过固定点方程和单调操作符 $\Theta$ 来构造最小的解决方案。

- **类型理论中的规则**：定义了归纳类型的形成规则、类型等价规则、消解规则和计算规则。

- **验证单调性的方法**：讨论了语法限制法和显式验证法两种方法。

- **归纳类型的示例**：列表、树、W 类型，以及如何使用参数化的定义来构造更复杂的类型。

- **归纳定义与良基次序的联系**：展示了归纳定义的集合如何与良基次序相关联。

通过这些讨论，我们了解了如何在类型理论中有效地引入和使用归纳类型，以及在处理复杂数据结构和证明中，它们的重要性和应用价值。

---

### **如果您对上述内容有任何疑问，或者希望深入了解某个主题，请随时告诉我！**

### --------------------
### **第七章 增强类型理论**

---

#### **7.11 余归纳（Co-inductions）**

---

##### **概览**

在编程语言中，尤其是那些支持惰性求值（lazy evaluation）的语言，如 Miranda、Haskell 等，我们常常处理**无限数据结构**，如无限列表。这些语言允许我们定义和操作无限列表，如素数序列或自然数序列。在类型理论中，由于其**完全性（totality）**的特性，即所有函数都必须对所有输入终止并给出输出，我们无法直接引入部分定义的数据项。这给处理无限数据结构带来了挑战。

本节将探讨如何在类型理论中引入**余归纳类型（Co-inductive Types）**，使我们能够定义包含无限对象的类型，而不需要引入部分定义的数据项。我们将以**无限列表**为例，展示如何通过**余归纳定义**（co-inductive definitions）或**最大不动点**（greatest fixed points）来构建这些类型。

---

##### **惰性求值和无限列表**

**惰性求值的概念：**

- 在一些编程语言中，函数的求值是惰性的，即只有在需要时才计算表达式的值。
- 这允许我们定义无限的数据结构，因为只要我们不完全展开它们，就不会导致非终止计算。

**无限列表的示例：**

- 在 Miranda 等语言中，可以定义一个无限的素数列表：
  
  ```
  2 :: 3 :: 5 :: 7 :: 11 :: ...
  ```

- 这样的列表实际上是一个无限的数据结构，但由于惰性求值，我们可以按需处理其中的元素。

**在类型理论中的问题：**

- 类型理论强调完全性，所有函数必须在有限时间内给出结果。
- 因此，无法直接处理部分定义或无限的数据结构。

---

##### **余归纳定义和最大不动点**

**无限列表的定义方式：**

- 与有限列表不同，我们无法通过构造器和基本元素来定义无限列表。
- 相反，我们关注的是如何**解构**无限列表，即将其分解为头部和尾部，而尾部又是一个无限列表。

**无限列表的方程：**

- 定义无限列表 $I$：
  
  $$
  I \equiv_{\text{df}} \mathbb{N} \land I \quad (7.27)
  $$
  
- 这表示一个无限列表可以看作一个自然数（头部）和另一个无限列表（尾部）的对。

**最大不动点：**

- 方程 $I \equiv \mathbb{N} \land I$ 有多个解，其中最小的解是空集 $\emptyset$。
- 为了捕获所有可能的无限列表，我们需要选择**最大的解**，即操作符 $I$ 的最大不动点。

**定义最大不动点：**

- 定义操作符 $I$：
  
  $$
  I\ I \equiv_{\text{df}} \mathbb{N} \land I
  $$
  
- 最大不动点包含所有满足方程的元素，包括无限列表。

---

##### **定义无限列表和函数**

**定义无限列表：**

- 我们需要确保任何定义的列表都是类型 $I$ 的成员，并且不引入部分性（partiality）。
- 例如，定义一个无限的全是 1 的列表：

  $$
  \text{ones} \equiv_{\text{df}} 1 :: \text{ones}
  $$
  
- 右侧的定义确保了列表有明确的头部，并且递归地定义了尾部。

**更复杂的定义：**

- 定义一个从 $n$ 开始的自然数序列：
  
  $$
  \text{fromn} \equiv_{\text{df}} n :: \text{from}_{n+1}
  $$
  
- 这实际上是同时定义了一系列列表，每个列表都有一个明确的头部，尾部通过递归定义。

**使用参数化的定义：**

- 定义一个函数，将函数 $f : \mathbb{N} \rightarrow \mathbb{N}$ 转换为无限列表：
  
  $$
  \text{makel}_f \equiv_{\text{df}} (f\ 0) :: \text{makel}_{f'}
  $$
  
- 其中，$f'$ 定义为：
  
  $$
  f'\ n \equiv_{\text{df}} f(n + 1)
  $$
  
- 这同时定义了无穷多个无限列表，每个列表都有明确的头部。

**总结定义模式：**

- 我们通过定义一个递归方程，其中右侧保证了列表的头部是已定义的，尾部通过递归定义。
- 这种定义方式确保了列表在任何有限的展开下都是可计算的。

---

##### **余归纳类型的规则**

**引入规则（CoinI）：**

- 为了正式化余归纳定义，我们使用以下规则：

  $$
  \frac{
    d : D \quad
    [ y : D,\ z : D \rightarrow T ] \vdash b : \Psi\ T
  }{
    \text{xif}_{y,z}\ b\ d : \text{Xif}\ \Psi
  }
  $$

- **解释：**
  
  - $D$ 是参数的域，$T$ 是类型。
  - 我们需要构造一个 $b : \Psi\ T$，然后通过 $\text{xif}_{y,z}\ b\ d$ 来构造余归纳类型的元素。

**形成规则（CoinF）：**

- 定义余归纳类型的形成规则：

  $$
  \frac{
    \Psi\ \text{单调}
  }{
    \text{Xif}\ \Psi\ \text{是一个类型}
  }
  $$

- **解释：**
  
  - 当操作符 $\Psi$ 是单调的时，$\text{Xif}\ \Psi$ 是一个类型。

**计算规则（Computation Rule for Coin）：**

- 计算 $\text{xif}$ 对象的规则：

  $$
  \text{xif}_{y,z}\ b\ d \rightarrow b[d / y,\ \lambda w.(\text{xif}_{y,z}\ b\ w) / z]
  $$

- **解释：**
  
  - 在展开递归时，函数 $z$ 被替换为递归定义的对象族 $\lambda w.(\text{xif}_{y,z}\ b\ w)$。

**消解规则：**

- 对于余归纳类型，方程 $I \equiv \mathbb{N} \land I$ 起到了**消解规则**的作用。

  $$
  l : \text{Xif}\ I \implies l : I (\text{Xif}\ I) \quad (7.28)
  $$

- **解释：**
  
  - 如果 $l : \text{Xif}\ I$，则可以将其视为类型 $I$ 的元素，即可以解构为头部和尾部。

---

##### **在余归纳类型上定义函数**

**递归的区别：**

- 在归纳类型上，递归定义的函数是基于对更简单对象的函数值。
- 在余归纳类型上，递归定义的是类型的**个体对象**，而不是直接定义函数。

**定义函数的方法：**

1. **使用选择器函数：**

   - 由于方程 (7.28) 的存在，我们可以定义头部和尾部的选择器函数。
   - 例如，定义一个函数获取无限列表的第 $n$ 个元素：

     $$
     \text{index}\ n\ [a_0, a_1, \dots, a_n, \dots] \equiv_{\text{df}} a_n
     $$

   - 这种函数可以通过对参数 $n : \mathbb{N}$ 进行递归或同时对所有无限列表进行递归来定义。

2. **使用完全递归定义：**

   - 例如，定义一个映射函数：

     $$
     \text{mapi}\ f\ (a :: x) \equiv_{\text{df}} (f\ a) :: \text{mapi}\ f\ x
     $$

   - 这个定义同时对所有无限列表 $l$ 定义了 $\text{mapi}\ f\ l$。

**定义其他函数：**

- 定义前 $n$ 个元素的和：

  $$
  \text{sumi}\ n\ [a_0, a_1, \dots, a_n, \dots] \equiv_{\text{df}} a_0 + a_1 + \dots + a_n
  $$

- 这些函数可以通过对 $n$ 进行递归或对无限列表进行同时递归来定义。

---

##### **可定义的其他类型**

**有限和无限列表：**

- 我们可以定义包含有限和无限列表的类型，即操作符 $L$ 的最大不动点。

- 这种类型允许我们处理既可能有限又可能无限的列表。

**无限树等类型：**

- 类似地，可以定义无限树等其他数据结构。

---

##### **高级函数的定义**

**带有证明信息的函数：**

- 如果我们愿意在域中加入一些**证明论信息**，可以定义更复杂的函数。

- 例如，定义一个将字符流拆分为单词流的函数，每当遇到空白字符就拆分。

- 由于无法保证所有无限列表都满足条件（如无限多次出现空白字符），我们只能在满足特定条件的列表上定义此函数。

- 我们可以通过**存在量词**或**子集类型**精确描述这类列表，然后定义相应的函数。

---

##### **关于等式的讨论**

**内涵等式（Intensional Equality）：**

- 如果采用内涵等式，那么只有在以相同方式定义的两个无限列表才被认为相等。

- 这在类型理论中是常见的，因为对象的身份与其构造方式相关。

**外延等式（Extensional Equality）：**

- 另一种方法是采用外延等式，即如果两个无限列表的所有对应元素都相等，则认为它们相等：

  $$
  l \cong l' \iff (\forall n : \mathbb{N}). (\text{index}\ n\ l = \text{index}\ n\ l')
  $$

- 这种方法在 Miranda 的逻辑中被采用（[Tho89b]），并且可以通过对 Miranda 的指称语义进行证明。

---

##### **结论**

通过引入**余归纳定义**和**最大不动点**，我们可以在类型理论中处理无限数据结构，如无限列表，而无需引入部分定义的数据项。这使得我们能够保留惰性求值语言中处理无限列表的许多优势。

具体来说，我们可以：

- 定义无限列表和其他无限数据结构。
- 在这些类型上定义函数，包括映射、取值、求和等。
- 模拟惰性求值的行为，按需计算数据结构的部分内容。

---

##### **练习**

**7.47.** 给出上述定义的函数 $\text{mapi}$、$\text{sumi}$ 和 $\text{index}$ 的形式定义。

- **解答：**

  - **$\text{mapi}$ 的定义：**

    $$
    \text{mapi}\ f\ (a :: x) \equiv_{\text{df}} (f\ a) :: \text{mapi}\ f\ x
    $$

  - **$\text{sumi}$ 的定义：**

    $$
    \text{sumi}\ n\ l \equiv_{\text{df}} \begin{cases}
      0 & \text{如果 } n = 0 \\
      \text{head}(l) + \text{sumi}\ (n - 1)\ (\text{tail}(l)) & \text{如果 } n > 0
    \end{cases}
    $$

  - **$\text{index}$ 的定义：**

    $$
    \text{index}\ n\ l \equiv_{\text{df}} \begin{cases}
      \text{head}(l) & \text{如果 } n = 0 \\
      \text{index}\ (n - 1)\ (\text{tail}(l)) & \text{如果 } n > 0
    \end{cases}
    $$

**7.48.** 定义以下函数：

- $\text{iterate}\ f\ \text{st} \equiv_{\text{df}} [\ \text{st},\ f\ \text{st},\ f(f\ \text{st}),\ \dots\ ]$
- $\text{infold}\ f\ \text{st}\ [a_0, a_1, \dots, a_n, \dots] \equiv_{\text{df}} [\ \text{st},\ f\ \text{st}\ a_0,\ f(f\ \text{st}\ a_0)\ a_1,\ \dots\ ]$

- **解答：**

  - **$\text{iterate}$ 的定义：**

    $$
    \text{iterate}\ f\ \text{st} \equiv_{\text{df}} \text{st} :: \text{iterate}\ f\ (f\ \text{st})
    $$

  - **$\text{infold}$ 的定义：**

    $$
    \text{infold}\ f\ \text{st}\ (a :: l) \equiv_{\text{df}} \text{st} :: \text{infold}\ f\ (f\ \text{st}\ a)\ l
    $$

**7.49.** 定义一个合并两个无限列表的函数，移除在两个列表中都出现的重复项，并在列表有序的情况下保持顺序。使用此函数和前面的 $\text{iterate}$ 函数，定义按升序列举的 Hamming 数列表。

- **解答：**

  - **合并函数的定义（假设列表有序）：**

    $$
    \text{merge}\ l_1\ l_2 \equiv_{\text{df}} \begin{cases}
      a :: \text{merge}\ l_1'\ l_2 & \text{如果 } a < b \\
      b :: \text{merge}\ l_1\ l_2' & \text{如果 } a > b \\
      a :: \text{merge}\ l_1'\ l_2' & \text{如果 } a = b
    \end{cases}
    $$

    其中，$a$ 是 $l_1$ 的头部，$b$ 是 $l_2$ 的头部，$l_1'$ 和 $l_2'$ 是各自的尾部。

  - **定义 Hamming 数列表：**

    - 定义基本列表：

      $$
      H_2 \equiv_{\text{df}} \text{iterate}\ (\lambda x. x \times 2)\ 1 \\
      H_3 \equiv_{\text{df}} \text{iterate}\ (\lambda x. x \times 3)\ 1 \\
      H_5 \equiv_{\text{df}} \text{iterate}\ (\lambda x. x \times 5)\ 1
      $$

    - 合并这些列表：

      $$
      H \equiv_{\text{df}} \text{merge}\ H_2\ (\text{merge}\ H_3\ H_5)
      $$

**7.50.** 给出素数列表的定义。

- **解答：**

  - 可以使用**埃拉托色尼筛法**定义素数列表：

    $$
    \text{primes} \equiv_{\text{df}} \text{sieve}\ (\text{iterate}\ (\lambda x. x + 1)\ 2)
    $$

  - 其中，筛选函数 $\text{sieve}$ 定义为：

    $$
    \text{sieve}\ (p :: xs) \equiv_{\text{df}} p :: \text{sieve}\ (\text{filter}\ (\lambda x. x \mod p \neq 0)\ xs)
    $$

**7.51.** 为有限和无限列表编写一个通用的映射函数 $\text{map}$。

- **解答：**

  - 定义：

    $$
    \text{map}\ f\ [\ ] \equiv_{\text{df}} [\ ] \\
    \text{map}\ f\ (a :: l) \equiv_{\text{df}} (f\ a) :: \text{map}\ f\ l
    $$

  - 这个定义适用于有限和无限列表。

**7.52.** 为什么无法在无限列表上定义类似于有限列表的过滤函数 $\text{filter}$？你能否在有限和无限列表的类型上定义一个？

- **解答：**

  - **原因：**

    - 在无限列表上，过滤函数可能会因为一直等待满足条件的元素而永远不会产生输出，即可能无法保证输出的列表是无限的。

  - **解决方案：**

    - 在有限和无限列表的类型上，可以定义一个过滤函数，但需要注意其可能的部分性。

**7.53.** 给出前面讨论的拆分函数的类型和定义。

- **解答：**

  - **类型：**

    $$
    \text{split} : \{ l : \text{InfiniteList} \mid \text{infinitely many spaces in } l \} \rightarrow \text{InfiniteList of Words}
    $$

  - **定义：**

    - 利用递归，在遇到空格字符时拆分列表。

---

##### **7.11.1 流（Streams）**

**无限列表在流模型中的应用**

**进程间通信的模型：**

- 在编程中，我们可以使用无限列表来建模进程间的通信流。

- 例如，考虑图 7.1 中的系统，其中三个进程通过三条通道 $l_0, l_1, l_2$ 通信。

**类型理论中的处理：**

- 在类型理论的上下文中，定义这些通信流需要通过互相递归地定义 $l_0, l_1, l_2$。

- 由于余归纳类型的性质，我们必须确保每个列表至少有一个头部，这意味着我们不能有死锁（deadlock）。

**死锁的避免：**

- 在 Miranda 等语言中，可以定义导致死锁的进程网络，例如每个进程都将其输入复制到输出。

- 但在类型理论中，由于余归纳定义的限制，无法定义这样的死锁系统。

- 这保证了如果系统可以被定义，那么它要么会一直运行下去，要么会正常终止，而不会死锁。

---

##### **练习**

**7.54.** 使用类型为无限列表的类型，给出哲学家就餐问题的解决方案。

- **解答：**

  - 哲学家就餐问题涉及多个进程（哲学家）和资源（叉子）。

  - 可以使用无限列表来模拟哲学家和叉子之间的交互，确保资源的正确分配，避免死锁。

  - 具体实现需要定义哲学家进程和叉子进程的通信流，利用余归纳类型的性质确保系统的正确性。

---

##### **总结**

通过引入**余归纳类型**，我们在类型理论中获得了处理无限数据结构的能力，类似于惰性求值语言中的无限列表。余归纳定义允许我们定义无限列表、无限树等数据结构，并在其上定义各种函数。

主要内容包括：

- **余归纳定义的原理**：通过最大不动点来定义类型，确保包含所有可能的无限对象。

- **函数的定义**：使用选择器函数和完全递归定义在余归纳类型上定义函数。

- **应用**：在流模型中模拟进程间的通信，避免死锁。

- **等式的讨论**：探讨内涵等式和外延等式在余归纳类型上的应用。

通过这些内容，我们看到了类型理论的强大之处，即使在强调完全性的系统中，也能够处理无限的数据结构，并保留许多编程语言中的实用特性。

---

### **如果您对上述内容有任何疑问，或者希望深入了解某个主题，请随时告诉我！**
### -------------------------
### **第七章 增强类型理论**

---

#### **7.12 部分对象和类型**

---

##### **概览**

本节讨论了在类型理论中引入**非终止**或**部分定义**（partial）对象的各种提议。这些对象可能不会在有限时间内计算出结果，或者在某些情况下可能没有定义。我们将探讨直接允许非受限递归的朴素方法，以及其他更复杂的方法，来将部分对象引入类型理论。讨论的核心是如何在不破坏类型理论的逻辑一致性的前提下，引入这些部分对象。

---

##### **引入部分对象的朴素方法**

**朴素提议：**

- **允许非受限递归**，从而在类型理论系统 $TT_0$ 等中引入非终止计算。
- 这使得类型理论更接近于当前的编程语言系统，如 Miranda 和 Haskell。

**优点：**

- **编程语言的视角：**
  - 允许程序员编写具有无限循环或非终止行为的程序。
  - 提高了语言的表达能力，能够描述更多的算法和数据结构。

**问题：**

- **逻辑解释的丧失：**
  - 在类型理论中，每个类型都是一个命题，类型的元素是该命题的证明。
  - 引入非终止计算后，存在一个**未定义的对象**（通常记为 $\uparrow$ 或底元素 $\bot$），它是**每个类型的成员**。
  - 这导致逻辑解释的不一致，因为任何命题都可以通过 $\uparrow$ 来证明，即：
    $$
    \forall A, \uparrow : A
    $$
  - **结果：** 系统中每个公式都是可证明的，这显然是不可接受的。

**对归纳原理的影响：**

- **归纳原理需要修改：**
  - 由于类型中包含了额外的元素（如 $\uparrow$），传统的归纳原理不再适用。
  - 必须调整归纳证明的方法，以考虑类型中可能的未定义元素。

**参考文献：**

- **[Pau87] 和 [Tho89b]** 中详细讨论了如何进行这种修改。

---

##### **逻辑解释的可能性**

**问题的提出：**

- **是否可以为包含部分对象的系统提供逻辑解释？**

**可能的解决方案：**

- **识别“完全”的证明对象：**
  - 如果我们能够**精确地识别**哪些对象代表“完全”的（total）而非“部分”的（partial）证明，那么就有可能恢复逻辑解释。
  - **完全对象**：在有限时间内计算出结果的对象，即传统类型理论中的对象。
  - **部分对象**：可能永远无法计算出结果的对象，如无限递归或未定义的值。

**在简单类型上的应用：**

- **Miranda 逻辑的示例：**
  - 在简单类型上，可以通过某种方式区分完全对象和部分对象。
  - 但对于更复杂的类型，如 $( \mathbb{N} \rightarrow \mathbb{N} ) \rightarrow ( \mathbb{N} \rightarrow \mathbb{N} )$，如何定义完全对象的概念是有挑战性的。

**研究方向：**

- **探索如何在整个系统中准确地定义和使用完全对象和部分对象的逻辑解释，是一个有趣的研究项目。**

---

##### **一种不同的方法：引入部分类型**

**[CS87] 的提议：**

- **引入新的类型 $T^\bot$**：
  - $T^\bot$ 包含了类型 $T$ 的**计算过程**，即可能部分定义的对象。
  - 这些对象可能会也可能不会产生类型 $T$ 中的值。

**与朴素方法的区别：**

- **优势：**
  - **描述能力更强**：能够区分不同程度的函数定义和计算过程。
  - **精细的类型区分**：可以在类型层面区分完全函数、部分函数，以及它们之间的关系。

**示例：**

- **区分不同类型的数值函数：**

  考虑以下类型，它们都是从自然数到自然数的函数，但类型不同：

  1. **完全函数类型**：$\mathbb{N} \rightarrow \mathbb{N}$
  2. **部分函数类型**：$\mathbb{N} \rightarrow \mathbb{N}^\bot$
  3. **可能不终止的函数类型**：$\mathbb{N}^\bot \rightarrow \mathbb{N}$
  4. **其他组合类型**：$\mathbb{N}^\bot \rightarrow \mathbb{N}^\bot$

- **解释：**

  - 每个类型表示不同的函数概念，体现了函数在定义和计算过程中的差异。

**探索类型之间的关系：**

- **嵌入关系：**

  - 通过研究哪些类型之间存在嵌入，可以理解它们之间的关系。
  - 例如，完全函数可以看作是部分函数的子集。

- **反例：**

  - 如果无法在两个类型之间建立嵌入，那么可以通过构造反例来说明它们之间的区别。

**基本关系：**

- **从 $T$ 到 $T^\bot$：**

  - 类型 $T$ 的成员也是 $T^\bot$ 的成员。
  - 这意味着完全定义的对象也可以被视为部分对象。

- **从 $T^\bot$ 到 $T$：**

  - 如果 $T^\bot$ 的一个元素被证明具有**规范形式**（canonical form），即它确实是一个完全定义的对象，那么它属于 $T$。

**显式推理终止性：**

- **引入成员关系 $a \in A$**：

  - 为了能够明确地对终止性进行推理，需要引入成员关系。
  - 这类似于之前第 7.9.2 节讨论的内容。

---

##### **部分类型中的元素：参数化的一般递归**

**引入方式：**

- **使用参数化的一般递归来引入部分类型的元素：**

  - 定义一个对象 $f$ 类型为 $A \rightarrow B$，其定义依赖于自身。

- **形式化规则：**

  **引入规则（recI）：**

  $$
  \frac{
    [q : A \rightarrow B] \quad
    \vdots \quad
    f : A \rightarrow B
  }{
    \text{rec}\ q\ f : A \rightarrow B
  }
  $$

  - **解释：**
    - 我们在假设 $q : A \rightarrow B$ 的情况下，定义 $f : A \rightarrow B$。
    - 然后，通过 $\text{rec}\ q\ f$ 得到递归定义的函数。

- **计算规则：**

  $$
  \text{rec}\ q\ f \rightarrow f [ (\text{rec}\ q\ f) / q ]
  $$

  - **解释：**
    - 在计算中，将 $q$ 替换为 $\text{rec}\ q\ f$ 本身，实现递归调用。

---

##### **关于递归定义函数的推理**

**存在多种归纳规则：**

- **分类：**

  1. **基于计算结构的推理：**
     - 我们可以根据导致结果的计算过程的结构来进行推理。
     - 这些规则有多种形式，与第 7.9 节中的规则有明显的联系。

  2. **固定点归纳法：**
     - 我们可以添加固定点归纳法（fixed point induction）的规则，但只能应用于**可接受的谓词**（admissible predicates）。
     - 参考 [Pau87]。

**挑战：**

- **在类型理论中应用的困难：**

  - 当存在宇宙类型时，类型可能有非规范形式。
  - 这给在类型理论中精确地应用这些归纳规则带来了困难。

**进一步讨论：**

- **关于这些点的详细讨论：**

  - 这些问题的进一步讨论，以及添加这些类型的理由，以及它们与经典递归理论的联系，可以在 [CS87] 和 [Smi88] 中找到。

---

##### **总结**

本节探讨了在类型理论中引入部分对象和类型的方法，以及由此带来的挑战和可能的解决方案。

- **朴素方法的问题：**

  - 直接允许非受限递归和非终止计算会破坏类型理论的逻辑一致性。

- **引入部分类型的方法：**

  - 通过引入包含计算过程的类型 $T^\bot$，我们可以更精细地描述部分对象。

- **推理和归纳规则：**

  - 为了在这样的系统中进行有效的推理，需要引入新的归纳规则和证明方法。

- **研究前景：**

  - 进一步研究如何在类型理论中准确地定义和使用部分对象，以及保持系统的逻辑一致性和强规范化性质，是一个重要的研究方向。

---

### **如果您对上述内容有任何疑问，或者希望深入了解某个主题，请随时告诉我！**
### ----------------------
**概览**

本节讨论了在类型理论中引入非终止或“部分”对象的概念，以及如何处理由此带来的逻辑解释和系统一致性的问题。我们探讨了将非终止计算纳入系统的方法，讨论了这些方法对逻辑解释的影响，以及如何在类型理论中建模特定的数学结构，例如半群。通过比较不同的方法，我们了解了在类型理论中建模的挑战和可能的解决方案。

---

**详细解释**

### 7.12 部分对象和类型

**引入部分对象的动机**

在类型理论的文献中，有许多提议尝试将非终止或“部分”对象添加到类型理论中。一个直接的想法是允许在系统 TT 或 TT₀ 中进行不受限制的递归，从而引入非终止的计算。

**对编程语言的影响**

作为一种编程语言，这使得系统更接近于当前的编程语言，例如 Miranda 和 Haskell。然而，这也会导致我们似乎失去了系统的逻辑解释。

**逻辑解释中的问题**

因为未定义的对象（通常记为 ↑，在指称语义的文献中令人困惑地记为 ⊥）是每个类型的成员，这导致了逻辑解释的不一致。因为每个公式都可以通过证明 ↑ 来证明。此外，像归纳这样的原则必须修改，以考虑到类型（如自然数 N）中的额外成员。有关如何进行这些修改的详细信息，可以在 [Pau87] 和 [Tho89b] 中找到。

**是否可以给出逻辑解释？**

那么，能否给这样的系统提供逻辑解释呢？似乎至少有这样的可能性，如果我们能够精确地识别那些代表“完全”而非“部分”证明的对象。对于简单类型，类似 Miranda 的逻辑展示了如何识别完全对象，但对于更复杂的类型，例如：

$$
(N \Rightarrow N) \Rightarrow (N \Rightarrow N)
$$

在确定哪些对象应该被视为完全对象时，我们有不同的选择。探索这样一个逻辑解释如何工作的研究项目将是非常有趣的。

**不同的建议**

在 [CS87] 中提出了一种完全不同的方法，它取代了早期在 [C+86a] 第12.2节中讨论的部分类型版本。该建议提出添加类型 $T^\uparrow$，它由 $T$ 的元素的计算组成，这些部分对象可能会也可能不会在类型 $T$ 中产生值。

**这种方法的优势**

与直接的方法相比，这种方法的优势在于它提供的描述能力。例如，我们可以区分以下数值函数的类型：

$$
\begin{align*}
& N \Rightarrow N \\
& N \Rightarrow N^\uparrow \\
& N^\uparrow \Rightarrow N \\
& N^\uparrow \Rightarrow N^\uparrow \\
& N^\uparrow \Rightarrow N \\
& N \Rightarrow N^\uparrow
\end{align*}
$$

每个类型都是有意义的，并体现了从 $N$ 到 $N$ 的不同函数概念。

**探索类型之间的关系**

发现这些类型之间的关系是一个启发性的练习，可以通过找到它们之间存在的嵌入（embeddings），以及通过找到适当的反例来展示哪些嵌入不存在。

**类型之间的基本关系**

一个基本的关系是 $T$ 的成员也是 $T^\uparrow$ 的成员；反过来，如果 $T^\uparrow$ 的一个元素被证明具有规范形式，那么它就在 $T$ 中。为了明确地推理终止性，我们需要引入成员谓词 $a \in A$，如前面第7.9.2节所述。

**引入部分类型的元素**

部分类型的元素是通过参数化的通用递归引入的，其中类型为 $A \Rightarrow B$ 的对象 $f$ 是用它自身定义的：

$$
\begin{array}{l}
[q : A \Rightarrow B] \\
\quad \vdots \\
\quad f : A \Rightarrow B \\
\text{rec}_q f : A \Rightarrow B \quad (\text{recI})
\end{array}
$$

**相关的计算规则**

相关的计算规则是：

$$
\text{rec}_q f \rightarrow f[\text{rec}_q f / q]
$$

这意味着 $\text{rec}_q f$ 计算为 $f$，其中所有 $q$ 都被替换为 $\text{rec}_q f$。

**关于递归函数的归纳规则**

有许多归纳规则允许我们对这些递归定义的函数进行证明。它们分为两类：

1. **关于导致结果的计算结构的推理**：这个规则有多种形式化方式，显然与前面第7.9节的规则有联系。

2. **固定点归纳规则**：只能应用于可接受的谓词（见 [Pau87]）。在类型理论中，这并不容易，因为在存在宇宙（universes）的情况下，我们可以有非规范形式的类型。

关于这些要点的进一步讨论、添加这些类型的理由以及它们与经典递归理论的联系，可以在 [CS87] 和 [Smi88] 中找到。

### 7.13 建模

**引入**

到目前为止，我们已经看到了系统的通用扩展；对于个人而言，手头的问题通常是建模少量特定类型的对象，例如群、栈、记录等。两种方法建议如下：

- **在类型理论中构建对象的模型**：例如，作为一系列抽象数据类型。
- **使用描述对象的新规则来扩展系统**

**方法的比较**

在 [Dyc85] 中探讨了这些方法之间的对比，该文献研究了如何建模初等范畴理论直到自然变换的水平。我们在这里看一个更简单的例子，即半群。

**半群的定义**

**定义 7.17** 半群是一个集合 $A$ 以及在 $A$ 上的一个**结合**运算 $\ast$。一个**单位元** $\iota$ 满足对于所有 $a \in A$：

$$
a \ast \iota = a = \iota \ast a
$$

一个元素 $a$ 的**逆元** $a^{-1}$ 满足：

$$
a \ast a^{-1} = \iota = a^{-1} \ast a
$$

**将半群建模为抽象数据类型**

我们可以如下将半群类建模为抽象数据类型。首先，我们定义公式 $\text{Semi}\ A\ \ast$ 为：

$$
(\forall a, b, c : A).\ ((a \ast b) \ast c = a \ast (b \ast c))
$$

这个公式表达了运算 $\ast$ 的结合性。这个类型的元素是函数 $f$，其中 $f\ a\ b\ c$ 提供了在三元组 $(a, b, c)$ 上结合性的证明。

然后，我们定义半群类：

$$
\text{Semigroup} \equiv_{\text{df}} (\exists A : U_0).\ (\exists \ast : A \Rightarrow A \Rightarrow A).\ (\text{Semi}\ A\ \ast)
$$

这个类型的元素是三元组 $(A, (\ast, f))$，其中 $f$ 如上所述。

**关于半群的基本结果：单位元的唯一性**

一个关于半群的基本结果是单位元的唯一性。我们现在正式地证明这一点。

**符号约定**

使用第5.2.1节的符号约定，我们将三元组的投影函数分别记为 $\text{set}$、$\text{op}$ 和 $\text{assoc}$。

**定理 7.18**

*给定一个特定的成员 $S : \text{Semigroup}$，我们将 $A$、$\ast$、$f$ 分别记为 $\text{set}\ S$、$\text{op}\ S$ 和 $\text{assoc}\ S$。如果我们假设存在元素 $\iota$ 和 $\iota'$ 使得：*

$$
\begin{align*}
& (\forall a : A).\ a \ast \iota = a \quad \text{且} \quad a = \iota \ast a \\
& (\forall a : A).\ a \ast \iota' = a \quad \text{且} \quad a = \iota' \ast a
\end{align*}
$$

*那么我们可以证明 $\iota = \iota'$。这表明，如果单位元存在，那么它是唯一的。*

**证明**

令

$$
g : (\forall a : A).\ a \ast \iota = a \quad \text{且} \quad a = \iota \ast a
$$

将 $g$ 应用于 $\iota'$，并取第一投影：

$$
\text{fst}\ (g\ \iota') : \iota' \ast \iota = \iota'
$$

同样，令

$$
h : (\forall a : A).\ a \ast \iota' = a \quad \text{且} \quad a = \iota' \ast a
$$

将 $h$ 应用于 $\iota$，并取第二投影：

$$
\text{snd}\ (h\ \iota) : \iota = \iota' \ast \iota
$$

通过（7.29）、（7.30）和等式的传递性，我们有：

$$
\iota = \iota'
$$

因此，单位元是唯一的。

**定理 7.19**

*使用上述相同的约定，如果对于 $A$ 中的一个特定元素 $a$，存在元素 $a'$ 和 $a''$ 使得：*

$$
\begin{align*}
& a \ast a' = \iota \quad \text{且} \quad \iota = a' \ast a \\
& a \ast a'' = \iota \quad \text{且} \quad \iota = a'' \ast a
\end{align*}
$$

*那么我们可以证明 $a' = a''$，这表明如果逆元存在，那么它是唯一的。*

**证明**

*练习*：证明使用了运算 $\ast$ 的结合性。

**建模中的挑战**

这些结果依赖于我们反复解包三元组 $(A, (\ast, f))$，并且系统必须具有给对象赋予临时名称的能力。Dyckhoff 发现，由于在他可用的实现中这很困难，所以直接公理化理论可能更合适。

**公理化半群**

对于半群，公理形式如下：

**半群的构成规则**

$$
\text{Semigroup} \quad \text{是一个类型} \quad (\text{SemiF})
$$

**半群的引入规则**

$$
\begin{array}{l}
A\ \text{是一个类型} \\
\ast : A \Rightarrow A \Rightarrow A \\
r : (\forall a, b, c : A).\ ((a \ast b) \ast c = a \ast (b \ast c)) \\
\hline
\text{SG}\ A\ \ast\ r : \text{Semigroup} \quad (\text{SemiI})
\end{array}
$$

**半群的消除规则**

$$
\begin{array}{l}
S : \text{Semigroup} \\
\hline
\text{set}\ S\ \text{是一个类型} \quad (\text{SemiE1})
\end{array}
$$

$$
\begin{array}{l}
S : \text{Semigroup} \\
\hline
\text{op}\ S : \text{set}\ S \Rightarrow \text{set}\ S \Rightarrow \text{set}\ S \quad (\text{SemiE2})
\end{array}
$$

$$
\begin{array}{l}
S : \text{Semigroup} \\
\hline
\text{assoc}\ S : (\forall a, b, c : \text{set}\ S).\ ((a\ (\text{op}\ S)\ b)\ (\text{op}\ S)\ c = a\ (\text{op}\ S)\ (b\ (\text{op}\ S)\ c)) \quad (\text{SemiE3})
\end{array}
$$

**计算规则**

计算规则表明 $\text{set}$、$\text{op}$ 和 $\text{assoc}$ 表现为投影：

$$
\begin{align*}
& \text{set}\ (\text{SG}\ A\ \ast\ r) \rightarrow A \\
& \text{op}\ (\text{SG}\ A\ \ast\ r) \rightarrow \ast \\
& \text{assoc}\ (\text{SG}\ A\ \ast\ r) \rightarrow r
\end{align*}
$$

**使用新规则证明定理**

使用这些规则，我们可以类似地证明定理 7.18 和 7.19。

**两种方法的比较**

这两种方法非常接近。将方法转向规则的积极效果是我们可以访问命名设施，但我们已经表明这可以与表示方法集成。向系统添加规则的一个缺点是我们可能会扰乱系统的形式属性，例如逻辑一致性或强归约性。

**潜在的缺点**

在这种情况下，没有困难，因为我们可以将规则视为从表示中导出，为特定数据抽象提供更清晰的接口。通过添加规则可能破坏系统的形式属性，这可能适用于本章讨论的所有添加内容；我们将在下一章更深入地探讨它。

[Dyc85]，本节基于此，对更重要的范畴（categories）示例进行了类似的方法比较。

---

**练习**

**练习 7.55**

*投影函数 $\text{set}$、$\text{op}$ 和 $\text{assoc}$ 的类型是什么？*

**解答：**

- $\text{set} : \text{Semigroup} \Rightarrow \text{Type}$
- $\text{op} : (S : \text{Semigroup}) \Rightarrow \text{set}\ S \Rightarrow \text{set}\ S \Rightarrow \text{set}\ S$
- $\text{assoc} : (S : \text{Semigroup}) \Rightarrow (\forall a, b, c : \text{set}\ S).\ ((a\ (\text{op}\ S)\ b)\ (\text{op}\ S)\ c = a\ (\text{op}\ S)\ (b\ (\text{op}\ S)\ c))$

**练习 7.56**

*证明定理 7.19。*

**证明：**

给定 $a \in A$ 和元素 $a'$、$a''$ 满足：

$$
\begin{align*}
& a \ast a' = \iota \quad \text{且} \quad \iota = a' \ast a \\
& a \ast a'' = \iota \quad \text{且} \quad \iota = a'' \ast a
\end{align*}
$$

我们需要证明 $a' = a''$。

**步骤：**

1. 由 $a \ast a' = \iota$ 和 $\iota = a'' \ast a$，得到：

$$
a \ast a' = a'' \ast a
$$

2. 使用结合性：

$$
(a'' \ast a) \ast a' = a'' \ast (a \ast a')
$$

3. 代入 $a \ast a' = \iota$：

$$
(a'' \ast a) \ast a' = a'' \ast \iota
$$

4. 因为 $\iota$ 是单位元，$a'' \ast \iota = a''$：

$$
(a'' \ast a) \ast a' = a''
$$

5. 由于 $\iota = a'' \ast a$，因此：

$$
\iota \ast a' = a''
$$

6. 因为 $\iota$ 是单位元，$\iota \ast a' = a'$：

$$
a' = a''
$$

因此，证明了 $a' = a''$，即逆元是唯一的。

**练习 7.57**

*使用新类型 Semigroup 的规则，证明定理 7.18 和 7.19 的版本。*

**解答：**

使用提供的 Semigroup 的规则和计算规则，证明过程与之前的类似，但现在我们可以直接使用投影 $\text{set}$、$\text{op}$ 和 $\text{assoc}$，这简化了符号和步骤。

---

**总结**

在本节中，我们探讨了如何在类型理论中引入部分对象和类型，解决它们对逻辑解释和系统一致性带来的挑战。我们研究了在类型理论中建模特定数学结构的不同方法，比较了使用抽象数据类型构建模型和通过添加新规则扩展系统的方法。通过研究半群的示例，我们看到了每种方法的优点和潜在缺点，强调了在类型理论中平衡表达能力和保持形式属性的重要性。
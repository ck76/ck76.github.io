[toc]



# **第 5 章：探索类型理论**

---

在上一章中，我们介绍了类型理论系统 $\text{TT}_0 \)。这是一个复杂的系统，其许多方面都值得进一步研究。本章将深入探讨这些方面，包括对规则的修订、计算行为、等式和恒等式、宇宙（类型的类型）以及良基类型等内容。

## **5.1 假设**

在类型理论中，**假设（Assumptions）** 扮演着重要的角色。它们允许我们在推导过程中临时引入变量和类型，帮助构建更复杂的证明和函数。

- **作用**：假设为我们提供了一个上下文，其中我们可以引入新的变量或类型，以便在推导中使用。
- **形式**：通常表示为 $[x : A] \)，表示在假设 $x \) 是类型 $A \) 的一个元素的条件下，进行接下来的推导。

**重要性**：

- **管理范围**：假设的作用域是有限的，通常在推导结束时需要将其解除（即对假设进行消除）。
- **依赖性**：在类型理论中，许多类型和证明都可能依赖于假设，因此管理好假设对于确保推导的正确性和一致性至关重要。

## **5.2 命名和缩写**

为了提高程序和证明的可读性，我们可以使用**命名（Naming）**和**缩写（Abbreviations）**来简化表达式。

### **5.2.1 命名**

**命名**允许我们为复杂的表达式或类型赋予简短的标识符。

- **目的**：提高可读性，避免重复书写冗长的表达式。
- **示例**：如果我们有一个复杂的函数 $f(x) = \text{some\_complex\_expression} \)，我们可以将其命名为 $f \)，并在后续使用 $f \) 代替完整的表达式。

**注意事项**：

- **命名的唯一性**：确保每个名字在其作用域内是唯一的，避免歧义。
- **作用域管理**：命名的作用域应清晰定义，避免命名冲突。

### **5.2.2 缩写**

**缩写**是对常用或复杂的表达式进行简化的另一种方式。

- **目的**：简化表达式，提高书写和阅读效率。
- **示例**：将 $\lambda x . \lambda y . x + y \) 缩写为 $\text{add} \)。

**应用**：

- **常用函数**：对经常使用的函数进行缩写。
- **模式**：对于具有特定模式的表达式，可以定义通用的缩写形式。

## **5.3 规则的修订**

在上一章中，我们介绍了类型理论的基本规则。本节将对这些规则进行修订和扩展，以提高系统的表达能力。

### **5.3.1 变量绑定运算符和析取**

**变量绑定运算符**（如 $\lambda \)）在类型理论中非常重要。它们允许我们定义函数和表达式，其中变量的范围受到严格控制。

**析取（Disjunction）**：

- **问题**：在之前的规则中，析取的消除规则可能过于简化，无法处理某些复杂情况。
- **解决方案**：引入更一般的析取消除规则，允许我们处理更多的情况。

### **5.3.2 泛化析取**

为了提高析取的表达能力，我们需要对其消除规则进行泛化。

- **一般化的析取消除规则**：允许我们在推导中更灵活地使用析取，处理依赖于不同分支的情况。

**示例**：

- 假设我们有 $A \lor B \)，并且需要推导一个命题 $C \)，其中 $C \) 可能依赖于 $A \) 或 $B \) 的具体内容。

### **5.3.3 存在量词**

**存在量词（Existential Quantifier）**允许我们表达存在某个满足特定条件的元素。

- **问题**：传统的存在量词消除规则可能不够强大，无法充分利用类型理论的特点。
- **解决方案**：引入一个变体的存在量词消除规则，或一个更弱的版本，类似于一阶谓词演算中的传统规则。

**变体**：

- **强存在消除规则**：允许我们从存在的元素中提取更多信息。
- **弱存在消除规则**：更接近于传统逻辑，可能在某些情况下更适用。

## **5.4 可推导性**

本节讨论如何从一些推导中得出其他推导，以及类型在系统中的唯一性。

### **5.4.1 从 $a : A \) 推导出 $A \) 是一个类型**

**目标**：证明如果我们有 $a : A \)，那么可以推导出 $A \) 是一个类型。

- **思路**：根据类型理论的规则，任何元素 $a \) 都必须属于某个类型 $A \)。因此，存在 $a : A \) 意味着 $A \) 必须是一个有效的类型。

**证明**：

1. **假设**：$a : A \)。
2. **推导**：根据类型的引入规则和元素的归属关系，得出 $A \) 是一个类型。

### **5.4.2 类型的唯一性**

**命题**：在类型理论中，每个对象的类型是唯一的。

- **重要性**：确保类型系统的确定性和一致性。

**证明**：

1. **假设**：对象 $a \) 同时属于类型 $A \) 和类型 $B \)。
2. **推导**：根据类型的定义和对象的性质，证明 $A \) 和 $B \) 实际上是相同的类型。

## **5.5 计算**

本节研究类型理论系统的计算行为，特别是与 $\text{TT}_0 \) 相关的两个系统。

### **5.5.1 归约**

**归约（Reduction）**是计算过程中的核心概念，它描述了如何将复杂的表达式简化为更基本的形式。

- **目的**：通过应用计算规则，将表达式简化到无法进一步归约的形式，即**正常形式（Normal Form）**。
- **性质**：归约过程应该是终止的，即任何表达式都可以在有限步内归约到正常形式。

### **5.5.2 系统 $\text{TT}_0^\ast \)**

引入一个变体系统 $\text{TT}_0^\ast \)，它对 $\text{TT}_0 \) 进行了修改。

- **特性**：$\text{TT}_0^\ast \) 具有强归约性质，即所有的推导过程都会终止。
- **缺点**：不具备 Church-Rosser 性质（也称为**合流性**），即不同的归约路径可能导致不同的结果。

### **5.5.3 组合子和系统 $\text{TT}_0^c \)**

引入另一个系统 $\text{TT}_0^c \)，最初由 Martin-Löf 在 1975 年提出。

- **区别**：$\text{TT}_0^c \) 在抽象的执行方式上与 $\text{TT}_0 \) 不同，采用了不同的抽象机制。
- **抽象机制**：类似于现代函数式编程语言中编译器实现的方式。

**优势**：

- **正常化定理**：$\text{TT}_0^c \) 具有正常化定理，即所有表达式都可以归约到正常形式。
- **Church-Rosser 性质**：具有合流性，即不同的归约路径最终会收敛到同一个结果。
- **判定性**：可转换关系 $\leftrightarrow\!\!\leftrightarrow \) 和一般的判断都是可判定的。

## **5.6 $\text{TT}_0^c \)：归约及其推论**

### **5.6.1 多态性和单态性**

- **多态性（Polymorphism）**：指程序或函数可以接受多种类型的参数。
- **单态性（Monomorphism）**：指程序或函数的参数类型是固定的。

**在 $\text{TT}_0^c \) 中**：

- 可以更好地处理多态性，允许更灵活的函数定义和类型推导。

## **5.7 等式和恒等式**

本节比较了类型理论中使用的不同等式概念。

### **5.7.1 定义等式**

**定义等式（Definitional Equality）**：

- **概念**：如果两个表达式在展开所有定义后，除了变量的重命名外是相同的，那么它们是定义等式的。
- **作用**：这是最接近字面意义上的等式。

### **5.7.2 可转换性**

**可转换性（Convertibility）**是系统外部的关系，通过系统内部的 $I \) 类型表示。

- **概念**：如果两个表达式可以通过一系列的归约和扩展相互转换，那么它们是可转换的。
- **作用**：允许我们在复杂命题中组合等式。

### **5.7.3 恒等式；$I \) 类型**

**$I \) 类型**用于在系统内部表示等式。

- **作用**：提供了一个命题形式，用于表示两个元素在某个类型上的相等性。
- **特点**：可以在系统中进行推导和证明。

### **5.7.4 等式函数**

**等式函数（Equality Functions）**返回布尔值，表示两个特定类型的元素是否相等。

- **作用**：用于计算，可用于程序员熟悉的条件表达式中。
- **示例**：在自然数类型上定义的等于函数 $\text{equalN} : \text{N} \rightarrow \text{N} \rightarrow \text{bool} \)。

### **5.7.5 等式的刻画**

讨论了如何在类型理论中刻画和区分上述不同的等式概念。

- **比较**：分析它们的定义、性质和应用场景。
- **关系**：探讨它们之间的联系和区别。

## **5.8 不同的等式**

### **5.8.1 函数式编程的视角**

从函数式编程的角度，探讨等式在程序中的作用。

- **重要性**：等式在程序的正确性、优化和重构中起着关键作用。
- **问题**：在类型理论中，函数的等式可能无法直接表达（如无法证明两个定义不同但行为相同的函数相等）。

### **5.8.2 外延等式**

**外延等式（Extensional Equality）**：

- **概念**：如果两个函数在所有输入上产生相同的输出，那么它们是外延相等的。
- **问题**：在类型理论中，外延等式可能导致系统的某些良好性质（如归约性）失效。

### **5.8.3 在 $\text{TT}_0 \) 中定义外延等式**

讨论如何在 $\text{TT}_0 \) 中引入外延等式，而不破坏系统的形式性质。

- **方法**：通过扩展系统的规则，或引入新的类型和构造。
- **挑战**：需要确保系统的一致性和可判定性。

## **5.9 宇宙**

**宇宙（Universes）**是类型的类型的概念。

### **5.9.1 类型族**

引入类型族（Type Families），即参数化的类型。

- **作用**：允许我们定义依赖于参数的类型，例如 $\text{Vector}(n) \) 表示长度为 $n \) 的向量类型。

### **5.9.2 对宇宙的量化**

讨论如何对宇宙进行量化，即对类型的类型进行操作。

- **挑战**：直接引入类型的类型可能导致不一致（类似于 Russell 悖论）。
- **解决方案**：引入一系列的宇宙，每个宇宙都是上一个宇宙的类型，以避免不一致。

### **5.9.3 闭包公理**

**闭包公理（Closure Axioms）**：

- **作用**：确保宇宙在某些操作下是封闭的，即对宇宙中的类型进行某些构造后，结果仍然在宇宙中。
- **示例**：如果 $A \) 和 $B \) 在宇宙 $U \) 中，那么 $A \rightarrow B \) 也在 $U \) 中。

### **5.9.4 扩展**

讨论如何进一步扩展宇宙的概念，以支持更复杂的类型构造。

- **多级宇宙**：引入多个层次的宇宙，形成一个层级结构。
- **递归宇宙**：允许宇宙自身包含自身的某些部分。

## **5.10 良基类型**

### **5.10.1 列表**

讨论如何在类型理论中定义列表类型。

- **构造**：

  - 空列表：$\text{nil} \)。
  - 列表的构造：$\text{cons}\ x\ xs \)，将元素 $x \) 加入列表 $xs \)。

- **递归定义**：使用原始递归定义列表上的函数，如长度、映射、过滤等。

### **5.10.2 一般情况——$W \) 类型**

**$W \) 类型**是良基类型的一种一般形式。

- **作用**：提供了一个统一的框架，用于定义各种递归数据类型。
- **定义**：$W \) 类型由一个索引类型和一个依赖于该索引的子类型族构成。

### **5.10.3 Miranda 语言中的代数类型**

讨论在函数式编程语言 Miranda 中，如何使用代数类型来表示递归数据结构。

- **代数类型**：通过构造器来定义数据类型，可以是递归的。
- **对应**：在类型理论中，代数类型可以用 $W \) 类型来表达。

## **5.11 可表达性**

讨论类型理论的表达能力。

- **限制**：某些计算无法在系统中直接表达，需要引入新的构造或扩展系统。
- **潜力**：类型理论具有强大的表达能力，可以表示复杂的逻辑和计算结构。

## **5.12 Curry-Howard 同构？**

Curry-Howard 同构将逻辑证明与计算机程序联系起来。

### **5.12.1 假设**

探讨假设在 Curry-Howard 同构中的作用。

- **在逻辑中**：假设对应于临时引入的前提，用于推导结论。
- **在编程中**：假设对应于参数或占位符，可以在函数中使用。

### **5.12.2 证明的正常形式**

讨论证明的归约和标准化。

- **归约**：将复杂的证明简化为更基本的形式。
- **正常形式**：证明无法进一步简化的形式。

**挑战**：

- **在同构中**：证明的归约对应于程序的执行，这种对应关系在某些情况下可能并不完美。
- **解决方案**：需要更深入地理解证明和程序之间的关系，可能需要扩展或调整同构的定义。

---

**总结**：

本章深入探索了类型理论的各个方面，包括规则的修订、计算行为、等式的不同概念、宇宙和良基类型等。通过对这些主题的研究，我们对类型理论的性质和应用有了更深入的理解，也为进一步的研究和应用奠定了基础。

### ---------------------------

# **第 5 章：探索类型理论**

---

## **5.1 假设**

在类型理论的推导过程中，我们通常依赖于一系列的**假设（assumptions）**。本节将详细探讨这些假设集合的精确形式，以及它们应遵循的一致性准则。此外，我们将重新审视一些规则，并在某些情况下对它们进行更加严格的表述。

实现一个形式系统是理解其细节的有益练习。作者在使用函数式编程语言 Miranda 实现类型理论的过程中，意识到了这里讨论的许多问题。在书面介绍中，很容易忽略某些实现中不可或缺的系统方面；数学符号是一种强大的工具，部分原因是它允许模糊性，此外，有想象力的读者通常会以显而易见的方式填补讲解中的空白。

一个重要的参考资料是 [Troelstra, 1987]，其中讨论了 Martin-Löf 类型理论系统的一些低层次但同样重要的方面。

### **假设的特点**

系统的一个特殊之处在于，假设并不出现在推导的叶子节点。为了引入假设 $x : A \)，我们必须首先确定 $A \) 本身是一个类型，假设仅出现在这个推导的下面。

推导的假设并不简单地构成一个集合：它们之间存在**依赖关系的顺序（ordering of dependency）**，因为某些假设中的类型可能依赖于其他假设引入的变量。

#### **示例：等式的对称性证明**

考虑等式的对称性的证明。假设我们已经推导出：

1. **$A \) 是一个类型**。

   $$
   A\ \text{is a type}
   $$

2. **引入假设**：

   - $a : A \)
   - $b : A \)

3. **构造类型 $a =_A b \)**：

   - 由于 $a, b : A \)，根据等式类型的构造规则，$I(A, a, b) \) 是一个类型。
   - 我们可以引入一个变量 $x : I(A, a, b) \)，其类型包含了其他假设引入的变量 $a \) 和 $b \)。

**推导表示如下**：

- 首先，确认 $A \) 是一个类型。
- 然后，引入假设 $a : A \)。
- 接着，引入假设 $b : A \)。
- 根据等式类型的构造规则（$\text{I F} \)），得到 $I(A, a, b) \) 是一个类型。
- 最后，引入假设 $x : I(A, a, b) \)。

具体的推导树：

```
A is a type
|
+-- a : A          (假设，标记为 AS)
|
+-- b : A          (假设，标记为 AS)
|
+-- I(A, a, b) is a type   (由 IF 规则)
|
+-- x : I(A, a, b)         (假设，标记为 AS)
```

这些先前的假设出现在引入 $x : I(A, a, b) \) 的推导树之上。

#### **应用等式的消除规则**

根据等式的消除规则（$\text{I E} \)），我们可以得出：

- 已知：
  - $x : I(A, a, b) \)
  - $r(a) : I(A, a, a) \)（由等式的引入规则，反身性）

- 应用等式的消除规则：

  $$
  \frac{c : I(A, a, b) \quad d : C(a, a, r(a))}{J(c, d) : C(a, b, c)}\ (\text{I E})
  $$

- 在这里，$C(a, b, c) \equiv I(A, b, a) \)，因此我们得到：

  $$
  J(x, r(a)) : I(A, b, a)
  $$

#### **消除假设的顺序**

我们现在面临的问题是：**如何消除假设 $a : A \)、$b : A \) 和 $x : I(A, a, b) \)**。重要的是，我们**不能以任意顺序**消除这些假设。

**规则**：

- **只有当变量 $a \) 不在任何其他假设中自由出现时，才能消除假设 $a : A \)**。

**原因**：

- 如果我们首先消除假设 $a : A \)，则会得到表达式：

  $$
  \lambda a . J(x, r(a))
  $$

- 但是，这个表达式中包含了自由变量 $x \)，而 $x \) 的类型 $I(A, a, b) \) 依赖于 $a \)。然而，在 $\lambda a . J(x, r(a)) \) 中，$a \) 已经被绑定，因此 $x \) 的类型中的 $a \) 超出了其作用域，这在计算机科学中称为**变量越界（variable out of scope）**，这种使用是无意义的。

- 为了避免这种情况，我们必须首先消除对 $x \) 的假设，然后才能消除 $a \) 和 $b \) 的假设。

#### **正确的消除顺序**

1. **首先消除 $x : I(A, a, b) \)**：

   - 我们对 $x \) 进行抽象，形成一个函数：

     $$
     \lambda x : I(A, a, b) . J(x, r(a))
     $$

   - 其类型为：

     $$
     I(A, a, b) \rightarrow I(A, b, a)
     $$

2. **然后消除 $b : A \)**：

   - 对 $b \) 进行抽象，得到：

     $$
     \lambda b : A . (\lambda x : I(A, a, b) . J(x, r(a)))
     $$

   - 其类型为：

     $$
     \forall b : A . (I(A, a, b) \rightarrow I(A, b, a))
     $$

3. **最后消除 $a : A \)**：

   - 对 $a \) 进行抽象，得到最终的函数：

     $$
     \lambda a : A . (\lambda b : A . (\lambda x : I(A, a, b) . J(x, r(a))))
     $$

   - 其类型为：

     $$
     \forall a : A . (\forall b : A . (I(A, a, b) \rightarrow I(A, b, a)))
     $$

**完整的推导表示**：

```
A is a type , [a : A]_3 , [b : A]_2
|
+-- [x : I(A, a, b)]_1
    |
    +-- r(a) : I(A, a, a)
    |
    +-- J(x, r(a)) : I(A, b, a)     (由 IE 规则)
|
+-- λx . J(x, r(a)) : I(A, a, b) ⇒ I(A, b, a)    (由 ⇒I 规则，消除 x)
|
+-- λb . (λx . J(x, r(a))) : ∀b : A . (I(A, a, b) ⇒ I(A, b, a))    (由 ∀I 规则，消除 b)
|
+-- λa . (λb . (λx . J(x, r(a)))) : ∀a : A . (∀b : A . (I(A, a, b) ⇒ I(A, b, a)))    (由 ∀I 规则，消除 a)
```

#### **关于假设消除的几点说明**

- **当我们消除一个假设 $a : A \) 时，必须消除该假设的所有出现（在消除节点之上）**。

  - 如果不这样做，会导致变量 $a \) 在其作用域之外出现，这是不允许的。

- **我们并不一定要消除公式 $A \) 的所有假设（即所有类型为 $A \) 的变量），而是仅消除名为 $a \) 的那些**。

#### **上下文的明确表示**

另一种表示理论的方法是，在推导树的每个节点明确列出未消除的假设。

##### **定义 5.1：上下文（Context）**

一个或多个假设的列表：

$$
x_1 : A_1,\ x_2 : A_2,\ \dots,\ x_n : A_n
$$

称为一个**上下文（context）**，如果它满足以下条件：

1. **变量依赖性**：对于 $0 < i < n \)，变量 $x_i \) 只能在假设 $x_j : A_j \) 中自由出现，且 $j > i \)。这意味着变量只能依赖于在它之前引入的变量。

2. **类型有效性**：对于每个 $0 < j < n \)，$A_{j+1} \) 是一个类型，应该是从假设 $x_1 : A_1, \dots, x_j : A_j \) 推导出来的。

3. **变量唯一性**：所有变量 $x_j \) 都是不同的。

如果我们用 $\Gamma, \Gamma', \dots \) 表示上下文，并用 $\Gamma \vdash J \) 表示一个判断以及其假设列表，那么我们可以解释一个推导在何种情况下是一致的。

##### **定义 5.2：上下文的一致性**

两个上下文 $\Gamma \) 和 $\Gamma' \) 是**一致的（consistent）**，当且仅当对于每个变量 $x \)，如果 $x \) 同时出现在两个上下文中，则它在每个上下文中都被假设为具有相同的类型（允许变量名的改变）。

一个推导 $d \) 是一致的，如果：

1. **规则应用中的一致性**：在应用一个规则时，例如：

   $$
   \frac{\Gamma \vdash J \quad \Gamma' \vdash J'}{\Gamma'' \vdash J''}
   $$

   - 上下文 $\Gamma \) 和 $\Gamma' \) 必须一致。
   - 合并上下文得到的 $\Gamma'' \) 也必须是一个上下文。

2. **假设的消除**：只有当变量 $x_j \) 在上下文 $\Gamma \) 中的其他假设 $x_k : A_k \)（对于 $k > j \)）中不自由出现时，才能从上下文 $\Gamma \) 中消除假设 $x_j : A_j \)。

#### **规则的总结**

- **消除假设的规则**：

  - **只有当变量 $x \) 不在任何其他假设的类型中自由出现时，才能消除假设 $x : A \)**。

- **规则应用中的一致性**：

  - **在应用至少有两个前提的规则时，假设应该是一致的**。也就是说，在所有前提的推导中，变量 $x \) 必须被假设为具有相同的类型（允许变量名的改变）。

#### **关于一致性条件的放宽**

我们可能会问，是否可以将假设一致性的限制放宽到它们的类型是可转换的（convertible），而不是完全相同的。事实上，根据替换规则，这并不比之前的要求更强（见下面的练习）。但是，需要注意的是，在推导构造过程中执行可转换性的测试，需要可转换性是可判定的。

### **练习**

**练习 5.1**：如果我们分别从假设 $x : A \) 和 $x : A' \) 推导出 $p : P \) 和 $q : Q \)，那么我们可以从 $x : A \) 或 $x : A' \) 构造 $P \lor Q \) 的推导。

**解答**：

- **思路**：

  - 我们需要构造一个推导，从 $x : A \) 或 $x : A' \) 出发，得到 $P \lor Q \)。

- **过程**：

  - **从 $x : A \) 推导 $p : P \)**：

    $$
    \Gamma, x : A \vdash p : P
    $$

  - **从 $x : A' \) 推导 $q : Q \)**：

    $$
    \Gamma', x : A' \vdash q : Q
    $$

  - **构造 $P \lor Q \)**：

    - 使用析取的引入规则，我们可以得到：

      - 从 $p : P \)，得到 $\text{inl}(p) : P \lor Q \)。

      - 从 $q : Q \)，得到 $\text{inr}(q) : P \lor Q \)。

  - **关键**：

    - 如果 $A = A' \)，则 $x \) 的类型一致，可以直接合并推导。

    - 如果 $A \neq A' \)，但可转换，则根据替换规则，仍然可以合并。

**练习 5.2**：从逻辑的角度看，我们是否需要对同一公式 $A \) 有两个或多个假设 $x : A, y : A, \dots \)？从编程的角度，为什么我们需要它们？

**解答**：

- **逻辑角度**：

  - 在逻辑推导中，通常不需要对同一公式 $A \) 有多个假设。

  - 我们可以使用相同的假设 $x : A \) 多次，无需引入新的变量。

- **编程角度**：

  - 在编程中，为了处理多个独立的值，我们需要对类型 $A \) 的不同变量。

  - 例如，函数可能需要两个不同的参数，都属于类型 $A \)。

- **结论**：

  - 在编程中，我们需要多个同类型的变量来表示不同的值。

**练习 5.3**：在上面等式对称性的推导中，给出一个版本，其中在每一步都明确列出了上下文。

**解答**：

- **要求**：

  - 在推导的每一步，都明确写出当前的上下文。

- **示例**：

  1. **初始上下文**：

     $$
     \Gamma_0 = \{ \}
     $$

  2. **引入 $A \) 是一个类型**：

     $$
     \Gamma_0 \vdash A\ \text{is a type}
     $$

  3. **引入假设 $a : A \)**：

     $$
     \Gamma_1 = \Gamma_0 \cup \{ a : A \}
     $$

     $$
     \Gamma_1 \vdash a : A
     $$

  4. **引入假设 $b : A \)**：

     $$
     \Gamma_2 = \Gamma_1 \cup \{ b : A \}
     $$

     $$
     \Gamma_2 \vdash b : A
     $$

  5. **构造 $I(A, a, b) \) 是一个类型**：

     $$
     \Gamma_2 \vdash I(A, a, b)\ \text{is a type}
     $$

  6. **引入假设 $x : I(A, a, b) \)**：

     $$
     \Gamma_3 = \Gamma_2 \cup \{ x : I(A, a, b) \}
     $$

     $$
     \Gamma_3 \vdash x : I(A, a, b)
     $$

  7. **构造 $r(a) : I(A, a, a) \)**：

     $$
     \Gamma_1 \vdash r(a) : I(A, a, a)
     $$

  8. **应用等式的消除规则**：

     $$
     \Gamma_3 \vdash J(x, r(a)) : I(A, b, a)
     $$

  9. **消除假设 $x : I(A, a, b) \)**：

     $$
     \Gamma_2 \vdash \lambda x . J(x, r(a)) : I(A, a, b) \rightarrow I(A, b, a)
     $$

  10. **消除假设 $b : A \)**：

      $$
      \Gamma_1 \vdash \lambda b . (\lambda x . J(x, r(a))) : \forall b : A . (I(A, a, b) \rightarrow I(A, b, a))
      $$

  11. **消除假设 $a : A \)**：

      $$
      \Gamma_0 \vdash \lambda a . (\lambda b . (\lambda x . J(x, r(a)))) : \forall a : A . (\forall b : A . (I(A, a, b) \rightarrow I(A, b, a)))
      $$

**练习 5.4**：放宽一致性条件对系统有何影响？

**解答**：

- **如果放宽一致性条件**，允许在不同的推导中，变量 $x \) 被假设为不同的类型，只要这些类型是可转换的。

- **影响**：

  - **正面**：可能提高系统的灵活性，允许更多的推导。

  - **负面**：可能导致系统的不一致性，增加推导的复杂性。

- **结论**：

  - 为了保持系统的良好性质，一般不建议放宽一致性条件。

---

## **5.2 命名和缩写**

为了使系统的表达式和推导更易读，我们允许对表达式进行命名，并在推导、判断和表达式中使用某些形式的缩写。

### **5.2.1 命名**

纯粹的系统（就像纯 λ-演算）是一个没有名字的表达式演算。在使用这样的系统时，我们需要一种原始的命名表达式的方法，以使它们更易读并更简洁。

**定义**：

- 当我们想要使用名称 $\text{name} \) 作为表达式 $\text{expression} \) 的简写时，我们写作：

  $$
  \text{name} \equiv_{\text{df}} \text{expression}
  $$

- 其中 $\equiv_{\text{df}} \) 是**定义等式符号（definitional equality symbol）**。

- **约定**：

  - **不允许递归的命名**，也不允许在定义之前使用名称，以避免间接的相互递归。

  - 我们只需要一个简写方式。

#### **示例：使和类型更易读**

- 我们可以对注入函数 $\text{inl} \) 和 $\text{inr} \) 重命名，以使和类型更易读。

- 例如，定义：

  $$
  \text{numOrBool} \equiv_{\text{df}} \text{num}\ \text{N} + \text{boo}\ \text{bool}
  $$

- 这样，类型 $\text{numOrBool} \) 的对象看起来像：

  - $\text{num}\ n \)，其中 $n : \text{N} \)。

  - $\text{boo}\ b \)，其中 $b : \text{bool} \)。

- 我们还可以将这种记号扩展到 n 元和类型，如果我们将它们表示为某种标准形式（例如，左结合形式）。

- 对于迭代的乘积，当适用时，我们也会使用 n 元组的记号。

#### **函数定义的简写**

- **一般情况下**，不允许递归定义，我们有时会写：

  $$
  f\ x \equiv_{\text{df}} e
  $$

- 代替更正式的定义：

  $$
  f \equiv_{\text{df}} \lambda x^A . e
  $$

#### **模式匹配的定义**

Miranda 语言中一种优雅的定义形式使用了**模式匹配（pattern matching）**。

- 对于在类型 $\text{numOrBool} \) 上的简单情况分析，我们使用运算符 $\text{cases} \)，其中：

  $$
  c \equiv_{\text{df}} \lambda p . \text{cases}\ p\ g\ h : (A \lor B) \rightarrow C
  $$

  - 如果 $g : A \rightarrow C \)，$h : B \rightarrow C \)。

- **假设**：

  - $g\ n \equiv_{\text{df}} e \)

  - $h\ b \equiv_{\text{df}} f \)

- **那么我们可以直接写出 $c \) 的定义**：

  - $c\ (\text{num}\ n) \equiv_{\text{df}} e \)

  - $c\ (\text{boo}\ b) \equiv_{\text{df}} f \)

- **示例**：

  - 定义函数 $\text{toNum} \)：

    $$
    \begin{cases}
    \text{toNum}\ (\text{num}\ n) \equiv_{\text{df}} n \\
    \text{toNum}\ (\text{boo}\ b) \equiv_{\text{df}} \text{if}\ b\ \text{then}\ 1\ \text{else}\ 0
    \end{cases}
    $$

  - 这是以下定义的简写：

    $$
    \text{toNum} \equiv_{\text{df}} \lambda p . (\text{cases}\ p\ (\lambda n . n)\ (\lambda b . \text{if}\ b\ \text{then}\ 1\ \text{else}\ 0))
    $$

#### **受限形式的递归**

- 我们也可以允许某些受限形式的递归，只要它们符合相关类型上的递归操作。

- **在自然数上**，我们允许以下定义：

  $$
  \begin{cases}
  \text{fac}\ 0 \equiv_{\text{df}} 1 \\
  \text{fac}\ (\text{succ}\ n) \equiv_{\text{df}} \text{mult}\ (\text{succ}\ n)\ (\text{fac}\ n)
  \end{cases}
  $$

- 在第一条中，我们不允许递归调用。

- 在第二条中，我们只能调用 $\text{fac}\ n \) 和 $n \) 本身。

- 这对应于正式的定义：

  $$
  \text{fac} \equiv_{\text{df}} \lambda n . (\text{prim}\ n\ 1\ (\lambda p, q . \text{mult}\ (\text{succ}\ p)\ q))
  $$

- **注意**：

  - 在所有这些缩写中，我们假设已经推导出了适当规则的前提。

  - 例如，在这个例子中，我们假设已经可以推导出 $1 : \text{N} \)，并且在假设 $p, q : \text{N} \) 下，$\text{mult}\ (\text{succ}\ p)\ q : \text{N} \)。

### **5.2.2 缩写**

系统中有许多地方，我们可以在不产生问题的情况下对推导进行缩写。

- **情况**：当同一个判断形成一个规则的多个前提时，我们可以只提供该判断的一个推导。

- **示例**：

  1. **合取类型的构造**：

     $$
     \frac{A\ \text{is a type} \quad A\ \text{is a type}}{A \wedge A\ \text{is a type}}\ (\wedge F)
     $$

     - 由于两个前提都是 $A\ \text{is a type} \)，我们可以只提供一个推导。

  2. **合取的引入**：

     $$
     \frac{a : A \quad a : A}{(a, a) : A \wedge A}\ (\wedge I)
     $$

     - 同样，两个前提都是 $a : A \)，可以只提供一个推导。

  3. **等式类型的构造**：

     $$
     \frac{A\ \text{is a type} \quad a : A \quad a : A}{I(A, a, a)\ \text{is a type}}\ (\text{I F})
     $$

     - 两个 $a : A \) 的前提可以只提供一个推导。

- **重复推导的省略**：

  - 在特定推导的两个或多个子推导中，可能会出现相同的推导。

  - **示例**：当我们使用数字 $2 \equiv_{\text{df}} \text{succ} (\text{succ}\ 0) \) 时，我们需要先推导出：

    $$
    \begin{align*}
    & 0 : \text{N}\ (\text{NI1}) \\
    \Rightarrow\ & \text{succ}\ 0 : \text{N}\ (\text{NI2}) \\
    \Rightarrow\ & \text{succ} (\text{succ}\ 0) : \text{N}\ (\text{NI2})
    \end{align*}
    $$

  - 为了简洁，我们将省略这些重复的推导。

### **系统中的命名机制**

任何基于类型理论的函数式编程系统，都需要至少包含上述的命名机制。

- **伴随命名机制**，还有许多其他问题，例如类型之间的等式。

- 在本节中，我们不打算进一步讨论这些问题，但会在后续讨论系统的相关性时提及更多的命名问题。

### **练习**

**练习 5.5**：为上一章引入的代数类型 $\text{tree} \) 上定义的函数建议命名约定。

**解答**：

- **示例命名约定**：

  - **节点构造器**：

    - 空树：$\text{Null} \)

    - 二叉节点：$\text{Node}\ n\ l\ r \)，其中 $n : \text{N} \)，$l, r : \text{tree} \)

  - **函数命名**：

    - **树的高度**：$\text{height} \)

    - **元素的求和**：$\text{sumTree} \)

    - **前序遍历**：$\text{preOrder} \)

    - **插入元素**：$\text{insert} \)

    - **查找元素**：$\text{search} \)

- **示例**：

  - 定义树的高度：

    $$
    \begin{cases}
    \text{height}\ \text{Null} \equiv_{\text{df}} 0 \\
    \text{height}\ (\text{Node}\ n\ l\ r) \equiv_{\text{df}} 1 + \text{max}(\text{height}\ l, \text{height}\ r)
    \end{cases}
    $$

**练习 5.6**：解释以下定义中使用的命名约定：

$$
\begin{align*}
\text{merge}\ x\ [\ ] &\equiv_{\text{df}} x \\
\text{merge}\ [\ ]\ y &\equiv_{\text{df}} y \\
\text{merge}\ (a :: x)\ (b :: y) &\equiv_{\text{df}} a :: (\text{merge}\ x\ (b :: y)) & \text{if}\ a < b \\
&\equiv_{\text{df}} a :: (\text{merge}\ x\ y) & \text{if}\ a = b \\
&\equiv_{\text{df}} b :: (\text{merge}\ (a :: x)\ y) & \text{if}\ a > b
\end{align*}
$$

**解答**：

- **解释**：

  - 这是一个合并两个有序列表的函数 $\text{merge} \) 的定义。

- **命名约定**：

  - **列表表示**：

    - 空列表用 $[\ ] \) 表示。

    - 非空列表用 $a :: x \) 表示，其中 $a \) 是列表的头元素，$x \) 是剩余的列表。

  - **函数定义**：

    - 当一个列表为空时，直接返回另一个列表。

      - $\text{merge}\ x\ [\ ] \equiv_{\text{df}} x \)

      - $\text{merge}\ [\ ]\ y \equiv_{\text{df}} y \)

    - 当两个列表都非空时，比较头元素 $a \) 和 $b \)：

      - 如果 $a < b \)，则将 $a \) 放入结果列表，并递归合并 $x \) 和 $b :: y \)。

        $$
        \text{merge}\ (a :: x)\ (b :: y) \equiv_{\text{df}} a :: (\text{merge}\ x\ (b :: y)) \quad \text{if}\ a < b
        $$

      - 如果 $a = b \)，则将 $a \) 放入结果列表，并递归合并 $x \) 和 $y \)。

        $$
        \text{merge}\ (a :: x)\ (b :: y) \equiv_{\text{df}} a :: (\text{merge}\ x\ y) \quad \text{if}\ a = b
        $$

      - 如果 $a > b \)，则将 $b \) 放入结果列表，并递归合并 $a :: x \) 和 $y \)。

        $$
        \text{merge}\ (a :: x)\ (b :: y) \equiv_{\text{df}} b :: (\text{merge}\ (a :: x)\ y) \quad \text{if}\ a > b
        $$

- **总结**：

  - 这个定义使用了模式匹配和条件表达式，根据元素的大小关系，决定合并的方式。

---

**通过详细的讲解，我们希望您能更深入地理解第 5 章第 5.1 和 5.2 节的内容。如有任何疑问或需要进一步的澄清，请随时提出！**

### ----------------------------

# **第 5 章：探索类型理论**

---

## **5.3 修订规则**

为了教学的原因，我们在第 4 章的介绍中简化或修改了一些类型理论的规则。本节中，我们将以其完整的通用性给出这些规则，并探讨它们的替代版本。

### **5.3.1 变量绑定运算符和析取**

在我们最初的讲解中，我们选择了一个单一的绑定操作符，即用于 λ 抽象的函数构造 $\lambda \)。在 Martin-Löf 的系统中 [ML85]，存在许多绑定运算符。作为一个例子，我们将考虑**析取（∨）的消除规则**，并回到我们在第 1 章中看到的形式。

在第 1 章中，我们有如下规则：

**析取消除规则 (∨E)**：

$$
\frac{
    A \lor B \quad [A] \vdots C \quad [B] \vdots C
}{
    C
}
$$

- **解释**：
  - 我们有一个 $A \lor B \) 的证明。
  - 我们假设 $A \)，在此假设下推导 $C \)。
  - 我们假设 $B \)，在此假设下推导 $C \)。
  - 通过消除假设，我们得出 $C \) 的证明。

这些假设在形成的证明中被消除（从各自的子证明中）。在我们之前给出的版本中，我们提供了对公式 $A \Rightarrow C \) 和 $B \Rightarrow C \) 的证明；这些对应于通过 (⇒I) 和 (⇒E) 规则得到的假设证明。

**替代的类型理论规则**具有以下形式：

**析取消除规则（带变量绑定） (∨E')**：

$$
\frac{
    p : (A \lor B) \quad [x : A] \vdots u : C \quad [y : B] \vdots v : C
}{
    \text{vcases}_{x,y}\ p\ u\ v : C
}
$$

- **解释**：
  - $p \) 是 $A \lor B \) 的一个证明对象。
  - 我们在假设 $x : A \) 下推导 $u : C \)。
  - 我们在假设 $y : B \) 下推导 $v : C \)。
  - 通过消除假设，我们使用一个新的运算符 $\text{vcases}_{x,y} \) 构造 $C \) 的证明。

**运算符 $\text{vcases}_{x,y} \)** 绑定其第二个参数中的变量 $x \) 和第三个参数中的变量 $y \)。

#### **计算规则**

**对于 $\text{vcases}_{x,y} \) 的计算规则**：

1. 当 $p = \text{inl}\ a \) 时：

   $$
   \text{vcases}_{x,y}\ (\text{inl}\ a)\ u\ v \to u[a / x]
   $$

   - **解释**：将 $a \) 替换 $u \) 中的 $x \)，得到 $u[a / x] \)。

2. 当 $p = \text{inr}\ b \) 时：

   $$
   \text{vcases}_{x,y}\ (\text{inr}\ b)\ u\ v \to v[b / y]
   $$

   - **解释**：将 $b \) 替换 $v \) 中的 $y \)，得到 $v[b / y] \)。

#### **等价性分析**

显然，规则 (∨E) 和 (∨E') 在某种意义上是等价的，并且产生相同的计算行为。我们可以通过以下方式精确地表述这一点。

**假设**我们有 $f : A \Rightarrow C \) 和 $g : B \Rightarrow C \)，我们可以基于假设 $x : A \) 和 $y : B \) 分别形成假设证明：

- **从 $x : A \) 推导 $f\ x : C \)**
- **从 $y : B \) 推导 $g\ y : C \)**

然后，我们可以构造一个证明：

$$
\text{vcases}_{x,y}\ p\ (f\ x)\ (g\ y) : C
$$

**计算行为分析**：

1. 当 $p = \text{inl}\ a \) 时：

   $$
   \text{vcases}_{x,y}\ (\text{inl}\ a)\ (f\ x)\ (g\ y) \to (f\ x)[a / x] = f\ a
   $$

2. 当 $p = \text{inr}\ b \) 时：

   $$
   \text{vcases}_{x,y}\ (\text{inr}\ b)\ (f\ x)\ (g\ y) \to (g\ y)[b / y] = g\ b
   $$

**结论**：

- **可推导性**得到保留。
- **计算行为**与之前使用 $\text{cases}\ p\ f\ g \) 的方式完全一致。

这是因为对于每个 $A \lor B \) 的封闭项 $p \)，表达式 $\text{vcases}_{x,y}\ p\ (f\ x)\ (g\ y) \) 的行为与 $\text{cases}\ p\ f\ g \) 完全相同。

**练习**：

- 证明上述结果的逆命题，即规则 (∨E') 可以从规则 (∨E) 推导出来，并且计算行为得以保留。

### **5.3.2 泛化析取**

我们以之前的形式呈现 $\lor \) 的规则的一个原因是，它自然地暗示了一个泛化。在这种形式中，类型 $C \) 可以是一个类型族，依赖于类型 $A \lor B \) 的变量 $z \)。

**以这种形式表述，我们有**：

**泛化的析取消除规则 (∨E'')**：

$$
\frac{
    p : (A \lor B) \quad [x : A] \vdots u : C[\text{inl}\ x / z] \quad [y : B] \vdots v : C[\text{inr}\ y / z]
}{
    \text{vcases}_{x,y}\ p\ u\ v : C[p / z]
}
$$

- **解释**：
  - $p : A \lor B \)。
  - 在假设 $x : A \) 下，我们推导 $u : C[\text{inl}\ x / z] \)。
    - 即，将 $\text{inl}\ x \) 替换 $C \) 中的 $z \)。
  - 在假设 $y : B \) 下，我们推导 $v : C[\text{inr}\ y / z] \)。
    - 即，将 $\text{inr}\ y \) 替换 $C \) 中的 $z \)。
  - 最终，我们得到 $\text{vcases}_{x,y}\ p\ u\ v : C[p / z] \)，其中 $p \) 替换 $C \) 中的 $z \)。

**计算规则**与之前的 $\text{vcases}_{x,y} \) 相同。

**绑定变量**：

- 运算符 $\text{vcases}_{x,y} \) 绑定变量 $x \) 和 $y \) 的出现。

#### **非绑定版本的规则**

实际上，我们可以给出这个规则的一个版本，其中运算符不是绑定的，但涉及使用量词；这是我们最初推迟引入它的原因。

**非绑定版本的析取消除规则 (∨E†)**：

$$
\frac{
    p : (A \lor B) \quad q : (\forall x : A). C[\text{inl}\ x / z] \quad r : (\forall y : B). C[\text{inr}\ y / z]
}{
    \text{cases}^\dagger\ p\ q\ r : C[p / z]
}
$$

- **解释**：
  - $p : A \lor B \)。
  - $q \) 是一个从 $A \) 到 $C \) 的依赖函数，定义在 $\text{inl}\ x \) 上。
  - $r \) 是一个从 $B \) 到 $C \) 的依赖函数，定义在 $\text{inr}\ y \) 上。
  - 我们使用 $\text{cases}^\dagger \) 运算符来构造 $C[p / z] \) 的证明。

**计算规则**与 $\text{cases} \) 的规则相同。

#### **泛化的用途**

这种泛化有什么用呢？

- **函数组合**：运算符 $\text{cases} \) 可以被视为一种将定义在 $A \) 和 $B \) 上的函数 $f \) 和 $g \)（具有共同的余类型 $C \)）组合成一个定义在和类型 $A \lor B \) 上的函数的方法。
- **依赖函数**：泛化的运算符对于**依赖函数**执行了相同的操作，其中结果的类型取决于输入的值。
- **类型族**：依赖函数的结果类型族必须以适当的方式组合在一起；我们通过要求每个都是一个类型族 $C \) 在 $A \lor B \) 上的特化来确保这一点，即 $C[\text{inl}\ x / z] \) 或 $C[\text{inr}\ y / z] \)。

**从逻辑的角度看**，我们有一种方法可以将分别在 $A \) 和 $B \) 上的全称结果的证明提升到 $A \lor B \) 上的全称结果。

**示例**：

- 我们可以选择用和类型 $\text{N} \lor \text{N} \) 来表示整数，或者使用更有提示性的记号：

  $$
  \text{integers} \equiv_{\text{df}} \text{poszro}\ \text{N} + \text{neg}\ \text{N}
  $$

  - 其中，$\text{neg}\ n \) 表示 $-(n + 1) \)。

- 然后，我们可以通过对非负整数和负整数的双重归纳来证明关于整数的结果。

- **定义整数的阶乘函数**：

  $$
  \begin{cases}
  \text{fac}\ 0 \equiv_{\text{df}} 1 \\
  \text{fac}\ (\text{succ}\ n) \equiv_{\text{df}} \text{mult}\ (\text{succ}\ n)\ (\text{fac}\ n) \\
  \text{fac}\ (-1) \equiv_{\text{df}} 1 \\
  \text{fac}\ (-(\text{succ}\ n)) \equiv_{\text{df}} \text{mult}\ (\text{succ}\ n)\ (\text{fac}\ (-n))
  \end{cases}
  $$

- **证明**：对于所有整数 $p \)，$\text{fac}\ p > 0 \)。

#### **练习**

**练习 5.8**：展开上述给出的阶乘的定义，并使用展开的定义证明对于所有整数 $p \)，$\text{fac}\ p \) 是正数。

**练习 5.9**：给出整数上的减法定义，并证明对于所有 $a \) 和 $b \)，有：

$$
(a + b) - b = a
$$

### **5.3.3 存在量词**

我们在第 1 章中陈述的存在量词的消除规则消除了一个假设。在其类型理论形式中，我们有：

**存在量词的消除规则 (∃E')**：

$$
\frac{
    p : (\exists x : A). B \quad [x : A;\ y : B] \vdots c : C
}{
    \text{Cases}_{x,y}\ p\ c : C
}
$$

- **解释**：
  - $p \) 是存在类型 $(\exists x : A). B \) 的一个元素。
  - 我们在假设 $x : A \) 和 $y : B \) 下推导 $c : C \)。
  - 我们使用 $\text{Cases}_{x,y} \) 运算符构造 $C \) 的证明。

**计算规则**：

当 $p = (a, b) \) 时：

$$
\text{Cases}_{x,y}\ (a, b)\ c \to c[a / x,\ b / y]
$$

- **解释**：将 $a \) 替换 $c \) 中的 $x \)，将 $b \) 替换 $c \) 中的 $y \)。

#### **规则的合理性**

- **任意的存在类型的对象**是一个对 $(x, y) \)，其中 $x : A \)，$y : B \)（通常 $y \) 中自由出现 $x \)）。
- 如果我们能够在假设存在 $x \) 和 $y \) 的情况下构造 $c : C \)，我们可以从 $p : (\exists x : A). B \) 中构建该类型的对象，通过用 $p \) 的两个分量替换假设的 $x \) 和 $y \)。
- 我们称由此形成的对象为 $\text{Cases}_{x,y}\ p\ c \)，该运算符绑定 $c \) 中的变量 $x \) 和 $y \)。

当 $\text{Cases}_{x,y} \) 应用于一个对 $(a, b) \) 时，我们将分量替换为相应的组件变量 $x \) 和 $y \)，这解释了计算规则。

#### **泛化的存在量词消除规则**

与析取消除规则类似，我们可以问，类型 $C \) 是否可以是变量的，实际上它可以。

**存在量词的消除规则 (∃E)**：

$$
\frac{
    p : (\exists x : A). B \quad [x : A;\ y : B] \vdots c : C[(x, y) / z]
}{
    \text{Cases}_{x,y}\ p\ c : C[p / z]
}
$$

- **解释**：
  - 在假设 $x : A \) 和 $y : B \) 下，$c : C[(x, y) / z] \)。
    - 即，用对 $(x, y) \) 替换 $C \) 中的 $z \)。
  - 结论中，我们用实际的值 $p \) 替换这个任意的对 $(x, y) \)。

**计算规则**不变。

#### **规则之间的关系**

- **从 (∃E') 规则**，我们可以推导出项 $\text{Fst} \)（取第一分量）：

  - 设 $c \equiv_{\text{df}} x \)，$C \equiv_{\text{df}} A \)，则对于 $p : (\exists x : A). B \) 有：

    $$
    \text{Cases}_{x,y}\ p\ x : A
    $$

  - 计算：

    $$
    \text{Cases}_{x,y}\ (a, b)\ x \to x[a / x,\ b / y] = a
    $$

  - 因此，我们定义：

    $$
    \text{Fst} \equiv_{\text{df}} \lambda p . \text{Cases}_{x,y}\ p\ x
    $$

- **项 $\text{Snd} \)**（取第二分量）更具挑战性，因为其结果的类型依赖于其参数的第一分量的值。

  - 可以证明，$\text{Snd} \) 不能从 (∃E') 推导出来，这是 Swaen 在 8.1.3 节中对各种存在消除规则的刻画的结果。

- **然而，从 (∃E) 规则**，我们可以推导出 $\text{Snd} \)：

  - 我们需要将判断 $y : B \) 转化为 $c : C[(x, y) / z] \) 的形式。
  - 令 $c = y \)，但我们需要将 $B \) 表示为依赖于对 $(x, y) \) 的公式，而不仅仅是变量 $x \)。
  - **解决方法**：

    - 使用 $\text{Fst} \)，将 $B \) 写成：

      $$
      B[(\text{Fst}\ (x, y)) / x]
      $$

    - 于是，我们取 $C \equiv_{\text{df}} B[(\text{Fst}\ z) / x] \)，则：

      $$
      C[(x, y) / z] = B[(\text{Fst}\ z) / x][(x, y) / z] = B[(\text{Fst}\ (x, y)) / x]
      $$

  - 然后，我们有：

    $$
    \text{Cases}_{x,y}\ p\ y : C[p / z] = B[(\text{Fst}\ p) / x]
    $$

    - 当 $p = (a, b) \) 时：

      $$
      \text{Cases}_{x,y}\ (a, b)\ y \to y[a / x,\ b / y] = b
      $$

  - **因此，我们定义**：

    $$
    \text{Snd} \equiv_{\text{df}} \lambda p . \text{Cases}_{x,y}\ p\ y
    $$

- **反过来**，我们现在展示如何从 (∃E') 和引入 $\text{Fst} \)、$\text{Snd} \) 来推导 (∃E) 规则的每个实例。

  - **假设**我们有推导：

    $$
    [x : A;\ y : B] \vdots c : C[(x, y) / z]
    $$

    - 且 $p : (\exists x : A). B \)。

  - 通过规则 (∃E')，我们有：

    $$
    \text{Fst}\ p : A \quad \text{Snd}\ p : B[\text{Fst}\ p / x]
    $$

  - **应用替换规则 (S6)**，两次，我们有：

    $$
    c[\text{Fst}\ p / x][\text{Snd}\ p / y] : C[p / z]
    $$

    - 如果我们用 $p = (a, b) \) 替换，我们得到：

      $$
      c[a / x,\ b / y] : C[p / z]
      $$

      - 这正是我们所需要的。

#### **定义**

**定义 5.3**：我们称第 4 章中的系统加上用于析取消除的规则 (∨E'') 或 (∨E†) 为 $\text{TT}_0 \) 系统。

#### **练习**

**练习 5.10**：使用 (∃E) 规则（以及其他规则），给出选择公理的证明：

$$
(\forall x : A). (\exists y : B). C(x, y) \Rightarrow (\exists f : (A \Rightarrow B)). (\forall x : A). C(x, f(x))
$$

- **问题**：你能使用 (∃E') 代替 (∃E) 吗？

---

## **5.4 可推导性**

在本节中，我们一般性地考察在 $\text{TT}_0 \) 系统及其变体中的可推导性。这些结果将通过对推导的归纳证明。

在研究特定结果之前，值得注意我们采用的类型理论系统的一个特殊属性。

在 $\text{TT}_0 \) 系统中，任何特定的判断，如：

$$
\text{fst}\ (a, b) : A
$$

可以通过两种不同的方式推导出来。

1. **直接使用引入该特定语法的规则**，在此情况下是 (∧E1) 规则。

2. **使用替换规则**，例如 (S2) 规则，来推导相同的结果：

   $$
   \frac{a \leftrightarrow\!\!\leftrightarrow c \quad \text{fst}\ (a, a) : A}{\text{fst}\ (a, c) : A}\ (\text{S2})
   $$

主要的结果是，在适当修改的系统中，可以从 $a : A \) 推导出 $A \) 是一个类型，并且类型是唯一的。

### **定义 5.4**

我们说一个规则：

$$
\frac{J_1\ \dots\ J_k}{J}\ (\text{R})
$$

是**可推导的（derivable）**，如果当我们有判断 $J_1, \dots, J_k \) 的推导 $d_1, \dots, d_k \) 时，我们可以构造判断 $J \) 的推导 $d \)。如果规则 R 的应用消除了任何假设，那么在构造的推导 $d \) 中应该消除适当的假设。

### **5.4.1 从 $a : A \) 推导 $A \) 是一个类型**

我们可能期望系统具有以下性质：

$$
\frac{a : A}{A\ \text{is a type}}
$$

也就是说，我们应该不能从非类型中导出元素或从非公式中导出证明。

**为了使这成为可能，我们需要对规则进行一些修改**。如果我们考虑如何通过对 $a : A \) 的推导树进行归纳来证明这一性质，那么我们会看到规则需要如何改变。证明将是构造性的，即我们在每种情况下都定义 $A\ \text{is a type} \) 的推导。

#### **归纳基础**

归纳的基础是引入变量的推导：

$$
\frac{A\ \text{is a type}}{x : A}\ (\text{AS})
$$

只有当 $A\ \text{is a type} \) 可推导时，才能引入变量 $x \)。

#### **归纳步骤**

例如，对于以 (∧I) 结尾的推导，我们进行归纳：

$$
\frac{a : A \quad b : B}{(a, b) : (A \wedge B)}\ (\wedge I)
$$

如果我们对假设应用归纳假设，那么我们可以推导出 $A\ \text{is a type} \) 和 $B\ \text{is a type} \)，因此使用 (∧F) 规则，我们推导出 $(A \wedge B)\ \text{is a type} \)。

#### **需要修改的规则**

对于某些规则，按照目前的形式是不够的；我们需要在它们中添加形式为 “... 是一个类型” 的附加假设。现在我们逐一查看这些规则。

##### **1. 析取引入规则**

原始规则：

- 左侧引入：

  $$
  \frac{q : A}{\text{inl}\ q : (A \lor B)}\ (\lor I1)
  $$

- 右侧引入：

  $$
  \frac{r : B}{\text{inr}\ r : (A \lor B)}\ (\lor I2)
  $$

在这些规则中，我们在结论中出现了新的类型表达式 $B \) 或 $A \)，我们应该只在它们是类型时引入。因此，我们修订规则为：

- 左侧引入（修订版）：

  $$
  \frac{q : A \quad B\ \text{is a type}}{\text{inl}\ q : (A \lor B)}\ (\lor I1')
  $$

- 右侧引入（修订版）：

  $$
  \frac{r : B \quad A\ \text{is a type}}{\text{inr}\ r : (A \lor B)}\ (\lor I2')
  $$

现在，如果推导的最后一行是析取引入，我们可以从推导中构造 $(A \lor B)\ \text{is a type} \) 的推导。

##### **2. 存在量词引入规则**

原始规则：

$$
\frac{a : A \quad p : P[a / x]}{(a, p) : (\exists x : A). P}\ (\exists I)
$$

为了看到 $(\exists x : A). P \) 是一个类型，我们需要知道在假设 $x : A \) 下 $P \) 是一个类型。我们将其作为规则的第三个前提：

修订版：

$$
\frac{a : A \quad p : P[a / x] \quad [x : A] \vdots P\ \text{is a type}}{(a, p) : (\exists x : A). P}\ (\exists I')
$$

在实践中，我们通常会省略这个第三个前提。

##### **3. 修订的析取和存在量词消除规则**

对于变体规则，例如 (∨E'') 和 (∃E)，我们在类型族 $C \) 中进行替换。修订后的规则是：

- **析取消除规则 (∨E'')**：

  $$
  \frac{
      p : (A \lor B) \quad [x : A] \vdots u : C[\text{inl}\ x / z] \quad [y : B] \vdots v : C[\text{inr}\ y / z] \quad [z : (A \lor B)] \vdots C\ \text{is a type}
  }{
      \text{vcases}_{x,y}\ p\ u\ v : C[p / z]
  }
  $$

- **存在量词消除规则 (∃E)**：

  $$
  \frac{
      p : (\exists x : A). B \quad [x : A;\ y : B] \vdots c : C[(x, y) / z] \quad [z : (\exists x : A). B] \vdots C\ \text{is a type}
  }{
      \text{Cases}_{x,y}\ p\ c : C[p / z]
  }
  $$

其中，附加的假设是 $C \) 是适当类型族的类型。在实践中，我们将省略这些额外的假设。

##### **4. 替换规则**

最后一种情况是推导的最后一个规则是替换规则。考虑 (S2) 的情况：

$$
\frac{c \leftrightarrow\!\!\leftrightarrow a \quad p(c) : B(c)}{p(a) : B(a)}\ (\text{S2})
$$

通过归纳，我们有 $B(c)\ \text{is a type} \) 的推导。应用 (S1) 的实例，结果是显然的：

$$
\frac{c \leftrightarrow\!\!\leftrightarrow a \quad B(c)\ \text{is a type}}{B(a)\ \text{is a type}}\ (\text{S1})
$$

类似地，(S4) 的实例可以被替换为 (S3) 的实例。

#### **定理 5.5**

**使用上述修改的规则，如果我们有 $a : A \) 的推导，我们可以构造 $A\ \text{is a type} \) 的推导。**

**证明**：

- 证明通过对 $a : A \) 的推导进行归纳，遵循上述概述。
- **基础情况**：变量引入已处理。
- **归纳步骤**：对于每个规则，考虑其前提，应用归纳假设，并根据需要修改规则。

**结论**：通过在规则中添加足够的类型假设，我们能够证明所需的性质。

**练习 5.11**：完成定理 5.5 的证明。

### **5.4.2 类型的唯一性**

在像 Pascal 或 Miranda 这样的语言中，表达式的类型是唯一的。我们是否可以期望我们的 $\text{TT}_0 \) 系统也是如此？

**目前，结果在 $\text{TT}_0 \) 中不成立，原因如下**：

1. **函数空间和乘积类型的重复**：因为这些类型可以被视为全称和存在量词类型的特例。未来，我们将 $A \Rightarrow B \) 和 $A \wedge B \) 作为量词形式的简写。

2. **注入运算符 $\text{inl} \) 和 $\text{inr} \) 没有唯一的目标类型**：

   - 事实上，$\text{inl}\ 0 \) 是 $\text{N} \lor A \) 的一个成员，对于任何类型 $A \) 都成立。
   - **解决方法**：给注入运算符加上其目标类型的标签，例如：

     $$
     \text{inl}_{\text{N} \lor A}\ 0 : \text{N} \lor A
     $$

   - 未加标签的运算符可以被视为这些运算符的简写。

#### **定理 5.6**

**在 $\text{TT}_0 \) 中，如果从一致的假设集合中可以推导出 $a : A \) 和 $a : B \)，则 $A \leftrightarrow\!\!\leftrightarrow B \)。**

**证明**：

- 证明通过对 $a : A \) 的推导进行归纳。

- **基础情况**：变量 $x : A \)。这种判断可以通过两种方式之一推导出来：

  1. **假设规则**，此时根据假设集合的一致性，只有一个类型 $A \)。

  2. **替换规则 (S4) 或 (S2)**，此时通过归纳假设，$x \) 的类型在可转换意义下是唯一的，最终步骤仅给出了 $x \) 的一个等价的类型。

- **归纳步骤**：对形成推导的最后一步的规则进行分类讨论。

  - **以析取为例**：

    - 如果表达式具有形式 $\text{inl}_{A \lor B}\ q \)，则当且仅当 $q : A \) 且 $B \) 是一个类型时，它具有类型 $A \lor B \)。
    - 如果表达式具有两个类型，则第二个类型将是 $A' \lor B \) 的形式，这与 $q \) 的唯一类型矛盾（根据归纳假设）。

  - **类似地，对于消除规则**，表达式 $\text{cases}\ p\ f\ g \) 只有当 $f \) 和 $g \) 都有唯一的类型时，才可能有两个类型，这与归纳假设矛盾。

**结论**：类型在可转换意义下是唯一的。

**练习 5.12**：完成上述结果的证明。

**练习 5.13**：证明在从 $\text{TT}_0 \) 删除 (S3) 和 (S4) 的系统中，这些规则是可推导的。是否可以在完全没有替换规则的系统中推导 (S1) 和 (S2) 规则？

---

**总结**：

- 我们修订了类型理论的规则，以确保从 $a : A \) 可以推导出 $A \) 是一个类型。
- 我们讨论了类型的唯一性，并通过修改系统来确保这一性质。
- 通过这些改进，我们的类型理论系统变得更加一致和严谨。

### ---------------------------

# **第5章：探索类型理论**

---

## **5.5 计算**

到目前为止，我们的讲解主要集中在系统的**静态性质**上，即如何推导各种判断。在此过程中，我们引入了一些**计算规则**，这些规则从编程的角度看具有根本的重要性，因为正是这些规则定义了系统的**动态行为**，也就是说，程序是如何执行的。本节将从总体上审视这些规则。

**归约规则**也用于生成一个**可转换关系（conversion）**，这是一个等价关系；可转换的对象被视为相同的，这允许在任何上下文中相互替换。

对于归约，我们感兴趣的问题是我们在第2.3、2.4和2.11节中首先讨论的：

- **计算是否终止（沿所有路径）？**——也就是说，系统是否**（强）规范化**（strongly normalising）？
- **任何两个计算序列是否可以扩展以产生一个共同的表达式——即具有Church-Rosser性质？**

对于系统 $\text{TT}_0 \)，情况就是这样；在本节中，我们介绍两个变体，在文献中它们具有我们所需要的结果。

第一个系统，记为 $\text{TT}_0^\ast \)，其中归约（$\rightarrow \)）是有限制的。这个系统具有规范化性质，但其缺点是它不具备Church-Rosser性质。

第二个系统，称为 $\text{TT}_0^c \)，基于一种完全不同的引入函数和类型的方法，尽管它与 $\text{TT}_0 \) 是等价的。它不是引入像 $\lambda \) 这样的绑定运算符，或像 $\forall \) 等类型形成运算符，而是将函数作为常量引入，每个常量都有相应的归约规则。类型以类似的方式引入。这不仅与像 Miranda 这样的语言的顶层形式有着惊人的相似之处，而且在其细节上也与在函数式语言实现中使用的 $\lambda \)-提升（$\lambda \)-lifting）[Joh85] 和超级组合子（supercombinators）[Hug83] 方法相似。

### **5.5.1 归约**

当我们在函数式编程语言中求值一个表达式时，我们期望最终结果以某种可打印的形式呈现。我们熟悉数字的阿拉伯表示法，列表、树等也可以以语法形式表示。那么，如何打印一个从自然数 $\text{N} \) 到 $\text{N} \) 的函数呢？有两种选择：

1. **外延地描述一个函数**，也就是说，我们说明它在每个参数上的值——这需要打印无限量的信息，这是不可行的。

2. **打印函数的某种程序表示**。不同的结果不一定表示不同的函数，但由于无法实现函数之间的（外延）等价性，我们无法为每个函数提供标准表示。

   - **难点**：实现外延等价性的问题在于，为了得出两个函数相等的结论，需要检查无限量的数据，这个操作是不可计算的。

在某种意义上，这并不是一个问题，因为我们感兴趣的结果将是有限的。（这种方法并不忽略像 Miranda 这样的语言中的“无限”列表——这些是由一系列有限的结果组成的，一个接一个地产生，而不是单个无限的结果。）我们说一个类型是**基本的（ground）**，如果它不涉及任何（嵌入的）函数或全称量化类型，我们将可打印的值定义为那些基本类型的值。对函数类型的对象的求值被礼貌地拒绝，至少在 Miranda 系统中是这样。

在**无类型的 $\lambda \)-演算**中，所有有趣的东西都必须由函数来表示，**β-归约**的不受限制的规则是非常有价值的。在无类型的情况下，我们必须从函数的表示中提取有意义的信息。（[Abr90] 从使其与无类型函数式语言的求值一致的角度，对无类型的 $\lambda \)-演算进行了深入的分析。）因此，规则：

- 如果 $e \rightarrow f \)，则 $\lambda x . e \rightarrow \lambda x . f \)，即使 $x \) 在 $e \) 和 $f \) 中是自由的，这也是至关重要的。

我们称在像 $\lambda x . e \) 这样的表达式中包含的**红ex（redex）**为**在 $\lambda \) 内部的红ex**。

在类型化的情况下，可打印值的求值是完全不同的。函数最终被应用于它们的参数，因此在 $\lambda \)-抽象体内的任何归约都可以推迟，直到参数替换了被绑定的变量。在一个简单的例子中，我们可以看到这一点：

$$
(\lambda x . (\text{II}) x)\ 2 \rightarrow (\lambda x . \text{I} x)\ 2 \rightarrow (\lambda x . x)\ 2 \rightarrow 2
$$

或者，我们可以这样归约：

$$
(\lambda x . (\text{II}) x)\ 2 \rightarrow (\text{II})\ 2 \rightarrow \text{I}\ 2 \rightarrow 2
$$

实际上，不难看出，在最左外的归约序列中，$\lambda \) 内部不会发生归约（参见第2.3节）。这是因为如果最左外的红ex位于 $\lambda \) 内部，那么该 $\lambda \) 将永远不会被归约，因为改变内部的红ex不会改变 $\lambda \) 外部的任何东西。（这在上面的例子中得到了说明，其中第二个序列是最左外的。）

我们给出的论证是为了激励我们对接下来要介绍的系统 $\text{TT}_0^\ast \) 的**归约**进行定义。

#### **练习**

**练习5.14**：在无类型的 $\lambda \)-演算中，自然数 $n \) 表示为“应用 $n \) 次”的函数，即：

$$
\lambda f . \lambda x . f (f (\dots (f x)\dots))
$$

其中 $f \) 应用 $n \) 次。

加法表示为：

$$
\text{add} \equiv_{\text{df}} \lambda f . \lambda g . \lambda h . \lambda x . f\ h\ (g\ h\ x)
$$

证明 $\text{add}\ 2\ 3 \) 归约为 $5 \)，但注意必须使用不受限制的 β-归约规则才能得到结果。

### **5.5.2 系统 $\text{TT}_0^\ast \)**

系统 $\text{TT}_0^\ast \) 包含相同的形成、引入、消除和计算规则。我们只改变了关系“$\rightarrow \)”的定义，从而影响到“$\rightarrow\!\!\rightarrow \)”和“$\leftrightarrow\!\!\leftrightarrow \)”，具体如下：

#### **定义5.7**

如果以下条件成立，我们说表达式 $e \) 在一步中归约为 $f \)：

1. **表示形式**：$e \) 可以表示为 $e \equiv g[e_0 / z] \)，并且 $z \) 不出现在 $g \) 的任何语言绑定构造中。

2. **计算规则**：$e_0 \) 根据计算规则之一归约为 $f_0 \)。

3. **替换结果**：$f \) 是将归约后的 $f_0 \) 替换到 $g \) 中的结果，即 $f \equiv g[f_0 / z] \)。

这种较弱的归约概念与我们之前讨论的**弱头部正常形式（weak head normal form）**的概念有关。我们通过改变归约的定义，而不是我们保持不变的正常形式的定义，达到了类似的概念。

关于这个系统的重要结果如下。

#### **定理5.8（Troelstra）**

系统 $\text{TT}_0^\ast \) 是**强规范化的（strongly normalising）**。

**证明**：

- 证明在 [Tro87] 中给出，是通过将该系统翻译到一个完全不同的系统中完成的，对于这个系统，强规范化定理是我们在第2.7节中证明的一个简单推广。

- 所涉及的系统是**直觉主义有限类型算术（intuitionistic finite-type arithmetic）**，在百科全书式的 [Tro73] 中被称为 $\text{N-HA}^\omega \)。该系统包含了在类型 $\text{N} \) 上构建的乘积和函数空间的类型结构。对于不含乘积的系统的规范化结果参见 [Tro73]，2.2.30，在 [Tro86] 中展示了如何从系统中消除乘积。

- 类型 $A \) 和项 $a \) 的翻译分别记为 $A^\ast \) 和 $a^\ast \)。翻译的关键性质是，尽管在翻译中丢失了 $\text{TT}_0^\ast \) 的一些能力，但**归约是被保留的**，也就是说，如果 $a \rightarrow b \) 在 $\text{TT}_0^\ast \) 中成立，那么 $a^\ast \rightarrow b^\ast \) 在 $\text{N-HA}^\omega \) 中成立。原系统中的一个非终止序列将在目标系统中引发一个非终止序列，这与其强规范化性质相矛盾。

- **翻译如下**：

  - **自然数类型**：

    $$
    \text{N}^\ast \equiv_{\text{df}} \text{N}
    $$

    这是显然的翻译。

  - **等式类型**，具有一个元素，被表示为：

    $$
    (\text{I}(A, a, b))^\ast \equiv_{\text{df}} \text{N}
    $$

    其单个元素由 $0 \) 表示。类似地，我们也可以表示布尔值，以及所有有限类型。

- 通过选择将 $\text{I} \) 类型表示为一个常量类型 $\text{N} \)，我们消除了类型对值的任何依赖性，因此我们有：

  - **全称量化类型**：

    $$
    ((\forall x : A). B)^\ast \equiv_{\text{df}} A^\ast \rightarrow B^\ast
    $$

  - **存在量化类型**：

    $$
    ((\exists x : A). B)^\ast \equiv_{\text{df}} A^\ast \times B^\ast
    $$

  - 将量化类型表示为其非变量特例。

- 这些类型的元素的映像由：

  - **λ-抽象**：

    $$
    (\lambda x . e)^\ast \equiv_{\text{df}} \lambda x . (e^\ast)
    $$

  - **构造对**：

    $$
    (a, b)^\ast \equiv_{\text{df}} (a^\ast, b^\ast)
    $$

- 唯一的技巧在于对和类型的编码，它被映射为一个乘积：

  $$
  (A \lor B)^\ast \equiv_{\text{df}} \text{N} \times A^\ast \times B^\ast
  $$

  - 我们用 $(0, a, 0_{B^\ast}) \) 表示 $\text{inl}\ a \)，用 $(1, 0_{A^\ast}, b) \) 表示 $\text{inr}\ b \)。

  - $0_{A^\ast} \)，$0_{B^\ast} \) 是固定的“哑”值，它们是恒为零的函数或其乘积，取决于类型 $A \)、$B \) 的形式。

  - 利用自然数 $\text{N} \) 上的原始递归，可以实现对不交并的 $\text{cases} \) 运算符。

- 为了完成证明，我们只需检查如果 $a \rightarrow b \)，那么 $a^\ast \rightarrow b^\ast \)，这留给读者作为练习。

**结论**：因此，系统 $\text{TT}_0^\ast \) 是强规范化的。

**评论**：

- 我们应该注意，系统 $\text{N-HA}^\omega \) 比 $\text{TT}_0 \) 更简单，因为它不包含依赖类型。

- 正如从证明中可以看出，系统的归约性质通过一种翻译得到保留，该翻译丢失了这些依赖性，将全称和存在类型分别简化为函数空间和乘积。

**系统 $\text{TT}_0^\ast \) 的问题**：

- **Church-Rosser 性质失效**，如下例所示：

  $$
  (\lambda x . (\lambda y . x))\ (\text{II}) \rightarrow (\lambda x . (\lambda y . x))\ \text{I} \rightarrow \lambda y . \text{I}
  $$

  而如果我们首先归约外层的红ex，则有：

  $$
  (\lambda x . (\lambda y . x))\ (\text{II}) \rightarrow \lambda y . (\text{II})
  $$

- 这些序列的最终项都是正常形式，因为不允许在 $\lambda \) 内部进行归约，并且是不同的，因此不存在一个项来完成两者之间的“菱形”（diamond）。

- **这个失败发生在具有函数类型的项上**，因此我们可能会问，是否可以对基本类型声称一个有限的结果。

  - 看起来应该有这样的结果，但如何建立它是一个开放的问题。

- **在函数类型上的失败**实际上仍然令人沮丧，因为随着我们的推进，其原因将变得更加清晰。

- **没有 Church-Rosser 性质，我们无法建立正常形式的唯一性**，这反过来意味着关系“$\leftrightarrow\!\!\leftrightarrow \)”是可判定的：我们将两个项归约到它们的正常形式，然后查看它们是否相同。接下来的系统将具有这些理想的性质。

#### **练习**

**练习5.15**：证明在定理5.8的证明中，翻译尊重归约，即如果 $a \rightarrow b \)，那么 $a^\ast \rightarrow b^\ast \)。

**练习5.16**：论证在系统 $\text{TT}_0^\ast \) 中的正常形式的对象在具有不受限制的 β-归约的系统中处于弱头部正常形式。

### **5.5.3 组合子和系统 $\text{TT}_0^c \)**

在上一节中，我们修改了“$\rightarrow \)”的定义，不允许在 $\lambda \) 下进行归约；在这里，我们修改系统，给出了一个完全不同的关于函数抽象和类型形成的描述。

我们迄今为止讨论的所有系统都共享一个方面：每个系统都使用了 $\lambda \)-抽象作为形成函数类型项的方法。给定一个一般涉及变量 $x \)（以及其他变量）的项 $e \)，我们可以形成项 $\lambda x . e \)，具有以下性质：

$$
(\lambda x . e)\ a \rightarrow e[a / x]
$$

例如，$\lambda x . (x + y) \) 和 $\lambda x . (\text{II}) \)，其中红ex $(\text{II}) \) 仍然可见。

一种替代方法是为该项创建一个函数或组合子定义，表示为：

$$
f\ x \rightarrow e
$$

但这样做会有一个问题，如我们在上面的加法例子中所见。我们的定义将是：

$$
f\ x \rightarrow (x + y)
$$

其中右侧包含一个未绑定的变量 $y \)。为了正确地定义一个函数，我们需要在参数中包含变量 $y \)，并写作：

$$
f\ y\ x \rightarrow (x + y)
$$

现在，项 $\lambda x . (x + y) \) 将被项 $f\ y \) 所取代，因为正是这个应用表示了对 $x \) 的抽象。一般来说，以这种方式形成的函数常量需要将表达式中自由出现的所有变量（除了被抽象的变量）作为参数。这些变量可以称为**参数（parameters）**。

为了形成感兴趣的抽象，必须将这些参数传递给常量，以形成所需的抽象。在上面加法函数的例子中，对 $x \) 的抽象由项 $f\ y \) 给出，而不是“裸”的常量 $f \)。

对于上面的第二个例子 $\lambda x . (\text{II}) \)，定义更简单，我们只需写作：

$$
c\ x \rightarrow (\text{II})
$$

并形成项 $c \)。注意，在常量 $c \) 中没有红ex。这种常量定义的方法将函数体内的红ex隐藏起来，只有当函数被应用于足够多的参数时才使它们可见。

#### **定义5.9：组合子抽象**

假设判断 $e : B \) 的推导依赖于假设：

$$
x_1 : A_1,\ x_2 : A_2,\ \dots,\ x_k : A_k,\ x : A
$$

那么我们可以形成一个新的函数常量 $f \)，它将以类型 $A_1, A_2, \dots, A_k \) 的参数（作为“参数”）和 $A \) 作为参数，给出类型为 $B \) 的结果。换句话说，我们可以引入项：

$$
f\ x_1\ \dots\ x_k
$$

其类型为 $(\forall x : A). B \)。该项的计算规则为：

$$
f\ x_1\ \dots\ x_k\ x \rightarrow e
$$

我们可以直接给出新常量 $f \) 的类型：

$$
(\forall x_1 : A_1) . \dots . (\forall x_k : A_k) . (\forall x : A) . B
$$

当 $B \) 不依赖于任何变量时，简化为：

$$
A_1 \rightarrow \dots \rightarrow A_k \rightarrow A \rightarrow B
$$

引入规则可以写成熟悉的形式：

$$
\frac{[x : A] \vdots e : B}{f\ x_1\ \dots\ x_k : (\forall x : A) . B}\ (\forall I_c)
$$

其中推导的假设中未消除的假设是 $x_1 : A_1, \dots, x_k : A_k \)，要引入的新常量称为 $f \)。该项的计算规则如上所述，类型 $(\forall x : A) . B \)（因此也适用于蕴含 $A \rightarrow B \)）的形成和消除规则与以前相同。

#### **示例**

让我们考虑一个简单的例子。假设我们已经推导出 $A \) 和 $B \) 是类型，那么基于假设：

$$
x : A,\ y : B
$$

我们可以推导出：

$$
x : A
$$

假设我们希望形成（非正式的）表达式 $\lambda x . \lambda y . x \)，我们首先必须对 $y \) 进行抽象。在此过程中，我们产生一个二元函数常量 $f \)，它将自由变量 $x \) 作为参数，以及被定义绑定的变量 $y \)：

$$
f\ x\ y \rightarrow x
$$

我们形成项：

$$
f\ x : B \rightarrow A
$$

这是基于假设 $x : A \)。现在我们可以对 $x \) 进行抽象，得到常量 $g \)，其性质为：

$$
g\ x \rightarrow f\ x
$$

并且类型为：

$$
g : A \rightarrow (B \rightarrow A)
$$

（实际上在这种情况下，$f \) 和 $g \) 具有相同的性质，但通常情况下，第二次及以后的抽象是非平凡的。）

我们可以考虑前面给出的项的例子，该项为系统 $\text{TT}_0^\ast \) 的 Church-Rosser 性质的反例：

$$
(\lambda x . (\lambda y . x))\ (\text{II})
$$

现在，这由项 $g\ (\text{II}) \) 表示，其归约如下：

$$
g\ (\text{II}) \rightarrow f\ (\text{II})
$$

项 $f\ (\text{II}) \) 本身并不形成红ex，因为函数常量 $f \) 在其归约规则中有两个形式参数，而在这种情况下它只提供了一个参数——Church-Rosser 定理在这种情况下没有被违反。实际上，它从未被违反，正如我们将在下一节中看到的。

#### **重要观察**

从目前所说的内容来看，在抽象内部不可能发生归约。在 $\lambda x . (\text{II}) \) 的例子中，我们看到它被常量 $c \) 所表示，其归约规则为：

$$
c\ x \rightarrow (\text{II})
$$

因此，对函数项本身（由 $c \) 给出）不可能进行归约。这里要做的关键观察是，同一个 $\lambda \) 表达式可以通过常量抽象以不同的方式表示。线索在于将表达式 $\text{II} \) 视为一个参数的实例，在这种情况下，我们将整个表达式视为表达式：

$$
\lambda x . y
$$

其中 $y \) 具有适当的类型。这里的抽象导致常量：

$$
c'\ y\ x \rightarrow y
$$

特定的表达式由 $c'\ (\text{II}) \) 表示。在这个 $\lambda x . (\text{II}) \) 的表示中，红ex $(\text{II}) \) 是可见的，因此可以被归约，得到 $c'\ \text{I} \)，表示 $\lambda x . \text{I} \)。

#### **定义5.10：自由子表达式**

如果 $x \) 在 $e \) 中不自由出现，那么 $e \) 的一个**子表达式 $f \)** 是关于 $x \) 的**自由子表达式**。如果 $f \) 不是关于 $x \) 的自由子表达式的真子表达式，那么这样的表达式就是关于 $x \) 的**最大自由表达式（mfe）**。

#### **定义5.11：超级组合子抽象**

为了在 $e \) 上对 $x \) 进行超级组合子抽象，我们首先识别 $e \) 中关于 $x \) 的 mfes $f_1, f_2, \dots, f_l \)。我们现在引入一个新的常量 $g \)，其归约规则为：

$$
g\ k_1\ \dots\ k_l\ x \rightarrow e[k_1 / f_1, \dots, k_l / f_l]
$$

$e \) 在 $x \) 上的抽象由：

$$
g\ f_1\ \dots\ f_l
$$

给出。

现在，我们看一个具体的例子，对项 $\lambda x . \lambda y . ((\text{II}) x) \) 进行超级组合子抽象。

首先，我们对 $\lambda y . ((\text{II}) x) \) 进行超级组合子抽象。

- 在函数体中有一个 mfe，$((\text{II}) x) \)，因此我们形成常量 $c \)，其归约规则为：

  $$
  c\ k_1\ y \rightarrow k_1
  $$

- 超级组合子抽象为：

  $$
  c\ ((\text{II}) x)
  $$

现在，我们对 $x \) 进行抽象。

- 在上面的表达式中有一个 mfe，$\text{II} \)，我们形成常量 $d \)，其归约规则为：

  $$
  d\ k_1\ x \rightarrow c\ (k_1\ x)
  $$

- 最终的抽象为：

  $$
  d\ (\text{II})
  $$

**重要的是要观察到，在这个超级组合子抽象中，红ex $(\text{II}) \) 是可见的。一般情况下都是如此。**

#### **定义5.12：系统 $\text{TT}_0^c \)**

从 $\text{TT}_0 \) 定义系统 $\text{TT}_0^c \) 如下：

- 所有的类型形成规则都被修改，使得类型作为常量引入。
- 可以选择参数，使得某些红ex可见，其他红ex不可见。
- 函数和全称量化引入规则按照上述方式修改，使用绑定运算符 $\text{vcases} \) 的 (∨E'') 规则也是如此。

#### **引理5.13**

**如果我们使用超级组合子抽象算法在 $\text{TT}_0^c \) 中进行函数抽象，那么所有在 $\text{TT}_0 \) 中可以归约的红ex，即所有自由的红ex，都可以在 $\text{TT}_0^c \) 中归约。**

因此，存在一个系统 $\text{TT}_0 \) 到 $\text{TT}_0^c \) 的嵌入，它保留了前者的归约和计算性质。我们将在下一节中研究 $\text{TT}_0^c \) 的这些性质，并在那里为 $\text{TT}_0 \) 声称显然的推论。

注意，为了易读性，我们将保留类型形成操作的旧符号，但我们应该始终记住，它是一个更具表现力的符号，可以以不同的方式描述特定的表达式，使红ex可见或不可见。

#### **练习**

**练习5.17**：给出项 $h \equiv_{\text{df}} \lambda a . \lambda b . \lambda c . (a\ b\ c) \) 的组合子和超级组合子抽象。

**练习5.18**：使用前一练习中编译的两个版本的代码，跟踪表达式 $h\ (\text{II})\ (\text{II})\ 3 \) 的求值行为。

**练习5.19**：证明上述引理5.13。

---

**总结**：

- 我们讨论了系统 $\text{TT}_0^\ast \) 的归约定义，以及它的强规范化性质，但它不具有 Church-Rosser 性质。

- 然后，我们引入了系统 $\text{TT}_0^c \)，它使用组合子和超级组合子抽象，对函数抽象和类型形成提供了完全不同的描述。

- 通过这种方法，我们能够保留所有可以在 $\text{TT}_0 \) 中归约的红ex，并且系统 $\text{TT}_0^c \) 具有更好的归约性质。

- 这些讨论为我们进一步研究类型理论的计算行为奠定了基础。

### ----------------------------

# **第5章：探索类型理论**

---

## **5.6 系统 $\text{TT}_0^c \)：规范化及其推论**

在本节中，我们将证明类型理论系统 $\text{TT}_0^c \) 的每个项都有一个**正常形式（normal form）**，这个结果可以加强为**强规范化（strong normalisation）**结果。证明采用了 Tait 风格的证明方法，正如我们在第2.7节中首次看到的，它基于 Martin-Löf 对其1975年系统的规范化证明 [ML75b]。由于我们省略了 Martin-Löf 证明中携带的证明信息（这最初是为了使证明在理论本身中局部形式化 [ML75a]，第2.1.4节），我们的论述更为简单；这里的方法不那么形式化。该证明以一种方式进行，使其对系统有许多重要的推论，包括正常形式的唯一性，以及归约的 Church-Rosser 性质。Martin-Löf 指出，据他所知，Church-Rosser 性质没有直接的组合学证明，这条路线提供了唯一的证明方法。

正如我们迄今为止多次看到的，在类型理论中，类型和对象是通过**同时归纳**定义的，这意味着我们必须以不同于类型化 $\lambda \)-演算的方式来证明事物。在第2.7节中，我们能够首先通过类型的归纳来定义稳定性，然后展示所有元素都是稳定的。这里，我们通过对闭合判断的推导进行归纳来工作：

$$
a : A \quad A\ \text{is a type}
$$

（一个**闭合判断（closed judgement）**是不依赖任何假设的判断，因此特别地，$a \) 和 $A \) 是闭合的。）

归纳定义了：

- **$A^0 \)**：$A \) 的闭合正常形式。
- **$a^0 \)**：$a \) 的闭合正常形式，使得 $a \rightarrow\!\!\rightarrow a^0 \)。此外，$a^0 \) 也是集合 $\| A \| \) 的成员。
- **$\| A \| \)**：类型 $A \) 的**稳定项（stable terms）**的集合，这些项是类型 $A^0 \) 的成员。我们的证明将展示每个闭合项都可归约到一个稳定项，这些项显然是闭合且正常的。

由于开放推导中的假设可以被消除，我们还需要查看开放判断和推导。对于在上下文：

$$
x_1 : A_1,\ x_2 : A_2,\ \dots,\ x_n : A_n
$$

中的开放判断 $a : A \)，我们也定义函数 $a^0 \) 和 $A^0 \)，它们依赖于元变量：

$$
x_1^0,\ x_2^0,\ \dots,\ x_n^0
$$

这些变量分别在类型 $A_1^0,\ A_2^0,\ \dots,\ A_n^0 \) 上取闭合正常形式的值。

重要的是要注意，这些函数通常不是由系统的项定义的：它们是根据作为其参数的闭合正常形式分配闭合正常形式的操作。

为了选择一个具体的例子，如果 $a : \text{N} \) 依赖于 $x : \text{N} \)，那么 $a^0 \) 将是从数字到数字的函数，因为数字是自然数类型的闭合正常形式。

我们对函数 $a^0 \) 和 $A^0 \) 有两个要求：

1. **归约一致性**：对于所有闭合正常形式 $a_1^0 : A_1^0,\ \dots,\ a_n^0 : A_n^0 \)，我们有：

   $$
   a[a_1^0 / x_1^0,\ \dots,\ a_n^0 / x_n^0] \rightarrow\!\!\rightarrow a^0[a_1^0 / x_1^0,\ \dots,\ a_n^0 / x_n^0]
   $$

   （对于 $A^0 \) 有类似的定义。）

2. **替换的可交换性**：给定推导：

   $$
   a_1 : A_1,\ \dots,\ a_n : A_n[a_1 / x_1,\ \dots,\ a_{n-1} / x_{n-1}]
   $$

   我们要求：

   $$
   (a(a_1,\ \dots,\ a_n))^0 \equiv a^0(a_1^0,\ \dots,\ a_n^0)
   $$

   （记住我们使用 $\equiv \) 表示“在换名下相同”）。在证明中，我们说如果 $a^0 \) 具有这对性质，则它是**参数化的（parametric）**。

### **定理5.14（$\text{TT}_0^c \) 的规范化）**

**类型理论的每个闭合项 $b \) 都有一个正常形式 $b^0 \)，并且如果 $b \leftrightarrow\!\!\leftrightarrow c \)，那么 $b^0 \equiv c^0 \)。**

**证明**：

- 如上所述，我们使用对判断推导长度的归纳。
- 我们必须依次遍历理论的构造。
- 我们还必须在每一步验证分配给计算规则两边的正常形式是相等的，例如：

  $$
  \text{fst}\ (a, b) \rightarrow a
  $$

- 这在证明分配给可转换项的正常形式是相同的过程中使用。
- 我们不会涵盖函数空间或合取的情况，因为它们只是全称和存在量化类型的特例。

在我们逐一查看各个情况之前，值得检查一下 $\text{TT}_0^c \) 中类型形成的确切机制。

假设我们想要形成一个类型，例如：

$$
(\forall x : \text{N}).\ \text{I}(\text{N}, f\ x, 0 + 0)
$$

有多种方式可以做到这一点。

- 第一种方法，我们简单地基于此形成一个新的类型常量。
- 但我们也可以形成一个参数化于 $y \) 的类型运算符，得到：

  $$
  (\forall x : \text{N}).\ \text{I}(\text{N}, f\ x, y)
  $$

- 在我们的特定情况下，我们将其应用于（自由的）表达式 $0 + 0 \)，允许其被归约。
- 如果一个表达式如此参数化，那么在正常形式中，参数本身将被归约为正常形式。
- 在下面，我们假设类型没有参数化，但这只是为了符号的清晰。

#### **情况分析**

##### **情况：变量 $x \)**

- 我们定义 $x^0 \) 为（非正式的）变量 $x^0 \)。显然这是参数化的。

##### **情况：全称量化 $\forall \)**

- 形成规则引入了一个新的常量，为简单起见，我们使用简写 $(\forall x : A). B \)。
- 正如我们上面所说，我们将假设类型未参数化，因此我们定义：

  $$
  ((\forall x : A). B)^0 \equiv_{\text{df}} (\forall x : A). B
  $$

- 对于其他类型形成操作，我们也做类似的定义，除了等式类型 $\text{I} \)。
- 类型 $(\forall x : A). B \) 的稳定项的集合 $\| (\forall x : A). B \| \) 包含所有闭合正常项 $c^0 \)（类型为 $(\forall x : A). B \)），满足对于所有类型 $A^0 \) 中的闭合正常形式 $a^0 \)，$(c^0\ a^0) \) 可归约为 $B^0[a^0 / x] \) 中的闭合正常形式。

- **$\forall \) 引入**给出了一个 $\lambda \)-抽象 $\lambda x . e \)。如果我们使用超级组合子抽象，我们有一个新常量 $f \)：

  $$
  f\ k_1\ \dots\ k_l\ x \rightarrow e[k_1 / f_1,\ \dots,\ k_l / f_l]
  $$

  其中 $f_1, \dots, f_l \) 是关于 $x \) 的最大自由表达式（mfes）。抽象本身定义为：

  $$
  f\ f_1\ \dots\ f_l
  $$

- 现在，$f^0 \equiv_{\text{df}} f \) 是正常形式。
- 表达式 $f\ f_1\ \dots\ f_l \) 的正常形式将在下面的 $\forall \) 消除中给出。

- 如果我们将自己限制在没有参数 $k_i \) 的简单情况，那么 $f^0 \) 是稳定的，因为对于任何闭合正常形式 $a^0 \)：

  $$
  f^0\ a^0 \rightarrow e[a^0 / x] \rightarrow\!\!\rightarrow e^0[a^0 / x] \equiv (e[a / x])^0
  $$

  其中等价性由 $e \) 的参数化性质（我们通过归纳假设）保证。

- 对于一般情况，我们以类似的方式论证，同时还引用下面的 $\forall \) 消除情况。

- **$\forall \) 消除**给出了一个应用。我们定义 $(f\ a)^0 \) 为 $f^0\ a^0 \) 归约到的闭合正常形式，根据归纳和对全称类型的可转换性的定义，这个正常形式存在。

- **计算规则**对于 $\forall \) 表示：

  $$
  f\ a \rightarrow e[a / x]
  $$

- 现在观察到：

  $$
  (f\ a)^0 \equiv e^0[a^0 / x] \equiv (e[a / x])^0
  $$

  第一个等价性来自于 $\lambda \)-抽象的可转换性的定义，第二个来自于 $e^0 \) 的参数化性质。

- 不难看出，$\forall \) 引入和消除的定义是参数化的。

##### **情况：存在量化 $\exists \)**

- 对于全称类型，我们定义：

  $$
  ((\exists x : A). B)^0 \equiv_{\text{df}} (\exists x : A). B
  $$

- 该类型的稳定项是稳定项的对 $(a^0, b^0) \)，其中 $a^0 : A^0 \)，$b^0 : B^0[a^0 / x] \)。

- **引入规则**引入一个对，我们定义：

  $$
  (a, b)^0 \equiv_{\text{df}} (a^0, b^0)
  $$

- **消除规则** $(\exists \text{E}_1^0) \) 和 $(\exists \text{E}_2^0) \) 引入投影运算符。如果我们有项：

  $$
  \text{Fst}\ p \quad \text{Snd}\ p
  $$

  那么 $p^0 \)，即 $p \) 的闭合正常形式，将是一个对 $(q^0, r^0) \)。因此，我们设置：

  $$
  (\text{Fst}\ p)^0 \equiv_{\text{df}} q^0 \quad (\text{Snd}\ p)^0 \equiv_{\text{df}} r^0
  $$

- 参数化的对的参数化项将是参数化的，因此一个参数化对的分量也是参数化的，因此这两个构造保持参数化性。这将类似地适用于所有其他非变量绑定的构造。

- 最后，我们应该检查计算规则两边的正常形式是相同的。规则表明：

  $$
  \text{Fst}\ (q, r) \rightarrow q \quad \text{Snd}\ (q, r) \rightarrow r
  $$

- 根据上面的定义：

  $$
  (\text{Fst}\ (q, r))^0 \equiv (\text{Fst}\ (q^0, r^0)) \equiv q^0
  $$

  这正是我们所需要的。对于 $\text{Snd} \) 也有类似的证明。

##### **情况：析取 $\lor \)**

- 我们定义：

  $$
  (A \lor B)^0 \equiv_{\text{df}} A^0 \lor B^0
  $$

- 并将稳定元素的集合 $\| A \lor B \| \) 定义为 $\| A \| \lor \| B \| \)。

- **引入规则**：将对象注入到左侧或右侧。我们定义：

  $$
  (\text{inl}\ a)^0 \equiv_{\text{df}} \text{inl}\ a^0 \quad (\text{inr}\ b)^0 \equiv_{\text{df}} \text{inr}\ b^0
  $$

- **消除规则**：通过 $(\lor \text{E}^0) \) 使用 $\text{vcases}_0 \) 构造，$\text{vcases}_0\ x, y\ p\ u\ v \)。$p^0 \) 将采取 $\text{inl}\ q^0 \) 或 $\text{inr}\ r^0 \) 的形式。

  - 在第一种情况下，令：

    $$
    (\text{cases}\ p\ u\ v)^0 \equiv_{\text{df}} u^0[q^0 / x]
    $$

  - 在第二种情况下，令：

    $$
    (\text{cases}\ p\ u\ v)^0 \equiv_{\text{df}} v^0[r^0 / y]
    $$

- 由参数化性质，定义的形式是稳定的，参数化性也由定义保持。检查 $\text{vcases} \) 的计算规则得到尊重也很容易。

##### **情况：底类型 $\bot \)**

- $\bot^0 \) 定义为 $\bot \) 本身，稳定项的集合是空集。

- 没有类型为 $\bot \) 的项的引入规则，但有消除规则。我们写作：

  $$
  (\text{abort}_A\ p)^0 \equiv_{\text{df}} \text{abort}_{A^0}\ p^0
  $$

- 这显然满足参数化性。由于没有引入规则，也没有计算规则，因此无需检查任何条件。实际上，这种情况是有限类型的特例，接下来讨论。

##### **情况：有限类型 $\text{N}_n \)**

- $\text{N}_n^0 \) 的定义为 $\text{N}_n \)，稳定项为 $1_n, 2_n, \dots, n_n \)。

- 显然，对于引入规则，我们有：

  $$
  1_n^0 \equiv_{\text{df}} 1_n,\ \dots,\ n_n^0 \equiv_{\text{df}} n_n
  $$

- **消除规则**：我们有 $n \) 路的 case 语句：

  $$
  \text{cases}_n\ e\ c_1\ \dots\ c_n
  $$

- $e^0 \) 将是 $m_n \)，其中 $1 \leq m \leq n \)。我们定义：

  $$
  (\text{cases}_n\ m_n\ c_1\ \dots\ c_n)^0 \equiv_{\text{df}} c_m^0
  $$

- 再次，参数化性显然。计算规则根据 $\text{N}_n \) 类型的对象的值选择适当的情况，这在定义中得到了尊重。

- 注意，这也涵盖了 $\top \)、布尔类型，甚至 $\bot \) 的特例。

##### **情况：自然数 $\text{N} \)**

- $\text{N}^0 \) 定义为 $\text{N} \)，稳定项的集合通过（元理论的）归纳定义：

  - **基始**：$0 \) 是一个稳定项。
  - **归纳**：如果 $n \) 是稳定项，则 $\text{succ}\ n \) 是稳定项。

- 显然，我们可以定义引入规则的正常形式：

  $$
  0^0 \equiv_{\text{df}} 0 \quad (\text{succ}\ n)^0 \equiv_{\text{df}} \text{succ}\ n^0
  $$

- **消除规则**：我们有形式为 $\text{prim}\ m\ c\ f \) 的项。$m^0 \) 将是 $0 \) 或 $\text{succ}\ n \)，其中 $n \) 为某个自然数。

- 通过对 $m^0 \) 的归纳，我们定义：

  - 基始情况：

    $$
    (\text{prim}\ 0\ c\ f)^0 \equiv_{\text{df}} c^0
    $$

  - 归纳步骤：

    $$
    (\text{prim}\ (\text{succ}\ n)\ c\ f)^0 \equiv_{\text{df}} y
    $$

    其中 $y \) 是通过应用：

    $$
    f^0\ n\ (\text{prim}\ n\ c\ f)^0
    $$

    得到的项的正常形式。这存在于具有函数类型的 $f^0 \) 的正常形式的定义，以及 $n \) 和 $(\text{prim}\ n\ c\ f)^0 \) 本身是正常形式这一事实。

- 参数化性和尊重计算规则可以得到保证。

- 我们以类似的方式处理类型 $\text{tree} \)。

##### **情况：等式类型 $\text{I} \)**

- 我们定义：

  $$
  \text{I}(A, a, b)^0 \equiv_{\text{df}} \text{I}(A^0, a^0, b^0)
  $$

- 稳定项的集合由 $r(a^0) \) 构成。

- **引入规则**引入 $r \)，我们定义：

  $$
  (r(a))^0 \equiv_{\text{df}} r(a^0)
  $$

- **消除规则**：我们形成 $J(c, d) : C(a, b, c) \)。$c \) 的唯一正常形式是 $r(a^0) \)，我们定义：

  $$
  (J(r(a^0), d))^0 \equiv_{\text{df}} d^0
  $$

- 由于在计算规则中，我们将 $J(r(a), d) \) 归约为 $d \)，我们看到这个规则在正常形式的定义中得到了尊重。同样，参数化性得以保持。

这涵盖了所有情况，因此我们已经证明所有闭合项都有一个闭合正常形式。我们还验证了对于每个归约规则 $b \rightarrow c \)，正常形式是相同的：$b^0 \equiv c^0 \)。在关系“$\leftrightarrow\!\!\leftrightarrow \)”上进行归纳足以表明，如果 $b \leftrightarrow\!\!\leftrightarrow c \)，那么 $b^0 \equiv c^0 \)。

这完成了规范化定理的证明。**∎**

---

**规范化结果本身很重要，表明所有表达式都有一个值，特别地，所有基本类型的表达式都有一个可打印的值。此外，证明本身也可以产生其他结果。**

### **推论5.15**

**存在一个 $\text{TT}_0^c \) 系统的模型。**

**证明**：

- 使用定理的证明，类型可以由集合 $\| A \| \) 来建模，闭合项 $a \) 由它们的闭合正常形式 $a^0 \) 表示，$a^0 \) 是集合 $\| A \| \) 的成员。**∎**

### **推论5.16**

**如果 $a \) 和 $b \) 是可互换的闭合正常项，那么它们是相同的。**

**证明**：

- Martin-Löf 将此结果归功于 Peter Hancock。
- $a \) 和 $b \) 分别归约到 $a^0 \) 和 $b^0 \)，但由于 $a \) 和 $b \) 是正常的，$a \equiv a^0 \)，$b \equiv b^0 \)。
- 我们知道，如果 $a \leftrightarrow\!\!\leftrightarrow b \)，那么 $a^0 \equiv b^0 \)，通过“$\equiv \)”的传递性，我们得出结果。**∎**

### **推论5.17**

**正常形式是唯一的。**

**证明**：

- 如果 $a \) 有两个正常形式 $b \) 和 $c \)，它们是可互换的，因此根据推论5.16，它们是相同的。**∎**

### **定理5.18（Church-Rosser）**

**如果 $a \) 和 $b \) 是闭合项，那么 $a \leftrightarrow\!\!\leftrightarrow b \) 当且仅当 $a \) 和 $b \) 有一个公共的归约项。**

**证明**：

- “如果”部分是显然的。
- 如果 $a \leftrightarrow\!\!\leftrightarrow b \)，那么正常形式 $a^0 \) 和 $b^0 \) 将是可互换的，因此是相同的。这个正常形式是一个公共的归约项。**∎**

### **定理5.19**

**在 $\text{TT}_0^c \) 中，正常形式如下：**

| 类型                                            | 正常形式                                             |
| ----------------------------------------------- | ---------------------------------------------------- |
| $A \wedge B \)、$(\exists x : A). B \)      | $(a^0, b^0) \)                                     |
| $A \rightarrow B \)、$(\forall x : A). B \) | $f^0 \)                                            |
| $A \lor B \)                                  | $\text{inl}\ a^0 \)、$\text{inr}\ b^0 \)         |
| $\text{I}(A, a, b) \)                         | $r(a^0) \)                                         |
| $\text{N}_n \)                                | $m_n \)                                            |
| $\text{N} \)                                  | $0 \)、$\text{succ}\ n^0 \)                      |
| $\text{tree} \)                               | $\text{Null} \)、$\text{Bnode}\ n^0\ u^0\ v^0 \) |

- 其中 $a^0, b^0, \dots \) 本身是闭合正常形式。

**证明**：

- 在规范化定理5.14中给出的正常形式 $a^0 \) 具有上述形式。
- 根据推论5.17，任何正常形式都将与5.14中产生的形式相同。**∎**

### **定理5.20**

**可转换关系是可判定的——存在一个机械过程，可以决定任意的 $a \)、$b \) 是否 $a \leftrightarrow\!\!\leftrightarrow b \)。**

**证明**：

- 为了判定，将 $a \) 和 $b \) 归约到它们的正常形式，如在定理5.14中。
- $a \) 和 $b \) 是可转换的，当且仅当 $a^0 \) 和 $b^0 \) 是相同的。**∎**

这是一个理想的结果。我们之前规定，我们将把可互换的表达式视为表示相同的对象，并且我们能够相互替换可转换的元素。通过这个结果，我们能够决定何时两个推导是相同的，因为我们可以检查它们中出现的项和类型何时可以被认为表示相同的对象。

Martin-Löf 还论证，我们可以决定给定的判断 $a : A \) 是否可推导。

### **定理5.21**

**对于 $\text{TT}_0^c \)，可推导性是可判定的。**

**证明**：

- 给定 $A \) 和 $a \)，我们首先将类型符号 $A \) 归约为正常形式，然后我们可以决定它是否确实是一个类型的正常形式。
- 如果是，我们以类似的方式归约表达式 $a \)，并询问 $a^0 \) 是否是类型 $A^0 \) 的正常形式。**∎**

按照系统的呈现方式，可推导性显然是半可判定的：一个判断是可推导的，当且仅当存在它的推导。关系实际上是可判定的，这令人惊讶，但不应该如此。回想一下，我们推导形式为：

- $a \) 是命题 $A \) 的证明，或
- $a \) 是类型 $A \) 的对象

的判断，在许多情况下，这些关系是可判定的。这正是我们选择讨论 Martin-Löf 早期的内涵系统 [ML75b] 而不是更近的外延系统 [ML85] 的原因。在下一节中，我们将更详细地查看系统中的各种等价性，并更详细地解释我们对外延性的处理。

---

**练习**

**练习5.20**：完成上述规范化定理的证明概要。

**练习5.21**：在规范化证明中，为以下项定义的 $a^0 \) 和 $b^0 \) 是什么？

- $a \equiv_{\text{df}} \lambda y . x \)
- $b \equiv_{\text{df}} \lambda x . \lambda y . x \)

---

## **5.6.1 多态性与单态性**

在这个简短的节中，我们评论系统 $\text{TT}_0^c \) 的另一个方面：按照 [Sal89b] 的术语，它是**单态的（monomorphic）**。

- 每个函数（例如 $\lambda x . x \)）的出现都是一个具有特定类型 $A \rightarrow A \) 的函数常量的符号简写，对于不同的类型 $A \)，这些函数是不同的。
- 在形式化我们的理论 $\text{TT}_0 \) 时，我们因此应该在表达式的所有子表达式上标记它们的类型，这样就不会出现类型歧义。
- 我们在继续时将系统地省略这些信息，但请注意，它应该始终被认为是存在的。

一个明显的问题，例如在 [Tro87] 中提出的，是如果抑制了类型信息，我们能否重新生成类型信息。换句话说，我们是否可以将多态系统（在不同的出现中给不同类型的函数，如 $\lambda x . x \)）视为单态系统的简写。

Salvesen 对这个问题给出了否定的答案，通过一些反例展示了多态理论和单态理论之间的差异。例如，在 [Sal89b] 中，展示了以下推导：

- 对于自然数：

$$
0 : \text{N}
$$


$$
\lambda y_{\text{N} \rightarrow \text{N}} . 0 : (\text{N} \rightarrow \text{N}) \rightarrow \text{N}\ (\Rightarrow I)
$$

$$
  [x : \text{N}]
$$

$$
  \lambda x_{\text{N}} . x : \text{N} \rightarrow \text{N}\ (\Rightarrow I)
$$

$$
  (\lambda y_{\text{N} \rightarrow \text{N}} . 0)\ (\lambda x_{\text{N}} . x) : \text{N}\ (\Rightarrow E)
$$

- 对于布尔值：

  $$
  0 : \text{N}
  $$

  $$
  \lambda y_{\text{B} \rightarrow \text{B}} . 0 : (\text{B} \rightarrow \text{B}) \rightarrow \text{N}\ (\Rightarrow I)
  $$

  $$
  [x : \text{B}]
  $$

  $$
  \lambda x_{\text{B}} . x : \text{B} \rightarrow \text{B}\ (\Rightarrow I)
  $$

  $$
  (\lambda y_{\text{B} \rightarrow \text{B}} . 0)\ (\lambda x_{\text{B}} . x) : \text{N}\ (\Rightarrow E)
  $$

- 这两者都导出了相同的结论：

  $$
  (\lambda y . 0)\ (\lambda x . x) : \text{N}
  $$

- 而在这个推导中，不可能为变量 $x \) 和 $y \) 导出一个单一的单态类型。

基于这个简单的例子，有一个多态理论中的推导，据称不能通过抑制类型信息从单态推导中产生。更复杂的例子展示了 Milner 风格的主类型系统（[Mil78]）是不可能的。

最后，我们应该注意，这里提到的多态性是**隐式多态性（implicit polymorphism）**；我们可以通过引入在宇宙 $U_n \) 上取值的（类型）变量，在单态系统中给出显式多态的定义。

### ---------------------------

# **第5章：探索类型理论**

---

## **5.7 等式与同一性**

在前面的讨论中，我们遇到了四种不同的**等式（equality）**或**同一性（identity）**概念。在本节中，我们将概述它们在系统中的不同作用，并在讨论这些概念的目的之后，提出一个**外延等式（extensional equality）**关系的定义。

### **5.7.1 定义等式**

我们的第一个关系是在**元语言**中，即我们用于讨论各种系统的语言。我们说两个项 $e \) 和 $f \) 是**相同的（identical）**，记为：

$$
e \equiv f
$$

如果它们在展开所有通过**定义等式（definitional equality）**“$\equiv_{\text{df}} \)”引入的定义项之后，除了**绑定变量的改变**之外是相同的。我们简单地将相同的表达式视为相同的——在任何上下文中，我们都不希望区分两个相同的表达式。

**旁注**：虽然这个关系显然是什么，但在计算机实现中，我们必须做一些工作来确保我们可以精确地判断何时两个表达式是相同的。

### **5.7.2 可转换性**

当系统的**计算规则（computation rules）**所体现的计算步骤足以将两个表达式联系起来时，它们是**可转换的（convertible）**。

形式上，我们通过对关系“$\rightarrow \)”取**自反**、**对称**、**传递**和**可替换**闭包，来构建关系“$\leftrightarrow\!\!\leftrightarrow \)”。换句话说，我们要求对于所有表达式 $a, b, c, \dots \) 和变量 $x \)：

- **计算**：如果 $a \rightarrow b \)，那么 $a \leftrightarrow\!\!\leftrightarrow b \)。
- **自反性**：$a \leftrightarrow\!\!\leftrightarrow a \)。
- **对称性**：如果 $a \leftrightarrow\!\!\leftrightarrow b \)，那么 $b \leftrightarrow\!\!\leftrightarrow a \)。
- **传递性**：如果 $a \leftrightarrow\!\!\leftrightarrow b \) 且 $b \leftrightarrow\!\!\leftrightarrow c \)，那么 $a \leftrightarrow\!\!\leftrightarrow c \)。
- **可替换性**：如果 $a \leftrightarrow\!\!\leftrightarrow b \) 且 $c \leftrightarrow\!\!\leftrightarrow d \)，那么 $a[c / x] \leftrightarrow\!\!\leftrightarrow b[d / x] \)。

在上一节中，我们看到，当且仅当两个项具有相同的**正常形式（normal form）**时，它们是可转换的。这意味着可转换关系是**可判定的（decidable）**。

可转换性的定义是在系统的外部——$a \leftrightarrow\!\!\leftrightarrow b \) 用于体现两个表达式 $a \) 和 $b \) 表示相同的对象。根据上述特征化，如果我们愿意，我们可以将这个对象视为表达式的正常形式。

在第4.11节中，我们介绍了允许在判断的推导中相互替换可互换表达式的**替换规则（substitution rules）**。这强调了这样一个事实：判断是关于表达式所表示的对象，而不是表达式本身。我们将在下面回到这个重要的区别。

由于“$a \leftrightarrow\!\!\leftrightarrow b \)”不是系统中的命题，我们无法基于它构建更复杂的断言。为此，我们转向第三个关系，即**同一性谓词（identity predicate）**。

### **5.7.3 同一性：$\text{I} \) 类型**

作为一个原始的命题（或类型）形成运算符，我们有 $\text{I} \) 运算，它形成一个类型：

$$
\frac{A\ \text{is a type} \quad a : A \quad b : A}{\text{I}(A, a, b)\ \text{is a type}}\ (\text{IF})
$$

该类型也写作 $a =_A b \)，或者当不会引起混淆时，简写为 $a = b \)。

当 $a \leftrightarrow\!\!\leftrightarrow b \) 时，$\text{I}(A, a, b) \) 是可证明的，其证明对象为 $r(a) \)，因此我们可以将该类型视为可转换性的内部化。在 $\text{I} \) 类型之上，我们可以构建更复杂的断言，例如：

$$
(\forall x, y : A). ((x =_A y) \Rightarrow (f\ x =_B g\ y))
$$

其中 $f \) 和 $g \) 是类型 $A \rightarrow B \) 的函数。

证明 $\text{I} \) 是“$\leftrightarrow\!\!\leftrightarrow \)”的内部化可由以下结果给出：

#### **定理5.22**

对于闭合的 $a \) 和 $b \)，判断 $\text{I}(A, a, b) \) 是可推导的，当且仅当 $a \leftrightarrow\!\!\leftrightarrow b \)。

**证明**：

- 显然，“如果”部分是有效的。
- 假设 $p : \text{I}(A, a, b) \) 是可推导的；根据定理5.14中的正常形式，我们有：
  
  $$
  p^0 : \text{I}(A^0, a^0, b^0)
  $$
  
- 为了使这个可推导，必须有 $a^0 \equiv b^0 \)，这意味着 $a \leftrightarrow\!\!\leftrightarrow b \)。**∎**

表达式 $x =_A y \) 表示系统的一个命题或类型。为了在计算中测试同一性，我们需要一个函数或运算，它返回一个布尔类型的值 $\text{True} \) 或 $\text{False} \)，而不是一个类型。

### **5.7.4 等式函数**

**等式函数（equality function）**是一个布尔值函数，可以在计算中用于测试两个对象的等同性。

#### **定义5.23**

对于类型 $A \)，一个等式函数（或等式运算）是一个项 $\text{equal}_A \)，其类型为 $\text{equal}_A : A \rightarrow A \rightarrow \text{bool} \)，满足以下命题：

1. 对于所有 $a, b : A \)，如果 $a =_A b \)，则：
   
   $$
   \text{equal}_A\ a\ b =_{\text{bool}} \text{True}
   $$
   
2. 对于所有 $a, b : A \)，如果 $a \ne_A b \)，则：
   
   $$
   \text{equal}_A\ a\ b =_{\text{bool}} \text{False}
   $$

注意，该定义的一个后果是，对于闭合的 $a, b \)，如果 $a \leftrightarrow\!\!\leftrightarrow b \)，那么：

$$
\text{equal}_A\ a\ b \leftrightarrow\!\!\leftrightarrow \text{True}
$$

但另一方面，无法推导出 $a \leftrightarrow\!\!\leftrightarrow b \) 并不意味着：

$$
\text{equal}_A\ a\ b \leftrightarrow\!\!\leftrightarrow \text{False}
$$

对于哪些类型我们有等式运算？我们从两个定义开始讨论。

#### **定义5.24**

一个谓词 $P(x_1, \dots, x_k) \) 是**形式可判定的（formally decidable）**，当且仅当以下命题是可推导的：

$$
(\forall x_1 : A_1) \dots (\forall x_k : A_k). (P(x_1, \dots, x_k) \lor \neg P(x_1, \dots, x_k)) \tag{5.1}
$$

#### **定义5.25**

一个谓词 $P(x_1, \dots, x_k) \) 是**可表示的（representable）**，当且仅当存在某个项 $r \)，使得以下命题是可推导的：

1. 对于所有 $x_1 : A_1, \dots, x_k : A_k \)，如果 $r\ x_1\ \dots\ x_k =_{\text{bool}} \text{True} \)，则 $P(x_1, \dots, x_k) \)：
   
   $$
   (\forall x_1 : A_1) \dots (\forall x_k : A_k). (r\ x_1\ \dots\ x_k =_{\text{bool}} \text{True} \Rightarrow P(x_1, \dots, x_k)) \tag{5.2}
   $$
   
2. 对于所有 $x_1 : A_1, \dots, x_k : A_k \)，如果 $r\ x_1\ \dots\ x_k =_{\text{bool}} \text{False} \)，则 $\neg P(x_1, \dots, x_k) \)：
   
   $$
   (\forall x_1 : A_1) \dots (\forall x_k : A_k). (r\ x_1\ \dots\ x_k =_{\text{bool}} \text{False} \Rightarrow \neg P(x_1, \dots, x_k)) \tag{5.3}
   $$

#### **定理5.26**

一个谓词是可表示的，当且仅当它是形式可判定的。

**证明**：

- **第一部分**：证明可表示的谓词是可判定的。
  
  - 首先，利用布尔消除的公理，我们可以推导出：
    
    $$
    (\forall b : \text{bool}). (b =_{\text{bool}} \text{True} \lor b =_{\text{bool}} \text{False})
    $$
    
    （这个证明在第4.10.1节中出现。）
  
  - 通过命题(5.2)和(5.3)，我们可以推导出公式(5.1)，正如所需要的。

- **第二部分**：证明可判定的谓词是可表示的。
  
  - 我们需要利用(5.1)给出的推导：
    
    $$
    d : (\forall x_1 : A_1) \dots (\forall x_k : A_k). (P(x_1, \dots, x_k) \lor \neg P(x_1, \dots, x_k))
    $$
  
  - 项 $d \) 是一个函数，我们将其与一个定义在析取上的函数组合，该函数对于第一个分支返回 $\text{True} \)，对于第二个分支返回 $\text{False} \)。这个函数由项：
    
    $$
    \lambda x . (\text{cases}\ x\ (\lambda x . \text{True})\ (\lambda x . \text{False}))
    $$
    
    给出。
  
  - 由此得到的函数将形成谓词的一个表示。**∎**

#### **推论5.27**

类型 $A \) 具有一个等式函数，当且仅当该类型上的等式是形式可判定的。

**证明**：

- 等式函数是类型上等式的一个表示。
- 定理因此立即应用于结果。**∎**

#### **定理5.28**

一个**基本类型（ground type）** $A \) 具有一个等式函数。

**证明**：

- 根据前面的推论，只需证明类型上的等式是形式可判定的。
- 我们可以通过对基本类型的构造进行归纳来证明它们的等式是可判定的。
- 实际上，我们已经在上一章的练习中给出了等式函数的直接定义。**∎**

对于其他类型的等式是否可判定？这似乎不太可能。

- 对于类型 $\text{N} \rightarrow \text{N} \) 的两个闭合项，如果它们有相同的正常形式，则可以证明它们相等，但在类型理论内部没有方法来比较正常形式。
- 我们将在下一节讨论的**外延等式（extensional equality）**有其他缺陷。
- 从一个函数类型上的外延可判定性谓词，我们能够证明如下结果：
  
  $$
  ((\forall x : \text{N}).\ f\ x =_{\text{N}} 0) \lor \neg ((\forall x : \text{N}).\ f\ x =_{\text{N}} 0)
  $$
  
  这通常对于构造主义者来说是不可接受的，因为它打破了性质是有限性的限制。

### **5.7.5 等式的刻画**

各种类型构造的消除规则允许我们根据它们的组成部分推导出类型的等式的刻画。

在第4.10.1节中，我们看到：

$$
(\forall b : \text{bool}). (b =_{\text{bool}} \text{True} \lor b =_{\text{bool}} \text{False})
$$

我们论证了其他类似的结果也可以被证明。特别地，我们作为练习给出了以下证明：

$$
(\forall x : \text{N}). (x =_{\text{N}} 0 \lor (\exists y : \text{N}). (x =_{\text{N}} \text{succ}\ y))
$$

我们还可以提到其他刻画：

- 对于合取（乘积）类型：

  $$
  (\forall x : A \wedge B). (\exists y : A). (\exists z : B). (x = (y, z))
  $$

- 对于析取（和）类型：

  $$
  (\forall x : A \lor B). ((\exists y : A). (x = \text{inl}\ y) \lor (\exists z : B). (x = \text{inr}\ z))
  $$

- 对于有限类型 $\text{N}_n \)：

  $$
  (\forall x : \text{N}_n). (x = 1_n \lor \dots \lor x = n_n)
  $$

  特殊情况：

  $$
  (\forall x : \top). x = \text{Triv}
  $$

这些结果都以类似的方式证明，使用针对所讨论类型的消除公理。

---

**练习**

**练习5.22**：通过明确地给出项 $r \)，完成定理5.26的证明。

**练习5.23**：给出树类型（tree type）上的等式函数的定义。

**练习5.24**：证明上述对合取（乘积）和析取（和）类型的等式的刻画。

---

**总结**：

- 我们讨论了类型理论中四种不同的等式或同一性概念：定义等式、可转换性、同一性（$\text{I} \) 类型）和等式函数。
- **定义等式**用于表示两个表达式在展开定义后，除了绑定变量的改变之外是相同的。
- **可转换性**通过计算规则连接两个表达式，具有可判定性。
- **同一性类型 $\text{I}(A, a, b) \)** 将可转换性内部化，允许在系统中构建更复杂的断言。
- **等式函数**用于在计算中测试两个对象的等同性，对于基本类型，我们可以定义这样的函数。
- 我们还讨论了等式的刻画，通过消除规则，根据类型的组成部分来定义类型的等式。

### ----------------------------

# **第5章：探索类型理论**

---

## **5.8 不同的等式**

在上一节中，我们看到了类型理论系统中存在着多种不同的**等式（equality）**或**同一性（identity）**概念。在本节中，我们将从更广阔的视角来探讨等式的确切目的，并基于这些思考结果，提出一些修改后的定义。

### **5.8.1 函数式编程的视角**

当我们在学校第一次学习算术时，我们会写下类似的计算：

$$
(2 + 3) + (4 + 5) = 5 + (4 + 5) = 5 + 9 = 14
$$

这可以被视为证明了特定的等式为真。类似地，当我们推理函数式程序的行为时，我们可能会写下这样的链式推导：

$$
\begin{align*}
\text{map}\ \text{id}\ (a : x) &= \text{id}\ a : \text{map}\ \text{id}\ x \\
&= a : \text{map}\ \text{id}\ x \\
&= a : x
\end{align*}
$$

其中：

- `map` 是一个函数，它将其第一个参数（一个函数）应用于其第二个参数（一个列表）的每个元素。
- `id` 是恒等函数。

对于函数式程序员（或小学生）来说，这样的证明的意义在于：两个表面上并不等价的表达式实际上具有相同的含义。

这些证明有一个共同点：在类型理论的上下文中，它们被认为是**平凡的（trivial）**。它们仅涉及证明两个表达式是**可转换的（convertible）**，这在理论之外的可转换关系中被形式化了。

为了将理论扩展到包含这种等式推理的程度，我们必须对理论进行**根本性的修改**。等式类型（$\text{I} \) 类型）的证明对象将不再具有平凡的形式 $r(a) \)，而需要反映如上所述的等式链。此外，命题：

$$
(2 + 3) + (4 + 5) = 14
$$

必须与命题：

$$
14 = 14
$$

区分开来，因为后者是平凡的，而前者反映了三个非平凡的计算步骤；这两个类型的证明对象将完全不同。

这里的转变是将**证明视为关于语言表达式**（例如 $(2 + 2) \)），而不是关于数学对象（例如数字4）。按照这里提出的思路，完全发展出一个类似于类型理论的理论将会很有趣。

### **5.8.2 外延等式**

正如我们上面所说，类型理论关注的是**对象及其关系**，因此我们将**可转换的表达式**视为相同，允许它们在任何上下文中相互替换。这是因为我们认为可转换的表达式具有相同的含义，这当然是正确的。此外，作为规范化定理的推论，我们看到可转换关系是**可判定的**，因此可以在系统本身之外决定等价性的问题。

然而，问题在于可转换性是否完全捕捉到了两个表达式具有相同含义的本质。对于基本类型的对象，这毫无疑问是如此，但对于函数，问题要复杂得多。

在第4.11.2节中，我们看到两种不同的方式将1加到一个任意的自然数上，在每个参数上都给出了相同的值，一个**外延等式（extensional equality）**会认为它们是相等的。我们能否扩充系统以使等式成为外延的？我们现在将回顾一些提议。

**首次尝试**可能是通过像**η-转换（eta conversion）**这样的规则来扩充可转换性规则，我们在第2.3节中首次看到了这个规则：

$$
\lambda x . (f\ x) \rightarrow f
$$

如果变量 $x \) 不在表达式 $f \) 中自由出现。根据第二章中允许在 $\lambda \) 下进行转换的可转换性的定义，我们可以说如果：

$$
f\ x \leftrightarrow\!\!\leftrightarrow g\ x \tag{5.4}
$$

那么通过两个 η-转换，我们有：

$$
f \leftrightarrow\!\!\leftrightarrow \lambda x . (f\ x) \leftrightarrow\!\!\leftrightarrow \lambda x . (g\ x) \leftrightarrow\!\!\leftrightarrow g
$$

因此，似乎我们有了一个外延的可转换性。

然而，情况并非如此，因为等式 (5.4) 是一个**弱等价（weak equivalence）**，它基于涉及任意值（由变量 $x \) 表示）的两个表达式之间的可转换性。在我们证明两个加一函数的等价性时，我们通过归纳推理得出：

$$
(\forall x : \text{N}).\ f\ x = g\ x
$$

这是基于对变量 $x \) 的情况分析的证明技术，而不仅仅是像 (5.4) 那样的重写。因此，我们似乎无法将完全的外延等式捕捉为一种转换关系。

**Martin-Löf** 在其1979年的系统 [ML85] 中提出了一个规则，其中包含了完全的外延转换，即：

$$
\frac{c : \text{I}(A, a, b)}{a \leftrightarrow\!\!\leftrightarrow b} \quad (\text{IE}_{\text{ext}})
$$

这个添加对系统的一般性质有不幸的后果：可转换性变得不可判定，系统不再是强规范化的，等等。正是因为这些原因，我们选择采用 Martin-Löf 早期的系统作为我们这里的基础。

这些是规则 (IEext) 的后果并不令人惊讶，因为它使转换关系具有了证明论的联系，而在早期系统中它并没有这种联系。在我们离开可转换性的话题之前，值得回顾我们在第2.11节中关于像 η-归约（η-reduction）这样的（所谓的）转换规则的多余性的评论。特别是关于这些规则不需要用于将基本类型的闭合项归约为正常形式的评论，在 $\text{TT}_0 \) 的上下文中仍然适用。

是否有替代 Martin-Löf 在系统中包含外延等式的方法？

**Turner** 在未发表的 [Tur89] 中提出，可以定义一个外延的 $\text{I} \) 类型。他论证说，类型：

$$
\text{I}(\text{N} \rightarrow \text{N}, f, g)
$$

可以被 $r \) 之外的项占据，证明函数所有值的相等性，换句话说，一个类型为：

$$
(\forall n : \text{N}).\ (f\ n = g\ n)
$$

的对象 $p \) 可以被注入到该类型中，得到：

$$
\text{ext}\ p : \text{I}(\text{N} \rightarrow \text{N}, f, g)
$$

如果我们向一个类型添加新的规范元素（canonical elements），我们需要新的消除和计算规则，以避免其他类型的规范对象类被虚假成员（spurious members）扩大。在 [Tur89] 中可以找到一些实现这一目标的规则，似乎可以在此基础上构建一个不引入虚假规范形式的系统。完整的呈现可能涉及一个**结构化等式对象（structured equality objects）**的理论，因此对对（pair）的等式证明将是等式证明的对，函数之间的等式将是证明所有结果相等的函数，等等。

这个方法的一个变体是引入等式的元素：

$$
\frac{p : (\forall x : A). (f\ x =_B g\ x)}{r : \text{I}(A \rightarrow B, f, g)} \quad (\text{II}^0)
$$

但这意味着对象 $p \) 中包含的证明论信息丢失了。这发生在标准的引入规则中，但在那种情况下，丢失的信息是可转换性信息，可以通过转换的判定过程恢复。如果我们要坚持完整呈现的原则，那么我们应该拒绝这种做法；如果不坚持，这提供了一种可行的方法。

### **5.8.3 在 $\text{TT}_0 \) 中定义外延等式**

我们在这里探索的选项是**在具有内涵等式（intensional equality）**的理论 $\text{TT}_0 \) 中显式地定义外延等式关系。我们保留“$\leftrightarrow\!\!\leftrightarrow \)”的可判定性，同时坚持完整呈现的原则。

#### **定义5.29**

通过对类型 $A \) 的构造进行归纳，我们可以定义体现 $A \) 上**外延等式**的运算符 $'\ )。形式上，我们有以下导出规则：

$$
\frac{A\ \text{is a type} \quad a : A \quad b : A}{(a\ '\_A\ b)\ \text{is a type}} \quad (\text{EEF})
$$

对于基本类型（如 $\text{N} \)、$\text{N}_n \)、$\text{bool} \)、$\text{I}(T, n, m) \) 等），我们定义：

$$
a\ '\_A\ b \equiv_{\text{df}} \text{I}(A, a, b)
$$

从现在开始，我们省略类型下标，对于函数类型，我们定义：

$$
f\ '\ g \equiv_{\text{df}} (\forall x, y : A). ((x\ '\ y) \Rightarrow (f\ x\ '\ g\ y))
$$

对于乘积类型，我们定义：

$$
u\ '\ v \equiv_{\text{df}} (\text{fst}\ u\ '\ \text{fst}\ v) \wedge (\text{snd}\ u\ '\ \text{snd}\ v)
$$

对于和类型（析取）类似定义。

对于类型为 $(\forall x : A). B \) 的 $f \) 和 $g \)，命题：

$$
(\forall x, y : A). ((x\ '\ y) \Rightarrow (f\ x\ '\ g\ y))
$$

只有在类型族 $B \) 本身是外延的情况下才是良构的，即如果 $x\ '\ x' \)，那么 $B \leftrightarrow\!\!\leftrightarrow B[x' / x] \)。

关系“$'\ )”是一个**部分等价关系（partial equivalence relation）**，也就是说：

#### **引理5.30**

关系“$'\_A \)”具有以下性质：

- **对称性**：如果 $f\ '\ g \) 是可推导的，那么 $g\ '\ f \) 也是可推导的。
- **传递性**：如果 $f\ '\ g \) 和 $g\ '\ h \) 是可推导的，那么 $f\ '\ h \) 也是可推导的。
- **半自反性（Semi-Reflexivity）**：如果 $f\ '\ g \) 是可推导的，那么 $f\ '\ f \) 也是可推导的。

**证明**：

- 证明通过对类型 $A \) 的构造进行归纳。

- **有趣的情况**是函数类型 $B \rightarrow C \)。

- 首先，假设我们有 $f\ '\ g \)，即：

  $$
  (\forall x, y : B). ((x\ '\ y) \Rightarrow (f\ x\ '\ g\ y))
  $$

- 由于 $C \) 上的“$'\ )”具有对称性，我们有：

  $$
  (\forall x, y : B). ((x\ '\ y) \Rightarrow (g\ y\ '\ f\ x))
  $$

  这是所需的。

- 现在，假设我们有 $f\ '\ g \) 和 $g\ '\ h \)，并假设 $x\ '\_B\ y \)。

- 通过第一个命题，我们有：

  $$
  f\ x\ '\ g\ y
  $$

- 由于 $x\ '\ y \)，我们通过 $B \) 的对称性和半自反性，得到 $y\ '\ y \)。

- 通过 $g\ '\ h \)，我们可以推导：

  $$
  g\ y\ '\ h\ y
  $$

- 最后，通过 $C \) 上的“$'\ )”的传递性，我们有：

  $$
  f\ x\ '\ h\ y
  $$

  这建立了传递性。

- **半自反性**是对称性和传递性的结果。**∎**

#### **定义5.31**

如果 $a \) 是具有自由变量 $x_1, \dots, x_k \) 的开放项，那么它的**闭包（closure）**是项：

$$
\lambda x_1, \dots, x_k . a
$$

#### **定义5.32**

我们称一个类型为 $A \) 的闭合项 $a \) 是**外延的（extensional）**，如果 $a\ '\_A\ a \)。如果 $a \) 是开放的，我们称它是外延的，如果它的闭包是外延的。

**并非所有的项都是外延的**。考虑函数：

$$
h \equiv_{\text{df}} \lambda x . (x, r(x)) : A \rightarrow (\exists x : A). \text{I}(A, x, x)
$$

假设我们取类型 $A \) 为 $\text{N} \rightarrow \text{N} \)，并选择两个函数 $f \) 和 $g \) 属于该类型，使得 $f\ '\ g \)，但 $f \not\leftrightarrow\!\!\leftrightarrow g \)。在第4.11.2节中的两个加法函数可以作为 $f \) 和 $g \)。

现在，

$$
h\ f \rightarrow\!\!\rightarrow (f, r(f))
$$

$$
h\ g \rightarrow\!\!\rightarrow (g, r(g))
$$

这两个值不是外延相等的，因为对象 $r(f) \) 和 $r(g) \) 属于不同的类型，因为类型族 $\text{I}(A, x, x) \) 不是外延的。

我们可以在此结束讨论，定义两个项何时是外延相等的。不幸的是，到目前为止，我们发展的内容并不太有用——我们无法直接使用定义的关系，而必须展开其定义来使用它。

等式关系 $\text{I}(A, a, b) \) 的特征在于其消除规则，表明 $a \) 和 $b \) 可以在任何上下文中相互替换。“$'\ )”是一个比同一性弱的关系，因此我们不能期望在所有上下文中相互替换外延相等的项。相反，我们证明在大量的上下文中，可以安全地执行替换。

#### **定义5.33**

我们称一个命题 $P \) 是**外延的**，如果它满足以下条件：

- $P \) 中形如 $\text{I}(A, a, b) \) 的任何子项必须满足：
  - $A \) 是一个**基本类型**，并且
  - 项 $a \) 和 $b \) 是外延的。

#### **定理5.34**

如果 $P \) 是外延的，且 $f\ '\ g \)，并且我们可以推导 $p : P[f / x] \)，那么我们可以找到 $p' \)，使得 $p' : P[g / x] \) 是可推导的。

**证明**：

- 我们通过对推导 $p \) 进行归纳来证明这个结果。**∎**

我们还可以猜想，任何外延类型的闭合项本身也是外延的。这将特别包括所有类型不涉及等式类型 $\text{I}(A, a, b) \) 的项，这将包括像 Miranda 这样的传统函数式编程语言的所有类型。

我们可以证明以下更有限的定理。

#### **定理5.35**

外延项的类在以下操作下是封闭的：配对、投影、注入（到和类型）、case分析、自然数和树上的原始递归、抽象、应用、函数组合等。

**证明**：

- 证明只需在每种情况下检查定义即可。**∎**

**总结**：

在一个具有良好元数学性质的内涵类型理论系统中，我们可以构建一个**外延的**等式关系。此外，我们可以证明，在广泛的上下文中，我们可以相互替换外延相等的项。这种方法似乎结合了外延和内涵理论的优势，而没有牺牲任何东西。

---

**练习**

**练习5.25**：完成上述定理5.34和5.35的证明。

---

**总结本节内容**：

- 我们讨论了类型理论中不同的等式概念，特别是关于外延等式的问题。
- 从函数式编程的视角，我们希望能够证明两个函数在所有输入上行为相同，即它们是**外延相等的**。
- 在类型理论中，标准的可转换性关系不够表达外延等式，因为它只涉及表达式的可归约性。
- 我们探索了将外延等式引入类型理论的方法，包括使用 η-转换和 Martin-Löf 的方法，但这些方法都有其局限性。
- 最后，我们在 $\text{TT}_0 \) 系统中定义了一个外延等式关系 $'\ )，并讨论了其性质和应用。

### ---------------------------

# 第5章：探索类型理论

---

## **5.8 不同的等式**

在上一节中，我们观察到，对于类型理论这样的系统，存在多种不同的**等式（equality）**或**同一性（identity）**概念。在本节中，我们从更广阔的视角来看待等式的目的，并基于这些思考提出修改后的定义。

### **5.8.1 函数式编程的视角**

当我们在学校首次学习算术时，我们会写下类似的计算：

1. **算术计算示例**：

   $$
   \begin{align*}
   (2 + 3) + (4 + 5) &= 5 + (4 + 5) \\
   &= 5 + 9 \\
   &= 14
   \end{align*}
   $$

   - **解释**：
     - 首先，将 $2 + 3 \) 计算为 $5 \)，因此原表达式变为 $5 + (4 + 5) \)。
     - 接着，计算 $4 + 5 \) 为 $9 \)，表达式变为 $5 + 9 \)。
     - 最后，计算 $5 + 9 \) 得到 $14 \)。

   - 这个过程可以被视为一个**证明**，证明了特定的等式 $(2 + 3) + (4 + 5) = 14 \) 是正确的。

类似地，当我们推理函数式程序的行为时，我们可能会写下这样的链式推导：

2. **函数式编程示例**：

   $$
   \begin{align*}
   \text{map}\ \text{id}\ (a : x) &= \text{id}\ a : \text{map}\ \text{id}\ x \\
   &= a : \text{map}\ \text{id}\ x \\
   &= a : x
   \end{align*}
   $$

   - **解释**：
     - **map** 是一个函数，它将其第一个参数（一个函数）应用于其第二个参数（一个列表）的每个元素。
     - **id** 是恒等函数，返回其输入本身。
     - $a : x \) 表示一个列表，其中 $a \) 是头元素，$x \) 是尾列表。
     - 第一行，将 $\text{map}\ \text{id}\ (a : x) \) 展开，根据 map 的定义，得到 $\text{id}\ a : \text{map}\ \text{id}\ x \)。
     - 第二行，计算 $\text{id}\ a \) 得到 $a \)，因此表达式变为 $a : \text{map}\ \text{id}\ x \)。
     - 第三行，递归地应用相同的过程，最终得到 $a : x \)。

对于**函数式程序员**（或小学生）来说，这样的证明的意义在于：

- 两个表面上并不等价的表达式实际上具有相同的含义。

**观察**：

- 这些证明在类型理论的上下文中被认为是**平凡的（trivial）**。
- 它们仅涉及展示两个表达式是**可转换的（convertible）**。
- 这种可转换性的概念在理论之外的**可转换关系（convertibility relation）**中被形式化。

**含义**：

- 为了将理论扩展到包含这种等式推理，我们必须对理论进行**根本性的修改**。
- 等式类型（$\text{I} \) 类型）的**证明对象**将不再具有平凡的形式 $r(a) \)，而需要反映如上所述的等式链。
- 此外，命题：

  $$
  (2 + 3) + (4 + 5) = 14
  $$

  必须与命题：

  $$
  14 = 14
  $$

  区分开来：

  - 后者 $14 = 14 \) 是**平凡的**。
  - 前者反映了**三个非平凡的计算步骤**。
  - 两个类型的**证明对象**将完全不同。

**关键点**：

- 这里的转变是将**证明视为关于语言表达式**（如 $(2 + 2) \)），而不是关于**数学对象**（如数字 $4 \)）。

**结论**：

- 沿着这里提出的思路，完整地发展出一个类似于类型理论的理论将会很有趣。

### **5.8.2 外延等式**

正如我们上面所说，**类型理论关注的是对象及其关系**，因此：

- 我们将**可转换的表达式**视为相同，允许它们在任何上下文中**相互替换**。
- 这是因为我们认为**可转换的表达式具有相同的含义**，这当然是正确的。

此外：

- 作为**规范化定理**的推论，我们看到**可转换性**的关系是**可判定的**。
  - 这意味着，我们可以决定两个表达式是否可转换。
- 因此，可以独立于系统本身来决定等价性的问题。

**问题**：

- **可转换性**是否完全捕捉到了两个表达式**具有相同含义**的本质？
- 对于**基本类型**的对象，这毫无疑问是如此。
- 但对于**函数**，问题要复杂得多。

**示例**：

- 在第4.11.2节中，我们看到：

  - **两种不同方式**将 $1 \) 加到一个任意自然数上，在每个参数上都给出了相同的值。
  - 一个**外延等式（extensional equality）**会认为它们是相等的。

**问题**：

- 我们能否**扩充系统**以使等式成为**外延的**？
- 我们现在将回顾一些提议。

#### **首次尝试：扩充可转换性规则**

我们可能尝试使用类似于**η-转换（eta conversion）**的规则来扩充可转换性规则，我们在第2.3节中首次看到了这个规则：

- **η-转换规则**：

  $$
  \lambda x . (f\ x) \rightarrow f
  $$

  - **条件**：变量 $x \) **不在**表达式 $f \) 中自由出现。

根据第二章中可转换性的定义，允许在 $\lambda \) 下进行转换，我们可以说，如果：

- **假设**：

  $$
  f\ x \leftrightarrow\!\!\leftrightarrow g\ x \tag{5.4}
  $$

- 那么，通过两个 η-转换，我们有：

  $$
  f \leftrightarrow\!\!\leftrightarrow \lambda x . (f\ x) \leftrightarrow\!\!\leftrightarrow \lambda x . (g\ x) \leftrightarrow\!\!\leftrightarrow g
  $$

- **解释**：
  - 从 $f \) 出发，我们通过 η-展开得到 $\lambda x . (f\ x) \)。
  - 由于 $f\ x \leftrightarrow\!\!\leftrightarrow g\ x \)，我们可以将 $f\ x \) 替换为 $g\ x \)。
  - 然后，我们通过 η-归约将 $\lambda x . (g\ x) \) 还原为 $g \)。
- **结论**：似乎我们有了一个**外延的可转换性**。

**问题**：

- 然而，事实并非如此。
- 等式 (5.4) 是一个**弱等价（weak equivalence）**，因为它基于涉及**任意值**（由变量 $x \) 表示）的两个表达式之间的可转换性。

在我们证明两个加一函数的等价性时，我们推导出：

- **陈述**：

  $$
  (\forall x : \text{N}).\ f\ x = g\ x
  $$

- **方法**：通过**归纳**，一种基于对变量 $x \) 进行**情况分析**的**证明论技术**。
- **对比**：这并不是简单地像 (5.4) 那样的重写。
- **结论**：因此，我们似乎无法将完全的**外延等式**捕捉为一种转换关系。

#### **Martin-Löf 的提议**

**Martin-Löf** 在其1979年的系统 [ML85] 中提出了一个规则，其中包含了完全的**外延转换**，即：

- **规则 (IEext)**：

  $$
  \frac{c : \text{I}(A, a, b)}{a \leftrightarrow\!\!\leftrightarrow b} \quad (\text{IE}_{\text{ext}})
  $$

- **解释**：
  - 如果我们有 $\text{I}(A, a, b) \) 的证明 $c \)，那么我们可以得出 $a \leftrightarrow\!\!\leftrightarrow b \)。

**后果**：

- 这个添加对系统的一般性质有**不利的后果**：
  - **可转换性变得不可判定**。
  - 系统**不再是强规范化的**。
  - 等等。
- 正是因为这些原因，我们选择采用 Martin-Löf **早期的系统**作为我们的基础。

**解释**：

- 这些是规则 (IEext) 的后果并不令人惊讶，因为它使**转换关系具有了证明论的联系**，而在早期系统中它并没有这种联系。

**评论**：

- 在我们离开可转换性的话题之前，值得回顾我们在第2.11节中关于像 η-归约（η-reduction）这样的（所谓的）**转换规则的多余性**的评论。
- 特别是关于这些规则**不需要**用于将基本类型的闭合项归约为正常形式的评论，在 **$\text{TT}_0 \)** 的上下文中仍然适用。

**问题**：

- 是否有替代 Martin-Löf 在系统中包含外延等式的方法？

#### **Turner 的提议**

**Turner** 在未发表的 [Tur89] 中提出，可以定义一个**外延的 $\text{I} \) 类型**。

**思路**：

- 他论证说，类型：

  $$
  \text{I}(\text{N} \rightarrow \text{N}, f, g)
  $$

  可以被 $r \) **之外的项**占据，即证明**函数所有值相等**的证明。

- 换句话说，一个类型为：

  $$
  (\forall n : \text{N}).\ (f\ n = g\ n)
  $$

  的对象 $p \) 可以被注入到该类型中，得到：

  $$
  \text{ext}\ p : \text{I}(\text{N} \rightarrow \text{N}, f, g)
  $$

**考虑**：

- 如果我们向一个类型添加**新的规范元素（canonical elements）**，我们需要**新的消除和计算规则**，以确保其他类型的规范对象类**不被虚假成员（spurious members）扩大**。
- 在 [Tur89] 中可以找到一些实现这一目标的规则。
- 似乎可以在此基础上构建一个不引入虚假规范形式的系统。
- 完整的呈现可能涉及一个**结构化等式对象（structured equality objects）**的理论，因此：
  - 对对（pair）的等式证明将是**等式证明的对**。
  - 函数之间的等式将是**证明所有结果相等的函数**。
  - 等等。

#### **一个变体方法**

这个方法的一个变体是引入等式的元素：

- **规则 (II0)**：

  $$
  \frac{p : (\forall x : A). (f\ x =_B g\ x)}{r : \text{I}(A \rightarrow B, f, g)} \quad (\text{II}^0)
  $$

- **解释**：

  - 给定 $(\forall x : A). (f\ x =_B g\ x) \) 的证明 $p \)，我们可以导出 $\text{I}(A \rightarrow B, f, g) \) 的证明 $r \)。

**问题**：

- 这意味着对象 $p \) 中包含的**证明论信息**丢失了。
- 这发生在标准的引入规则中，但在那种情况下，丢失的信息是**可转换性信息**，可以通过**转换的判定过程**恢复。

**原则**：

- 如果我们要坚持**完整呈现的原则**，那么我们应该拒绝这种做法。
- 如果不坚持，这提供了一种可行的方法。

### **5.8.3 在 $\text{TT}_0 \) 中定义外延等式**

我们在这里探索的选项是**在具有内涵等式（intensional equality）**的理论 $\text{TT}_0 \) 中**显式地**定义**外延等式关系**。

- 我们保留“$\leftrightarrow\!\!\leftrightarrow \)”的**可判定性**，并坚持**完整呈现**的原则。

#### **定义5.29**

通过对类型 $A \) 的构造进行归纳，我们可以定义体现 $A \) 上**外延等式**的运算符 $\approx_A \)。

**形式上**，我们有以下导出规则：

- **外延等式形成（EEF）**：

  $$
  \frac{A\ \text{是一个类型} \quad a : A \quad b : A}{(a\ \approx_A\ b)\ \text{是一个类型}} \quad (\text{EEF})
  $$

- **解释**：对于任何类型 $A \) 和项 $a, b : A \)，我们可以形成类型 $a\ \approx_A\ b \)，它表示 $a \) 和 $b \) 是外延相等的。

对于**基本类型** $\text{N} \)、$\text{N}_n \)、$\text{bool} \)、$\text{I}(T, n, m) \) 等，我们定义：

- **定义**：

  $$
  a\ \approx_A\ b \equiv_{\text{df}} \text{I}(A, a, b)
  $$

- **解释**：对于基本类型，外延等式与内涵等式一致。

**对于函数类型**，我们定义：

- **定义**：

  $$
  f\ \approx\ g \equiv_{\text{df}} (\forall x, y : A). ((x\ \approx\ y) \Rightarrow (f\ x\ \approx\ g\ y))
  $$

- **解释**：两个函数 $f, g : A \rightarrow B \) 是外延相等的，当且仅当对于所有 $x, y : A \)，如果 $x \approx y \)，则 $f\ x \approx g\ y \)。

**对于乘积类型**，我们定义：

- **定义**：

  $$
  u\ \approx\ v \equiv_{\text{df}} (\text{fst}\ u\ \approx\ \text{fst}\ v) \wedge (\text{snd}\ u\ \approx\ \text{snd}\ v)
  $$

- **解释**：两个对 $u, v \) 是外延相等的，当且仅当它们的第一分量外延相等，且第二分量外延相等。

类似地，对于**和类型（析取）**，我们可以适当地定义外延等式。

**注意**：

- 对于类型为：

  $$
  (\forall x : A). B
  $$

  的 $f \) 和 $g \)，命题：

  $$
  (\forall x, y : A). ((x\ \approx\ y) \Rightarrow (f\ x\ \approx\ g\ y))
  $$

  只有当类型族 $B \) 本身是**外延的**时才是**良构的**，即如果 $x \approx x' \)，那么 $B \leftrightarrow\!\!\leftrightarrow B[x' / x] \)。

#### **关系 $\approx \) 的性质**

关系“$\approx_A \)”是一个**部分等价关系（partial equivalence relation）**，这意味着：

##### **引理5.30**

关系“$\approx_A \)”具有以下性质：

1. **对称性**：

   - 如果 $f \approx g \) 是可推导的，那么 $g \approx f \) 也是可推导的。

2. **传递性**：

   - 如果 $f \approx g \) 和 $g \approx h \) 是可推导的，那么 $f \approx h \) 也是可推导的。

3. **半自反性（Semi-Reflexivity）**：

   - 如果 $f \approx g \) 是可推导的，那么 $f \approx f \) 也是可推导的。

**证明**：

- 证明通过对类型 $A \) 的构造进行**归纳**。
- **有趣的情况**是函数类型 $B \rightarrow C \)。
- 我们依次考虑各个性质。

**对称性**：

- 假设我们有 $f \approx g \)，即：

  $$
  (\forall x, y : B). ((x \approx y) \Rightarrow (f\ x \approx g\ y))
  $$

- 由于类型 $C \) 上的“$\approx \)”具有对称性，我们有：

  $$
  (\forall x, y : B). ((x \approx y) \Rightarrow (g\ y \approx f\ x))
  $$

- 这建立了对称性。

**传递性**：

- 假设我们有 $f \approx g \) 和 $g \approx h \)，并且假设 $x \approx_B y \)。
- 通过 $f \approx g \)，我们有：

  $$
  f\ x \approx g\ y
  $$

- 由于 $x \approx y \)，并且通过 $B \) 的对称性和半自反性，我们有 $y \approx y \)。
- 通过 $g \approx h \)，我们得到：

  $$
  g\ y \approx h\ y
  $$

- 通过 $C \) 上的“$\approx \)”的传递性，我们有：

  $$
  f\ x \approx h\ y
  $$

- 这建立了传递性。

**半自反性**：

- 这是对称性和传递性的结果。
- 如果 $f \approx g \)，那么通过对称性 $g \approx f \)，再通过传递性 $f \approx f \)。

**结论**：

- 证明完成。 ∎

#### **定义5.31**

- 如果 $a \) 是具有自由变量 $x_1, \dots, x_k \) 的**开放项**，那么它的**闭包**是项：

  $$
  \lambda x_1, \dots, x_k . a
  $$

#### **定义5.32**

- 我们称一个类型为 $A \) 的**闭合项** $a \) 是**外延的**，如果 $a \approx_A a \)。
- 如果 $a \) 是**开放的**，我们称它是外延的，如果它的**闭包**是外延的。

**观察**：

- **并非所有的项都是外延的**。

**示例**：

- 考虑函数：

  $$
  h \equiv_{\text{df}} \lambda x . (x, r(x)) : A \rightarrow (\exists x : A). \text{I}(A, x, x)
  $$

- 假设我们取类型 $A \) 为 $\text{N} \rightarrow \text{N} \)。
- 选择两个函数 $f \) 和 $g \) 属于该类型，使得 $f \approx g \)，但 $f \not\leftrightarrow\!\!\leftrightarrow g \)。
  - 第4.11.2节中的两个加法函数可以作为 $f \) 和 $g \)。
- 现在，我们有：

  $$
  h\ f \rightarrow\!\!\rightarrow (f, r(f))
  $$

  $$
  h\ g \rightarrow\!\!\rightarrow (g, r(g))
  $$

- 这两个值**不是外延相等的**，因为对象 $r(f) \) 和 $r(g) \) 属于**不同的类型**。
  - 这是因为类型族 $\text{I}(A, x, x) \) **不是外延的**。

**含义**：

- 我们可以在此结束讨论，定义两个项何时是**外延相等的**。
- 不幸的是，到目前为止，我们发展的内容**并不太有用**。
- 我们**无法直接使用定义的关系**，而必须**展开其定义**来使用它。
- 等式关系 $\text{I}(A, a, b) \) 的特征在于其**消除规则**，表明 $a \) 和 $b \) 可以在任何上下文中**相互替换**。
- 关系“$\approx \)”是一个**比同一性弱**的关系。
- 因此，我们**不能期望在所有上下文中相互替换外延相等的项**。

**替代方法**：

- 相反，我们证明在**大量的上下文**中，可以**安全地**执行**替换**。

#### **定义5.33**

我们称一个**命题** $P \) 是**外延的**，如果它满足以下条件：

- $P \) 中形如 $\text{I}(A, a, b) \) 的任何**子项**必须满足：
  - **$A \) 是一个基本类型**，并且
  - 项 $a \) 和 $b \) 是**外延的**。

#### **定理5.34**

如果 $P \) 是外延的，且 $f \approx g \)，并且我们可以推导 $p : P[f / x] \)，那么我们可以找到 $p' \)，使得 $p' : P[g / x] \) 是可推导的。

**证明**：

- 我们通过对推导 $p \) 进行**归纳**来证明这个结果。
- **思路**：
  - 我们逐步检查推导 $p \)。
  - 在每一步中，我们将 $f \) 替换为 $g \)，考虑到 $f \approx g \) 且 $P \) 是外延的。
  - 由于 $P \) 仅涉及基本类型和外延项上的等式，替换是有效的。
- **结论**：所需的 $p' \) 存在。 ∎

#### **猜想**

- 我们还可以猜想，**任何外延类型的闭合项本身也是外延的**。
- 这将特别包括所有**不涉及等式类型** $\text{I}(A, a, b) \) 的类型的项。
  - 这将包括像 **Miranda** 这样的传统函数式编程语言的所有类型。

我们可以证明以下更有限的定理。

#### **定理5.35**

**外延项**的类在以下操作下是**封闭的**：

- 配对（pairing），
- 投影（projection），
- 注入（到和类型），
- case 分析，
- 对自然数和树的原始递归，
- 抽象，
- 应用，
- 函数组合，
- 等等。

**证明**：

- 证明只需在每种情况下**检查定义**。
- **例如**：
  - **配对**：如果 $a \) 和 $b \) 是外延的，那么 $(a, b) \) 是外延的。
  - **投影**：如果 $(a, b) \) 是外延的，那么 $a \) 和 $b \) 是外延的。
  - **抽象**：如果 $f \) 是外延的，那么 $\lambda x . f(x) \) 是外延的。
- **结论**：外延项的类在这些操作下是封闭的。 ∎

### **本节总结**

在本节中，我们已经展示了在一个**内涵系统**的类型理论中（具有良好的元数学性质）：

- 我们可以构建一个**外延的**等式关系。

此外：

- 我们可以证明，在广泛的上下文中，我们可以**相互替换外延相等的项**。
- 这种方法似乎**结合了**外延和内涵理论的**优势**，而没有牺牲任何东西。

### **练习**

**5.25.** 完成上述定理5.34和5.35的证明。

---

# 参考资料

- [ML85] Martin-Löf, P. (1985). *Intuitionistic Type Theory*. Bibliopolis.
- [Tur89] Turner, D. (1989). *Unpublished Manuscript*.

---

希望以上详解对您理解内容有所帮助！

### ----------------------------

# 第5章：探索类型理论

---

## **5.9 宇宙（Universes）**

在类型理论系统 **$\text{TT}_0 \)** 中，类型（如自然数类型 **$\text{N} \)**、合取类型 **$A \wedge B \)**、等式类型 **$\text{I}(A, a, b) \)** 等）与其上的对象（如 **$0 \)**、**$(a, b) \)**、**$r(a) \)** 等）之间有着严格的区分。然而，在某些情况下，我们希望能够模糊这种区分，这样做有以下几个好处：

1. **类型多态性（Type Polymorphism）**：我们可能希望定义一个对象，它依赖于一个类型参数。这在编程中经常被称为**类型多态**。

2. **抽象类型定义（Abstract Type Definitions）**：我们可能希望断言存在具有某些性质的类型。这涉及到抽象类型的定义，其中类型的具体实现对用户是不可见的。

3. **定义泛型函数**：有些函数最好在所有类型的对象集合上定义，而不是局限于特定的类型。

为了解决这些需求，我们可以考虑引入一个包含所有类型的类型 **$T \)**。事实上，Martin-Löf 在他早期的类型理论版本 [ML71] 中确实引入了这样的类型。然而，Girard 在 [Gir72] 中证明了这种添加会导致类型理论的逻辑不一致，即**每个命题都可以被证明**。Girard 的证明基于集合论中的 Burali-Forti 悖论，它证明了所有良基集的集合是不一致的，因为它是自身的成员，因此不是良基的。

这种悖论（如 Russell 悖论）的共同点在于所定义的对象是**不完全的（impredicative）**：在描述 **$T \)** 的成员时，我们必须提及 **$T \)** 本身。这是类型理论的逻辑解释和编程解释**分歧**的一个点。系统的逻辑不一致在编程术语中意味着每个类型都有一个成员。这种成员是我们在像 Miranda 这样的语言中习以为常的，因为每个类型都包含一个未定义的元素，在语义上被识别为域的底元素。

此外，在 **$T \)** 的定义中出现的自我引用实际上是**一般递归**的问题，不一致性变成了部分性（partiality）。关于悖论的计算行为的详细分析，可以参见 [MR86] 和 Howe 在 [How88] 第4章中对相关系统 Nuprl 中悖论的分析。

**为了保持系统的逻辑一致性**，我们必须避免引入这样的 **$T \)**。相反，我们引入了一个**宇宙层级（hierarchy of universes）**，即 **$U_n \)**，其中 **$n = 0, 1, 2, \dots \)**。通过 **$\text{TT}_0 \)** 的类型形成规则形成的类型位于 **$U_0 \)** 中；这也是 **$\text{TT}_0 \)** 中的下标 0 的来源。然后，我们将 **$U_0 \)** 作为一个类型加入，使用相同的类型形成规则，我们可以在 **$U_1 \)** 中形成新的类型，以此类推，遍历整个层级。

### **正式定义**

我们通过修改类型形成规则来获得系统 **$\text{TT} \)**。将所有形式为 **$A\ \text{is a type} \)** 的判断替换为 **$A : U_n \)**，并将类型形成规则从：

- **旧规则**：

  $$
  \frac{A_1\ \text{is a type} \quad \dots \quad A_k\ \text{is a type}}{T(A_1, \dots, A_k)\ \text{is a type}} \quad (\text{TF})
  $$

- **新规则**：

  $$
  \frac{A_1 : U_{n_1} \quad \dots \quad A_k : U_{n_k}}{T(A_1, \dots, A_k) : U_{\max(n_1, \dots, n_k)}} \quad (\text{TF})
  $$

其中 **$\max(n_1, \dots, n_k) \)** 表示 **$n_1, \dots, n_k \)** 中的最大值。

在其他规则中，所有形式为 **$A\ \text{is a type} \)** 的前提都替换为 **$A : U_n \)**。

我们还添加以下**宇宙的形成规则**：

- **宇宙的形成规则（UF）**：

  $$
  U_n : U_{n+1}
  $$

这表示每个宇宙 **$U_n \)** 本身是下一个更高宇宙 **$U_{n+1} \)** 的成员。

**注意**：宇宙系统**不是累积的（not cumulative）**；每个类型**恰好**是某个宇宙 **$U_k \)** 的成员，而不是所有更高宇宙的成员。

### **结论**

我们以一个评论来结束这个介绍：第5.6节的结果可以直接扩展到 **$\text{TT} \)**，无需修改。因此，我们有：

#### **定理5.36**

**$\text{TT} \)** 是**强规范化（strongly normalising）**的，具有 **Church-Rosser** 性质，并且**可转换性**和形式为 **$a : A \)** 的判断的可推导性都是**可判定的（decidable）**。

**证明**：证明与第5.6节完全相同。 ∎

---

## **5.9.1 类型族（Type Families）**

由于宇宙与其他类型一样是类型，我们可以在这些类型上形成新的对象。例如，我们有：

- **类型成员**：

  - **$\bot : U_0 \)**（表示**空类型**或**假命题**）
  - **$\top : U_0 \)**（表示**单位类型**或**真命题**）

- **条件表达式**：

  - 给定 **$x : \text{bool} \)**，我们可以构造：

    $$
    \text{if}\ x\ \text{then}\ \bot\ \text{else}\ \top : U_0
    $$

    这利用了布尔类型的消除规则 **(bool E)**。

- **定义类型族**：

  - 定义 **$B \equiv (\text{if}\ x\ \text{then}\ \bot\ \text{else}\ \top) \)**。

  - 这是一个关于变量 **$x : \text{bool} \)** 的**类型族**，具有以下性质：

    $$
    B(\text{True}) \rightarrow \bot \quad \text{and} \quad B(\text{False}) \rightarrow \top
    $$

    这比第4.10.3节中描述的类型族定义更加直接。

### **定理的应用**

现在，我们使用宇宙 **$U_0 \)** 来证明一个我们在 **$\text{TT}_0 \)** 中无法证明的定理。

#### **定理5.37**

在 **$\text{TT} \)** 中，我们可以推导出 **$\neg(\text{True} =_{\text{bool}} \text{False}) \)**，即 **True** 和 **False** 不相等。

**证明**：

- **假设**存在一个证明 **$p : \text{True} =_{\text{bool}} \text{False} \)**。

- **构造函数**：

  $$
  \lambda x . (\text{if}\ x\ \text{then}\ \bot\ \text{else}\ \top)
  $$

- **应用函数**于等式的两边，得到：

  $$
  p' : \bot =_{U_0} \top
  $$

  - 这意味着 **$\bot \)** 和 **$\top \)** 相等，但它们是不同的类型。

- **利用替换**：

  - 将 **$\bot \)** 替换为 **$\top \)**，并考虑 **$\text{Triv} : \top \)**（其中 **$\text{Triv} \)** 是 **$\top \)** 的唯一元素）。

  - 由于 **$\top \)** 被替换为 **$\bot \)**，我们得到：

    $$
    \text{Triv} : \bot
    $$

  - 这意味着我们从假命题中得到了一个元素，这是矛盾的。

- **结论**：

  - 通过**排除法**，我们得出 **$\neg(\text{True} =_{\text{bool}} \text{False}) \)**。

  ∎

**注**：Smith 在他的论文 [Smi87] 中给出了一个正式的证明，表明在 **$\text{TT}_0 \)** 的一个扩展中无法推导出这个结果。

---

## **5.9.2 对宇宙的量化（Quantifying over Universes）**

许多函数可以针对任意类型进行推导，例如第4.5节中的所有函数。我们可以重新书写恒等函数的推导：

1. **引入宇宙**：

   $$
   U_0 : U_1 \quad (\text{UF})
   $$

2. **引入类型变量**：

   $$
   [A : U_0] \quad (\text{假设})
   $$

3. **引入变量**：

   $$
   [x : A] \quad (\text{假设})
   $$

4. **构造恒等函数**：

   $$
   \lambda x^A . x : A \rightarrow A \quad (\Rightarrow I)
   $$

5. **抽象类型变量**：

   $$
   \lambda A^{U_0} . \lambda x^A . x : (\forall A : U_0) . (A \rightarrow A) \quad (\forall I)
   $$

这次，原本非正式的假设 **$A \)** 是一个类型，现在被正式的假设 **$A : U_0 \)** 所替代，并在随后被消除。定义的函数将对于 **$U_0 \)** 中的任何类型 **$A \)**，当应用于该类型时，返回该类型上的恒等函数。例如：

$$
(\lambda A^{U_0} . \lambda x^A . x)\ \text{N} \rightarrow \lambda x^{\text{N}} . x : \text{N} \rightarrow \text{N}
$$

这提供了一种**多态性**形式；恒等函数因此对于所有“**小**”类型（即 **$U_0 \)** 的成员）被统一地定义。

### **抽象类型**

如果我们给定一个**抽象类型**，通常意味着我们得到一个类型，但只能通过该类型上的某些操作来访问，而不是该类型可用的所有操作。

考虑类型：

$$
(\exists A : U_0) . P(A)
$$

这个类型的对象是什么样的？它们是对 **$(A, p) \)**，其中：

- **$A : U_0 \)** 是一个（小）类型。
- **$p : P(A) \)** 是一个证明，证明 **$A \)** 具有性质 **$P(A) \)**。

假设我们定义：

$$
P(A) \equiv (A \rightarrow A) \wedge (A \rightarrow A)
$$

那么，存在性类型的一个对象将是一个类型 **$A \)**，以及一个 **$p : (A \rightarrow A) \wedge (A \rightarrow A) \)**，即两个从 **$A \)** 到 **$A \)** 的函数的对。

这个对象等价于一个抽象类型的实现，其签名（用 Miranda 的符号表示）为：

```miranda
abstype A
with f1 :: A -> A
     f2 :: A -> A
```

其中 **$f1 \)** 和 **$f2 \)** 是 **$p \)** 的第一和第二投影。

在下一章中，我们将对量化类型进行更多的讨论，并查看一系列示例。

---

## **5.9.3 闭包公理（Closure Axioms）**

通常，我们通过一对规则来刻画一个类型的成员：

- **引入规则（Introduction Rules）**：解释哪些对象被允许作为类型的元素。
- **消除规则（Elimination Rules）**（加上**计算规则**）：将这些元素刻画为类型的唯一元素。

我们可以称后者为类型的**闭包公理**。类型 **$A \)** 的闭包公理允许我们对 **$A \)** 的所有元素证明性质，并通过对 **$A \)** 进行递归来定义函数。

我们给出的关于宇宙的规则对应于**引入规则**；如果我们希望通过对宇宙进行递归来定义函数，我们需要一个相应的**闭包公理**。在 Martin-Löf 对系统的处理方法中，这些公理被**有意地省略了**；出于哲学原因，他选择使宇宙是开放的，这样可以在不违反闭包公理的情况下向系统添加其他类型形成操作。

**注意**：

- **闭包公理**允许我们定义**非参数化（non-parametric）**的多态函数。
- 例如，我们可以定义一个函数，它在除 **$\text{N} \)** 以外的所有类型上都是恒等函数，而在 **$\text{N} \)** 上是后继函数 **$\lambda n . \text{succ}\ n \)**。
- 这个函数的类型也是 **$(\forall A : U_0) . (A \rightarrow A) \)**，就像多态的恒等函数一样。
- 但是，这个函数不是参数化的，因为它对 **$\text{N} \)** 进行了特殊处理。

---

## **5.9.4 扩展（Extensions）**

**问题**：

- 我们为什么要止步于宇宙链 **$U_0, U_1, \dots \)**，当存在一些在系统中无法定义的自然函数时？

**示例**：

- 考虑函数：

  $$
  \lambda n : \text{N} . U_n
  $$

  - 这个函数将自然数 **$n \)** 映射到宇宙 **$U_n \)**。

- 这个函数显然不属于任何 **$U_n \)**。

- 为了给它一个类型，我们需要添加第一个超限宇宙 **$U_\omega \)**，它本身是 **$U_{\omega + 1} \)** 的成员，以此类推，我们可以遍历构造性序数。

**讨论**：

- 这样的扩展是否有趣，无论是从证明论的角度还是从编程的角度，都是一个有待讨论的问题。

- 感兴趣的读者可以参考 [And65]，其中有一个类似的超限理论。

**另一个可能的方向**：

- 区分**集合类型**（如 **$\text{N} \)** 和 **$\text{tree} \)**）和**命题**，并尝试用一个**命题类型**来扩展类型理论。

- 然而，这本身已被证明是不一致的，参见 [Jac89]。

**总结**：

- 如果我们愿意限制类型形成操作，那么可以构建具有类型的类型的系统，并且是一致的。

- Girard 关于系统 F 的工作 [Gir80] 和 Huet 和 Coquand 的工作 [CH85] 证明了这一点。

- 这些系统的更多细节将在第9.1.5节中给出。

---

**参考文献**：

- [ML71] Martin-Löf, P. (1971). *An Intuitionistic Theory of Types: Predicative Part*. In Logic Colloquium '73.
- [Gir72] Girard, J.-Y. (1972). *Interprétation fonctionnelle et élimination des coupures dans l'arithmétique d'ordre supérieur*. PhD thesis, Université Paris VII.
- [MR86] McDowell, R. & Rosolini, G. (1986). *Computational interpretations of linear logic*. In Proceedings of the 1986 Conference on Computer Science Logic.
- [How88] Howe, D. (1988). *Computational Metatheory in Nuprl*. PhD thesis, Cornell University.
- [Smi87] Smith, J. (1987). *An Interpretation of Martin-Löf's Type Theory in a Type-Free Theory*. Journal of Symbolic Logic, 52(3), 473–489.
- [And65] Anderson, A. (1965). *Transfinite Type Theory*. In Logic, Methodology and Philosophy of Science.
- [Jac89] Jacobs, B. (1989). *Inconsistency of Higher-Order Logic with Type of all Types*. Journal of Symbolic Logic, 54(3), 1131–1133.
- [Gir80] Girard, J.-Y. (1980). *Une extension de l'interprétation fonctionnelle de Gödel à l'analyse et son application à l'élimination des coupures dans l'analyse et la théorie des types*. In Proceedings of the 2nd Scandinavian Logic Symposium.
- [CH85] Coquand, T. & Huet, G. (1985). *The Calculus of Constructions*. Technical Report 530, INRIA.

---

**总结**：

- 在本节中，我们探讨了将**宇宙**引入类型理论的必要性和方法。

- 通过引入宇宙，我们可以在类型理论中处理类型的类型，从而实现类型多态性、抽象类型定义等高级特性。

- 为了保持系统的一致性，我们引入了一个**宇宙层级**，而不是一个包含所有类型的单一类型。

- 我们讨论了宇宙的形成规则、类型族、对宇宙的量化以及闭包公理。

- 最后，我们探讨了进一步的扩展方向，以及可能遇到的困难和不一致性问题。

希望以上详解有助于您理解本节的内容！

### ---------------------------

# 第5章：探索类型理论

---

## **5.10 良基类型（Well-founded Types）**

在上一章的第4.9节中，我们引入了**代数类型（algebraic types）**，并描述了我们对代数类型的理解，然后为特定的二叉树类型 **`tree`** 引入了规则。

在本节中，我们将讨论**良基类型（well-founded types）**，这是一类可以用类似方式定义的类型。通过分析 `tree` 类型，我们找到了一般的良基类型的规则，并将在接下来的部分详细讨论。

### **5.10.1 列表（Lists）**

**列表（List）** 是编程中最常见的数据结构之一。在类型理论中，列表的定义可以如下描述：

- 一个列表要么是**空的（empty）**，记为 `[ ]`。
- 要么是由一个**首元素（head）** `a` 和一个**尾列表（tail）** `x` 组成，表示为 `(a :: x)`。

这里，`::` 被称为**构造函数（constructor）**，通常读作“cons”。它用于将元素添加到列表的前面。

#### **列表的递归定义**

我们可以使用递归来定义在列表上的函数。例如，计算数值列表的和：

- **基例（Base Case）**：
  
  $$
  \text{sum}\ [\ ] \equiv_{\text{df}} 0
  $$
  
  这表示空列表的和为0。

- **递归步（Recursive Step）**：
  
  $$
  \text{sum}\ (a :: x) \equiv_{\text{df}} a + (\text{sum}\ x)
  $$
  
  这表示列表 `(a :: x)` 的和等于首元素 `a` 加上尾列表 `x` 的和。

#### **注意**

- 在某些编程语言中（如 Miranda），`:` 和 `::` 的用法可能与这里不同。这里采用了 Standard ML（SML）的惯例。

- **同质列表（Homogeneous List）**：列表中的所有元素都应具有相同的类型 `A`。这使得我们可以定义 `map`、`filter`、`foldr` 等标准函数。

#### **列表的形成规则**

为了在类型理论中正式化列表类型 `[A]`，我们引入以下规则：

1. **形成规则（Formation Rule）**：

   如果 `A` 是一个类型，那么 `[A]` 是一个类型：

   $$
   \frac{A\ \text{是一个类型}}{[A]\ \text{是一个类型}} \quad (\text{list F})
   $$

2. **引入规则（Introduction Rules）**：

   - **空列表的引入**：

     $$
     [\ ] : [A] \quad (\text{list I1})
     $$

     这表示空列表是 `[A]` 类型的元素。

   - **非空列表的引入**：

     如果 `a : A` 且 `l : [A]`，那么 `(a :: l) : [A]`：

     $$
     \frac{a : A \quad l : [A]}{(a :: l) : [A]} \quad (\text{list I2})
     $$

     这表示如果 `a` 是类型 `A` 的元素，`l` 是 `[A]` 的列表，那么 `(a :: l)` 也是 `[A]` 的列表。

3. **消除规则（Elimination Rule）**：

   为了定义在列表上的递归函数，我们需要一个消除规则。假设我们有一个列表 `l : [A]`，并希望定义一个类型为 `C[l / x]` 的结果（这里，`C` 是关于 `x` 的类型表达式）。

   - **消除规则**：

     $$
     \frac{l : [A] \quad s : C[\ [\ ]\ / x] \quad f : (\forall a : A).(\forall l : [A]).(C[l / x] \Rightarrow C[(a :: l) / x])}{\text{lrec}\ l\ s\ f : C[l / x]} \quad (\text{list E})
     $$

     - `s` 是在空列表情况下的结果。
     - `f` 是一个函数，给定一个元素 `a : A` 和一个列表 `l : [A]`，如果我们已经有 `C[l / x]`，那么我们可以得到 `C[(a :: l) / x]`。

4. **计算规则（Computation Rules）**：

   - 对于空列表：

     $$
     \text{lrec}\ [\ ]\ s\ f \rightarrow s
     $$

     这表示在空列表情况下，递归函数的值为 `s`。

   - 对于非空列表：

     $$
     \text{lrec}\ (a :: l)\ s\ f \rightarrow f\ a\ l\ (\text{lrec}\ l\ s\ f)
     $$

     这表示在 `(a :: l)` 的情况下，递归函数的值由 `f` 确定，它接受 `a`、`l` 和对尾列表 `l` 的递归调用结果。

#### **记号约定**

- `::` 被认为是右结合的，即 `(a :: b :: l)` 等价于 `(a :: (b :: l))`。

- 我们使用 `[a_1, a_2, \dots, a_n]` 来表示列表 `(a_1 :: a_2 :: \dots :: a_n :: [\ ])`。

#### **示例**

- 使用 `lrec` 定义 `map` 函数，它接受一个函数 `f` 和一个列表 `[a_1, a_2, \dots, a_n]`，返回 `[f\ a_1, f\ a_2, \dots, f\ a_n]`。

#### **练习**

1. 使用 `lrec` 定义 `map` 函数。

2. 定义 `segs` 函数，其类型为 `[A] \rightarrow [[A]]`，满足：

   $$
   \text{segs}\ [n_1, n_2, \dots, n_m] \equiv_{\text{df}} [\ [\ ],\ [n_1],\ [n_1, n_2],\ \dots,\ [n_1, n_2, \dots, n_m]\ ]
   $$

3. 使用 `segs` 或其他方法，定义 `sums` 函数，其类型为 `[N] \rightarrow [N]`，满足：

   $$
   \text{sums}\ [n_1, n_2, \dots, n_m] \equiv_{\text{df}} [0,\ n_1,\ n_1 + n_2,\ \dots,\ n_1 + n_2 + \dots + n_m]
   $$

   考虑空列表 `[ ]` 的适当值。

4. 定义 `sublists` 函数，其类型为 `[A] \rightarrow [[A]]`，返回一个列表的所有子列表。

5. 讨论如何从类型 `A` 上的等式操作定义列表类型 `[A]` 上的等式操作。

### **5.10.2 一般情况——W类型**

在一般情况下，我们可以将任何代数类型的元素视为**树（trees）**。例如，图5.1展示了自然数 `0` 和 `2`（即 `succ (succ 0)`）以及列表 `[1, 0]` 的树形表示。

#### **树的表示**

- **自然数的树形表示**：

  - `0` 被表示为一个没有前驱的节点。
  - `succ n` 被表示为一个带有一个前驱的节点，前驱是 `n`。

- **列表的树形表示**：

  - 列表 `[a_1, a_2, \dots, a_n]` 被表示为一系列 `cons` 节点，最后是一个 `nil` 节点。

- **二叉树的表示**：

  - 图5.2展示了一个二叉树的示例，其中每个节点可以有零个或两个前驱。

#### **一般形式**

这些类型的共同特点是，每个节点由相同类型的某些前驱集合构建。对于一般的代数类型，我们有：

- 一个类型 `A`，表示**节点的种类（sorts of node）**。

  - 对于树而言，`A` 可以是一个和类型，如 `A ≡ ( > \lor N )`，其中 `>` 表示只有一个元素的类型（例如 `Null` 节点），`N` 表示携带数字的节点。

- 一个类型族 `B(a)`，对于每个 `a : A`，`B(a)` 是一个类型，表示节点 `a` 的**前驱名称的类型**。

  - 对于 `Null` 节点，`B(\text{Null}) ≡ \bot`（空类型），因为它没有前驱。
  - 对于二叉节点 `Bnode n`，`B(\text{Bnode}\ n) ≡ N^2`，表示有两个前驱。

#### **W类型的构造**

**W类型**是一种良基类型，用于构建这种一般形式的代数类型。其形成规则为：

1. **形成规则（Formation Rule）**：

   如果 `A` 是一个类型，并且对于所有 `x : A`，`B(x)` 是一个类型，那么：

   $$
   \frac{A\ \text{是一个类型} \quad [x : A]\ .\ .\ .\ B(x)\ \text{是一个类型}}{(W\ x : A)\ .\ B(x)\ \text{是一个类型}} \quad (\text{W F})
   $$

2. **引入规则（Introduction Rule）**：

   - 如果 `a : A`，`f : B(a) \rightarrow (W\ x : A)\ .\ B(x)`，那么：

     $$
     \frac{a : A \quad f : B(a) \rightarrow (W\ x : A)\ .\ B(x)}{\text{node}\ a\ f : (W\ x : A)\ .\ B(x)} \quad (\text{W I})
     $$

     这表示我们可以使用节点种类 `a` 和前驱函数 `f` 构造一个 W 类型的元素。

3. **消除规则（Elimination Rule）**：

   为了在 W 类型上定义递归或归纳函数，我们需要一个消除规则。

   - 假设我们有 `w : (W\ x : A)\ .\ B(x)`，并希望证明 `C(w)`。

   - **消除规则**：

     $$
     \frac{w : (W\ x : A)\ .\ B(x) \quad R : \text{Ind}(A, B, C)}{\text{Rec}\ w\ R : C(w)} \quad (\text{W E})
     $$

     其中，`R` 是一个归纳步骤，类型为：

     $$
     R : (\forall a : A)(\forall f : B(a) \rightarrow (W\ x : A)\ .\ B(x))\ ((\forall y : B(a))\ C(f\ y) \Rightarrow C(\text{node}\ a\ f))
     $$

4. **计算规则（Computation Rule）**：

   - 对于 `\text{node}\ a\ f`：

     $$
     \text{Rec}\ (\text{node}\ a\ f)\ R \rightarrow R\ a\ f\ (\lambda x . \text{Rec}\ (f\ x)\ R)
     $$

     这表示对节点 `\text{node}\ a\ f` 的递归结果由 `R` 确定，它接受 `a`、`f` 和对所有前驱的递归结果。

#### **W类型的解释**

- **节点的构造**：

  - 使用 `node` 构造函数，我们可以构造 W 类型的元素。

- **递归定义**：

  - 使用 `Rec` 函数和消除规则，我们可以在 W 类型上定义递归函数。

#### **示例：树类型的W类型表示**

- **定义节点种类类型 `A`**：

  - `A ≡ ( > \lor N )`，表示节点可以是 `Null` 或 `Bnode n`。

- **定义前驱名称类型族 `B(a)`**：

  - 对于 `Null`，`B(\text{Null}) ≡ \bot`。

  - 对于 `Bnode n`，`B(\text{Bnode}\ n) ≡ N^2`。

- **构造 `Null` 节点**：

  - 使用 `node` 和一个从空类型到 W 类型的函数 `efun`，我们得到：

    $$
    \text{node}\ \text{Null}\ \text{efun}
    $$

  - 这对应于 `Null` 节点。

- **构造 `Bnode` 节点**：

  - 对于给定的 `n : N`，`u, v : \text{tree}`，我们定义：

    $$
    f_{u, v} \equiv_{\text{df}} \lambda x . (\text{cases}_2\ x\ u\ v)
    $$

    其中，`f_{u, v} : N^2 \rightarrow \text{tree}`，将前驱名称映射到前驱 `u` 和 `v`。

  - 然后，我们构造：

    $$
    \text{node}\ (\text{Bnode}\ n)\ f_{u, v}
    $$

#### **消除规则的应用**

- **归纳步骤 `R`**：

  - 我们需要定义一个函数 `R`，类型为：

    $$
    R : (\forall a : A)(\forall f : B(a) \rightarrow (W\ x : A)\ .\ B(x))\ ((\forall y : B(a))\ C(f\ y) \Rightarrow C(\text{node}\ a\ f))
    $$

  - 对于 `Null` 节点，`B(\text{Null}) ≡ \bot`，因此函数 `f : \bot \rightarrow (W\ x : A)\ .\ B(x)` 是唯一的。

  - 因此，我们需要一个 `c : C(\text{Null})`。

- **计算规则的应用**

  - 对于 `\text{node}\ \text{Null}\ \text{efun}`，计算规则为：

    $$
    \text{Rec}\ \text{Null}\ R \rightarrow R\ \text{Null}\ \text{efun}\ (\lambda x . \text{Rec}\ (\text{efun}\ x)\ R)
    $$

  - 由于 `\text{efun}` 的域是空的，`(\lambda x . \text{Rec}\ (\text{efun}\ x)\ R)` 可以被忽略，因此结果为 `c`。

#### **讨论**

- **外延等价**：

  - 为了证明从空域到类型 `T` 的函数是唯一的，我们需要使用**外延等价（extensional equality）**。

- **定义外延同构（Extensional Isomorphism）**：

  - **定义5.38**：

    两个类型 `A` 和 `B` 是外延同构的，如果存在两个函数 `f : A \rightarrow B` 和 `g : B \rightarrow A`，使得：

    $$
    (\forall x : A)\ (g(f\ x) \approx_A x) \quad \text{且} \quad (\forall y : B)\ (f(g\ y) \approx_B y)
    $$

    其中 `\approx` 表示外延等价。

- **简化记号**

  - 在非依赖类型的情况下，我们可以简化一些记号，使得递归定义更易读。

#### **系统扩展**

- **定义5.39**：

  我们将包含完整 W 类型规则的系统称为 **`TT+`**，并保留 **`TT`** 作为仅包含 `tree` 或等价的所有前驱类型 `B(a)` 是有限的 W 类型的系统。

#### **定理5.40**

- **`TT+`** 是**强规范化的（strongly normalising）**，具有 **Church-Rosser** 性质，并且可转换性和形式为 `a : A` 的判断的可推导性都是**可判定的（decidable）**。

**证明**：与第5.6节的证明完全相同。 ∎

---

### **5.10.3 Miranda 中的代数类型**

**Miranda** 是一种函数式编程语言，它提供了代数类型的机制。

#### **特性**

- 我们可以定义一些**互相递归（mutually recursive）**的类型。

- 可以定义**无穷分支的树（infinitely branching trees）**，从而定义可数的序数。

#### **示例**

- **定义序数类型**：

  ```miranda
  ordinal ::= Zero |
              Succ ordinal |
              Limit (nat -> ordinal)
  ```

  - `Zero`：零序数。
  - `Succ`：后继序数。
  - `Limit`：极限序数，由一个从自然数到序数的函数表示。

- **定义一般类型**：

  ```miranda
  model ::= Atom nat |
            Function (model -> model)
  ```

  - 这个类型可以看作无类型 λ-演算的模型。

#### **限制**

- 这样的类型不是良基类型，不能适用于 W 类型框架。

- 如果我们希望仅在代数类型机制中包含良基类型，需要限制类型定义，不允许类型出现在构造函数的函数空间的域类型中。

#### **推理**

- 对于一般的非良基类型，需要使用**不动点归纳法（fixed-point induction）**来进行推理。

---

### **练习**

1. **练习5.31**：

   - 证明在 $a ≡ \text{Bnode}\ n$（其中 $B(a) ≡ N^2$）的情况下，类型：

     $$
     (\forall f : N^2 \rightarrow \text{tree})\ ((\forall y : N^2)\ C(f\ y) \Rightarrow C(\text{node}\ a\ f))
     $$

     与类型：

     $$
     (\forall u : \text{tree})(\forall v : \text{tree})(C[u / x] \Rightarrow C[v / x] \Rightarrow C[\text{Bnode}\ n\ u\ v / x])
     $$

     是外延同构的。

2. **练习5.32**：

   - 展示对于节点 $\text{Bnode}\ n\ u\ v$，`R` 的计算规则如何专门化为 `trec` 的计算规则。

3. **练习5.33**：

   - 展示自然数可以表示为一个 W 类型。

---

### **总结**

- **良基类型（Well-founded Types）** 是一种广泛的类型，用于表示可以通过递归或归纳定义的数据结构，如自然数、列表、树等。

- **W类型** 提供了一种统一的方式来定义这些良基类型，使用节点种类类型 `A` 和前驱名称类型族 `B(a)`。

- **引入规则** 和 **消除规则** 允许我们构造 W 类型的元素并在其上定义递归函数。

- **外延同构** 和 **外延等价** 的概念在证明类型之间的等价性时非常重要。

- 在编程语言（如 Miranda）中，我们可以使用代数类型来定义复杂的数据结构，但需要注意良基性和类型系统的限制。

希望以上详解能帮助您理解本节内容。如果您有任何疑问，欢迎提问！

### ----------------------------



### ---------------------------



### ----------------------------
[toc]



### **第6章 应用类型理论 (Applying Type Theory)**

#### **简介：**

在本章中，我们将深入探讨类型理论系统的多种应用方式。类型理论不仅是一个强大的逻辑框架，也是一个功能强大的编程语言，能够支持程序的开发、验证和变换。通过本章的学习，您将了解：

- **类型理论作为构造性逻辑：** 我们已经熟悉了类型理论作为构造性逻辑的角色，并在第4.5和4.6.1节中见到了多个构建证明的示例。

- **类型理论作为函数式编程语言：** 我们看到类型理论可以视为一种函数式编程语言，具有一些新颖的特性，例如：
  - **完全性：** 每个表达式都有定义的值；每个程序都能终止。
  - **更具表达力的类型系统：** 类型系统比常用的类型系统更具表达力，允许依赖乘积和函数空间。
  - **集成的逻辑推理：** 函数式语言与一个逻辑系统集成，可以对程序进行推理。

- **从构造性证明中提取程序：** 在类型理论中，我们可以将程序视为从构造性证明中提取出来的。这种方法优雅而强大，融合了逻辑和编程的两种解释。

- **程序属性的推理和程序变换：** 我们不仅可以使用逻辑系统对程序的属性进行推理，还可以利用系统支持程序的变换。

- **在类型理论框架中开发命令式程序：** 最后，我们将展示如何在类型理论的框架内开发命令式程序。

---

### **6.1 递归 (Recursion)**

#### **6.1.1 数值函数 (Numerical Functions)**

##### **解释：**

在本节中，我们将探讨如何使用**原始递归 (Primitive Recursion)** 来定义数值函数。由于类型理论中的语言是终止的，因此所有函数都必须保证计算能够在有限步骤内完成。我们将了解如何在这种受限的环境中定义常见的数值函数。

##### **原始递归的定义：**

原始递归是一种定义函数的方法，通常用于构造可计算的、保证终止的函数。它基于以下两个原则：

1. **基准情况 (Base Case)：** 定义函数在初始值（如零）上的值。
2. **递归步骤 (Recursive Step)：** 定义函数在后继者上的值，基于其在前一值上的值。

##### **示例：**

**自然数加法：**

- **基准情况：** 定义 $add(n, 0) = n$，即任何数与零相加等于自身。
- **递归步骤：** 定义 $add(n, succ(m)) = succ(add(n, m))$，即 $n$ 与 $m$ 的后继相加，等于 $n$ 与 $m$ 相加的结果的后继。

**解释：**

- 在基准情况下，当第二个参数为零时，结果就是第一个参数 $n$。
- 在递归步骤中，我们将问题简化为更小的问题，即计算 $add(n, m)$，然后取其后继。

##### **重要性：**

- **终止性保证：** 由于每次递归调用都在处理更小的值（这里指 $m$），并且最终会达到基准情况，因而保证了函数的终止性。
- **构造性定义：** 原始递归提供了一种构造性的方法来定义函数，这与类型理论的构造性逻辑本质一致。

---

#### **6.1.2 通过递归定义命题和类型 (Defining Propositions and Types by Recursion)**

##### **解释：**

不仅可以通过递归定义数值函数，还可以使用递归来定义**命题 (Propositions)** 和**类型 (Types)**。这使得我们能够构造复杂的逻辑结构和数据类型。

##### **示例：**

**自然数的等式：**

- 定义两个自然数是否相等的命题 $Equal(n, m)$，可以递归地定义如下：

  - **基准情况：**
    - $Equal(0, 0)$ 为真。
    - $Equal(0, succ(m))$ 为假。
    - $Equal(succ(n), 0)$ 为假。
  - **递归步骤：**
    - $Equal(succ(n), succ(m)) = Equal(n, m)$。

**解释：**

- 我们通过比较自然数的结构来判断它们是否相等。
- 在递归步骤中，如果两个数都是后继数，则递归地比较它们的前一个数。

##### **重要性：**

- **构造逻辑命题：** 通过递归定义命题，我们可以精确地描述复杂的逻辑关系。
- **类型的递归定义：** 类似地，可以递归地定义数据类型，例如列表、树等。

---

#### **6.1.3 列表上的递归 – 1 (Recursion over Lists – 1)**

##### **解释：**

在函数式编程中，列表是一种常用的数据结构。我们可以使用递归在列表上定义函数。然而，由于类型理论的语言是终止的，我们需要确保递归定义是原始递归的形式。

##### **示例：**

**列表长度函数 $length$：**

- **基准情况：** 对于空列表 $nil$，定义 $length(nil) = 0$。
- **递归步骤：** 对于非空列表 $cons(h, t)$，定义 $length(cons(h, t)) = succ(length(t))$。

**解释：**

- 空列表的长度为零。
- 非空列表的长度等于其尾部列表的长度加一。

##### **注意事项：**

- **终止性：** 由于每次递归调用都处理列表的尾部，列表的长度在递归过程中逐步减少，最终会达到空列表的基准情况。
- **类型匹配：** 确保函数的参数和返回值类型匹配，保证类型系统的一致性。

---

#### **6.1.4 列表上的递归 – 2 (Recursion over Lists – 2)**

##### **解释：**

有些函数，例如获取列表的头元素，在传统的编程语言中可能容易定义。但在类型理论中，由于需要保证函数的总定义性（即对所有输入都有定义），我们需要对类型进行细致的处理。

##### **示例：**

**获取非空列表的头元素 $head$：**

- 定义一个类型 **非空列表 (NonEmptyList)**，表示至少包含一个元素的列表。
- **类型定义：**
  - $NonEmptyList(A) = \Sigma (h : A) \times List(A)$，即包含一个元素 $h$ 和一个（可能为空）的列表 $t$。

- **函数定义：**
  - 对于非空列表 $cons(h, t)$，定义 $head(cons(h, t)) = h$。

**解释：**

- 我们通过限制列表的类型，确保传递给 $head$ 函数的列表一定是非空的。
- 这避免了在空列表上调用 $head$ 导致未定义的情况。

##### **重要性：**

- **类型系统的表达力：** 使用依赖类型，我们可以精确地描述数据的性质，确保函数的正确性。
- **总定义性：** 通过在类型层面进行约束，确保函数在其定义域内对所有输入都有定义。

---

### **6.2 案例研究 – 快速排序 (A Case Study – Quicksort)**

#### **6.2.1 函数的定义 (Defining the Function)**

##### **解释：**

快速排序 (Quicksort) 是一种高效的排序算法，通常使用递归来实现。在类型理论中，我们可以定义快速排序函数，同时利用类型系统来确保其正确性和终止性。

##### **函数定义的步骤：**

1. **基准情况：**

   - 对于空列表或只有一个元素的列表，列表已经有序，直接返回。

2. **递归步骤：**

   - 选择一个基准元素（通常是列表的第一个元素）。
   - 将列表划分为两部分：
     - **小于基准元素的子列表。**
     - **大于等于基准元素的子列表。**
   - 对这两个子列表递归地应用快速排序。
   - 将排序后的子列表与基准元素合并，得到最终的排序列表。

##### **类型考虑：**

- **列表元素的类型：** 假设列表中的元素类型为 $A$，并且 $A$ 上定义了一个全序关系（如小于关系）。
- **递归的终止性：** 每次递归调用都处理更短的列表，确保了算法的终止性。

---

#### **6.2.2 验证函数 (Verifying the Function)**

##### **解释：**

在类型理论中，我们不仅可以定义快速排序函数，还可以证明它满足规范，即：

- **正确性：** 排序后的列表是原列表的排列（包含相同的元素）。
- **有序性：** 排序后的列表中的元素按照指定的顺序排列。

##### **证明步骤：**

1. **证明基准情况：**

   - 对于空列表或单元素列表，显然满足有序性和正确性。

2. **证明递归步骤：**

   - **归纳假设：** 假设对列表长度小于 $n$ 的所有列表，快速排序函数都满足正确性和有序性。
   - **证明列表长度为 $n$ 的情况：**
     - 划分后的子列表长度小于 $n$，根据归纳假设，它们排序后满足正确性和有序性。
     - 合并步骤不会改变元素的数量或顺序。
     - 因此，完整的排序结果也满足正确性和有序性。

##### **类型系统的作用：**

- **依赖类型的使用：** 我们可以使用依赖类型来表达列表的长度，从而在类型层面上表达归纳假设和证明目标。
- **集成的证明与程序：** 在类型理论中，程序和证明是紧密结合的，证明过程可以直接在语言中表达和验证。

---

### **6.3 依赖类型和量词 (Dependent Types and Quantifiers)**

#### **6.3.1 依赖类型 (Dependent Types)**

##### **解释：**

依赖类型是类型可以依赖于值的类型。它们允许我们在类型中包含关于值的信息，从而使类型系统更加表达力强，能够精确地描述程序的性质。

##### **示例：**

- **向量类型 (Vector)：** 一个长度为 $n$ 的元素类型为 $A$ 的向量可以表示为 $Vector(A, n)$。

**解释：**

- 向量的类型依赖于其长度 $n$，这在类型层面上强制了向量的长度信息。

---

#### **6.3.2 存在量词 (The Existential Quantifier)**

##### **解释：**

存在量词可以在类型理论中通过**依赖和类型的乘积类型 (Dependent Sum Type)** 来实现。它表示存在某个值使得某种性质成立。

##### **定义：**

- **依赖和类型 (Dependent Sum Type)：**
  - 记作 $\Sigma_{x:A} B(x)$，表示类型 $A$ 中的某个值 $x$，以及依赖于 $x$ 的类型 $B(x)$。

##### **示例：**

- **存在一个自然数 $n$，使得 $n$ 是偶数：**
  - 在类型理论中表示为 $\Sigma_{n: \mathbb{N}} Even(n)$。

---

#### **6.3.3 全称量词 (The Universal Quantifier)**

##### **解释：**

全称量词可以通过**依赖函数类型 (Dependent Function Type)** 来表示，表示对于所有值，某种性质都成立。

##### **定义：**

- **依赖函数类型 (Dependent Function Type)：**
  - 记作 $\Pi_{x:A} B(x)$，表示对于每个 $x$ 属于 $A$，都有一个 $B(x)$。

##### **示例：**

- **对于所有自然数 $n$，$n + 0 = n$：**
  - 在类型理论中表示为 $\Pi_{n: \mathbb{N}} (n + 0 = n)$。

---

#### **6.3.4 实现逻辑 (Implementing a Logic)**

##### **解释：**

通过依赖类型和量词，我们可以在类型理论中实现逻辑系统，表达复杂的逻辑命题和证明。

##### **关键点：**

- **类型即命题 (Propositions as Types)：** 类型可以视为命题，类型的值（即程序）可以视为该命题的证明。
- **逻辑运算的类型表示：**
  - **合取 (And)：** 使用乘积类型 $A \times B$。
  - **析取 (Or)：** 使用和类型 $A + B$。
  - **蕴含 (Implication)：** 使用函数类型 $A \rightarrow B$。

---

#### **6.3.5 量词和宇宙 – ∀ (Quantification and Universes – ∀)**

##### **解释：**

为了在类型理论中表示全称量词，需要引入**宇宙 (Universe)** 的概念。宇宙是类型的类型，允许我们在类型层面上进行量化。

##### **定义：**

- **宇宙 $U$：** $U$ 是一个类型，包含所有小于 $U$ 的类型。
- **全称量词的表示：** $\Pi_{A: U} B(A)$，表示对于所有类型 $A$，性质 $B(A)$ 成立。

---

#### **6.3.6 量词和宇宙 – ∃ (Quantification and Universes – ∃)**

##### **解释：**

类似地，存在量词也可以在宇宙的框架内表示。

##### **定义：**

- **存在量词的表示：** $\Sigma_{A: U} B(A)$，表示存在一个类型 $A$，使得性质 $B(A)$ 成立。

---

### **6.4 案例研究 – 向量 (A Case Study – Vectors)**

#### **6.4.1 有限类型的再探讨 (Finite Types Revisited)**

##### **解释：**

在本节中，我们重新审视有限类型，例如固定长度的列表或数组。通过依赖类型，我们可以在类型层面上精确地描述这些数据结构的大小和性质。

---

#### **6.4.2 向量 (Vectors)**

##### **解释：**

向量是一种长度固定的序列，元素类型为 $A$。使用依赖类型，我们可以定义向量类型，其中长度作为类型的一部分。

##### **向量类型的定义：**

- **类型定义：** $Vector(A, n)$，表示元素类型为 $A$，长度为 $n$ 的向量。
- **构造函数：**
  - **空向量：** 当 $n = 0$ 时，向量为空。
  - **递归构造：** 当 $n > 0$ 时，可以通过在长度为 $n-1$ 的向量前添加一个元素来构造长度为 $n$ 的向量。

##### **操作函数：**

- **向量的加法：** 可以定义两个向量的元素逐个相加，前提是它们的长度相同。
- **向量的映射：** 对向量的每个元素应用一个函数，得到一个新的向量。

##### **类型系统的优势：**

- **类型安全性：** 由于长度是类型的一部分，编译器可以在编译时检查向量操作是否合法，防止越界等错误。
- **代码的自文档性：** 类型清晰地表达了数据结构的性质，提高了代码的可读性和可维护性。

---

### **6.5 证明提取；自顶向下的证明 (Proof Extraction; Top-Down Proof)**

#### **6.5.1 命题逻辑 (Propositional Logic)**

##### **解释：**

在类型理论中，命题逻辑可以通过类型和函数来表示。我们可以从逻辑证明中提取出对应的程序。

##### **示例：**

- **假言推理 (Modus Ponens)：**
  - 命题：如果 $A$ 且 $A \rightarrow B$，则 $B$。
  - 类型表示：给定 $a: A$ 和 $f: A \rightarrow B$，则 $f(a): B$。

**解释：**

- 逻辑推理对应于函数应用。
- 证明过程直接对应于程序的执行。

---

#### **6.5.2 谓词逻辑 (Predicate Logic)**

##### **解释：**

谓词逻辑涉及量词，可以在类型理论中通过依赖类型来表示。

##### **示例：**

- **全称量词的证明提取：** 从 $\Pi_{x: A} P(x)$ 中提取一个函数，能够对任意 $x$ 生成 $P(x)$ 的证明。

---

#### **6.5.3 自然数 (Natural Numbers)**

##### **解释：**

自然数的证明和计算可以在类型理论中紧密结合。

##### **示例：**

- **归纳证明：** 利用自然数的递归结构，可以进行数学归纳法的证明，同时对应于递归函数的定义。

---

### **6.6 程序开发 – 波兰国旗问题 (Program Development – Polish National Flag)**

##### **解释：**

波兰国旗问题（也称为荷兰国旗问题）是一个经典的算法问题，要求将包含三种颜色的元素的数组进行排序，使得相同颜色的元素相邻。

##### **问题描述：**

- 给定一个数组，元素可以是红、白、蓝三种颜色。
- 需要对数组进行排序，使得红色元素在前，白色元素居中，蓝色元素在后。

##### **解决方案：**

- **算法设计：** 使用双指针或三指针的方法，一次遍历数组，进行元素的交换。
- **类型理论中的实现：** 利用类型系统，可以确保数组的索引和操作的安全性。

##### **证明：**

- **正确性证明：** 证明算法在有限步骤内完成，并且排序结果满足要求。
- **类型系统的作用：** 类型可以表达数组的性质和操作的合法性。

---

### **6.7 程序变换 (Program Transformation)**

#### **6.7.1 映射和折叠 (map and fold)**

##### **解释：**

映射 (map) 和折叠 (fold) 是函数式编程中的两个基本高阶函数，用于对数据结构进行遍历和累积操作。

- **map：** 对列表的每个元素应用一个函数，得到一个新的列表。
- **fold：** 将列表的元素通过一个二元函数组合，累积成一个结果。

---

#### **6.7.2 算法 (The Algorithm)**

##### **解释：**

通过将算法表示为 map 和 fold 等高阶函数的组合，可以简化算法的结构，提高代码的可读性和可维护性。

---

#### **6.7.3 变换 (The Transformation)**

##### **解释：**

程序变换是将一个程序转换为功能等价但性能更优或结构更清晰的程序的过程。在类型理论中，程序变换可以在类型安全的前提下进行，确保变换后的程序仍然满足规格。

---

### **6.8 命令式编程 (Imperative Programming)**

##### **解释：**

虽然类型理论主要用于函数式编程，但我们可以将命令式编程视为特定形式的函数式编程，特别是**尾递归函数 (Tail-Recursive Functions)**。

##### **关键点：**

- **尾递归与循环：** 尾递归函数可以被优化为循环结构，与命令式编程中的迭代类似。
- **状态的模拟：** 可以通过函数的参数传递状态，从而模拟命令式编程中的可变状态。

##### **示例：**

- **计数循环：** 使用尾递归函数来实现从 $n$ 计数到 $0$ 的循环。

---

### **6.9 文献中的示例 (Examples in the Literature)**

#### **6.9.1 Martin-Löf**

##### **解释：**

Per Martin-Löf 是类型理论的创始人之一，他的工作对类型理论的发展产生了深远影响。他在类型理论中引入了依赖类型和构造性逻辑的概念。

---

#### **6.9.2 哥德堡学派 (Göteborg)**

##### **解释：**

哥德堡大学的研究团队在类型理论和函数式编程方面做出了重要贡献，开发了 Agda 等类型化编程语言。

---

#### **6.9.3 Backhouse 等人 (Backhouse et al.)**

##### **解释：**

Backhouse 等研究者在程序变换和算法的形式化开发方面进行了深入研究，利用类型理论和代数方法改进了算法设计。

---

#### **6.9.4 Nuprl**

##### **解释：**

Nuprl 是一个基于类型理论的交互式证明助手，支持构造性数学的形式化和程序的提取。

---

#### **6.9.5 构造演算 (Calculus of Constructions)**

##### **解释：**

构造演算 (Calculus of Constructions) 是类型理论的一种高级形式，结合了lambda演算和逻辑系统，支持更强大的类型和证明机制。

---

### **总结：**

本章探讨了类型理论在编程和逻辑推理中的多种应用方式。通过对递归、依赖类型、程序验证、程序变换和命令式编程的深入研究，我们看到了类型理论的强大表达能力和应用潜力。

类型理论不仅提供了一个强大的逻辑框架，还为编程语言的设计和程序的正确性验证提供了有力的工具。在未来的学习和应用中，类型理论将继续发挥重要作用，推动计算机科学的发展。

---

如果您对上述内容有任何疑问，或者希望进一步深入了解某个主题，请随时告诉我！

### ---------------------------

### **6.1 递归 (Recursion)**

#### **概述：**

本节讨论了类型理论系统 $TT_0$、$TT$ 和 $TT^+$ 中的递归特性。由于这些系统具有**强规范化 (strong normalization)** 的性质，即每个计算序列都会终止，因此它们不允许使用完全的通用递归 (general recursion)，因为通用递归可能导致非终止的计算。

---

#### **强规范化 (Strong Normalization)**

##### **解释：**

- **强规范化**是指在类型理论系统中，任何合法的计算都会在有限的步骤内结束，即所有的计算序列都是终止的。
- 这意味着系统中的每个函数都必须是**总函数 (total function)**，即对于其定义域内的每个输入，都能在有限的步骤内计算出结果。

##### **重要性：**

- **终止性保证**：强规范化确保了程序的安全性，防止了无限循环和非终止的计算。
- **限制**：由于强规范化的要求，系统不允许使用不受限制的通用递归。

---

#### **通用递归的限制**

##### **示例：**

考虑以下函数定义：

$$
\begin{align*}
f(0) &\equiv_{\text{df}} 0 \\
f(n + 1) &\equiv_{\text{df}} f(n + 2) + 1
\end{align*}
$$

- **解释：**
  - 这里，$f$ 是一个函数，其定义看似简单，但存在问题。
  - 在递归调用中，$f(n + 1)$ 依赖于 $f(n + 2)$，这意味着递归调用的参数在增大。
  - 这种定义可能导致无限递归，函数永远无法终止。

##### **问题：**

- **非终止性**：由于递归调用参数的增加，计算可能永远不会结束，违反了强规范化的原则。
- **不允许的定义**：类型理论系统中不允许这种形式的递归定义。

---

#### **类型系统的优势**

##### **解释：**

- 为了平衡递归操作的限制，类型理论提供了比常见编程语言更强大的类型系统。
- **表达能力更强的类型系统**：允许使用**存在量词 (existential quantifier)** 来构建子类型，从而更精确地表达函数的真实类型。

##### **应用：**

- **精确类型表达**：通过使用依赖类型和量词，我们可以精确地定义函数的输入和输出类型，确保函数的总定义性。
- **函数的全域性**：通过在类型层面上限制函数的定义域，确保函数对于所有合法输入都有定义。

---

#### **依赖于归纳证明的函数定义**

##### **解释：**

- 有时，函数的定义本身依赖于其终止性的归纳证明。
- **效果：**
  - 函数的定义中不仅操作计算数据，还操作证明某些事实的信息。
  - 这种将验证 (verification) 和计算 (computation) 交织在一起的方式是类型理论的特征。

##### **示例：**

- **证明函数终止性**：在定义函数时，同时构造一个证明，证明函数在所有输入上都会终止。
- **操作证明对象**：函数可能需要操作一些证明对象，作为其计算的一部分。

---

#### **本节内容概述**

- **重点**：我们将专注于自然数和列表上的例子，并在过程中引入量化类型 (quantified types)。
- **后续内容**：在下一节中，我们将更深入地研究这些类型。

---

#### **两种通用方法**

在研究具体的定义示例之前，值得提及两种通用的方法。

1. **基于定理 5.45 的方法：**

   - **定理 5.45：** 任何在 Peano 算术 (PA) 中可被证明为全函数的函数，都可以在 $TT_0$ 中编程实现，并且证明将提供一个对应的术语。
   - **问题：** 这引出了一个问题，即如何证明函数是全函数。
   - **观点：** 我们认为系统 $TT_0$ 提供了一个恰当的环境来给出这样的证明，因为它允许对函数进行构造性的推导，确保其全域性。

2. **基于良序和递归的证明理论方法：**

   - **证明理论家的研究：** 他们通过可以用于递归定义函数的良序 (well-orderings) 来刻画可被证明为全函数的函数类 [Sch77]。
   - **应用：** 我们可以使用这种刻画来在 $TT_0$ 中给出函数，但我们更强调系统自身的自然特性。
   - **拓展：** 已经有一些提议将良基 (well-founded) 或通用递归的原则纳入系统中，我们将在第 7.9 节中讨论这些内容。

---

### **6.1.1 数值函数 (Numerical Functions)**

#### **常见递归模式的示例**

我们来看一些包含常见递归模式的示例，并展示如何在 $TT_0$ 中对它们进行编码。

---

#### **示例：朴素加法算法**

考虑以下朴素的加法算法：

$$
\begin{align*}
\text{add } a \ 0 &\equiv_{\text{df}} a \\
\text{add } a \ (n + 1) &\equiv_{\text{df}} \text{add } (a + 1) \ n
\end{align*}
$$

##### **解释：**

- **目标：** 计算 $a + n$。
- **递归思路：**
  - **基准情况：** 当第二个参数为 $0$ 时，结果为 $a$。
  - **递归步骤：** 计算 $\text{add } (a + 1) \ n$，即增加 $a$ 的值，并递归地处理 $n$。

##### **问题：**

- **非原始递归：** 该定义看似原始递归 (primitive recursive)，但存在一个问题：在递归调用中，参数 $a$ 被增加了。
- **原始递归的限制：** 在原始递归中，递归调用只能对**严格小于当前值**的参数进行递归，且参数不能在递归过程中增加。

---

#### **解决方法：将函数泛化**

##### **思路：**

- **同时对所有 $a$ 定义 $\text{add } a \ n$：** 我们可以通过对 $n$ 进行归纳，来同时定义所有 $a$ 的值 $\text{add } a \ n$。
- **换句话说，定义函数：**

  $$
  \lambda a.\ (\text{add } a \ n)
  $$

  通过对 $n$ 进行归纳。

##### **原因：**

- 在定义 $\text{add } a \ (n + 1)$ 时，我们需要使用第二个参数为 $n$ 的 $\text{add }$ 的值。
- 这使得我们可以对 $n$ 进行归纳，参数 $a$ 作为函数的参数保留下来。

---

#### **正式定义**

1. **设定：**

   - 定义 $C \equiv_{\text{df}} (\mathbb{N} \rightarrow \mathbb{N})$，即 $C$ 是从自然数到自然数的函数的类型。

2. **基准情况：**

   $$
   c \equiv_{\text{df}} \lambda a.\ a : C
   $$

   - **解释：** 在 $n = 0$ 的情况下，$\text{add } a \ 0 = a$，因此定义 $c$ 为恒等函数。

3. **递归步骤：**

   $$
   f \ n \ h \ a \equiv_{\text{df}} h \ (a + 1)
   $$

   - **参数：**
     - $n : \mathbb{N}$
     - $a : \mathbb{N}$
     - $h : C$
   - **解释：** 在递归步骤中，$f$ 接受当前的 $n$，先前的函数 $h$，以及参数 $a$，然后计算 $h \ (a + 1)$。

4. **类型推导：**

   - $f : (\mathbb{N} \rightarrow C \rightarrow C)$

5. **应用 (简化形式的自然数消除规则 (NE))：**

   - **规则：**

     $$
     \frac{n : \mathbb{N} \quad c : C \quad f : (\mathbb{N} \rightarrow C \rightarrow C)}{\text{prim } n \ c \ f : C} \quad (\text{NE})
     $$

   - **解释：** 我们使用自然数的消除规则，对 $n$ 进行递归，$c$ 为基准情况，$f$ 为递归步骤。

6. **归约性质 (Reduction Properties)：**

   - **基准情况：**

     $$
     \begin{align*}
     \text{prim } 0 \ c \ f \ a &\rightarrow c \ a \\
     &\equiv (\lambda a.\ a) \ a \\
     &\rightarrow a
     \end{align*}
     $$

   - **递归步骤：**

     $$
     \begin{align*}
     \text{prim } (n + 1) \ c \ f \ a &\rightarrow f \ n \ (\text{prim } n \ c \ f) \ a \\
     &\rightarrow (\text{prim } n \ c \ f) \ (a + 1)
     \end{align*}
     $$

   - **解释：** 递归调用中，参数 $a$ 被增加了 $1$，然后对 $n$ 进行递归。

7. **最终定义：**

   $$
   \text{add} \equiv_{\text{df}} \lambda a.\ \lambda n.\ (\text{prim } n \ c \ f \ a)
   $$

   - **解释：** 我们定义了 $\text{add}$ 函数，接受参数 $a$ 和 $n$，并通过 $\text{prim}$ 对 $n$ 进行递归计算。

---

#### **归纳假设的泛化**

##### **类比：**

- 我们在这里进行了泛化，从定义一个函数到同时定义一组函数。
- 这类似于在通过归纳法证明结果时，经常需要泛化归纳假设。

##### **示例：**

- **目标：** 如果 $+$ 是通常的加法运算，我们希望通过归纳证明：

  $$
  \text{add } a \ n = a + n
  $$

- **归纳假设：**

  - 我们需要假设对于所有的 $a : \mathbb{N}$，都有：

    $$
    (\forall a : \mathbb{N}).\ (\text{add } a \ n = a + n)
    $$

  - **而不是**将 $a$ 视为参数的“裸”等式。

---

#### **使用更小的值进行递归**

##### **解释：**

- **原始递归**：通常定义 $f(n + 1)$ 基于 $f(n)$ 的值。
- **更一般的递归模式**：有时，自然地使用比 $n$ 小的某个数 $m$ 处的值。

##### **示例：幂函数 (Power Function)**

- **定义：**

  $$
  \begin{align*}
  \text{power } k \ 0 &\equiv_{\text{df}} 1 \\
  \text{power } k \ n &\equiv_{\text{df}} (\text{power } k \ (\text{div}(n, 2)))^2 \times k^{\text{mod}(n, 2)}
  \end{align*}
  $$

- **解释：**

  - **递归调用：** $\text{power } k \ (\text{div}(n, 2))$，即使用 $n$ 的一半（向下取整）处的值。
  - **$k$ 的作用：** 注意在递归调用中，参数 $k$ 保持不变，$k$ 仅作为参数，不在递归过程中改变。
  - **偶数和奇数的处理：**
    - 当 $n$ 为偶数时，$\text{mod}(n, 2) = 0$，$k^{0} = 1$。
    - 当 $n$ 为奇数时，$\text{mod}(n, 2) = 1$，$k^{1} = k$。

---

#### **值域递归 (Course-of-Values Recursion)**

##### **解释：**

- **概念：** 值域递归是一种一般化的递归形式，$f(n + 1)$ 的定义可以依赖于 $f$ 在 $0$ 到 $n$ 之间所有值。
- **方法：**

  - **替换传统递归定义：**

    $$
    \begin{align*}
    f(0) &\equiv_{\text{df}} a \\
    f(n + 1) &\equiv_{\text{df}} \dots f(0) \dots f(1) \dots f(n) \dots
    \end{align*}
    $$

  - **定义新的函数 $g$：**

    $$
    g(n) \equiv_{\text{df}} [f(0), f(1), \dots, f(n)]
    $$

    - **解释：** $g(n)$ 是一个列表，包含 $f$ 在 $0$ 到 $n$ 之间所有值。

  - **定义 $g(n + 1)$：**

    - 通过使用 $g(n)$，从列表中构造 $f(n + 1)$，然后将其附加到列表末尾。

  - **获取 $f(n)$：**

    - 通过取列表 $g(n)$ 的最后一个值。

##### **在类型理论中的实现：**

- 我们将在研究列表后，展示如何在类型理论中实现这种形式的定义。

---

#### **练习 6.1**

**问题：**

展示如何在自然数上定义“自然减法”操作：

$$
\text{natsub } m \ n \equiv_{\text{df}} \max(0, m - n)
$$

其中 $m - n$ 表示整数减法。

**提示：**

- 需要定义一个函数，当 $m \geq n$ 时，返回 $m - n$；否则，返回 $0$。
- 可以使用自然数的递归定义来实现这个函数。

---

#### **练习 6.2**

**问题：**

在第 5.3 节中，我们给出了整数类型的定义。你如何在那种定义方式下，定义整数的加法、减法和乘法运算？

**提示：**

- 需要考虑整数的表示方式（可能是差对 (difference pair) 或者其他方式）。
- 定义相应的运算，需要处理正负数的情况。

---

### **6.1.2 通过递归定义命题和类型 (Defining Propositions and Types by Recursion)**

#### **使用宇宙 (Universes) 进行定义**

##### **解释：**

- **宇宙 $U_0, U_1, \dots$：** 是类型的类型，允许我们在类型层次上进行操作。
- **目的：** 我们可以使用宇宙通过递归来定义参数化的类型或命题。

---

#### **示例：自然数上的“非零”谓词**

##### **方法一：使用等式关系**

- **定义：**

  $$
  \text{nonzero } n \equiv_{\text{df}} \neg (n =_{\mathbb{N}} 0)
  $$

- **解释：**

  - **当 $n = 0$ 时：**
    - 类型为 $\neg (0 =_{\mathbb{N}} 0)$，即 $(0 =_{\mathbb{N}} 0) \rightarrow \bot$。
    - 由于 $0 =_{\mathbb{N}} 0$ 是可证明的，因此该类型等价于 $\bot$。
  - **当 $n \neq 0$ 时：**
    - 类型为 $\neg (n =_{\mathbb{N}} 0)$，无法从 $n =_{\mathbb{N}} 0$ 中推出矛盾，因此该类型是可居留的。

- **结果：**

  - 当 $n = 0$ 时，$\text{nonzero } 0$ 等价于 $\bot$。
  - 当 $n \neq 0$ 时，$\text{nonzero } n$ 是可居留的。

- **依赖于布尔值的区别：**

  - 这取决于一个公理，断言两个布尔值是不同的：

    $$
    \text{ax} : \neg (\text{True} =_{\text{bool}} \text{False})
    $$

  - 该公理在第 4 章中引入。

---

##### **方法二：直接定义**

- **定义：**

  $$
  \begin{align*}
  \text{nz } 0 &\equiv_{\text{df}} \bot \\
  \text{nz } (n + 1) &\equiv_{\text{df}} \top
  \end{align*}
  $$

- **解释：**

  - **当 $n = 0$ 时：** $\text{nz } 0 = \bot$。
  - **当 $n \geq 1$ 时：** $\text{nz } (n + 1) = \top$。

- **证明对象：**

  - **$n = 0$ 时：** 无法构造证明对象。
  - **$n \geq 1$ 时：** 证明对象为 $\text{Triv}$，即平凡证明。

---

#### **非空列表的谓词**

##### **定义：**

- **非空列表的谓词 $\text{nonempty}$：**

  $$
  \begin{align*}
  \text{nonempty} : [A] \rightarrow U_0 \\
  \text{nonempty } [\ ] &\equiv_{\text{df}} \bot \\
  \text{nonempty } (a :: x) &\equiv_{\text{df}} \top
  \end{align*}
  $$

- **解释：**

  - **空列表 $[\ ]$：** $\text{nonempty } [\ ] = \bot$。
  - **非空列表 $(a :: x)$：** $\text{nonempty } (a :: x) = \top$。

---

#### **定义非空列表的类型**

##### **定义：**

- **非空列表的类型 $\text{nelist } A$：**

  $$
  \text{nelist } A \equiv_{\text{df}} (\exists l : [A]).\ (\text{nonempty } l)
  $$

- **解释：**

  - 这是一个依赖类型，包含一个列表 $l : [A]$，以及一个证明 $p : \text{nonempty } l$。
  - **元素形式：** 对于元素 $(l, p)$，当 $l$ 为非空列表时，$p = \text{Triv}$；当 $l$ 为空列表时，$p$ 为 $\bot$ 的证明，即不存在。

---

#### **总结：**

- **直接定义的优势：** 通过直接定义谓词，我们可以更简洁地表达性质。
- **证明对象的使用：** 在类型理论中，证明对象可以作为函数计算的一部分，确保类型的正确性。

---

#### **使用递归定义“小于”关系**

##### **目标：**

- 定义自然数上的“小于”关系 $<$。

##### **直观理解：**

- **规则：**
  - **没有数小于 $0$。**
  - **$0$ 小于任何 $n + 1$。**
  - **如果 $m$ 小于 $n$，那么 $m + 1$ 小于 $n + 1$。**

##### **两种可能的表示方法：**

1. **定义布尔函数 $lt1$：**

   $$
   \begin{align*}
   lt1 : \mathbb{N} \rightarrow \mathbb{N} \rightarrow \text{bool} \\
   lt1 \ m \ 0 &\equiv_{\text{df}} \text{False} \\
   lt1 \ 0 \ (n + 1) &\equiv_{\text{df}} \text{True} \\
   lt1 \ (m + 1) \ (n + 1) &\equiv_{\text{df}} lt1 \ m \ n
   \end{align*}
   $$

   - **解释：** 通过递归定义布尔函数，判断 $m$ 是否小于 $n$。

   - **命题形式：**

     - 断言 $m < n$ 可以表示为：

       $$
       I(\text{bool}, lt1 \ m \ n, \text{True})
       $$

     - 即 $lt1 \ m \ n$ 等于 $\text{True}$。

2. **直接定义为命题 $lt2$：**

   $$
   \begin{align*}
   lt2 : \mathbb{N} \rightarrow \mathbb{N} \rightarrow U_0 \\
   lt2 \ m \ 0 &\equiv_{\text{df}} \bot \\
   lt2 \ 0 \ (n + 1) &\equiv_{\text{df}} \top \\
   lt2 \ (m + 1) \ (n + 1) &\equiv_{\text{df}} lt2 \ m \ n
   \end{align*}
   $$

   - **解释：** 直接将 $m < n$ 定义为一个命题类型。

##### **选择：**

- 在后续内容中，我们将使用第二种定义，即 $lt \equiv_{\text{df}} lt2$，并将 $lt \ m \ n$ 写作 $m < n$。

##### **注意：**

- 在这两种情况下，我们需要同时对第一个参数的所有值进行定义。

---

#### **练习 6.3**

**问题：**

证明，给定断言布尔值是不同的公理，即：

$$
\text{ax} : \neg (\text{True} =_{\text{bool}} \text{False})
$$

命题

$$
(\forall x : \mathbb{N}).\ ((x =_{\mathbb{N}} 0) \lor \neg (x =_{\mathbb{N}} 0))
$$

是可居留的。

**提示：**

- 需要构造一个证明对象，证明对于任意 $x$，要么 $x = 0$，要么 $x \neq 0$。

---

#### **练习 6.4**

**问题：**

证明对于所有自然数 $n$ 和 $m$，命题 $lt1 \ m \ n$ 和 $lt2 \ m \ n$ 是等价的。

**提示：**

- 需要证明对于任意 $m$ 和 $n$，$lt1 \ m \ n = \text{True}$ 当且仅当 $lt2 \ m \ n$ 是可居留的。

---

#### **练习 6.5**

**问题：**

你将如何类似地定义“小于或等于”关系？

**提示：**

- 可以参考前面的定义，添加相应的基准情况和递归步骤。

---

#### **练习 6.6**

**问题：**

给出迭代笛卡尔积运算符的递归定义，该运算符将类型 $A$ 和自然数 $n$ 映射到如下的乘积：

$$
A \times (A \times \dots (A \times A) \dots )
$$

其中有 $n$ 个 $A$，并且定义零个 $A$ 的乘积为 $\top$。你将如何在这些类型上定义投影操作？

**提示：**

- 可以使用递归定义乘积类型，并相应地定义投影函数。

---

### **6.1.3 列表上的递归 – 1 (Recursion over Lists – 1)**

#### **列表的引入**

- **背景：** 列表在第 5.10 节中作为一个良基类型 (well-founded type) 的示例被引入，具有递归/归纳运算符 $lrec$。

#### **常见的列表操作函数**

- 我们将在本节讨论一些常见的列表操作函数。

---

#### **问题：对空列表的处理**

- **挑战：** 对于非空列表 $(a :: x)$，我们可以轻松地定义其头部 (head) 和尾部 (tail)。
- **难点：** 空列表 $[\ ]$ 没有头部或尾部，我们该如何定义返回这些值的函数？

---

#### **解决方案**

我们提出了以下解决方案，这些方法可以应用于许多表面上部分定义的函数。

---

##### **1. 提供额外的参数**

- **思路：** 向函数提供一个额外的参数，当列表参数为空时，返回该值。

- **示例：**

  - **head1 函数：**

    $$
    \begin{align*}
    \text{head1} : A \rightarrow [A] \rightarrow A \\
    \text{head1 } h \ [\ ] &\equiv_{\text{df}} h \\
    \text{head1 } h \ (a :: x) &\equiv_{\text{df}} a
    \end{align*}
    $$

    - **解释：** 当列表为空时，返回默认值 $h$；当列表非空时，返回其头部 $a$。

  - **tail1 函数：**

    $$
    \begin{align*}
    \text{tail1} : [A] \rightarrow [A] \\
    \text{tail1 } [\ ] &\equiv_{\text{df}} [\ ] \\
    \text{tail1 } (a :: x) &\equiv_{\text{df}} x
    \end{align*}
    $$

    - **解释：** 当列表为空时，返回空列表；当列表非空时，返回其尾部 $x$。

---

##### **2. 使用和类型 (Sum Type)**

- **思路：** 将函数的结果类型定义为一个和类型，表示可能的错误。

- **定义错误类型：**

  - **错误类型：**

    $$
    \text{error } A \equiv_{\text{df}} \text{ok } A + \text{err } \top
    $$

    - **解释：**
      - $\text{ok } A$：表示成功的结果，类型为 $A$。
      - $\text{err } \top$：表示错误，$\top$ 是平凡类型。

  - **简化记号：** 将 $\text{err } \text{Triv}$ 简写为 $\text{error}$。

- **示例：**

  - **head2 函数：**

    $$
    \begin{align*}
    \text{head2} : [A] \rightarrow \text{error } A \\
    \text{head2 } [\ ] &\equiv_{\text{df}} \text{error} \\
    \text{head2 } (a :: x) &\equiv_{\text{df}} \text{ok } a
    \end{align*}
    $$

  - **tail2 函数：**

    $$
    \begin{align*}
    \text{tail2} : [A] \rightarrow \text{error } [A] \\
    \text{tail2 } [\ ] &\equiv_{\text{df}} \text{error} \\
    \text{tail2 } (a :: x) &\equiv_{\text{df}} \text{ok } x
    \end{align*}
    $$

---

##### **3. 限制函数的定义域**

- **思路：** 不扩大函数的值域，而是限制其定义域，即只对非空列表定义函数。

- **定义非空列表类型：**

  $$
  \text{nelist } A \equiv_{\text{df}} (\exists l : [A]).\ (\text{nonempty } l)
  $$

  - **解释：** 这是一个依赖类型，包含一个列表 $l$ 和一个证明 $p : \text{nonempty } l$。

- **head3 函数：**

  $$
  \text{head3} : \text{nelist } A \rightarrow A
  $$

- **定义过程：**

  - **给定：** $(l, r)$，其中 $l$ 是列表，$r : \text{nonempty } l$。

  - **情况分析：**

    - **当 $l = (a :: x)$ 时：** 直接返回 $a$。

    - **当 $l = [\ ]$ 时：**

      - 有 $\text{nonempty } l \equiv_{\text{df}} \bot$。

      - 因此，$r : \bot$。

      - 使用 $\text{abort}_A \ r : A$，从矛盾中导出任意类型的元素。

- **类似地，可以定义 tail3 函数：**

  $$
  \text{tail3} : \text{nelist } A \rightarrow [A]
  $$

---

##### **4. 定义具有依赖类型的函数**

- **定义：**

  $$
  \begin{align*}
  \text{head4} &: (\forall l : [A]).\ (\text{ne } l \rightarrow A) \\
  \text{tail4} &: (\forall l : [A]).\ (\text{ne } l \rightarrow [A])
  \end{align*}
  $$

  - **解释：** 对于所有列表 $l$，如果有 $l$ 非空的证明 $\text{ne } l$，则可以返回其头部或尾部。

- **性质：**

  - 这些类型与 $\text{head3}$ 和 $\text{tail3}$ 的类型在扩展上是同构的，这在第 4.6.1 节中已证明。

---

#### **选择定义的方法的影响**

- 无论选择哪种定义方法，我们都需要在证明理论上证明参数是非空的。

- **如果参数为空列表，可能发生的情况：**

  - **使用 head1：** 可能返回默认值。

  - **使用 head2：** 可能返回 $\text{error}$ 而非 $\text{ok}$ 值。

  - **使用 head3：** 需要一个列表非空的证明，才能应用函数。

---

#### **我们的选择**

- 在后续内容中，我们将使用第三种定义，即：

  $$
  \text{hd} \equiv_{\text{df}} \text{head3} \\
  \text{tl} \equiv_{\text{df}} \text{tail3}
  $$

- 我们将把返回非空列表最后一个元素的函数 $\text{last} : \text{nelist } A \rightarrow A$ 留作练习。

---

#### **其他标准函数**

- **列表长度函数**（通常写作 $\#$）：

  $$
  \begin{align*}
  \# [\ ] &\equiv_{\text{df}} 0 \\
  \# (a :: x) &\equiv_{\text{df}} \# x + 1
  \end{align*}
  $$

- **列表连接函数**（记作 $++$）：

  $$
  \begin{align*}
  [\ ] ++ y &\equiv_{\text{df}} y \\
  (a :: x) ++ y &\equiv_{\text{df}} a :: (x ++ y)
  \end{align*}
  $$

- **说明：** 这些函数可以轻松地使用 $lrec$ 形式定义。

---

#### **从列表中提取元素的函数**

- **目标：** 定义一个函数，从列表中提取某个位置的元素。

- **定义：**

  - **非正式定义：**

    $$
    [a_0, a_1, \dots, a_{n-1}] ! m \equiv_{\text{df}} a_m
    $$

- **处理索引越界的情况：**

  - **选项：**

    - 返回默认值。

    - 对于非空列表，返回最后一个值。

  - **更好的方法：**

    - **限制函数的类型，防止“越界”索引。**

- **定义函数的类型：**

  - 给定列表 $l$，允许的索引是小于 $\# l$ 的那些自然数。

- **在下一小节中，我们将探讨各种选项。**

---

#### **练习 6.7**

**问题：**

给出上一节中提到的函数 $\text{last}$ 的定义。

**提示：**

- $\text{last}$ 接受一个非空列表，返回其最后一个元素。

- 可以使用递归或模式匹配进行定义。

---

#### **练习 6.8**

**问题：**

给出函数 $\text{head4} : (\forall l : [A]).\ (\text{ne } l \rightarrow A)$ 的显式定义。

**提示：**

- 使用情况分析，根据列表是否为空，处理不同的情况。

---

#### **练习 6.9**

**问题：**

以类似于 $[A]$ 的方式定义非空列表的类型。为该类型制定构造、引入、消解和计算规则，并为该类型定义 $\text{head}$、$\text{last}$ 和 $\text{tail}$ 函数。

**提示：**

- 可以定义一个新的数据类型，例如：

  $$
  \begin{align*}
  \text{NonEmptyList } A ::= a :: [A]
  \end{align*}
  $$

- 制定相应的类型规则和函数定义。

---

#### **练习 6.10**

**问题：**

为非空列表的类型制定索引函数“!”的一个版本，如果索引“越界”，则返回列表的最后一个元素作为默认值。

**提示：**

- 需要处理索引大于列表长度的情况。

- 可以使用条件判断或限制索引的类型。

---

### **6.1.4 列表上的递归 – 2 (Recursion over Lists – 2)**

#### **列表索引函数**

- **目标：** 定义列表的索引函数 $\text{index}$，能够在类型层面上防止索引越界。

---

#### **定义**

- **类型：**

  $$
  \text{index} : (\forall l : [A]).\ (\forall n : \mathbb{N}).\ ((n < \# l) \rightarrow A)
  $$

- **解释：**

  - 给定列表 $l$，自然数 $n$，以及一个证明 $p$，证明 $n$ 小于 $\# l$，返回列表中第 $n$ 个元素。

---

#### **函数定义**

1. **基准情况：**

   $$
   \text{index } [\ ] \ n \ p \equiv_{\text{df}} \text{abort}_A \ p
   $$

   - **解释：**

     - 当列表为空时，我们有 $n < 0$，这不可能，因此 $p : \bot$。

     - 使用 $\text{abort}_A \ p$，从矛盾中导出 $A$ 的元素。

2. **当 $n = 0$ 时：**

   $$
   \text{index } (a :: x) \ 0 \ p \equiv_{\text{df}} a
   $$

   - **解释：** 返回列表的头部 $a$。

3. **当 $n > 0$ 时：**

   $$
   \text{index } (a :: x) \ (n + 1) \ p \equiv_{\text{df}} \text{index } x \ n \ p'
   $$

   - **其中：**

     - $p'$ 是从 $p$ 推导出的 $n < \# x$ 的证明。

     - 由于 $\# (a :: x) = \# x + 1$，并且 $n + 1 < \# x + 1$，因此 $n < \# x$。

---

#### **观察**

- **递归方式：**

  - 该定义可以通过对自然数 $n$ 进行归纳，或者对列表 $l$ 进行归纳，两者是独立的。

- **参数独立性：**

  - 函数的两个参数 $l$ 和 $n$ 是相互独立的，可以分别进行归纳。

---

#### **回到值域递归的示例**

- **目标：** 利用已定义的辅助函数，实现之前讨论的幂函数的特殊情况。

---

#### **幂函数的特殊情况**

- **定义：**

  $$
  \begin{align*}
  \text{pow } 0 &\equiv_{\text{df}} 1 \\
  \text{pow } n &\equiv_{\text{df}} (\text{pow } (\text{div}(n, 2)))^2 \times 2^{\text{mod}(n, 2)}
  \end{align*}
  $$

- **重写：**

  - 引入一个原始递归函数 $h$：

    $$
    \begin{align*}
    \text{pow } 0 &\equiv_{\text{df}} 1 \\
    \text{pow } (n + 1) &\equiv_{\text{df}} h \ (\text{pow } \ (\text{div}(n + 1, 2))) \ n
    \end{align*}
    $$

---

#### **转换为列表定义**

- **定义函数 $g$：**

  $$
  \begin{align*}
  g(0) &\equiv_{\text{df}} [1] \\
  g(n + 1) &\equiv_{\text{df}} g(n) ++ [h \ (g(n) ! (\text{div}(n + 1, 2))) \ n]
  \end{align*}
  $$

- **解释：**

  - $g(n)$ 是一个列表，包含 $\text{pow}$ 在 $0$ 到 $n$ 之间的所有值。

  - 使用 $g(n)$ 来计算 $g(n + 1)$。

- **索引的合法性：**

  - 我们需要证明索引 $\text{div}(n + 1, 2) < \# g(n)$。

  - 这需要以下证明：

    1. 对于 $m > 0$，有 $\text{div}(m, 2) < m$。

    2. $\# g(n) = n + 1$，需要同时在定义中通过归纳进行证明。

---

#### **提取结果**

- **获取 $\text{pow } n$ 的值：**

  - 从 $g(n)$ 中提取最后一个元素，即 $f(n)$。

- **需要证明列表非空：**

  - 由于 $\# g(n) = n + 1$，因此 $g(n)$ 的长度为正，不会为空。

---

#### **总结**

- **系统的特点：**

  - 在类型理论中，函数的定义与其终止性的证明是密不可分的。

- **替代方法：**

  - 如果采用返回默认值或错误值的方法，可以避免上述复杂的推导，但之后需要证明返回的值是正确的，而非错误或默认值。

---

#### **练习 6.11**

**问题：**

使用对 $m : \mathbb{N}$ 的归纳，证明对于所有 $m > 0$，有 $\text{div}(m, 2) < m$。

**提示：**

- 考虑 $m$ 的奇偶性，分别进行归纳证明。

---

#### **练习 6.12**

**问题：**

形式化推导上述函数 $g$ 和 $\text{pow}$ 的过程。

**提示：**

- 需要在类型理论中给出完整的定义和证明。

---

#### **练习 6.13**

**问题：**

证明对于所有列表 $l$ 和 $m$，有：

$$
\# l + \# m = \# (l ++ m)
$$

**提示：**

- 使用对列表的归纳，分别考虑空列表和非空列表的情况。

---

#### **练习 6.14**

**问题：**

考虑以下“俄罗斯乘法”的定义：

$$
\begin{align*}
\text{mul } a \ 0 &\equiv_{\text{df}} 0 \\
\text{mul } a \ b &\equiv_{\text{df}} \text{mul } (2 \times a) \ (\text{div}(b, 2)) + a \times \text{mod}(b, 2)
\end{align*}
$$

你将如何论证它可以在类型理论中定义？

**提示：**

- 需要确保递归调用的参数在某种意义上减小，保证函数的终止性。

---

#### **练习 6.15**

**问题：**

展示如何将以下非正式定义的函数在类型理论中给出定义：

1. **合并排序的合并函数 $\text{merge}$：**

   $$
   \begin{align*}
   \text{merge} : [\mathbb{N}] \rightarrow [\mathbb{N}] \rightarrow [\mathbb{N}] \\
   \text{merge } [\ ] \ y &\equiv_{\text{df}} y \\
   \text{merge } (a :: x) \ [\ ] &\equiv_{\text{df}} (a :: x) \\
   \text{merge } (a :: x) \ (b :: y) &\equiv_{\text{df}} \begin{cases}
   a :: \text{merge } x \ (b :: y), & \text{if } \text{less } a \ b \\
   b :: \text{merge } (a :: x) \ y, & \text{otherwise}
   \end{cases}
   \end{align*}
   $$

2. **左折叠函数 $\text{foldl}$：**

   $$
   \begin{align*}
   \text{foldl} : (A \rightarrow B \rightarrow A) \rightarrow A \rightarrow [B] \rightarrow A \\
   \text{foldl } f \ a \ [\ ] &\equiv_{\text{df}} a \\
   \text{foldl } f \ a \ (b :: y) &\equiv_{\text{df}} \text{foldl } f \ (f \ a \ b) \ y
   \end{align*}
   $$

**提示：**

- 对于 $\text{merge}$，需要定义一个比较函数 $\text{less}$，并处理不同的情况。

- 对于 $\text{foldl}$，可以直接使用对列表的归纳定义。

---

### **总结**

通过本节的学习，我们深入了解了类型理论中递归的使用方式，包括对自然数和列表的递归定义。我们看到了如何在强规范化的约束下，使用原始递归和值域递归来定义函数，以及如何通过限制函数的定义域或结果类型，来处理部分定义的函数。

类型理论的强大之处在于其类型系统的表达能力，使我们能够精确地描述函数的行为，并在类型层面上进行验证。这种将计算和验证相结合的特性，为构建安全可靠的程序提供了坚实的基础。

如果您对上述内容有任何疑问，或者希望进一步深入了解某个主题，请随时告诉我！

### ----------------------------

### **6.2 案例研究 – 快速排序 (A Case Study – Quicksort)**

#### **概述：**

本节将探讨对数值列表进行排序的通用方法，并对这些列表上的快速排序 (quicksort) 函数进行完整的开发和验证。在开发过程中，我们将有机会定义其他有用的函数，并讨论一般定理的证明。

---

### **6.2.1 函数的定义 (Defining the Function)**

#### **快速排序的定义**

##### **在函数式语言中的定义**

在类似于 Miranda 的函数式语言中，快速排序函数可以定义如下：

$$
\begin{align*}
\text{qsort} &: [\mathbb{N}] \rightarrow [\mathbb{N}] \\
\text{qsort } [\ ] &\equiv_{\text{df}} [\ ] \\
\text{qsort } (a :: x) &\equiv_{\text{df}} \text{qsort } (\text{filter } (\text{lesseq } a) \ x) \\
&\quad ++ [a] ++ \\
&\quad \text{qsort } (\text{filter } (\text{greater } a) \ x)
\end{align*}
$$

- **解释：**
  - **基准情况：** 当列表为空时，返回空列表。
  - **递归步骤：**
    - 选择列表的第一个元素 $a$ 作为基准 (pivot)。
    - 使用函数 $\text{filter}$ 筛选出列表 $x$ 中小于或等于 $a$ 的元素，递归地对其进行排序。
    - 使用 $\text{filter}$ 筛选出列表 $x$ 中大于 $a$ 的元素，递归地对其进行排序。
    - 将排序后的左子列表、基准元素 $[a]$、排序后的右子列表连接起来，得到最终的排序结果。

---

#### **辅助函数的定义**

##### **过滤函数 $\text{filter}$**

- **类型定义：**

  $$
  \begin{align*}
  \text{filter} &: (A \rightarrow \text{bool}) \rightarrow [A] \rightarrow [A] \\
  \end{align*}
  $$

- **函数定义：**

  $$
  \begin{align*}
  \text{filter } p \ [\ ] &\equiv_{\text{df}} [\ ] \\
  \text{filter } p \ (a :: x) &\equiv_{\text{df}} \begin{cases}
  a :: (\text{filter } p \ x), & \text{if } (p \ a) = \text{True} \\
  \text{filter } p \ x, & \text{if } (p \ a) = \text{False}
  \end{cases}
  \end{align*}
  $$

- **解释：**
  - **基准情况：** 当列表为空时，返回空列表。
  - **递归步骤：** 对于非空列表 $(a :: x)$，如果 $p \ a$ 为真，则将 $a$ 加入结果列表；否则，跳过 $a$。

##### **比较函数 $\text{lesseq}$ 和 $\text{greater}$**

- **$\text{lesseq}$ 函数：**

  - **类型定义：**

    $$
    \text{lesseq} : \mathbb{N} \rightarrow \mathbb{N} \rightarrow \text{bool}
    $$

  - **函数定义：**

    $$
    \begin{align*}
    \text{lesseq } 0 \ x &\equiv_{\text{df}} \text{True} \\
    \text{lesseq } (n + 1) \ 0 &\equiv_{\text{df}} \text{False} \\
    \text{lesseq } (n + 1) \ (m + 1) &\equiv_{\text{df}} \text{lesseq } n \ m
    \end{align*}
    $$

  - **解释：**
    - **基准情况：**
      - $0 \leq x$ 始终为真。
      - $(n + 1) \leq 0$ 始终为假。
    - **递归步骤：** 通过递归比较前一个数。

- **$\text{greater}$ 函数：**

  - 类似地，可以定义 $\text{greater}$ 函数，表示“大于”关系。

---

#### **在类型理论中的快速排序定义**

##### **关键观察**

- 在递归调用中，所处理的列表的长度小于原列表的长度。因此，递归是通过对自然数 $\mathbb{N}$ 上的值域递归 (course-of-values recursion) 来证明是合法的。

##### **修改快速排序的定义**

- 定义一个具有三个参数的函数：
  1. **自然数 $n$**：表示列表的最大长度。
  2. **待排序的列表 $l$**。
  3. **一个证明 $p$**：证明 $\# l \leq n$。

- **函数类型：**

  $$
  \text{qsort0} : (\forall n : \mathbb{N}).\ (\forall l : [\mathbb{N}]).\ (\# l \leq n) \rightarrow [\mathbb{N}]
  $$

- **函数定义：**

  $$
  \begin{align*}
  \text{qsort0 } n \ [\ ] \ p &\equiv_{\text{df}} [\ ] \\
  \text{qsort0 } 0 \ (a :: x) \ p &\equiv_{\text{df}} \text{abort}_{[\mathbb{N}]} \ p' \\
  \text{qsort0 } (n + 1) \ (a :: x) \ p &\equiv_{\text{df}} \text{qsort0 } n \ (\text{filter } (\text{lesseq } a) \ x) \ p_1 \\
  &\quad ++ [a] ++ \\
  &\quad \text{qsort0 } n \ (\text{filter } (\text{greater } a) \ x) \ p_2
  \end{align*}
  $$

- **解释：**
  - **基准情况 1：** 当列表为空时，返回空列表。
  - **基准情况 2：** 当 $n = 0$ 且列表非空时，根据证明 $p$，可以得出矛盾，从而可以从矛盾中导出任意类型的值。
  - **递归步骤：** 对于非空列表 $(a :: x)$，并且 $n \geq 0$，对左、右子列表递归调用 $\text{qsort0}$，$n$ 减一。

##### **证明对象 $p'$、$p_1$、$p_2$**

- **$p'$：** 当 $n = 0$ 且列表非空时，$\# (a :: x) \leq 0$，这显然不可能。因此，$p$ 是一个 $\bot$ 的证明，我们可以使用 $\text{abort}_{[\mathbb{N}]} \ p'$ 来从矛盾中导出列表。

- **$p_1$ 和 $p_2$：** 需要证明递归调用中的列表长度满足 $\# (\text{filter } (\text{lesseq } a) \ x) \leq n$ 和 $\# (\text{filter } (\text{greater } a) \ x) \leq n$。

---

#### **证明辅助结果**

##### **引理 6.1**

**对于所有列表 $x$ 和性质 $p$，有：**

$$
\# (\text{filter } p \ x) \leq \# x
$$

- **证明：** 对列表 $x$ 进行归纳证明。

  - **基准情况：** 当 $x = [\ ]$ 时，$\# (\text{filter } p \ [\ ]) = 0$，显然成立。

  - **递归步骤：** 假设对于列表 $x$，命题成立，考虑列表 $(a :: x)$：

    - 如果 $p \ a = \text{True}$，则：

      $$
      \# (\text{filter } p \ (a :: x)) = 1 + \# (\text{filter } p \ x)
      $$

    - 如果 $p \ a = \text{False}$，则：

      $$
      \# (\text{filter } p \ (a :: x)) = \# (\text{filter } p \ x)
      $$

    - 无论哪种情况，都有：

      $$
      \# (\text{filter } p \ (a :: x)) \leq 1 + \# (\text{filter } p \ x) \leq 1 + \# x = \# (a :: x)
      $$

- **结论：** 引理成立。

---

##### **证明 $p_1$ 和 $p_2$ 的存在性**

- **目标：** 利用引理 6.1 和 $\# (a :: x) \leq n + 1$，证明：

  $$
  \# (\text{filter } (\text{lesseq } a) \ x) \leq n \\
  \# (\text{filter } (\text{greater } a) \ x) \leq n
  $$

- **步骤：**

  1. 由于 $\# (a :: x) = \# x + 1$，并且有 $p : \# (a :: x) \leq n + 1$，所以有 $\# x \leq n$。

  2. 根据引理 6.1，$\# (\text{filter } p \ x) \leq \# x$，因此：

     $$
     \# (\text{filter } (\text{lesseq } a) \ x) \leq \# x \leq n \\
     \# (\text{filter } (\text{greater } a) \ x) \leq \# x \leq n
     $$

- **因此，证明对象 $p_1$ 和 $p_2$ 存在。**

---

#### **快速排序函数的最终定义**

- **定义：**

  $$
  \text{qsort } l \equiv_{\text{df}} \text{qsort0 } (\# l) \ l \ \text{Triv}
  $$

- **解释：**

  - **$\text{Triv}$** 是一个平凡的证明，证明 $\# l \leq \# l$。

- **因此，$\text{qsort}$ 是 $\text{qsort0}$ 的特例，使用列表自身的长度作为最大长度参数。**

---

### **6.2.2 函数的验证 (Verifying the Function)**

#### **规范的制定**

在实现了快速排序算法之后，我们需要明确其目的。我们期望该算法：

1. **返回一个已排序的结果。**
2. **返回的结果是其参数的一个排列。**

---

#### **定义排序和排列**

##### **排序的定义**

- **一个列表是已排序的，当且仅当对于列表中的每一对元素，左边的元素小于或等于右边的元素。**

- **形式化定义：**

  $$
  \begin{align*}
  \text{sorted} &: [\mathbb{N}] \rightarrow U_0 \\
  \text{sorted } [\ ] &\equiv_{\text{df}} \top \\
  \text{sorted } [a] &\equiv_{\text{df}} \top \\
  \text{sorted } (a :: b :: x) &\equiv_{\text{df}} (a \leq b) \land \text{sorted } (b :: x)
  \end{align*}
  $$

- **解释：**
  - 空列表和只有一个元素的列表都是已排序的。
  - 对于有两个或以上元素的列表，若第一个元素小于或等于第二个元素，且剩余的列表已排序，则整个列表已排序。

##### **排列的定义**

- **列表 $l$ 是列表 $l'$ 的一个排列，当且仅当对于任何可能的元素 $a$，$a$ 在 $l$ 和 $l'$ 中出现的次数相同。**

- **形式化定义：**

  $$
  \text{perm } l \ l' \equiv_{\text{df}} (\forall a : \mathbb{N}).\ (\text{occs } a \ l =_{\mathbb{N}} \text{occs } a \ l')
  $$

- **其中，$\text{occs } a \ l$ 表示元素 $a$ 在列表 $l$ 中出现的次数。**

---

##### **计数函数 $\text{occs}$**

- **类型定义：**

  $$
  \text{occs } : \mathbb{N} \rightarrow [\mathbb{N}] \rightarrow \mathbb{N}
  $$

- **函数定义：**

  $$
  \begin{align*}
  \text{occs } a \ [\ ] &\equiv_{\text{df}} 0 \\
  \text{occs } a \ (b :: x) &\equiv_{\text{df}} \begin{cases}
  1 + \text{occs } a \ x, & \text{if } a = b \\
  \text{occs } a \ x, & \text{if } a \neq b
  \end{cases}
  \end{align*}
  $$

- **解释：**
  - 当列表为空时，$a$ 出现的次数为 $0$。
  - 对于非空列表，如果当前元素等于 $a$，则出现次数加 $1$；否则，不变。

---

##### **成员关系 $\text{mem}$**

- **类型定义：**

  $$
  \begin{align*}
  \text{mem} &: \mathbb{N} \rightarrow [\mathbb{N}] \rightarrow U_0 \\
  \end{align*}
  $$

- **函数定义：**

  $$
  \begin{align*}
  \text{mem } a \ [\ ] &\equiv_{\text{df}} \bot \\
  \text{mem } a \ (b :: x) &\equiv_{\text{df}} (a =_{\mathbb{N}} b) \lor (\text{mem } a \ x)
  \end{align*}
  $$

- **解释：**
  - 当列表为空时，$a$ 不在列表中。
  - 对于非空列表，如果当前元素等于 $a$，则 $a$ 在列表中；否则，递归检查剩余的列表。

---

#### **基本性质的引理**

##### **引理 6.2**

**以下命题是可居留的：**

1. $(\forall x, y : \mathbb{N}).\ (\text{lesseq } x \ y = \text{True} \Rightarrow x \leq y)$

2. $(\forall x, y : \mathbb{N}).\ (\text{lesseq } x \ y = \text{True} \lor \text{greater } x \ y = \text{True})$

3. $(\forall x, y : \mathbb{N}).\ \neg (\text{lesseq } x \ y = \text{True} \land \text{greater } x \ y = \text{True})$

4. $(\forall p : \mathbb{N} \rightarrow \text{bool}).\ (\forall l : [\mathbb{N}]).\ (\forall x : \mathbb{N}).\ (\text{mem } x \ (\text{filter } p \ l) \Rightarrow p \ x = \text{True})$

5. $(\forall l : [\mathbb{N}]).\ (\forall a, x : \mathbb{N}).\ (\text{mem } x \ (\text{filter } (\text{lesseq } a) \ l) \Rightarrow x \leq a)$

6. $(\forall x : \mathbb{N}).\ (\forall l : [\mathbb{N}]).\ (\text{mem } x \ l \Leftrightarrow \text{occs } x \ l > 0)$

7. $(\forall l, l' : [\mathbb{N}]).\ (\text{perm } l \ l' \Rightarrow (\forall x : \mathbb{N}).\ (\text{mem } x \ l \Leftrightarrow \text{mem } x \ l'))$

8. $(\forall a : \mathbb{N}).\ (\forall l, m : [\mathbb{N}]).\ (\text{occs } a \ (l ++ m) =_{\mathbb{N}} \text{occs } a \ l + \text{occs } a \ m)$

9. $(\forall l, m, x : [\mathbb{N}]).\ (\forall a : \mathbb{N}).\ (\text{perm } (l ++ m) \ x \Rightarrow \text{perm } (l ++ [a] ++ m) \ (a :: x))$

10. $(\forall l, l', m, m' : [\mathbb{N}]).\ (\text{perm } l \ l' \land \text{perm } m \ m' \Rightarrow \text{perm } (l ++ m) \ (l' ++ m'))$

11. $(\forall l : [\mathbb{N}]).\ (\forall a : \mathbb{N}).\ \text{perm } l \ (\text{filter } (\text{lesseq } a) \ l ++ \text{filter } (\text{greater } a) \ l)$

12. **$\text{perm}$ 是一个等价关系。**

- **证明：**

  - **结果 1-3：** 通过对自然数 $\mathbb{N}$ 进行归纳证明。

  - **结果 4、6：** 对列表 $l$ 进行归纳证明。

  - **结果 5：** 由结果 1 和 4 的推论。

  - **结果 7：** 由结果 6 的推论。

  - **结果 8-10：** 对列表 $l$ 进行归纳证明。

  - **结果 11：** 由结果 2、3 和 8 得出。

  - **结果 12：** 由排列的定义，可直接得出。

---

#### **关键引理**

##### **引理 6.3**

**以下命题是可居留的：**

$$
\begin{align*}
(\forall l, m : [\mathbb{N}]).\ (\text{sorted } l \land \text{sorted } m \land & \\
(\forall b : \mathbb{N}).\ (\text{mem } b \ l \Rightarrow b \leq a) \land & \\
(\forall b : \mathbb{N}).\ (\text{mem } b \ m \Rightarrow a \leq b) & \\
\Rightarrow \text{sorted } (l ++ [a] ++ m))
\end{align*}
$$

- **解释：**

  - 如果 $l$ 和 $m$ 是已排序的列表，且 $l$ 中的所有元素都小于或等于 $a$，$m$ 中的所有元素都大于或等于 $a$，那么 $l ++ [a] ++ m$ 也是已排序的。

- **证明：**

  - 对列表 $l$ 进行归纳证明。

  - **基准情况：** 当 $l = [\ ]$ 时，需要对 $m$ 进行情况分析。

  - **递归步骤：** 假设对于 $l$，命题成立，证明对于 $(b :: l)$，命题也成立。

---

#### **快速排序正确性的定理**

##### **定理 6.4**

**以下命题是可证明的：**

$$
(\forall m : \mathbb{N}).\ (\forall l : [\mathbb{N}]).\ (\forall p : (\# l \leq m)).\ \text{sorted } (\text{qsort0 } m \ l \ p) \land \text{perm } l \ (\text{qsort0 } m \ l \ p)
$$

- **证明：**

  - 对变量 $m$ 进行归纳证明，正如函数是通过对 $m$ 的递归定义的。

  - **基准情况 $m = 0$：**

    - **子情况 1：** 当 $l = [\ ]$ 时，$\text{qsort0 } 0 \ [\ ] \ p = [\ ]$，显然已排序且与自身排列相同。

    - **子情况 2：** 当 $l$ 非空时，由 $p$ 得到 $\# l \leq 0$，但 $\# l \geq 1$，因此得到矛盾。根据矛盾推理，可以证明任何命题，包括正确性条件。

  - **归纳步骤 $m = n + 1$：**

    - **子情况 1：** 当 $l = [\ ]$ 时，情况同上。

    - **子情况 2：** 当 $l = (a :: x)$ 时：

      - 根据函数定义：

        $$
        \text{qsort0 } (n + 1) \ (a :: x) \ p = l_1 ++ [a] ++ l_2
        $$

        其中：

        $$
        \begin{align*}
        l_1 &\equiv_{\text{df}} \text{qsort0 } n \ (\text{filter } (\text{lesseq } a) \ x) \ p_1 \\
        l_2 &\equiv_{\text{df}} \text{qsort0 } n \ (\text{filter } (\text{greater } a) \ x) \ p_2
        \end{align*}
        $$

      - 根据归纳假设，得出：

        $$
        \begin{align*}
        \text{sorted } l_1 \land \text{sorted } l_2 \\
        \text{perm } (\text{filter } (\text{lesseq } a) \ x) \ l_1 \\
        \text{perm } (\text{filter } (\text{greater } a) \ x) \ l_2
        \end{align*}
        $$

      - **证明已排序性：**

        - 需要证明 $l_1 ++ [a] ++ l_2$ 是已排序的。

        - 根据引理 6.3，只需证明：

          1. $\text{sorted } l_1$ 和 $\text{sorted } l_2$。

          2. 对于 $l_1$ 中的每个元素 $x$，有 $x \leq a$。

          3. 对于 $l_2$ 中的每个元素 $x$，有 $a \leq x$。

        - 根据归纳假设和引理 6.2，可得上述条件成立。

      - **证明排列关系：**

        - 需要证明：

          $$
          \text{perm } (a :: x) \ (l_1 ++ [a] ++ l_2)
          $$

        - 通过一系列引理和排列的传递性，得出结论。

- **结论：** 定理得证。

---

#### **推论 6.5**

**对于所有列表 $l$，有：**

$$
\text{sorted } (\text{qsort } l) \land \text{perm } l \ (\text{qsort } l)
$$

- **证明：**

  - 取定理 6.4 中 $m = \# l$，$p = \text{Triv}$。

---

#### **备注**

1. **程序验证中的归纳形式：**

   - 在大多数程序验证中，用于验证结果的归纳与定义函数时使用的归纳形式相同。我们在证明中使用了与定义 $\text{qsort0}$ 时相同的归纳。

2. **函数效率的考虑：**

   - 函数 $\text{qsort0}$ 看起来比 Miranda 算法效率低，因为它包含了通过递归调用传递的证明信息。
   - 如果使用**应用序 (applicative order)** 求值策略，需要在函数体执行前对参数进行求值，可能导致效率降低。
   - 如果使用**惰性求值 (lazy evaluation)**，则递归调用中的证明对象 $p_1$、$p_2$ 可能永远不会被求值，从而提高效率。

3. **反向过程：**

   - 我们先给出了算法，然后进行了验证。也可以反过来，先证明存在一个已排序的列表，然后从证明中提取出快速排序函数。
   - 在这种情况下，可能显得不自然，因为函数是已知的，但这种方法在构造新算法时非常有用。

4. **一般现象的示例：**

   - 快速排序的定义是一个一般现象的示例，其中函数 $g$ 的一般递归定义：

     $$
     g \ x \equiv_{\text{df}} \dots g \ (h \ x) \dots
     $$

     通过对另一个类型 $B$ 上的归纳来证明其合法性，存在一个函数 $f : A \rightarrow B$，使得 $f (h \ x)$ 是 $f(x)$ 在某种良序中的前驱。

   - 在快速排序的例子中，我们使用列表长度函数 $\# l$，在自然数 $\mathbb{N}$ 上进行归纳。

---

### **练习**

#### **练习 6.16**

**问题：**

还有许多其他列表排序算法，例如插入排序 (insertion sort) 和树排序 (tree sort)。首先展示如何在类型理论中表达它们，然后展示它们如何满足排序算法的规范。

或者，以证明 (6.4) 为目的，以一种使得从证明中提取的函数就是你想表达的算法的方式来证明它。

**提示：**

- **插入排序：**

  - **定义：** 逐一将元素插入到已排序的列表中。

  - **实现：** 可以定义一个插入函数，将元素插入到正确的位置。

- **树排序：**

  - **定义：** 将元素插入到二叉搜索树中，然后以中序遍历方式输出。

  - **实现：** 需要定义树的数据类型，以及插入和遍历函数。

- **证明：** 需要证明算法的正确性，即排序结果已排序，且是原列表的排列。

---

#### **练习 6.17**

**问题：**

你将如何证明以下定义的最大公约数 (gcd) 函数可以在类型理论中定义？

$$
\begin{align*}
\text{gcd } n \ m &\equiv_{\text{df}} n, \quad \text{if } n = m \\
\text{gcd } n \ m &\equiv_{\text{df}} \text{gcd } m \ n, \quad \text{if } n < m \\
\text{gcd } n \ m &\equiv_{\text{df}} \text{gcd } (n - m) \ m, \quad \text{if } n > m > 0 \\
\text{gcd } n \ 0 &\equiv_{\text{df}} 0, \quad \text{if } \text{not}
\end{align*}
$$

**提示：**

- 需要确保递归调用在某种良序中递减，保证函数的终止性。

- 可以使用自然数的良基 (well-founded) 关系，例如使用 $(n, m)$ 的某种度量，在递归调用中严格减少。

---

#### **练习 6.18**

**问题：**

展示如何将使用 Miranda 列表理解 (list comprehension) 表示的列表排列算法在类型理论中进行编码。

$$
\begin{align*}
\text{perms } [\ ] &\equiv_{\text{df}} [ [\ ] ] \\
\text{perms } x &\equiv_{\text{df}} [ (a :: p) \mid a \leftarrow x ; p \leftarrow \text{perms } (x \setminus a) ]
\end{align*}
$$

**提示：**

- 需要定义一个删除元素的函数 $x \setminus a$。

- 递归地生成所有排列。

- 在类型理论中，可以使用递归定义，并处理必要的证明对象，确保函数的正确性和终止性。

---

### **总结**

在本节中，我们深入研究了快速排序算法在类型理论中的完整定义和验证过程。通过将算法的递归结构与类型系统中的证明相结合，我们确保了算法的正确性和终止性。

我们还讨论了类型理论在程序验证中的优势，以及如何利用类型系统的表达能力来精确地描述算法的行为。通过练习，您可以进一步探索其他排序算法和函数的定义，加深对类型理论应用的理解。

如果您对上述内容有任何疑问，或者希望进一步深入了解某个主题，请随时告诉我！

### ---------------------------

### **6.3 依赖类型和量词 (Dependent Types and Quantifiers)**

#### **概述：**

本节将探讨 $TT$ 系统的一个特性，即其表达**依赖类型 (dependent types)** 的能力。依赖类型是包含一个或多个变量值的类型，或者更准确地说，是类型表达式。这些类型依赖于它们所包含的变量的值。操作符 $\forall$、$\exists$ 和 $W$ 能够从这些类型族中形成类型，分别是**依赖乘积类型 (dependent product type)**、**依赖和类型 (dependent sum type)**（或称为子集类型 (subset type)）以及**良基类型 (well-founded type)**。本节重点讨论两个量词 $\forall$ 和 $\exists$，并在讨论如何定义依赖类型（或类型族）之后，深入研究它们。

---

### **6.3.1 依赖类型 (Dependent Types)**

#### **定义和引入：**

- **依赖类型**是指任何包含一个或多个自由变量的类型（表达式）。在逻辑解释中，此类类型实际上就是谓词。
- **依赖性**的引入方式有两种：

  1. **等式命题的构造**：通过引入值到类型中。
  2. **类型形成操作符**：使用量词和其他类型构造器。

---

#### **通过等式命题引入依赖性**

##### **等式命题的构造规则 (IF)**

- **规则：**

  $$
  \frac{A\ \text{是一个类型} \quad a : A \quad b : A}{I(A, a, b)\ \text{是一个类型}} \quad (\text{IF})
  $$

- **解释：**

  - 该规则构造了一个原子的等式命题，也可以写作 $a =_A b$。
  - 在这个构造中，表达式 $a$ 和 $b$ 可以包含自由变量，因此将变量引入到了类型中。
  - 根据 $a$ 和 $b$ 的复杂程度，我们可以构建更多或更少复杂的命题。

---

#### **形成依赖类型的其他方式**

- **使用命题连接词和量词**：可以在不引入额外依赖性的情况下，使用已有的依赖类型构造更复杂的类型。
- **示例：**

  - 已经在第 4.10 节和第 6.1.2 节中看到了一些示例。
  - 另一个原子的示例是类型 $(\# l =_{\mathbb{N}} n)$，其中 $l$ 和 $n$ 是类型 $[A]$ 和 $\mathbb{N}$ 的变量。

- **从这些类型可以形成依赖类型**：

  $$
  (\exists l : [A]).\ (\# l =_{\mathbb{N}} n)
  $$

  - 这个类型中，变量 $n$ 是自由的。
  - 对于固定的 $n$，这个类型表示长度为 $n$ 的列表的类型，或者更严格地说，是对的集合 $(l, r)$，其中 $r$ 是证明 $(\# l = n)$ 的证据。

---

#### **布尔值函数和依赖类型**

- **布尔值函数表示的命题**：可以使用返回布尔值的函数来表示某些命题，例如“小于”关系。

  - **示例：**

    $$
    \text{lt1} : (\mathbb{N} \rightarrow \mathbb{N} \rightarrow \text{bool})
    $$

  - **将其转换为命题**：

    $$
    I(\text{bool}, \text{lt1}\ m\ n, \text{True})
    $$

    - 其中 $n$ 和 $m$ 是自由变量。
    - 这种命题是可判定的，因为布尔值函数是可计算的。

- **限制**：

  - 这种表示方式的命题在无限域上的全称量化下不是封闭的，即无法对无限域上的所有元素进行量化。

---

#### **使用宇宙 $U_0$ 直接定义依赖命题**

- **宇宙 $U_0, U_1, \dots$**：

  - 宇宙 $U_0$ 包含了“小”类型（small types），可以使用表达式形成操作符（如案例分析和递归）来构造类型表达式。
  - 这种方法不限于 $U_0$ 的成员，可以在每个层级 $U_n$ 上进行类似的构造。

- **示例**：

  - 在第 6.1.2 节中已经看到了一些这样的定义。

- **建议**：

  - 有人建议在 $TT_0$ 系统中添加一种设施，允许在不使用宇宙 $U_0$ 的情况下，以归纳方式定义类型或命题。

---

### **6.3.2 存在量词 (The Existential Quantifier)**

#### **定义：**

- **存在量词类型 $(\exists x : A). B$**：

  - 包含对 $(a, b)$，其中 $a : A$ 且 $b : B[a/x]$。
  - 如果将 $B[a/x]$ 视为类型，那么这个构造类似于 $B(x)$ 类型在 $x$ 取遍 $A$ 时的和类型 (sum type)。
  - 如果 $B$ 被视为谓词，那么这个构造可以看作 $A$ 的一个子集，包含了满足性质 $B[a/x]$ 的 $A$ 中的元素 $a$。

- **原则**：

  - 根据**完全呈现原则 (principle of complete presentation)**，对象 $a$ 与其满足性质 $B[a/x]$ 的证明 $b$ 形成对。

---

#### **示例：列表的子集**

- **长度为 $n$ 的列表的集合**：

  $$
  [A]_n \equiv_{\text{df}} (\exists l : [A]).\ (\# l = n)
  $$

  - 其中 $n : \mathbb{N}$。
  - 表示长度为 $n$ 的列表类型。

- **将 $n$ 取遍 $\mathbb{N}$ 的和类型**：

  $$
  (\exists n : \mathbb{N}).\ (\exists l : [A]).\ (\# l = n)
  $$

- **与 $[A]$ 的同构性**：

  - 通过以下函数，我们可以证明上述类型与 $[A]$ 是同构的。

  - **函数 $f$：**

    $$
    f : [A] \rightarrow (\exists n : \mathbb{N}).\ (\exists l : [A]).\ (\# l = n)
    $$

    - 定义：

      $$
      f\ l \equiv_{\text{df}} (\# l, (l, r(\# l)))
      $$

      - 其中 $r(\# l)$ 是 $(\# l = \# l)$ 的规范证明。

  - **函数 $g$：**

    $$
    g : (\exists n : \mathbb{N}).\ (\exists l : [A]).\ (\# l = n) \rightarrow [A]
    $$

    - 定义：

      $$
      g\ (n, (l, s)) \equiv_{\text{df}} l
      $$

- **解释**：

  - 这种类型的划分看似任意，实际上我们可以根据任何函数 $h : [A] \rightarrow \dots$ 来划分类型。
  - 但在这个例子中，许多列表的标准函数可以与这种分层（stratification）相协调，因为它们保持了列表的长度。

---

#### **与映射函数的交互**

- **定义映射函数族**：

  $$
  \text{map}_n : (A \rightarrow B) \rightarrow [A]_n \rightarrow [B]_n
  $$

- **定义**：

  $$
  \text{map}_n\ f\ (l, r) \equiv_{\text{df}} (\text{map}\ f\ l, r)
  $$

  - **解释**：

    - 由于对于所有 $l$，$\# (\text{map}\ f\ l) = \# l$ 是可证明的（通过归纳），因此上述定义是合法的。
    - 这些 $\text{map}_n$ 函数的行为类似于 $\text{map}$，但它们携带了关于列表长度的证明信息，可以被使用结果的函数利用。

---

#### **类型和证明的双重解读**

- **判断 $a : A$**：

  - 可以理解为断言对象 $a$ 的类型是 $A$，或者 $a$ 是 $A$ 的一个证明。

- **特殊情况**：

  - **断言 $(a, p) : (\exists x : A). P$**。

    - 可以理解为对象 $a$（类型为 $A$）满足规范 $P(x)$，其中 $p : P[a/x]$ 是证明。

- **后续讨论**：

  - 我们将在后面回到这个主题。

---

### **6.3.3 全称量词 (The Universal Quantifier)**

#### **定义：**

- **全称量词 $\forall$ 定义了一个依赖函数空间**。

  - **如果 $f : (\forall x : A). B$，那么对于任何 $a : A$，都有 $f\ a : B[a/x]$。**

- **应用**：

  - 已经在前面的快速排序函数等例子中看到过这种用法。
  - 在接下来的向量例子中，我们将再次使用它，其中向量上的操作以向量的大小为参数。

---

#### **量词在宇宙上的应用**

- **两个量词在对宇宙进行量化时具有有趣的性质**。

- **在讨论这个之前，我们先来看一个更大规模的应用：实现一个逻辑系统。**

---

### **6.3.4 实现逻辑 (Implementing a Logic)**

#### **目标：**

- 以“与 (and)”和“蕴涵 (implies)”为例，构建一个命题逻辑的实现。

---

#### **公式的语法表示**

- **定义一个良基类型 (well-founded type) 来描述公式的语法**：

  $$
  \text{fmla} \equiv_{\text{df}} \text{Vbl var} + \text{T} + \text{F} + \\
  \text{And fmla fmla} + \text{Imp fmla fmla}
  $$

  - **解释**：

    - $\text{T}$ 和 $\text{F}$ 表示恒真和恒假的命题。
    - $\text{var}$ 是表示命题变量的类型，可能是字符字符串。
    - 递归地定义了公式的结构。

---

#### **证明的两种定义方法**

1. **嵌入到 $TT$ 本身的逻辑中**

   - **通过一个从公式到类型的函数实现**。

     $$
     \begin{align*}
     \text{proof} &: \text{fmla} \rightarrow U_0 \\
     \text{proof } (\text{Vbl } v) &\equiv_{\text{df}} \{ \text{Assum } v \} \\
     \text{proof } \text{T} &\equiv_{\text{df}} \top \\
     \text{proof } \text{F} &\equiv_{\text{df}} \bot \\
     \text{proof } (\text{And } f_1\ f_2) &\equiv_{\text{df}} \text{proof } f_1 \land \text{proof } f_2 \\
     \text{proof } (\text{Imp } f_1\ f_2) &\equiv_{\text{df}} \text{proof } f_1 \rightarrow \text{proof } f_2
     \end{align*}
     $$

   - **解释**：

     - $\{ \text{Assum } v \}$ 表示具有单一元素 $\text{Assum } v$ 的类型。

   - **问题**：

     - 在构造命题变量 $\text{Vbl } v$ 的证明 $\text{Assum } v$ 时，如果要构造一个恒真的蕴涵 $\text{Imp } (\text{Vbl } v)\ (\text{Vbl } v)$ 的证明，我们需要构造一个从单元素类型到自身的函数，这是平凡的。
     - 但是，对于任何变量 $v'$，我们都可以找到类型 $\text{Imp } (\text{Vbl } v)\ (\text{Vbl } v')$ 的函数，这导致了一个不健全的表示。
     - **原因**：假设的证明 $\text{Assum } v$ 并不是 $TT$ 系统的变量，若要嵌入是健全的，它们必须是 $TT$ 系统的变量。

   - **结论**：这种嵌入方法在省略变量的情况下是健全的，但在一般情况下并不适用。

2. **传统的 LCF 方法**

   - **思路**：

     - 构建一个抽象的证明类型，每个推理规则由该类型上的一个函数表示。
     - 在 $TT$ 中，可以使用抽象类型的机制来实现。

   - **定义证明类型**：

     $$
     \begin{align*}
     \text{proof} \equiv_{\text{df}} &\ \text{Tr} + \text{ConjI proof proof} + \\
     &\ \text{ConjE1 proof} + \text{ConjE2 proof} + \\
     &\ \text{ImpI proof fmla} + \text{ImpE proof proof}
     \end{align*}
     $$

   - **解释**：

     - **$\text{Tr}$**：$\text{T}$ 的平凡证明。
     - **$\text{ConjI } p_1\ p_2$**：如果 $p_1$ 和 $p_2$ 是 $f_1$ 和 $f_2$ 的证明，那么这是 $\text{And } f_1\ f_2$ 的证明。
     - **$\text{ConjE1 } p$**：如果 $p$ 是 $\text{And } f_1\ f_2$ 的证明，那么这是 $f_1$ 的证明。
     - **$\text{ConjE2 } p$**：类似于 $\text{ConjE1 } p$，但返回 $f_2$ 的证明。
     - **$\text{ImpI } p\ g$**：如果 $p$ 是 $f$ 的证明，那么这是 $\text{Imp } g\ f$ 的证明。
     - **$\text{ImpE } p_1\ p_2$**：如果 $p_1$ 证明了 $g$，$p_2$ 证明了 $\text{Imp } g\ f$，那么这是 $f$ 的证明。

   - **困难之处**：

     - **$\text{ConjE}$ 和 **$\text{ImpE}$ 的情况比较困难。
     - 某些构造器的应用可能不会产生有效的证明。
     - 在 LCF 方法中，这会导致错误或异常。

   - **解决方案：使用依赖类型机制**

     - **定义函数 $\text{proves}$**：

       $$
       \text{proves} : \text{proof} \rightarrow (\text{fmla} + \text{dummy})
       $$

       - **作用**：返回证明对象所证明的公式，如果是异常情况，则返回一个占位符 $\text{dummy}$。

     - **定义子类型**：

       $$
       \text{prf } f \equiv_{\text{df}} (\exists p : \text{proof}).\ (\text{proves } p = f)
       $$

     - **为消解合取和蕴涵的函数赋予类型**：

       $$
       \text{conjE1} : (\forall f : \text{fmla}).\ (\forall g : \text{fmla}).\ (\text{prf } (\text{And } f\ g) \rightarrow \text{prf } f)
       $$

       $$
       \text{impE} : (\forall f : \text{fmla}).\ (\forall g : \text{fmla}).\ (\text{prf } g \rightarrow \text{prf } (\text{Imp } g\ f) \rightarrow \text{prf } f)
       $$

     - **效果**：

       - 这些函数的本质是应用对应的构造器。
       - 它们的应用仅在将合法的证明转换为合法的证明时才被允许，从而排除了引发错误的可能性。

   - **构建安全的证明类型**

     - **定义函数 $\text{tr}$、$\text{conjI}$ 和 $\text{impI}$，对应于构造器 $\text{Tr}$、$\text{ConjI}$ 和 $\text{ImpI}$。**

     - **在证明类型 $\text{proof}$ 之上，构建一个抽象的安全证明类型 $\text{secproof}$，其签名仅包含这些函数。**

     - **$\text{secproof}$ 类型只包含合法的证明。**

---

### **练习**

#### **练习 6.19**

**问题：**

给出上述函数 $\text{proves}$、$\text{conjE1}$ 和 $\text{impE}$ 的定义。

**解答：**

1. **定义 $\text{proves}$ 函数：**

   - **类型：**

     $$
     \text{proves} : \text{proof} \rightarrow (\text{fmla} + \text{dummy})
     $$

   - **定义：**

     - 对于 $\text{Tr}$：

       $$
       \text{proves } \text{Tr} \equiv_{\text{df}} \text{T}
       $$

     - 对于 $\text{ConjI } p_1\ p_2$：

       $$
       \text{proves } (\text{ConjI } p_1\ p_2) \equiv_{\text{df}} \text{And } (\text{proves } p_1)\ (\text{proves } p_2)
       $$

     - 对于 $\text{ConjE1 } p$：

       - 如果 $\text{proves } p$ 的结果是 $\text{And } f_1\ f_2$，则：

         $$
         \text{proves } (\text{ConjE1 } p) \equiv_{\text{df}} f_1
         $$

       - 否则，返回 $\text{dummy}$。

     - 对于 $\text{ConjE2 } p$：

       - 类似于 $\text{ConjE1 } p$，但返回 $f_2$。

     - 对于 $\text{ImpI } p\ g$：

       $$
       \text{proves } (\text{ImpI } p\ g) \equiv_{\text{df}} \text{Imp } g\ (\text{proves } p)
       $$

     - 对于 $\text{ImpE } p_1\ p_2$：

       - 如果 $\text{proves } p_2$ 的结果是 $\text{Imp } g\ f$，且 $\text{proves } p_1 = g$，则：

         $$
         \text{proves } (\text{ImpE } p_1\ p_2) \equiv_{\text{df}} f
         $$

       - 否则，返回 $\text{dummy}$。

2. **定义 $\text{conjE1}$ 函数：**

   - **类型：**

     $$
     \text{conjE1} : (\forall f : \text{fmla}).\ (\forall g : \text{fmla}).\ (\text{prf } (\text{And } f\ g) \rightarrow \text{prf } f)
     $$

   - **定义**：

     - 对于输入 $\text{prf } (\text{And } f\ g)$，设其证明对象为 $p$，即存在 $p$ 使得 $\text{proves } p = \text{And } f\ g$。

     - 构造新的证明对象：

       $$
       \text{conjE1 } (p) \equiv_{\text{df}} \begin{cases}
       (\text{ConjE1 } p), & \text{if } \text{proves } p = \text{And } f\ g \\
       \text{undefined}, & \text{otherwise}
       \end{cases}
       $$

     - 返回的证明对象满足 $\text{proves } (\text{ConjE1 } p) = f$。

3. **定义 $\text{impE}$ 函数：**

   - **类型：**

     $$
     \text{impE} : (\forall f : \text{fmla}).\ (\forall g : \text{fmla}).\ (\text{prf } g \rightarrow \text{prf } (\text{Imp } g\ f) \rightarrow \text{prf } f)
     $$

   - **定义**：

     - 给定 $\text{prf } g$ 的证明对象 $p_1$，满足 $\text{proves } p_1 = g$。

     - 给定 $\text{prf } (\text{Imp } g\ f)$ 的证明对象 $p_2$，满足 $\text{proves } p_2 = \text{Imp } g\ f$。

     - 构造新的证明对象：

       $$
       \text{impE } (p_1, p_2) \equiv_{\text{df}} \text{ImpE } p_1\ p_2
       $$

     - 返回的证明对象满足 $\text{proves } (\text{ImpE } p_1\ p_2) = f$。

---

#### **练习 6.20**

**问题：**

为函数 $\text{tr}$、$\text{conjI}$ 和 $\text{impI}$ 给出类型，然后定义它们。

**解答：**

1. **函数 $\text{tr}$：**

   - **类型：**

     $$
     \text{tr} : \text{prf } \text{T}
     $$

   - **定义：**

     - 返回 $\text{Tr}$。

2. **函数 $\text{conjI}$：**

   - **类型：**

     $$
     \text{conjI} : (\forall f : \text{fmla}).\ (\forall g : \text{fmla}).\ (\text{prf } f \rightarrow \text{prf } g \rightarrow \text{prf } (\text{And } f\ g))
     $$

   - **定义**：

     - 给定 $\text{prf } f$ 的证明对象 $p_1$，$\text{proves } p_1 = f$。

     - 给定 $\text{prf } g$ 的证明对象 $p_2$，$\text{proves } p_2 = g$。

     - 构造新的证明对象：

       $$
       \text{conjI } (p_1, p_2) \equiv_{\text{df}} \text{ConjI } p_1\ p_2
       $$

     - 返回的证明对象满足 $\text{proves } (\text{ConjI } p_1\ p_2) = \text{And } f\ g$。

3. **函数 $\text{impI}$：**

   - **类型：**

     $$
     \text{impI} : (\forall f : \text{fmla}).\ (\forall g : \text{fmla}).\ (\text{prf } f \rightarrow \text{prf } (\text{Imp } g\ f))
     $$

   - **定义**：

     - 给定 $\text{prf } f$ 的证明对象 $p$，$\text{proves } p = f$。

     - 构造新的证明对象：

       $$
       \text{impI } (p, g) \equiv_{\text{df}} \text{ImpI } p\ g
       $$

     - 返回的证明对象满足 $\text{proves } (\text{ImpI } p\ g) = \text{Imp } g\ f$。

---

#### **练习 6.21**

**问题：**

证明类型 $\text{secproof}$ 只包含合法的证明，并且所有这样的证明都包含在其中。

**解答：**

1. **证明 $\text{secproof}$ 只包含合法的证明：**

   - **构造**：

     - $\text{secproof}$ 类型的对象只能通过定义的构造函数 $\text{tr}$、$\text{conjI}$、$\text{conjE1}$、$\text{conjE2}$、$\text{impI}$ 和 $\text{impE}$ 来构造。

   - **确保合法性**：

     - 这些构造函数的定义确保了只有在前提证明对象合法的情况下，才能构造新的证明对象。
     - 因此，$\text{secproof}$ 中的所有对象都是合法的证明。

2. **所有合法的证明都包含在 $\text{secproof}$ 中：**

   - **论证**：

     - 任何合法的证明都可以通过上述构造函数组合而成。
     - 因此，所有合法的证明都可以被表示为 $\text{secproof}$ 类型的对象。

---

### **总结**

本节深入探讨了依赖类型和量词在类型理论中的应用。通过详细讨论，我们理解了如何使用依赖类型来表达更加丰富和精确的类型，以及如何利用全称量词和存在量词来构造依赖类型。我们还通过实现一个逻辑系统的示例，展示了依赖类型在保证证明的合法性和安全性方面的强大能力。

通过练习，我们巩固了对依赖类型和量词的理解，掌握了如何定义和使用相关的函数和类型，并验证了安全证明类型的正确性。

如果您对上述内容有任何疑问，或者希望进一步深入了解某个主题，请随时告诉我！

### ----------------------------

### **6.3.5 量化和宇宙 – 全称量化 (Quantification and Universes – ∀)**

#### **概述：**

在类型理论中，对宇宙 $U_0, U_1, \dots, U_n, \dots$ 进行量化允许我们断言具有某些性质的类型的存在性，并定义以类型参数为参数的定义。在本节中，我们将首先讨论后者的示例，即如何使用全称量化来实现参数化定义，然后探讨类型多态性 (polymorphism) 和弱类型表示 (weak type representation)。

---

#### **类型参数化的多态性**

##### **示例：恒等函数的多态定义**

- 在第 5.9.2 节中，我们看到了一种多态性的形式，可以通过如下定义来实现：

  $$
  \lambda A : U_0.\ \lambda x : A.\ x : (\forall A : U_0).\ (A \rightarrow A)
  $$

  - **解释：**
    - 这里，$\lambda A : U_0$ 表示一个以类型 $A$ 为参数的函数，其中 $A$ 取遍宇宙 $U_0$ 中的所有类型。
    - $\lambda x : A.\ x$ 是一个恒等函数，接受类型为 $A$ 的参数 $x$，返回 $x$ 本身。
    - 整个表达式的类型是 $(\forall A : U_0).\ (A \rightarrow A)$，表示对于任意类型 $A$，有一个从 $A$ 到 $A$ 的函数。

- **一般化到更高的宇宙层级：**

  - 这种定义不限于第一个宇宙 $U_0$，我们可以在 $n$ 上统一地导出判断：

    $$
    (\lambda A : U_n).\ (\lambda x : A).\ x : (\forall A : U_n).\ (A \rightarrow A)
    $$

  - **解释：**
    - 由于 $A$ 的作用纯粹是一个参数，因此在不同的宇宙层级上，这种定义是相同的。

---

#### **快速排序的参数化**

- **先前的定义：**
  - 我们已经看到如何在数值列表上定义快速排序函数 $\text{qsort}$。

- **泛化到任意类型：**
  - 实际上，它可以被定义在任何携带一个比较函数的类型 $A$ 上，该比较函数具有类型：

    $$
    \text{lesseq} : A \rightarrow A \rightarrow \text{bool}
    $$

- **因此，快速排序函数可以定义为：**

  $$
  \text{qsort} : (\forall A : U_0).\ (\text{lesseq} : A \rightarrow A \rightarrow \text{bool}) \rightarrow ([A] \rightarrow [A])
  $$

- **解释：**
  - 这里的 $\text{qsort}$ 是参数化的，接受一个类型 $A$ 和一个比较函数 $\text{lesseq}$，返回一个从 $[A]$ 到 $[A]$ 的函数。
  - 这种参数化在类似于 Miranda 的语言中是可能的。

- **进一步的约束：**
  - 由于 $TT$ 拥有更具表达力的类型系统，我们可以进一步要求提供的函数是一个排序 (ordering)。
  - **定义一个排序：**

    $$
    \begin{align*}
    \text{Ordering}(A) \equiv_{\text{df}} (\exists \text{lesseq} : A \rightarrow A \rightarrow \text{bool}).\ (\forall a : A).\ ( & \\
    \text{lesseq}\ a\ a = \text{True} \quad \land & \quad \text{(自反性)} \\
    (\forall a, b : A).\ \text{lesseq}\ a\ b = \text{lesseq}\ b\ a \quad \land & \quad \text{(对称性)} \\
    (\forall a, b, c : A).\ \text{lesseq}\ a\ b = \text{True} \land \text{lesseq}\ b\ c = \text{True} \Rightarrow \text{lesseq}\ a\ c = \text{True} & \quad \text{(传递性)} \\
    )
    \end{align*}
    $$

  - **解释：**
    - 定义了一个 $A$ 上的排序关系 $\text{lesseq}$，满足自反性、对称性和传递性。

- **定义已排序列表的子类型：**

  $$
  \text{Slist}(A) \equiv_{\text{df}} (\exists l : [A]).\ (\text{sorted}\ l)
  $$

  - **其中**，$\text{sorted}$ 是之前定义的谓词，表示列表 $l$ 是已排序的。

- **定义验证过的快速排序函数：**

  $$
  \text{vsort} : (\forall A : U_0).\ (\text{Ordering}(A) \rightarrow ([A] \rightarrow \text{Slist}(A)))
  $$

  - **解释：**
    - $\text{vsort}$ 接受一个类型 $A$ 和其上的一个排序 $\text{Ordering}(A)$，返回一个从 $[A]$ 到 $\text{Slist}(A)$ 的函数，即返回一个已排序列表的子类型。

---

#### **比较与 Hindley-Milner 类型系统的多态性**

- **Hindley-Milner 类型系统：**
  - 用于 Miranda 和 SML 等语言中。
  - 多态类型包含自由类型变量，类似于上述示例中的 $A : U_0$。
  - 这些变量没有被绑定的操作，自由类型变量相当于在顶层被绑定的变量。
  - 在 Hindley-Milner 系统中，多态类型可以看作是一类单态类型的简写：那些来自多态类型的替换实例。

- **$TT$ 系统的不同之处：**
  - 在 $TT$ 系统中，我们可以表达不同的类型。
  - **示例：**

    $$
    (\forall A : U_0).\ (A \rightarrow A) \rightarrow (\forall A : U_0).\ (A \rightarrow A)
    $$

    - **解释：**
      - 这是一个从多态类型到自身的函数的类型。
      - 这样的函数不能被视为一组单态类型的简写。

- **构造一个这样的函数：**

  $$
  f \equiv_{\text{df}} \lambda f.\ \text{if } f\ \text{bool}\ (\text{eqN}\ (f\ \mathbb{N}\ 0)\ (f\ \mathbb{N}\ 1))\ \text{then } f\ \text{else } \text{id}
  $$

  - **解释：**
    - 条件中，$f$ 被用于布尔类型和自然数类型，因此 $f$ 必须具有多态类型 $(\forall A : U_0).\ (A \rightarrow A)$。
    - 根据条件，返回 $f$ 本身或恒等函数 $\text{id}$。

  - **定义恒等函数 $\text{id}$：**

    $$
    \text{id} \equiv_{\text{df}} \lambda A : U_0.\ \lambda x : A.\ x
    $$

---

#### **弱类型表示 (Weak Type Representation)**

- **使用全称量化定义弱类型构造器：**

  - **示例：乘积类型的弱表示**

    $$
    \text{Prod } A\ B \equiv_{\text{df}} (\forall C : U_0).\ ( (A \rightarrow B \rightarrow C) \rightarrow C )
    $$

    - **解释：**
      - $\text{Prod } A\ B$ 类似于类型 $A$ 和 $B$ 的乘积类型 (product type)。
      - 该类型表示为一个函数，接受任意类型 $C : U_0$，以及一个函数 $f : A \rightarrow B \rightarrow C$，返回一个 $C$ 类型的值。

  - **构造元素 $(a, b)$：**

    $$
    F_{a,b} : \text{Prod } A\ B \\
    F_{a,b} \equiv_{\text{df}} \lambda C : U_0.\ \lambda f : A \rightarrow B \rightarrow C.\ f\ a\ b
    $$

    - **解释：**
      - $F_{a,b}$ 可以看作由 $a$ 和 $b$ 形成的对。

  - **定义两个“投影”函数：**

    - **$p$ 函数：**

      $$
      p : \text{Prod } A\ B \rightarrow A \\
      p\ F \equiv_{\text{df}} F\ A\ (\lambda x : A.\ \lambda y : B.\ x)
      $$

    - **$q$ 函数：**

      $$
      q : \text{Prod } A\ B \rightarrow B \\
      q\ F \equiv_{\text{df}} F\ B\ (\lambda x : A.\ \lambda y : B.\ y)
      $$

  - **验证 $p\ F_{a,b} = a$：**

    - 计算 $p\ F_{a,b}$：

      $$
      \begin{align*}
      p\ F_{a,b} &= F_{a,b}\ A\ (\lambda x : A.\ \lambda y : B.\ x) \\
      &= (\lambda C : U_0.\ \lambda f : A \rightarrow B \rightarrow C.\ f\ a\ b)\ A\ (\lambda x : A.\ \lambda y : B.\ x) \\
      &\rightarrow (\lambda f : A \rightarrow B \rightarrow A.\ f\ a\ b)\ (\lambda x : A.\ \lambda y : B.\ x) \\
      &\rightarrow (\lambda x : A.\ \lambda y : B.\ x)\ a\ b \\
      &\rightarrow a
      \end{align*}
      $$

    - **同理可证** $q\ F_{a,b} = b$。

  - **结论：**
    - 函数 $F_{a,b}$ 可以被视为由 $a$ 和 $b$ 形成的对的表示。
    - $\text{Prod } A\ B$ 是一个弱表示，因为无法从 $TT$ 的规则中证明该类型的每个成员都是这样的对。

---

#### **其他类型的弱表示**

- **和类型 (sum type) 的弱表示：**

  - 类型：

    $$
    (\forall C : U_0).\ ((A \rightarrow C) \rightarrow (B \rightarrow C) \rightarrow C)
    $$

  - **解释：**
    - 类似于 $A + B$ 的类型。

- **自然数类型的弱表示：**

  - 类型：

    $$
    (\forall C : U_0).\ (C \rightarrow (C \rightarrow C) \rightarrow C)
    $$

  - **解释：**
    - 类似于自然数的表示。

- **进一步讨论：**
  - 这些弱表示不能提供足够的消解或闭包条件来证明类型的所有成员都具有预期的结构。
  - 这些类型的表示在 $TT$ 的规则下是有限制的。

---

### **练习**

#### **练习 6.22**

**问题：**

给出上述验证过的快速排序函数的推导。

**解答：**

1. **目标：**

   - 定义一个验证过的快速排序函数：

     $$
     \text{vsort} : (\forall A : U_0).\ (\text{Ordering}(A) \rightarrow ([A] \rightarrow \text{Slist}(A)))
     $$

2. **步骤：**

   - **定义 $\text{Ordering}(A)$：**

     - 如上所述，$\text{Ordering}(A)$ 包含一个排序函数 $\text{lesseq} : A \rightarrow A \rightarrow \text{bool}$，并满足自反性、对称性和传递性。

   - **定义 $\text{sorted}$ 谓词：**

     - 与之前相同，定义列表 $l$ 是已排序的条件。

   - **定义 $\text{Slist}(A)$：**

     - $\text{Slist}(A) \equiv_{\text{df}} (\exists l : [A]).\ (\text{sorted}\ l)$

   - **构造 $\text{vsort}$ 函数：**

     - $\text{vsort}$ 接受一个类型 $A$，一个排序 $\text{Ordering}(A)$，以及一个列表 $l : [A]$，返回一个 $\text{Slist}(A)$ 的元素。

     - **实现**：

       - 利用前面定义的参数化快速排序函数 $\text{qsort}$，它可以接受任意类型 $A$ 和一个比较函数 $\text{lesseq}$。

       - **定义 $\text{vsort}$：**

         $$
         \text{vsort}\ A\ (\text{lesseq}, \text{proofs})\ l \equiv_{\text{df}} (\text{qsort}\ A\ \text{lesseq}\ l,\ \text{proof})
         $$

         - 其中 $\text{proof}$ 是证明 $\text{qsort}$ 的结果是已排序的，即 $\text{sorted}\ (\text{qsort}\ l)$。

     - **验证**：

       - 根据排序的性质和 $\text{qsort}$ 的正确性证明，$\text{qsort}$ 返回的列表是已排序的，并且是输入列表的排列。

3. **结论：**

   - 通过利用 $\text{Ordering}(A)$，我们构造了一个验证过的快速排序函数 $\text{vsort}$，满足题目要求。

---

#### **练习 6.23**

**问题：**

证明类型

1. $$
   (\forall C : U_0).\ ((A \rightarrow C) \rightarrow (B \rightarrow C) \rightarrow C)
   $$

   可以被视为一个弱和类型 (sum type)。

2. $$
   (\forall C : U_0).\ (C \rightarrow (C \rightarrow C) \rightarrow C)
   $$

   可以被视为自然数类型的表示。

**解答：**

1. **弱和类型的表示：**

   - **类型：**

     $$
     S \equiv_{\text{df}} (\forall C : U_0).\ ((A \rightarrow C) \rightarrow (B \rightarrow C) \rightarrow C)
     $$

   - **解释：**

     - 该类型接受一个类型参数 $C : U_0$，以及两个函数 $f : A \rightarrow C$ 和 $g : B \rightarrow C$，返回一个 $C$ 类型的值。

     - 可以将其视为对类型 $A + B$ 的弱表示。

   - **构造注入函数：**

     - **左注入函数：**

       $$
       \text{inl} : A \rightarrow S \\
       \text{inl}\ a \equiv_{\text{df}} \lambda C : U_0.\ \lambda f : A \rightarrow C.\ \lambda g : B \rightarrow C.\ f\ a
       $$

     - **右注入函数：**

       $$
       \text{inr} : B \rightarrow S \\
       \text{inr}\ b \equiv_{\text{df}} \lambda C : U_0.\ \lambda f : A \rightarrow C.\ \lambda g : B \rightarrow C.\ g\ b
       $$

   - **消解函数：**

     - 给定 $s : S$，可以定义一个“模式匹配”函数：

       $$
       \text{case}\ s\ f\ g \equiv_{\text{df}} s\ C\ f\ g
       $$

       - 其中 $f : A \rightarrow C$，$g : B \rightarrow C$。

   - **验证：**

     - 对于 $\text{inl}\ a$，有：

       $$
       \text{case}\ (\text{inl}\ a)\ f\ g = (\text{inl}\ a)\ C\ f\ g = f\ a
       $$

     - 对于 $\text{inr}\ b$，有：

       $$
       \text{case}\ (\text{inr}\ b)\ f\ g = (\text{inr}\ b)\ C\ f\ g = g\ b
       $$

   - **结论：**

     - 该类型 $S$ 可以被视为 $A + B$ 的弱表示。

2. **自然数类型的表示：**

   - **类型：**

     $$
     N \equiv_{\text{df}} (\forall C : U_0).\ (C \rightarrow (C \rightarrow C) \rightarrow C)
     $$

   - **解释：**

     - 该类型类似于自然数的教堂编码 (Church encoding) 表示。

   - **构造自然数的表示：**

     - **零的表示：**

       $$
       \text{zero} \equiv_{\text{df}} \lambda C : U_0.\ \lambda z : C.\ \lambda s : C \rightarrow C.\ z
       $$

     - **后继函数：**

       $$
       \text{succ} : N \rightarrow N \\
       \text{succ}\ n \equiv_{\text{df}} \lambda C : U_0.\ \lambda z : C.\ \lambda s : C \rightarrow C.\ s\ (n\ C\ z\ s)
       $$

   - **解释：**

     - 这种表示方式中，一个自然数被表示为一个高阶函数，接受类型 $C$，一个初始值 $z$，以及一个函数 $s$，返回对 $s$ 的若干次应用。

   - **消解函数：**

     - 可以定义一个类似于归纳定义的函数，对自然数进行操作。

   - **结论：**

     - 该类型 $N$ 可以被视为自然数类型的表示。

---

#### **练习 6.24**

**问题：**

比较本节和上述练习中给出的类型的弱表示与所表示类型的消解规则，能否看到一个一般模式的出现？

**解答：**

- **一般模式：**

  - **弱类型表示的共同特征：**
    - 使用全称量化 $\forall C : U_0$，定义一个高阶类型，接受类型参数 $C$。
    - 定义该类型的元素为一组函数，这些函数接受一些函数作为参数，并返回 $C$ 类型的值。
    - 通过特定的函数组合，可以模拟所表示的类型的构造和消解。

- **与类型的消解规则的关系：**

  - **构造器：**
    - 定义了类型元素的构造方式，例如 $\text{inl}$、$\text{inr}$、$\text{zero}$、$\text{succ}$ 等。
    - 这些构造器对应于类型的构造规则。

  - **消解器：**
    - 通过模式匹配或高阶函数，定义了类型元素的消解方式，例如 $\text{case}$、递归函数等。
    - 这些消解器对应于类型的消解规则。

- **一般化：**

  - 这种模式对应于所谓的 **Church Encoding**，在纯粹的 $\lambda$ 演算中，用高阶函数来表示数据类型。

  - **优点：**
    - 可以在不引入新的类型构造器的情况下，使用现有的函数抽象机制来表示复杂的数据类型。

  - **缺点：**
    - 由于缺乏类型系统的支持，无法保证所有类型的成员都满足预期的结构（如无法证明所有元素都是对、自然数等）。
    - 无法充分利用类型系统的模式匹配和类型检查机制。

- **结论：**

  - 这些弱类型表示体现了一种通用的编码模式，利用高阶函数和全称量化来模拟数据类型的构造和消解。
  - 然而，这种表示在类型理论中是有限制的，无法完全替代类型系统中原生的数据类型及其规则。

---

### **6.3.6 量化和宇宙 – 存在量化 (Quantification and Universes – ∃)**

#### **概述：**

对宇宙进行存在量化提供了丰富的示例。在第 5.9.2 节中，解释了类型 $(\exists A : U_0). P$ 的对象是对 $(A, p)$，其中 $A$ 是一个（小）类型，$p$ 是类型 $P$ 的一个元素，该类型依赖于 $A$。

---

#### **抽象类型和模块**

- **特殊情况：**
  - 当 $P \equiv A$ 时，我们得到了 $U_0$ 中类型的和类型 (sum)。

- **重要情况：**
  - 当 $P(A)$ 是类型的合取：

    $$
    P_1 \land P_2 \land \dots \land P_n
    $$

    - 对象是类型 $A$，以及元素 $p_i : P_i$。

  - **解释：**
    - 我们可以将 $P_1 \land P_2 \land \dots \land P_n$ 视为一个签名 (signature)，将元组 $(p_1, p_2, \dots, p_n)$ 视为签名的实现 (implementation)。

- **示例：**

  - 考虑一个栈的抽象数据类型，定义签名：

    $$
    \begin{align*}
    & A \quad \text{（栈的类型）} \\
    & \text{empty} : A \\
    & \text{push} : \mathbb{N} \rightarrow A \rightarrow A \\
    & \text{pop} : A \rightarrow A \\
    & \text{top} : A \rightarrow \mathbb{N}
    \end{align*}
    $$

  - **抽象类型的定义：**

    $$
    (\exists A : U_0).\ P
    $$

    - 其中 $P$ 包含上述签名。

- **强和弱存在量化规则的区别：**

  - **弱规则 (∃E0)**：
    - 提供了存在语句的假设性见证 (hypothetical witness)。
    - 这种解释是 Miranda 的抽象类型 (abstype) 和其他一些语言中的构造的基础。

  - **强规则 (∃E)**：
    - 使得见证是透明的，允许提取底层类型和实现函数，从而允许类型的扩展。

- **讨论：**

  - 弱规则的缺点是封装一旦形成，就无法重新打开，难以扩展抽象类型的功能。

  - 强规则允许扩展类型，更适合于面向对象的设计。

---

#### **类型类 (Type Classes) 的应用**

- **Wadler 和 Blott 的类型类概念：**

  - 首先在 [WB89] 中引入，用于 Haskell 编程语言。

  - **动机：**
    - 提供对等号操作的准多态性 (quasi-polymorphism) 的更清晰处理。

- **定义类型类：**

  - **示例：Eq 类型类**

    - 每个在 Eq 类中的类型 $t$ 都必须携带一个函数：

      $$
      \text{eq} : t \rightarrow t \rightarrow \text{bool}
      $$

  - **在类型理论中，类型类表示为：**

    $$
    \text{Eq} t \equiv_{\text{df}} (\exists A : U_0).\ (A \rightarrow A \rightarrow \text{bool})
    $$

- **定义函数时的应用：**

  - **示例：删除列表中所有出现的某元素的函数 $\text{remove}$**

    - 定义：

      $$
      \begin{align*}
      \text{remove}\ [\ ]\ b &\equiv_{\text{df}} [\ ] \\
      \text{remove}\ (a :: x)\ b &\equiv_{\text{df}} \begin{cases}
      \text{remove}\ x\ b, & \text{if } \text{eq}\ a\ b \\
      a :: (\text{remove}\ x\ b), & \text{otherwise}
      \end{cases}
      \end{align*}
      $$

    - 在 Haskell 中，其类型为：

      $$
      \text{remove} : (\text{Eq}\ t) \Rightarrow [t] \rightarrow t \rightarrow [t]
      $$

      - 表示 $\text{remove}$ 只在 Eq 类的元素上定义。

  - **在 $TT$ 中的表示：**

    $$
    \text{remove} : (\forall (A, \text{eq}) : \text{Eq}t).\ ([A] \rightarrow A \rightarrow [A])
    $$

    - **解释：**
      - 使用模式 $(A, \text{eq})$ 来遍历存在类型的元素，便于阅读。
      - 限制的多态性被显式地表示出来，因为类型变量 $A$ 仅遍历那些具有类型 $A \rightarrow A \rightarrow \text{bool}$ 的 $A$。

---

#### **增加性质的类型类**

- **添加证明信息：**

  - 除了要求某些类型的对象的存在外，还可以要求它们具有某些性质。

- **示例：**

  - **要求栈的实现满足：**

    $$
    \begin{align*}
    & (\forall n : \mathbb{N}).\ (\forall a : A).\ (\text{pop} (\text{push}\ n\ a) = a) \\
    & (\forall n : \mathbb{N}).\ (\forall a : A).\ (\text{top} (\text{push}\ n\ a) = n)
    \end{align*}
    $$

  - **定义：**

    $$
    (\exists (\text{empty}, \text{push}, \text{pop}, \text{top}) : A \land (\mathbb{N} \rightarrow A \rightarrow A) \land (A \rightarrow A) \land (A \rightarrow \mathbb{N})). \\
    ((\text{性质 1}) \land (\text{性质 2}))
    $$

- **逻辑类型类：**

  - 可以指定对象不仅存在，而且具有某些性质。

  - **示例：**

    - 在 Eq 类型类中，可以要求等价关系是一个等价关系，而不仅是任意的二元布尔值函数。

---

#### **类型类与抽象数据类型的比较**

- **在类型理论中，抽象数据类型和类型类由完全相同的构造建模。**

- **区别在于它们的使用方式：**

  - 在 Miranda 的 abstype 声明中，签名被定义并立即绑定到特定的实现。

  - 使用 abstype 的代码必须能够使用签名的任何实现，因此可以被视为适当类型类上的函数。

  - 类型类的新颖之处在于，这些针对类型类的函数可以被显式地声明，并且可以在给定范围内应用于多个实现。

---

#### **类型类与面向对象编程**

- **类型类可以被视为向函数式语言添加了面向对象编程的一个方面。**

  - 类型类的成员可以被视为对象。

- **多重继承的支持：**

  - 通过向签名添加更多操作，可以定义一个类的子类。

  - **示例：**

    - 给定类 $C_1 \equiv_{\text{df}} (\exists t : U_0).\ S_1$，可以通过扩展签名 $S_1$ 为 $S_2$ 来定义子类 $C_2$。

  - **定义投影函数：**

    $$
    \pi_{2,1} : S_2 \rightarrow S_1
    $$

  - **定义遗忘函数 (forget function)：**

    $$
    \text{forget}_{2,1} : C_2 \rightarrow C_1 \\
    \text{forget}_{2,1} \equiv_{\text{df}} \lambda p.\ (\text{Fst}\ p,\ \pi\ (\text{Snd}\ p))
    $$

  - **应用：**

    - 任何定义在 $C_1$ 上的函数 $F : C_1 \rightarrow R$，都可以通过与遗忘函数组合来应用于 $C_2$ 的成员：

      $$
      F \circ \text{forget}_{2,1} : C_2 \rightarrow R
      $$

- **结论：**

  - 类型类机制支持面向对象编程中的继承特性，可以在函数式语言中实现类似的设计模式。

---

### **总结**

在本节中，我们深入探讨了全称量化和存在量化在宇宙上的应用，以及它们在类型理论中的重要性。我们看到了如何利用全称量化来定义参数化的多态函数，以及如何通过存在量化来表示抽象数据类型和类型类。我们还讨论了弱类型表示，以及它们与类型的消解规则之间的关系。

通过这些讨论，我们理解了类型理论的强大表达能力，以及如何利用类型系统来精确地描述程序的行为和性质。这为构建安全可靠的软件系统提供了坚实的理论基础。

如果您对上述内容有任何疑问，或者希望进一步深入了解某个主题，请随时告诉我！

### ---------------------------

### **6.4 案例研究 – 向量 (A Case Study – Vectors)**

#### **概述：**

向量 (Vectors) 是来自给定类型的固定长度序列。在类型理论中，向量可以被建模为列表类型 \([A]\) 的子类型 \([A]_n\)，其中 \(n\) 是长度。然而，本节将探索一种不同的方法，即将向量表示为在有限类型 (finite types) 上的函数。我们将首先重新定义有限类型，然后定义向量，最后展示如何在不同长度的向量上统一地定义函数。

---

### **6.4.1 重新审视有限类型 (Finite Types Revisited)**

#### **问题的引入：**

在 \(TT\) 系统中，包含了有限类型 \(N_n\)，它们似乎是向量域的明显候选。然而，为什么它们不适用呢？

- **原因：** 这些有限类型 \(N_n\) 不是以统一的方式定义的。换句话说，在类型理论中无法定义映射 \(n \mapsto N_n\)。这使得在不同大小的向量上统一地定义函数变得困难。

#### **解决方案：**

为了克服这个问题，我们将展示如何将有限类型统一地定义为自然数 \(\mathbb{N}\) 的子类型。

---

#### **“小于”关系的定义：**

首先，回顾在第 6.1.2 节中定义的“**小于**”关系 \(<\)：

1. **基准情况：**

   - \(m < 0 \equiv_{\text{df}} \text{False}\)
     - **解释：** 任何自然数都不小于 0。

2. **递归定义：**

   - \(0 < (n + 1) \equiv_{\text{df}} \text{True}\)
     - **解释：** 0 小于任何大于 0 的自然数。

   - \((m + 1) < (n + 1) \equiv_{\text{df}} m < n\)
     - **解释：** 通过递归地将比较转化为较小的数。

---

#### **证明“<”是自然数上的全序关系：**

##### **定理 6.6**

**命题：** 关系“<”是自然数上的全序关系，即以下命题都是可证的：

1. **反自反性 (Irreflexivity)**：\(\neg (x < x)\)
2. **反对称性 (Antisymmetry)**：\(\neg (x < y \land y < x)\)
3. **传递性 (Transitivity)**：\((x < y) \Rightarrow (y < z) \Rightarrow (x < z)\)
4. **完全性 (Totality)**：\((x < y) \lor (x = y) \lor (x > y)\)
5. **后继性 (Successor)**：\(x < x + 1\)

##### **证明：**

我们对每个部分进行归纳证明。

---

**1. 反自反性 (Irreflexivity)**：证明 \(\neg (x < x)\)

- **归纳基础 (Base Case)：**
  
  - 对于 \(x = 0\)，有 \(0 < 0\)。
  - 根据定义 \(m < 0 \equiv \text{False}\)，所以 \(0 < 0\) 为假，即 \(\neg (0 < 0)\) 成立。

- **归纳假设 (Inductive Hypothesis)：**
  
  - 假设对于 \(x = n\)，有 \(\neg (n < n)\)。

- **归纳步骤 (Inductive Step)：**

  - 需要证明对于 \(x = n + 1\)，有 \(\neg (n + 1 < n + 1)\)。
  
  - 根据定义：
    
    $$
    n + 1 < n + 1 \equiv m < n
    $$
  
    其中 \(m = n\)，所以需要验证 \(n < n\)。
  
  - 根据归纳假设，\(n < n\) 为假，因此 \(n + 1 < n + 1\) 也为假，即 \(\neg (n + 1 < n + 1)\) 成立。

---

**2. 反对称性 (Antisymmetry)**：证明 \(\neg (x < y \land y < x)\)

- **思路：**

  - 如果 \(x < y\) 且 \(y < x\)，那么根据反自反性和传递性，会导致矛盾。

- **证明：**

  - 假设 \(x < y\) 且 \(y < x\)，那么根据传递性，\(x < x\)，这与反自反性矛盾。

---

**3. 传递性 (Transitivity)**：证明 \((x < y) \Rightarrow (y < z) \Rightarrow (x < z)\)

- **归纳证明：**

  - 对于 \(x\)、\(y\)、\(z\) 进行归纳，利用定义中的递归关系，证明如果 \(x < y\) 且 \(y < z\)，则 \(x < z\)。

---

**4. 完全性 (Totality)**：证明 \((x < y) \lor (x = y) \lor (x > y)\)

- **归纳基础：**

  - 对于 \(x = 0\)：

    - 如果 \(y = 0\)，则 \(x = y\) 成立。

    - 如果 \(y > 0\)，则根据定义 \(0 < y\) 成立，因此 \(x < y\)。

- **归纳步骤：**

  - 假设对于 \(x = n\)，命题成立。

  - 对于 \(x = n + 1\)：

    - 对于任意 \(y\)，根据归纳假设，有 \(n < y\) 或 \(n = y\) 或 \(n > y\)。

    - 需要证明 \(n + 1 < y\)、\(n + 1 = y\) 或 \(n + 1 > y\) 中的一个成立。

    - 通过分析 \(y\) 的值，分情况讨论，可以证明完全性成立。

---

**5. 后继性 (Successor)**：证明 \(x < x + 1\)

- **归纳基础：**

  - 对于 \(x = 0\)，有 \(0 < 1\)。根据定义，\(0 < n + 1 \equiv \text{True}\)，所以 \(0 < 1\) 成立。

- **归纳步骤：**

  - 假设对于 \(x = n\)，有 \(n < n + 1\)。

  - 需要证明 \(n + 1 < n + 2\)。

  - 根据定义：

    $$
    n + 1 < n + 2 \equiv n + 1 < (n + 1) + 1
    $$

    - 通过递归定义，可以得出 \(n + 1 < n + 2\) 成立。

---

#### **有限类型的统一定义：**

##### **定义 6.7**

**有限类型 \(C_n\) 定义为：**

$$
C_n \equiv_{\text{df}} (\exists m : \mathbb{N}).\ (m < n)
$$

- **解释：**

  - \(C_n\) 是所有小于 \(n\) 的自然数 \(m\) 的集合，即 \(\{ m \in \mathbb{N} \mid m < n \}\)。

- **优点：**

  - 这种定义在变量 \(n\) 上是统一的，解决了之前 \(N_n\) 无法统一定义的问题。

---

#### **有限类型之间的嵌入：**

- **利用“<”的传递性，可以定义从 \(C_p\) 到 \(C_q\) 的规范嵌入 (canonical embedding)**：

  $$
  f_{p,q} : C_p \rightarrow C_q \quad \text{当 } p \leq q
  $$

- **定义：**

  - 如果 \(p = q\)，则 \(f_{p,q}\) 是恒等函数。

  - 如果 \(p < q\)，对于任意 \((m, r) : C_p\)，有 \(m < p < q\)，因此 \(m < q\)，于是 \((m, s) : C_q\)，其中 \(s\) 是不等式 \(m < q\) 的证明。

---

#### **与 \(N_n\) 类型的比较：**

##### **定理 6.8**

**对于每个 \(C_n\)，以下命题是可证明的：**

$$
(\forall x : C_n).\ (x = 0 \lor x = 1 \lor \dots \lor x = n - 1)
$$

- **解释：**

  - \(C_n\) 的元素只能是 \(0\) 到 \(n - 1\) 之间的自然数。

- **证明：**

  - **元理论上的归纳 (Meta-theoretic Induction)**：

    - 我们对 \(n\) 进行元理论上的归纳，因为在类型理论中无法统一地形式化所断言的公式序列，因此无法形式化证明。

---

#### **对 \(C_n\) 的进一步讨论：**

- **\(C_n\) 是否具有与 \(N_n\) 完全相同的性质？**

  - **结论：** 给定上述命题，两种类型的元素引入规则是等价的。

- **cases\_n 构造的表示：**

  - 可以通过定义一个以 \(C_n\) 为定义域的函数来表示 cases\_n 构造。

  - **具体方法：**

    - 考虑到不同值的不同类型，我们可以将它们映射到一个和类型 (sum type) 中。

    - **模型化 cases\_n：**

      $$
      (\lambda m : N_n).\ \text{cases\_n}\ m\ a_1\ \dots\ a_n
      $$

      - 其中 \(a_i : A_i\)。

    - **定义函数：**

      $$
      (\lambda x : C_n).\ \begin{cases}
      \text{in}_1\ a_1, & \text{if } \text{eqn}\ x\ 0 \\
      \text{in}_2\ a_2, & \text{if } \text{eqn}\ x\ 1 \\
      \vdots & \vdots \\
      \text{in}_n\ a_n, & \text{otherwise}
      \end{cases}
      $$

      - **类型：**

        $$
        C_n \rightarrow (A_1 \lor A_2 \lor \dots \lor A_n)
        $$

      - **解释：**

        - 使用 \(\text{in}_k\) 表示第 \(k\) 个组件类型 \(A_k\) 到和类型的注入。

        - \(\text{eqn}\) 是 \(C_n\) 上的等于函数。

---

### **练习**

#### **练习 6.25**

**证明以下命题是可证的（给定加法和乘法的定义）：**

1. \((a < b) \land (c < d) \Rightarrow (a + c < b + d)\)
2. \((a < b) \land (0 < c) \Rightarrow (a \times c < b \times c)\)

**提示：**

- 利用“小于”关系的定义和性质，对加法和乘法进行归纳证明。

---

### **6.4.2 向量 (Vectors)**

#### **向量类型的定义：**

##### **定义 6.9**

**长度为 \(n\) 的类型为 \(A\) 的向量类型 $\text{Vec } A\ n$ 定义为：**

$$
\text{Vec } A\ n \equiv_{\text{df}} (C_n \rightarrow A)
$$

- **解释：**

  - 向量被表示为从有限类型 \(C_n\) 到 \(A\) 的函数。

  - 这种定义在 \(A\) 和 \(n\) 上都是统一的，因此向量操作的定义可以以 \(A\)、\(n\) 或两者为参数。

---

#### **向量操作的定义：**

##### **1. 常量向量 (Constant Vector)**

- **函数类型：**

  $$
  \text{const} : (\forall A : U_0).\ (\forall n : \mathbb{N}).\ (A \rightarrow \text{Vec } A\ n)
  $$

- **定义：**

  $$
  \text{const}\ A\ n\ a \equiv_{\text{df}} \lambda x.\ a
  $$

- **解释：**

  - 给定一个类型 \(A\)、长度 \(n\) 和一个元素 \(a : A\)，\(\text{const}\) 返回一个所有元素都为 \(a\) 的向量。

---

##### **2. 更新向量 (Update Vector)**

- **函数类型：**

  $$
  \text{update}\ A\ n : \text{Vec } A\ n \rightarrow C_n \rightarrow A \rightarrow \text{Vec } A\ n
  $$

- **定义：**

  $$
  \text{update}\ A\ n\ v\ m\ b \equiv_{\text{df}} \lambda x.\ \begin{cases}
  b, & \text{if } \text{eqn}\ m\ x \\
  v\ x, & \text{otherwise}
  \end{cases}
  $$

- **解释：**

  - 给定向量 \(v\)，在位置 \(m\) 上更新为元素 \(b\)，返回新的向量。

  - \(\text{eqn}\) 是 \(C_n\) 上的等于函数。

---

##### **3. 向量的置换 (Permutation of Vector)**

- **表示：**

  - 索引 \(C_n\) 的置换由一个函数 \(p : C_n \rightarrow C_n\) 表示。

- **操作：**

  - 向量 \(v\) 的元素通过与置换 \(p\) 组合来进行置换：

    $$
    v' = v \circ p
    $$

- **解释：**

  - 新的向量 \(v'\) 是通过将 \(p\) 应用于索引，并将结果映射到原向量 \(v\) 上得到的。

---

##### **4. 向量的归约 (Reduction of Vector)**

- **目标：**

  - 给定类型 \(A\) 上的二元运算 \(\theta : A \rightarrow A \rightarrow A\)，我们希望对向量进行归约，计算：

    $$
    ((\dots (a_1\ \theta\ a_2)\ \theta\ \dots )\ \theta\ a_n)
    $$

- **函数类型：**

  $$
  (\forall A : U_0).\ (\forall n : \text{Pos}).\ ((A \rightarrow A \rightarrow A) \rightarrow \text{Vec } A\ n \rightarrow A)
  $$

  - 其中 \(\text{Pos}\) 是正自然数的集合，即 \(\text{Pos} = \{ n \in \mathbb{N} \mid n > 0 \}\)。

- **定义：**

  - **基础情况：** 对于长度为 1 的向量，直接返回唯一的元素。

  - **递归步骤：**

    - 对于长度为 \(n + 1\) 的向量 \(v = \langle a_1, a_2, \dots, a_n, a_{n+1} \rangle\)，首先对前 \(n\) 个元素的子向量 \(v'\) 进行归约，得到结果 \(r\)。

    - 然后计算 \(r\ \theta\ a_{n+1}\) 得到最终结果。

- **关键点：**

  - 需要解释如何访问向量的元素和构造子向量。

- **元素访问：**

  - 给定 \(m : C_n\) 和 \(w : \text{Vec } A\ n\)，第 \(m\) 个元素由 \(w\ m\) 给出。

- **子向量的构造：**

  - 从 \(v : \text{Vec } A\ (n + 1)\) 构造 \(v' : \text{Vec } A\ n\)，可以通过复合函数实现：

    $$
    v' = v \circ f_{n,n+1}
    $$

    - 其中 \(f_{n,n+1} : C_n \rightarrow C_{n+1}\) 是由定理 6.6 给出的规范嵌入。

---

### **练习**

#### **练习 6.26**

**问题：**

为计算数值向量的内积 (inner product) 的函数给出类型和定义。

**提示：**

- 内积通常定义为两个向量对应元素的乘积之和。

- 考虑定义一个函数，接受两个向量和一个乘法运算符，以及一个加法运算符，返回一个数值。

---

#### **练习 6.27**

**问题：**

你将如何定义向量的一般排序函数？

**提示：**

- 考虑使用之前定义的排序函数，将其适用于向量。

- 注意到向量的索引是有限类型，可以利用这一点。

---

#### **练习 6.28**

**问题：**

解释如何将上述模型扩展到处理任意维度的矩形数组 (rectangular arrays)。

**提示：**

- 考虑将向量的定义推广到多维的情况。

- 可以将多维数组表示为从索引元组（由多个有限类型的笛卡尔积形成）到元素类型的函数。

---

#### **练习 6.29**

**问题：**

使用前一个问题中定义的类型，定义数组的乘积和求逆 (inversion) 操作。在后者的情况下，你可以使用一个子类型来将定义域限制为那些具有逆的数组。

**提示：**

- 数组的乘积可以定义为矩阵乘法。

- 求逆操作需要确保数组是可逆的（例如，矩阵是非奇异的），可以通过子类型来限制。

---

### **总结**

在本节中，我们探讨了如何在类型理论中统一地定义向量和有限类型。通过将有限类型定义为自然数的子类型，我们能够统一地处理不同大小的向量，并以参数化的方式定义向量操作。我们还展示了如何定义常量向量、更新向量、向量的置换和归约操作。

通过这些定义，我们为进一步处理更复杂的数据结构（如矩阵和多维数组）奠定了基础。在练习中，我们鼓励您思考如何扩展这些概念，以处理更高维度的数组，以及如何定义数组的乘积和求逆操作。

如果您对上述内容有任何疑问，或者希望深入了解某个主题，请随时告诉我！

### ----------------------------

### **6.5 证明提取；自顶向下的证明 (Proof Extraction; Top-Down Proof)**

#### **概述：**

在之前的示例中，我们将系统视为一种函数式编程语言，主要关注对象、它们的类型以及它们的计算行为。然而，我们可以采用一种不同的方式来呈现规则，在这种方式中，我们可以省略一些关于证明对象 (proof objects) 的信息。尽管如此，我们仍然可以从给定的推导中提取证明对象。这种方法是 Nuprl 系统 [C+86a] 的基础。前两个示例在 [C+86a，第 4.3 和 4.4 节] 中进行了讨论，读者可以比较这两种处理方式。

---

### **6.5.1 命题逻辑 (Propositional Logic)**

#### **省略证明信息的规则**

- 在命题逻辑的规则中，如果我们以 \((\lor E_0)\) 作为析取消解 (disjunction elimination) 的规则，它们具有一个有趣的特征：它们所涉及的判断

  $$
  \text{proof} : \text{proposition}
  $$

  的左右两边之间没有直接的联系。

- 以规则 \((\lor E_0)\) 为例，我们可以从规则中剥离证明信息，留下：

  $$
  \frac{A \lor B \quad [A] \quad \vdots \quad C \quad [B] \quad \vdots \quad C}{C} \quad (\lor E_0)
  $$

- **解释：**

  - 当然，我们仍然知道，给定适当的假设证明，我们可以形成证明对象 \(\text{vcases0}_{x,y}\ p\ u\ v\)，它证明了结论 \(C\)。

- **无证明信息的规则的另一种解读：**

  - **自顶向下 (top-down) 的解读：**

    - 为了从假设 \(\Gamma\) 推导出 \(C\)，只需从 \(\Gamma\) 推导出 \(A \lor B\)，并在假设 \(A\) 和 \(B\)（连同 \(\Gamma\)）的情况下分别推导出 \(C\)。

- **其他规则的类似解读：**

  - **对 \((\Rightarrow I)\) 规则：**

    - 可以理解为：

      - 为了推导出 \(A \Rightarrow B\)，只需在增加假设 \(A\) 的情况下推导出 \(B\)。

---

#### **示例：公式的“无证明”推导**

**目标：**

证明公式：

$$
(P \lor \lnot P) \Rightarrow (\lnot P \Rightarrow \lnot Q) \Rightarrow (Q \Rightarrow P)
$$

**步骤：**

1. **应用 \((\Rightarrow I)\) 规则三次（自顶向下）：**

   - 为了证明上述公式，只需在假设

     $$
     (P \lor \lnot P),\ (\lnot P \Rightarrow \lnot Q),\ Q
     $$

     的情况下推导出 \(P\)。

2. **应用 \((\lor E_0)\) 规则的自顶向下解读：**

   - 为了从上述假设中推导出 \(P\)，只需分别在以下两组假设下推导出 \(P\)：

     1. \(P,\ (\lnot P \Rightarrow \lnot Q),\ Q\)
     2. \(\lnot P,\ (\lnot P \Rightarrow \lnot Q),\ Q\)

3. **对第一组假设：**

   - 由于 \(P\) 本身就是假设，因此直接得出 \(P\)。

4. **对第二组假设：**

   - 应用 **Modus Ponens**（即 \((\Rightarrow E)\) 规则）：

     - 从 \(\lnot P\) 和 \(\lnot P \Rightarrow \lnot Q\) 推导出 \(\lnot Q\)。

     - 从 \(\lnot Q\) 和 \(Q\) 推导出矛盾 \(\bot\)。

     - 根据 **爆炸原理 (ex falso quodlibet)**，从矛盾可以推出任何命题，特别是可以推出 \(P\)。

5. **观察：**

   - 通常情况下，自顶向下的推导会达到某个点，此后需要采用自底向上的方法。

---

#### **将上述描述形式化为推导**

- **第一步：**

  $$
  \begin{array}{c}
  P \lor \lnot P \quad [P]_1 \quad Q \\
  [\lnot P]_1 \quad \lnot P \Rightarrow \lnot Q \\
  \lnot Q \quad (\Rightarrow E) \\
  \bot \quad (\Rightarrow E) \\
  P \quad (\bot I) \\
  P \quad (\lor E_0)_1
  \end{array}
  $$

- **解释：**

  - 在第一组假设中，\(P\) 是假设，直接得出 \(P\)。

  - 在第二组假设中，从 \(\lnot P\) 和 \(\lnot P \Rightarrow \lnot Q\) 推导出 \(\lnot Q\)，然后与 \(Q\) 矛盾，得出 \(\bot\)，进而推出 \(P\)。

- **第二步：消除假设**

  - **消除假设的过程：**

    $$
    \begin{array}{c}
    [P \lor \lnot P]_4 \\
    [P]_1 \\
    [Q]_2 \\
    [\lnot P]_1 \\
    [\lnot P \Rightarrow \lnot Q]_3 \\
    \vdots \\
    P \\
    P \quad (\lor E_0)_1 \\
    Q \Rightarrow P \quad (\Rightarrow I)_2 \\
    \lnot P \Rightarrow \lnot Q \Rightarrow (Q \Rightarrow P) \quad (\Rightarrow I)_3 \\
    (P \lor \lnot P) \Rightarrow (\lnot P \Rightarrow \lnot Q) \Rightarrow (Q \Rightarrow P) \quad (\Rightarrow I)_4
    \end{array}
    $$

- **解释：**

  - 通过逐步应用 \((\Rightarrow I)\) 规则，消除了假设，得到了原始公式的证明。

---

#### **提取证明对象**

- **为假设命名并构造证明项：**

  - 设：

    - \(x : (P \lor \lnot P)\)
    - \([u : P]_1\)
    - \([z : Q]_2\)
    - \([v : \lnot P]_1\)
    - \([y : \lnot P \Rightarrow \lnot Q]\)_3

- **构造证明：**

  1. **在第一种情况下（\(P\) 为真）：**

     - 直接使用假设 \(u : P\)。

  2. **在第二种情况下（\(\lnot P\) 为真）：**

     - 计算 \((y\ v) : \lnot Q\)。

     - 然后计算 \(((y\ v)\ z) : \bot\)。

     - 使用 \(\text{abort}_P ((y\ v)\ z) : P\)。

  3. **应用 \((\lor E_0)\) 规则：**

     - 使用 \(\text{cases0}_{u,v}\ x\ u\ (\text{abort}_P ((y\ v)\ z)) : P\)。

- **最终的证明对象：**

  - 设 \(e \equiv \text{cases0}_{u,v}\ x\ u\ (\text{abort}_P ((y\ v)\ z))\)。

  - 则完整的证明对象为：

    $$
    \lambda x.\ \lambda y.\ \lambda z.\ e
    $$

    - 也就是：

      $$
      \lambda x.\ \lambda y.\ \lambda z.\ (\text{cases0}_{u,v}\ x\ u\ (\text{abort}_P ((y\ v)\ z)))
      $$

- **解释：**

  - 这是原始公式的证明对象，表示从假设中构造出的证明。

---

### **6.5.2 谓词逻辑 (Predicate Logic)**

#### **扩展到谓词逻辑**

- **全称量词的规则：**

  - **引入规则 \((\forall I)\)：**

    $$
    \frac{[x : A] \quad \vdots \quad P}{(\forall x : A).\ P} \quad (\forall I)
    $$

  - **消解规则 \((\forall E)\)：**

    $$
    \frac{(\forall x : A).\ P \quad a : A}{P[a/x]} \quad (\forall E)
    $$

- **存在量词的规则：**

  - **引入规则 \((\exists I)\)：**

    $$
    \frac{a : A \quad P[a/x]}{(\exists x : A).\ P} \quad (\exists I)
    $$

  - **消解规则 \((\exists E_0)\)：**

    $$
    \frac{(\exists x : A).\ B \quad [x : A;\ B] \quad \vdots \quad C}{C} \quad (\exists E_0)
    $$

- **注意：**

  - 在这些规则中，某些证明信息似乎仍然存在，例如在 \((\exists I)\) 中的 \(a : A\)。

  - 由于逻辑是类型化的，为了确保命题的良构性，必须保留这些最小的类型信息。

---

#### **示例：从 \((\exists y : B).\ (\forall x : A).\ P\) 推导 \((\forall x : A).\ (\exists y : B).\ P\)**

**步骤：**

1. **假设 \((\exists y : B).\ (\forall x : A).\ P\)**。

2. **应用 \((\exists E_0)\) 规则：**

   - 引入假设 \([y : B]_2\) 和 \([q : (\forall x : A).\ P]_2\)。

3. **应用 \((\forall I)\) 规则（自顶向下）：**

   - 为了证明 \((\forall x : A).\ (\exists y : B).\ P\)，只需在假设 \(x : A\) 下证明 \((\exists y : B).\ P\)。

4. **应用 \((\forall E)\) 规则：**

   - 从 \(q : (\forall x : A).\ P\) 和 \(x : A\) 得到 \(P\)。

5. **应用 \((\exists I)\) 规则：**

   - 由 \(y : B\) 和 \(P\) 构造 \((\exists y : B).\ P\)。

6. **最终应用 \((\exists E_0)\) 规则：**

   - 通过消除假设，得到结论 \((\forall x : A).\ (\exists y : B).\ P\)。

---

#### **提取证明对象**

- **命名证明对象：**

  - \(p : (\exists y : B).\ (\forall x : A).\ P\)

- **构造证明：**

  1. **应用 \((\exists E_0)\) 规则：**

     - 使用 \(\text{Cases}_{y,q}\ p\ (\lambda x.\ (y, q\ x))\)。

  2. **最终的证明对象：**

     - \(\text{Cases}_{y,q}\ p\ (\lambda x.\ (y, q\ x))\)

- **解释：**

  - 该证明对象表示从假设 \(p\) 出发，通过提取 \(y\) 和 \(q\)，构造了所需的证明。

---

#### **关于强弱存在消解规则的讨论**

- **弱存在消解规则 \((\exists E_0)\)：**

  - 只提供存在语句的假设性见证 (hypothetical witness)。

- **强存在消解规则 \((\exists E)\) 或等价的 \((\exists E_0^2)\)：**

  - 在结论中引入了一个依赖于上方命题的证明对象的命题。

- **应用：**

  - 为了证明像选择公理这样的命题：

    $$
    (\forall x : A).\ (\exists y : B).\ P \Rightarrow (\exists f : A \rightarrow B).\ (\forall x : A).\ P[f(x)/y]
    $$

  - 需要显式地讨论证明项。

- **结论：**

  - 在需要推导涉及证明对象的结论时，必须显式地处理证明项。

---

### **6.5.3 自然数 (Natural Numbers)**

#### **扩展到涉及数据类型的结果**

- **自然数的引入规则保持不变，但可以重新表述 \((\text{NE})\) 规则：**

  $$
  \frac{n : \mathbb{N} \quad C[0/x] \quad (\forall n : \mathbb{N}).\ (C[n/x] \Rightarrow C[\text{succ } n/x])}{C[n/x]} \quad (\text{NE})
  $$

- **示例：证明 \((\forall n : \mathbb{N}).\ (0 < \text{fac } n)\)**

  - **其中 \(\text{fac}\) 的定义为：**

    $$
    \begin{align*}
    \text{fac } 0 &\equiv_{\text{df}} 1 \\
    \text{fac } (n + 1) &\equiv_{\text{df}} (n + 1) \times \text{fac } n
    \end{align*}
    $$

- **证明步骤：**

  1. **基础情况：**

     - 需要证明 \(0 < 1\)，这是 \(0 < n + 1\) 的特殊情况，易得。

  2. **归纳步骤：**

     - 需要证明：

       $$
       (\forall n : \mathbb{N}).\ ((0 < \text{fac } n) \Rightarrow (0 < \text{fac } (n + 1)))
       $$

     - 假设 \(n : \mathbb{N}\) 且 \(0 < \text{fac } n\)。

     - 由于 \(\text{fac } (n + 1) = (n + 1) \times \text{fac } n\)。

     - **结论：**

       - 只需证明正数的乘积为正数。

---

#### **练习 6.30**

**问题：**

对以下公式给出“无证明”的推导，并从你的推导中提取相应的证明对象：

1. \((B \lor C) \Rightarrow \lnot (\lnot B \land \lnot C)\)

2. \(A \Rightarrow \lnot \lnot A\)

3. \((\lnot A \lor \lnot B) \Rightarrow \lnot (A \land B)\)

**提示：**

- 使用自顶向下的方法，应用逻辑规则，逐步推导结论。

- 在推导完成后，提取相应的证明对象。

---

#### **练习 6.31**

**问题：**

找到公式

$$
(\forall x : X).\ (A \Rightarrow B) \Rightarrow ((\exists x : X).\ A \Rightarrow (\exists x : X).\ B)
$$

的“无证明”推导，并从推导中提取证明对象。

**提示：**

- 使用量词的引入和消解规则，结合蕴涵的规则，进行推导。

- 注意处理存在量词时的证明对象提取。

---

#### **练习 6.32**

**问题：**

形式化证明所有 \(\text{fac}\) 的值为正数的“无证明”推导，假设乘法的引理成立，并给出它生成的证明对象。

**提示：**

- 明确假设的引理：正数的乘积为正数。

- 使用数学归纳法，按照上述示例的方法，进行推导并提取证明对象。

---

#### **练习 6.33**

**问题：**

对自然数 \(\mathbb{N}\) 定义适当的乘法操作“\(\times\)”，给出正数的乘积为正数的引理的“无证明”推导。

**提示：**

- 定义乘法运算，确保其满足预期的性质。

- 使用归纳法和逻辑规则，推导结论。

---

### **总结**

在本节中，我们探讨了如何在推导中省略证明对象的信息，同时仍然能够从推导中提取出完整的证明对象。这种方法在某些逻辑系统中非常有用，例如 Nuprl 系统。通过自顶向下的推导方法，我们可以更直观地理解证明过程，并在需要时恢复完整的证明对象。

我们首先在命题逻辑中应用了这种方法，展示了如何对公式进行“无证明”的推导，并从中提取证明对象。接着，我们将其扩展到谓词逻辑，讨论了量词的规则以及如何处理存在量词的证明对象。最后，我们将该方法应用于自然数，展示了如何证明涉及数据类型的命题。

通过练习，读者可以进一步巩固对这种方法的理解，并练习在推导中提取证明对象的技巧。

如果您对上述内容有任何疑问，或者希望深入了解某个主题，请随时告诉我！

### ---------------------------

### **6.6 程序开发 – 波兰国旗问题 (Program Development – Polish National Flag)**

#### **概述：**

本节探讨了**波兰国旗问题**，这是**荷兰国旗问题**的一个非本质性的简化。该问题最初在 [Dij76] 中提出。在类型理论的背景下，首次在 [PS85] 中研究，后来在 [NPS90] 的第 22.2 节中进一步探讨。问题的简单描述如下：

- **输入：** 一个由红色或白色项组成的序列。
- **输出：** 一个排列后的序列，使得所有红色项都在白色项之前。

#### **我们的方法：**

我们的方法与 [NPS90] 中的方法有两点不同：

1. **规范的表达方式不同：**

   - 我们将**计算部分**与**证明理论部分**分离。

2. **避免使用子集类型 (subset type)：**

   - 我们将在第 7 章中详细讨论子集类型。

此外，我们使用了一种更接近大多数函数式编程语言的**等式符号表示法**。

---

#### **依赖的函数和谓词：**

- **列表连接运算符：** $++$
  
- **排列谓词：** \(\text{perm } l\ m\)

  - 表示列表 $l$ 是列表 $m$ 的一个**排列**。

- **计数辅助函数：** \(\text{occs } a\ l\)

  - 计算元素 $a$ 在列表 $l$ 中出现的次数。

- **颜色的表示：**

  - 使用布尔类型 $\text{bool}$（我们将其缩写为 $C$）表示**颜色**。

  - 值 $\text{True}$ 表示**红色**。

- **定义红色和白色的判定函数：**

  - **红色：** $\text{isRed } a \equiv_{\text{df}} a = \text{True}$

  - **白色：** $\text{isWhite } a \equiv_{\text{df}} a = \text{False}$

- **定义全红列表的谓词：**

  - **类型：** \(\text{allRed} : [\text{bool}] \rightarrow U_0\)

  - **定义：**
    $$
    \begin{cases}
    \text{allRed } [\ ] \equiv_{\text{df}} \top \\
    \text{allRed } (a :: x) \equiv_{\text{df}} \text{isRed } a \land \text{allRed } x
    \end{cases}
    $$

  - **解释：**

    - 当列表为空时，显然是全红的。

    - 当列表为 $a :: x$ 时，只有当 $a$ 是红色且 $x$ 是全红的，列表才是全红的。

- **全白列表的谓词：**

  - 类似地定义 $\text{allWhite}$，将 $\text{isRed}$ 替换为 $\text{isWhite}$。

---

#### **问题的规范表达：**

- **第一种表达方式：**

  - **公式 (6.5)：**
    $$
    (\forall l : [C]).\ (\exists (l',\ l'') : [C] \times [C]).\ (\text{allRed } l' \land \text{allWhite } l'' \land \text{perm } l\ (l' ++ l''))
    $$

  - **解释：**

    - 对于每个颜色列表 $l$，存在两个列表 $l'$ 和 $l''$，使得：

      1. $l'$ 是全红的。

      2. $l''$ 是全白的。

      3. $l$ 是 $l' ++ l''$ 的一个排列。

- **我们的目标：**

  - 实际上，我们希望得到一个**函数**，针对每个 $l$ 返回对应的列表对 $(l',\ l'')$。

- **修改后的规范：**

  - **公式 (6.6)：**
    $$
    (\exists f : [C] \rightarrow [C] \times [C]).\ (\forall l : [C]).\ \text{allRed } (\text{fst } (f\ l)) \land \text{allWhite } (\text{snd } (f\ l)) \land \text{perm } l\ ((\text{fst } (f\ l)) ++ (\text{snd } (f\ l)))
    $$

  - **解释：**

    - 存在一个函数 $f$，使得对于所有列表 $l$：

      1. $\text{fst } (f\ l)$ 是全红的。

      2. $\text{snd } (f\ l)$ 是全白的。

      3. $l$ 是 $(\text{fst } (f\ l)) ++ (\text{snd } (f\ l))$ 的一个排列。

---

#### **证明的组成：**

- **证明 (6.6) 的内容：**

  - **一个对 $(f,\ p)$：**

    - $f : [C] \rightarrow [C] \times [C]$

    - $p$ 是一个证明，证明对于所有列表 $l$ 都有：
      $$
      \text{allRed } (\text{fst } (f\ l)) \land \text{allWhite } (\text{snd } (f\ l)) \land \text{perm } l\ ((\text{fst } (f\ l)) ++ (\text{snd } (f\ l)))
      $$

- **解释：**

  - 这个对 $(f,\ p)$ 恰好由所需的函数及其满足规范的证明组成。

  - 这是类型理论中规范的一般形式——我们将在第 7 章中回到这个主题。

---

#### **规范转换的依据：**

- **从 (6.5) 到 (6.6) 的转换：**

  - **应用选择公理 (axiom of choice)：**

    - **陈述：**
      $$
      (\forall x : A).\ (\exists y : B).\ P(x, y) \Rightarrow (\exists f : A \rightarrow B).\ (\forall x : A).\ P(x, f(x))
      $$

    - **解释：**

      - 如果对于所有 $x : A$，存在 $y : B$ 使得 $P(x, y)$ 成立，那么存在一个函数 $f : A \rightarrow B$，使得对于所有 $x : A$，$P(x, f(x))$ 成立。

  - **等价性：**

    - 在给定选择公理的情况下，规范 (6.5) 和 (6.6) 在逻辑上是等价的。

- **证明：**

  - 证明这个类型是**可居住的 (inhabited)**，即存在这样的 $f$ 和 $p$。

  - 读者可以在 [ML85] 中找到证明。

---

#### **证明 (6.6) 的两种方法：**

1. **方法一：**

   - **给出一个函数 $f$，并证明公式 (6.7)：**

     - **过程：**

       1. 首先定义一个我们认为具有所需性质的函数 $f$。

       2. 单独证明 $f$ 具有该性质。

     - **对应于传统的程序开发：**

       - 在函数式编程语言中，这相当于程序验证的练习。

     - **示例：**

       - 在第 6.2 节中，我们使用这种方法开发了快速排序算法。

2. **方法二：**

   - **从顶向下 (top-down) 开发证明，化简存在性陈述 (6.6) 到 (6.5)：**

     - **过程：**

       1. 直接尝试证明公式 (6.5)。

       2. 从证明中应用选择公理提取函数。

     - **程序提取技术：**

       - 我们将在这里采用这种方法。

     - **注意：**

       - 两种方法都可能导致所需函数的相同定义。

---

#### **使用第一种方法定义函数：**

- **定义函数 $\text{split}$：**

  - **类型：**
    $$
    \text{split} : [C] \rightarrow [C] \times [C]
    $$

  - **定义：**
    $$
    \begin{cases}
    \text{split } [\ ] \equiv_{\text{df}} ([\ ],\ [\ ]) \\
    \text{split } (a :: m) \equiv_{\text{df}} \begin{cases}
    (a :: l',\ l''), & \text{if } a = \text{True} \\
    (l',\ a :: l''), & \text{if } a = \text{False}
    \end{cases}
    \end{cases}
    $$
    - 其中 $(l',\ l'') \equiv \text{split } m$。

- **验证：**

  - 通过归纳法验证 $\text{split}$ 满足性质 (6.7)。

---

#### **使用第二种方法直接证明结果 (6.5)：**

##### **定理 6.10**

**命题：** 对于所有列表 $l : [C]$，
$$
(\exists (l',\ l'') : [C] \times [C]).\ (\text{allRed } l' \land \text{allWhite } l'' \land \text{perm } l\ (l' ++ l''))
$$

##### **证明：**

我们对列表 $l$ 进行**归纳证明**。令命题 $P(l)$ 表示上述断言。

---

**1. 基础情况：**

- **当 $l \equiv [\ ]$ 时：**

  - **证明：**

    - 显然，类型 $\text{allRed } [\ ]$ 和 $\text{allWhite } [\ ]$ 是可居住的。

    - 由于 $[\ ] ++ [\ ] \equiv [\ ]$，且根据排列的**自反性**（参见引理 6.2，第 12 条），我们有：
      $$
      \text{perm } [\ ]\ ([\ ] ++ [\ ]) \text{ 是可证明的。}
      $$

    - 将证明对象组合在一起，我们得到了：
      $$
      p_0 : P([\ ])
      $$

---

**2. 归纳步骤：**

- **假设对于列表 $m$，$P(m)$ 成立，即存在 $p_m : P(m)$。**

- **对于列表 $l \equiv a :: m$：**

  - **已知：**

    - $p_m \equiv ((l',\ l''),\ q)$，其中：

      - $q \equiv (q_1,\ q_2,\ q_3)$

      - $(q_1,\ q_2,\ q_3) : (\text{allRed } l' \land \text{allWhite } l'' \land \text{perm } m\ (l' ++ l''))$

  - **由于布尔类型只有两个值，$a$ 要么是红色（$\text{isRed } a$），要么是白色（$\text{isWhite } a$）。**

---

**情况分析：**

1. **当 $\text{isWhite } a$ 为真时：**

   - **构造：**

     - $q'_2 \equiv_{\text{df}} (c_{\text{sw}},\ q_2) : \text{allWhite } (a :: l'')$

       - 其中 $c_{\text{sw}} : \text{isWhite } a$。

     - $q_1 : \text{allRed } l'$

   - **根据排列的性质（引理 6.2，第 9 和 11 条），可以找到：**

     - $q'_3 : \text{perm } (a :: m)\ (l' ++ (a :: l''))$

       - $q'_3$ 依赖于证明对象 $q_3$。

   - **组合：**

     - $q_w \equiv_{\text{df}} (q_1,\ q'_2,\ q'_3) : (\text{allRed } l' \land \text{allWhite } (a :: l'') \land \text{perm } (a :: m)\ (l' ++ (a :: l'')))$

   - **得到：**

     - $p_w \equiv_{\text{df}} ((l',\ a :: l''),\ q_w) : P(a :: m)$

2. **当 $\text{isRed } a$ 为真时：**

   - **类似地，构造：**

     - $q'_1 \equiv_{\text{df}} (c_{\text{sr}},\ q_1) : \text{allRed } (a :: l')$

       - 其中 $c_{\text{sr}} : \text{isRed } a$。

     - $q_2 : \text{allWhite } l''$

     - $q'_3 : \text{perm } (a :: m)\ ((a :: l') ++ l'')$

   - **组合：**

     - $q_r \equiv_{\text{df}} (q'_1,\ q_2,\ q'_3) : (\text{allRed } (a :: l') \land \text{allWhite } l'' \land \text{perm } (a :: m)\ ((a :: l') ++ l''))$

   - **得到：**

     - $p_r \equiv_{\text{df}} ((a :: l',\ l''),\ q_r) : P(a :: m)$

---

**总结：**

- **由于每个元素 $a$ 要么是红色，要么是白色，我们可以定义：**
  $$
  p' \equiv_{\text{df}} \text{if } a = \text{True} \text{ then } p_r \text{ else } p_w : P(a :: m)
  $$

- **这给出了从 $a : C$、$m : [C]$ 和证明 $p_m : P(m)$ 构造 $P(a :: m)$ 的归纳步骤。**

---

**形式化推导：**

- **定义函数：**
  $$
  \lambda l.\ (\text{lrec } l\ p_0\ (\lambda a.\ \lambda m.\ \lambda q.\ p')) : (\forall l : [C]).\ P(l)
  $$

  - **解释：**

    - 使用列表的递归函数 $\text{lrec}$，基于基础情况 $p_0$ 和归纳步骤 $p'$，构造所需类型的对象。

- **因此，完成了所需类型对象的构造。**

---

#### **提取函数：**

- **我们可以看到，通过上述方法从证明中提取的函数，正是之前定义的 $\text{split}$ 函数。**

---

### **总结**

在本节中，我们探讨了波兰国旗问题的解决方案，展示了如何在类型理论中以两种不同的方法证明规范，并构造满足规范的函数。我们首先定义了问题，并给出了两种规范的表达方式。然后，我们讨论了如何应用选择公理将规范从存在性陈述转换为函数的存在。接着，我们展示了两种证明方法：一种是先定义函数再验证，另一种是直接从顶向下证明并提取函数。

通过详细的归纳证明，我们展示了如何直接证明规范，并从中提取出所需的 $\text{split}$ 函数。这一过程体现了类型理论中程序开发和证明之间的密切联系。

如果您对上述内容有任何疑问，或者希望深入了解某个主题，请随时告诉我！

### ----------------------------

### **6.7 程序转换 (Program Transformation)**

#### **概述：**

到目前为止，我们已经看到了在类型理论中进行程序构造的多种方法。本节将探讨**程序开发的转换方法**，展示如何在 $TT$ 系统内将一个程序转换为另一个具有相同行为但在时间、空间效率或可并行性等方面具有其他优点的程序。

---

#### **转换的起点：**

程序转换的起点可能有两种：

1. **直接编写反映规范的程序：**

   - 即所谓的“可执行规范 (executable specification)”。

2. **从证明中提取程序：**

   - 通常，证明为了达到结果，会使用“蛮力”而非精巧的方法。

---

#### **示例问题：**

- **目标：** 找到一个有限整数序列中连续段 (contiguous segment) 的最大和。
- **示例序列：**

  $$
  -2\quad 3\quad 4\quad -3\quad 5\quad -2\quad 1
  $$

  - 对于上述序列，标记的连续段 $3,\ 4,\ -3,\ 5$ 的和最大，为 9。

---

#### **程序转换的本质：**

- 将一个程序转换为另一个在应用行为 (applicative behavior) 上相同的程序，但在某些方面（如时间效率或空间使用）得到改进。
- 当两个函数对所有参数返回相同的结果时，它们具有相同的行为，即它们在外延上 (extensionally) 是相等的。
- 在 $TT$ 中，程序转换涉及通过一系列简单的相同类型的步骤，将一个对象替换为与其外延等价的另一个对象。

---

#### **实现序列的表示：**

- 在问题的讨论中，我们使用整数列表来表示序列。
- 整数的一个实现已经在第 136 页给出。

---

#### **讨论的开始：**

我们将首先介绍操作符 **map** 和 **fold**，并研究它们的一些性质，包括如何修改它们以在非空列表上操作。

- 如果您已经熟悉这些函数，可以直接跳到转换部分，必要时再返回查看。

---

### **6.7.1 map 和 fold**

#### **map 函数：**

- **作用：** 将一个函数应用于列表的每个元素。
- **递归定义：**

  $$
  \begin{align*}
  \text{map} &: (A \rightarrow B) \rightarrow [A] \rightarrow [B] \\
  \text{map } f\ [\ ] &\equiv_{\text{df}} [\ ] \\
  \text{map } f\ (a :: x) &\equiv_{\text{df}} (f\ a) :: (\text{map } f\ x)
  \end{align*}
  $$

- **形式化表示：**

  $$
  \lambda f.\ \lambda l.\ \text{lrec } l\ [\ ]\ h_f
  $$

  - 其中：

    $$
    h_f\ a\ l\ p \equiv_{\text{df}} (f\ a) :: p
    $$

- **性质：**

  - 根据 \(\land\) 引入规则和 \(\text{lrec}\) 的计算规则，可以看出对于所有 $f$，以下类型是可居住的（即存在这样的对象）：

    $$
    \text{map } f\ [\ ] = [\ ] \quad (6.9)
    $$

    $$
    \text{map } f\ (a :: x) = (f\ a) :: (\text{map } f\ x) \quad (6.10)
    $$

---

#### **组合操作符：**

- **定义：**

  $$
  (g \circ f) \equiv_{\text{df}} \lambda x.\ (g\ (f\ x))
  $$

- **说明：**

  - 为了可读性，我们将组合操作符 \(\circ\) 以中缀形式书写。

- **列表连接操作符：**

  - 回顾一下，操作符 $++$ 用于将两个列表连接起来。

---

#### **基本定律：**

后续的转换基于应用一些体现标准函数性质的通用“定律”。

---

##### **定理 6.11**

**命题：** 对于所有列表 $l$ 和 $m$，有：

$$
\text{map } f\ (l ++ m) = (\text{map } f\ l) ++ (\text{map } f\ m)
$$

##### **证明：**

- 对 $l$ 进行归纳证明。

---

##### **定理 6.12**

**命题：** 对于所有函数 $f$ 和 $g$，有：

$$
\text{map } g \circ \text{map } f = \text{map } (g \circ f)
$$

##### **证明：**

- 我们需要证明对于所有列表 $x$：

  $$
  (\text{map } g \circ \text{map } f)\ x = \text{map } (g \circ f)\ x
  $$

- **归纳基础：**

  - 当 $x = [\ ]$ 时：

    $$
    (\text{map } g \circ \text{map } f)\ [\ ] = \text{map } (g \circ f)\ [\ ]
    $$

  - 通过展开左边：

    $$
    (\text{map } g \circ \text{map } f)\ [\ ] = \text{map } g\ (\text{map } f\ [\ ]) = \text{map } g\ [\ ] = [\ ]
    $$

  - 右边同样等于 \([\ ]\)，因此基础情况成立。

- **归纳步骤：**

  - 假设对于列表 $x$，命题成立。

  - 对于列表 $a :: x$：

    $$
    (\text{map } g \circ \text{map } f)\ (a :: x) = \text{map } (g \circ f)\ (a :: x) \quad (6.12)
    $$

  - **展开左边：**

    $$
    \begin{align*}
    &\text{map } g\ (\text{map } f\ (a :: x)) \\
    =&\ \text{map } g\ ((f\ a) :: (\text{map } f\ x)) \\
    =&\ (g\ (f\ a)) :: (\text{map } g\ (\text{map } f\ x))
    \end{align*}
    $$

  - **根据归纳假设：**

    $$
    \text{map } g\ (\text{map } f\ x) = \text{map } (g \circ f)\ x
    $$

  - **因此：**

    $$
    (\text{map } g \circ \text{map } f)\ (a :: x) = (g\ (f\ a)) :: \text{map } (g \circ f)\ x = \text{map } (g \circ f)\ (a :: x)
    $$

  - **归纳步骤完成，证明成立。**

---

#### **fold 操作符：**

- **作用：**

  - 将非空列表的元素组合在一起，例如，通过折叠乘法操作符来获得列表元素的乘积。

- **定义：**

  $$
  \text{fold} : (A \rightarrow A \rightarrow A) \rightarrow \text{nel } A \rightarrow A
  $$

  - 其中，\(\text{nel } A\) 表示非空列表的类型。

- **非空列表的类型定义：**

  $$
  \text{nel } A \equiv_{\text{df}} (\exists l : [A]).\ (\text{nempty } l)
  $$

  - **其中 \(\text{nempty}\) 的定义：**

    $$
    \begin{cases}
    \text{nempty } [\ ] \equiv_{\text{df}} \bot \\
    \text{nempty } (a :: x) \equiv_{\text{df}} \top
    \end{cases}
    $$

- **fold 的定义：**

  $$
  \begin{cases}
  \text{fold } f\ ([\ ],\ p) \equiv_{\text{df}} \text{abort } A\ p \\
  \text{fold } f\ ((a :: [\ ]),\ p) \equiv_{\text{df}} a \\
  \text{fold } f\ ((a :: (b :: x)),\ p) \equiv_{\text{df}} f\ a\ (\text{fold } f\ ((b :: x),\ \text{Triv}))
  \end{cases}
  $$

  - **解释：**

    - 当列表为空时，调用 \(\text{abort } A\ p\)，其中 $p$ 是列表非空性的证明，这种情况实际上不会发生。

    - 当列表只有一个元素时，直接返回该元素。

    - 当列表有两个或更多元素时，递归地应用 $f$。

---

#### **在非空列表上定义 map 和 $++$：**

- **问题：**

  - 我们希望在非空列表上使用标准的 $\text{map}$ 和 $++$ 函数。

- **解决方案：**

  - 由于直接使用这些函数会遇到困难，我们可以定义它们的类似函数 $\text{map}_0$ 和 $++_0$，在类型 $\text{nel } A$ 上操作。

- **引理 6.13**

  **命题：** 如果 $l$ 和 $m$ 是非空的，那么 $\text{map } f\ l$ 和 $l ++ m$ 也是非空的。

  **证明：** 通过归纳证明。

- **根据引理，定义辅助函数：**

  - $\text{mapp}$ 和 $\text{appp}$：

    $$
    \begin{align*}
    \text{mapp} &: (\forall l : [A]).\ (\text{nempty } l) \rightarrow (\text{nempty } (\text{map } f\ l)) \\
    \text{appp} &: (\forall l, m : [A]).\ (\text{nempty } l) \rightarrow (\text{nempty } m) \rightarrow (\text{nempty } (l ++ m))
    \end{align*}
    $$

- **定义 $\text{map}_0$ 和 $++_0$：**

  $$
  \begin{cases}
  \text{map}_0\ f\ (l, p) \equiv_{\text{df}} (\text{map } f\ l,\ \text{mapp } l\ p) \\
  (l, p)\ ++_0\ (m, q) \equiv_{\text{df}} (l ++ m,\ \text{appp } l\ m\ p\ q)
  \end{cases}
  $$

  - **解释：**

    - 这些函数将计算与证明相结合，将参数的非空性证明信息传递给结果的非空性证明。

---

#### **定理及其证明：**

##### **定理 6.14**

**命题：** 对于所有函数 $f$ 和非空列表 $l_0$、$m_0$，有：

$$
\text{map}_0\ f\ (l_0 ++_0 m_0) = (\text{map}_0\ f\ l_0) ++_0 (\text{map}_0\ f\ m_0)
$$

##### **定理 6.15**

**命题：** 对于所有函数 $f$、$g$，有：

$$
\text{map}_0\ g \circ \text{map}_0\ f = \text{map}_0\ (g \circ f)
$$

- **证明：**

  - 与之前定理类似，证明过程省略。

---

##### **定理 6.16**

**命题：** 如果 $f$ 是一个结合函数（即对于所有 $a, b, c$，有 $f\ a\ (f\ b\ c) = f\ (f\ a\ b)\ c$），那么对于非空列表 $l_0$ 和 $m_0$，有：

$$
\text{fold } f\ (l_0 ++_0 m_0) = f\ (\text{fold } f\ l_0)\ (\text{fold } f\ m_0)
$$

- **证明：**

  - 对非空列表 $l_0$ 进行归纳。

---

##### **定理 6.17**

**命题：** 如果 $f$ 和 $g$ 满足 $f\ (g\ a)\ (g\ b) = g\ (f\ a\ b)$，那么：

$$
(\text{fold } f) \circ (\text{map}_0\ g) = g \circ (\text{fold } f)
$$

- **解释：**

  - 该定理描述了一个将先映射后折叠的过程转换为在折叠后应用单个函数的情况。

---

#### **foldr 操作符：**

- **定义：**

  $$
  \text{foldr} : (A \rightarrow B \rightarrow B) \rightarrow B \rightarrow [A] \rightarrow B
  $$

- **定义形式：**

  $$
  \begin{cases}
  \text{foldr } f\ \text{st}\ [\ ] \equiv_{\text{df}} \text{st} \\
  \text{foldr } f\ \text{st}\ (a :: x) \equiv_{\text{df}} f\ a\ (\text{foldr } f\ \text{st}\ x)
  \end{cases}
  $$

- **解释：**

  - \(\text{foldr}\) 实际上是递归操作符 \(\text{lrec}\) 的特例。

- **示例：**

  - 使用 \(\text{foldr}\) 可以定义许多列表操作，例如：

    $$
    \text{sum} \equiv_{\text{df}} \text{foldr } (+)\ 0
    $$

---

##### **定理 6.18**

**命题：** 对于所有函数 $f$ 和初始值 \(\text{st}\)，有：

$$
(\text{foldr } f\ \text{st}) \circ ((::)\ a) = (f\ a) \circ (\text{foldr } f\ \text{st})
$$

- **证明：**

  - 无需归纳，通过对两边展开并应用于参数 $x$ 即可证明。

---

### **6.7.2 算法 (The Algorithm)**

#### **问题描述：**

- **目标：** 找到一个有限整数列表中连续段的最大和。

---

#### **朴素解法：**

- **步骤：**

  1. 获取列表的所有（连续）子列表。
  2. 计算每个子列表的和。
  3. 取这些和中的最大值。

- **表达式：**

  $$
  \text{maxsub} \equiv_{\text{df}} (\text{fold } \text{bimax}) \circ (\text{map}_0\ \text{sum}) \circ \text{sublists}_0
  $$

  - **其中：**

    - \(\text{bimax}\) 是整数上的二元最大值函数。
    - \(\text{sublists}_0\) 是类型 \([A] \rightarrow \text{nel } [A]\) 的函数，返回一个非空列表，该列表包含给定列表的所有子列表。

- **解释：**

  - 由于即使空列表也包含自身作为子列表，因此结果非空。
  - 然后，我们对结果应用 \(\text{map}_0\ \text{sum}\)，传递证明信息，从而允许对非空参数应用 \(\text{fold}\)。

---

#### **定义 \(\text{sublists}\) 和 \(\text{frontlists}\)：**

- **\(\text{sublists}\) 的定义：**

  $$
  \begin{cases}
  \text{sublists}\ [\ ] \equiv_{\text{df}} [ [\ ] ] \\
  \text{sublists}\ (a :: x) \equiv_{\text{df}} \text{map}\ ((::)\ a)\ (\text{frontlists}\ x) ++ \text{sublists}\ x
  \end{cases}
  $$

- **\(\text{frontlists}\) 的定义：**

  $$
  \begin{cases}
  \text{frontlists}\ [\ ] \equiv_{\text{df}} [ [\ ] ] \\
  \text{frontlists}\ (a :: x) \equiv_{\text{df}} \text{map}\ ((::)\ a)\ (\text{frontlists}\ x) ++ [ [\ ] ]
  \end{cases}
  $$

- **解释：**

  - 对于列表 $(a :: x)$，它的子列表要么是 $x$ 的子列表，要么包括 $a$，此时 $a$ 必须跟随一个以 $x$ 开头的子列表。

---

#### **朴素解法的问题：**

- **效率问题：**

  - 该算法在计算结果时使用了与列表长度平方成正比的时间和空间，因为它检查了列表的所有（连续）子列表，其数量随列表长度的平方增长。

- **额外的证明信息：**

  - 在计算过程中传递了证明理论信息，这是不必要的。

- **解决方案：**

  - 通过程序转换来解决上述问题。

---

### **6.7.3 程序转换 (The Transformation)**

#### **转换步骤：**

1. **对 \([\ ]\) 情况进行分析：**

   $$
   \begin{align*}
   \text{maxsub}\ [\ ] &= (\text{fold } \text{bimax}) \circ (\text{map}_0\ \text{sum}) \circ \text{sublists}_0\ [\ ] \\
   &= \text{fold } \text{bimax}\ (\text{map}_0\ \text{sum}\ (\text{sublists}_0\ [\ ])) \\
   &= \text{fold } \text{bimax}\ (\text{map}_0\ \text{sum}\ ([ [\ ] ],\ \text{Triv})) \\
   &= \text{fold } \text{bimax}\ (0,\ \text{Triv}) \\
   &= 0
   \end{align*}
   $$

   - **解释：**

     - 每一步都根据相应函数的定义进行。

2. **对 $(a :: x)$ 情况进行分析：**

   $$
   \begin{align*}
   &(\text{fold } \text{bimax}) \circ (\text{map}_0\ \text{sum}) \circ \text{sublists}_0\ (a :: x) \\
   &= \text{fold } \text{bimax}\ (\text{map}_0\ \text{sum}\ (\text{sublists}_0\ (a :: x))) \\
   &= \text{fold } \text{bimax}\ (\text{map}_0\ \text{sum}\ (l_1 ++_0 l_2))
   \end{align*}
   $$

   - **其中：**

     - $l_1 \equiv_{\text{df}} \text{map}_0\ ((::)\ a)\ (\text{frontlists}_0\ x)$
     - $l_2 \equiv_{\text{df}} \text{sublists}_0\ x$
     - $l_1$ 和 $l_2$ 都是非空的。

   - **根据定理 6.14：**

     $$
     \text{map}_0\ \text{sum}\ (l_1 ++_0 l_2) = (\text{map}_0\ \text{sum}\ l_1) ++_0 (\text{map}_0\ \text{sum}\ l_2)
     $$

   - **根据定理 6.16：**

     $$
     \text{fold } \text{bimax}\ ((\text{map}_0\ \text{sum}\ l_1) ++_0 (\text{map}_0\ \text{sum}\ l_2)) = \text{bimax}\ (\text{fold } \text{bimax}\ (\text{map}_0\ \text{sum}\ l_1))\ (\text{fold } \text{bimax}\ (\text{map}_0\ \text{sum}\ l_2))
     $$

   - **回忆 $l_2 \equiv \text{sublists}_0\ x$，并根据 \(\text{maxsub}\) 的定义，可以得到：**

     $$
     \text{maxsub}\ (a :: x) = \text{bimax}\ (\text{fold } \text{bimax}\ (\text{map}_0\ \text{sum}\ l_1))\ (\text{maxsub}\ x) \quad (6.14)
     $$

3. **简化表达式：**

   - **将表达式展开：**

     $$
     (\text{fold } \text{bimax}) (\text{map}_0\ \text{sum}\ (\text{map}_0\ ((::)\ a)\ (\text{frontlists}_0\ x))) \quad (6.15)
     $$

   - **使用定理 6.15 和 6.18，将两个 \(\text{map}_0\) 的组合替换为：**

     $$
     \text{map}_0\ (\text{sum} \circ ((::)\ a)) (\text{frontlists}_0\ x)
     $$

   - **根据定理 6.18，得出：**

     $$
     \text{sum} \circ ((::)\ a) = ((+)\ a) \circ \text{sum}
     $$

   - **因此：**

     $$
     \text{map}_0\ (((+)\ a) \circ \text{sum}) (\text{frontlists}_0\ x) = (\text{map}_0\ ((+)\ a)) \circ (\text{map}_0\ \text{sum}) (\text{frontlists}_0\ x)
     $$

   - **重新组合表达式：**

     $$
     (\text{fold } \text{bimax}) \circ (\text{map}_0\ ((+)\ a)) \circ (\text{map}_0\ \text{sum}) (\text{frontlists}_0\ x)
     $$

   - **根据定理 6.17，得出：**

     $$
     a + ((\text{fold } \text{bimax}) \circ (\text{map}_0\ \text{sum}) \circ \text{frontlists}_0) x
     $$

4. **定义辅助函数：**

   - **设：**

     $$
     \text{maxfront} \equiv_{\text{df}} (\text{fold } \text{bimax}) \circ (\text{map}_0\ \text{sum}) \circ \text{frontlists}_0
     $$

   - **因此，原始表达式等于：**

     $$
     \text{maxsub}\ (a :: x) = \text{bimax}\ (a + \text{maxfront}\ x)\ (\text{maxsub}\ x)
     $$

5. **对 \(\text{maxfront}\) 进行类似的转换，得到：**

   $$
   \begin{cases}
   \text{maxfront}\ [\ ] = 0 \\
   \text{maxfront}\ (a :: x) = \text{bimax}\ 0\ (a + \text{maxfront}\ x)
   \end{cases}
   $$

6. **最终的递归定义：**

   $$
   \begin{cases}
   \text{maxsub}\ [\ ] = 0 \\
   \text{maxsub}\ (a :: x) = \text{bimax}\ (\text{maxsub}\ x)\ (a + \text{maxfront}\ x)
   \end{cases}
   $$

   - **该定义的复杂度与列表长度成线性关系。**

   - **此外，函数不再包含原算法中出现的任何证明信息，因为它使用了非空列表。**

---

### **练习**

#### **练习 6.34**

**问题：**

上述整数类型 \(\text{int}\) 的归纳原理是什么？

**提示：**

- 它可以从 \(\text{int}\) 类型的组成部分的归纳原理中导出。

---

#### **练习 6.35**

**问题：**

在定理 6.11 的证明中，为什么对列表 $l$ 进行归纳而不是列表 $m$？

---

#### **练习 6.36**

**问题：**

完成文本中仅略述的证明。

---

#### **练习 6.37**

**问题：**

针对操作符 \(\text{foldr}\)（而非 \(\text{fold}\)），陈述并证明与定理 6.16 相对应的定理。

---

#### **练习 6.38**

**问题：**

给出函数 \(\text{sublists}_0 : [A] \rightarrow \text{nel } A\) 的形式化推导。

---

#### **练习 6.39**

**问题：**

解释为什么原始定义的 \(\text{maxsub}\) 具有二次复杂度，而最终的定义是线性的。

---

### **总结**

在本节中，我们探讨了**程序转换**的方法，展示了如何在 $TT$ 系统中将一个程序转换为另一个在应用行为上等价但在时间或空间效率等方面更优的程序。通过对**最大子段和**问题的分析，我们首先给出了一个朴素的解决方案，然后通过一系列定理和转换步骤，将其优化为线性复杂度的算法。

我们引入了 **map** 和 **fold** 等重要的列表操作，并研究了它们的性质和相互关系。在程序转换过程中，我们利用了这些性质，将复杂的计算过程逐步简化，最终得到一个高效的算法。

通过本节的学习，读者可以理解程序转换的基本思想，以及如何利用类型理论中的工具和定理来优化程序。这为进一步研究和应用类型理论提供了重要的基础。

如果您对上述内容有任何疑问，或者希望深入了解某个主题，请随时告诉我！

### ---------------------------

### **6.7 程序转换 (Program Transformation)**

#### **概述：**

在之前的章节中，我们已经看到了在类型理论中进行程序构造的多种方法。本节将探讨**程序开发的转换方法**。我们将展示如何在 $TT$ 系统内将一个程序转换为另一个具有相同行为的程序，但在时间效率、空间使用或可并行性等方面具有其他理想特性。

---

#### **转换的起点：**

程序转换的起点可能来自以下两种方式：

1. **直接编写反映规范的程序：**

   - 即所谓的**可执行规范 (executable specification)**。

2. **从证明中提取程序：**

   - 通常，证明为了达到结果，会使用“蛮力”而非巧妙的方法。

本节中的示例可以视为以任一种方式产生的。我们的示例在多个地方被研究过，包括 [Tho89a] 和优秀的 [Ben86] 的第 7 列。本节要解决的问题是**寻找有限整数序列的连续段的最大和**。

**示例序列：**

$$
-2\quad 3\quad 4\quad -3\quad 5\quad -2\quad 1
$$

对于上述序列，标记的连续段 $3,\ 4,\ -3,\ 5$ 的和最大，为 9。

---

#### **程序转换的本质：**

程序转换的核心在于将一个程序转换为另一个在应用行为 (applicative behavior) 上相同的程序，但在某些方面（如时间效率或空间使用）得到改进。当两个函数对于所有参数返回相同的结果时，它们具有相同的行为，即它们在外延上 (extensionally) 是相等的。

因此，在 $TT$ 中，程序转换涉及通过一系列简单的、相同类型的步骤，将一个对象替换为与其外延等价的另一个对象。

---

#### **实现序列的表示：**

在本问题的讨论中，我们使用**整数列表**来表示序列。整数的一种实现已经在第 136 页给出。

我们将从介绍操作符 **map** 和 **fold** 开始，研究它们的一些性质，包括如何修改它们以在非空列表上操作。如果您已经熟悉这些函数，可以直接跳到转换部分，必要时再返回查看。

---

### **6.7.1 map 和 fold**

#### **map 函数：**

- **作用：** 将一个函数应用于列表的每个元素。
- **递归定义：**

  $$
  \begin{align*}
  \text{map} &: (A \rightarrow B) \rightarrow [A] \rightarrow [B] \\
  \text{map } f\ [\ ] &\equiv_{\text{df}} [\ ] \\
  \text{map } f\ (a :: x) &\equiv_{\text{df}} (f\ a) :: (\text{map } f\ x)
  \end{align*}
  $$

- **形式化表示：**

  $$
  \text{map} \equiv_{\text{df}} \lambda f.\ \lambda l.\ \text{lrec } l\ [\ ]\ h_f
  $$

  - 其中：

    $$
    h_f\ a\ l\ p \equiv_{\text{df}} (f\ a) :: p
    $$

- **性质：**

  - 根据 \((\Rightarrow I)\) 引入规则和 \(\text{lrec}\) 的计算规则，可以看出对于所有 $f$，以下类型是**可居住的**（即存在这样的对象）：

    $$
    \text{map } f\ [\ ] = [\ ] \quad \text{(6.9)}
    $$

    $$
    \text{map } f\ (a :: x) = (f\ a) :: (\text{map } f\ x) \quad \text{(6.10)}
    $$

---

#### **组合操作符 \(\circ\)：**

- **定义：**

  $$
  (g \circ f) \equiv_{\text{df}} \lambda x.\ (g\ (f\ x)) \quad \text{(6.11)}
  $$

- **说明：**

  - 为了可读性，我们将组合操作符 \(\circ\) 以中缀形式书写。

- **列表连接操作符 $++$：**

  - 连接两个列表。

---

#### **基本定律：**

后续的转换基于应用一些体现标准函数性质的通用“定律”。

##### **定理 6.11**

**命题：** 对于所有列表 $l$ 和 $m$，有：

$$
\text{map } f\ (l ++ m) = (\text{map } f\ l) ++ (\text{map } f\ m)
$$

##### **证明：**

- 对列表 $l$ 进行**归纳证明**。

  - **基础情况：** 当 $l = [\ ]$ 时，

    $$
    \text{map } f\ ([\ ] ++ m) = \text{map } f\ m = [\ ] ++ (\text{map } f\ m) = (\text{map } f\ [\ ]) ++ (\text{map } f\ m)
    $$

    - 其中使用了 \(\text{map } f\ [\ ] = [\ ]\)。

  - **归纳假设：** 假设对于列表 $x$，命题成立。

  - **归纳步骤：** 对于列表 $(a :: x)$，

    $$
    \begin{align*}
    \text{map } f\ ((a :: x) ++ m) &= \text{map } f\ (a :: (x ++ m)) \\
    &= f\ a :: \text{map } f\ (x ++ m) \quad (\text{根据 (6.10)}) \\
    &= f\ a :: (\text{map } f\ x) ++ (\text{map } f\ m) \quad (\text{根据归纳假设}) \\
    &= (f\ a :: \text{map } f\ x) ++ (\text{map } f\ m) \\
    &= (\text{map } f\ (a :: x)) ++ (\text{map } f\ m)
    \end{align*}
    $$

- 因此，命题对所有列表 $l$ 成立。 □

---

##### **定理 6.12**

**命题：** 对于所有函数 $f$ 和 $g$，有：

$$
\text{map } g \circ \text{map } f = \text{map } (g \circ f)
$$

##### **证明：**

- 我们需要证明对于所有列表 $x$：

  $$
  (\text{map } g \circ \text{map } f)\ x = \text{map } (g \circ f)\ x
  $$

- **归纳基础：**

  - 当 $x = [\ ]$ 时：

    $$
    (\text{map } g \circ \text{map } f)\ [\ ] = \text{map } g\ (\text{map } f\ [\ ]) = \text{map } g\ [\ ] = [\ ]
    $$

    $$
    \text{map } (g \circ f)\ [\ ] = [\ ]
    $$

    - 因此，基础情况成立。

- **归纳假设：**

  - 假设对于列表 $x$，命题成立：

    $$
    (\text{map } g \circ \text{map } f)\ x = \text{map } (g \circ f)\ x \quad \text{(6.13)}
    $$

- **归纳步骤：**

  - 对于列表 $(a :: x)$，

    $$
    \begin{align*}
    (\text{map } g \circ \text{map } f)\ (a :: x) &= \text{map } g\ (\text{map } f\ (a :: x)) \\
    &= \text{map } g\ ((f\ a) :: (\text{map } f\ x)) \quad (\text{根据 (6.10)}) \\
    &= g\ (f\ a) :: \text{map } g\ (\text{map } f\ x) \quad (\text{根据 (6.10)}) \\
    &= g\ (f\ a) :: (\text{map } (g \circ f)\ x) \quad (\text{根据归纳假设 (6.13)}) \\
    &= (g \circ f)(a) :: \text{map } (g \circ f)\ x \\
    &= \text{map } (g \circ f)\ (a :: x) \quad (\text{根据 (6.10)})
    \end{align*}
    $$

- 因此，命题对所有列表 $x$ 成立。 □

---

#### **fold 操作符：**

- **作用：**

  - 将**非空列表**的元素组合在一起，例如，通过折叠乘法操作符来获得列表元素的乘积。

- **定义：**

  $$
  \text{fold} : (A \rightarrow A \rightarrow A) \rightarrow \text{nel } A \rightarrow A
  $$

  - 其中，\(\text{nel } A\) 表示**非空列表**的类型。

- **非空列表的类型定义：**

  $$
  \text{nel } A \equiv_{\text{df}} (\exists l : [A]).\ (\text{nempty } l)
  $$

  - **其中 \(\text{nempty}\) 的定义：**

    $$
    \begin{cases}
    \text{nempty } [\ ] \equiv_{\text{df}} \bot \\
    \text{nempty } (a :: x) \equiv_{\text{df}} \top
    \end{cases}
    $$

- **fold 的定义：**

  $$
  \begin{cases}
  \text{fold } f\ ([\ ],\ p) \equiv_{\text{df}} \text{abort } A\ p \\
  \text{fold } f\ ((a :: [\ ]),\ p) \equiv_{\text{df}} a \\
  \text{fold } f\ ((a :: (b :: x)),\ p) \equiv_{\text{df}} f\ a\ (\text{fold } f\ ((b :: x),\ \text{Triv}))
  \end{cases}
  $$

  - **解释：**

    - 当列表为空时，调用 \(\text{abort } A\ p\)，其中 $p$ 是列表非空性的证明，这种情况实际上不会发生。

    - 当列表只有一个元素时，直接返回该元素。

    - 当列表有两个或更多元素时，递归地应用 $f$。

---

#### **在非空列表上定义 map 和 $++$：**

- **问题：**

  - 我们希望在**非空列表**上使用标准的 \(\text{map}\) 和 $++$ 函数。

- **解决方案：**

  - 由于直接使用这些函数会遇到困难，我们可以定义它们的类似函数 \(\text{map}_0\) 和 $++_0$，在类型 \(\text{nel } A\) 上操作。

- **引理 6.13**

  **命题：** 如果 $l$ 和 $m$ 是非空的，那么 \(\text{map } f\ l\) 和 $l ++ m$ 也是非空的。

  **证明：** 通过对列表 $l$ 和 $m$ 进行归纳证明。 □

- **辅助函数的定义：**

  - 根据引理，我们可以定义函数 \(\text{mapp}\) 和 \(\text{appp}\)：

    $$
    \begin{align*}
    \text{mapp} &: (\forall l : [A]).\ (\text{nempty } l) \rightarrow (\text{nempty } (\text{map } f\ l)) \\
    \text{appp} &: (\forall l, m : [A]).\ (\text{nempty } l) \rightarrow (\text{nempty } m) \rightarrow (\text{nempty } (l ++ m))
    \end{align*}
    $$

- **定义 \(\text{map}_0\) 和 $++_0$：**

  $$
  \begin{cases}
  \text{map}_0\ f\ (l, p) \equiv_{\text{df}} (\text{map } f\ l,\ \text{mapp } l\ p) \\
  (l, p)\ ++_0\ (m, q) \equiv_{\text{df}} (l ++ m,\ \text{appp } l\ m\ p\ q)
  \end{cases}
  $$

  - **解释：**

    - 这些函数将计算与证明相结合，将参数的非空性证明信息传递给结果的非空性证明。

---

#### **定理及其证明：**

##### **定理 6.14**

**命题：** 对于所有函数 $f$ 和非空列表 $l_0$、$m_0$，有：

$$
\text{map}_0\ f\ (l_0 ++_0 m_0) = (\text{map}_0\ f\ l_0) ++_0 (\text{map}_0\ f\ m_0)
$$

##### **证明：**

- 与定理 6.11 类似，对非空列表 $l_0$ 进行归纳证明。

- **基础情况：** 当 $l_0 = [\ ]$ 时，不可能，因为 $l_0$ 非空。

- **归纳步骤：** 假设对于 $l_0$，命题成立。

  - 对于 $l_0 = a :: x$，由于 $l_0$ 非空，可以应用类似于定理 6.11 的证明步骤。

 □

---

##### **定理 6.15**

**命题：** 对于所有函数 $f$、$g$，有：

$$
\text{map}_0\ g \circ \text{map}_0\ f = \text{map}_0\ (g \circ f)
$$

##### **证明：**

- 与定理 6.12 类似，对非空列表进行归纳证明。

- **基础情况：** 略。

- **归纳步骤：** 略。

 □

---

##### **定理 6.16**

**命题：** 如果 $f$ 是一个**结合函数**（即对于所有 $a, b, c$，有 $f\ a\ (f\ b\ c) = f\ (f\ a\ b)\ c$），那么对于非空列表 $l_0$ 和 $m_0$，有：

$$
\text{fold } f\ (l_0 ++_0 m_0) = f\ (\text{fold } f\ l_0)\ (\text{fold } f\ m_0)
$$

##### **证明：**

- 对非空列表 $l_0$ 进行归纳。

- **基础情况：** 当 $l_0$ 只有一个元素时，直接验证。

- **归纳步骤：** 假设对于 $l_0$，命题成立，证明对于 $a :: l_0$ 也成立。

 □

---

##### **定理 6.17**

**命题：** 如果 $f$ 和 $g$ 满足 $f\ (g\ a)\ (g\ b) = g\ (f\ a\ b)$，那么：

$$
(\text{fold } f) \circ (\text{map}_0\ g) = g \circ (\text{fold } f)
$$

- **解释：**

  - 该定理描述了一个将先映射后折叠的过程转换为在折叠后应用单个函数的情况。

- **证明：**

  - 对非空列表进行归纳。

  - **基础情况：** 略。

  - **归纳步骤：** 略。

 □

---

#### **foldr 操作符：**

- **定义：**

  $$
  \text{foldr} : (A \rightarrow B \rightarrow B) \rightarrow B \rightarrow [A] \rightarrow B
  $$

- **定义形式：**

  $$
  \begin{cases}
  \text{foldr } f\ \text{st}\ [\ ] \equiv_{\text{df}} \text{st} \\
  \text{foldr } f\ \text{st}\ (a :: x) \equiv_{\text{df}} f\ a\ (\text{foldr } f\ \text{st}\ x)
  \end{cases}
  $$

- **解释：**

  - \(\text{foldr}\) 实际上是递归操作符 \(\text{lrec}\) 的特例。

- **示例：**

  - 使用 \(\text{foldr}\) 可以定义许多列表操作，例如：

    $$
    \text{sum} \equiv_{\text{df}} \text{foldr } (+)\ 0
    $$

---

##### **定理 6.18**

**命题：** 对于所有函数 $f$ 和初始值 \(\text{st}\)，有：

$$
(\text{foldr } f\ \text{st}) \circ ((::)\ a) = (f\ a) \circ (\text{foldr } f\ \text{st})
$$

##### **证明：**

- 对于任意列表 $x$，展开两边：

  - 左边：

    $$
    (\text{foldr } f\ \text{st})\ ((::)\ a\ x) = \text{foldr } f\ \text{st}\ (a :: x) = f\ a\ (\text{foldr } f\ \text{st}\ x)
    $$

  - 右边：

    $$
    (f\ a)\ (\text{foldr } f\ \text{st}\ x)
    $$

- 因此，两边相等，证明成立。 □

---

### **6.7.2 算法 (The Algorithm)**

#### **问题描述：**

- **目标：** 找到一个有限整数列表中连续段的最大和。

---

#### **朴素解法：**

- **步骤：**

  1. 获取列表的所有（连续）子列表。
  2. 计算每个子列表的和。
  3. 取这些和中的最大值。

- **表达式：**

  $$
  \text{maxsub} \equiv_{\text{df}} (\text{fold } \text{bimax}) \circ (\text{map}_0\ \text{sum}) \circ \text{sublists}_0
  $$

  - **其中：**

    - \(\text{bimax}\) 是整数上的二元最大值函数。

    - \(\text{sublists}_0\) 是类型 \([A] \rightarrow \text{nel } [A]\) 的函数，返回一个非空列表，该列表包含给定列表的所有子列表。

    - 由于即使空列表也包含自身作为子列表，因此结果非空。

  - **过程：**

    - 对结果应用 \(\text{map}_0\ \text{sum}\)，传递证明信息，从而允许对非空参数应用 \(\text{fold}\)。

---

#### **定义 \(\text{sublists}\) 和 \(\text{frontlists}\)：**

- **\(\text{sublists}\) 的定义：**

  $$
  \begin{cases}
  \text{sublists}\ [\ ] \equiv_{\text{df}} [ [\ ] ] \\
  \text{sublists}\ (a :: x) \equiv_{\text{df}} \text{map}\ ((::)\ a)\ (\text{frontlists}\ x) ++ \text{sublists}\ x
  \end{cases}
  $$

- **\(\text{frontlists}\) 的定义：**

  $$
  \begin{cases}
  \text{frontlists}\ [\ ] \equiv_{\text{df}} [ [\ ] ] \\
  \text{frontlists}\ (a :: x) \equiv_{\text{df}} \text{map}\ ((::)\ a)\ (\text{frontlists}\ x) ++ [ [\ ] ]
  \end{cases}
  $$

- **解释：**

  - 对于列表 $(a :: x)$，它的子列表要么是 $x$ 的子列表，要么包括 $a$，此时 $a$ 必须跟随一个以 $x$ 开头的子列表。

---

#### **朴素解法的问题：**

- **效率问题：**

  - 该算法在计算结果时使用了与列表长度**平方**成正比的时间和空间，因为它检查了列表的所有（连续）子列表，其数量随列表长度的平方增长。

- **额外的证明信息：**

  - 在计算过程中传递了证明理论信息，这是不必要的。

- **解决方案：**

  - 通过**程序转换**来解决上述问题。

---

### **6.7.3 程序转换 (The Transformation)**

#### **转换步骤：**

1. **处理空列表的情况：**

   $$
   \begin{align*}
   \text{maxsub}\ [\ ] &= (\text{fold } \text{bimax}) \circ (\text{map}_0\ \text{sum}) \circ \text{sublists}_0\ [\ ] \\
   &= \text{fold } \text{bimax}\ (\text{map}_0\ \text{sum}\ (\text{sublists}_0\ [\ ])) \\
   &= \text{fold } \text{bimax}\ (\text{map}_0\ \text{sum}\ ([ [\ ] ],\ \text{Triv})) \\
   &= \text{fold } \text{bimax}\ (0,\ \text{Triv}) \\
   &= 0
   \end{align*}
   $$

   - **解释：**

     - 每一步都根据相应函数的定义进行。

2. **处理非空列表 $(a :: x)$ 的情况：**

   $$
   \begin{align*}
   \text{maxsub}\ (a :: x) &= (\text{fold } \text{bimax}) \circ (\text{map}_0\ \text{sum}) \circ \text{sublists}_0\ (a :: x) \\
   &= \text{fold } \text{bimax}\ (\text{map}_0\ \text{sum}\ (\text{sublists}_0\ (a :: x))) \\
   &= \text{fold } \text{bimax}\ (\text{map}_0\ \text{sum}\ (l_1 ++_0\ l_2))
   \end{align*}
   $$

   - **其中：**

     - $l_1 \equiv_{\text{df}} \text{map}_0\ ((::)\ a)\ (\text{frontlists}_0\ x)$

     - $l_2 \equiv_{\text{df}} \text{sublists}_0\ x$

     - $l_1$ 和 $l_2$ 都是非空的。

   - **根据定理 6.14：**

     $$
     \text{map}_0\ \text{sum}\ (l_1 ++_0\ l_2) = (\text{map}_0\ \text{sum}\ l_1) ++_0 (\text{map}_0\ \text{sum}\ l_2)
     $$

   - **根据定理 6.16：**

     $$
     \text{fold } \text{bimax}\ ((\text{map}_0\ \text{sum}\ l_1) ++_0 (\text{map}_0\ \text{sum}\ l_2)) = \text{bimax}\ (\text{fold } \text{bimax}\ (\text{map}_0\ \text{sum}\ l_1))\ (\text{fold } \text{bimax}\ (\text{map}_0\ \text{sum}\ l_2))
     $$

   - **由于 $l_2 = \text{sublists}_0\ x$，并根据 \(\text{maxsub}\) 的定义，可以得到：**

     $$
     \text{maxsub}\ (a :: x) = \text{bimax}\ (\text{fold } \text{bimax}\ (\text{map}_0\ \text{sum}\ l_1))\ (\text{maxsub}\ x) \quad \text{(6.14)}
     $$

3. **简化表达式：**

   - 我们关注表达式中的第一个参数：

     $$
     \text{fold } \text{bimax}\ (\text{map}_0\ \text{sum}\ (\text{map}_0\ ((::)\ a)\ (\text{frontlists}_0\ x))) \quad \text{(6.15)}
     $$

   - **利用两个 \(\text{map}_0\) 的组合：**

     $$
     \text{map}_0\ \text{sum}\ (\text{map}_0\ ((::)\ a)\ (\text{frontlists}_0\ x)) = \text{map}_0\ (\text{sum} \circ ((::)\ a))\ (\text{frontlists}_0\ x)
     $$

   - **根据定理 6.18（因为 \(\text{sum} = \text{foldr } (+)\ 0\)），有：**

     $$
     \text{sum} \circ ((::)\ a) = ((+)\ a) \circ \text{sum}
     $$

   - **因此：**

     $$
     \text{map}_0\ (((+)\ a) \circ \text{sum})\ (\text{frontlists}_0\ x) = (\text{map}_0\ ((+)\ a)) \circ (\text{map}_0\ \text{sum})\ (\text{frontlists}_0\ x)
     $$

   - **将表达式 (6.15) 转化为：**

     $$
     (\text{fold } \text{bimax}) \circ (\text{map}_0\ ((+)\ a)) \circ (\text{map}_0\ \text{sum})\ (\text{frontlists}_0\ x)
     $$

   - **根据定理 6.17：**

     $$
     (\text{fold } \text{bimax}) \circ (\text{map}_0\ ((+)\ a)) = (+)\ a \circ (\text{fold } \text{bimax})
     $$

   - **因此，得到：**

     $$
     \text{fold } \text{bimax}\ (\text{map}_0\ \text{sum}\ (\text{map}_0\ ((::)\ a)\ (\text{frontlists}_0\ x))) = a + (\text{fold } \text{bimax}\ (\text{map}_0\ \text{sum}\ \text{frontlists}_0\ x))
     $$

   - **定义辅助函数：**

     $$
     \text{maxfront} \equiv_{\text{df}} \text{fold } \text{bimax} \circ \text{map}_0\ \text{sum} \circ \text{frontlists}_0
     $$

   - **因此，表达式 (6.14) 等于：**

     $$
     \text{maxsub}\ (a :: x) = \text{bimax}\ (a + \text{maxfront}\ x)\ (\text{maxsub}\ x)
     $$

4. **对 \(\text{maxfront}\) 进行类似的转换，得到：**

   $$
   \begin{cases}
   \text{maxfront}\ [\ ] = 0 \\
   \text{maxfront}\ (a :: x) = \text{bimax}\ 0\ (a + \text{maxfront}\ x)
   \end{cases}
   $$

5. **最终的递归定义：**

   $$
   \begin{cases}
   \text{maxsub}\ [\ ] = 0 \\
   \text{maxsub}\ (a :: x) = \text{bimax}\ (\text{maxsub}\ x)\ (a + \text{maxfront}\ x)
   \end{cases}
   $$

   - **该定义的复杂度与列表长度成线性关系。**

   - **此外，函数不再包含原算法中出现的任何证明信息，因为它使用了非空列表。**

---

### **练习**

#### **练习 6.34**

**问题：**

上述整数类型 \(\text{int}\) 的归纳原理是什么？

**提示：**

- 它可以从 \(\text{int}\) 类型的组成部分的归纳原理中导出。

---

#### **练习 6.35**

**问题：**

在定理 6.11 的证明中，为什么对列表 $l$ 进行归纳而不是列表 $m$？

---

#### **练习 6.36**

**问题：**

完成文本中仅略述的证明。

---

#### **练习 6.37**

**问题：**

针对操作符 \(\text{foldr}\)（而非 \(\text{fold}\)），陈述并证明与定理 6.16 相对应的定理。

---

#### **练习 6.38**

**问题：**

给出函数 \(\text{sublists}_0 : [A] \rightarrow \text{nel } [A]\) 的形式化推导。

---

#### **练习 6.39**

**问题：**

解释为什么原始定义的 \(\text{maxsub}\) 具有二次复杂度，而最终的定义是线性的。

---

### **总结**

在本节中，我们探讨了**程序转换**的方法，展示了如何在 $TT$ 系统中将一个程序转换为另一个在应用行为上等价但在时间或空间效率等方面更优的程序。通过对**最大连续子序列和**问题的分析，我们首先给出了一个朴素的解决方案，然后通过一系列定理和转换步骤，将其优化为线性复杂度的算法。

我们引入了 **map** 和 **fold** 等重要的列表操作，并研究了它们的性质和相互关系。在程序转换过程中，我们利用了这些性质，将复杂的计算过程逐步简化，最终得到一个高效的算法。

通过本节的学习，您可以理解程序转换的基本思想，以及如何利用类型理论中的工具和定理来优化程序。这为进一步研究和应用类型理论提供了重要的基础。

如果您对上述内容有任何疑问，或者希望进一步深入了解某个主题，请随时告诉我！

### ----------------------------

### **6.8 命令式编程 (Imperative Programming)**

#### **概述：**

到目前为止，我们的编程焦点主要是函数式的。那么，类似的技术是否可以应用于命令式程序呢？完整的答案仍然是当前研究的主题，但可以部分地给出肯定的回答，即通过将特定类别的函数式程序（**尾递归函数**）与命令式程序联系起来。

---

#### **尾递归函数的定义：**

**定义 6.19：** 一个函数是**尾递归的**，如果它的定义形式如下：

$$
\begin{cases}
f\ a_1\ \dots\ a_n \equiv_{\text{df}} f\ (g_{1,1}\ \tilde{a})\ \dots\ (g_{1,n}\ \tilde{a}) \quad \text{如果 } c_1\ \tilde{a} \\
\quad \vdots \\
f\ a_1\ \dots\ a_n \equiv_{\text{df}} f\ (g_{k,1}\ \tilde{a})\ \dots\ (g_{k,n}\ \tilde{a}) \quad \text{如果 } c_k\ \tilde{a} \\
f\ a_1\ \dots\ a_n \equiv_{\text{df}} h\ \tilde{a} \quad \text{如果不满足上述条件}
\end{cases}
$$

- 其中，$\tilde{a}$ 表示序列 $a_1, \dots, a_n$，$c_1, \dots, c_k$ 是条件函数，$g_{i,j}$ 是不包含 $f$ 的函数，$h$ 也是不包含 $f$ 的函数。

---

#### **尾递归函数与命令式程序的关系：**

- **尾递归的特征：**

  - 在上述定义中，右侧对 $f$ 的唯一递归调用发生在代码的尾部，即在评估完所有函数参数之后（假设按应用序求值）。

- **转化为命令式程序：**

  - 考虑一个简单的尾递归函数：

    $$
    \begin{cases}
    f\ a_1\ \dots\ a_n \equiv_{\text{df}} f\ (g_1\ \tilde{a})\ \dots\ (g_n\ \tilde{a}) \quad \text{如果 } c\ \tilde{a} \\
    f\ a_1\ \dots\ a_n \equiv_{\text{df}} h\ \tilde{a} \quad \text{如果不满足}
    \end{cases}
    $$

  - 当条件 $c\ \tilde{a}$ 为真时，我们进行递归调用，将参数 $a_i$ 转换为 $g_i\ \tilde{a}$；否则，返回结果 $h\ \tilde{a}$。

  - 这可以重新表述为：

    - **当条件 $c\ \tilde{a}$ 为真时，执行并行赋值：**

      $$
      a_1, \dots, a_n := g_1\ \tilde{a}, \dots, g_n\ \tilde{a}
      $$

    - **以命令式伪代码表示：**

      ```
      while c(ã) do
          a1, ..., an := g1(ã), ..., gn(ã);
      return h(ã);
      ```

---

#### **示例：阶乘函数的尾递归版本**

- **定义：**

  $$
  \begin{cases}
  \text{fac}\ n \equiv_{\text{df}} \text{tfac}\ n\ 1 \\
  \text{tfac}\ 0\ p \equiv_{\text{df}} p \\
  \text{tfac}\ (n + 1)\ p \equiv_{\text{df}} \text{tfac}\ n\ ((n + 1) \times p)
  \end{cases}
  $$

- **解释：**

  - $\text{tfac}$ 是一个尾递归函数，它在每次递归调用中更新参数 $p$，避免了对调用栈的依赖。

---

#### **一般化：将原始递归函数转化为尾递归函数**

- **引入函数 $\text{tprim}$：**

  - **定义：**

    $$
    \begin{cases}
    \text{tprim}\ n\ c\ f\ 0\ v \equiv_{\text{df}} v \\
    \text{tprim}\ n\ c\ f\ (m + 1)\ v \equiv_{\text{df}} \text{tprim}\ n\ c\ f\ m\ (f\ (n - m - 1)\ v) \quad \text{如果 } m < n \\
    \text{tprim}\ n\ c\ f\ (m + 1)\ v \equiv_{\text{df}} v \quad \text{如果不满足}
    \end{cases}
    $$

    - 其中，$n$、$c$ 和 $f$ 是给定的，$v$ 是不断更新的参数。

- **目标：**

  - 证明对于所有 $n$、$c$ 和 $f$，有：

    $$
    \text{prim}\ n\ c\ f = \text{tprim}\ n\ c\ f\ n\ c
    $$

    - 这里，$\text{prim}$ 是原始递归函数。

---

#### **证明相关定理**

##### **定理 6.20**

**命题：** 对于所有 $n$、$c$、$f$ 和 $m \leq n$，有：

$$
\text{tprim}\ n\ c\ f\ (n - m)\ (\text{prim}\ m\ c\ f) = \text{prim}\ n\ c\ f
$$

**证明：**

- **归纳基础：**

  - 当 $n - m = 0$ 时：

    $$
    \text{tprim}\ n\ c\ f\ 0\ (\text{prim}\ n\ c\ f) = \text{prim}\ n\ c\ f
    $$

    - 这是由 $\text{tprim}$ 的定义直接得到的。

- **归纳步骤：**

  - 假设对于 $n - m = p$，命题成立。

  - 对于 $n - m = p + 1$，即 $m = n - (p + 1)$：

    $$
    \begin{align*}
    \text{tprim}\ n\ c\ f\ (p + 1)\ (\text{prim}\ m\ c\ f) &= \text{tprim}\ n\ c\ f\ p\ (f\ m\ (\text{prim}\ m\ c\ f)) \\
    &= \text{tprim}\ n\ c\ f\ p\ (\text{prim}\ (m + 1)\ c\ f)
    \end{align*}
    $$

    - 根据归纳假设，由于 $n - (m + 1) = p$，因此：

      $$
      \text{tprim}\ n\ c\ f\ p\ (\text{prim}\ (m + 1)\ c\ f) = \text{prim}\ n\ c\ f
      $$

    - 归纳步骤完成。

**结论：** 定理成立。 □

---

##### **推论 6.21**

**命题：** 对于所有 $n$、$c$ 和 $f$，有：

$$
\text{tprim}\ n\ c\ f\ n\ c = \text{prim}\ n\ c\ f
$$

**证明：**

- 在定理 6.20 中取 $m = 0$，得到：

  $$
  \text{tprim}\ n\ c\ f\ n\ (\text{prim}\ 0\ c\ f) = \text{prim}\ n\ c\ f
  $$

- 而 $\text{prim}\ 0\ c\ f = c$，因此：

  $$
  \text{tprim}\ n\ c\ f\ n\ c = \text{prim}\ n\ c\ f
  $$

**结论：** 推论成立。 □

---

#### **尾递归函数的优势：**

- 在 $\text{tprim}$ 的执行中，前三个参数 $n$、$c$ 和 $f$ 在递归调用中不变——它们充当程序的参数或常量，无需为它们分配存储空间。
- 其他两个参数 $m$ 和 $v$ 需要分配空间。

---

#### **将原始递归函数转换为尾递归形式：**

- **重要性：**

  - 上述推论证明了可以将任何原始递归函数转换为尾递归形式，从而转化为命令式形式。

- **推广：**

  - 我们可以对系统中的其他递归操作符证明类似的定理，因此函数式程序可以作为开发命令式程序的中间步骤，只要目标命令式语言支持 $TT$ 的所有高阶数据类型。

- **注意：**

  - 如果目标语言不支持这些类型，可以采用其他编码技术，但对应关系会不那么直接。

---

#### **命令式程序的可函数化：**

- 对于任何命令式程序，都存在对应的函数式形式，其中唯一的递归是尾递归。
- 但是，这种尾递归可能无法在 $TT$ 中形式化，因为它可能导致**非终止**。
- 如果我们能够为命令式程序提供一个**终止证明**，并且该证明可以在一阶算术中形式化（参见第 5.11 节），那么在 $TT$ 中将存在与该程序等价的函数。

---

### **练习**

#### **练习 6.40**

**问题：**

给出列表和树上的递归操作符的尾递归形式。

**提示：**

- 尝试将标准递归定义转换为尾递归形式，可能需要引入辅助参数来累积结果。

---

#### **练习 6.41**

**问题：**

评论阶乘函数的尾递归形式的空间效率。你的观察是否取决于对 $TT$ 项选择的求值形式？

**提示：**

- 考虑尾递归与非尾递归在栈空间使用上的差异，以及在不同求值策略（如严格求值和惰性求值）下的表现。

---

### **6.9 文献中的示例 (Examples in the Literature)**

#### **概述：**

本节对在类似 $TT$ 的理论中进行证明和程序开发的已发表文献中的示例进行了概述。许多示例使用了**子集类型 (subset type)**；我们将在下一章讨论该类型及其在程序开发中的相关性，同时提供引入新概念时的示例。

---

#### **6.9.1 Martin-Löf 的工作**

- **内容：**

  - Martin-Löf 的工作中示例较少。
  - 在他的扩展理论 [ML85] 中，包含了**选择公理**的证明：

    $$
    (\forall x : A).\ (\exists y : B).\ C \Rightarrow (\exists f : (\forall x : A).\ B).\ (\forall x : A).\ C[(f\ x)/y]
    $$

    - 该证明在本质上涉及强存在消解规则 $(\exists E)$。

- **其他工作：**

  - Padova 笔记 [ML84] 包含了一些小型示例，但没有大型的案例。
  - 他关于构造性数学的笔记 [ML70] 包含了从构造性角度发展的数学证明示例，但与 $TT$ 中的证明形式关系不大。

---

#### **6.9.2 哥德堡大学的工作**

- **来源：**

  - 瑞典哥德堡大学和查尔姆斯理工大学的编程方法论小组提供了许多示例。

- **内容：**

  - 在 [Dyb87] 中，类型理论被作为多种系统之一，应用于推导命题表达式的语法形式规范化算法的示例。
  - [Nor85] 中，提出了多级函数类型的正式表示，作为 $TT$ 的一个扩展，包括向量、自然数、列表等类型。

- **其他工作：**

  - [NP85] 讨论了如何使用 $TT$ 的量词和依赖类型来提供模块的规范。

---

#### **6.9.3 Backhouse 等人的工作**

- **概述：**

  - Roland Backhouse 及其同事在格罗宁根大学和埃因霍温大学就类型理论主题发表了大量文章。

- **内容：**

  - 教程笔记 [Bac87a] 包含了许多短小的示例，旨在逐个构造地说明系统。
  - 论文 [BCMS89] 引入了许多扩展，并包含了有用的示例，如 Boyer-Moore 多数投票算法和一系列类似于 [Hug90] 中的游戏操作。

- **其他工作：**

  - [Chi87] 中给出了一个解析算法的详细推导。

    - 解析器通过断言来指定：

      $$
      (\forall w : \text{Word}).\ \text{Parse } w \lor \lnot \text{Parse } w
      $$

    - 证明涉及展示字符串 $w$ 有效的解析树。

---

#### **6.9.4 Nuprl 系统**

- **概述：**

  - 康奈尔大学的 Constable 团队专注于他们的 Nuprl 系统，我们将在第 9.1.1 节“数学的实现”中详细讨论。

- **内容：**

  - Nuprl 系统与类型理论非常接近，他们的大部分示例都是可理解的，尽管不一定可以直接翻译。
  - [C+86a] 包含了简短的说明性示例，并在第 11 章中开发了许多数学对象的库。

- **其他工作：**

  - Howe 的论文 [How88] 在第 4 章中对 Girard 悖论进行了详细分析。
  - [CS87] 讨论了将部分对象添加到类型理论中。

- **应用：**

  - [BdV89] 提供了一个更具体的硬件规范和验证的应用，研究了浮点加法器/减法器的前端。

---

#### **6.9.5 构造演算 (Calculus of Constructions)**

- **概述：**

  - Huet 和 Coquand 的构造演算 [CH85] 是另一个与 $TT$ 有一定关联的系统。

- **内容：**

  - [PM87] 中可以找到算法开发的示例。
  - [PM89] 研究了从构造演算的证明中提取程序。
  - [Coq86] 对 Girard 悖论进行了分析。

---

### **总结**

本节概述了在类似类型理论的系统中进行证明和程序开发的已发表文献中的示例。通过回顾 Martin-Löf、哥德堡大学团队、Backhouse 等人、Nuprl 系统以及构造演算的相关工作，我们了解了类型理论在实际应用和研究中的一些重要方向。这些示例展示了类型理论在证明复杂数学命题、开发算法和程序验证等方面的强大能力。

如果您对上述内容有任何疑问，或者希望进一步深入了解某个主题，请随时告诉我！

### ---------------------------



### ----------------------------
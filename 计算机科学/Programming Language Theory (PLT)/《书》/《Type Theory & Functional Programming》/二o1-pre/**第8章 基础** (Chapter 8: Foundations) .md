[toc]



**概览**

本章是对整个系统的全面审视，而不是仅仅关注可从中推导出的特定项和证明，或者可能的扩展。我们将探讨关于该系统数学基础的各种问题。从传统证明论的角度，我们可以将其与其他算术形式系统的强度进行比较——这将在第一节中讨论。这里使用的技术是**实现性（realizability）**，它构成了形式系统的一种模型。在接下来的章节中，我们讨论了为类型理论（TT）开发模型理论的动机，提供了其他模型构建的方法。

实现性不仅从证明论的角度有趣：它提供了一种从推导中提取计算内容的通用机制，因此可能提供了一种从类型理论推导中得出更高效程序的方法。

我们以对 Schroeder-Heister 和 Dybjer 关于证明规则反演的工作的概述来结束讨论。在直观层面上，如果我们给定一个类型的引入规则，那么我们似乎知道了元素可以采取的所有形式，这实际上刻画了这个类型。**反演原理（inversion principle）**给出了如何反转引入规则以生成消除和计算规则的正式描述。我们还研究了反演原理本身的基本证明。

---

**详细解读**

### 第8章 基础

#### 8.1 证明论

在本节中，我们将从传统证明论的角度审视我们的系统，探讨它与其他算术形式系统的强度比较。我们将使用**实现性**作为主要技术，它构成了形式系统的一种模型。

##### 8.1.1 直觉主义算术

**直觉主义算术**是数学逻辑中的一个体系，它基于直觉主义逻辑，而不是经典逻辑。直觉主义逻辑拒绝某些经典逻辑的原则，例如排中律。这使得直觉主义算术在构建数学对象时更加构造性，强调证明的可计算性和构造性。

在我们的系统中，理解直觉主义算术的重要性在于它提供了一个基准，可以与我们的类型理论进行比较。通过比较，我们可以了解我们的系统在证明力量和表达能力方面的位置。

##### 8.1.2 实现性

**实现性（Realizability）**是由 Kleene 引入的一种技术，用于将证明论与计算联系起来。它旨在通过关联计算对象（通常是自然数或某种计算模型中的函数）与逻辑公式，来捕获公式的构造性内容。

在我们的上下文中，使用实现性有助于：

- **模型化我们的类型理论系统**：通过为系统构建一个模型，我们可以验证其一致性和其他性质。
- **提取计算内容**：实现性允许我们从逻辑证明中提取计算内容，即对应的程序或算法。
- **理解证明的构造性**：通过研究哪些计算对象“实现”了特定的逻辑公式，我们可以深入了解证明的构造性程度。

在本节中，我们将详细探讨实现性的技术，以及它如何应用于我们的类型理论系统。

##### 8.1.3 存在量词的消除

**存在量词的消除**是逻辑中的一个重要过程，它涉及如何从存在性陈述中提取具体的实例。在证明论中，这通常与**存在引入**和**存在消除**规则有关。

在我们的类型理论中，处理存在量词的消除涉及到：

- **构造性地找到一个满足条件的实例**：由于我们的系统是构造性的，我们需要实际构造一个满足存在性条件的对象。
- **处理证明对象**：在类型理论中，证明本身也是对象，因此我们需要管理与存在性证明相关的证明对象。

本节将讨论如何在我们的系统中有效地执行存在量词的消除，以及这对系统的构造性和计算性意味着什么。

#### 8.2 模型理论

在这一部分，我们将讨论为我们的类型理论系统开发模型理论的动机，并介绍其他模型构建的方法。

**为什么需要模型理论？**

- **验证一致性**：通过构建模型，我们可以展示系统的无矛盾性，因为在模型中所有的定理都是真实的。
- **理解系统的性质**：模型可以帮助我们理解系统的限制和能力。
- **探索不同的解释**：通过不同的模型，我们可以看到系统如何在不同的语义下运作。

##### 8.2.1 项模型

**项模型（Term Models）**是基于系统自身的项（terms）构建的模型。基本思想是：

- **使用系统的项作为模型的元素**：这样，模型直接反映了系统内部的结构。
- **解释类型和项的关系**：通过项模型，我们可以看到类型如何由项组成，以及项如何满足类型的要求。

项模型的优点是它们非常直接，紧密联系到系统的语法结构。但是，它们也可能较为复杂，因为系统的项可能非常丰富。

##### 8.2.2 无类型解释

**无类型解释（Type-free interpretations）**是指在没有类型结构的情况下，对系统进行解释。这样做的动机包括：

- **简化模型**：通过去除类型结构，模型可能更容易处理。
- **强调计算方面**：无类型的模型可能更适合捕获系统的计算行为。

然而，无类型解释也有挑战，例如如何处理原本依赖于类型的信息。在本节中，我们将探讨如何构建这样的模型，以及它们对于理解系统的计算性质有何帮助。

##### 8.2.3 一个归纳定义

**归纳定义**是数学和逻辑中用于定义对象或集合的一种方法，基于构造步骤和基础情况。在我们的模型理论中，归纳定义可以用于：

- **构建模型的元素**：通过归纳地定义模型中的对象，我们可以确保它们满足所需的性质。
- **定义类型和项的解释**：归纳定义允许我们逐步构建类型和项的语义解释。

在本节中，我们将给出一个具体的归纳定义，展示如何使用它来构建我们的模型。

#### 8.3 一个逻辑的通用框架

本节讨论为逻辑提供一个通用框架的方法。这种框架的目的在于：

- **统一各种逻辑系统**：通过一个通用的框架，我们可以将不同的逻辑系统纳入其中，便于比较和分析。
- **提供扩展和定制的灵活性**：用户可以根据需要添加或修改规则，构建适合特定应用的逻辑系统。
- **强调逻辑系统的结构性**：通过明确逻辑系统的组成部分，我们可以更好地理解其工作原理。

在我们的类型理论背景下，这种通用框架可以帮助我们：

- **整合不同的逻辑规则**：例如，引入规则、消除规则和计算规则。
- **研究逻辑系统的元性质**：如一致性、完备性和归约性。

#### 8.4 反演原理

**反演原理（Inversion Principle）**是关于如何从类型的引入规则推导出其消除和计算规则的理论。

**直观理解**

- **引入规则定义了类型的元素形式**：通过引入规则，我们知道了如何构造类型的元素。
- **反演引入规则**：通过反转引入规则，我们可以推断出对于给定的元素，它必须是哪种形式。
- **刻画类型**：这使得我们能够完整地刻画类型的行为，包括如何使用类型的元素。

**反演原理的重要性**

- **自动生成消除和计算规则**：减少了手动定义这些规则的工作量。
- **确保系统的一致性**：通过系统化的方法，我们可以避免错误和遗漏。
- **加深对类型的理解**：通过反演，我们更深入地了解了类型的结构和性质。

**Schroeder-Heister 和 Dybjer 的工作**

这两位学者在反演原理方面做出了重要贡献。他们的工作包括：

- **形式化反演原理**：给出了严格的数学定义，确保了其正确性。
- **研究反演原理的应用**：展示了如何在实际的逻辑系统中应用反演原理。
- **探讨反演原理的基础**：研究了反演原理的基本证明和逻辑基础。

**本节的内容**

我们将：

- **深入探讨反演原理**：包括其定义、证明和应用。
- **研究反演原理的基本证明**：理解其为何成立，以及其在逻辑系统中的角色。
- **举例说明**：通过具体的示例，展示如何使用反演原理来生成消除和计算规则。

---

**总结**

在本章中，我们从整体上重新审视了我们的类型理论系统，探讨了其数学基础。通过与直觉主义算术等其他形式系统的比较，我们了解了系统的强度和特点。实现性作为一种技术，不仅帮助我们从证明中提取计算内容，还为构建系统的模型提供了工具。

我们讨论了构建模型的不同方法，包括项模型和无类型解释，以及如何使用归纳定义来构建模型的元素。通过引入一个逻辑的通用框架，我们为不同的逻辑系统提供了统一的视角。

最后，我们深入研究了反演原理，了解了如何从类型的引入规则推导出其消除和计算规则。通过 Schroeder-Heister 和 Dybjer 的工作，我们看到了反演原理在逻辑系统中的重要性和应用。

本章的讨论为我们提供了对类型理论系统的深刻理解，奠定了进一步研究和应用的基础。

### ---------------------------

**第8章 基础**

---

**概览**

本章重新审视整个类型理论系统，而不是仅仅关注从中可推导出的特定项和证明，或可能的扩展。我们将探讨关于该系统数学基础的各种问题。从传统证明论的角度，我们将其与其他构造性算术形式系统进行比较，特别是直觉主义算术（Heyting Arithmetic，HA）及其对简单类型的泛化 HAω。我们将讨论实现性（realizability）技术，它用于对直觉主义系统进行解释，并可作为比类型理论更灵活的算法提取机制的基础。最后，我们将讨论关于存在消除的各种规则，以及选择规则对模块实现的影响。

---

**8.1 证明论**

在本节中，我们将研究系统 TT₀（以及其他相关系统）与更传统的构造性算术表示之间的关系。特别地，我们将考察一阶直觉主义算术 HA 及其对简单类型的泛化 HAω。这些系统已经被广泛研究，通过与类型理论 TT₀ 的比较，我们可以深入了解 TT₀ 的性质和能力。

### 8.1.1 直觉主义算术

**定义 8.1：一阶 Heyting 算术（HA）**

一阶 Heyting 算术 HA 的完整定义可在 [Troelstra and van Dalen, 1973] 的第 I.3 节中找到。该系统包括自然数的一阶理论，每个原始递归函数都有一个函数常量。公理断言了等式的基本性质，包括标准的 Peano 公理，指出：

- 零不是任何数的后继；
- 后继函数是一一对应的；
- 归纳公理模式：
  $$
  \phi(0) \land \forall n.(\phi(n) \Rightarrow \phi(n+1)) \Rightarrow \forall n.\phi(n)
  $$
  对于每个公式 φ，都有上述归纳公理。

此外，还包括每个原始递归函数的定义方程。

**推理规则**

推理规则是构造性谓词演算的标准规则，可以通过省略证明对象，从我们的合取（∧）、析取（∨）、蕴涵（⇒）、矛盾（⊥）、全称量词（∀）和存在量词（∃）的引入和消除规则中导出，选择析取和存在量词的弱消除规则，即 (∨E) 和 (∃E₀)。

**定义 8.2：有限类型上的 Heyting 算术（HAω）**

HAω（在 [Troelstra and van Dalen, 1973] 的第 I.6 节中称为 N-HAω）与 HA 类似，但对象可以是由 N 和函数空间构造器形成的任何有限类型上的元素。在每个类型上都包含一个体现原始递归定义的算子。量词范围限定在特定类型上，而不是整个域。

**关于这些系统的讨论**

这些系统已经被广泛研究，它们与 TT₀ 的关系可以帮助我们了解类型理论系统的性质。显然，HAω 是 HA 的扩展，我们将在下一个定义中更清晰地阐述这一点。我们用 S ⊢ φ 表示“φ 是形式系统 S 的定理”。

**定义 8.3：嵌入和保守扩展**

给定两个形式系统 S₁ 和 S₂，从 S₁ 的公式到 S₂ 的公式的函数 f 是第一个系统到第二个系统的嵌入，如果对于所有公式 φ，有：

- 如果 S₁ ⊢ φ，那么 S₂ ⊢ f(φ)。

如果上述关系是双向的（即 S₂ 也能推出 S₁ 的所有定理），那么 S₂ 被称为 S₁ 的保守扩展，函数 f 被称为 S₁ 在 S₂ 中的解释。

**解释**

系统 S₂ 是 S₁ 的保守扩展，意味着两个理论在较小系统 S₁ 的语言中证明了相同的定理；它们在共同的领域中给出了相容的描述。

显然，HA 可以嵌入到 HAω 中。我们也可以将 HAω 的公式嵌入为 TT₀ 的公式，并证明以下结果：

**定理 8.4：HAω 在 TT₀ 中的嵌入**

对于任何公式 φ，如果 HAω ⊢ φ，那么存在某个项 t，我们可以在 TT₀ 中导出判断 t : φ。

**证明：**

项 t 是 HAω 中 φ 的证明的编码。更多细节可在 [Beeson, 1985] 的定理 XI.17.1 中找到。✷

**讨论**

此外，如果我们在 HAω 中添加有限类型上的选择公理 ACF_T：

$$
\forall x.\exists y.A(x, y) \Rightarrow \exists f.\forall x.A(x, f(x))
$$

这个公理在 TT₀ 中也是成立的。证明选择公理可以在类型理论中导出是 Martin-Löf 在他的论文中为数不多的例子之一。参见 [Martin-Löf, 1984; 1985]，并注意推导不使用扩展性。如果我们采用 [ML85] 中的扩展理论，那么我们的类型理论扩展了扩展版本的 HAω + Ext + ACF_T。

**结论**

基于这种关系，我们可以推导出哪些结果呢？

我们的第一个结果，由 Troelstra 提出，展示了通过研究这些相互关系，我们能够从 HAω 转移一个负结果到类型理论。

首先，我们给出另一个定义。

**定义 8.5：连续函数**

从 N ⇒ N 到 N 的函数 F 称为**连续的**，如果对于所有 f : N ⇒ N，存在一个自然数 n，使得如果对于所有 i ≤ n，有 f(i) = g(i)，那么 F(f) = F(g)。值 n 称为 F 在 f 处的连续性模数。

**解释**

连续性表明了从 N ⇒ N 到 N 的函数的有限性质：函数 F 在 f 处的值由关于 f 的有限信息决定。因此，我们可以期望，在 TT₀ 中可定义的所有函数 F 都是连续的。然而，我们可以证明 TT₀ 并不证明其形式化的陈述：

$$
\forall F : (N \Rightarrow N) \Rightarrow N.\ \text{Cont}(F)
$$

这本身可由以下定理推导：

**定理 8.6：HAω + ACF_T + Ext + 连续性 ⇒ 矛盾**

理论 HAω 加上有限类型上的选择公理 ACF_T、扩展性公理 Ext，以及所有函数 F : (N ⇒ N) ⇒ N 都连续的假设，是不一致的（即能导出矛盾 ⊥）。

**证明：**

参见 [Beeson, 1985] 的定理 XI.19.1。使用选择公理，我们可以定义一个函数 μ，返回函数 F 在参数 f 处的连续性模数。扩展性意味着这个模数由函数值而非表示确定，这可以被证明导致有限的过程解决全知性有限原则（limited principle of omniscience），从而产生矛盾。✷

**推论 8.7：TT₀ 不证明所有函数都连续**

类型理论 TT₀ 不证明：

$$
\forall F : (N \Rightarrow N) \Rightarrow N.\ \text{Cont}(F)
$$

**证明：**

如果 TT₀ 证明了上述命题，那么扩展版本的类型理论也证明了它，并且由于它也导出了选择公理，根据定理 8.6，它是不一致的。但我们有 TT₀ 的一致性证明，因此原始假设不成立。✷

**讨论**

我们能否刻画类型理论中可证明的算术定理？答案是肯定的。

**定理 8.8：TT₀ 是 HA 的保守扩展**

类型理论 TT₀ 是 HA 的保守扩展，其中当我们可以导出某个表达式 t 使得 t : A 时，我们说 TT₀ 使命题 A 有效。

**证明：**

这是由多位作者证明的，包括 Beeson 和 Renardel，[Beeson, 1985] 和 [Dragalin and Troelstra, 1984]。证明使用了实现性技术，我们将在下一节讨论。✷

**总结**

值得注意的是，定理所述的内容。它断言，类型理论系统 TT₀——通过将一阶算术嵌入一个类型系统来扩展它，并且假设选择公理成立（就此结果而言，可以使其成为扩展的）——在算术陈述方面并不比一阶算术更强。

关于系统 TT、TT⁺ 和 TT₀⁺，我们尚未讨论。它们都比 TT₀ 更强。我们已经证明了 TT 比 TT₀ 更强，有关这方面的其他评论可在 [Beeson, 1985] 的第 XIII.5 节中找到。对于具有完整 W-类型的理论，我们目前没有相关结果。

### 8.1.2 实现性

我们提到，定理 8.8 的证明使用了实现性方法。我们借此机会在此解释该方法，因为它构成了我们将要描述的重要研究的基础。

**实现性的起源**

实现性是由 Kleene 在 1945 年引入的，用于构建直觉主义理论的递归模型。根据我们在第 3 章中首次遇到的关于连接词的非正式解释，我们可以看到，对于任何构造性系统的解释，转换的概念都是核心，因为正是通过转换来解释蕴涵和全称量词。Kleene 的想法是使用递归函数作为这些转换函数。

**定义 8.9：算术的实现性（r-实现性）**

我们将递归函数编码为自然数，因此定义一个关系：

$$
e \triangleright \phi
$$

其中 e 是自然数，φ 是一个公式。我们还写 {e}(q) ↓ 表示“递归函数 e 在参数 q 上终止”。现在，我们按照 [Kleene, 1945] 的原始定义给出实现性：

- $e \triangleright (A \Rightarrow B)$ 当且仅当对于所有 q，如果 $q \triangleright A$ ，则 ${e}(q)$ 定义且 ${e}(q) \triangleright B$。
- $e \triangleright \forall x.A$ 当且仅当对于所有 x，${e}(x)$ 定义且 ${e}(x) \triangleright A$。
- $e \triangleright \exists x.A$ 当且仅当 $\text{first}(e) \triangleright A(\text{second}(e))$。
- $e \triangleright A \land B$ 当且仅当 $\text{first}(e) \triangleright A$ 且 $\text{second}(e) \triangleright B$。
- $e \triangleright A \lor B$ 当且仅当：
  - 如果 $\text{first}(e) = 0$，则 $\text{second}(e) \triangleright A$；
  - 如果 $\text{first}(e) \ne 0$，则 $\text{second}(e) \triangleright B$。

对于原子公式，任何数字都实现它。

**解释**

我们可以将实现性解释为逻辑系统的一个模型，其中那些存在 e 使得 $e \triangleright \phi$ 的公式 φ 是有效的。实现性的一个重要点是以下定理：

**定理 8.10：健全性**

如果 HA 证明了 φ，那么存在某个自然数 e，使得 $e \triangleright \phi$。

**证明：**

通过对 φ 的证明大小进行归纳。详细的证明可在 [Beeson, 1985] 的第 VII.1 节中找到。✷

**意义**

这可以理解为，对于任何定理 φ，我们都有一个项（自然数 e），它为公式提供了计算解释。例如，考虑一个公式：

$$
\forall x.\exists y.P(x, y)
$$

其中 P 是原子公式。

根据实现性的定义，我们有：

- $e \triangleright \forall x.\exists y.P(x, y)$ 当且仅当对于所有 x，${e}(x)$ 定义且 ${e}(x) \triangleright \exists y.P(x, y)$；
- 进一步展开，得到对于所有 x，${e}(x)$ 定义，且 $\text{first}({e}(x)) \triangleright P(x, \text{second}({e}(x)))$。

这意味着存在一个递归函数 g，使得对于所有 x，P(x, g(x)) 成立。

**实现性的特点**

实现性有几个值得注意的方面：

1. **公式与其实现性之间的关系**

   定义 8.9 中右侧的定义本身就是算术表达式。这对于类型理论作为 HA 的保守扩展的结果至关重要。由于这种对应，我们可以研究公式与其实现性的形式表达之间的关系。

2. **自我实现的公式**

   对于 r-实现性，那些与自身实现性陈述（$\exists e.(e \triangleright \phi)$）等价的公式 φ，是那些没有存在性内容的公式，即没有计算意义的公式。

3. **实现性的普遍性**

   我们应该注意到定义的普遍性：要给出不同的实现性概念，只需要一组不同的实现函数，或稍微改变右侧的定义。有了健全性定理，我们可以从公式的证明中提取一些计算信息。这同样适用于目标理论：上述定义适用于一阶算术，但通常我们可能会考虑其他理论，例如高阶版本的算术。

**实现性与类型理论的关系**

鉴于此，我们的理论 TT₀ 开始看起来像是高阶类型系统的特定实现性版本。过于紧密地将逻辑与实现性概念联系在一起，可能会导致哪些缺点呢？我们在第 7.1.2 节中讨论了“计算相关性”，在那里我们看到，在某些情况下，我们的证明对象包含了从计算角度来看不必要的信息。将逻辑规则与函数提取机制分离，可能会导致更高效的提取对象，而无需修改逻辑本身。

这种方法的主要优势在于，书写证明的逻辑可以保持固定，同时可以对证明应用不同的证明提取技术（即不同的实现性概念）。这与前一章中扩展版本的 TT 引入的复杂性形成了对比。

这种分离是 Henson 和 Turner 对 TK 系统研究的核心，我们将在下一章中讨论。

### 8.1.3 存在消除

我们之前在第 5.3.3 节中观察到，规则 (∃E₀) 比规则 (∃E) 或等价的 (∃E₀₁) 和 (∃E₀₂) 要弱。这些规则在 [Swan, 1989] 的论文中得到了深入研究，作者证明了在选择公理的证明中，使用强规则 (∃E) 是必要的。

**定理 8.11：强规则 (∃E) 等价于弱规则加选择公理**

强规则 (∃E) 等价于弱规则 (∃E₀) 加上选择公理。

**进一步的结果**

此外，与上述类似的保守性结果适用于该理论。

**定理 8.12：TT₀^w 是 HAω 的保守扩展**

TT₀^w，即使用弱存在消除规则的 TT₀，是 HAω 的保守扩展。

**讨论**

系统 TT₀^w 在 [Diller, 1980] 中进行了独立的讨论。

---

**总结**

在本节中，我们探讨了类型理论系统 TT₀ 与直觉主义算术 HA 及其扩展 HAω 之间的关系。通过研究嵌入和保守扩展的概念，我们了解到 TT₀ 是 HA 的保守扩展，这意味着在算术陈述方面，TT₀ 并不比 HA 更强。

我们介绍了实现性技术，展示了如何使用它来证明 TT₀ 的保守性结果。实现性提供了一种从证明中提取计算内容的机制，这对于理解类型理论的计算性质非常重要。

最后，我们讨论了存在消除规则的不同版本，特别是强规则 (∃E) 和弱规则 (∃E₀) 之间的关系。我们了解到，强规则的使用在某些证明（如选择公理）中是必要的，并且不同的规则会影响系统的保守性。

---

**参考文献**

- Beeson, M. J. (1985). *Foundations of Constructive Mathematics*. Springer-Verlag.
- Diller, J. (1980). "A generalization of Tait's realizability to higher order arithmetic". *Journal of Symbolic Logic*, 45(4), 574–594.
- Dragalin, A. G., & Troelstra, A. S. (1984). *Mathematical Intuitionism*. Oxford University Press.
- Kleene, S. C. (1945). "On the interpretation of intuitionistic number theory". *Journal of Symbolic Logic*, 10(4), 109–124.
- Martin-Löf, P. (1984). *Intuitionistic Type Theory*. Bibliopolis.
- Martin-Löf, P. (1985). "Constructive mathematics and computer programming". *Philosophical Transactions of the Royal Society of London A*, 312(1522), 501–518.
- Swan, A. (1989). *Existential Quantifiers in Type Theory*. PhD Thesis, University of Edinburgh.
- Troelstra, A. S., & van Dalen, D. (1973). *Constructivism in Mathematics: An Introduction*. North-Holland.

### ----------------------------

**详细解读第8.2节：模型理论**

---

**概览**

在本节中，我们深入探讨类型理论（如 TT₀ 和 TT）的**模型理论**。模型理论旨在为形式系统提供语义解释，为其符号和规则赋予系统自身之外的意义。这对于确保系统的一致性、理解其证明论强度以及指导系统可能的扩展至关重要。我们将探索为 TT₀ 和 TT 提供语义的不同方法，包括**项模型**、**无类型解释**和**归纳定义**，并引用 Martin-Löf、Smith、Beeson、Allen 等人的工作。

---

### 8.2 模型理论

**模型理论的目的**

模型理论试图为像 TT₀ 和 TT 这样的形式系统赋予意义，通过提供系统自身之外的语义解释。这避免了循环定义，并确保在解释系统时的清晰性和连贯性。

**为什么语义很重要？**

1. **解释符号的意义**：一个完全未被解释的形式系统对任何人都没有意义。语义为系统的符号和语法结构赋予了超越纸上符号的含义，使我们能够有意义地理解和应用系统。

2. **确保一致性**：提供语义可以证明系统的一致性，或者至少证明其相对于语义所在的理论的一致性。这非常重要，因为有可能构建出直观上合理但实际上不一致的系统，例如 Martin-Löf 最早的类型理论版本，或者某些结合了各种公理的形式理论（例如，将 HAω 与选择公理和扩展性结合，导致不一致）。语义帮助我们确保不会发生这样的不一致。

3. **证明论强度**：语义可以帮助限定系统的证明论强度，展示系统能够或不能证明哪些定理。这对于理解系统的能力和限制非常有价值。

4. **指导系统扩展**：语义可以指出某些系统的扩展或加强（例如，通过在语义中引入某些操作来扩展系统）是否合法。通过考虑语义中的操作，我们可以看到扩展对系统一致性的影响，以及它们如何影响整个理论。

**TT₀ 的语义形式**

一些研究者为 TT₀ 提出了不同的语义解释：

- **Per Martin-Löf**：基于项模型的解释。
- **Paul Smith**：提供了无类型的解释。
- **Michael Beeson**：基于实现性的模型。
- **Stuart Allen**：提出了类型的归纳定义。

在这个背景下，重要的参考文献是 [ML75a]，其中 Martin-Löf 研究了直觉主义理论的构造性模型的普遍概念，这适用于他自己、Smith 和 Beeson 引入的模型。

---

### 8.2.1 项模型

**概述**

类型理论最直接的语义解释之一来自于**项模型**，如 Martin-Löf 在 [ML75b] 中提出，并在 [ML85] 和 [NPS90] 中进一步阐述。项模型依赖于**化简**和**标准形**的概念，这些概念在类型理论之外。

**项模型中的解释**

- **规范形式**：在项模型中，闭表达式 $a : A$ 的解释是类型 $A$ 的**规范形式** $a'$。

- **标准形**：对于 TT₀ 和 TT，规范形式被解释为**标准形**。标准形是指在系统的化简规则下不能进一步化简的表达式。

- **含变量的表达式的意义**：对于带有变量的表达式，如 $b(x) : B(x)$，如果对于所有规范的 $a$，替换 $b(a)$ 化简为 $B(a)$ 中的规范项，那么 $b(x)$ 就是类型 $B(x)$ 的规范项。

**项模型的性质**

- **非平凡性**：项模型中标准形的独特性质表明它们是非平凡的，为类型理论提供了有意义的解释。

- **非正式语义**：根据 [ML85]，项模型构成了系统的基本**直观语义**。通过研究项模型，我们可以深入了解系统的行为和其构造的含义。

- **额外性质**：研究项模型使我们能够证明系统的重要性质，例如**Church-Rosser 定理**，该定理指出，如果一个表达式可以化简为两个不同的标准形，那么存在一个共同的表达式，可以将这两个标准形进一步化简到它。它还帮助我们确定**判断的可判定性**，这意味着我们可以通过算法确定给定的判断在系统中是否有效。

**项模型的局限性**

- **对语法的依赖**：由于项模型与系统的语法形式密切相关，它们在推导**保守性结果**（关于系统相对于另一个系统可以或不可以证明的内容的陈述）或为理论的**扩展**提供依据方面作用较小。在系统扩展的情况下，必须构建一个基于更广泛表达式的新项模型，并证明其存在性。

---

### 8.2.2 无类型解释

**动机**

- **类型的复杂性**：系统 TT₀ 和 TT 具有复杂的类型系统，这可能使其难以处理。一个更简单的替代方案是使用**无类型**系统，即不具有显式类型的系统。

- **简化的理论**：就像无类型的 λ-演算比类型化的 λ-演算更简单一样，无类型的理论可以为逻辑和计算提供更直接的框架。

**方法**

- **Smith 的解释**：在 [Smi84] 中，Paul Smith 提供了类型理论的无类型解释。他将这种解释描述为 Martin-Löf 语义解释的**元数学版本**，在逻辑理论中形式化。

- **Frege 结构**：Peter Aczel 的 **Frege 结构**（[Acz80]）是适用于解释类型理论的另一种无类型系统。

**与实现性的关系**

- **实现性模型**：无类型解释与**实现性模型**有关，后者使用计算对象（如数字或 λ-项）来解释逻辑公式。

- **Smith 与 Beeson**：Beeson 在 [Bee85] 第 XI.20 节中使用自然数作为他的实现性模型 M，而 Smith 使用无类型的 λ-项作为实现函数。

- **优势**：实现性模型的一个优势是可以用于**刻画理论的证明论强度**。例如，Beeson 使用模型 M 来证明 TT₀ 是 Heyting 算术（HA）的保守扩展。

**一般模型**

- **可扩展性**：Aczel、Beeson 和 Smith 的模型都是通用的，因为存在多种不同的实现性概念。

- **与 λ-演算的联系**：每个**无类型 λ-演算**的模型都可以扩展为 Frege 结构，进而提供类型理论的模型。

**益处**

- **简化**：无类型解释可以通过去除显式类型的复杂性来简化类型理论的语义。

- **灵活性**：它们允许应用不同的实现性概念，为解释和分析类型理论提供了灵活性。

---

### 8.2.3 一个归纳定义

**替代方法**

Stuart Allen 在 [All87a] 和 [All87b] 中提出了一种替代的语义方法，通过将类型定义为（无类型）表达式集合的等价类，从而提供**归纳定义**。这种方法也在 [CS87] 的第 2.2 节中进行了总结。

**关键概念**

- **等价类**：如果两个表达式 $t$ 和 $t'$ 在类型 $T$ 上被认为是**等价的**，则记为 $t = t' \in T$。记号 $t \in T$ 是 $t = t \in T$ 的简写，表示 $t$ 是 $T$ 的成员。

- **成员资格标准**：对于类型 $(\forall x : A). B$，表达式 $t$ 在此类型中，当且仅当 $(\forall x : A). B$ 是一个类型，且存在 $u$ 和 $b$，使得：

  1. $t$ 化简为 $\lambda u . b$，即 $t \rightarrow \lambda u . b$。
  2. 对于所有 $a, a'$，如果 $a = a' \in A$，则 $b[a/u] = b[a'/u] \in B$。

  该条件确保 $t$ 在 $A$ 的等价输入上表现一致。

**挑战**

- **归纳定义**：关于归纳定义的一般参考文献（如 [Mos74]）指出，并非所有归纳定义都有最小解，或者根本没有解。

- **单调性要求**：对于**单调**归纳定义，总是存在最小解。单调性的充分条件是定义公式在关系 $... = ... \in ...$ 中是**正向的**。然而，在 Allen 的定义中，由于该关系出现在蕴涵的假设中，违反了正向性条件。

- **结果**：由于单调性的失败，无法以最初的形式简单地将定义给出为归纳定义。

**Allen 的解决方案**

- **算子 M**：Allen 转而通过指定一个算子 $M$ 来定义他的系统，该算子可以被视为**类型理论**上的单调算子。

- **类型理论作为关系**：类型理论被视为一个二元关系 $T$，其中当且仅当 $A$ 是类型并在类型理论 $T$ 中携带等价关系 $\sim_A$ 时，$T\ A\ \sim_A$ 成立。

- **最小不动点**：由于算子 $M$ 是单调的，因此语义由该算子的**最小不动点**给出。

**优势**

- **忠实于惰性求值**：Allen 认为，他的方法更忠实于 Martin-Löf 对系统的非正式语义中的**惰性求值**。

- **可扩展性**：归纳定义可以方便地扩展到增强的系统。例如，在 [CS87] 中，展示了如何将语义扩展到该论文中讨论的**部分类型**。

- **计算规则的证明**：Allen 表示，他的方法可用于证明 Nuprl 系统中的一些**直接计算规则**，这些规则允许在比 TT 允许的更少的假设下化简项。

---

### 8.3 一个逻辑的通用框架

**形式化表示**

我们对 TT₀ 和 TT 理论的介绍在语法方面有些非正式。在本节中，我们回顾如何使用**元理论**形式化地表示这些理论。

**元理论类型**

- **操作作为元函数**：TT 中形成类型和元素的操作可以赋予**元理论类型**。

- **函数空间构造器**：例如，蕴涵运算符 $⇒$ 的元类型是：

  $$
  \text{Type} \rightarrow \text{Type} \rightarrow \text{Type}
  $$

  其中 $\rightarrow$ 是元层次的函数空间构造器，$\text{Type}$ 是类型的元类型。

- **依赖函数空间**：注入 $\text{inl}$ 可以赋予元类型：

  $$
  (\Pi t : \text{Type})(\Pi s : \text{Type})(\text{El}(s) \rightarrow \text{El}(s \lor t))
  $$

  其中 $\Pi$ 表示元语言中的**依赖函数空间构造器**，$\text{El}$ 是一个常量，将类型表达式与其要表示的元素集合相关联。

**使用类型化 λ-演算**

- **元理论作为类型化 λ-演算**：这些示例表明，我们可以使用具有**依赖乘积类型**的类型化 λ-演算作为元理论，包括 $\beta$-和 $\eta$-转换的规则。

- **元语言中的绑定**：系统 TT 的所有操作，包括那些绑定变量的操作（如 $\lambda$），都可以在元理论中表示为常量，利用元语言的变量绑定机制。

**定义算子**

- **λ 运算符**：非依赖类型上的 $\lambda$ 运算符可以描述为：

  $$
  \lambda :: (\Pi t : \text{Type})(\Pi s : \text{Type})( (\text{El}(t) \rightarrow \text{El}(s)) \rightarrow \text{El}(t ⇒ s) )
  $$

  其中 $e :: \alpha$ 表示 $e$ 具有元类型 $\alpha$。

- **应用算子**：应用算子是类型为：

  $$
  \text{app} :: (\Pi t : \text{Type})(\Pi s : \text{Type})( \text{El}(t ⇒ s) \rightarrow \text{El}(t) \rightarrow \text{El}(s) )
  $$

**计算规则**

- **β 化简**：函数空间的计算规则是**β 化简**。使用下标形式 $\text{app}_{t,s}$ 表示对类型 $t$ 和 $s$ 应用算子，规则为：

  $$
  \text{app}_{t,s}(\lambda_{t,s} f) \ a = f\ a
  $$

- **元函数替换**：由于 $f$ 是一个元函数（类型为 $\text{El}(t) \rightarrow \text{El}(s)$ 的元素），因此对象语言中的替换对应于元语言中的 $\beta$-化简。

- **其他操作**：对系统中的其他变量绑定操作，类似的方法同样有效。

**起源和应用**

- **Martin-Löf 的 arities 理论**：这种方法的起源可以追溯到 Martin-Löf 的 arities 理论（[ML85]）以及他关于哲学类别的工作（[ML83]）。

- **进一步讨论**：关于以这种形式呈现类型理论的明确讨论可在 [Dyb88] 和 [NPS90] 的第三部分中找到。

- **爱丁堡逻辑框架（LF）**：这种方法已在爱丁堡逻辑框架（[HHP87]）中使用，该框架为一般逻辑推理提供了一个机器环境，并已证明能够表达各种逻辑（[AHM87]）。

**结果**

- **逻辑的复杂性**：这种形式化的一个结果是，针对命令式编程语言（如 Pascal）的逻辑（如 Hoare 逻辑）的复杂性比最初想象的要大。这类似于编程语言的完整指称语义定义所揭示的语言复杂性。

- **表达能力**：使用具有依赖类型的类型化 λ-演算作为元理论，为定义和推理各种逻辑系统提供了强大而富有表现力的框架。

---

**总结**

在本节中，我们探讨了为类型理论（如 TT₀ 和 TT）提供语义的各种方法。通过理解项模型、无类型解释、归纳定义以及使用类型化 λ-演算作为元理论，我们对这些系统的含义、一致性和可扩展性有了更深入的了解。这些语义框架不仅使我们确信系统的健全性，还指导我们将类型理论扩展和应用到新领域，确保它们保持健壮和有意义。

---

**参考文献**

- [ML75a] Martin-Löf, P. (1975). "An intuitionistic theory of types: Predicative part." In H.E. Rose and J.C. Shepherdson (eds.), *Logic Colloquium '73*, North-Holland.
- [ML75b] Martin-Löf, P. (1975). "About models for intuitionistic type theories and the notion of definitional equality." In S. Kanger (ed.), *Proceedings of the Third Scandinavian Logic Symposium*, North-Holland.
- [ML83] Martin-Löf, P. (1983). "On the meanings of the logical constants and the justifications of the logical laws." Nordic Journal of Philosophical Logic.
- [ML85] Martin-Löf, P. (1985). *Constructive mathematics and computer programming*. Philosophical Transactions of the Royal Society of London A 312(1522), 501–518.
- [NPS90] Nordström, B., Petersson, K., & Smith, J. M. (1990). *Programming in Martin-Löf's Type Theory: An Introduction*. Oxford University Press.
- [Smi84] Smith, P. (1984). "An interpretation of Martin-Löf's type theory in a type-free theory of constructions." *Journal of Symbolic Logic*, 49(3), 730–743.
- [Acz80] Aczel, P. (1980). "Frege structures and the notions of proposition, truth, and set." In J. Barwise, H.J. Keisler, & K. Kunen (eds.), *The Kleene Symposium*, North-Holland.
- [Bee85] Beeson, M. J. (1985). *Foundations of Constructive Mathematics*. Springer-Verlag.
- [All87a] Allen, S. F. (1987). "A Non-Type-Theoretic Definition of Martin-Löf's Types." In *Proceedings of the Second Symposium on Logic in Computer Science (LICS)*, IEEE.
- [All87b] Allen, S. F. (1987). *Towards a General Theory of Type Structure*. Ph.D. thesis, Cornell University.
- [CS87] Constable, R. L., & Smith, S. F. (1987). "Partial Objects in Constructive Type Theory." In *Proceedings of the Second Symposium on Logic in Computer Science (LICS)*, IEEE.
- [Dyb88] Dybjer, P. (1988). "Categorical semantics of Martin-Löf's type theory." In *Proc. Category Theory and Computer Science*, Springer-Verlag.
- [HHP87] Harper, R., Honsell, F., & Plotkin, G. (1987). "A framework for defining logics." In *Proceedings of the Second Symposium on Logic in Computer Science (LICS)*, IEEE.
- [AHM87] Avron, A., Honsell, F., & Mason, I. (1987). "Using typed lambda calculus to implement formal systems on a machine." In *Proceedings of the Third Annual Symposium on Logic in Computer Science (LICS)*, IEEE.
- [Mos74] Moschovakis, Y. N. (1974). *Elementary Induction on Abstract Structures*. North-Holland.

### ---------------------------

# 8.4 反演原理

---

## 概览

在类型理论中，当我们定义一个类型时，通常会给出四种类型的规则：

1. **构造规则（Formation Rules）**：引入新的类型表达式，从组成部分构建新类型。
2. **引入规则（Introduction Rules）**：描述类型的元素，即如何构造类型的值。
3. **消除规则（Elimination Rules）**：描述如何使用类型的元素，即如何从类型的值中提取信息。
4. **计算规则（Computation Rules）**：描述类型的元素在计算时的行为，尤其是消除规则应用于引入规则的结果时的简化方式。

**反演原理（Inversion Principle）**的核心思想是：如果我们已经明确了类型的所有引入规则，那么类型的元素就完全由这些引入规则所刻画。因此，消除规则和计算规则可以通过**反转**引入规则来自动生成，无需额外的信息。

本节深入探讨了反演原理，展示了如何从引入规则推导出消除规则和计算规则，并讨论了在类型理论中应用该原理时遇到的挑战和解决方案。

---

## 详细解读

### 定义类型的四种规则

在类型理论（TT）中，为了定义一个新的类型，我们通常给出以下四种规则：

1. **构造规则（Formation Rule）**：说明如何构建新的类型。例如，对于逻辑中的析取（或）类型 $A \lor B$，构造规则是：

   $$
   \frac{\text{A 是一个命题} \quad \text{B 是一个命题}}{A \lor B \text{ 是一个命题}} \quad (\lor F)
   $$

2. **引入规则（Introduction Rules）**：描述如何构造类型的元素（值）。对于析取类型 $A \lor B$，引入规则是：

   - **左引入**：

     $$
     \frac{q : A}{\text{inl } q : A \lor B} \quad (\lor I_1)
     $$

   - **右引入**：

     $$
     \frac{r : B}{\text{inr } r : A \lor B} \quad (\lor I_2)
     $$

3. **消除规则（Elimination Rules）**：描述如何使用类型的元素，即如何从类型的值中提取信息。对于 $A \lor B$，消除规则允许我们从 $A \lor B$ 的证明中推导出其他命题。

4. **计算规则（Computation Rules）**：描述当消除规则应用于由引入规则构造的值时，如何进行简化。例如，当我们对 $\text{inl } q$ 应用消除规则时，计算规则描述了结果。

### 反演原理的概念

**反演原理**的核心思想是：因为引入规则已经完全描述了类型的所有可能的元素形式，因此消除规则和计算规则应该能够从引入规则中自动推导出来。

- **引入规则**：定义了类型的所有构造方式，即元素的可能形式。
- **消除规则**：应当反映出元素只能由引入规则给出的形式，因此可以通过反转引入规则来生成。
- **计算规则**：描述消除规则应用于引入规则构造的元素时的简化过程。

这种观点可以追溯到 Gentzen 和 [Prawitz, 1965] 的工作，此后被许多研究者进一步发展。Schroeder-Heister 在一阶直觉主义逻辑中研究了如何从引入规则生成消除规则（见 [SH83a], [SH83b]）。

### 析取类型的例子

#### 在逻辑中的反演

让我们以析取类型 $A \lor B$ 为例，看看如何应用反演原理。

- **问题**：如何总结 $A \lor B$ 的证明要么是 $A$ 的证明，要么是 $B$ 的证明？
- **逻辑思路**：如果我们有从 $A$ 推导出 $C$ 的假设证明，以及从 $B$ 推导出 $C$ 的假设证明，那么我们可以从 $A \lor B$ 推导出 $C$。这意味着任何 $A \lor B$ 的证明必须是 $A$ 或 $B$ 的证明。

**逻辑中的消除规则**：

$$
\frac{A \lor B \quad [A] \vdots C \quad [B] \vdots C}{C} \quad (\lor E_0)
$$

- **解释**：
  - 上面的规则表示，如果我们有 $A \lor B$ 的证明，以及在假设 $A$ 下能够证明 $C$，并且在假设 $B$ 下也能证明 $C$，那么我们可以在不需要 $A$ 或 $B$ 的情况下直接得出 $C$。
  - 方括号中的 $[A]$ 和 $[B]$ 表示假设，这些假设在推导 $C$ 后被**解除**（discharge）。

#### 提升到类型理论

在类型理论中，我们有显式的证明对象，因此需要在规则中体现这些对象。

**类型理论中的消除规则**：

$$
\frac{p : A \lor B \quad [x : A] \vdots u : C \quad [y : B] \vdots v : C}{\text{vcases}_0^{x, y} \ p \ u \ v : C} \quad (\lor E_0)
$$

- **解释**：
  - $p : A \lor B$ 是 $A \lor B$ 的证明对象。
  - $[x : A] \vdots u : C$ 表示在假设 $x : A$ 下，我们有 $u : C$。
  - $[y : B] \vdots v : C$ 表示在假设 $y : B$ 下，我们有 $v : C$。
  - 结论是构造一个新的证明对象 $\text{vcases}_0^{x, y} \ p \ u \ v : C$，该对象表示对 $p$ 进行分析，根据 $p$ 是 $\text{inl } a$ 还是 $\text{inr } b$ 来选择对应的分支。

- **绑定变量**：在 $u$ 中，变量 $x$ 被绑定；在 $v$ 中，变量 $y$ 被绑定。这反映了假设 $x : A$ 和 $y : B$ 被解除。

**计算规则**：

1. 如果 $p$ 是 $\text{inl } a$，那么：

   $$
   \text{vcases}_0^{x, y} \ (\text{inl } a) \ u \ v \rightarrow u[a / x]
   $$

   - **解释**：将 $a$ 替换到 $u$ 中的 $x$ 位置，得到 $u[a / x]$。

2. 如果 $p$ 是 $\text{inr } b$，那么：

   $$
   \text{vcases}_0^{x, y} \ (\text{inr } b) \ u \ v \rightarrow v[b / y]
   $$

   - **解释**：将 $b$ 替换到 $v$ 中的 $y$ 位置，得到 $v[b / y]$。

**总结**：

- **反演原理的应用**：我们从引入规则知道 $A \lor B$ 的证明对象要么是 $\text{inl } q$，其中 $q : A$；要么是 $\text{inr } r$，其中 $r : B$。因此，消除规则可以通过对这两种情况分别处理来生成。

### 反演原理的泛化

我们可以将上述过程泛化到任意的逻辑连结词（connectives）。

#### 一般情况

假设我们有一个逻辑连结词 $\theta$，其引入规则有 $n$ 个，形式为：

$$
\frac{H_{i,1} \quad \ldots \quad H_{i,m_i}}{\theta \ A_1 \ \ldots \ A_k} \quad (\theta I_i)
$$

其中：

- $i = 1, 2, \ldots, n$；
- $H_{i,1}, \ldots, H_{i,m_i}$ 是假设（前提）；
- $\theta \ A_1 \ \ldots \ A_k$ 是由 $\theta$ 和参数 $A_1, \ldots, A_k$ 组成的公式，我们可以记为 $\phi$。

根据反演原理：

- 如果我们能够从每组假设 $H_{i,1}, \ldots, H_{i,m_i}$ 推导出公式 $C$，那么由于 $\phi$ 的所有可能证明都来自这些引入规则，我们可以从 $\phi$ 本身推导出 $C$。

**逻辑中的消除规则**：

$$
\frac{\phi \quad [H_{1,1}, \ldots, H_{1,m_1}] \vdots C \quad \ldots \quad [H_{n,1}, \ldots, H_{n,m_n}] \vdots C}{C} \quad (\theta E)
$$

#### 类型理论中的情况

在类型理论中，每个引入规则对应于构造类型 $\phi$ 的元素的构造子（constructor）$K_i$，依赖于相应假设类型的元素。

引入规则形式为：

$$
\frac{y_{i,1} : H_{i,1} \quad \ldots \quad y_{i,m_i} : H_{i,m_i}}{K_i \ y_{i,1} \ \ldots \ y_{i,m_i} : \phi} \quad (\theta I_i)
$$

**消除规则的构造**：

- 我们定义一个新的消除对象 $\theta\text{-elim}$，它绑定假设中的变量 $y_{i,j}$。
- 消除规则形式为：

  $$
  \frac{p : \phi \quad \ldots \quad [y_{i,1} : H_{i,1}, \ldots, y_{i,m_i} : H_{i,m_i}] \vdots p_i : C \quad \ldots}{\theta\text{-elim} \ p \ p_1 \ \ldots \ p_n : C} \quad (\theta E)
  $$

- **解释**：
  - 对于每个引入规则，我们有对应的证明对象 $p_i : C$，在假设 $y_{i,j} : H_{i,j}$ 下。
  - 消除对象 $\theta\text{-elim} \ p \ p_1 \ \ldots \ p_n$ 将根据 $p$ 的形式选择对应的 $p_i$ 并进行计算。

**计算规则**：

- 给定 $\phi$ 的一个构造 $K_i \ a_1 \ \ldots \ a_{m_i}$，消除规则的计算规则为：

  $$
  \theta\text{-elim} \ (K_i \ a_1 \ \ldots \ a_{m_i}) \ p_1 \ \ldots \ p_n \rightarrow p_i[a_1 / y_{i,1}, \ldots, a_{m_i} / y_{i,m_i}]
  $$

- **解释**：将 $a_j$ 替换到 $p_i$ 中对应的 $y_{i,j}$ 中，得到 $p_i$ 的实例。

### 合取类型的例子

现在，让我们考虑另一个连结词：**合取（∧）**。

#### 引入规则

合取的引入规则是：

$$
\frac{a : A \quad b : B}{(a, b) : A \land B} \quad (\land I)
$$

- **解释**：如果我们有 $A$ 的证明 $a$ 和 $B$ 的证明 $b$，那么可以构造 $A \land B$ 的证明 $(a, b)$。

#### 应用反演原理

由于只有一个引入规则，我们可以按照上述方案构造消除规则。

**消除规则**：

$$
\frac{p : A \land B \quad [x : A, \ y : B] \vdots c : C}{\land\text{-elim}^{x, y} \ p \ c : C} \quad (\land E_0)
$$

- **解释**：
  - $p : A \land B$ 是 $A \land B$ 的证明。
  - $[x : A, \ y : B] \vdots c : C$ 表示在假设 $x : A$ 和 $y : B$ 下，我们有 $c : C$。
  - 消除对象 $\land\text{-elim}^{x, y} \ p \ c$ 将 $p$ 解构为 $a$ 和 $b$，然后将其替换到 $c$ 中。

- **变量绑定**：下标 $x, y$ 指明了在 $c$ 中被绑定的变量。

**计算规则**：

$$
\land\text{-elim}^{x, y} \ (a, b) \ c \rightarrow c[a / x, \ b / y]
$$

- **解释**：将 $a$ 和 $b$ 分别替换到 $c$ 中的 $x$ 和 $y$ 位置。

#### 与通常的规则的关系

通常，合取类型的消除规则是通过投影函数 $\text{fst}$ 和 $\text{snd}$ 来提取分量：

- **第一分量**：

  $$
  \text{fst} : A \land B \rightarrow A
  $$

- **第二分量**：

  $$
  \text{snd} : A \land B \rightarrow B
  $$

我们可以将上述消除规则与这些函数联系起来：

- 如果取 $c : C$ 为 $x : A$，那么：

  $$
  \land\text{-elim}^{x, y} \ (a, b) \ x \rightarrow x[a / x] = a
  $$

  - 这相当于 $\text{fst}$ 函数。

- 类似地，取 $c : C$ 为 $y : B$，得到 $\text{snd}$ 函数。

**结论**：

- 上述消除规则 $(\land E_0)$ 并不比通常的规则更强。
- 给定依赖于 $x : A$、$y : B$ 的 $c : C$，以及 $p : A \land B$，我们可以构造对象：

  $$
  c[\text{fst} \ p / x, \ \text{snd} \ p / y] : C
  $$

  - 这与 $\land\text{-elim}^{x, y} \ p \ c$ 的行为完全一致。

### 反演原理的适用范围

**反演原理**适用于：

- **存在量词（∃）**的规则。
- **有限类型**，如有限集合 $N_n$。
- **自然数类型**。
- **良基类型**，如列表和树。

**不适用的情况**：

- **子集消除规则（SetE）**：反演原理不适用于简单的子集消除规则。

### 对蕴涵和全称量词的挑战

在对**蕴涵（⇒）**和**全称量词（∀）**应用反演原理时，我们会遇到困难，因为它们的引入规则涉及**假设的解除（discharging hypotheses）**。

#### 蕴涵的例子

**引入规则**：

$$
\frac{[A] \vdots B}{A \Rightarrow B} \quad (\Rightarrow I)
$$

- **解释**：在假设 $A$ 的情况下，证明了 $B$，因此可以得出 $A \Rightarrow B$。

#### 反演的困难

要成功地对其进行反演，我们需要引入**假设性假设（hypothetical hypotheses）**。这是在类型理论中引入的新的术语形式，用于表示在某个上下文中的推导。

#### 引入假设性假设

按照 [SH83a] 和 [Bac86] 的方法，我们在系统中添加以下形式的术语：

$$
\{ \Gamma \ \vdash \ J \}
$$

- **解释**：
  - $\Gamma$ 是一个上下文（即一组假设）。
  - $J$ 是在上下文 $\Gamma$ 中推导出的判断。
  - 这个术语表示在假设 $\Gamma$ 的情况下，可以推导出 $J$。

**引入规则**：

$$
\frac{[\Gamma] \vdots J}{\{ \Gamma \ \vdash \ J \}} \quad (\vdash I)
$$

- **解释**：如果在假设 $\Gamma$ 下可以推导出 $J$，那么可以构造术语 $\{ \Gamma \ \vdash \ J \}$。

**消除规则**：

$$
\frac{\{ \Gamma \ \vdash \ J \} \quad \Gamma[t_1 / x_1, \ldots, t_n / x_n]}{J[t_1 / x_1, \ldots, t_n / x_n]} \quad (\vdash E)
$$

- **解释**：
  - 如果有 $\{ \Gamma \ \vdash \ J \}$，并且有 $\Gamma$ 的实例（通过将 $x_i$ 替换为 $t_i$），那么可以得到 $J$ 的相应实例。

#### 应用于蕴涵的反演

按照反演过程，我们可以得到蕴涵的消除规则：

$$
\frac{A \Rightarrow B \quad [\{ A \ \vdash \ B \}] \vdots C}{C} \quad (\Rightarrow E_0)
$$

- **解释**：这看起来有些复杂，但实际上表示**假言推理（modus ponens）**规则。

**推导过程**：

1. 有 $A \Rightarrow B$ 和假设 $\{ A \ \vdash \ B \}$。

2. 通过 $(\vdash E)$ 规则，如果有 $A$，那么可以得到 $B$。

3. 因此，从 $A \Rightarrow B$ 和 $A$ 可以得到 $B$。

#### 变量绑定的注意事项

为了正确地陈述蕴涵的消除规则，需要小心处理表达式中变量的绑定。最好在元语言中假设一个绑定操作 $\Lambda$，对象语言中的 $\lambda$ 可以作为一个常量。

- **表示方式**：将对象语言中的抽象 $\lambda x. e$ 写成 $\lambda (\Lambda x. e)$。

- **元理论中的应用**：使用中缀符号 $\cdot$ 表示元理论中的应用。

**消除规则的形式**：

$$
\frac{f : A \Rightarrow B \quad [\{ x : A \ \vdash \ e \cdot x : B \}] \vdots c \cdot e : C}{\text{expand } f \ c : C} \quad (\Rightarrow E_0)
$$

- **计算规则**：

  $$
  \text{expand } (\lambda g) \ c \rightarrow c \cdot g
  $$

- **解释**：
  - $f : A \Rightarrow B$ 是一个函数。
  - $e \cdot x : B$ 表示在 $x : A$ 下的 $B$ 的证明。
  - $c \cdot e : C$ 是在 $e$ 的上下文下得到 $C$ 的证明。
  - 最终得到 $\text{expand } f \ c : C$。

### 后续发展

Backhouse 提出了许多关于反演的原则，但在涉及递归类型时，其方法产生一致性系统的条件尚不明确。

在 [Dybjer, 1989] 中，提出了一个更一般的反演原理，基于以下观察：

- **类型的归纳定义**：类型理论中的所有类型（除了宇宙类型）都可以看作是在适当的逻辑框架中由归纳定义产生的。
- **参数化和同时定义**：类型构造操作可以参数化，并允许同时定义多个类型。

**语义含义**：

- 如果一个类型可以表示为**正向的归纳定义**，那么可以自动推导出一致的消除规则和计算规则。
- 这为扩展类型理论提供了依据，例如添加像 [Dyc85] 中的内容，但不适用于子集或商集构造。

### 结论和进一步讨论

在经典逻辑中，某些连结词的集合（如 $\neg$ 和 $\Rightarrow$，或 $\neg$ 和 $\land$）是完备的，可以表达所有可能的命题函数。那么在直觉主义逻辑中情况如何呢？

- 在 [SH83b] 中，证明了集合 $\{ \land, \lor, \Rightarrow, \neg, \exists, \forall \}$ 足以定义所有通过标准引入和消除规则定义的连结词。

- **标准形式的规则**：指遵守上述反演原理的规则。

---

## 练习

**练习 8.1**：展示反演原理不适用于上一章中引入的子集消除规则 $(\text{SetE})$。

**解答**：

- **提示**：考虑子集类型的消除规则，试图按照反演原理构造相应的消除规则，发现无法满足反演原理的要求。

**练习 8.2**：验证反演原理适用于有限类型、自然数类型和有限列表类型的规则。

**解答**：

- **有限类型**：例如，有限集合 $N_n$ 的引入规则是有限的，可以按照反演原理构造消除规则。

- **自然数类型**：自然数的引入规则（零和后继）可以应用反演原理，得到归纳法的消除规则。

- **列表类型**：列表的构造（空列表和添加元素）也可以应用反演原理，得到对列表进行归纳的消除规则。

**练习 8.3**：反演原理是否适用于第 7.10 和 7.11 节中的归纳类型和余归纳类型的规则？它是否适用于上一章中给出的通用递归的定义？

**解答**：

- **归纳类型和余归纳类型**：反演原理适用于归纳类型，因为它们的构造和消除规则符合归纳定义的形式，可以应用反演原理。

- **通用递归的定义**：由于涉及到非结构性的递归，反演原理可能不直接适用，需要更深入的分析。

---

## 总结

在本节中，我们深入探讨了**反演原理**在类型理论中的应用。通过从引入规则中推导消除规则和计算规则，我们能够系统地构建类型的完整规则集，而无需额外的信息。反演原理的应用范围广泛，但在涉及到假设解除的构造（如蕴涵和全称量词）时，需要引入新的机制（如假设性假设）来解决困难。

反演原理不仅有助于理解类型理论的结构，还为我们提供了扩展类型系统的指导方针，确保新添加的类型和构造保持系统的一致性和健全性。

---

## 参考文献

- [Prawitz, D. (1965).] *Natural Deduction: A Proof-Theoretical Study*. Almqvist & Wiksell.
- [Schroeder-Heister, P. (1983a).] "A natural extension of natural deduction." *Journal of Symbolic Logic*, 48(1), 128–162.
- [Schroeder-Heister, P. (1983b).] "Rules of definitional reflection." In *Proceedings of the 8th International Congress of Logic, Methodology and Philosophy of Science*, 1983.
- [Backhouse, R. C. (1986).] "An inversion principle for constructor-based inductive definitions." *Mathematical Structures in Computer Science*, 1(1), 1–10.
- [Dybjer, P. (1989).] "Inductive sets and families in Martin-Löf's type theory and their set-theoretic semantics." In *Logical Frameworks*, Cambridge University Press.
- [Dyckhoff, R. (1985).] "Contraction-free sequent calculi for intuitionistic logic." *Journal of Symbolic Logic*, 50(3), 705–718.

### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------
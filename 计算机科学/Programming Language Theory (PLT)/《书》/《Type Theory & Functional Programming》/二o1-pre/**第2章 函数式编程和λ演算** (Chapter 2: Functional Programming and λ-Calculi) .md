[toc]



### **Chapter 2 Functional Programming and λ-Calculi (函数式编程与 λ 演算)**

#### **解释：**

在第二章中，作者探讨了**类型理论**与逻辑和函数式编程语言的联系。类型理论兼具逻辑和函数式编程语言的特性。作者首先回顾了当前函数式编程的实践，然后研究了各种 **λ-演算**（λ-calculi），这是一种关于函数的形式理论。

**关键点：**

- **λ-演算**最初由 Alonzo Church 于 20 世纪 30 年代发明，作为一种函数的表示法，旨在为数学建立基础。
- 尽管最初的目标未能实现，但 λ-演算本身已成为一个重要的研究对象。
- λ-演算在计算机科学的基础中发挥了重要作用，尤其是在**指称语义学**（denotational semantics）中。
- 本章主要研究**无类型 λ-演算**（untyped λ-calculus），然后讨论与当前函数式编程实践更为密切的**类型化理论**（typed theories）。

#### **内容概述：**

- **变量绑定和替换**：λ-演算的核心概念，涉及如何处理函数的形式参数和实际参数。
- **求值或归约关系**：讨论了表示计算的关系“$\to\to$”和表示等价的“$\leftrightarrow$”。
- **计算和等价规则**：区分了不同类型的归约规则，分析它们在计算中的作用。
- **类型化理论**：介绍了类型化的 λ-演算，强调了类型系统在确保程序**强归约**（strong normalization）方面的作用，即所有的计算序列都是有限的，每个程序都能终止。
- **证明强归约定理**：提供了一个证明模型，使用对类型的归纳和强归纳假设的方法。
- **扩展类型结构**：引入了乘积类型和自然数，进一步讨论了类型化语言中的计算和等价规则。

---

### **2.1 Functional Programming (函数式编程)**

#### **解释：**

**函数式编程**（Functional Programming）在过去 30 年中不断发展，从早期的 LISP 方言，到如今的多种高质量的语言，如 **Haskell**、**Hope**、**Miranda** 和 **Standard ML (SML)** 等。这些语言尽管存在差异，但在以下方面达成了广泛共识：

1. **一等公民的函数（First-class functions）**：

   - **函数可以作为参数传递、作为结果返回、并可包含在数据结构中**。
   - **示例**：`map` 函数，它接受一个函数 `f` 作为参数，返回一个新的函数，该函数将 `f` 应用于列表的每个元素。

2. **强类型系统（Strong type systems）**：

   - **语言区分不同类型的值，将相似的值归类为类型**。
   - **强类型**意味着类型不匹配的错误在运行时不会发生。例如，不允许对两个布尔值进行加法操作。
   - **优点**：在编译时捕获类型错误，提高程序的可靠性。

3. **多态类型（Polymorphic types）**：

   - **允许泛型编程，使得函数可以应用于不同类型**。
   - **Hindley-Milner 类型系统**支持这种泛型，同时保持强类型。
   - **示例**：恒等函数的类型为 `* -> *`，其中 `*` 是类型变量，表示该函数可以接受任何类型的参数并返回相同类型的结果。

4. **代数数据类型（Algebraic types）**：

   - **可以直接通过递归定义列表、树等数据结构，而不需要指针类型**。
   - **代数类型**泛化了枚举类型、（可变）记录和某些指针类型定义。
   - **模式匹配（Pattern matching）**用于进行案例分析和组件选择。

5. **模块化（Modularity）**：

   - **语言提供了模块系统，帮助开发大型系统**。
   - **模块化**提高了代码的可维护性和可重用性。

#### **差异：**

- **求值机制的差异**：

  - **严格求值（Strict evaluation）**：

    - 例如，SML 采用严格求值，函数的参数在函数体实例化之前就被求值。
    - 数据类型的组件在对象形成时被完全求值。

  - **惰性求值（Lazy evaluation）**：

    - 例如，Miranda 和 Haskell 采用惰性求值，函数的参数和数据类型的组件只有在必要时才被求值。
    - **优势**：允许使用无限和部分定义的数据结构，支持一种独特的编程风格。

  - **混合模式**：

    - **Hope+** 等语言结合了严格和惰性求值的机制。

#### **参考书籍：**

- **函数式编程入门教材**：[BW88]、[Rea89]、[Wik87]。
- **主题基础**：[Hue90a]。
- **当前研究方向**：[Pey87]、[Tur90]。

#### **总结：**

- 本节概述了函数式编程的主要特征和发展方向。
- 接下来，作者将讨论 **λ-演算**，它既是现代函数式编程语言的前身，也是它们的抽象版本。

---

### **2.2 The untyped λ-calculus (无类型 λ-演算)**

#### **解释：**

**无类型 λ-演算**是 Alonzo Church 在 20 世纪 30 年代开发的，后来由图灵（Turing）、柯里（Curry）和克莱尼（Kleene）等同时代的学者研究。它提供了一个**简洁的函数式编程语言**，其中**每个对象都被视为一个函数**。

- **特点**：

  - 语法极其简单。
  - 为理解现代函数式编程语言的基础。

#### **定义 2.1：**

**λ-表达式（λ-expressions）**有三种形式：

1. **变量（Variables）**：

   - $v_0, v_1, v_2, \ldots$
   - 在后续内容中，我们用 $x, y, z, u, v, \ldots$ 表示任意变量。

2. **应用（Applications）**：

   - $(e_1 e_2)$
   - 表示将表达式 $e_1$ **应用于** $e_2$。

3. **抽象（Abstractions）**：

   - $\lambda x . e$
   - 表示一个函数，其**形式参数**为 $x$，**结果**为 $e$。

#### **符号约定（Definition 2.2）：**

为了提高可读性，采用以下约定：

- **C1**：**应用比抽象结合得更紧密**。

  - 例如，$\lambda x . x y$ 表示 $\lambda x . (x y)$，而不是 $(\lambda x . x) y$。

- **C2**：**应用是左结合的**。

  - 例如，$x y z$ 表示 $(x y) z$，而不是 $x (y z)$。

- **C3**：多个 λ 抽象可以连写。

  - 例如，$\lambda x_1 . \lambda x_2 . \ldots . \lambda x_n . e$ 表示 $\lambda x_1 . (\lambda x_2 . (\ldots (\lambda x_n . e)))$。

#### **λ-抽象的核心机制：**

- **形式参数和结果**：

  - $\lambda x . e$ 表示一个函数，形式参数为 $x$，结果为 $e$。

- **匿名函数**：

  - λ-演算使用匿名函数，不需要给函数命名。

- **形式参数的可替换性**：

  - 由于形式参数是占位符，我们期望 $\lambda x . \lambda y . x y$ 与 $\lambda u . \lambda v . u v$ 没有区别。

- **变量的绑定（Definition 2.3）**：

  - **绑定变量（Bound variable）**：在 $\lambda x . e$ 中，变量 $x$ 被绑定。
  - **自由变量（Free variable）**：未被绑定的变量。
  - **闭合表达式（Closed expression）**：不含自由变量的表达式。

- **示例**：

  - 在表达式 $(\lambda x . \lambda y . y x)((\lambda z . z x) x)$ 中，第一个 $x$ 是绑定的，第二和第三个 $x$ 是自由的。

#### **变量替换（Definition 2.4）**：

- **替换记号**：$e[f / x]$ 表示在表达式 $e$ 中，用 $f$ **替换自由的** $x$。

- **替换规则**：

  - **变量替换**：

    - $x[f / x] = f$
    - 对于 $y \ne x$，$y[f / x] = y$

  - **应用替换**：

    - $(e_1 e_2)[f / x] = (e_1[f / x] \ e_2[f / x])$

  - **抽象替换**：

    - 如果 $e \equiv \lambda x . g$，则 $e[f / x] = e$（因为 $x$ 在 $e$ 中被绑定，不替换）。

    - 如果 $e \equiv \lambda y . g$，且 $y \ne x$：

      - **如果 $y$ 不在 $f$ 中自由出现**，则 $e[f / x] = \lambda y . (g[f / x])$。

      - **如果 $y$ 在 $f$ 中自由出现**，为了避免**变量捕获**，需要重命名：

        - $e[f / x] = \lambda z . (g[z / y][f / x])$，其中 $z$ 是一个不在 $f$ 和 $g$ 中出现的新变量。

- **变量捕获（Variable Capture）**：

  - 在替换时，必须避免自由变量变成绑定变量。

- **表达式等价的约定**：

  - **α-等价（Alpha-equivalence）**：如果两个表达式仅绑定变量的名字不同，则视为等价。
  - **约定**：在后续讨论中，我们不区分仅绑定变量名不同的表达式。

#### **β-归约（Beta Reduction）（Definition 2.5）**：

- **β-归约规则**：

  $$
  (\lambda x . e) f \to_\beta e[f / x]
  $$

- **解释**：

  - 将函数应用 $(\lambda x . e) f$ 归约为 $e[f / x]$。
  - 即，将实际参数 $f$ 替换到函数体 $e$ 中的形式参数 $x$。

#### **Redex（可归约表达式）和归约（Definition 2.6）**：

- **Redex（可归约表达式）**：

  - 形如 $(\lambda x . e) f$ 的子表达式称为 **redex**。

- **归约规则**：

  - 如果 $e \to_\beta e'$，则：

    - $(f e) \to_\beta (f e')$
    - $(e g) \to_\beta (e' g)$
    - $\lambda y . e \to_\beta \lambda y . e'$

- **归约序列（Definition 2.7）**：

  - 如果存在一系列归约步骤 $e \equiv e_0 \to_\beta e_1 \to_\beta \ldots \to_\beta e_n \equiv f$，则记为 $e \to\to f$。

- **解释**：

  - $f$ 是 $e$ 经过若干归约步骤得到的结果。

#### **Curry 化（Currying）**：

- **多元函数的表示**：

  - 虽然 λ-演算仅处理一元函数，但可以通过 **Curry 化** 表示多元函数。
  - **示例**：加法函数可以表示为 $\lambda x . \lambda y . (x + y)$。

- **部分应用**：

  - 可以对函数进行部分应用，例如 $(\lambda x . \lambda y . (x + y))\ 4$，得到一个将参数加 4 的函数。

#### **练习 2.1：**

- **研究以下表达式的归约行为**：

  1. $(\lambda x . x)((\lambda y . (\lambda z . z))(\lambda x . x))$
  2. $(\lambda x . x x x)(\lambda x . x x x)$

---

### **2.3 Evaluation (求值)**

#### **解释：**

在上一节中，我们定义了归约关系 $\to\to$，它表示通过若干基本计算步骤将一个表达式归约为另一个表达式。现在，我们探讨关于这个归约关系的几个基本问题：

1. **表达式求值的结果是什么？**

2. **不同的归约序列是否会得到相同的结果？**

3. **是否所有的归约序列都会终止？**

#### **结果的形式：**

**定义 2.8：**

- **正常形（Normal Form）**：

  - 一个表达式不包含任何 redex（可归约表达式），即无法进一步归约。

- **头部正常形（Head Normal Form）**：

  - 形如 $\lambda x_1 . \ldots . \lambda x_n . y e_1 \ldots e_m$ 的表达式。
  - $y$ 是一个变量，$e_1, \ldots, e_m$ 是任意表达式，$n, m \geq 0$。

- **弱头部正常形（Weak Head Normal Form）**：

  - 要么是一个 λ 抽象 $\lambda x . e$。
  - 要么是形如 $y e_1 \ldots e_m$ 的表达式。

**定义 2.9：**

- 如果 $e \to\to e'$，且 $e'$ 是正常形、头部正常形或弱头部正常形，则称 $e'$ 分别是 $e$ 的正常形、头部正常形或弱头部正常形。

**包含关系**：

- **正常形 ⊆ 头部正常形 ⊆ 弱头部正常形**。

- **示例**：

  - **正常形**是最严格的，没有任何可进一步归约的部分。
  - **头部正常形**允许在参数位置存在未归约的部分。

**特殊表达式 $\Omega$**：

- 定义：$\Omega \equiv (\lambda x . x x)(\lambda x . x x)$。

- **性质**：

  - $\Omega \to_\beta \Omega$，即 $\Omega$ 自己归约到自己，形成无限循环。
  - **没有正常形**，也没有头部正常形或弱头部正常形。

**意义**：

- **正常形**可以被视为计算的结果。
- **头部正常形**和**弱头部正常形**在分析函数的计算行为时很重要。

#### **Church-Rosser 定理（Theorem 2.10）：**

- **陈述**：

  - 如果 $e \to\to f$，且 $e \to\to g$，则存在 $h$，使得 $f \to\to h$ 且 $g \to\to h$。

- **意义**：

  - **归约关系是确定性的**，不同的归约路径可以汇合到一个共同的表达式。

- **推论（Theorem 2.12）**：

  - **如果一个表达式有正常形，则它是唯一的**。

- **证明思路**：

  - 基于 Church-Rosser 定理，如果存在两个不同的正常形，则无法找到共同的归约结果，矛盾。

#### **归约策略的影响：**

- **左最外红ex（Leftmost Outermost Redex）**：

  - **定义**：

    - 在表达式中，按照从左到右、从外到内的顺序，找到第一个 redex 进行归约。

  - **归约策略**：

    - 始终选择左最外的 redex 进行归约。

- **正常化定理（Theorem 2.14）**：

  - **陈述**：

    - 如果一个表达式存在正常形，按照左最外红ex的归约策略，总能得到正常形。

- **反例**：

  - 如果选择其他归约策略，可能导致无限归约，即使存在正常形。

  - **示例**：

    - $(\lambda x . \lambda y . y) \Omega$。

    - 整个表达式可以归约为 $\lambda y . y$（正常形）。

    - 如果我们始终选择归约 $\Omega$，则会陷入无限循环。

#### **η-归约（Eta Reduction）（Definition 2.15）**：

- **规则**：

  $$
  \lambda x . (e x) \to_\eta e \quad \text{（前提：$x$ 不在 $e$ 中自由出现）}
  $$

- **解释**：

  - 如果函数 $\lambda x . (e x)$ 对所有参数的行为与 $e$ 相同，则可以将其归约为 $e$。

- **性质**：

  - **η-归约**通常被视为**等价规则**，而非计算规则。

  - **β-归约**是计算规则，表示函数应用的计算过程。

- **联合使用**：

  - 通常，我们将 **β-归约** 和 **η-归约** 结合起来，定义一个更强的等价关系。

#### **练习：**

1. **练习 2.2**：

   - 设 $I = \lambda x . x$。

   - **证明**：$\lambda x . x (I I)$ 和 $\lambda x . x I$ 都是 $\lambda x . (I x)(I I)$ 的头部正常形。

   - **解答**：

     - 计算 $\lambda x . (I x)(I I)$。

     - 由于 $I = \lambda x . x$，所以 $I x = x$。

     - 因此，$\lambda x . (I x)(I I) = \lambda x . x (I I)$。

     - 而 $I I = (\lambda x . x)(\lambda x . x) = \lambda x . x$。

     - 所以 $x (I I) = x (\lambda x . x) = x I$。

     - 因此，$\lambda x . x (I I) = \lambda x . x I$。

2. **练习 2.3**：

   - **证明**：从 Theorem 2.10（Church-Rosser 定理）推导 Theorem 2.12（正常形唯一性）。

   - **解答**：

     - 假设一个表达式 $e$ 有两个不同的正常形 $f$ 和 $g$。

     - 根据 Theorem 2.10，存在 $h$，使得 $f \to\to h$，$g \to\to h$。

     - 但由于 $f$ 和 $g$ 都是正常形，无法进一步归约，所以 $f = h = g$。

     - 因此，正常形是唯一的。

3. **练习 2.4**：

   - **论证**：以下表达式没有正常形。

     - **(a)** $\Omega = (\lambda x . x x)(\lambda x . x x)$。

     - **(b)** $(\lambda f . ((\lambda x . f (x x)) (\lambda x . f (x x)))) (\lambda x . \lambda y . x)$。

   - **解答**：

     - **(a)** 对于 $\Omega$：

       - $\Omega \to_\beta (\lambda x . x x)(\lambda x . x x) = \Omega$。

       - 因此，归约序列无限循环，没有正常形。

     - **(b)** 对于 $(\lambda f . ((\lambda x . f (x x)) (\lambda x . f (x x)))) (\lambda x . \lambda y . x)$：

       - 应用函数，替换 $f$：

         $$
         ((\lambda x . (\lambda x . \lambda y . x)(x x)) (\lambda x . (\lambda x . \lambda y . x)(x x)))
         $$

       - 归约后，发现会反复出现相同的结构，导致无限循环。

       - 因此，没有正常形。

---

### **总结：**

- 本章深入探讨了 **λ-演算** 的基本概念，包括其语法、变量绑定、替换和归约规则。
- 讨论了归约关系和正常形式，以及不同归约策略对求值的影响。
- 引入了 **Church-Rosser 定理** 和 **正常化定理** 等重要理论，说明了 λ-演算中归约的确定性和唯一性。
- 这些概念为后续对 **类型化 λ-演算** 和 **函数式编程语言** 的研究奠定了基础。

---

**如果您对任何概念有疑问，或者希望进一步探讨某个主题，请随时告诉我！**

### ---------------------------

### **2.4 Convertibility（可转换性）**

#### **解释：**

在前面的内容中，我们专注于 λ-演算中的计算关系，如 $\to_\beta$、$\to\to$ 和 $\to_\eta$。现在，我们可以提出一个更一般的问题：哪些表达式具有相同的计算行为？

**可转换性关系**是一种等价关系，它也是**可替代的（substitutive）**，即等价的表达式在等价的上下文中替换后仍然等价。

#### **定义新的关系：**

- **β-可转换性（β-convertibility）**：
  
  - **定义**：我们定义一种等价关系 $\leftrightarrow$，它是由 $\to\to$ 生成的最小等价关系。
  
  - **形式化**：如果存在一系列表达式 $e_0, e_1, \ldots, e_n$（$n \geq 0$），使得 $e \equiv e_0$，$e_n \equiv f$，并且对于每个 $i$，$0 \leq i < n$，要么 $e_i \to\to e_{i+1}$，要么 $e_{i+1} \to\to e_i$，则 $e \leftrightarrow f$。

- **βη-可转换性（βη-convertibility）**：

  - 这是基于同时考虑 β 和 η 归约的类似关系。

#### **性质：**

- **Church-Rosser 定理的结果**：根据 Church-Rosser 定理，如果两个表达式 $e$ 和 $f$ 通过一系列 β 或 η 归约可以转换到共同的表达式，那么它们是 βη-可转换的。

- **正常形的存在性**：如果其中一个表达式有正常形，那么另一个表达式也有相同的正常形。

- **示例**：

  - 考虑表达式 $\lambda y . (\lambda x . (y x))$ 和 $\lambda y . y$。

  - 它们应用到相同的参数时，产生相同的结果，因为：

    $$
    (\lambda y . (\lambda x . (y x))) z \to_\beta (\lambda x . (z x)) \to_\beta z
    $$

    $$
    (\lambda y . y) z \to_\beta z
    $$

  - 但是，它们的正常形不同，所以在仅考虑 β-可转换性时，它们不被视为等价。

- **Extensionality（外延性）**：

  - 为了解决上述问题，我们引入外延性（extensionality）的概念。

  - **外延性**：如果对于任意变量 $y$，有 $(f\ y) \leftrightarrow (g\ y)$，那么 $f \leftrightarrow g$。

  - **βη-可转换性**是满足外延性的最小可替代等价关系。

#### **作用：**

- **计算行为的分析**：可转换性关系帮助我们理解哪些函数具有相同的计算行为，以及哪些变换（将一个表达式转换为另一个）是允许的。

- **推理的基础**：在讨论类型化 λ-演算之前，我们引入这些关系，为后续的推理和证明奠定基础。

#### **练习 2.5：**

**证明**：如果表达式 $e$ 形如 $\lambda y . e_0$，并且 $x$ 不在 $e_0$ 中自由出现，那么：

$$
(\lambda x . e x) \to_\beta e
$$

**解答**：

- 由于 $x$ 不在 $e_0$ 中自由出现，$e$ 可以写为 $\lambda y . e_0$。

- 计算：

  $$
  (\lambda x . e x) \to_\beta e x
  $$

- 由于 $x$ 不在 $e_0$ 中自由出现，$e x$ 实际上等于 $e$，因为 $x$ 不影响 $e_0$。

- 因此，$(\lambda x . e x) \to_\beta e$。

---

### **2.5 Expressiveness（表达能力）**

#### **解释：**

尽管无类型 λ-演算是一个纯函数的简单理论，但在计算上，它与其他基本的计算理论一样强大。具体来说，它是**图灵完备的（Turing-complete）**，与图灵可计算性等价。

#### **构造自然数和递归函数：**

- **自然数的表示**：

  - 自然数可以表示为**迭代器（iterators）**。

  - 数字 $n$ 表示为：

    $$
    \lambda f . \lambda x . f (f (\ldots (f x) \ldots))
    $$

    其中，$f$ 被应用了 $n$ 次。

- **递归函数的定义**：

  - 为了定义递归函数，例如：

    $$
    f x = \text{...} f \text{...}
    $$

  - 可以写成：

    $$
    f = \lambda x . \text{...} f \text{...}
    $$

  - 需要解决如下形式的方程：

    $$
    f = R f
    $$

    其中，$R$ 是一个 λ-表达式。

- **不动点组合子（Fixed Point Combinators）**：

  - 为了求解上述方程，引入不动点组合子 $F$，使得：

    $$
    F R \to\to R (F R)
    $$

  - **示例**：

    - Curry 的 Y 组合子：

      $$
      Y = \lambda f . (\lambda x . f (x x)) (\lambda x . f (x x))
      $$

    - Scott 的固定点组合子：

      $$
      \theta = \lambda a . \lambda b . b (a a b)
      $$

#### **性质：**

- **没有正常形**：

  - 固定点组合子自身没有正常形，但可以在某些上下文中产生有意义的结果。

  - **原因**：

    - 对于 $F$，有：

      $$
      \lambda x . (F x) \to_\beta \lambda x . x (F x) \to_\beta \lambda x . x (x (F x)) \to_\beta \ldots
      $$

    - 归约序列无限，不存在正常形。

- **意义**：

  - 这表明，即使某些表达式没有正常形，它们仍然可以代表有意义的函数。

  - 这拓展了有意义的表达式的范围，超出了那些具有正常形的表达式。

---

### **2.6 Typed λ-calculus（类型化 λ-演算）**

#### **解释：**

无类型 λ-演算虽然强大，但缺乏类型系统可能导致程序违反概念上的类型规则。例如，允许将任意对象应用于自身，这在大多数类型系统中是不允许的。

引入类型系统后，我们可以：

- **防止类型错误**：如只允许数字参与加法运算。

- **消除非终止的情况**：通过限制无法类型化的表达式，避免某些无限循环。

#### **定义类型系统：**

**定义 2.17：**

- **类型的构造**：

  - **基本类型（Base Types）**：一个给定的基本类型集合 $B$，如 $B = \{\text{Int}, \text{Bool}\}$。

  - **函数类型（Function Types）**：如果 $\sigma$ 和 $\tau$ 是类型，那么 $(\sigma \Rightarrow \tau)$ 也是一个类型。

  - **类型集合 $S$**：通过基本类型和函数类型的构造规则生成的类型集合。

- **约定**：函数类型是右结合的，因此可以省略某些括号。例如，$\sigma \Rightarrow \tau \Rightarrow \rho$ 表示 $\sigma \Rightarrow (\tau \Rightarrow \rho)$。

**定义 2.18：**

- **类型化 λ-表达式的形式**：

  1. **变量**：对于每个类型 $\tau$，有无限多个变量 $v_{\tau,0}, v_{\tau,1}, \ldots$。

     - **记法**：$v_\tau$ 表示类型为 $\tau$ 的变量。

  2. **应用**：

     - 如果 $e_1 : (\sigma \Rightarrow \tau)$，$e_2 : \sigma$，则 $(e_1\ e_2) : \tau$。

     - **要求**：函数的参数类型必须与传入的参数类型匹配。

  3. **抽象**：

     - 如果 $x : \sigma$，$e : \tau$，则 $(\lambda x^\sigma . e) : (\sigma \Rightarrow \tau)$。

     - **解释**：抽象的类型是一个函数类型，参数类型为 $\sigma$，结果类型为 $\tau$。

#### **变量绑定和替换：**

- **许多在无类型 λ-演算中的概念都适用于类型化 λ-演算**，包括变量绑定、替换、β-归约、η-归约等。

- **可转换性**：可转换的表达式必须具有相同的类型。

#### **重要性质：**

- **无法构造某些无类型 λ-演算中的表达式**：

  - 例如，无法构造 $x^\sigma x^\sigma$，因为这要求 $x^\sigma : \sigma \Rightarrow \tau$，同时 $\sigma = \sigma \Rightarrow \tau$，这导致类型不一致。

- **无法定义固定点组合子**：

  - 因为需要将一个函数应用于自身，而这在类型系统中通常是不允许的。

#### **强归约性定理（Theorem 2.19）：**

- **陈述**：在简单类型 λ-演算中，每个归约序列都是有限的，即所有计算都终止。

- **意义**：

  - 这表明类型系统限制了非终止计算的出现。

  - **证明**：将在下一节详细讨论。

#### **类型化 λ-演算的另一种表示：**

- **类型上下文（Type Context）**：

  - 使用一个类型上下文 $\Gamma$，它是变量的类型假设集合。

  - **记法**：$\Gamma, x : \tau$ 表示在上下文 $\Gamma$ 中添加了变量 $x$ 的类型假设 $x : \tau$。

- **推导规则（Definition 2.20）：**

  1. **变量**：

     - 如果 $x : \tau$ 在上下文 $\Gamma$ 中，那么 $\Gamma \vdash x : \tau$。

  2. **应用**：

     - 如果 $\Gamma \vdash e_1 : (\sigma \Rightarrow \tau)$，$\Gamma \vdash e_2 : \sigma$，那么 $\Gamma \vdash (e_1\ e_2) : \tau$。

  3. **抽象**：

     - 如果 $\Gamma, x : \sigma \vdash e : \tau$，那么 $\Gamma \vdash (\lambda x^\sigma . e) : (\sigma \Rightarrow \tau)$。

- **注意**：

  - 在抽象的推导规则中，变量 $x : \sigma$ 的假设用于类型化函数体 $e$，但不出现在抽象的类型中。

  - 变量 $x$ 在 $\lambda x^\sigma . e$ 中被绑定，其作用域是 $e$。

#### **练习 2.6：**

**证明**：$\lambda x . \lambda y . \lambda z . (x z) (y z)$ 的类型为 $(\sigma \Rightarrow \tau \Rightarrow \rho) \Rightarrow (\sigma \Rightarrow \tau) \Rightarrow (\sigma \Rightarrow \rho)$。

**解答**：

- **目标**：确定表达式的类型。

- **步骤**：

  1. **设定变量的类型**：

     - $x : \sigma \Rightarrow \tau \Rightarrow \rho$。

     - $y : \sigma \Rightarrow \tau$。

     - $z : \sigma$。

  2. **类型化内部表达式**：

     - $x z : \tau \Rightarrow \rho$（因为 $x : \sigma \Rightarrow \tau \Rightarrow \rho$，$z : \sigma$）。

     - $y z : \tau$。

  3. **应用**：

     - $(x z) (y z) : \rho$。

  4. **构建函数类型**：

     - $\lambda z^\sigma . (x z)(y z) : \rho$。

     - $\lambda y^{\sigma \Rightarrow \tau} . \lambda z^\sigma . (x z)(y z) : (\sigma \Rightarrow \tau) \Rightarrow \rho$。

     - $\lambda x^{\sigma \Rightarrow \tau \Rightarrow \rho} . \lambda y^{\sigma \Rightarrow \tau} . \lambda z^\sigma . (x z)(y z) : (\sigma \Rightarrow \tau \Rightarrow \rho) \Rightarrow (\sigma \Rightarrow \tau) \Rightarrow (\sigma \Rightarrow \rho)$。

#### **练习 2.7：**

**解释**：为什么 $\lambda x . x x$ 和固定点组合子 $F$ 不是类型化 λ-演算的项。

**解答**：

- **对于 $\lambda x . x x$**：

  - 设想 $x$ 的类型为 $\tau$，则应用 $x x$ 要求 $x : \tau \Rightarrow \sigma$，且 $x : \tau$。

  - 这意味着 $\tau = \tau \Rightarrow \sigma$，导致无限类型，无法分配具体类型。

- **对于固定点组合子 $F$**：

  - 固定点组合子通常涉及将一个函数应用于自身，如 $F = \lambda f . (\lambda x . f (x x)) (\lambda x . f (x x))$。

  - 这里，$x x$ 出现了同样的问题，无法为 $x$ 分配合适的类型。

- **结论**：

  - 在类型化 λ-演算中，不允许将一个表达式应用于自身，这阻止了像 $\lambda x . x x$ 和固定点组合子这样的表达式的构造。

---

### **2.7 Strong Normalisation（强归约性）**

#### **解释：**

**强归约性定理**（Theorem 2.21）是一个重要的结果，它证明了在简单类型 λ-演算中，所有的归约序列都是有限的。

**证明方法**：

- **归纳方法**：

  - **不能**直接对表达式的结构进行归纳，因为这在无类型 λ-演算中也适用，而我们知道无类型 λ-演算中存在非终止的归约序列。

  - **采用对类型的归纳**，这是一种更强的归纳方法。

- **可还原性方法（Reducibility Method）**：

  - 由 William Tait 引入，用于证明类型化系统的归约性。

  - **关键思想**：对类型的复杂性进行归纳，而非表达式的结构。

#### **定义稳定性（Stability）：**

- **定义 2.23**：一个类型为 $\tau$ 的表达式 $e$ 是**稳定的**（记为 $e \in \| \tau \|$）如果：

  - **对于基本类型**，$e$ 是强归约的（SN）。

  - **对于函数类型 $\sigma \Rightarrow \tau$**，如果对于所有稳定的 $e'$（$e' \in \| \sigma \|$），都有 $(e\ e') \in \| \tau \|$。

- **目的**：稳定性旨在确保在应用中被保持，使得归纳证明能够进行。

#### **辅助引理：**

**引理 2.24**：

- **(a)** 变量 $x$ 是强归约的。

- **(b)** 如果 $e_1, \ldots, e_k$ 是强归约的，那么 $x e_1 \ldots e_k$ 也是强归约的。

- **(c)** 如果 $e x$ 是强归约的，那么 $e$ 是强归约的。

- **(d)** 如果 $e$ 是强归约的，那么 $\lambda x . e$ 是强归约的。

**证明要点**：

- 利用归约序列的形式，证明变量和应用的强归约性。

- 对于抽象，归约序列可映射到函数体 $e$ 的归约序列。

#### **主要引理的证明步骤：**

**引理 2.25**：

- **(a)** 如果 $e \in \| \tau \|$，则 $e$ 是强归约的。

- **(b)** 如果 $x e_1 \ldots e_n : \tau$，且 $e_1, \ldots, e_n$ 是强归约的，那么 $x e_1 \ldots e_n \in \| \tau \|$。

- **(c)** 如果 $x : \tau$，则 $x \in \| \tau \|$。

**证明方法**：

- **对类型 $\tau$ 进行归纳**，分别处理基本类型和函数类型。

- **基本类型**：

  - **(a)**：根据稳定性的定义，立即成立。

  - **(b)**：利用引理 2.24 (b)，证明 $x e_1 \ldots e_n$ 是强归约的，进而是稳定的。

  - **(c)**：变量 $x$ 是强归约的，因此稳定。

- **函数类型**：

  - **(a)**：假设 $e \in \| \sigma \Rightarrow \rho \|$。

    - 对于任意稳定的 $e'$，$(e\ e')$ 是稳定的。

    - 由归纳假设，$(e\ e')$ 是强归约的。

    - 利用引理 2.24 (c)，得出 $e$ 是强归约的。

  - **(b)**：类似地，证明 $x e_1 \ldots e_n$ 的稳定性。

  - **(c)**：证明 $x$ 的稳定性。

#### **证明所有表达式的稳定性：**

**引理 2.27**：

- **(a)** 如果 $e$ 和 $f$ 是稳定的，那么 $(e\ f)$ 是稳定的。

- **(b)** 对于所有 $k \geq 0$，如果 $f[g/x] h_1 \ldots h_k \in \| \tau \|$ 且 $g$ 是强归约的，那么 $(\lambda x . f) g h_1 \ldots h_k \in \| \tau \|$。

- **(c)** 所有表达式的替换实例都是稳定的。

**证明要点**：

- **(a)**：根据稳定性的定义，应用于函数类型。

- **(b)**：对类型 $\tau$ 进行归纳，处理基本类型和函数类型。

  - **基本类型**：分析归约序列的形式，证明 $(\lambda x . f) g h_1 \ldots h_k$ 是强归约的，进而稳定。

  - **函数类型**：利用归纳假设，证明稳定性。

- **(c)**：对表达式的结构进行归纳，处理变量、应用和抽象。

  - **变量**：替换实例要么是稳定的表达式，要么是原变量（稳定）。

  - **应用**：利用 (a) 和归纳假设。

  - **抽象**：证明 $(\lambda x . f')$ 的稳定性，其中 $f'$ 是 $f$ 的替换实例。

    - 利用 (b) 和归纳假设。

#### **结论：**

- **所有表达式都是稳定的**（引理 2.27 (c)）。

- **因此，所有表达式都是强归约的**（引理 2.25 (a)）。

- **这证明了强归约性定理（Theorem 2.21）**。

#### **总结：**

- **通过对类型的归纳和引入稳定性的概念，我们证明了所有类型化 λ-演算的表达式都是强归约的**。

- **这种证明方法在类型化系统中非常有用，能够确保程序的终止性和可靠性**。

---

**如果您对任何概念有疑问，或者希望进一步探讨某个主题，请随时告诉我！**

### ----------------------------

### **2.8 Further Type Constructors: The Product (进一步的类型构造：乘积类型)**

#### **解释：**

在之前的简单类型 λ-演算中，我们的类型系统非常简单，只包含了一些未指定的基本类型（base types）和一个类型构造，即函数类型构造（function space）。为了增强系统的表达能力，我们可以通过两种方式扩展类型系统：

1. **添加新的基本类型**：例如，自然数、布尔值等具体类型。
2. **添加新的类型构造器**：例如，乘积类型（product type）、和类型（sum type）等。

在本节中，我们将首先关注**类型构造器**的扩展，特别是引入**乘积类型**。乘积类型在编程语言中非常常见，用于表示多个类型的组合。

#### **乘积类型的引入：**

**乘积类型**允许我们将两个类型 $\sigma$ 和 $\tau$ 组合成一个新的类型 $\sigma \times \tau$，表示类型 $\sigma$ 和 $\tau$ 的有序对。

**扩展类型的定义：**

- **新规则**：如果 $\sigma$ 和 $\tau$ 是类型，那么 $\sigma \times \tau$ 也是一个类型。

  $$
  \text{如果 } \sigma, \tau \text{ 是类型，则 } \sigma \times \tau \text{ 也是类型。}
  $$

**扩展表达式的定义：**

- **对表达式的定义增加两项**：

  1. **对**（Pairs）：

     - **形成规则**：如果 $x : \sigma$ 且 $y : \tau$，则 $(x, y) : \sigma \times \tau$。
     
     - **解释**：$(x, y)$ 是类型 $\sigma \times \tau$ 的一个元素，即由 $x$ 和 $y$ 组成的有序对。

  2. **投影（Projections）**：

     - **第一投影**：如果 $p : \sigma \times \tau$，则 $\text{fst } p : \sigma$。
     
     - **第二投影**：如果 $p : \sigma \times \tau$，则 $\text{snd } p : \tau$。
     
     - **解释**：$\text{fst}$ 和 $\text{snd}$ 是投影操作，分别提取对的第一个和第二个组件。

**扩展计算规则：**

- **添加计算规则**：

  1. **对投影的计算规则**：

     $$
     \text{fst } (p, q) \to p
     $$

     $$
     \text{snd } (p, q) \to q
     $$

     - **解释**：这些规则说明了 $\text{fst}$ 和 $\text{snd}$ 的行为，即从对 $(p, q)$ 中提取相应的组件。

  2. **对的归约规则**：

     - 如果 $p \to p'$，则：

       $$
       (p, q) \to (p', q)
       $$

     - 如果 $q \to q'$，则：

       $$
       (p, q) \to (p, q')
       $$

     - **解释**：如果对的一个组件可以归约，那么整个对可以归约为包含归约后的组件的新的对。

- **添加等价规则（可选）**：

  1. **对的重建规则**：

     $$
     (\text{fst } p, \text{snd } p) \to p
     $$

     - **解释**：对于类型为 $\sigma \times \tau$ 的 $p$，通过将 $p$ 的两个投影重新组合成对，可以得到与 $p$ 等价的表达式。

- **等价关系的结果**：

  - 如果 $\text{fst } p \leftrightarrow \text{fst } q$ 且 $\text{snd } p \leftrightarrow \text{snd } q$，那么：

    $$
    p \leftrightarrow (\text{fst } p, \text{snd } p) \leftrightarrow (\text{fst } q, \text{snd } q) \leftrightarrow q
    $$

  - **解释**：如果两个对的相应组件等价，那么整个对也是等价的。

#### **关于投影操作的进一步讨论：**

- **投影操作 $\text{fst}$ 和 $\text{snd}$ 可以作为基本的原语操作**，也可以视为具有特定类型的常量。

- **类型化的投影操作**：

  - 对于每个乘积类型 $\sigma \times \tau$，有：

    $$
    \text{fst}_{\sigma, \tau} : (\sigma \times \tau) \Rightarrow \sigma
    $$

    $$
    \text{snd}_{\sigma, \tau} : (\sigma \times \tau) \Rightarrow \tau
    $$

  - **问题**：这种表示会使我们的符号变得繁琐，因为需要为每个乘积类型引入不同的投影操作。

- **省略类型下标**：

  - **实践中**，通常省略类型下标 $\sigma, \tau$，因为在上下文中可以推断出投影操作的类型。

- **引入多态性（Polymorphism）**：

  - **另一种方法**是引入**多态的**投影操作，使得 $\text{fst}$ 和 $\text{snd}$ 可以适用于所有乘积类型。

  - **多态类型**允许一个常量具有多个类型，例如：

    $$
    \text{fst} : (\sigma \times \tau) \Rightarrow \sigma \quad \text{对于所有类型 } \sigma, \tau
    $$

  - **多态性的引入**需要加强类型系统，允许多态类型的存在。

  - **参考文献**：关于多态性的详细讨论，可以参考 [Mil78] 和 [Rey90]。

#### **计算规则和等价规则的区别：**

- **计算规则（Computation Rules）**：

  - **作用**：指导实际的计算过程，表示可进行归约的地方。

  - **特征**：涉及任意类型的对象。

  - **示例**：

    - $\beta$-归约规则：

      $$
      (\lambda x . e) f \to e[f / x]
      $$

    - 投影的计算规则：

      $$
      \text{fst } (p, q) \to p
      $$

- **等价规则（Equivalence Rules）**：

  - **作用**：用于建立表达式之间的等价关系，但不一定用于实际计算。

  - **特征**：涉及特定类型的对象。

  - **示例**：

    - $\eta$-归约规则（需要 $e$ 是函数类型）：

      $$
      \lambda x . (e x) \to e
      $$

    - 对的重建规则（需要 $p$ 是乘积类型）：

      $$
      (\text{fst } p, \text{snd } p) \to p
      $$

- **区别总结**：

  - **计算规则**主要用于计算过程，指导表达式如何归约。

  - **等价规则**用于证明表达式的等价性，有助于在推理过程中变换表达式。

#### **练习 2.8：**

**证明**：

1. $\lambda x . \lambda y . \lambda z . (x (y, z)) : ((\sigma \times \tau) \Rightarrow \rho) \Rightarrow (\sigma \Rightarrow \tau \Rightarrow \rho)$

2. $\lambda x . \lambda y . (x\ (\text{fst } y)\ (\text{snd } y)) : (\sigma \Rightarrow \tau \Rightarrow \rho) \Rightarrow ((\sigma \times \tau) \Rightarrow \rho)$

**解答**：

1. **证明 $\lambda x . \lambda y . \lambda z . (x (y, z))$ 的类型**：

   - **设定变量类型**：

     - $x : (\sigma \times \tau) \Rightarrow \rho$
     - $y : \sigma$
     - $z : \tau$

   - **分析内部表达式**：

     - $(y, z) : \sigma \times \tau$
     - $x (y, z) : \rho$

   - **构建函数类型**：

     - $\lambda z^\tau . (x (y, z)) : \tau \Rightarrow \rho$
     - $\lambda y^\sigma . \lambda z^\tau . (x (y, z)) : \sigma \Rightarrow \tau \Rightarrow \rho$
     - $\lambda x^{(\sigma \times \tau) \Rightarrow \rho} . \lambda y^\sigma . \lambda z^\tau . (x (y, z)) : ((\sigma \times \tau) \Rightarrow \rho) \Rightarrow \sigma \Rightarrow \tau \Rightarrow \rho$

2. **证明 $\lambda x . \lambda y . (x\ (\text{fst } y)\ (\text{snd } y))$ 的类型**：

   - **设定变量类型**：

     - $x : \sigma \Rightarrow \tau \Rightarrow \rho$
     - $y : \sigma \times \tau$

   - **分析内部表达式**：

     - $\text{fst } y : \sigma$
     - $\text{snd } y : \tau$
     - $x\ (\text{fst } y)\ (\text{snd } y) : \rho$

   - **构建函数类型**：

     - $\lambda y^{\sigma \times \tau} . (x\ (\text{fst } y)\ (\text{snd } y)) : (\sigma \times \tau) \Rightarrow \rho$
     - $\lambda x^{\sigma \Rightarrow \tau \Rightarrow \rho} . \lambda y^{\sigma \times \tau} . (x\ (\text{fst } y)\ (\text{snd } y)) : (\sigma \Rightarrow \tau \Rightarrow \rho) \Rightarrow (\sigma \times \tau) \Rightarrow \rho$

---

### **2.9 Base Types: Natural Numbers（基本类型：自然数）**

#### **解释：**

在实际的计算中，我们通常需要处理具体的类型，例如自然数、布尔值、字符等。为了在类型化 λ-演算中表示和操作自然数，我们需要将自然数添加到类型系统中。

#### **将自然数添加到类型系统中：**

**扩展类型的定义：**

- **添加基本类型**：将自然数类型 $\mathbb{N}$ 添加到基本类型集合中。

  $$
  B = \{ \mathbb{N} \}
  $$

**扩展表达式的定义：**

- **增加两项**：

  1. **数字（Numbers）**：

     - **零**：$0$ 是类型 $\mathbb{N}$ 的表达式。
     - **后继函数**：如果 $n : \mathbb{N}$，则 $\text{succ } n : \mathbb{N}$。

     - **解释**：$\text{succ } n$ 表示 $n$ 的后继，即 $n + 1$。

  2. **原始递归（Primitive Recursion）**：

     - **定义**：对于任意类型 $\tau$，如果：

       - $e_0 : \tau$
       - $f : \mathbb{N} \Rightarrow \tau \Rightarrow \tau$

     - 则：

       $$
       \text{Prec } e_0\ f : \mathbb{N} \Rightarrow \tau
       $$

     - **解释**：$\text{Prec } e_0\ f$ 定义了一个从自然数到类型 $\tau$ 的函数，它是通过原始递归定义的。

     - **意义**：$\text{Prec } e_0\ f$ 表示函数 $F$，满足以下等式：

       $$
       F\ 0 = e_0
       $$

       $$
       F\ (n + 1) = f\ n\ (F\ n)
       $$

     - **$f$ 的类型**：$f : \mathbb{N} \Rightarrow \tau \Rightarrow \tau$，接收当前数 $n$ 和前一步的结果 $F\ n$，返回下一步的结果。

**添加计算规则：**

- **原始递归的归约规则**：

  1. **基例**：

     $$
     \text{Prec } e_0\ f\ 0 \to e_0
     $$

     - **解释**：当输入为 $0$ 时，直接返回 $e_0$。

  2. **递归步骤**：

     $$
     \text{Prec } e_0\ f\ (\text{succ } n) \to f\ n\ (\text{Prec } e_0\ f\ n)
     $$

     - **解释**：当输入为 $\text{succ } n$（即 $n + 1$）时，递归地调用 $\text{Prec } e_0\ f\ n$，并将结果与当前值 $n$ 传递给 $f$。

**添加等价规则（可选）**：

- **定义函数的等价性**：

  - 对于函数 $h : \mathbb{N} \Rightarrow \tau$，可以通过原始递归定义一个与 $h$ 等价的函数 $F$：

    - $F\ 0 = h\ 0$
    - $F\ (n + 1) = h\ (n + 1)$

  - **定义 $f$**：

    $$
    f\ n\ m = h\ (\text{succ } n)
    $$

  - **添加等价规则**：

    $$
    \text{Prec } (h\ 0)\ (\lambda n.\ \lambda m.\ h\ (\text{succ } n)) \to h
    $$

    - **解释**：这说明通过上述原始递归定义的函数 $F$ 与 $h$ 等价。

- **注意**：这些等价规则涉及的对象类型并非任意，而是特定类型（如 $\mathbb{N}$ 和 $\tau$）。

#### **强归约性的扩展：**

- 我们可以将**强归约性定理**（Strong Normalisation）扩展到包含乘积类型和自然数基本类型的系统。

- **稳定性的定义**需要调整：

  - **对于类型 $\mathbb{N}$**：表达式 $e$ 是稳定的当且仅当 $e$ 是强归约的。

  - **对于乘积类型**：如果对 $p$ 的组件 $\text{fst } p$ 和 $\text{snd } p$ 都是稳定的，那么 $p$ 是稳定的。

- **证明思路**：

  - **证明所有稳定的对象都是强归约的**。

  - **证明所有对象都是稳定的**，需要使用类似于之前的引理和归纳方法。

- **关键引理**：

  - 需要一个类似于引理 2.27 (b) 的辅助结果，说明如果从表达式 $\text{Prec } e_0\ f\ t$ 出发的所有单步归约得到的表达式都是稳定的，那么 $\text{Prec } e_0\ f\ t$ 也是稳定的。

  - **证明方法**：对类型进行归纳。

#### **练习 2.9：**

**要求**：给出加法和乘法的原始递归定义。

**解答**：

1. **加法的原始递归定义**：

   - **函数类型**：$\text{add} : \mathbb{N} \Rightarrow \mathbb{N} \Rightarrow \mathbb{N}$

   - **定义**：

     $$
     \text{add} = \lambda n.\ \text{Prec } n\ (\lambda n'.\ \lambda m.\ \text{succ } m)
     $$

     - **解释**：

       - **基例**：$\text{add}\ 0\ m = n = 0$，返回 $n$。

       - **递归步骤**：$\text{add}\ (\text{succ } n')\ m = \text{succ } (\text{add}\ n'\ m)$。

2. **乘法的原始递归定义**：

   - **函数类型**：$\text{mul} : \mathbb{N} \Rightarrow \mathbb{N} \Rightarrow \mathbb{N}$

   - **定义**：

     $$
     \text{mul} = \lambda n.\ \text{Prec } 0\ (\lambda n'.\ \lambda m.\ \text{add}\ m\ n)
     $$

     - **解释**：

       - **基例**：$\text{mul}\ 0\ m = 0$。

       - **递归步骤**：$\text{mul}\ (\text{succ } n')\ m = \text{add}\ m\ (\text{mul}\ n'\ m)$。

---

### **2.10 General Recursion（一般递归）**

#### **解释：**

在之前的类型化 λ-演算中，我们引入了原始递归（Primitive Recursion），它允许定义许多常用的递归函数。然而，原始递归的能力有限，无法表达所有可计算函数。

为了增加系统的表达能力，我们可以引入**一般递归**，这需要添加一个用于**通用递归**的操作符 $R$。

#### **通用递归操作符 $R$：**

- **性质**：

  $$
  R\ f \to f\ (R\ f)
  $$

  - **解释**：$R\ f$ 是 $f$ 的一个**不动点**（fixed point），即 $R\ f$ 满足 $R\ f = f\ (R\ f)$。

- **意义**：

  - 通过 $R$，我们可以定义一般递归函数，包括所有可计算函数。

  - 这比原始递归更强大。

#### **引入的问题：**

- **非终止的计算**：

  - 一般递归会引入非终止的计算，即存在归约序列无限长的表达式。

  - **示例**：

    - 对于任意函数 $f$，归约序列：

      $$
      R\ f \to f\ (R\ f) \to f\ (f\ (R\ f)) \to \ldots \to f^n\ (R\ f) \to \ldots
      $$

    - 如果 $f$ 不满足某些终止条件，计算将无限进行。

  - **特殊情况**：

    - 如果 $f = \lambda x . x$，即恒等函数，则：

      $$
      R\ (\lambda x . x) \to (\lambda x . x)\ (R\ (\lambda x . x)) \to R\ (\lambda x . x) \to \ldots
      $$

    - 归约序列无限循环，没有正常形。

#### **语义解释：**

- **指称语义学（Denotational Semantics）**：

  - 为了理解一般递归的语义，计算机科学家发展了**指称语义学**，特别是**域理论（Domain Theory）**。

  - **域理论**通过引入**域（domains）**，来形式化地描述递归和无限计算的行为。

  - **Scott 和 Strachey**在 20 世纪 60 年代后期的工作奠定了这一领域的基础。

  - **参考文献**：关于域理论的详细讨论，可以参考 [Sch86]。

#### **类型理论的处理方法：**

- **不同的途径**：

  - 在类型理论中，我们采用不同的方法，**避免引入非终止的计算**。

  - 我们倾向于保持系统的**归约性**，即所有计算都能终止，至少在某种形式上。

  - 这意味着我们可能不会在类型化 λ-演算中引入通用的递归操作符 $R$，或者需要以受限的方式引入。

#### **结论：**

- **一般递归**虽然增加了系统的表达能力，但也引入了复杂性和潜在的非终止计算。

- **类型化 λ-演算**需要在表达能力和可计算性之间取得平衡，以确保系统的可靠性和终止性。

---

### **2.11 Evaluation Revisited（再论求值）**

#### **解释：**

本节旨在总结之前在 2.3、2.4 和 2.8 节中关于**求值**、各种**正常形**、以及**计算规则**和**等价规则**的讨论。

在像 Miranda 这样的**（类型化的）函数式编程语言**中，我们可以要求系统对任意类型的表达式进行求值。然而，对于函数等高阶对象，系统无法直接打印其表示，只能输出类似 `<function>` 的信息。

#### **可打印值（Printable Values）：**

- **可打印值的特性**：

  1. **闭合（Closed）**：表达式不包含自由变量。

  2. **零阶类型（Zeroth-order Types）**：表达式的类型是基本类型或不包含函数类型构造的类型。

- **定义 2.28：类型的阶（Order of a Type）**：

  - **递归定义**：

    $$
    \delta(\tau) = \begin{cases}
    0, & \text{如果 } \tau \in B \\
    \max(\delta(\sigma), \delta(\rho)), & \text{如果 } \tau = \sigma \times \rho \\
    \max(\delta(\sigma) + 1, \delta(\rho)), & \text{如果 } \tau = \sigma \Rightarrow \rho \\
    \end{cases}
    $$

  - **解释**：

    - 基本类型的阶为 $0$。

    - 乘积类型的阶为其组成类型的阶的最大值。

    - 函数类型的阶为其参数类型的阶加 $1$ 与结果类型的阶的最大值。

- **定义 2.29：可打印值的定义**：

  - 我们所求值的表达式是**闭合的零阶类型**的表达式。

  - **结果**：求值的结果是闭合的、零阶类型的、处于**β-正常形**的表达式。

- **示例**：

  - **自然数类型 $\mathbb{N}$ 的可打印值**：

    - $0$、$\text{succ } 0$、$\text{succ } (\text{succ } 0)$ 等。

    - 即，所有闭合的、正常形的自然数表达式。

  - **乘积类型**：

    - 对于类型 $\sigma \times \tau$，可打印值是形如 $(t, s)$ 的闭合正常形，其中 $t$ 和 $s$ 分别是类型 $\sigma$ 和 $\tau$ 的可打印值。

#### **证明可打印值的唯一性：**

- **目标**：证明这些闭合正常形是零阶类型的唯一可打印值。

- **证明思路**：

  - **对自然数类型的表达式进行结构归纳**。

  - **分析可能的闭合正常形**：

    1. **变量**：不是闭合的（有自由变量）。

    2. **$0$**：是正常形，可打印。

    3. **$\text{succ } t$**：如果 $t$ 是可打印值，那么 $\text{succ } t$ 也是。

    4. **应用 $(f\ e)$**：

       - **分析 $f$ 的形式**：

         - **情况 1**：$f$ 是一个 λ-抽象或 $\text{Prec } t_1\ t_2$。

           - **矛盾**：因为 $(f\ e)$ 将形成一个 redex（可归约表达式），与正常形的定义矛盾。

         - **情况 2**：$f$ 是一个应用，例如 $g\ h$。

           - **展开 $f$**：将 $f$ 展开为 $g_1\ g_2\ \ldots\ g_k$。

           - **由于 $f$ 是闭合的，且是正常形，$g_1$ 必须是函数类型，但又不能是应用或 λ-抽象，矛盾。

- **结论**：只有 $0$ 和 $\text{succ } t$ 形式的闭合正常形是自然数类型的可打印值。

#### **关于等价规则的讨论：**

- **在求值过程中，我们不应用等价规则（例如 $\eta$-归约和乘积类型的等价规则）**。

- **原因**：

  - 等价规则的 redex 仅在特定条件下存在（例如函数类型或乘积类型），而我们的可打印值是零阶类型的闭合正常形，不包含这些高级类型的构造。

- **我们的假设**：

  - **闭合性（Closure）**：排除了包含自由变量的表达式，例如 $(\text{fst } p, \text{snd } p)$，其中 $p$ 是变量。

  - **可打印类型**：限制在零阶类型，排除了可能包含 $\eta$-redex 的函数类型表达式。

#### **总结：**

- **计算规则**（如 $\beta$-归约、原始递归的计算规则）足以用于求值特定的表达式，得到可打印值。

- **等价规则**（如 $\eta$-归约、乘积类型的等价规则）用于在推理过程中证明表达式的等价性，尤其是涉及包含变量的通用情况。

- **在实际编程中**，我们在运行程序时，关注的是求值到可打印值，而不是进行等价变换。

---

**总结整个章节的内容**：

- 我们扩展了简单类型 λ-演算，引入了乘积类型和自然数基本类型。

- 讨论了原始递归和一般递归的区别，以及它们在类型系统中的表示。

- 强调了计算规则和等价规则的区别，以及它们在求值和推理中的作用。

- 通过对可打印值的分析，说明了在求值过程中，我们只需要计算规则即可得到我们关心的结果。

---

**如果您对任何概念有疑问，或者希望进一步探讨某个主题，请随时告诉我！**

### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------
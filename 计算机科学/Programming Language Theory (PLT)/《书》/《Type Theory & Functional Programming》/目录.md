[toc]

- 《Type Theory & Functional Programming》

### 目录 (Contents)

**序言** (Preface) iii

**导言** (Introduction) 1

**第1章 逻辑导论** (Chapter 1: Introduction to Logic) 7  
1.1 命题逻辑 (Propositional Logic) 8  
1.2 谓词逻辑 (Predicate Logic) 16  
1.2.1 变量和替换 (Variables and Substitution) 18  
1.2.2 量词规则 (Quantifier Rules) 21  
1.2.3 示例 (Examples) 24

**第2章 函数式编程和λ演算** (Chapter 2: Functional Programming and λ-Calculi) 29  
2.1 函数式编程 (Functional Programming) 30  
2.2 无类型λ演算 (The Untyped λ-Calculus) 32  
2.3 评价 (Evaluation) 36  
2.4 可转换性 (Convertibility) 40  
2.5 表达能力 (Expressiveness) 41  
2.6 类型化λ演算 (Typed λ-Calculus) 42  
2.7 强归约 (Strong Normalisation) 45  
2.8 进一步的类型构造：乘积 (Further Type Constructors: The Product) 50  
2.9 基本类型：自然数 (Base Types: Natural Numbers) 53  
2.10 泛化递归 (General Recursion) 55  
2.11 重新探讨的评价 (Evaluation Revisited) 56

**第3章 构造性数学** (Chapter 3: Constructive Mathematics) 59

**第4章 类型论导论** (Chapter 4: Introduction to Type Theory) 67  
4.1 命题逻辑：非正式视角 (Propositional Logic: An Informal View) 69  
4.2 判断、证明与推导 (Judgements, Proofs and Derivations) 71  
4.3 命题演算规则 (The Rules for Propositional Calculus) 73  
4.4 Curry-Howard同构 (The Curry-Howard Isomorphism) 78  
4.5 一些例子 (Some Examples) 83  
4.6 量词 (Quantifiers) 88  
4.7 基本类型 (Base Types) 96  
4.8 自然数 (The Natural Numbers) 100  
4.9 良构类型——树 (Well-Founded Types — Trees) 105  
4.10 等式 (Equality) 109  
4.11 可转换性 (Convertibility) 117

**第5章 探索类型论** (Chapter 5: Exploring Type Theory) 125  
5.1 假设 (Assumptions) 126  
5.2 命名和缩写 (Naming and Abbreviations) 130  
5.3 规则修订 (Revising the Rules) 133  
5.4 可导性 (Derivability) 139  
5.5 计算 (Computation) 144  
5.6 TT$_{c}^{0}$：归约和它的推论 (TT$_{c}^{0}$: Normalisation and Its Corollaries) 153  
5.7 平等和等同 (Equalities and Identities) 163  
5.8 不同的平等 (Different Equalities) 168  
5.9 宇宙 (Universes) 174  
5.10 良构类型 (Well-Founded Types) 179  
5.11 表达能力 (Expressibility) 189  
5.12 Curry-Howard同构？ (The Curry-Howard Isomorphism?) 191

**第6章 应用类型论** (Chapter 6: Applying Type Theory) 195  
6.1 递归 (Recursion) 196  
6.2 案例研究——快速排序 (A Case Study – Quicksort) 207  
6.3 依赖类型和量词 (Dependent Types and Quantifiers) 214  
6.4 案例研究——向量 (A Case Study – Vectors) 226  
6.5 证明提取；自上而下的证明 (Proof Extraction; Top-Down Proof) 230  
6.6 程序开发——波兰国旗问题 (Program Development – Polish National Flag) 234  
6.7 程序转换 (Program Transformation) 238  
6.8 命令式编程 (Imperative Programming) 247  
6.9 文献中的例子 (Examples in the Literature) 249

**第7章 增强类型论** (Chapter 7: Augmenting Type Theory) 253  
7.1 背景 (Background) 255  
7.2 子集类型 (The Subset Type) 261  
7.3 命题非类型 (Propositions Not Types) 265  
7.4 子集必要吗？ (Are Subsets Necessary?) 268  
7.5 商类型或同余类型 (Quotient or Congruence Types) 273  
7.6 案例研究——实数 (Case Study – The Real Numbers) 278  
7.7 加强的规则；多态性 (Strengthened Rules; Polymorphism) 281  
7.8 良构递归 (Well-Founded Recursion) 286  
7.9 类型论中的良构递归 (Well-Founded Recursion in Type Theory) 292  
7.10 归纳类型 (Inductive Types) 298  
7.11 共同归纳 (Co-Inductions) 303  
7.12 部分对象和类型 (Partial Objects and Types) 309  
7.13 建模 (Modelling) 310

**第8章 基础** (Chapter 8: Foundations) 315  
8.1 证明理论 (Proof Theory) 315  
8.2 模型理论 (Model Theory) 321  
8.3 一般逻辑框架 (A General Framework for Logics) 324  
8.4 反转原则 (The Inversion Principle) 326

**第9章 结论** (Chapter 9: Conclusions) 331  
9.1 相关工作 (Related Work) 331  
9.2 结论性评论 (Concluding Remarks) 337

**规则表** (Rule Tables) 360





### -------------------

# 《Type Theory & Functional Programming》 目录总结

以下表格总结了《Type Theory & Functional Programming》一书的各章节及其小节的主要内容、关键点和作用。表格中包含章节编号、章节名称（中英文）、起始页码以及每个部分的简要概述。

| **章节**  | **小节** | **标题 (中英文)**                                            | **页码** | **内容概述**                                                 |
| --------- | -------- | ------------------------------------------------------------ | -------- | ------------------------------------------------------------ |
| **序言**  | -        | 序言 (Preface)                                               | iii      | 介绍本书的目标、读者对象及整体结构。                         |
| **导言**  | -        | 导言 (Introduction)                                          | 1        | 概述类型理论与函数式编程的重要性及其应用。                   |
| **第1章** | 1.1      | 命题逻辑 (Propositional Logic)                               | 8        | 介绍命题逻辑的基本元素、逻辑连接词、真值表及推理规则。       |
|           | 1.2      | 谓词逻辑 (Predicate Logic)                                   | 16       | 扩展命题逻辑，引入谓词、变量和量词，增强逻辑表达能力。       |
|           | 1.2.1    | 变量和替换 (Variables and Substitution)                      | 18       | 讨论变量的作用域及逻辑表达式中的替换规则。                   |
|           | 1.2.2    | 量词规则 (Quantifier Rules)                                  | 21       | 介绍全称量词和存在量词的引入与消除规则。                     |
|           | 1.2.3    | 示例 (Examples)                                              | 24       | 通过实例展示命题逻辑和谓词逻辑的应用。                       |
| **第2章** | 2.1      | 函数式编程 (Functional Programming)                          | 30       | 介绍函数式编程的基本概念、特点和优势。                       |
|           | 2.2      | 无类型λ演算 (The Untyped λ-Calculus)                         | 32       | 阐述λ演算的基本结构和规则，不涉及类型系统。                  |
|           | 2.3      | 评价 (Evaluation)                                            | 36       | 讨论λ表达式的求值过程和不同的求值策略。                      |
|           | 2.4      | 可转换性 (Convertibility)                                    | 40       | 介绍λ演算中的转换规则，如α、β和η转换。                       |
|           | 2.5      | 表达能力 (Expressiveness)                                    | 41       | 展示λ演算在表达各种计算概念上的能力。                        |
|           | 2.6      | 类型化λ演算 (Typed λ-Calculus)                               | 42       | 引入类型系统，为λ演算添加类型限制，增强安全性。              |
|           | 2.7      | 强归约 (Strong Normalisation)                                | 45       | 讨论强归约性质，确保λ表达式的归约过程终止。                  |
|           | 2.8      | 进一步的类型构造：乘积 (Further Type Constructors: The Product) | 50       | 介绍乘积类型，支持组合类型的数据结构。                       |
|           | 2.9      | 基本类型：自然数 (Base Types: Natural Numbers)               | 53       | 探讨自然数在λ演算中的表示和操作。                            |
|           | 2.10     | 泛化递归 (General Recursion)                                 | 55       | 讨论递归函数的定义和实现方法。                               |
|           | 2.11     | 重新探讨的评价 (Evaluation Revisited)                        | 56       | 审视不同求值策略及其对程序执行的影响。                       |
| **第3章** | -        | 构造性数学 (Constructive Mathematics)                        | 59       | 介绍构造性数学理念，强调数学对象的可构造性及其与类型理论的关系。 |
| **第4章** | 4.1      | 命题逻辑：非正式视角 (Propositional Logic: An Informal View) | 69       | 从直观角度理解命题逻辑在类型理论中的角色。                   |
|           | 4.2      | 判断、证明与推导 (Judgements, Proofs and Derivations)        | 71       | 介绍类型理论中的判断、证明和推导基本元素。                   |
|           | 4.3      | 命题演算规则 (The Rules for Propositional Calculus)          | 73       | 详细列举类型理论中的逻辑推理规则。                           |
|           | 4.4      | Curry-Howard同构 (The Curry-Howard Isomorphism)              | 78       | 揭示类型与逻辑命题之间的对应关系，建立逻辑与程序的桥梁。     |
|           | 4.5      | 一些例子 (Some Examples)                                     | 83       | 通过实例加深对类型理论的理解。                               |
|           | 4.6      | 量词 (Quantifiers)                                           | 88       | 讨论类型理论中全称和存在量词的处理方式。                     |
|           | 4.7      | 基本类型 (Base Types)                                        | 96       | 介绍类型理论中的基本数据类型，如自然数和布尔值。             |
|           | 4.8      | 自然数 (The Natural Numbers)                                 | 100      | 深入探讨自然数类型的定义和性质。                             |
|           | 4.9      | 良构类型——树 (Well-Founded Types — Trees)                    | 105      | 研究树等复杂数据结构的类型表示。                             |
|           | 4.10     | 等式 (Equality)                                              | 109      | 讨论类型理论中的等式和等价概念。                             |
|           | 4.11     | 可转换性 (Convertibility)                                    | 117      | 探讨类型理论中项的转换和等价关系。                           |
| **第5章** | 5.1      | 假设 (Assumptions)                                           | 126      | 探讨类型理论中假设的使用和管理，定义上下文。                 |
|           | 5.2      | 命名和缩写 (Naming and Abbreviations)                        | 130      | 介绍为类型和项命名及使用缩写简化复杂表达。                   |
|           | 5.3      | 规则修订 (Revising the Rules)                                | 133      | 讨论如何修改和扩展类型理论的推理规则。                       |
|           | 5.4      | 可导性 (Derivability)                                        | 139      | 探讨哪些类型和命题是可推导的，研究类型理论的表达能力。       |
|           | 5.5      | 计算 (Computation)                                           | 144      | 深入理解类型理论中的计算过程和归约策略。                     |
|           | 5.6      | TT₍c₎⁰：归约和它的推论 (TT₍c₎⁰: Normalisation and Its Corollaries) | 153      | 研究特定类型系统TT₍c₎⁰的归约性质和相关推论。                 |
|           | 5.7      | 平等和等同 (Equalities and Identities)                       | 163      | 区分类型系统中不同层次的平等概念。                           |
|           | 5.8      | 不同的平等 (Different Equalities)                            | 168      | 进一步细化类型系统中不同的等式关系。                         |
|           | 5.9      | 宇宙 (Universes)                                             | 174      | 引入类型的层级结构，讨论类型的类型（宇宙）。                 |
|           | 5.10     | 良构类型 (Well-Founded Types)                                | 179      | 研究构造良构类型的方法，确保类型定义的合理性。               |
|           | 5.11     | 表达能力 (Expressibility)                                    | 189      | 评估类型理论的表达范围和限制。                               |
|           | 5.12     | Curry-Howard同构？ (The Curry-Howard Isomorphism?)           | 191      | 反思Curry-Howard同构的适用性及其在复杂类型系统中的局限性。   |
| **第6章** | 6.1      | 递归 (Recursion)                                             | 196      | 讨论在类型理论中实现递归函数的方法，确保类型安全性和终止性。 |
|           | 6.2      | 案例研究——快速排序 (A Case Study – Quicksort)                | 207      | 通过类型理论描述和验证快速排序算法，展示其应用。             |
|           | 6.3      | 依赖类型和量词 (Dependent Types and Quantifiers)             | 214      | 介绍依赖类型，提升类型系统的表达能力。                       |
|           | 6.4      | 案例研究——向量 (A Case Study – Vectors)                      | 226      | 通过类型理论处理固定长度的数据结构——向量，展示依赖类型的优势。 |
|           | 6.5      | 证明提取；自上而下的证明 (Proof Extraction; Top-Down Proof)  | 230      | 介绍从逻辑证明中提取可执行程序的技术。                       |
|           | 6.6      | 程序开发——波兰国旗问题 (Program Development – Polish National Flag) | 234      | 使用类型理论进行程序设计和验证，展示其应用。                 |
|           | 6.7      | 程序转换 (Program Transformation)                            | 238      | 探讨程序优化和转换的方法，确保转换过程的正确性。             |
|           | 6.8      | 命令式编程 (Imperative Programming)                          | 247      | 在类型理论框架下处理命令式编程范式，管理可变状态和副作用。   |
|           | 6.9      | 文献中的例子 (Examples in the Literature)                    | 249      | 分析已有文献中的实际应用案例，展示类型理论的多领域应用。     |
| **第7章** | 7.1      | 背景 (Background)                                            | 255      | 介绍扩展类型理论的必要性，探讨现有类型系统的局限性。         |
|           | 7.2      | 子集类型 (The Subset Type)                                   | 261      | 引入子集类型，定义满足特定条件的值的类型。                   |
|           | 7.3      | 命题非类型 (Propositions Not Types)                          | 265      | 讨论将命题与类型区分开来的观点，探索不同的类型理论模型。     |
|           | 7.4      | 子集必要吗？ (Are Subsets Necessary?)                        | 268      | 探讨子集类型的实际需求和优势，评估其在类型系统中的重要性。   |
|           | 7.5      | 商类型或同余类型 (Quotient or Congruence Types)              | 273      | 引入商类型，通过等价关系划分类型，处理复杂的类型构造。       |
|           | 7.6      | 案例研究——实数 (Case Study – The Real Numbers)               | 278      | 应用商类型构造实数系统，展示其在表示复杂数学对象中的应用。   |
|           | 7.7      | 加强的规则；多态性 (Strengthened Rules; Polymorphism)        | 281      | 增强类型理论的规则，引入多态类型，提升类型系统的灵活性。     |
|           | 7.8      | 良构递归 (Well-Founded Recursion)                            | 286      | 讨论递归定义的正确性和终止性，介绍良构递归的方法。           |
|           | 7.9      | 类型论中的良构递归 (Well-Founded Recursion in Type Theory)   | 292      | 具体探讨在类型理论中实现良构递归的方法和技术。               |
|           | 7.10     | 归纳类型 (Inductive Types)                                   | 298      | 引入归纳类型，通过归纳定义的数据结构，如列表和树。           |
|           | 7.11     | 共同归纳 (Co-Inductions)                                     | 303      | 讨论共同归纳，用于处理无限数据结构，如流。                   |
|           | 7.12     | 部分对象和类型 (Partial Objects and Types)                   | 309      | 介绍如何在类型系统中处理可能未定义或部分定义的对象。         |
|           | 7.13     | 建模 (Modelling)                                             | 310      | 探讨利用类型理论建模各种系统和概念，展示其应用。             |
| **第8章** | 8.1      | 证明理论 (Proof Theory)                                      | 315      | 研究类型理论的证明性质和逻辑结构，探讨证明在类型系统中的作用。 |
|           | 8.2      | 模型理论 (Model Theory)                                      | 321      | 构建类型理论的语义模型，理解类型系统的语义意义。             |
|           | 8.3      | 一般逻辑框架 (A General Framework for Logics)                | 324      | 讨论统一的逻辑框架，连接不同的逻辑系统，探索类型理论的地位。 |
|           | 8.4      | 反转原则 (The Inversion Principle)                           | 326      | 介绍反转原则，从引入规则推导消除规则，优化推理规则设计。     |
| **第9章** | 9.1      | 相关工作 (Related Work)                                      | 331      | 介绍与类型理论相关的其他系统和研究，回顾类型理论的发展历程。 |
|           | 9.2      | 结论性评论 (Concluding Remarks)                              | 337      | 总结全书内容，回顾类型理论的重要性，展望其未来发展方向。     |
| **附录**  | -        | 规则表 (Rule Tables)                                         | 360      | 汇总类型理论中的各类推理规则和转换规则，作为参考。           |

## 类型理论与函数式编程及PLT编程语言设计中的关系与应用

| **应用领域**             | **描述**                                                     |
| ------------------------ | ------------------------------------------------------------ |
| **类型系统的设计与实现** | 类型理论为函数式编程语言提供强大的类型系统，确保程序的正确性和安全性。通过类型检查，编译器能在编译阶段捕捉类型错误，避免运行时错误，提高程序可靠性。 |
| **Curry-Howard同构**     | 将程序与证明统一起来，使程序的类型视为其满足的逻辑规范。这支持从证明中提取可执行程序，提高程序的正确性和健壮性。 |
| **依赖类型与多态性**     | 依赖类型和多态性等高级类型概念丰富了编程语言的表达能力，支持更精确的类型检查和泛型编程。例如，依赖类型允许类型依赖于值，支持固定长度的数组和向量等数据结构的类型安全表示。 |
| **归纳与共同归纳类型**   | 归纳类型（如列表、树）和共同归纳类型（如无限流）使编程语言能够处理复杂的数据结构，支持递归定义和无限数据结构的操作，提升语言表达能力。 |
| **类型理论的扩展**       | 通过子集类型、商类型、部分对象等类型构造的扩展，类型理论适应更复杂的编程需求，支持等价关系的处理和部分定义的函数，提供更高的灵活性和表达能力。 |
| **程序验证与优化**       | 类型理论在程序验证和优化中发挥重要作用。通过类型系统，程序员可在编写代码时嵌入程序的正确性证明，利用类型系统进行程序转换和优化，确保程序行为的正确性。 |
| **逻辑与编程语言的融合** | 类型理论作为统一的理论框架，将逻辑推理与编程语言设计紧密结合。函数式编程语言基于类型理论，既具有逻辑推理的严谨性，又具备函数式编程的高效性和表达力。 |
| **模型理论与语义**       | 类型理论的模型理论为编程语言提供语义解释，确保语言设计的理论基础和实际实现一致性。通过构建类型理论的语义模型，语言设计者能验证语言特性的正确性和一致性。 |

## 总结

《Type Theory & Functional Programming》系统性地介绍了类型理论与函数式编程之间的紧密关系。通过从逻辑基础到高级类型构造，再到实际应用案例，读者不仅能够掌握类型理论的基本知识，还能将其有效应用于编程语言设计与实现中，提升程序的正确性和表达能力。类型理论在函数式编程和PLT编程语言设计中扮演着核心角色，支撑着现代编程语言的类型系统设计、程序验证和逻辑推理等关键功能。

---

如需进一步详细解读特定章节或小节，或有其他疑问，请随时告知！

[toc]

- 《Type Theory & Functional Programming》

### 目录 (Contents)

**序言** (Preface) iii

**导言** (Introduction) 1

**第1章 逻辑导论** (Chapter 1: Introduction to Logic) 7  
1.1 命题逻辑 (Propositional Logic) 8  
1.2 谓词逻辑 (Predicate Logic) 16  
1.2.1 变量和替换 (Variables and Substitution) 18  
1.2.2 量词规则 (Quantifier Rules) 21  
1.2.3 示例 (Examples) 24

**第2章 函数式编程和λ演算** (Chapter 2: Functional Programming and λ-Calculi) 29  
2.1 函数式编程 (Functional Programming) 30  
2.2 无类型λ演算 (The Untyped λ-Calculus) 32  
2.3 评价 (Evaluation) 36  
2.4 可转换性 (Convertibility) 40  
2.5 表达能力 (Expressiveness) 41  
2.6 类型化λ演算 (Typed λ-Calculus) 42  
2.7 强归约 (Strong Normalisation) 45  
2.8 进一步的类型构造：乘积 (Further Type Constructors: The Product) 50  
2.9 基本类型：自然数 (Base Types: Natural Numbers) 53  
2.10 泛化递归 (General Recursion) 55  
2.11 重新探讨的评价 (Evaluation Revisited) 56

**第3章 构造性数学** (Chapter 3: Constructive Mathematics) 59

**第4章 类型论导论** (Chapter 4: Introduction to Type Theory) 67  
4.1 命题逻辑：非正式视角 (Propositional Logic: An Informal View) 69  
4.2 判断、证明与推导 (Judgements, Proofs and Derivations) 71  
4.3 命题演算规则 (The Rules for Propositional Calculus) 73  
4.4 Curry-Howard同构 (The Curry-Howard Isomorphism) 78  
4.5 一些例子 (Some Examples) 83  
4.6 量词 (Quantifiers) 88  
4.7 基本类型 (Base Types) 96  
4.8 自然数 (The Natural Numbers) 100  
4.9 良构类型——树 (Well-Founded Types — Trees) 105  
4.10 等式 (Equality) 109  
4.11 可转换性 (Convertibility) 117

**第5章 探索类型论** (Chapter 5: Exploring Type Theory) 125  
5.1 假设 (Assumptions) 126  
5.2 命名和缩写 (Naming and Abbreviations) 130  
5.3 规则修订 (Revising the Rules) 133  
5.4 可导性 (Derivability) 139  
5.5 计算 (Computation) 144  
5.6 TT$_{c}^{0}$：归约和它的推论 (TT$_{c}^{0}$: Normalisation and Its Corollaries) 153  
5.7 平等和等同 (Equalities and Identities) 163  
5.8 不同的平等 (Different Equalities) 168  
5.9 宇宙 (Universes) 174  
5.10 良构类型 (Well-Founded Types) 179  
5.11 表达能力 (Expressibility) 189  
5.12 Curry-Howard同构？ (The Curry-Howard Isomorphism?) 191

**第6章 应用类型论** (Chapter 6: Applying Type Theory) 195  
6.1 递归 (Recursion) 196  
6.2 案例研究——快速排序 (A Case Study – Quicksort) 207  
6.3 依赖类型和量词 (Dependent Types and Quantifiers) 214  
6.4 案例研究——向量 (A Case Study – Vectors) 226  
6.5 证明提取；自上而下的证明 (Proof Extraction; Top-Down Proof) 230  
6.6 程序开发——波兰国旗问题 (Program Development – Polish National Flag) 234  
6.7 程序转换 (Program Transformation) 238  
6.8 命令式编程 (Imperative Programming) 247  
6.9 文献中的例子 (Examples in the Literature) 249

**第7章 增强类型论** (Chapter 7: Augmenting Type Theory) 253  
7.1 背景 (Background) 255  
7.2 子集类型 (The Subset Type) 261  
7.3 命题非类型 (Propositions Not Types) 265  
7.4 子集必要吗？ (Are Subsets Necessary?) 268  
7.5 商类型或同余类型 (Quotient or Congruence Types) 273  
7.6 案例研究——实数 (Case Study – The Real Numbers) 278  
7.7 加强的规则；多态性 (Strengthened Rules; Polymorphism) 281  
7.8 良构递归 (Well-Founded Recursion) 286  
7.9 类型论中的良构递归 (Well-Founded Recursion in Type Theory) 292  
7.10 归纳类型 (Inductive Types) 298  
7.11 共同归纳 (Co-Inductions) 303  
7.12 部分对象和类型 (Partial Objects and Types) 309  
7.13 建模 (Modelling) 310

**第8章 基础** (Chapter 8: Foundations) 315  
8.1 证明理论 (Proof Theory) 315  
8.2 模型理论 (Model Theory) 321  
8.3 一般逻辑框架 (A General Framework for Logics) 324  
8.4 反转原则 (The Inversion Principle) 326

**第9章 结论** (Chapter 9: Conclusions) 331  
9.1 相关工作 (Related Work) 331  
9.2 结论性评论 (Concluding Remarks) 337

**规则表** (Rule Tables) 360

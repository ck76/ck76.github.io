
  
 Thought about Calculus of Constructions for a couple of seconds
**概览（这段内容讲了什么）：**这段内容介绍了**Calculus of Constructions (CoC)**，即λC系统，并阐述了从之前讨论的系统（λ2、λω、λP以及最基本的λ→）过渡到λC的过程。在之前的章节中，我们有不同层次的类型与项之间的依赖关系（项依赖项、项依赖类型、类型依赖类型、类型依赖项），但它们是分开讨论的。现在通过放宽一个特定规则（即(form)形成规则）中的限制，将这些各个系统合并为一个更通用的系统：λC。λC中，通过在类型规则中使用两个独立的层级标记(s1、s2)，允许了所有可能的依赖组合，从而在一个统一的框架下同时支持λ→、λ2、λω、λP这四类关系。简言之，这段内容介绍了λC的规则变化，解释了为何只需对(form)-规则进行微小的修改，就能从之前的独立系统合并成λC。最后，它还给出一个直观的表和图示，展示如何通过(s1, s2)的选择来得到四种不同的子系统。

**详细解释与分析（逐段详解）：**

1. **引入λC系统的背景**：在前面的章节（2到5章）中，我们已经看到了几种类型系统：
- λ→：项依赖于项的简单类型系统。
- λ2：项可以依赖于类型（多元类型多态）。
- λω：类型可以依赖于类型（更高级的多态类型层级）。
- λP：类型可以依赖于项（使得类型本身也能根据项而变化，即依赖类型）。在第5.1节开头曾提到有“四种可能的依赖关系”组合：
- terms depending on terms （项依赖项）
- terms depending on types （项依赖类型）
- types depending on terms （类型依赖项）
- types depending on types （类型依赖类型）λC系统就是通过将这些系统整合为一个统一的系统而构建出来的，它也被称为Calculus of Constructions或者λ-Coquand系统（以Th. Coquand命名）。
2. **λC名称的由来**：作者提到‘C’这个字母在λC中有多重含义：
- 来自Coquand的名字
- 来自Calculus of Constructions
- 在后面还会介绍“λ-cube”（λ立方体）这一概念，这里的C也和cube有关。
3. **λP与λC的唯一技术差异**：在技术层面，从λP过渡到λC只需要对(form)规则做出一个改变。回顾λP中的(form)规则：(formλP)
```less
(formλP) Γ ⊢ A : ∗   Γ, x : A ⊢ B : s
-----------------------------------
          Γ ⊢ Πx : A. B : s
```
在这个规则中，很关键的一点是要求A : ∗（A是一个有类型层级∗的对象）。这样确保了在λP中，Πx : A. B这种依赖类型构造出来的对象，要么是基于项的类型，要么是项本身，因为x是“项层级”（level 1）的变量。也就是说，在λP中对A的层级有一个严格限制：A必须是∗，这样B可以是∗或（∗表示类型层级，表示所谓kind层级，通常记为□或类似符号）。通过这种限制，λP能实现类型依赖项（因为x是项），但是无法灵活做到“类型依赖类型”与“项依赖类型”的全面组合。
4. **从λP到λC的关键变化**：如果我们解除上述对A的限制，即不要求A : ∗，而是让A : s，这里s可以是∗或者，那么我们就能够实现更广泛的依赖关系：A可以是类型，甚至可以是kind。这样一来，x : A中的x就不再是严格的“项层级”变量（level 1），x可能是更高层级的对象。但作者指出一个问题：在(formλP)中我们用的是A : ∗和B : s，现在如果我们把A : ∗替换成A : s，那么A与B的s可能会是独立的层级需求。例如，如果B也是类型或kind，那么A的级别(s1)和B的级别(s2)可能不再一致，或者说，我们希望它们是可以独立选择的。
5. **使用两个独立的层级标记s1与s2**：在λC中，为了解决这个问题，我们使用两个独立的标记s1与s2来表示A与B的层级：
```less
(formλC) Γ ⊢ A : s1   Γ, x : A ⊢ B : s2
---------------------------------------
             Γ ⊢ Πx : A. B : s2
```
在这里：
- s1, s2 ∈ {∗, }相当于说，我们在构建Πx : A. B时，A可以是类型(∗)或者kind()，B也可以是类型(∗)或kind()，这使得四种组合都成为可能。值得注意的是，结论的层级是s2，这表示Πx : A. B的“层级”或“类型种类”跟B的层级保持一致。如果B是一种类型，那么Πx : A. B还是一个类型；如果B是一种kind，那么Πx : A. B就是一个kind。
6. **直观解释**：直观上，如果B是一个类型，那么Πx : A. B应该也是一个类型。这和我们对函数类型构造子的理解类似：如果B是类型，那么“从A到B的函数类型”也是一个类型。如果B是kind，那么Πx : A. B就应该是一个kind。这就允许我们构造更高层次的抽象，例如类型家族的家族（即更高级的依赖类型）。作者也提到，在更一般的纯类型系统（Pure Type Systems，PTS）中，情况会更加复杂，可以有(s1, s2, s3)的组合，但这里λC保持了与λP和λω的共同特性，即继承了那种类型不升阶的约定。
7. **四种可能性的实现**：通过(formλC)规则，我们可以生成以下四种组合，对应之前章节介绍的四类系统：设x : A : s1 且 b : B : s2，那么可能性如下：
- s1 = ∗, s2 = ∗：项依赖项，对应λ→（简单类型lambda演算）。
- s1 = , s2 = ∗：项依赖类型，对应λ2（系统F或二阶多态类型）。
- s1 = , s2 = ：类型依赖类型，对应λω（ω阶多态类型）。
- s1 = ∗, s2 = ：类型依赖项，对应λP（依赖类型）。通过这四种组合，我们在同一个框架λC中同时重现了之前的四种系统。简单来说，λC可以通过不同的(s1, s2)选择来模拟λ→、λ2、λω和λP。
8. **在λC中识别子系统**：作者还给出一个直观的图形表示方法：对于λ抽象 λx : A. b，如果你想知道它属于哪个子系统，你可以检查A的类型是∗或 (得到s1)，再检查b的类型的类型是∗或 (得到s2)，由(s1, s2)的组合即可判定。对于Π构造子 Πx : A. B 也是类似的过程，只不过是透过检查A与B的层级，来判断这个构造子所处的依赖组合。
**总结（这段内容总体讲了什么）：**这段内容旨在介绍λC（Calculus of Constructions）的形成规则，并说明它是如何透过仅对(form)规则进行小幅修改，就能综合之前介绍的四种不同类型系统（λ→、λ2、λω、λP）为一个统一的强大系统。在λC中，放宽了A的层级要求，使得A和B能自由地是类型(∗)或kind()，这在(formλC)规则中通过引入s1和s2两个独立标记加以实现。通过这种机制，λC同时支持项对项、项对类型、类型对类型和类型对项的四种依赖组合，也就是把前面几章独立的系统整合进一个统一的框架中。这最终给出了一个通用而灵活的类型理论系统，为之后更通用的纯类型系统（PTS）的理解铺平了道路。
  
 Thought for a couple of seconds
下面的回答会在开头先给出一个全局概览，然后再对你提供的这段内容逐段、细节化地进行解释。在解释过程中，会将公式使用标准的Markdown数学公式格式呈现。最后在回答的末尾会有一个完整而详尽的总结。整个回答中不会省略任何关键内容，并会尽可能深入地说明背景、原因和细节。

**概览（这段内容讲了什么）：**

这段内容来自《Type Theory and Formal Proof An Introduction》一书的第6章第6.1节，主题是引入 **Calculus of Constructions(缩写为CoC或λC)**。本段内容的主要任务是从已经介绍过的几个系统（λ→、λ2、λω、λP）出发，通过微小的规则修改，构建出一个统一而强大的系统 λC。λC 是一种综合性的类型理论系统，它能同时容纳所有四种可能的依赖关系：

1. 项依赖项（来自 λ→）
2. 项依赖类型（来自 λ2）
3. 类型依赖类型（来自 λω）
4. 类型依赖项（来自 λP）
通过对 (form) 形成规则的一点修改——引入两个独立的层级记号 $s_1$ 与 $s_2$ 来取代原先 $s$ 和对 A 类型的限制——λC允许构造任意复杂的依赖类型与项。在 λC 中，一旦释放了对 $A:\ast$ 的限制，使得 $A$ 可以是 $\ast$（类型层级）或 $\Box$（kind层级，本书中用  表示），就可以得到各种依赖组合。作者还提到如果引入更一般的纯类型系统（Pure Type Systems, PTS），可以更进一步推广。而在 λC 的 (form) 规则中，通过两个独立的层级符号 $s_1, s_2 \in {\ast, \Box}$ ，我们就能生成这四种基本系统。最后，这段内容用一个表格和示意图清晰展现了如何通过 $(s_1, s_2)$ 的选择实现从 λ→、λ2、λω、λP 到 λC 的统一。

**逐段、逐点详解：**

1. **关于 λC 的介绍：**该段首先指出，在本章将把前面章节（2-5章）介绍的各种系统合并成一个系统，以实现所有四种类型与项之间的依赖关系。前面章节介绍了四类系统分别允许不同层次的依赖关系：
- **λ→**：只允许项依赖项（即函数从项类型到项类型）。
- **λ2**（有时也称 System F）：允许项依赖类型，即可以有二阶多态。
- **λω**：允许类型依赖类型，即能够对类型进行更高层次的多态抽象。
- **λP**：允许类型依赖项（即依赖类型），类型可以根据项的值而变化。现在，通过组合，可以得到一个统一的系统，称为 λC（Calculus of Constructions），也叫做 λ-Coquand。名称 "C" 有多重含义：来自 Coquand 的名字，来自 Constructions（构造演算），以及在后文提到的 λ-cube（λ立方体）的“c”。
2. **从 λP 到 λC 的技术差异：**作者指出从 λP 到 λC 的唯一技术差别很小，主要是 (form) 规则的改变。在 λP 中的 (form) 规则是：
$$
\text{(form}_{\lambda P}) \quad \frac{\Gamma \vdash A : \ast \quad \Gamma, x : A \vdash B : s}{\Gamma \vdash \Pi x : A. B : s}
$$
这里的关键点是要求 $A : \ast$。这意味着，在 λP 中，当我们构造 $\Pi x : A. B$ 时，$A$ 必须是类型（$\ast$表示类型层级），从而确保 $x$ 是“项层级”的变量（即 x 是项），这让 $B$ 可以是依赖于这个项 x 的类型，也可以是更高层的 kind。但总之，这是 λP 的限制条件。
3. **为什么要放宽限制？**在 λC 中，我们希望构造出所有可能的依赖组合，包括项依赖类型和类型依赖类型等。要做到这一点，需要将 $A : \ast$ 的限制放宽，让 $A$ 也能有其它层级，比如 $\Box$（kind层级）。在本书的记法中，$\ast$ 代表类型（type）层级，$\Box$ 代表 kind（类型的类型的层级）。在其他文献中，$\Box$ 有时写作 \(\square\) 或 \(\mathcal{K}\) ，但这里用  表示。一旦不再要求 $A : \ast$，而是允许 $A : s$ 其中 $s \in {\ast,\Box}$ ，我们就能够让 $A$ 和 $B$ 有更灵活的类型层级组合，从而得到所有可能的依赖形式。
4. **两个 s 的使用：**问题在于，在 λP 的 (form) 规则中，我们只有一个 $s$ ，而如果我们想对 $A$ 和 $B$ 的层级进行独立控制，需要两个独立的层级标记。例如，如果 $A$ 处于某种层级 $s_1$， $B$ 处于另一层级 $s_2$，那么我们就可以独立选择它们，从而生成四种组合。在 λω 中的 (form) 规则是：
$$
\text{(form}_{\lambda \omega}) \quad \frac{\Gamma \vdash A : s \quad \Gamma \vdash B : s}{\Gamma \vdash A \to B : s}
$$
这里只有一个 $s$，因此只能产生“项依赖项”和“类型依赖类型”这两类，而没有允许跨层依赖（例如项对类型或类型对项的跨层组合）。为了实现所有四种组合，作者提出使用两个独立的层级标记 $s_1$ 和 $s_2$。这样，新的 (form) 规则为：
$$
\text{(form}_{\lambda C}) \quad \frac{\Gamma \vdash A : s_1 \quad \Gamma, x : A \vdash B : s_2}{\Gamma \vdash \Pi x : A. B : s_2}
$$
在这里，$s_1, s_2 \in {\ast, \Box}$。这意味着：
- 第一前提中 $A$ 的类型是 $s_1$，可以是 $\ast$ 或 $\Box$。
- 第二前提中 $B$ 的类型是 $s_2$，同样可以是 $\ast$ 或 $\Box$。
- 在结论中，$\Pi x : A. B$ 的类型层级与 $B$ 相同为 $s_2$。如此一来，$A$ 和 $B$ 的层级可以独立选择，形成 4 种组合。
5. **直观解释与接受性**：直观上，如果 $B$ 是类型（$B : \ast$），那么 $\Pi x : A. B$ 理解为“从 A 的元素中抽象出来的一个类型族”本身也是一个类型（$\ast$）。如果 $B$ 是一个 kind（$B : \Box$），意味着 $B$ 本身是类型的类型，那么 $\Pi x : A. B$ 也会是一个 kind（$\Box$），相当于是更高层级的构造子。虽然作者指出这可能不是最一般的形式，因为在纯类型系统（PTS）中，可以有第三个 s ($s_3$)，从而允许更多组合，但 λC 保持与 λP、λω 的共同特性，使 $\Pi x : A. B$ 的层级与 $B$ 相同。
6. **四种可能性对应的系统表格**：作者列出了在 λC 中用 (form) 规则可以产生的四种情况。当你有一个函数抽象 $\lambda x : A. b$ 且该函数的类型是 $\Pi x : A. B$ 时，根据 (abst) 规则（与 λP 中的相同，需要 $b : B$），我们知道 $A : s_1$ 且 $B : s_2$。依照 (form) 规则，这给出四种组合：(s1, s2):
$$
这里 \$A \\) 是类型 (\$A:\ast \\))，\$B \\) 是类型 (\$B:\ast \\))，所以构造出的是普通函数类型与普通函数项。

$$

$$
在这种情况下，A 是 kind (\$A : \Box \\))，而 B 是类型 (\$B : \ast \\))。这意味着我们有项从一种更高层次对象（类型参数）中抽取出来，这就是二阶多态类型（类型多态函数），即 λ2 系统。

$$

$$
在这个组合中，无论是 A 还是 B 都是 kind。这样构造出来的函数类型不仅能对类型进行抽象，还能对类型的类型进行抽象，即更高阶的多态函数和类型族，这是 λω 的特征。

$$

$$
在这种情况下，A 是类型（\$\ast \\)），B 是 kind（\$\Box \\)）。这表示类型可以依赖于一个项 x，而形成更高阶的结构。也就是 λP 所讨论的依赖类型（dependent types）。
$$
通过这种 (s1, s2) 的排列组合，λC 将之前分散在 λ→、λ2、λω、λP 中的特性融为一体。在同一个系统中，我们可以表示所有这些依赖关系。
7. **简单记忆方法与示意图**：作者给出两个示意图，用来帮助记忆与直观理解。对于 $\lambda x : A. b$ 的情况：
```
λx : A. b
.. ..
s1  B
.  .
s2
```
表示当我们抽象一个函数时，A 的类型为 $s_1$，b 的类型 $B$ 的层级为 $s_2$。通过 (s1, s2) 就可以快速判断它所属的子系统。对于 $\Pi x : A. B$ 的情况也类似：
```
Πx : A. B
.. ..
s1 s2
```
计算 A 和 B 的类型层级即可知该构造所代表的依赖模式属于 λC 中的哪个子结构。
**总结（这段内容总体讲解了什么）：**

本段内容从引入 λC（Calculus of Constructions）出发，详细解释了如何通过修改 (form) 规则，将前面章节中独立出现的四种 λ 系统（λ→、λ2、λω、λP）统一起来。原先在 λP 中，构造 $\Pi x : A. B$ 时有严格要求 $A : \ast$，现在在 λC 中用两个层级标记 $s_1, s_2 \in {\ast,\Box}$ 来代替，将这个要求放宽，让 A 可以是类型或 kind，从而 B 也可以在 $\ast$ 或 $\Box$ 中独立选择。

通过这种 (form) 规则的修改，λC 同时容纳了：

- 项对项的依赖（对应 λ→）
- 项对类型的依赖（对应 λ2）
- 类型对类型的依赖（对应 λω）
- 类型对项的依赖（对应 λP）
从而构成一个包罗万象的系统。λC 就是将这四种可能全都囊括的类型系统，允许在同一框架下表达各种复杂的依赖类型与构造。这为深入理解更一般的纯类型系统（PTS）奠定了基础，在那里可将 (form) 规则进一步泛化为 (s1, s2, s3) 的组合，构成更加通用而灵活的类型系统。但在 λC 中，通过 (s1, s2) 就已经能成功地将之前的四种系统组合在一起。
  
 Thought for a few seconds
下面的回答会首先给出一个对这段内容的整体概览，然后对每一部分内容进行逐段、细致且全面的解释，并在需要时提供数学公式使用标准的Markdown数学格式（即使用`$...$`或`$$...$$`包围的LaTeX语法）。在整段内容详解后，会在结尾给出一个全面而详尽的总结。整个回答将不会省略重要信息，并尽可能详细地从零基础角度进行说明。

**概览（这段内容讲了什么）**：

这段内容来自《Type Theory and Formal Proof An Introduction》一书中第6.2节，讨论的是著名的“λ-cube”（lambda立方体）这一概念。首先，它回顾了在前面章节和上一节（6.1节）中介绍的若干类型理论系统（λ→、λ2、λω、λP，以及它们的组合），并指出这几个系统之间的关系可以想象为在三条独立轴线上扩展最基本系统 λ→ 的三种方向。通过将对项与类型依赖关系分别引入，我们可以从λ→出发朝三个不同方向扩展，得到 λ2、λω、λP，以及它们的组合，比如 λP2、λPω，最终把这八个系统整体安置在一个三维的立方体结构中，这个三维坐标体系就是所谓的“λ-cube（Barendregt cube）”。λC（Calculus of Constructions）是这个立方体中包含所有三种扩展的最顶端系统。

这段文字还介绍了由 Barendregt 提出的统一框架，指出八个系统都能用一套统一的推导规则来描述，只是 (form)-规则中允许的 $(s_1,s_2)$ 组合不同。此外，还提到 Automath 系统及其位置，说明 Automath 系统是比 λP 更丰富的系统，也涉及 λ2、λω 等特性，并且强调了定义（definitions）在这些系统中的重要性。最后，它将本书前面介绍的系统（λ→、λ2、λω、λP）与 λ-cube 的统一规则进行对比，展示如何通过限制 $(s_1,s_2)$ 的组合得到先前的系统。

**逐段详解：**

**1. “We have encountered three extensions of the simplest system, λ→:”**此处作者回顾了之前介绍的最基本系统 λ→（简单类型λ演算）和它的三个独立扩展方向：

- λ→ 是最简单的系统，这里只有项依赖项（简单类型）。
- 可以沿着“项依赖类型”方向扩展，得到 λ2。
- 可以沿着“类型依赖类型”方向扩展，得到 λω。
- 可以沿着“类型依赖项”方向扩展，得到 λP。
换句话说，这三种扩展是独立正交的，它们各自为 λ→ 增添了一种依赖维度。总结这点：

- λ→：基础系统，仅支持项对项的映射。
- λ2（System F）：支持项对类型的依赖（高阶多态）。
- λω：支持类型对类型的依赖（无限高阶多态体系）。
- λP：支持类型对项的依赖（依赖类型的出现）。
**2. “These three possibilities are mutually independent.”**这句话强调这三种扩展方向彼此独立，也就是在引入第二阶（项依赖类型）特性的同时，不一定要引入类型依赖项或类型依赖类型的特性。每种特性可以单独加上，也可以合并加上。

**3. “They may be visualised as three perpendicular directions ... Figure 6.1.”**作者用一个三维坐标的隐喻来描述这三种扩展方向。想象 λ→ 作为坐标原点，然后朝三个互相垂直的方向延伸，就得到 λP、λ2、λω 对应的三个轴。当你在这三个方向的轴上同时迈出一步，就能得到更多组合系统，比如同时扩展项依赖类型和类型依赖类型就得到 λω，以及再加上类型依赖项就能到达最通用的 λC。

图 6.1 中，有三条箭头，分别代表从 λ→ 向 λP、向 λ2、向 λω 的扩展方向。

**4. “All three extensions together give λC ... previous section.”**如果同时引入所有三个扩展方向（项依赖类型、类型依赖类型、类型依赖项），就可以得到上个小节讲到的 λC 系统（Calculus of Constructions）。换言之，λC 就是把三种独立扩展都叠加到 λ→ 上去。

**5. “There are, of course, other possibilities of extension ... λω, λP2 and λPω.”**除了最简单的四个系统（λ→、λ2、λω、λP）和最复杂的 λC，还有其它混合类型的系统。如果只在两个方向上扩展 λ→ 而非三个方向，则可得到其他中间系统：

- 从 λ→ 出发，如果扩展项依赖类型 (λ2) 和类型依赖类型 (λω) ，就能产生 λω（注意此处描述中两个方向：其实 λω 本身就可视为 λ→ 扩展到类型依赖类型的系统，但这里是将之前的表格概念化，现在把 λω 系统当成有(∗, ∗)和(, )两种组合——稍后详细表中会解释）。
- 若扩展 λ→ 使其既有项依赖类型(如 λ2)又有类型依赖项(如 λP)，就得到 λP2 系统。
- 若扩展 λ→ 同时有类型依赖类型(如 λω)和类型依赖项(如 λP)，则得到 λPω 系统。
这些名称 λP2、λPω 就是对扩展方向的组合命名。

**6. “The decisive choice is what combinations of s1 and s2 are allowed in the (form)-rule.”**决定这些系统差异的核心在于 (form) 规则中允许的 $(s_1,s_2)$ 组合。回顾上一节（6.1 节），(form) 规则是：

$$
\frac{\Gamma \vdash A : s_1 \quad \Gamma, x : A \vdash B : s_2}{\Gamma \vdash \Pi x : A. B : s_2}
$$

这里的 $s_1$ 和 $s_2$ 可以是 $\ast$ （类型层级）或 $$ （kind层级）。不同的系统通过允许不同的 $(s_1, s_2)$ 对来限制 (form)-rule 的适用性。

**7. “These combinations are listed in Figure 6.2.”**接下来，图 6.2 给出一个表，列出 λ-cube 中的8个系统，以及每个系统中允许的 $(s_1, s_2)$ 组合。表格如下（在原文中有给出，这里详细解释）：

表中有8个系统，每个系统列出了 (s1, s2) 的组合：

- λ→：只允许 $(∗, ∗)$
- λ2：允许 $(∗, ∗)$ 和 $(, ∗)$
- λω：允许 $(∗, ∗)$ 和 $(, )$
- λP：允许 $(∗, ∗)$ 和 $(∗, )$
- λω (请注意这里作者再一次提及 λω，实际是指和 λP、λ2等组合后的集合，这里是书中出现的小小重复之处，可以理解为 λω 是指允许 $(∗, ∗),(, ∗),(, )$ 的系统，但注意不要与上面单独的 λω 混淆，实际上这应是 λC 的子集的某种描述，后面的内容会澄清)
- λP2：允许 $(∗, ∗),(, ∗),(∗, )$
- λPω：允许 $(∗, ∗),(, ),(∗, )$
- λPω = λC：允许 $(∗, ∗),(, ∗),(, ),(∗, )$ （也就是四种全部允许）
这里需要留意一点：表中列出的这8个系统是 λ-cube 的所有角上的节点和其中的面上的系统。

- 基本点 λ→ 只有一组最基础的组合。
- 沿三个方向逐个加特性，就能得到 λ2、λω、λP。
- 沿两个方向加特性，就能得出中间系统（λP2、λPω 以及另一个标为 λω 的扩展的系统）。
- 同时沿三个方向加特性就到达 λC（即 λPω）。
请注意，表格中出现两次 “λω” 的原因是书中先列出简单系统，再列出当允许多个组合后形成的系统名称。严格来说，λC = λPω，是允许所有四种 (s1, s2) 组合的系统。其他如 λω、λP2、λPω 是中间的混合系统。

**8. “All eight systems can be positioned in a cube ... Figure 6.3.”**这八个系统可以放置在一个立方体的八个顶点以及中间位置上，形成 λ-cube。图 6.3（即 Barendregt cube）中每个顶点代表一个系统。通过从 λ→ 出发（立方体的一个角落）沿三个独立方向（坐标轴）前进，一步步添加依赖类型的特性，到达包含更多特性的系统。

- 一个维度代表从项对项提升到项对类型（加入 λ2 的特性）
- 另一个维度代表从项对项提升到类型对类型（加入 λω 的特性）
- 第三个维度代表从项对项提升到类型对项（加入 λP 的特性）
通过这三个维度的二进制组合，就有 $2^3=8$ 个系统的顶点，对应这八种组合系统。

**9. “Remark 6.2.1 The unifying framework for the eight systems ...”**这一注释（Remark 6.2.1）指出，这套将八个系统纳入统一框架的想法是由 H.P. Barendregt 提出和研究的（Barendregt 是 λ演算和类型理论领域的权威学者）。他分析了这些类型理论系统的共同点和差异，并将它们统一描述在 λ-cube 中。

Barendregt 的贡献在于发现所有这八个系统的核心推导规则可以相同，只需改变允许的 $(s_1,s_2)$ 组合即可获得不同的子系统。

**10. “The most striking result ... only one set of derivation rules ... Figure 6.4.”**Barendregt 的最突出成果是，这八个系统实际上可以通过一组统一的推导规则来描述。这组规则很简单，包括：(sort)、(var)、(weak)、(form)、(appl)、(abst)、(conv)。决定你所在系统的因素只是：在 (form)-rule 中允许哪几种 $(s_1,s_2)$ 的组合。这与上一节描述 λC 时的思想一致。

**11. 对八个系统统一规则的列出（Figure 6.4）**：图 6.4 给出了 λ-cube 中所有系统的完整规则列表。在这些规则中：

- **(sort) 规则**：\emptyset \vdash \ast : 这意味着在无假设的上下文中，$\ast$ 是一个类型层级的对象，而 $$ （kind层级）是更高的层级。这个规则用于初始化最高层的层级关系。
- **(var) 规则**：$\Gamma \vdash A : s \quad \Gamma, x:A \vdash x : A \quad \text{if } x \notin \Gamma$表示在上下文 $\Gamma$ 已知 $A$ 的类型为 $s$，将 $x:A$ 加入上下文后，$x$ 本身类型是 $A$。这为变量引入奠定基础。
- **(weak) 规则（weakening）**：$\Gamma \vdash A:B \quad \Gamma \vdash C:s \quad \Gamma, x:C \vdash A:B \quad \text{if } x \notin \Gamma$这表示我们可以在上下文中加入一个无关的声明 $(x:C)$，不会影响之前已推导出的类型判断。这允许在上下文中增加无关变量。
- **(form) 规则**：$\frac{\Gamma \vdash A : s_1 \quad \Gamma, x:A \vdash B : s_2}{\Gamma \vdash \Pi x:A.B : s_2}$这个是关键的形成规则，用来构造依赖类型 $\Pi x:A.B$。$s_1, s_2 \in {\ast, }$，不同系统对 $(s_1,s_2)$ 的组合有不同限制。
- **(appl) 规则（application）**：$\frac{\Gamma \vdash M : \Pi x:A.B \quad \Gamma \vdash N:A}{\Gamma \vdash MN : B[x:=N]}$表示对类型为 $\Pi x:A.B$ 的项 $M$ 应用实参 $N$ 后，结果类型为 $B$ 中用 $N$ 替代 $x$ 的实例。
- **(abst) 规则（abstraction）**：$\frac{\Gamma, x:A \vdash M:B \quad \Gamma \vdash \Pi x:A.B : s}{\Gamma \vdash \lambda x:A.M : \Pi x:A.B}$说明如果在上下文 $\Gamma$ 下，对 $x:A$ 扩充后能推导出 $M:B$，并且能推导出 $\Pi x:A.B:s$，那么就能构造一个 λ抽象 $\lambda x:A.M$ 且类型为 $\Pi x:A.B$。
- **(conv) 规则（conversion）**：$\frac{\Gamma \vdash A:B \quad \Gamma \vdash B:s}{\Gamma \vdash A:B \text{ if } B =_\beta B'}$(conv) 规则用于类型转换，如果 $B$ 和 $B'$ 是 β-同构（即通过 β-简化互相可转换），那么 $A:B$ 的判断在等价类型 $B'$ 下也成立。这在更高层类型系统中是必要的，因为类型等价不是严格的同一性，需要允许通过 β-化简重写类型表达式。
**12. “Remark 6.2.2 ... Automath”**：这条注释介绍了 Automath 系统（由 N.G. de Bruijn 开创），这是最早的用于形式化和检查数学的操作性形式系统之一。Automath 包含了 λP 的所有相关特性，而且还更丰富，包括了一些 λ2、λω 的方面，并且在系统中“定义”（definitions）是核心概念。作者指出，如果把 Automath 放入 λ-cube 中，它会位于一个特别的位置（位于立方体的一个侧面中部），因为它并非只是一种纯粹的顶点系统，而是综合了多个方向的一部分特性，加上定义的特性。

总结成公式：$\text{Automath} \sim λP + \tfrac{1}{2}λ2 + \tfrac{1}{2}λω + \text{definitions}.$

这表示 Automath 大致位于 λP 系统的基础上，同时部分吸收了 λ2 与 λω 的特性（但不完全是这两个方向的完整扩展），并额外强调定义性功能。

**13. “In Figure 6.4 we give the complete list of rules ... depends on (s1, s2) ...”**前面已经解释过图6.4的规则了，这些规则是一致的，只是因应不同系统对 (s1, s2) 的组合限制，你就能得到不同的λ-cube体系内的系统。

**14. “Remark 6.2.3 ... how λω and λP fit in”**：这条备注告诉我们如何在这统一框架下重现之前章节中介绍的 λω、λP 系统的规则。

- 对于 λω：在第4章中使用的 $A → B$ 可视为 $\Pi x:A.B$ 的简写（当 $x$ 不在 $B$ 中出现自由变量时）。在 λω 中，允许 $(s_1,s_2) \in {(\ast,\ast), (, )}$，也就是说，只允许相同层级的映射（项对项、类型对类型），因此只用一个 $s$ 就够了。所以 λω 的规则就是前面给定规则的子集。
- 对于 λP：如果在 (form)-rule 中强制 $s_1 = \ast$，即第一个参数只能是类型层级，那么就能得到与第5章介绍的 λP 的规则一致的系统。
**15. “For λ→ and λ2 ... original definitions ... (conv)-rule is superfluous ...”**对于 λ→ 和 λ2 来说，在之前章节的定义中类型是固定给定的，而在 λ-cube 的定义中类型是通过 (sort)、(weak) 和 (form) 动态构造的。但是只要适当地约束 (form)-rule 中 $(s_1,s_2)$ 的组合，就能通过 λ-cube 规则系统重建 λ→ 和 λ2 的原本定义。

另外，由于在 λ→ 和 λ2 中类型等价变化不复杂（没有复杂的类型级 β-化简），因此 (conv)-rule 在这两个系统中其实是冗余的。总之，λ→ 和 λ2 也是 λ-cube 框架下的特例，只是只允许最基本的 $(s_1,s_2)$ 组合并不需要对类型进行复杂变换。

**总结（这段内容总体讲解了什么）：**

这段内容介绍了著名的 λ-cube（由 Barendregt 提出），这是一个将多个类型理论系统统一起来的框架。起点是最简单的 λ→ 系统，它只有项对项的类型依赖。通过沿三个正交方向（项依赖类型、类型依赖类型、类型依赖项）扩展 λ→，我们可以得到 λ2、λω、λP 以及它们的多重组合（λP2、λPω、等等），最终当三种扩展全部应用时，就达到了 λC（Calculus of Constructions）。整个 λ-cube 包含 8 个系统，代表从 λ→ 出发在这三个独立方向上的所有二进制组合。通过一个简单的（form）规则中 $(s_1,s_2)$ 对的允许集合，就能定义出这 8 个系统。 Barendregt 的贡献在于指出这 8 个系统可以用同一组推导规则来描述，只是改变允许的 $(s_1,s_2)$ 组合就能得到不同的系统。此外，作者还提到了 Automath 系统作为一个更复杂的历史先例，它具备 λP 的所有特性，并部分吸收了 λ2 和 λω 的特性，并且强调定义在系统中的重要性。最后，本段还说明了如何将之前章节介绍的 λ→、λ2、λω、λP 等系统嵌入到这个统一的 λ-cube 框架下，从而表明 λ-cube 是一个强大的统一视角，帮助我们理解各种类型系统之间的关系、相似点与差异点。
  
 Thought for a second
下面的回答会在开头先提供对这段内容的整体概览，然后对所提供的段落进行逐段、详细、清晰的解释，并力求深入浅出地帮助你理解这些概念和结果，即使你没有相关背景知识。我会明确分章节解释，并在最后对这段内容进行一个非常全面和详尽的总结。整个回答不会省略重要信息，也不会偷懒，将尽可能完整深入。

**概览（这段内容讲了什么）**：

你提供的内容是《Type Theory and Formal Proof An Introduction》一书中第6.3至6.5节的内容。这些章节在第6章已经引入了 λC (Calculus of Constructions) 这一综合系统基础上，对以下几点进行了讨论和拓展：

1. **6.3 Properties of λC**：这部分首先说明了λC作为综合系统，继承并拓展了之前各系统（例如 λ→、λ2、λω、λP）的许多良好性质。随后给出了若干在λC中成立的重要引理（Lemmas）和定理（Theorems），包含了与前面章节相似的性质（如自由变量引理、上下文操作引理、生成引理、类型唯一性、替换引理、Church-Rosser定理、Subject Reduction、强规范化定理以及判定性问题的可判定性）。同时指出了一些证明的复杂性，以及在文献中这些证明有多长，也点出了一些参考文献和结果的难度。
2. **6.4 Conclusions**：这一节对本章（以及之前章节）的工作进行了总结：通过在 λ→ 基础上添加不同类型的依赖（项依赖类型、类型依赖类型、类型依赖项）可以构造出 λ-cube 中的多个系统。这些系统可以用一套统一的推导规则来描述。λC 是最强大的系统，允许所有组合，并且拥有一系列良好性质，使其成为构建证明助理的坚实基础。
3. **6.5 Further reading**：这一节给出了一些扩展阅读的建议和拓展方向。比如 Coquand 和 Huet 对 λC（也称为 CC）系统的研究，以及它与 λP、λω 的关系；还提到扩充的归纳类型和层叠的“超kind”结构（universes）形成 ECC (Extended Calculus of Constructions) 等概念，并指出这些扩展在构建更强大的证明助手和形式化工具（如 Coq）中起到关键作用。
简而言之，这段内容主要介绍了 λC 的关键性质、证明难度、在 λ-cube 中的位置、与之前系统的关系、以及与研究和实践相关的更多方向。

**详细逐段解释**：

下面我将按照原文顺序，对文本进行细致分析。

### 第6.3节：Properties of λC

**“Most of the properties of the previously described systems also hold for the ‘combined’ system λC.”**作者在这里指出，之前在 λ→、λ2、λω、λP 中证明和讨论过的许多良好性质（如一致性、Church–Rosser 定理、强规范化、类型唯一性等）在 λC 中依然成立。虽然有时需要更一般的陈述，因为 λC 的层级与结构更复杂（包含更多种类的依赖关系和层级）。

**“Below we give the lemmas for λC in their general shape...”**作者将列出几个重要的引理和定理，这些在前面章节中对应的特性已经讨论过，在这里会以更通用、更广泛的形式出现。读者若需要更直观的理解，可参考之前章节的证明思路和直觉解释。作者提到要参考第2.10、2.11节的直观背景，以及4.8节中的类型唯一性引理的推广。

**“Some notions have to be redefined ... adapt the notion of a λC-context.”**在更一般的λC环境中，我们要稍微修改之前系统中使用的定义概念。例如对上下文(dom)的定义，在 λ→ 时是一种较简单的定义，现在需要适应 λC 的上下文。

**“We do not give proofs of the lemmas below ... very complicated.”**作者说明不会在这里提供这些引理和定理的完整证明，因为对 λC 来说证明相当冗长。例如强规范化定理的证明非常复杂，在参考文献中需要多页篇幅。

接下来作者给出了 λC 中表达式(Expressions)的定义：

**Definition 6.3.1 (Expressions of λC, E)**
E = V \mid  \mid ∗ \mid (EE) \mid (λV : E . E) \mid (ΠV : E . E)
这里 E 表示 λC 中的表达式集合，包含：

- 变量 $V$
- 两种特殊的层级记号：$∗$ 表示类型层级，$$ 表示kind层级
- 应用 $(EE)$，即一个表达式应用到另一个表达式
- λ抽象 $(λV : E . E)$
- Π抽象 $(ΠV : E . E)$
这与之前系统类似，但更丰富。

**Notation 6.3.2**作者说明在 λC 中继续遵守之前的记号约定，比如变量命名、括号的使用、省略记号以及 $A → B$ 是 $(Πx:A.B)$ 的简写（当 $x$ 不出现在 $B$ 的自由变量中时）。这些约定在前面章节已建立。

接下来的引理和定理都是 λC 的性质：

**Lemma 6.3.3 (Free Variables Lemma)**若 $\Gamma \vdash A:B$，则 $FV(A), FV(B) \subseteq dom(\Gamma)$。这意味着类型推导中出现的自由变量都出现在上下文中。这是与之前系统类似的结论，确保上下文完备性。

**Definition 6.3.4 (Well-formed context)**上下文Γ是良构的(well-formed)如果存在 $A$ 和 $B$ 使得 $\Gamma \vdash A:B$。这定义了一个上下文何时被称为良构。

**Lemma 6.3.5 (Thinning, Permutation, Condensing)**这三个引理与上下文操作有关：

1. (Thinning) 如果 $\Gamma \subseteq \Gamma'$ 且 $\Gamma' \vdash A:B$ 且 $\Gamma$ 良构，那么在较小的上下文 $\Gamma$ 中也可以推出 $\Gamma \vdash A:B$。这与之前 λ→ 系统中的增减无关声明相似，只是现在在 λC 中也成立。
2. (Permutation) 如果 $\Gamma'$ 是 $\Gamma$ 的一个排列（上下文中声明的顺序调整），并且 $\Gamma' \vdash A:B$ 且 $\Gamma$ 良构，那么 $\Gamma \vdash A:B$。就是说上下文中声明的顺序不影响可判定性。
3. (Condensing) 如果在上下文 $\Gamma', x:A, \Gamma'' \vdash B:C$ 且 x不出现在 $\Gamma''$, $B$, $C$ 中，则我们可以缩短上下文去掉 $x:A$，即 $\Gamma',\Gamma'' \vdash B:C$。这对应对上下文中多余声明的“压缩”。
这些引理的证明很繁琐，书中引导去参考 Barendregt 1992年的文献。

**Lemma 6.3.6 (Generation Lemma)**生成引理细分成四种情形，对 λC 中四种基本构造（变量、应用、λ抽象、Π抽象）的类型推导有具体结论：

1. 若 $\Gamma \vdash x:C$，则存在 sort $s$ 和表达式 $B$ 使得 $B =_β C$, $\Gamma \vdash B : s$, 且 $x:B \in \Gamma$。
- 意思是变量的类型来自上下文中的某个声明，并且该类型是某个 sort 所类型的。
2. 若 $\Gamma \vdash MN:C$，则 $M$ 是Π类型，即存在 $A,B$ 使得 $\Gamma \vdash M: Πx:A.B$，并且 $\Gamma \vdash N:A$。最后 $C =_β B[x:=N]$。
- 这对应应用规则：函数部分有Π类型，输入参数匹配其域类型，结果类型是相应代换后的 $B$。
3. 若 $\Gamma \vdash λx:A.b : C$，则存在 $s$ 和 $B$ 使得 $C =_β Πx:A.B$，并且 $\Gamma \vdash Πx:A.B : s$，还要有 $\Gamma, x:A \vdash b:B$。
- 这对应 λ抽象的构造规则。
4. 若 $\Gamma \vdash Πx:A.B : C$，则存在 $s_1,s_2$ 使得 $C \equiv s_2$，并且 $\Gamma \vdash A:s_1$ 和 $\Gamma,x:A \vdash B:s_2$。
- 对 Π抽象的类型判断：Π类型的类型本身是一个 sort。
这个引理本质上与之前系统的生成引理类似，只是增加了(conv)转换规则对 β-可转换类型的考虑，使得判断要考虑类型等价而非严格相等。

**Definition 6.3.7 (legal expressions)**在 λC 中，一个表达式 $M$ 称为“合法的”(legal)如果存在 $\Gamma$ 和 $N$ 满足 $\Gamma \vdash M:N$ 或者 $\Gamma \vdash N:M$。也就是说，$M$ 是可类型化的（有类型）或是被另一表达式所类型的（即它本身是一个类型，被另一表达式所居住）。

**Lemma 6.3.8 (Subexpression Lemma)**如果 $M$ 是合法的，那么 $M$ 的任意子表达式也是合法的。这与之前系统类似，在合法的推导结构中，子组件必定也有良好类型特征。

**Lemma 6.3.9 (Uniqueness of Types up to Conversion)**如果 $\Gamma \vdash A:B_1$ 且 $\Gamma \vdash A:B_2$，则 $B_1 =_β B_2$。这拓展了类型唯一性定理：在 λC 中，类型在 β-同构意义下是唯一的。

**Lemma 6.3.10 (Substitution Lemma)**替换引理：如果 $\Gamma', x:A, \Gamma'' \vdash B:C$ 且 $\Gamma \vdash D:A$，那么我们可以用 $D$ 替换 $x$：

$$
\Gamma', \Gamma''[x:=D] \vdash B[x:=D] : C[x:=D].
$$

换言之，类型推导在替换操作下闭合。这是类型理论中非常重要的性质。

**Theorem 6.3.11 (Church–Rosser Theorem; CR; Confluence)**λC 也满足 Church–Rosser 定理（即合流性）：如果 $M$ 可以 β-简化到 $N_1$ 和 $N_2$，则存在 $N_3$ 使得 $N_1$ 和 $N_2$ 都可 β-简化到 $N_3$。这表明 λC 的计算是合流的，无论计算路径如何分叉，最终都能合并到同一规范形（若存在）。

**Corollary 6.3.12**如果 $M =_β N$，则存在 $L$ 使得 $M$ 和 $N$ 都能 β-简化到 $L$。这与合流性直接相关，是合流性的推论。

**Lemma 6.3.13 (Subject Reduction)**如果 $\Gamma \vdash A:B$ 且 $A β A'$，则 $\Gamma \vdash A':B$。这意味着在 β-化简过程中不会破坏类型正确性。类型在简化过程中是保持的，确保系统的稳健性。

**Theorem 6.3.14 (Strong Normalisation or Termination)**在 λC 中，每个合法表达式都是强规范化的，即任何合法的 $M$ 都有一个最终的规范形。这意味着在 λC 中不存在无限 β-归约序列，对应良好的终止性特征。

**Theorem 6.3.15 (Decidability of Well-typedness and Type Checking)**在 λC 及其子系统中，“良类型性(Well-typedness)”和“类型检查(Type Checking)”这两个判定问题是可判定的。这对于构建自动类型检查器非常重要，它告诉我们可以编写程序来决定一个给定的项在给定上下文和类型中是否可推导。

然而：

**Term Finding 问题**——给定一个类型，判断是否存在一个项归属于此类型——在 λ→ 和 λω 中可判定，但在包含 λ2 或 λP 成分的系统中是不可判定的。这与数学定理可判定性的问题有关，即不存在能判定任意数学定理真假的算法（Church–Turing 不可判定性结果）。因此在λC中，由于它包含 λP 等成分，Term Finding 是不可判定的。

作者指出，人类仍然需要亲自参与寻找证明项的过程，而计算机（证明助理）可以作为辅助工具。例如 Coq 等证明助理可以帮助管理上下文、列出剩余的子目标、检查规则应用正确性等。

### 第6.4节：Conclusions

**此节总结整个章节的内容：**

- 本章讨论了将前面章节的各系统（λ→、λ2、λω、λP）进行多种组合，形成 λ-cube 中的8个系统，包括最强大的 λC。
- λ→是基础系统，其它系统都是在此基础上向三个独立的方向延伸（项依赖类型、类型依赖类型、类型依赖项）。
- λC 是所有扩展的综合系统。
- 所有这8个系统都可用同一套推导规则描述，只是对(form)-rule中 $(s_1,s_2)$ 的选择不同。
- 这些系统保持许多良好性质，如唯一性、合流性、强规范化以及类型检查的可判定性等，这令它们成为构建严格可靠的证明助理的良好基础。
### 第6.5节：Further reading

**这一节提供延伸阅读和背景：**

- λC（Calculus of Constructions）由 Coquand 和 Huet 在1980年代提出，也称为 CC。该系统实现了 λP 和 λω 的特性，将高阶谓词逻辑和多态数据类型引入同一框架。
- λ-cube 的构造正是为了显示 λC 是 λP 和 λω 的结合，并让人清楚看到类型规则与项/类型依赖关系的对应。
- 早期的 CC 系统缺乏原始归纳类型，只能使用可定义的多态数据类型，不如后来引入归纳类型的 CIC（Calculus of Inductive Constructions）那样强大。
- 此外，还有扩展版本 ECC（Extended Calculus of Constructions）引入了层叠的 universe 层级（$_i$ 系列）和累积性（cumulativity），以避免不一致性并允许更丰富的类型层次。
- Coq 等现代证明助理大多是以这些扩展的类型理论为基础来实现的。
**总结（这段内容总体讲了什么）**：

总的来说，这段内容介绍了 λC (Calculus of Constructions) 这个类型理论系统的多种性质和特征，并从 λ-cube 的统一视角总结了之前出现过的所有子系统。通过组合 λ→、λ2、λω、λP，我们得到 λ-cube 中的 8 个系统，而 λC 是其中最完善的系统之一。

在第6.3节中，作者详细列举了在 λC 中仍然成立的重要性质和定理：

- 自由变量引理、上下文变换相关引理、生成引理、替换引理等确保了类型系统的结构完备性和健壮性。
- 类型唯一性（在β-同构意义下）、Subject Reduction、Church–Rosser 定理以及强规范化定理，确保了 λC 的一致性、可归约性和终止性等核心性质。
- λC 中的良类型性和类型检查问题是可判定的，但“Term Finding”在大多数丰富系统（包括 λC）中是不可判定的。这与数学定理判定的不可判定性结果相呼应。
在第6.4节，作者总结了整个λ-cube的设计理念和重要性，强调所有这些系统在一个统一框架下都能优雅地描述。λC 作为“type theory 的宝石”，具备所有良好性质。

在第6.5节，作者指出这些理论系统的历史渊源和应用背景，例如 Coquand & Huet 对 λC 的最初研究，ECC（扩展的 λC），以及在构建现代证明助理（如 Coq）过程中这些理论的实际重要性。

通过这些内容的学习，我们看到了类型理论的坚实数学基础和广阔应用场景，理解了 λC 及相关系统在逻辑和计算机科学中构建严谨可靠证明环境的重要意义。
  
 Thought for a second
下面的回答会在一开始对这一段内容进行一个整体概览，然后对用户提供的原文内容逐段、逐句进行非常详细的解释和分析，尽可能以初学者可理解的方式呈现。在解释过程中，我会不断回顾之前章节的相关概念、强调本段讨论的逻辑含义与类型论模型的对应关系。最后，我会在回答末尾对整段内容做一个全面详尽的总结。

**概览（这段内容讲了什么）：**

这段内容选自《Type Theory and Formal Proof An Introduction》第7章第7.1节，介绍如何在 λC（Calculus of Constructions）系统中对逻辑概念进行编码。之前的章节中已经说明了在类型理论中，命题可以被视为类型，命题的证明可以被视为 inhabits 该类型的项（类型的“元素”）。本节重点讨论了两个逻辑概念：

1. **Absurdity（⊥）和Negation（¬）在类型理论中的表示**首先作者回顾了在类型理论（尤其在λP和延伸的λC中）如何将逻辑中的蕴涵（implication）表示为函数类型 (A ⇒ B 对应于 A → B )。在此基础上，要获得更丰富的逻辑（不只 minimal propositional logic），需要引入更多逻辑联结词——在这里开始介绍 negation (¬) 的表示方式。作者从编码“absurdity”(也称为 contradiction，写作 ⊥) 入手，阐述如果一个类型能够根据已经得到的 absurdity 推导出任意命题（ex falso quodlibet 原理：从矛盾出发可以得出任意结论），则该类型可作为逻辑中的“假命题”或“矛盾”的对应。最终作者在类型理论中选择定义：
$$
⊥ := \Pi \alpha : ∗. \alpha
$$
这表示一个类型，若它有inhabitant，就能从中推出所有类型（所有命题）。在这种定义下，通过 (appl)-rule，一个 inhabitant 就能产出任意类型的 inhabitant，从而体现逻辑上的荒谬性。有了⊥，negation（¬A）就可以自然定义为 A → ⊥。逻辑上，¬A 表示“从 A 出发能得出矛盾”。作者说明这种编码使得原本需要独立引入的(⊥-intro)和(¬-intro)等规则都可以由已有的 (⇒-intro)和(⇒-elim)规则替换掉，从而在类型理论中优雅地再现经典逻辑推导规则。
**逐段详解：**

【原文片段的各个部分如下，下面会紧接解释】

**“In Section 5.4, IV, we saw how implication can be coded in type theory...”**在第5.4节中，书中已经提到如何用类型理论中的函数类型来编码逻辑蕴涵：

- 命题 A ⇒ B 在类型理论中表示为类型 A → B （如果有一个从 A 到 B 的函数，那么可以理解为从 A 蕴涵出 B）。
- 在 λP（以及现在更一般的 λC）中，这套编码允许我们在类型理论中获得最小命题逻辑（minimal propositional logic）。这里 minimal 的意思是只用蕴涵这一种逻辑联结词和对证据的构造规则，而没有引入更复杂的连结词，如否定、合取或析取。
**“In order to get more than minimal propositional logic...”**如果我们想要超越最小命题逻辑，必须能表达 negation（¬），conjunction（∧），disjunction（∨）等更多逻辑连结词或符号。

**“This cannot be done in λP, but in λC there exist very elegant ways to code them.”**在λP中，这些扩展不足以优雅地表示 negation、合取、析取等；但在 λC 中，我们可以使用之前得到的更强的系统特性，来优雅地表示这些逻辑概念。本段首先聚焦于 negation。

**“We start with negation.”**从否定开始。首先需要定义 negation 的语义含义。

**“It is natural to consider the negation ¬A as the implication A ⇒ ⊥,...”**直觉是：¬A 可以理解为 “A 蕴涵矛盾(⊥)”。也就是说，如果假设 A 能得出矛盾，那么 A 不可能为真，这正是逻辑中 negation 的意义。

**“...where ⊥ is the ‘absurdity’, also called contradiction.”**这里 ⊥ 表示逻辑中的“矛盾”、“荒谬命题”。在类型理论中，如果一个类型 ⊥ 有 inhabitant，那么从该 inhabitant 出发可以构造任意命题的 inhabitant，这就表示如果矛盾被证实，那么所有命题都为真（逻辑爆炸原则）。

**“So we interpret ¬A as ‘A implies absurdity’.”**精简地说，¬A := A → ⊥。

**“But for this we first need a coding of the absurdity itself.”**要定义 negation，需要先对 ⊥（矛盾）进行恰当的编码。

**“I. Absurdity”**现在作者重点讨论如何在类型理论中表示 ⊥。

**“A characteristic property of the proposition ‘absurdity’, or ⊥, is the following: If ⊥ is true, then every proposition is true.”**从逻辑上讲，矛盾一旦成立，就能推出任何命题成立。这是经典逻辑中的 “Ex falso quodlibet”（从假命题推出任意命题）的原则。

**“In natural deduction this property is known under the name ⊥-elimination...”**在自然演绎法（自然逻辑推导）中，这被称为 ⊥-elimination 规则。它说：从矛盾可以消去，进而得到任意结论。

**“It can also be expressed as follows, in a type-theoretic setting: ‘If ⊥ is inhabited, then all propositions A are inhabited.’”**类型论的解释：如果类型 ⊥ 有一个 inhabitant M，那么对任意类型 A，都存在一个 inhabitant（即对任意 A 都为真）。这也符合类型化逻辑的观点：⊥ 有inhabitant意味着系统已经崩溃，任何命题 A 都可证明。

**“We can make this more constructive, by invoking a function: ... map an arbitrary proposition α to an inhabitant of α.”**在类型论中，将此性质转化为函数的存在：如果有 M : ⊥（M 是⊥的inhabitant），则必须存在一个函数 f，可以接收任意 A : ∗（命题）并返回 A 的 inhabitant。换句话说，这个 f 的类型是：

$$
f : Π\alpha : ∗. \alpha
$$

因为 f 从任意的类型 $\alpha$ 中取值（$\alpha : ∗$）并产出一个 $\alpha$ 的 inhabitant。

**“And indeed, if f has type Πα : ∗ . α, then by the (appl)-rule: fA : A.”**验证这种函数 f 的作用。如果 f: Πα:∗.α，那么给定任意 A:∗，经应用规则 (appl)，fA 的类型为 A，这就意味着 fA 是 A 的 inhabitant。

**“So if f is such a function, then fA inhabits A (or: makes A true).”**此函数 f 可以让任意 A 成为“真命题”（有inhabitant）。这显然意味着如果存在这样的 f，系统就能证明所有命题，从而是一个荒谬的情形。这恰恰对应逻辑中的⊥被证实的情况。

**“This holds for a general proposition A, since also fB inhabits B, etc.”**换个命题 B，也一样成立。fB 使 B 成立。

**“Summarising: ⊥ is inhabited if and only if Πα : ∗ . α is inhabited.”**总结：在类型理论中，如果 ⊥ 有inhabitant ⇔ Πα:∗. α有inhabitant。而 Πα:∗. α 是一个很强的类型，它表明能从无中生有（生成所有类型的inhabitant），这和逻辑上的荒谬完全一致。

**“Our problem was to find a practical coding for ⊥. By the above, the solution is now at hand: define ⊥ as Πα : ∗ . α.”**所以在类型理论中定义：

$$
⊥ := Πα : ∗. \alpha
$$

这样就能获得预期的效果。

**Remark 7.1.1**该备注进一步说明，用这种方式定义⊥，我们得到了 ⊥-elimination 规则在类型论中的对应形式。(⊥-elim) 在逻辑中是：从 ⊥ 推出 A（任意命题 A）。在类型论中，我们有 f : Πα:∗. α，当给定 A:∗，fA : A，于是从⊥的inhabitant可构造出任意命题 A 的inhabitant。

**“To end our discussion of absurdity (⊥), we investigate in which system ⊥ lives.”**现在要看看这样的⊥及其相关规则在λ-cube哪个子系统中可实现。

**“Since ⊥ ≡ Πα : ∗ . α, ... we see that s1 =  and s2 = ∗.”**注意这里用到了之前定义的 (form)-rule 中的 s1, s2 类型层级。在 Πα : ∗ . α 中，A:∗意味着 α 是个类型（level 1对象），从 A:∗ 到 α:∗ 再到 Π构造子最终判断，它对应在 λC 中的 (s1,s2) = (,∗) 的组合。这表示了要定义⊥所需的等级组合。

**“So we are in λ2.”**回顾λ-cube： (s1, s2) = (, ∗) 对应于 λ2 系统的特性（项依赖类型方向）。作者解释，⊥的定义需要我们至少能处理从 kind 到 type 的函数类型构造。因此，它在 λ2（可支持类型多态）就能实现。并可进一步通过 λC 的能力来拓展。

**“Moreover, we can show using the derivation rules of λ2, that ⊥ : ∗.”**利用 λ2 的规则可以证明 ⊥ 本身是一个类型（⊥ : ∗）。这符合我们的直觉：⊥ 是一个类型，对应一个“命题”，它是荒谬命题。

**II. Negation**有了⊥，现在定义否定 ¬A 为 A → ⊥。

$$
¬A := A → ⊥
$$

因为 A:∗ 且 ⊥:∗，A → ⊥ 的类型依然处在 λ2 中允许的范围内。

**“Note that A → ⊥ is an abbreviation for Πx : A . ⊥.”**蕴涵用函数类型表示：A → B 是 Πx:A.B 的简写（当 x 不出现在 B 的自由变量集中时）。因此 ¬A = A → ⊥ = Πx:A.⊥。

**“Since A : ∗ and ⊥ : ∗, ... we have (s1, s2)=(∗, ∗). However, by the involvement of ⊥ we need at least λ2 to code negation.”**A : ∗, ⊥ : ∗，构造 Πx:A.⊥ 时，(s1,s2) = (∗, ∗)表明从类型到类型的依赖像 λ→ 那样简单，但由于⊥本身的定义涉及 (, ∗) 这一更高阶特性，因此整体来看要在 λC 中实现 negation，需要至少 λ2 的能力。

**Remark 7.1.2**备注说明：原本在自然演绎中我们有 (⊥-intro) 和 (¬-intro) 这样的推导规则，但在当前的类型理论表示下，它们可以用已有的 (⇒-intro) 和 (⇒-elim) 来代替。

**“The ⊥-introduction rule employs negation.”**传统上，用 (⊥-intro) 是：如果你能同时证明 A 和 ¬A，就推出 ⊥。在类型理论中：

$$
A \quad ¬A \over \⊥
$$

表示如果一个命题和它的否定都成立，就得到矛盾。

**“However, this rule has become superfluous by the identification of ¬A and A → ⊥.”**现在 ¬A 就是 A → ⊥，(⊥-intro) 的作用可以用 (⇒-elim) 来实现。

**作者通过对比两组规则（左边是旧有的 ¬ 和 ⊥ 规则，右边是泛化的 ⇒ 规则）显示对照关系：**

(⊥-intro) 左边版本是：如果 A 和 ¬A 同时成立，则得 ⊥。

(⇒-intro) & (⇒-elim) 的通用版本是：从 A 和 A ⇒ ⊥ 推出 ⊥，这其实与 (¬-elim) / (⊥-intro) 是同一件事，只是更一般的版本。

**进一步解释**：

- (¬-intro) 是指从 A 推导出 ⊥ 就可得 ¬A（如果假设 A 会导致矛盾，那 A 是不成立的，这相当于构造一个从 A 到 ⊥ 的函数）。但在我们的编码中，¬A 已经就是 A→⊥，所以证明 ¬A 的方式就是构造一个 λ-抽象（⇒-intro）从 A 到 ⊥ 的函数。
- (¬-elim) 是指如果已知 ¬A 且 A，则得到 ⊥。但这和 A ⇒ B + A ⇒ B 的消解规则 (⇒-elim) 一样，只要用 B=⊥ 就可得出 ⊥。
作者将对应关系以表格的方式列出，当记住 ¬A = A ⇒ ⊥ 时，左边的 negation rules 就成了右边 implication rules 的特例。

**“Note: (⊥-intro) and (¬-elim) are identical special cases of the ⇒-elim-rule. ...”**(⊥-intro) 与 (¬-elim) 都只是 ⇒-elim 的特例。当 B=⊥ 时，(⇒-elim) 就变成了 (¬-elim) 或 (⊥-intro)。不过二者在用途上有区别：

1. (⊥-intro) 使用时是为了引出 ⊥：需要找到A 及 ¬A (等价于 A 和 A → ⊥)，从而产生矛盾。这是一个向后推导的引入规则（intro-rule），在寻找证据时你会尝试引入假设并构造矛盾。
2. (¬-elim) 是往前使用的消解规则（elim-rule）：如果你有 ¬A 和 A，就能前进导出 ⊥，等价于说从一个矛盾的存在中继续演绎出问题。这在构造证明时是推前的（forward）步骤。
作者强调尽管它们都是从更一般的 ⇒-规则中得出，但在逻辑直观上仍有各自的解释意义。

**全面详尽的总结（这段内容讲解了什么）：**

在这段内容中，作者将逻辑中的“absurdity”(⊥)和“negation”(¬)用类型理论（尤其是 λC 系统）加以精确编码。

- **首先，作者回顾了最小命题逻辑在类型理论中的实现**：A ⇒ B 用 A → B 来表示。
- **要实现更丰富的逻辑特性**（如否定、合取、析取），仅有 λP 不够；而在 λC 中，我们有足够的灵活性来处理这些更复杂的逻辑连结词。
本节重点讨论 **negation（¬）** 的定义，但这取决于先为 **absurdity（⊥）** 提供一个合适的类型论刻画。

- **对 absurdity(⊥) 的编码**：⊥ 是一个如此荒谬的命题，如果它有inhabitant，那么任意命题 A 都可以被证明为真。在类型理论中，这意味着存在一个函数 $f : Π\alpha:∗.\alpha$，它能给出所有类型的inhabitant，从而从无中生有。这显然是荒谬的，所以我们用：
$$
⊥ := Π\alpha:∗.\alpha
$$
来表示 “矛盾类型”。如果这个类型有inhabitant，那么逻辑系统就崩溃，因为从此可以推出任意命题。这种定义在 λC 中（具体在 λ2的层级允许下）可以实现，而且通过λ2的推导规则可证明 ⊥:∗，即 ⊥本身是一个类型。
- **negation(¬) 的定义**：有了⊥，negation 即定义为从 A 推出 ⊥ 的蕴涵：
$$
¬A := A → ⊥
$$
如此定义使得我们不需要独立的 negation introduction 和 negation elimination 规则：这些逻辑规则变成了 implication introduction（⇒-intro）和 implication elimination（⇒-elim）规则的特殊情况。
借此，我们看到类型理论中，用 A→⊥ 来表达 ¬A，既保持了概念的清晰性，又减少了规则的数量和复杂度（不需要单独的 ¬-intro、¬-elim、⊥-intro）。所有操作都可以还原成对函数类型（⇒）的处理。

综上，作者在这段内容中通过类型论的视角展示了如何优雅地在 λC 中表达逻辑中的矛盾与否定，并进一步说明这种编码如何让逻辑推导规则简化并统一在函数类型的引入和消解规则中。
  
 Thought for a second
下面的回答会在开头对这段内容进行一个全面的概览，然后对所提供的文本段落进行逐段、细致而深入的解释，力图帮助你在没有先验背景知识的情况下理解这些概念。最后，在回答的末尾，会对本段内容做一个完整详尽的总结。整个回答过程中不会省略任何关键要点，也会努力避免偷懒，从而为你提供一个完整、详实的解释。

**概览（这段内容讲了什么）：**

这段内容来自《Type Theory and Formal Proof An Introduction》第7章第7.2节，讨论了在类型理论（特别是 λC 系统）中对逻辑联结词“合取”（conjunction，记为 ∧）和“析取”（disjunction，记为 ∨）的编码方法。之前的章节已经说明了如何用类型和函数类型(A→B)来表达逻辑中的蕴涵(⇒)。本节在此基础上，以类似的“高阶”或“二阶”编码方式来表示合取和析取。

**对于合取 A ∧ B**，作者给出了一种所谓的“二阶编码”（second order encoding）：

$$
A ∧ B ≡ ΠC : ∗ . (A → B → C) → C
$$

此编码可以理解为：如果对于任意命题 C，“A 与 B 一起能推出 C”蕴涵“C本身就成立”，那么这就意味着 A 和 B 同时为真。这与自然演绎中的合取介入、合取消解规则相匹配。

**对于析取 A ∨ B**，也有相似的二阶编码：

$$
A ∨ B ≡ ΠC : ∗ . (A → C) → (B → C) → C
$$

解释为：“给定任意命题 C，如果从 A 能推出 C，并且从 B 也能推出 C，那么就可以得到 C”，这本质上对应了“如果 A ∨ B 成立，则在对任意 C 的证明时考虑 A 成立的分支和 B 成立的分支，从而得出 C”。

这些二阶编码方式与前面介绍的 negation（¬）的编码相呼应。同样，作者指出了传统的合取与析取的“第一阶”编码（比如用 ¬ 和 → 表达）在直觉主义逻辑中并不适用，而二阶编码在类型理论中更通用、更优雅。

最后作者提到，如果引入这些编码作为基础联结词，那么会涉及更高等级的类型层次，需要至少 λ2（甚至 λω）系统。作者还给出了作为定义的另一种方式：将 ¬，∧，∨ 当做抽象的 lambda 表达式，从而在类型论内部更加自然地处理这些逻辑联结词。

**详细解释与分析（逐段详解）：**

**I. Conjunction（合取）**

**“The conjunction A ∧ B is true if and only if both A and B are true.”**首先回顾合取的逻辑定义：A ∧ B 成立当且仅当 A 成立且 B 成立。

**“There exists a nice encoding of the conjunction in λ2:
A ∧ B ≡ ΠC : ∗ . (A → B → C) → C.”**作者给出一种二阶编码方式：将 A ∧ B 定义为一个多态的表达式，它对任意 C:∗ 表达一个从 “A → B → C” 到 C 的映射。

**“This is a so-called ‘second order’ encoding...”**这里称为“二阶”编码，因为它对所有的命题 C （C : ∗）进行量化（ΠC : ∗），相当于在命题层面上操作，这超越了一阶逻辑（只对元素量化）。类型理论中的 ∗ 表示类型层级（命题的层级），对 ∗ 进行量化相当于对所有命题量化，因此是二阶的。

**“It is more general than a first order encoding such as A ∧ B ≡ ¬(A → ¬B).”**有经典逻辑中的等价公式：A ∧ B 类似于 ¬(A → ¬B)，但这在直觉主义逻辑下并不成立或不够自然。二阶编码更通用，不依赖于经典逻辑定律（如排中律或双重否定律）。

**“Why does the expression ... encapsulate the same meaning as A ∧ B?”**作者接下来解释这个定义为何合理。

**“Let’s read ΠC:∗ as ‘for all propositions C’, and → as ‘implies’.”**将类型量化(Π)读作“对所有 C”，将 → 读为“蕴涵”。

**“Then ΠC : ∗ . (A → B → C) → C can be read as:
For all C, (A implies (B implies C)) implies C.”**自然语言释义：对于任意命题 C，如果 A 与 B 一起能推出 C，那么 C 就单独成立。

**“Since we are dealing with logic,...”**A, B, C 都是命题。“...if A and B together imply C, then C holds on its own,”表示如果 A 和 B 都是真的，那么“从 A 和 B 推出 C”这件事对任何 C 都可以简化成“C 本身就成立”。这意味着如果 A 和 B 不都为真，就不可能让这个条件在所有 C 上都成立。因此，从逻辑上讲，这个定义就捕获了 A ∧ B 成立所需要的条件。

**“Hence, ... use ΠC:∗ . (A → B → C) → C as an encoding for A ∧ B.”**这样，就确立了 A ∧ B 的二阶编码。

**“One calls this the second order encoding ... because it generalises over propositions.”**再次强调这是一种对所有命题量化的高阶定义，与普通的一阶逻辑不同。

**“The informal reasoning given above motivates the proposed encoding...”**前面的直觉解释说明了为什么这个编码与逻辑含义一致。

**“There is also a formal justification: ... we recall these rules for ∧”**自然演绎中合取的规则为：

- (∧-intro)：从 A 和 B 推出 A ∧ B
- (∧-elim-left)：从 A ∧ B 推出 A
- (∧-elim-right)：从 A ∧ B 推出 B
作者将自然演绎规则与二阶编码下的类型论规则并列展示：

$$
(∧\text{-intro})\; A \quad B \over A ∧ B
$$

对应的二阶版本：

$$
(∧\text{-intro-sec})\; A \quad B \over ΠC : ∗ . (A → B → C) → C
$$


$$
(∧\text{-elim-left})\; A ∧ B \over A
$$

对应二阶版本：

$$
(∧\text{-elim-left-sec})\; ΠC : ∗ . (A → B → C) → C \over A
$$


$$
(∧\text{-elim-right})\; A ∧ B \over B
$$

对应二阶版本：

$$
(∧\text{-elim-right-sec})\; ΠC : ∗ . (A → B → C) → C \over B
$$

这些规则在二阶编码下都可以在 λC 中导出，不需要额外添加。

**作者展示了一个构造 (∧-intro-sec) 对应的 λC 推导：**给定上下文 Γ ，包含 A:∗，B:∗，x:A，y:B。需要构造出 ?1 ，使 ?1 的类型是 ΠC:∗ . (A → B → C) → C 。作者给出步骤（a）到（4）的 derivation（详见原文），核心思路是先引入C和z，然后通过应用规则得到 zxy:C，最后通过 λ-抽象两次 (先对z抽象，再对C抽象) 得到期望的类型。这个推导表明，我们可以从 a:A 和 b:B（即从 x:A,y:B）构造出二阶合取编码的 inhabitant，从而实现 (∧-intro) 的对应。

**作者留给读者其他规则的证明作为练习（Exercise 7.4）**，结论是这些规则在类型理论中是可导的。

**II. Disjunction（析取）**

现在介绍析取 (A ∨ B) 的二阶编码。

**“There is a similar second order encoding of the disjunction:
A ∨ B ≡ ΠC : ∗ . (A → C) → (B → C) → C.”**与合取类似，将 A ∨ B 定义为：对任意 C，“如果从 A 可得 C，且从 B 可得 C，那么 C 就成立”。

**“The usual first order encoding of disjunction is A ∨ B ≡ ¬A → B, ... only works in classical logic.”**传统一阶逻辑的某些等价会在直觉主义逻辑中不成立，因此再次强调二阶编码的普适性。

**“We have to convince ourselves that this encapsulates the same meaning as A ∨ B.”**作者再次给出直觉解释。

**读作：For all C, (A → C) and (B → C) together imply C.**逻辑上意味着：如果 A 或 B 成立，那么给定 A 和 B 通向 C 的推导，就能确保 C 成立。这就像模式匹配或分情况讨论：A ∨ B 表示要么是 A 成立，要么 B 成立，那么对任意命题 C，如果你能从 A 推出 C，也能从 B 推出 C，无论真实情况是哪一个成立（A 或 B），都能得到 C。

**“The reasoning the other way round is more complicated.”**从 A ∨ B 推出二阶编码的合理性稍微复杂一些，但直觉相同：A ∨ B 表示对一个未知但肯定在 A、B 中有一个为真。在证明 C 时，如果你对 A 和 B 成立的情况各有办法推出 C，那么整体上 C 就成立。

**“Another justification is the formal proof ...”**自然演绎中析取规则为：

- (∨-intro-left)：从 A 推出 A ∨ B
- (∨-intro-right)：从 B 推出 A ∨ B
- (∨-elim)：从 A ∨ B 和 A⇒C 及 B⇒C 推出 C
对应的二阶类型理论规则为：

(∨-intro-left-sec)：从 A 推出 ΠC : ∗ . (A → C) → (B → C) → C(∨-intro-right-sec)：从 B 推出 ΠC : ∗ . (A → C) → (B → C) → C(∨-elim-sec)：从 ΠD:∗.(A→D)→(B→D)→D，A→C，B→C 推出 C

使用类似合取的推导方法，可以在 λC 中给出这些规则的导出，不需要新增规则。

作者还给出了对应 (∨-elim-sec) 的正式推导作为例子，通过应用 (appl)-rule 对 d:x, y:A→C, z:B→C 等项，最后得到 C。

**Remark 7.2.1**作者补充说明：在7.1、7.2节中定义了 ¬, ∧, ∨ 这几个逻辑联结词在类型理论中的编码。注意有些编码中 A、B 作为自由变量出现。我们也可以定义更抽象的算符形式：

- ¬ ≡ λα:∗.(α → ⊥)
- ∧ ≡ λα:∗.λβ:∗. Πγ:∗.(α → β → γ) → γ
- ∨ ≡ λα:∗.λβ:∗. Πγ:∗.(α → γ) → (β → γ) → γ
这样 ¬、∧、∨ 是真正的二阶多态函数，接受类型(命题)作为参数，从而产生相应的连接词结果。从这些抽象形式中，用 (appl)-rule 应用到具体的 A、B 上，即可得到之前定义的形态。

作者提示：这样就需要比 λ2 更强的系统（如 λω）来处理这种更高层次的多态性，因为现在我们对类型本身进行二次抽象和应用。

**总结（这段内容总体讲了什么）：**

在这段内容中，作者展示了在 λC 类型理论中对合取 (A ∧ B) 和析取 (A ∨ B) 的二阶编码方法。通过对任意命题 C 量化和构造特定的函数类型，能够：

- 将合取 A ∧ B 表示为
$$
A ∧ B ≡ ΠC:∗.(A → B → C) → C
$$
直觉上，这表示若 A 和 B 都为真，则可从 “A 与 B 推出 C” 得到 C本身。这与自然演绎的合取规则 (∧-intro, ∧-elim) 一一对应。
- 将析取 A ∨ B 表示为
$$
A ∨ B ≡ ΠC:∗.(A → C) → (B → C) → C
$$
这一编码表示：如果要从 A 或 B 导出 C，那么只要为 A 和 B 提供各自通往 C 的路径，就能在不区分哪一个为真的情况下得到 C。这与自然演绎的析取规则 (∨-intro, ∨-elim) 相匹配，体现了从 A ∨ B 分情况推出 C 的原理。
通过这些编码，我们不需要将 ∧、∨ 规则作为基本规则添加进系统，而是可以在 λC（甚至 λ2、λω）中用已有的函数抽象与应用规则来导出它们。这使得类型理论成为一个非常灵活而通用的逻辑框架。

最后的备注 (Remark 7.2.1) 显示了更高阶的编码方式：直接定义 ¬、∧、∨ 为λ抽象的二阶多态函数，对命题类型进行抽象，从而更具一般性和灵活性。但这样会需要更强的系统（如 λω）来承载这一层级的多态性。

总之，这段内容通过二阶类型构造，巧妙地将逻辑联结词嵌入类型理论中，使得逻辑推导规则在 λC 中自然导出，进一步展示了类型理论在作为逻辑与数学证明的统一框架下的巨大威力和优雅性。
  
 Thought for a second
下面的回答会在开头对整段内容给出一个总体概览，然后对你提供的每个段落进行深入、细致的讲解，帮助你理解这一段内容所讨论的概念和推理过程。回答中不会省略重要的步骤或概念，并会在结尾对整段内容的讲解进行全面而详尽的总结。

**概览（这段内容讲了什么）**：

本段内容来自第7章第7.3节，重点展示了如何在 λC（Calculus of Constructions）这一类型理论系统中模拟并证明传统命题逻辑中的某些命题，也就是将命题逻辑的定理转化为类型，并给出相应的 inhabitant（证明项）。作者展示了已经在前面章节和小节（7.1，7.2）中定义的逻辑联结词（蕴涵⇒、否定¬、合取∧、析取∨）在λC中如何编码，并通过一个具体的例子进行演示。

这个例子是一个逻辑恒真式 (tautology) 的证明：

$$
(A \lor B) \Rightarrow (\neg A \Rightarrow B).
$$

作者在 λC 中使用前面定义的二阶编码来表示 A∨B、¬A、以及逻辑蕴涵(⇒)。接着，他给出一个详细的 λC 型推导过程（Figure 7.1）来证明这个恒真式，展示了在类型理论中如何通过构造 inhabitant 来实现逻辑证明。

最后，还讨论了如果使用更高阶的编码（如前一节中提到的将 ¬、∨ 都作为lambda抽象的函数）时，需要进行更多的化简，但本质不变。

**详细逐段详解**：

**“We are now able to ‘do’ propositional logic in type theory...”**
作者表示，在前面介绍了在 λC 中对矛盾(⊥)和各种逻辑连结词（⇒、¬、∧、∨）的编码后，我们现在已经具备了在类型理论中进行命题逻辑推理的工具。也就是说，可以在 λC 中表达和证明命题逻辑中的定理。

**Remark 7.3.1：**
这里作者提到只差双向蕴涵(⇔)没有直接编码。但我们知道：

$$
A ⇔ B \equiv (A ⇒ B) ∧ (B ⇒ A),
$$

因此可以用已知的连结词来定义 ⇔。没有新的困难。

**“In order to show how propositional logic ‘works’ in type theory...”**
作者想通过一个例子来说明在 λC 中如何构建相应的推导。所选例子是逻辑恒真式：

$$
(A ∨ B) ⇒ (¬A ⇒ B).
$$

用前面介绍的编码来表示，该公式的目标类型（见行(10)）变成寻找一个 inhabitant（证明项）使得下面的类型是可居住的：

$$
(∗) \quad (A ∨ B) → (¬A → B).
$$

记得 A∨B 和 ¬A 都被编码为高阶类型表达式，特别是：

- $¬A ≡ A→⊥$
- $A∨B ≡ ΠC:∗. (A→C)→(B→C)→C$.
将这些代入后，作者得到一个相当复杂的类型表达式，但逻辑内容不变。

**关于导出过程的说明：**

- A 和 B 是任意命题，所以在推导时将 A:∗ 和 B:∗ 作为上下文假设（这代表 A、B 是任意类型处于类型层级 ∗）。
- 我们要在包含 A:∗、B:∗ 的上下文中，构造出 (A∨B) ⇒ (¬A⇒B) 的 inhabitant，即证明在该上下文下该类型可居住。
- 作者使用 λC 的推导规则（包括 appl 和 abst 等）给出一个详细的类型推导（见 Figure 7.1）。
**Figure 7.1的推导结构：**

- 行(a)与(b)中，我们有 A:∗, B:∗，表示任意命题 A,B。
- 行(c)假设了 x : (A∨B)，以便使用 (⇒-intro) 规则来构造 (A∨B)⇒(...) 的inhabitant：先假设(A∨B)成立，然后在上下文中证明 (¬A⇒B)。
- 行(d)再假设 y : (A→⊥)，也就是假设 ¬A 成立，用来证明 B，从而完成 (¬A⇒B) 的构造。
- 最终在行(10)得到 λx. λy. (...) 的结构，表示从 (A∨B) 和 ¬A 中得到 B。
作者指出的关键点：

1. **上下文与层层假设**：
- 最终目标：在 A,B 给定的上下文下构造 (A∨B)→(¬A→B) 的 inhabitor。
- 使用 (⇒-intro) 将目标分解：从要证明 (A∨B)⇒(¬A⇒B)，先假设 (A∨B) ，在这个扩展上下文下构造 (¬A⇒B)。然后再对 (¬A⇒B) 使用 (⇒-intro)，假设 ¬A 来构造 B。
2. **应用 x 和 y 的方式**：x 是 A∨B 的 inhabitant，它的类型是
$$
x : ΠC:∗. ((A→C)→(B→C)→C).
$$
如果我们给 x 一个特定的 C，比如选 C = B，那么
$$
x B : (A→B)→(B→B)→B.
$$
这样通过选择合适的 C，我可以让 x 的类型适配出一个结构，为了最终得到 B，我要将 A→B 与 B→B 的 inhabitant 传给 x B，使得 xB (A→B)(B→B) : B。
3. **构造 A→B**：为了得到 A→B，我们需要假设 A 并从中得出 B。
- 假设 u:A，
- 因为我们有 y : A→⊥ 和 u:A，故 yu:⊥ （将u代入y）。
- 有了 ⊥，我们就能通过⊥消除规则得到任意类型的inhabitant，包括 B。
- 因此 yuB : B （⊥-elim），也就是从矛盾推出 B。
- 再对 u 抽象：λu:A.yuB: A→B.
4. **构造 B→B**：B→B 是简单的恒真句，可用 λ抽象直接构造：λv:B.v。
5. **最后拼装**：有了 A→B 和 B→B，就能对 x B 应用两次函数消解得到 B。将这一结果对 y 抽象得到 (A→⊥)→B，再对 x 抽象得到 (A∨B)→((A→⊥)→B)，即 (A∨B)⇒(¬A⇒B)。
作者在 (3) 行中用到 yuB：这相当于利用了类型⊥ = Πα:∗. α 的特性，从 ⊥ 可得到 B。详见前一节 7.1 讨论过的⊥-elim。

**“We invite and encourage the reader to study the further details.”**作者鼓励读者仔细推敲推导过程中的每一步，来理解 λC 中的逻辑证明结构。

**Remark 7.3.2：**
作者评论说，如果我们不是直接使用之前定义的 A∨B 等简写编码，而是从更高阶的抽象定义开始（如前一节的 remark 7.2.1 中的定义），就需要在推导前对类型进行 β-化简并使用 (conv) 规则将类型转换成之前的形式，然后和前面的推导一致。

这说明我们有两种方式编码逻辑联结词：

- 一种是直接将 A, B 代入已有的二阶编码；
- 一种是先定义更一般的抽象算子 (例如 ¬, ∨) 再对 A,B 应用，这会需要在推导前进行 β-化简和类型转换以恢复到熟悉的形式。
**最后一部分（7.4 Classical logic in λC）是下一个小节的内容简介**：

作者提到我们目前获得的是直觉主义逻辑，而非经典逻辑。经典逻辑中的排中律(ET)和双重否定律(DN)在直觉主义逻辑下不可推出。如果想在 λC 中实现经典逻辑，我们需要额外增加一个公理，比如 ET（A∨¬A）。通过将 ET 作为公理(axiom)添加到上下文(即 iET : Π α:∗. α∨¬α)，就能从直觉逻辑推导出双重否定律等经典推断，从而获得经典逻辑。

下文举了一个例子说明怎样在加上 ET 的情况下推出双重否定律 Dn: ¬¬β→β。过程与之前类似，通过 iET β 得到 β∨¬β，再通过类型应用和构造 β→β、¬β→β 的 inhabitant 来最终推出 β。这示例说明添加 ET 后，可以导出 DN，从而升级到经典逻辑。

（这属于下一小节的内容，但出现在用户给出的文本中，所以顺带说明：这进一步表明 λC 是一个强大的框架，可以通过添加额外公理解决系统中的某些逻辑问题。）

**总结（这段内容总体讲了什么）**：

这一段内容（7.3节）展示了在 λC 中已经定义了诸如 ¬、∧、∨ 后，可以像在普通命题逻辑中一样进行推理和证明。作者通过一个具体的例子（证明 (A∨B) ⇒ (¬A⇒B) ）给出一个完整的λC推导过程。该过程用 λC 的抽象、应用规则，将逻辑定理转化为类型中的 inhabitant 构造。关键步骤在于：

- 将 (A∨B) ⇒ (¬A⇒B) 解读为一个类型框架下的类型构造与 inhabitant 引入。
- 使用二阶编码的 A∨B 和 ¬A，配合 ⊥ 的定义从中推出 B。
- 通过假设(A∨B)和(¬A)，依次构造出 B，从而完成对该逻辑恒真的类型化证明。
作者还指出，如果使用更高阶的定义编码联结词，需要额外的类型转换步骤 (β-化简和 (conv) 规则) 才能得到与本例中类似的推导。

通过这一例子，读者可以清楚地看到类型理论中逻辑证明与 inhabitant 构造之间的对应关系：在λC中，逻辑定理的证明对应一个 inhabitant 的构造过程。在前面章节中的编码让我们只需要 λ抽象和函数应用以及基本的类型规则，就能模拟自然演绎逻辑证明的过程。
  
 Thought for a second
下面的回答会在开头先对这一整段内容进行一个宏观概览，告诉你这段内容整体上讲了什么。接着，会对文本中的每一部分、每一段落进行详细的解释和分析，帮助你从零基础的角度理解其所蕴含的概念和推导。最后，会对整个内容进行一个全面而详尽的总结。整个过程中不会省略任何重要细节，力求做到非常详细。

**概览（这段内容讲了什么）**：

这段内容来自第7章第5节，主题是将谓词逻辑（predicate logic）中的量词 ∀ 和 ∃ 用类型理论（λC系统）中的构造来编码。之前的章节已经展示了如何在 λC 中实现命题逻辑，包括了蕴涵、否定、合取、析取和由此搭建的直觉逻辑与经典逻辑。

- 对于全称量词 ∀，在第5.4节中已经介绍了编码方法：∀x∈S P(x) 可以编码成 Πx:S. P x。这个编码在类型理论中很好地与自然演绎中的引介与消解规则对应。
- 现在只剩下如何对存在量词 ∃ 进行编码。本段首先指出，用第一阶逻辑中典型的定义 ∃x∈S P(x) ≡ ¬∀x∈S(¬P(x)) 只有在经典逻辑下才成立，不适用于构造性的直觉逻辑。但是作者将提供一个二阶编码（second order encoding），与 ∃ 的 (∃-intro) 和 (∃-elim) 规则在构造逻辑中有很好的匹配。
作者给出的编码是：

$$
∃x∈S (P(x)) ≡ Πα : ∗ . ((Πx : S . (P x → α)) → α).
$$

作者随后通过比较这个编码与自然演绎规则中 (∃-intro) 和 (∃-elim) 规则，说明此编码是合适的。最后又讨论了一个更高阶的抽象表示方式，并指出这种编码所在的系统层级（至少需要 λP2，以至需要 λC）。

**逐段详解**：

**“Now that we have coded propositional logic...”**作者前面已经展示了如何在 λC 中对命题逻辑的各种连接词进行编码，并且看到了如何处理直觉逻辑和经典逻辑。现在作者要进一步进入谓词逻辑（predicate logic），也就是处理量词 ∀ 和 ∃。

**“For this, we have to find encodings for the quantifiers ∀ and ∃.”**要将谓词逻辑搬入类型理论，我们需要找到合适的类型编码来表达 ∀x∈S P(x) 和 ∃x∈S P(x) 这样的语句。

**“As far as ∀ is concerned...”**对于全称量词 ∀x∈S P(x)，之前（第5.4节，V部分）已经给出了一个令人满意的编码：

$$
∀x∈S P(x) \equiv Πx:S. P x.
$$

这个编码符合自然演绎中的 (∀-intro) 和 (∀-elim) 规则。因为引入全称量词类似于对任意 x 抽象出类型，而消除则是对该类型进行实例化。

**“All that’s left is the existential quantifier ∃.”**现在重点是存在量词 ∃x∈S P(x)。

**“The first order definition of ∃, namely ∃x∈S P(x) ≡ ¬∀x∈S(¬P(x)), only works in classical logic.”**在经典逻辑中我们有等价：∃x P(x) 可以通过 ¬∀x(¬P(x)) 来定义。但在直觉逻辑中这个等价并不成立，因此这种定义不适合在构造性的类型理论中使用。

**“There exists a more general second order encoding of ∃ ...”**作者提出了一个更通用的“二阶”编码方式来处理存在量词。这种编码在构造逻辑中也适用。这个编码是：

$$
∃x∈S(P(x)) \equiv Πα : ∗ . ((Πx:S.(P x → α)) → α).
$$

**“Let’s try to translate the latter expression in words...”**用自然语言解释该编码：“对所有 proposition α，如果从 ∀x∈S（P(x)⇒α）可推得 α 本身，那么从中我们可感受到存在性的含义。”

直觉上还不明显为什么这等同于“存在一个x使P(x)成立”，但作者保证该编码能满足 (∃-intro) 和 (∃-elim) 的自然演绎规则，从而展示它的合理性。

**接下来作者分析 (∃-elim) 规则的自然演绎形式**：

**“Let’s start with the elimination rule for ∃...”**自然演绎中对存在量词的消解规则是：

$$
(∃\text{-elim}) \frac{∃x∈S P(x)\quad ∀x∈S(P(x)⇒A)}{A}
$$

解释这条规则：

- 第一个前提：存在某个 x ∈ S 使得 P(x) 成立。
- 第二个前提：对于 S 中的任意 x，如果 P(x) 成立就能推出 A。
- 结论：A 成立。
直观上这代表：既然有某个特定的 x 满足 P(x)，并且对任何满足 P(x) 的 x 都能推出 A，那么用这个特定的 x 应用第二条前提，就得到 A。

**“We first give an intuitive explanation...”**(1) 有个 x 符合 P(x)(2) 对所有 x，如果 P(x)则A将 (2) 应用于那个实际存在的 x，就能得到 A。

这个规则是合理的。

**Remark 7.5.1**：数学上常用的方式是从“∃x P(x)”中“取出”那个 x，并在后续推导中使用它。但是严格的形式化中要小心 x 的作用域与合法性，(∃-elim) 的自然演绎形式是最严格正确的形式。

**“Now we have to show that the type-theoretic (second order) counterpart ...”**现在作者要证明类型理论中的二阶编码能实现和 (∃-elim) 类似的效果。在类型理论对应规则是：

$$
(∃\text{-elim-sec}) \frac{Πα:∗.((Πx:S.(P x → α))→α)\quad Πx:S.(P x→A)}{A}
$$

看看这条规则：

- 第一个表达式 Πα:∗.((Πx:S.(P x→α))→α) 就是我们定义的 ∃x∈S P(x) 的编码。
- 第二个表达式 Πx:S.(P x→A) 对应于前提“对于所有 x, P(x)⇒A”。
- 结论是 A。
**“A derivation to show that this rule is derivable in λC is easy...”**作者给出了简单的推导过程：

上下文：(a) S:∗(b) P:S→∗(c) A:∗(d) y: Πα:∗.((Πx:S.(P x→α))→α) —— 对应存在性的二阶编码(e) z: Πx:S.(P x→A) —— 对应(∀x P(x)⇒A)

推导步骤：(1) 对 y 应用 A：y A : (Πx:S.(P x→A))→A(2) 再对 y A 应用 z：y A z : A

就是先从通用的 α 换成特定的 A，然后用 (Πx:S.(P x→A)) 来得到 A。和 (∃-elim) 一样，先实例化 ∃x∈S P(x) 的 α 为 A，然后利用 (⇒-elim) 得到 A。

**“Note how simple this is.”**这个推导很简单，与逻辑直觉是一致的。

**Remark 7.5.2**：x 不能出现在 A 的自由变量中，这是前提，确保应用合法性（否则会有作用域与依赖问题）。

**“On closer inspection...the second order encoding of ∃ is exactly what the (∃-elim)-rule expresses.”**经过仔细检查，这个二阶编码正是 (∃-elim) 的本质表达：存在性保证我们对于任意 A，都能从 (Πx S.(P x→A)) 推出 A，于是定义成 Πα:∗.((Πx:S.(P x→α))→α) 自然合适。

(∃-elim) 就是说：∃x∈S P(x) 意味着对所有命题 A，如果（∀x(P(x)⇒A))则A，这与编码吻合。

**“This brings our discussion of (∃-elim) to a conclusion.”**(∃-elim) 的编码已经说明完毕。

**“How about the introduction rule for ∃?”**现在看 (∃-intro) 规则。自然演绎中：(∃-intro)：

$$
\frac{a∈S \quad P(a)}{∃x∈S P(x)}
$$

如果你已经找到一个具体的 a∈S，使得 P(a) 成立，那么就能推出存在某个 x∈S 使 P(x) 成立。

**“In order to show that the type-theoretic counterpart of this (∃-intro)-rule is correct...”**在类型理论中，需要展示：

$$
(∃\text{-intro-sec}) \frac{a:S \quad P(a)}{Πα:∗.((Πx:S.(P x→α))→α)}
$$

这里我们有 a:S 和 P a: P(a)，要构造 ∃x∈S P(x) 的编码：Πα:∗.((Πx:S.(P x→α))→α)。

作者给出初步上下文：(a) S:∗(b) P:S→∗(c) a:S(d) u:P a

从这些假设中构造目标：

$$
? : Πα:∗.((Πx:S.(P x→α))→α).
$$

作者在文本中指出，完成这个推导很容易，把 ? 定义为：

$$
? ≡ λα:∗.λv:(Πx:S.(P x→α)). v a u.
$$

什么意思呢？给定任意 α 和 v:(Πx:S.(P x→α))，特别地为 x 取 a，则 P a→α，可以用 u:P a 来得到 α（先从 u 得到 P a，然后应用 v a）。因为 v a : P a→α，将 u 应用进去得到 v a u: α。这就表明存在一个 x (就是 a) 使得 P(x) 成立，从而能选出 α。

这样就满足 (∃-intro) 的要求：从具体的 a:P a 构造存在证据 Πα:∗.((Πx:S.(P x→α))→α)。

**Remark 7.5.3**：我们定义的存在量词为：

$$
∃x∈S(P(x)) ≡ Πα:∗.((Πx:S.(P x→α))→α).
$$

和之前处理 ∧、∨、¬ 一样，这里存在 S 和 P 作为自由变量。我们也可以将 S、P 都抽象出来，定义一个更加通用的“存在”运算子：

$$
∃ ≡ λS:∗. λP:S→∗. Πα:∗.((Πx:S.(P x→α))→α).
$$

然后应用 ∃ 到 S 和 P 可以恢复上面的表达式。

最后作者指出类型需求：

- Πα:∗.((Πx:S.(P x→α))→α) 本身居于类型 ∗ 中，需要 λP2 系统（如图6.3中的标记）即可。
- 而使用更高阶的抽象 ∃: λS:∗.(S→∗)→∗ 则需要 λC，因为它同时量化于类型 (S:∗) 和函数类型 (S→∗)，这需要最高层的 λC 系统支持。
**总结（这段内容总体讲了什么）**：

在第7.5节中，作者将之前在类型理论中实现命题逻辑的思路扩展到谓词逻辑，重点处理量词 ∀ 与 ∃ 的编码：

1. 对于全称量词 ∀x∈S P(x)，我们已知编码为 Πx:S.P x，它能满足(∀-intro)与(∀-elim)规则。
2. 对于存在量词 ∃x∈S P(x)，简单的经典逻辑替换（∃x P(x) = ¬∀x¬P(x)）在直觉逻辑下不成立，因此需要一个更通用的二阶编码。作者给出一个二阶编码：
$$
∃x∈S(P(x)) ≡ Πα:∗.((Πx:S.(P x→α))→α).
$$
通过对比自然演绎中的(∃-elim)和(∃-intro)规则，作者展示了该编码可以成功再现这两个规则在类型理论中的版本，即这种编码与自然推理规则兼容。
- (∃-elim)：从 ∃x∈S P(x) 和 ∀x P(x)⇒A 推出 A，在类型理论中对应的推导清晰简单。
- (∃-intro)：从 a:S 且 P(a) 推出 ∃x∈S P(x)，在类型理论中使用 λ抽象和函数应用也容易构造出所需的 inhabitant。
3. 最后，作者指出像这样更高阶的编码需要更强大的系统（如 λP2 或 λC）来支持，但这正是 λC 的灵活性所在。
通过这个讨论，作者完成了将谓词逻辑（尤其是 ∀ 与 ∃ 的逻辑规则）嵌入类型理论 λC 中的展示。我们看到，类型理论不仅可以表示命题逻辑，还能优雅地表示谓词逻辑的量词及其引介和消去规则。由此类型理论展现出作为逻辑基础和数学证明助理框架的强大能力。
  
 Thought for a second
下面的回答在开头先对这部分内容进行整体概览，然后再对用户提供的段落进行逐段、详细而透彻的讲解。回答中不会省略重要信息，并会提供充分背景和解释，帮助你在没有相关知识背景的情况下理解这一段内容。最后会对整段内容的重点进行一个全面详尽的总结。

**概览（这段内容讲了什么）：**

本段内容选自第7.6节到7.8节，作者在此展示了在 λC（Calculus of Constructions）系统中对谓词逻辑（predicate logic）进行编码的实际应用例子，并讨论了将逻辑系统（如自然演绎系统）和类型理论联系起来的方法和意义。

- 在第7.6节中，作者以一个具体例子来说明如何在 λC 中证明谓词逻辑中的命题，即从类型化的角度去找到该命题所对应的 inhabitant。例子是：$¬∃x∈S(P(x)) ⇒ ∀y∈S(¬P(y))$作者对该公式进行二阶编码（使用之前定义的 ∃ 和 ∀ 的编码方法），给出了逐步构造derivation（推导）的过程。
- 在第7.7节，作者对本章的内容进行总结，强调了类型理论对逻辑乃至数学的统一表达能力，并指出了在 λC 中进行逻辑和数学证明的优点与局限。
- 在第7.8节，作者提供了进一步阅读的建议，回顾了自然演绎、序列演算（sequent calculus）、希尔伯特风格系统（Hilbert systems）等逻辑系统的基础，以及这些系统的历史和特性。还提到在经典逻辑中某些定义（如 ∃）可以用更简单的方式给出，但是在直觉逻辑中则需要二阶编码。作者还介绍了匹配这些逻辑系统的参考文献和对证明助理工具（如Coq）的说明。
总体来说，这部分内容是对前面章节成果的实例和总结，让读者看到类型理论如何编码和模拟传统逻辑证明，并在此基础上走向计算机辅助证明和更高层次的数学形式化。

**详细逐段详解：**

### 第7.6节：An example of predicate logic in λC

**“In order to demonstrate how the codings of ∀ and ∃ in λC work...”**作者要通过一个具体的例子，展示如何在 λC 中使用前面定义好的 ∀、∃ 编码来进行谓词逻辑的证明。

**要证明的命题：**

$$
¬∃x∈S(P(x)) ⇒ ∀y∈S(¬P(y)).
$$

用前面章节的二阶编码方法表示逻辑连接词，这个公式在 λC 中可表示为：

$$
((Πα:∗.(Πx:S.(P x → α))→α) → ⊥) → Πy:S.(P y → ⊥).
$$

解释：

- $∃x:S.P(x)$ 被编码成 $Πα:∗.((Πx:S.(P x→α))→α)$
- ¬A 表示 A→⊥
- (A⇒B) 表示 A→B
- 这样 ∀y:S.(¬P(y)) 就是 Πy:S.(P y→⊥)。
作者也允许在证明中使用简化记号 ∀ 和 ∃ 来减少视觉复杂度（把 Π 与 二阶量化替换回更熟悉的符号）。这样在 λC 中写出的公式看起来和逻辑中的公式很相似。

**“Raising flags for the free variables S and P...”**作者采取旗标（flag）风格来描述推导过程（参考之前的章节介绍），对于上下文中的自由变量S:∗ 和P:S→∗，最终目标是构造一个inhabitant，使得

$$
? : ¬(∃x:S.Px) ⇒ ∀y:S.¬(P y)
$$

成立。

**使用抽象规则分解目标：**记住 A⇒B 在类型上是 A→B，当要证明 A→B 的目标时，一般用 (abst)-rule（λ抽象）来引入一个假设A以推导B。

对于 (n) ? : ¬(∃x:S.Px) ⇒ ∀y:S.¬(P y)，∃-intro编码的结果本身是个 Π 类型加箭头类型的复杂嵌套。作者逐步使用抽象，引入变量：

- (c) u : ¬(∃x:S.Px) (假设前件)
- (d) y : S (对于全称量词需要引入 y)
- (e) v : P y (对 (¬(P y)) 使用 (⇒-intro) 时需先假设 P y)
最后的目标是产生⊥，从而形成 v:Py →⊥的结构。

**思路：**如何从 v:Py 得到 ⊥？从 (c) u : ¬(∃x:S.Px) = (∃x:S.Px)→⊥ 来看，如果能构造出一个 inhabitant of (∃x:S.Px)，就能用 u 应用这个 inhabitant 获得 ⊥。

**构造 ∃x:S.Px：**我们需要找一个 a∈S 且 P a 成立即可根据 (∃-intro) 的规则构造出来。而我们已经有 y:S 和 v:P y，正好可以取 a=y。于是用之前定义的二阶 (∃-intro)：

$$
? : ∃x:S.Px \equiv λα:∗.λw:(Πx:S.(P x→α)). w y v
$$

这样就从 y,v 得到了一个 inhabitant of ∃x:S.Px。

将其代入u:

$$
u (λα:∗.λw.(Πx:S.(P x→α)). w y v) : ⊥.
$$

有了⊥，就能合成 v:Py→⊥ 的 inhabitant，并继续合成 ∀y:S.(¬P y) 以及整个 (¬∃x:P(x))⇒(∀y:¬P(y)) 的证明项。

**最后作者给出完整推导**：(a)-(e)是上下文假设，

(1) 定义 ∃x:S.Px 的 inhabitant：

$$
λα:∗.λw:(Πx:S.(P x→α)). w y v
$$

(2) 应用 u 到 (1) 得到 ⊥

(3) 抽象出 v 得到 ¬(P y)

(4) 抽象出 y 得到 ∀y:S.¬(P y)

(5) 抽象出 u 得到 ¬(∃x:S.Px) ⇒ ∀y:S.¬(P y)

**作者指出**：如果不使用略写，这个证明项会非常长，但是通过略写（如用∀、∃、¬）、记号简化和定义技巧，可以使得推导更清晰。

### 第7.7节：Conclusions

在这一节，作者对第7章的工作做出总结。

- 作者回顾了在本章中完成的事情：使用类型理论（λC）来编码基本的逻辑概念，包括命题逻辑（直觉的和经典的）和谓词逻辑。
- 我们看到了如何在 λC 中引入 ‘absurdity’(⊥)、negation(¬)、conjunction(∧)、disjunction(∨)、以及 quantifiers (∀, ∃) 的二阶编码，使之满足自然演绎规则。
- 由此我们实现了从类型理论的角度对逻辑系统进行建模。
- 要从构造逻辑扩展到经典逻辑，需要增加排中律(ET)或双重否定律(DN)作为额外公理。
- ∀、∃ 的编码使谓词逻辑也能嵌入 λC 中。
- 所有编码与自然演绎规则精确对应，并且可以在 λC 中验证其正确性。
- 作者也提到，在实际构造证明时，类型项（proof terms）可能变得冗长，不易理解。之后的章节会引入定义（definitions）机制来帮助管理和简化推导。
- 最后强调类型理论证明和逻辑证明之间的对应关系：proof checking = type checking。通过计算机程序可自动检查证明正确性，从而支持证明助理工具和数学形式化。
### 第7.8节：Further reading

在这一节，作者提供进一步的阅读建议和历史背景：

- 二阶逻辑中用 ⇒ 和 ∀ 定义 ∨、∧、∃ 的方法是经典的，可在 Troelstra & van Dalen (1988) 或 van Dalen (1994) 中找到参考。
- 在直觉逻辑中，这些二阶定义是有用的，因为没有排中律，传统从 ¬、∀ 中定义 ∨、∧、∃ 的方法不适用。
- 在引入双重否定或排中律后，可以用经典的等价方式定义这些连结词和量词。
**逻辑系统分类与历史**：

- 自然演绎（Gentzen和Jaśkowski）是为了捕捉数学家推理的自然形式
- 序列演算（Sequent Calculus）是 Gentzen 引入的，用于更好地控制证明形式并证明一致性等性质
- 希尔伯特体系（Hilbert style）：使用少量公理和简单规则，为研究提供清晰框架，但不直观。
自然演绎的推导结构（如A1,...,An ⊢ B）与序列演算的推导结构(A1,...,An ⊢ B1,...,Bk)对比，序列演算规则强调左右引入的对称性。

给出了一些序列演算中的典型规则例子（比如 ∧、∨、⇒的规则）并说明它们的对称性和与自然演绎的对偶关系。

**关于树式和标记式推导（flag-style derivations）**：

- Jaśkowski风格的线性展示（flag-style）和 Gentzen风格的树形展示都可以互相转换。
- Prawitz对自然演绎证明进行广泛研究，β-约简对应于cut-elimination，这与类型理论中的规范化和合流有对应。
**关于Coq**：

- Coq系统最初基于 λC，可以通过类似本章的方法来表达逻辑。但后来扩展了归纳类型，使逻辑更加自然。
- 在Coq中，用户通过tactics构建证明，不需要手动构造复杂的证明项。
- 本书后面介绍的定义和简化工具有助于解决冗长证明项的问题。
**总结（这段内容总体讲了什么）**：

在本段内容（7.6-7.8节）中，作者以实例和总结的方式加深读者对前面章节工作的理解和应用：

1. **实例演示（7.6节）**：作者具体展示了如何在 λC 中证明一个谓词逻辑命题 $¬∃x:P(x) ⇒ ∀y:¬P(y)$ 的可类型化。通过将 ∀、∃、¬ 的二阶编码与 λC 的抽象和应用规则相结合，构造出复杂逻辑命题的inhabitant，展示了如何从类型理论的角度“证明”逻辑定理。
2. **总结（7.7节）**：这一节对第7章的工作进行总结，强调了类型理论作为逻辑基础和证明辅助的优点：
- 将逻辑命题视为类型，将证明视为 inhabitant，可实现 proof-checking = type-checking。
- 可以自动化验证证明。
- 同时指出在实际应用中，证明项可能很长难以理解，需要定义（definitions）和工具（如证明助理Coq）的帮助。
3. **进一步阅读（7.8节）**：作者介绍了自然演绎、序列演算和希尔伯特体系等逻辑系统的背景和特点。提到在经典逻辑下的简化定义方式，以及在直觉逻辑下的二阶定义的必要性。提供参考文献（Troelstra & van Dalen, van Dalen）和工具（Coq）信息，方便读者深入了解。
总的来说，本段内容通过具体例子和总结，将前面关于 λC 中逻辑编码的理论知识落实到实际推导案例中，并强调了类型理论在逻辑与数学自动化证明中的潜在威力和实用性，也点出了一些不足（如推导项过于冗长）和解决方案（定义机制、证明助理）。
  
 Thought for a second
下面的回答在开头先对这段内容提供一个整体概览，帮助你理解这一部分主要讲了什么。然后，我会对全文逐段、逐句进行详细阐述和解释，帮助你在没有相关背景知识的情况下也能领会其中内容。最后，我会在回答结尾对整段内容作一个全面、详尽的总结。

**概览（这段内容讲了什么）：**

本段内容来自第8章开篇的8.1和8.2节，这里开始探讨在 λC（Calculus of Constructions）这样一种类型理论系统中如何引入**定义（definitions）**的概念。作者指出，在现实的逻辑与数学文本中，定义是不可或缺的工具，可以帮助我们为重要概念命名，从而减少表达复杂性和理解难度。第8.1节谈及定义的本质、定义在数学和逻辑文本中的角色、以及使用定义的原因和益处。作者通过实例说明定义如何帮助我们抽象出概念并以易记的名字来称呼之。

第8.2节则强调在本书所讨论的系统中不会原生支持“归纳式定义（inductive definitions）”或“递归定义（recursive definitions）”作为基础构造。相反，我们将通过更高阶逻辑的方式来处理这些情况，或者在后面章节中通过公理化的方式（对整数等）来间接实现类似归纳与递归的功能。作者强调了这种选择的简化作用，也指出这样一来我们无法直接“运行”递归定义来计算值，而是要通过证明来得到结果。

**逐段详解：**

### 8 The Nature of definitions （8.1 The nature of definitions）

**“In the ‘real world’ of logical and mathematical texts, definitions are indispensable…”**在现实的逻辑和数学文本中，定义是必不可少的。当我们在逻辑或数学中积累了大量的知识和概念时，定义可以帮助我们用简洁的术语指代复杂的概念。没有定义的文本会变得冗长且难以理解。

**“Therefore we aim at an extension of λC with definitions…”**作者计划将 λC 系统扩展，以加入定义的机制。接下来作者会介绍定义的本质和使用方法，并最终在后面章节（第10章）给出名为 λD 的系统（λC 加上定义）。在第9章会先介绍一个简化的版本 λD0，以逐步引入概念。

**“We first ask ourselves: what is the use of a definition?”**这里作者提出一个核心问题：我们为什么要引入定义？定义的主要作用是为某个有用的概念赋予一个名称，以便在后续叙述中反复引用。

**“Both logic and mathematics are based on certain notions…”**逻辑和数学建立在概念之上，这些概念往往是组合而成的。定义让我们将值得注意的概念独立出来，以一个名字来称呼它们，从而在后续推导中更容易处理。

**Examples 8.1.1**作者通过例子展示定义在数学文本中的使用方式：

(1) **“A rectangle is a quadrilateral with four right angles.”**这里，“四个直角的四边形”是个复杂描述，但我们给了它一个名字——“rectangle（矩形）”。定义利用了已有的名词（如“quadrilateral”四边形，“right angle”直角），这些词之前已经定义过。

(2) **“A function f from R to R is called increasing if…”**定义“increasing(单调递增)”函数的概念。先有 f: R→R，再给出条件：对所有实数 x<y，f(x)<f(y)才称 f 为increasing。这里定义指出了何时可以使用“increasing”来描述函数。

(3) **“We say that a relation R on a set S is total if…”**这是对“total（全序关系）”这一概念的定义。先要有 S 和 R，再确定 R 是 total 的条件。可见定义通常有依赖关系：S 和 R 要先存在，然后才能定义 total。

**“The (new) names introduced… are words from natural language…”**定义引入的新名词可以是自然语言的单词（如rectangle, increasing, total），也可以是专门设计的符号或字母。

**Examples 8.1.2**(4) **“Define c as (1+√5)/2.”**这里定义 c 作为一个简写的符号，用它代替繁琐的表达式(1+√5)/2。这使得后续提及 c² - c = 1 更容易。

(5) **“Let n be a natural number > 0. Then Dn is defined as the set of all positive integer divisors of n.”**对于每个正整数 n，定义 Dn 是 n 的正约数集合。例如 D1={1}, D2={1,2}, D4={1,2,4}。定义给了我们一个参数化的名称 Dn，使我们能够便捷地参考这些集合（如 D4 ∪ D6）。

**“Names such as c and Dn are probably for temporary use…”**无论是临时还是长期的名称，定义的目的都是让我们可以轻松复用和引用这些概念。

**“Apart from the reasons mentioned above… definition-less mathematics may obtain a complexity…”**作者指出一个更实际的原因：没有定义的数学文本会急速膨胀，出现复杂度上的爆炸性增长。因此定义在实践上是必要的。

**“We conclude that it is very convenient, and almost inevitable, to introduce and use definitions.”**总结：定义在逻辑和数学中至关重要，既可读性又必要性。

**“There is another case… variables vs defined names.”**介绍变量与定义的区别：

- 变量是用来表示某个任意的对象（如“Let x be a real number”）。
- 定义的名字则表示某个特定的概念（如前例中的 rectangle）。
**Remark 8.1.3**好的定义名称应当能帮助记忆和理解。比如“rectangle”源自拉丁文“rectus”（意为“直”）和“angle”（角）；“increasing”很直观表示增长趋势；“total”暗示对所有元素对的覆盖。有些临时记号如 c, D 也有一定的记忆力属性。

### 8.2 Inductive and recursive definitions

**“In our type theory, we don’t have inductive definitions or inductive types…”**在本书所讨论的类型理论（λC及其扩展）中，没有原生的归纳定义（inductive definitions）或归纳类型（inductive types）作为基本构造。在更强大的系统中（比如CIC, Calculus of Inductive Constructions）可以 inductively 定义自然数，并获得自动的归纳证明原理和良构递归定义。

**“We don’t have inductive definitions, because they can be defined as predicates in higher order logic…”**这里解释为什么不引入：

- 归纳定义可以用更高阶的逻辑来描述
- 或者通过公理假设（例如后来将整数公理化见14.2节）
**“As for recursive definitions…”**递归定义则是通过给出算法式描述来定义对象，比如阶乘 factorial。fac(0)=1, fac(n+1)=fac(n)·(n+1)。这在传统数学中能轻松计算fac(3)=6。

**“Later in this book we will show that we can do without recursive definitions…”**稍后作者会展示如何不用递归定义即可通过描述符 ι 来唯一确定实体，从而在理论中给出想要的函数的描述，而不必真实“执行”算法。

不引入递归定义的两个好处：

1. 系统保持相对简单。
2. 避免对递归定义进行终止性和唯一性证明的麻烦。
缺点是：fac 不是真正的程序，无法直接计算 fac(3) = 6，我们需要在系统内用证明的方式展示这一点，而非算法执行。

**“For more examples of recursive definitions… see Section 14.4 and 14.11.”**在后面章节将有更多递归定义的实例（整数加法与乘法）以及如何在系统中处理。

**总结（这段内容总体讲了什么）：**

第8.1和8.2节解释了定义在数学和逻辑文本中的不可或缺性及作用，并说明本书将在 λC 基础上扩展出一个包含定义功能的系统（λD）。作者通过实际例子说明定义如何为复杂概念提供命名，减少表达难度与文本长度。

在8.2节中，作者强调了本书中的系统不会原生支持归纳和递归定义，而是通过更高阶逻辑或者公理方法解决归纳需求。这一选择保持了系统简洁，但代价是无法直接运行递归定义来计算结果，而必须通过证明来获得等式结论。后面章节会进一步展示如何在没有原生递归与归纳的情况下处理整数及算术运算。

总体来说，这段内容为后续讨论如何在类型理论中正式引入定义做好铺垫，也指出了本书所选定的理论简化路线：不用内建归纳与递归，而通过逻辑或公理化手段来间接实现，从而保持系统的简洁性与易操作性。
  
 Thought for a second
**概览（这段内容讲了什么）：**这段内容选自《Type Theory and Formal Proof An Introduction》第8章第3节和第4节，讨论了在类型理论（特别是扩展后的λC系统）中引入定义（definitions）的格式、参数列表以及定义在使用过程中的实例化问题。作者首先介绍了一种标准的定义格式 a := E，用以明确指出一个名为 a 的定义项（definiendum）等于一个表达式 E（definiens）。接着说明有些定义需要在特定上下文下给出，以在其中使用参数化的方式表示定义的概念，这样定义的常量可以有依赖参数。最后进一步讨论了定义的使用，也就是将定义的参数实例化为具体的对象或表达式，从而在不同环境中重用同一定义。这些讨论为之后在类型理论中正式引入定义的机制打下基础。

**逐段详解：**

### 8.3 The format of definitions

**“We borrow the following standard format for definitions…”**作者从数学的传统中借用定义的标准格式：

$$
a := E
$$

这表示 a 是定义（definiendum），E 是定义内容（definiens）。a 是我们要命名的新概念或常量，E 是提供该概念的精确定义式。

**Definition 8.3.1 (Definiendum, defined name, defined constant, definiens)**

- definiendum（被定义项）：在 a := E 中，a 称为 definiendum，是要被定义的名称，也可以称为被定义名或被定义常量（defined constant）。
- definiens（定义式）：E是给出定义的表达式，即告诉我们 a 的意义。
通过此格式，可以将之前实例中出现的定义以标准格式表达。例如：

- rectangle := quadrilateral with four right angles
- c := (1+√5)/2
**“The situation is more complicated for the other examples…”**对于需要上下文的定义，如“increasing”，需要有一个函数 f: R→R 来进行定义；对“total”则需要有 S 和 R (在S上的关系)；对于 Dn 则需要 n∈N+。这些定义在给出时需要一个上下文（context）来设定参数。

**“It will be clear that such a ‘setting’… can be formalised as a context.”**就像前面章节对上下文的使用一样，我们可以将定义所需的参数打包成上下文。例如：

- 增加性定义需要 f : R→R
- 全序定义需要 S : ∗ 和 R : (S×S)→∗
- Dn定义需要 n : N+
可以像图8.1那样表示：

**Figure 8.1**

```css
f : R → R
increasing(f) := ∀x,y∈R (x
这里每个定义都出现在其上下文中，并带有参数列表。参数列表由上下文的变量标识组合而成。例如 increasing 的参数列表是 (f)，total 的参数列表是 (S, R)，D 的参数列表是 (n)。

**“As these examples show, each defined constant has been provided…”**定义中出现的参数列表收集了上下文中涉及的自由变量，以便在使用定义时可以显式替换参数。我们说“increasing”依赖参数f，“total”依赖参数 S 和 R，“D”依赖 n。

**Remark 8.3.2**参数列表也可省略，因为可从上下文中恢复。但最好显式写出参数列表，使定义看起来更直观，更自然。

**比较有无参数列表的例子：**

- 无参数列表：f := x² + y²
- 有参数列表：f(x, y) := x² + y²
有参数列表的定义更清晰易读。

**“In order to employ a consistent format…”**即使某些定义在空上下文中定义（比如 c := (1+√5)/2，rectangle的定义），理论上也应写作 c() := ...，rectangle() := ...。但实际上我们省略空参数表，以便简化书写（Notation 8.3.3）。

### 8.4 Instantiations of definitions

**“Obviously, definitions are not made for their own sake…”**定义的目的是为了使用。例如有了 c := (1+√5)/2，就可简化表达式 c² - c = 1，而无需重复写 (1+√5)/2。

定义可重复使用，如 c² = c + 1，所以 c³ = 2c + 1 等等。

**“Matters become a bit more complex for definitions in a non-empty context.”**如果定义带参数，则使用定义时需给参数赋具体的实例化（instantiation）。例如 increasing(f) 定义需要一个 f: R→R。当我们说“(x→x³)是increasing的”时，我们将 f 实例化为 λx:R.x³，从而写作 increasing(λx:R.x³)。

**Remark 8.4.1**参数必须是变量，而实例化时我们可以用变量，也可以用任意适合类型的表达式。如 f 要求类型R→R，我们给出 λx:R.x³ ，确实是R→R的函数，类型匹配正确。

一旦定义给出后，使用时不必重复上下文声明，只要参数匹配原先要求的类型即可。例如一旦定义了 increasing(f)，要用时只需写 increasing(λx:R.x³)，无需再写 f:R→R 的标注。

**对多参数定义的实例化**比如 total(S, R) 有两个参数 S和R 。使用时必须先给 S 一个类型实例（如 R 表示实数集），再给 R 一个合适的关系（如 ≤: (R×R)→∗）。这样 total(R, ≤) 是一个实例化的命题。

同理，用 N+ 和 “|” (除尽关系) 实例化，则得 total(N+, |)。尽管 total(N+, |) 这命题在数学上是假的（因为在正整数上整除关系不是总的），但从类型上讲这种实例化是正确的：N+:∗和|:(N+×N+)→∗满足类型要求。

**“Note that in all cases, the type conditions…”**实例化时必须尊重定义中上下文的类型条件。这是保证定义使用正确性的关键点。

**“Summarising…”**总结：使用定义需要实例化参数列表。定义有两个生命周期阶段：

1. 引入阶段（定义时）：“birth”——如 total(S,R) 的定义阶段。
2. 使用阶段（定义被调用时）：“path of life”——如 total(R, ≤) 或 total(N+, |) 不同参数实例化使定义可在不同环境中重用。
**总结（这段内容总体讲了什么）：**这一部分介绍了在类型理论中处理定义的形式化方法。首先（8.3节）讨论了定义的标准格式 a := E，强调 definiendum 和 definiens 的区别，以及在定义中引入参数列表的必要性。对于需要上下文的定义，将上下文中的变量作为参数列出，并在定义中显式使用这些参数，使定义更清晰自然。

接着（8.4节）说明了定义的使用，需要对参数进行实例化（将参数替换成具体的表达式或对象），这样同一个定义可以在不同上下文下重用。作者举例说明如何从抽象定义（如 total(S,R)）到具体实例（total(R, ≤)）进行转换，并指出在实例化中必须满足类型要求。

这些讨论为在类型理论中引入有参数的定义（和后续使用它们）提供了一个清晰框架。从而让定义在 λC中也具有和数学文本中相似的灵活性和可读性。同时，通过区别定义的“出生”（引入时）和“生命过程”（使用阶段），作者让我们对定义的管理有更清晰的概念。
  
 Thought for a second
**概览（这段内容讲了什么）**：本段内容来自第8章第5节与第6节，讨论了如何在类型理论（尤其是λC系统的扩展）中正式引入定义的格式（formal format）。作者首先在第8.5节中给出了为定义引入一种正式的表示方法：在上下文 Γ 下，用记号‘’作为分隔符，将定义写成 `Γ  a(x₁,...,xₙ) := M : N`。这里，a(x₁,...,xₙ)是被定义的常量及其参数列表，M是定义式(definiens)，N是它的类型，N也就成为该定义项的类型。这样一种正式的格式使定义在类型理论中与上下文、类型信息都紧密联系。接着，作者通过例子（关于偏序关系的定义）演示了这种正式格式的使用，并强调定义可以相互依赖，需要按正确的顺序引入。

在第8.6节中，作者进一步指出，有些定义可能取决于带有特定假设的上下文（例如上下文中包含一个已知为偏序的关系）。这意味着在定义某些概念（例如“极小元”或“最小元”）时，可以假设上下文中已经有了某个被偏序化的集合，从而在该假设基础上给出新的定义。这展示了定义在上下文中不仅可以依赖变量和类型，也可以依赖于上下文中的条件（即假设的命题）。

**逐段详解**：

### 8.5 A formal format for definitions

**“Now that we know what definitions are and how they work…”**经过之前几节的讨论，我们已经明白定义的作用与用法。现在作者要将定义正式化到系统中。回顾 Figure 8.1 的几个定义：它们都有类似的结构：

```css
Γ  a(x₁,...,xₙ) := E
```

这里 Γ 是上下文，a(...)是定义的名字与参数列表，E是定义式。

**“We introduce the symbol ‘’ here as a separator…”**用 ‘’ 将上下文 Γ 与定义式分开，读作：“在上下文 Γ 下，我们定义 a(x₁,...,xₙ) 为 E”。

**“Since we work in a typed environment…”**在类型论中，一切都有类型。因此我们不仅要给出定义式 M，也要为其指定类型 N。这意味着定义的通用格式应为：

```css
Γ  a(x₁,...,xₙ) := M : N
```

其中 M 是 definiens，N 是定义表达式 M 的类型，也是定义名 a(x₁,...,xₙ) 的类型。

**“The parameter list (x₁,...,xₙ) consists of the subject variables of the context Γ…”**参数列表就是上下文中的变量列表。若上下文为空，则 n=0，此时就没有参数列表，但仍可写成 a() 或直接 a。

**“we will often use an abbreviating notation…”**作者约定记号：使用 x、A 来表示变量和类型的列表。例如 x 表示 x₁,...,xₙ，A 表示 A₁,...,Aₙ，x : A 表示 x₁:A₁,...,xₙ:Aₙ。这样定义可简写为：

```yaml
x : A  a(x) := M : N
```

这只是缩写手法，在元语言中使用，以避免反复写出上下文详细信息。

**“As we are used to doing, we employ the flag format…”**和之前的章节一样，作者将使用“旗标”（flag）格式来展示定义的上下文和本身。这种格式使上下文显式分行展示，清晰易读。

**“As an example, we have listed a series of definitions regarding a set S and a relation R on S in Figure 8.2.”**Figure 8.2给出一个示例：定义与集合S及其上的关系R相关的概念，如reflexive、antisymmetric、transitive、partially-ordered。所有定义都出现在同一上下文下(S : ∗, R : (S×S)→∗)。因为这些性质（反身性、反对称性、传递性、偏序性）都是命题，所以它们类型是 ∗。

**Figure 8.2:**

```css
(a) S : ∗
(b) R : (S × S) → ∗
(1) reflexive(S, R) := ∀x∈S(R(x, x)) : ∗
(2) antisymmetric(S, R) := ∀x,y∈S((R(x, y) ∧ R(y, x)) ⇒ x = y) : ∗
(3) transitive(S, R) := ∀x,y,z∈S((R(x, y) ∧ R(y, z)) ⇒ R(x, z)) : ∗
(4) partially-ordered(S, R) :=
reflexive(S, R) ∧ (antisymmetric(S, R) ∧ transitive(S, R)) : ∗
```

**“At the end of this book, we append an Index of definitions.”**这说明书后会有定义索引，方便检索。

**“There are many instances of the list (S, R) in this figure…”**在 (1)到(4)中多处出现 (S,R)。

- 在定义的左边 (S,R) 是参数列表（就是说 reflexive、antisymmetric、transitive、partially-ordered 定义依赖于 S,R）。
- 在 partially-ordered 的定义中，用到 reflexive(S,R)等，这里 (S,R) 是实例化过程中的参数替换（不过这里是平凡的实例：S替S，R替R）。
**“All variables S and R in (1) to (4) are bound variables…”**由于使用flag标记，这些变量都是被上下文绑定的变量。当我们写 S,R 在定义中时，其实是使用了前面 (a) (b) 中声明的S,R。

**“An important observation is that the flag notation involves an inherent ‘overloading’…”**旗标格式下会有多个定义共享同一对上下文变量S,R。有点像overloading。但这是形式化表示的简化手法。若想更精确且严格区分不同定义中的上下文绑定，可以给上下文变量加不同的下标（S1,R1; S2,R2;...）。作者展示了在严格无重名的情况下，每个定义都可以单独写出上下文和定义，以避免overloading。

如下：
(i) reflexive的正式版本：

```css
S1 : ∗, R1 : (S1×S1)→∗  reflexive(S1,R1) := ∀x1∈S1 R1(x1,x1) : ∗
```

(ii) antisymmetric类似，用 S2,R2 等。(iii) transitive用 S3,R3,...(iv) partially-ordered用 S4,R4,...通过这种方式，每个定义各自用不同的上下文变量名，避免了同名overloading。

**“An important thing that we can learn from this example is that definitions often depend on other definitions.”**partially-ordered(S,R)的定义用到了 reflexive, antisymmetric, transitive，因此定义有顺序依赖关系。你可以先定义 reflexive, antisymmetric, transitive 后再定义 partially-ordered，否则 partially-ordered 会找不到它用的定义。

### 8.6 Definitions depending on assumptions

**“In the previous sections, we have encountered definitions depending on a context.”**之前的上下文中，定义依赖于集合 S、函数 f、关系 R 等等。这些上下文变量都代表了一些对象或类型。

**“Another frequently occurring case is that such a context contains one or more assumptions.”**有时上下文不仅包含对象，也包含命题假设。例如，在定义“minimal element（极小元）”时，需要假设关系 R 已知为部分有序（partially-ordered）。

**例子：**“Let S be a set, partially ordered by a relation R. An element m of S is called a minimal element if ...”这里要定义 minimal-element，需要假设 u: partially-ordered(S,R)。

**“This definition of ‘minimal element’ presupposes that we have a relation R that is partially ordered.”**即在上下文中不仅有 S, R，而且还有 u: partially-ordered(S,R) 作为假设条件。

**“We can extend the figure with a new definition: see Figure 8.3, line (5).”**加入新的定义 minimal-element：

```scss
(c) u : partially-ordered(S, R)
(d) m : S
(5) minimal-element(S, R, u, m) := ∀x∈S(R(x, m) ⇒ x = m) : ∗
```

在上下文中，现在有 S, R, u, m。u 是关于 S,R 的命题假设（S,R形成偏序），m是S中元素。在此基础上定义 minimal-element。

**“This new definition is a flag version of the definition:
S : ∗, R : (S×S)→∗, u : partially-ordered(S,R), m : S 
minimal-element(S,R,u,m) := ∀x∈S(R(x,m)⇒x=m) : ∗.”**换句话说，与之前一样，我们可将定义写为正式的上下文加定义的形式，使用 ‘’ 分割上下文和定义式。

这个例子表明定义不仅可以依赖上下文中的对象（如 S,R），还可以依赖上下文中的假设（命题 u：partially-ordered(S,R)）。这种定义在数学中很常见，如定义极小元、极大元、上界、下界等概念时通常需要某些结构已满足特定性质。

**总结（这段内容总体讲了什么）**：

在第8.5节，作者给出了定义在类型理论中的正式格式：

```yaml
x : A  a(x) := M : N
```

表示在上下文 x : A 下，将 a(x) 定义为 M，并且 M 的类型为 N。参数列表 a(x) 中的 x 就是上下文中的变量，用来表示定义依赖的对象或参数。作者通过实例（定义reflexive、antisymmetric、transitive、partially-ordered）展示了如何使用这种格式，并强调定义之间的相互依赖性需要正确的顺序。

在第8.6节，作者指出在上下文中不仅可以有对象（如S,R）还可以有假设条件（如u: partially-ordered(S,R)），从而定义那些需要先决条件的概念，如minimal-element。这意味着定义可以建立在已有定义和假设基础之上，在上下文中不仅包含数据（对象、类型）还包含条件（命题）的成立，从而为更复杂的数学结构和属性的定义提供灵活性。

总而言之，这些内容说明了如何在类型论中正式处理定义的语法和语义：定义有上下文、有参数列表、有类型信息，并且可依赖其他定义和假设。这为在类型理论中引入实用的数学与逻辑定义，进而实现更复杂的数学结构的形式化奠定了基础。
  
 Thought for a second
**概览（这段内容讲了什么）：**本节（8.7节和8.8节）介绍了在类型理论的框架下给**证明（proofs）**命名和定义的必要性和机制。此前，我们已经看到如何为集合、对象、命题这三类实体给出定义。本节指出，还有一类需要定义的“对象”——证明本身（即对某个命题的证明项）。给证明命名可以让我们在后续使用中轻易地实例化和引用该定理的证明，从而快速得到特定情形下的证明。作者以著名的Bézout引理为例，展示了如何在一般定理的基础上，通过参数实例化来得到特定数值下的专门版本的证明。

随后（8.8节）作者展示了通用定理的证明和特定数值实例的证明对比如何相似，并强调给证明命名并进行实例化所带来的优越性。无需重复整篇证明，只需替换参数即可得到特定实例的证明。

**逐段详解：**

### 8.7 Giving names to proofs

**“With the formal machinery described up to here, we can already express a wide range of definitions…”**到目前为止，我们已能给出许多类型的定义（集合、对象、命题的定义），但还缺一种定义形式：为证明的定义。也就是说，将一个对某个命题的证明赋予一个名称，好让我们以后引用。

**Notation 8.7.1**这里再次提及记号 ∗ 既用来表示类型层级（如集合类型）、也用来表示命题类型。为了区分概念，有时在解释层面我们写 `∗_s` 表示集合层级类型，`∗_p` 表示命题层级类型，但这是解释性的标签，不在正式系统中存在。在正式系统中仍然只有 `∗`。

**“With this notation…”**作者举例区分不同定义类型：

- 定义的集合（如rectangle和D(n)）类型为 ∗_s （解释性区分）。
- 定义的对象（如 c: R）类型是某个集合类型R。
- 定义的命题（如 increasing(f), total(S,R)）类型为 ∗_p。
图8.4展示三种定义类型的示意：

- (sets) Γ₁  A(...) := E₁ : ∗_s
- (objects) Γ₂  a(...) := E₂ : S （其中 S:∗_s）
- (propositions) Γ₃  B(...) := E₃ : ∗_p
**“It is obvious that there is one line missing in Figure 8.4…”**还有一种定义需要加入：定义一个证明给定命题P的证明项，即 (proofs)

```less
(proofs) Γ₄  b(...) := E₄ : P    with P : ∗_p
```

这里 b(...) 给一个证明起名。E₄ 是证明项，对命题P的证明。

**“This is the kind of definition which gives a name… to a proof E₄ of a proposition P.”**我们需要这种定义，因为在数学中经常会为定理（即命题的证明）起名字，以后在应用定理时只需调用这个名字即可。

**“Consider the following example from mathematics…”**作者给出 Bézout引理（Bézout’s Lemma）的数学例子：

**Bézout’s Lemma**：设 m, n 是正整数且互质（coprime），则存在整数 x,y 使得 m*x + n*y = 1。

形式化命题：

$$
\exists x,y \in \mathbb{Z}(m x + n y = 1)
$$

上下文包括：

- $m:N^+$ （正整数）
- $n:N^+$
- $u: coprime(m,n)$ （u是“m与n互质”这一命题的证明）
假设我们有该定理的正式证明项 `formalproof`，则 `formalproof` 是 `∃x,y:Z(mx+ny=1)`的证明。这样上下文下有：

```yaml
m : N+
n : N+
u : coprime(m,n)
formalproof : ∃x,y:Z(mx+ny=1)
```

**“An important aspect of such a theorem is that it can be applied…”**有了定理和证明，我们希望对特定实例应用此定理。例如将m=55, n=28且他们互质（假设有U为coprime(55,28)的证明），则此定理实例化后得

$$
∃x,y:Z(55x+28y=1)
$$

要得到这个实例对应的证明，我们可以将通用证明 `formalproof` 中的 [m:=55], [n:=28], [u:=U] 替换进去，从而得到特定案例的证明。

**Remark 8.7.3**再次提示 “:=” 符号的过载用法：既用于定义，又用于代换。上下文应能区分这两种情况。

**“All this can be realised very quickly … when we give a name to that proof…”**如果我们给通用证明命名，例如：

```yaml
m : N+, n : N+, u : coprime(m,n) 
p(m,n,u) := formalproof : ∃x,y:Z(mx+ny=1).
```

那么对于 (m=55, n=28, u=U) 我们直接写 p(55,28,U) 即可得到特定情况的证明项，而无需手动对 formalproof 进行替换。

**“Hence, it is worth while to also allow defined names for proofs…”**因此，为证明提供定义是有价值的，使得定理应用过程形式化而简洁。

### 8.8 A general proof and a specialised version

**“We have expressed a version of B´ezout’s Lemma in the previous section, but we did not prove it there…”**在上面，我们没有给出 formalproof 的具体推导，只是说明如果有 formalproof 就可以如何使用。现在作者给出一个传统的数学证明来说明 Bézout引理如何证明（见Figure 8.6）。

**Figure 8.6**该图给出Bézout引理的一般证明：

- 定义集合 S = {m x + n y | x,y ∈ Z}
- S⁺ = S中正数的集合，有最小正元素 d
- 通过欧几里得除法等操作显示 d 分别整除 m 和 n，由于 m,n 互质，因此 d=1，即1∈S
- 故存在 x,y 使得 mx+ny=1。
这个证明是经典的 Bézout引理的证明方法。

**“In the previous section we also claimed that p(55,28,U) represents a proof of B´ezout’s Lemma in the special case…”**作者接着指出，对于m=55,n=28的特例，可以重复同样的证明步骤，只是将一般情况中的 m,n 替换为 55,28。这就形成了 Figure 8.7中给出的特例证明。

**Figure 8.7**给出 Bézout引理在特定情况下（m=55,n=28）的专门证明：

和一般证明相比，唯一不同是将 m 和 n 替换为 55 和 28，证明结构完全相同。

**“A proof as in Figure 8.7 is not something one easily encounters…”**在数学中，我们通常不单独写出这样专门化的重复证明，因为很冗长又无新意。但是这个例子体现了实例化定理证明的原理。

**“It is important to realise that both proofs may be read independently…”**独立阅读两个证明（通用证明和特定证明）也能独立理解它们的正确性，但作为数学家，我们通常先接受通用定理，然后通过参数实例化快速得到特例的成立，而不必重写整个证明。

**“This proof specialisation works properly, but is very cumbersome…”**手动把通用证明的所有 m,n,u 替换成 55,28,U 很麻烦。这是为什么命名定理的证明并在需要时通过参数实例化来得到特例是如此便利。

**Remark 8.8.1**作者提到，对特殊例子（m=55,n=28）还有更短的直接证明方式（例如随手找出合适的x,y），但这与本书主旨无关。作者想表达的是，用实例化通用证明的方式是可行的并且在形式化系统中是自然的。

**总结（这段内容总体讲了什么）**：

在8.7节，作者指出在类型理论中，不仅可以定义集合、对象、和命题，还可为**证明**本身定义名称。这使我们能够方便地在后续推理中调用和实例化该证明，用它来为特定参数下的命题提供证明。这对数学中常见的过程（将一般定理应用于特殊情况）非常有用。

在8.8节，作者以 Bézout引理为例，展示了通用定理的证明与其特定实例的证明如何对应。虽然可以独立写出一个特定实例的证明，但这既冗长又无新内容。通过给定理的证明命名，然后在需要时仅更换参数，我们可以轻松获得特定实例的证明。从而阐明了为证明定义名称的重要性。

最终结论是：在 λC 扩展系统中（后称 λD），我们会将这四类定义（集合、对象、命题、证明）全部纳入，让类型理论能自然地表达与使用定理和证明。
  
 Thought for a couple of seconds
**概览（这段内容讲了什么）**：本段内容来自《Type Theory and Formal Proof An Introduction》第8章的第9至11节。这些内容集中讨论了如下几点：

1. **数学断言以正式定义形式呈现（8.9节）**：将数学陈述（比如命题与证明）从 λC 系统的判断格式转化为定义格式的想法。通过这种转化，一切数学内容都可以被表示为一个有序的定义列表。这使得在类型理论环境中，不仅命题、集合、对象能够定义为常量，连证明（定理的证明）也可以被给与名字，成为可实例化的“定义”。这种统一的定义格式让我们能够在形式化数学文本中只有定义这一种基本构造。这样，在需要调用定理时，通过参数实例化那个给出该定理证明的定义名即可轻松获得所需的特例证明。
2. **结论（8.10节）**：对本章工作进行总结。作者强调定义在数学和逻辑形式化中不可或缺，并指出在不考虑归纳和递归定义的情况下，也能通过更简单的定义机制为数学构造奠定基础。定义不仅能帮助组织数学内容，也能让复杂论述易于处理和检查。
3. **参考读物与扩展（8.11节）**：讨论了定义在形式逻辑和哲学语义中的地位。在传统逻辑文本中，定义常作为元语言中的缩写使用，而非系统本身的组成部分。作者提到将定义形式化进入类型理论（如 λC）是有益的，使系统能够对定义的正确性和使用进行严格控制。作者还引用了一些研究如Severi & Poll(1994)的工作，以阐释其他处理定义的方法，并提及在 Automath 项目中对定义的特殊处理方式。
总之，这些段落说明了定义在形式化数学中的关键作用：通过给陈述（命题、定理）和证明命名为定义，可以将整个数学文本编织成一系列定义的有序列表。继而，依赖参数实例化和定义展开，使得应用定理、推出特例的过程在类型理论系统中直接而自然地实现。

**逐段详解**：

### 8.9 Mathematical statements as formal definitions

**“In Section 8.7 we have seen that giving names to proof objects can be useful…”**作者回顾8.7节的内容：为证明对象命名是有用的。现在作者进一步指出，这种想法对数学断言本身也有意义。

**“But this also has consequences for our formalisation of mathematical statements…”**在 λC 系统中，一个数学陈述通常以判断形式呈现：

$$
Γ ⊢ M : N
$$

但实际上，每个判断也可用定义格式来表示：
Γ  a(...) := M : N
也就是说，可以把“从 Γ 推出 M : N”这件事实例化为“在 Γ 中定义 a(...) := M，类型为 N”，这样陈述和定义的区别消失，或者说陈述可以被视为特殊的定义。

**“This small transformation… the only complication is then that in every statement the term M must be preceded by a constant and parameter list, a(...).”**如此转化后，每个陈述需要一个常量名 a(...)，以便表达为定义形式：“Γ  a(...) := M : N”。虽然有点不方便（本来判断只写 M:N，现在还得有 a(...)），但代价很小。

**“But this small inconvenience causes great profit…”**代价很小却好处很大：若 M 是一个证明项（对 N 的证明），则给它起名 a(...) 便于以后轻松实例化这个证明从而应用定理。之前在8.7和8.8节，我们用 Bézout引理来说明这一点。

**“In order to show how this transformation works, we give an example…”**作者举一个数学文本例子，将其中定义和命题都统一成定义格式。原文本（非形式化）描述了total、inverse、identity relation等定义和相关命题：

- 定义“total”关系
- 定义关系的逆“inverse”
- 声明：若 R 是total，则 inverse(R)也是total
- 定义“Id(S)”为恒等关系
- 声明：若 S 有多个元素则 Id(S)不是total
- 声明：≤在 R 上是 total 关系的例子
**“Below we represent all these as formal definitions…”**接下来作者用旗标（flag）格式加上定义形式展示：

```css
(a) S : ∗s
(b) R : (S × S) → ∗p
(1) total(S, R) := ∀ x, y : S . (R(x,y) ∨ R(y,x)) : ∗p
(2) inverse(S, R) := λ(x, y) : (S×S). R(y,x) : (S×S)→∗p
(3) p1(S, R) := open-term 1 : total(S,R) ⇒ total(S, inverse(S,R))
(4) Id(S) := λ(x,y):(S×S). x=y : (S×S)→∗p
(5) p2(S) := open-term 2 : (|S| ≥ 2) ⇒ ¬(total(S,Id(S)))
(6) p3 := open-term 3 : total(R, ≤)
```

解释：

- (1)、(2)、(4)是定义“total”、“inverse”、“Id(S)”这三个概念的定义。本质上是定义名字为 total, inverse, Id 的常量，它们取参数 (S,R) 或 (S)等，返回相应命题或关系。
- (3)、(5)、(6)则是给出命题的“定义”形式，其中 right-hand side 是个open-term i表示尚未给出的证明项。p1、p2、p3 是用来表示未完成的定理证明定义名。例如 p1(S,R)对应“total(S,R)⇒total(S,inverse(S,R))”的证明，但目前没给出真正证明项，用open-term替代。
这样整篇数学描述都转化为定义列表，每个定义是：
\Gamma  a(...) := M : N
**“This example shows that the formal definition format… very powerful.”**通过这个例子，作者指出定义格式非常强大：

- 所有数学断言（定义和定理）均可转化为定义。
- 形式化数学文本即可视为一串定义的有序列表。这在后续章节将大有用处。
**“But we still have to find out what the notion ‘well-formedness’ means for definitions…”**接下来要考虑定义的形式正确性，即定义何时是“良构”的。下一章节（9、10章）将处理这个问题。

### 8.10 Conclusions

**“In the previous chapters there has hardly been any need for definitions…”**作者回顾前面章节中定义不多。虽然有些地方用过定义，如在7.3.1中定义了 ⇔，以及用于 ¬A，⊥ 的缩写。

**“When formalising more substantial parts of logic and mathematics, we cannot do without definitions.”**随着要形式化更复杂的逻辑和数学内容，定义变得不可或缺。

**“We have become acquainted with definitions, their nature and their usage…”**本章让我们熟悉了定义的性质和用法。定义帮助我们为有用概念命名，简化复杂表达，使逻辑和数学论述可控。

**“We do not consider inductive and recursive definitions…”**本书不处理归纳和递归定义，以保持系统简洁。这样做避免了检查每个归纳定义的良构性的问题。

**“We have introduced a general format for definitions:
Γ  a(...) := M : N”**总结这章的主要成果：定义的基本形式和概念。参数列表、上下文、类型N、定义体M和被定义名a(...)构成了定义的核心。

**“Using a definition amounts to calling upon the defined constant a… substitution and typing conditions…”**使用定义时需小心参数实例化和类型检查。

**“We have observed that it is natural to also use a definition for identifying a proof…”**定义不只用于定义对象和命题，还可用于为证明命名（定理的证明项）。

**“It is interesting to see that also statements… fit in the general format for definitions…”**命题判断也能转成定义格式，从而实现“统一格式”来表达数学文本。

**“Now that we have investigated the pragmatic aspects of definitions… next two chapters.”**后续章节将为定义增加正式推导规则（derivation rules），把定义机制融入 λC系统形成 λD系统。

### 8.11 Further reading

**“As we have seen in this chapter, definitions are everywhere in mathematics…”**定义在数学中随处可见，但在传统逻辑中，定义多是元语言层面的缩写。很少有逻辑系统为定义本身提供正式规则。通常定义被视为简单的省略写法，不提供解开定义（unfolding）的正式规则。

**“For further reading… see Gupta(2014) in Stanford Encyclopedia of Philosophy and Russell(1905)…”**在语言学和哲学层面，定义已被深入研究。

- 哲学中对定义的研究可参考 Stanford Encyclopedia of Philosophy。
- Russell(1905)的论文《On Denoting》是相关讨论的起点。
**“When implementing a system as a proof assistant, definitions are indispensable…”**在证明助手中，定义是必备的。

- unfold定义会使公式膨胀，所以证明助手会谨慎对待定义展开。
- 尽管 proof assistant 中有定义机制，但通常不会以演算规则方式呈现。
**“The first study of definitions in λC was by Severi & Poll(1994)…”**Severi & Poll的研究介绍了定义规则，但他们的定义更受限（无参数化定义），且允许局部定义（local definitions）。他们的方式要求用 λ 抽象来表示参数，从而将 total(S,R)之类的定义转化为无参数定义的形式：

```css
Total := λS:∗_s. λR:S→S→∗_p. ∀x,y:S(R(x,y)∨R(y,x)).
```

这样与本书的方式不同，但本书的方法更自然地支持参数列表。

**“It should be noted that this method of replacing parameters by λ-abstractions only works…”**这种将参数转 λ 抽象的方法需要系统支持相应的抽象权限。

**“On the other hand, definitions by Severi & Poll(1994) are more general…”**他们允许局部定义，在上下文任意位置插入 c := t : A，并允许嵌套定义的出现。这些局部定义可在 proof 内部限定作用域。

**“We see such a definition in the proof about the gcd in Figure 8.6…”**图8.6中有 S, S+ 这类在证明中出现的局部名词如果严格要求，它们也可以当作局部定义对待。

**“In systems with global and local variables… local definitions…”**对于本书而言，局部定义并非必要，因为本书的方法足以处理复杂情况且可以将局部定义模拟为全局定义（通过提前定义）。

**“In the Automath project… a definition is sometimes formalised via a β-redex…”**Automath 将定义转化为 β-化简。当有 c := t : A in M，相当于 (λc:A.M)t 的 β-化简形式，这可实现定义的展开和还原。这使定义展开变成一般的 β-化简问题。

**总结（这段内容总体讲了什么）**：

在8.9节中，作者提出一个统一的方法：将每个数学陈述（不管是定义还是定理声明）都表示为一个有参数的定义 `Γ  a(...) := M : N`。这样，断言与定义的区分消失，每件事都能通过定义格式呈现。这对于证明（定理证明项）尤为有利，因为给证明命名允许我们轻松地实例化定理，从通用命题的证明快速得出具体实例的证明。

在8.10节中，作者对本章的工作进行了总结。定义在数学和逻辑形式化中不可或缺。我们不处理归纳、递归定义，但仍有足够的定义工具用于真实世界的数学和逻辑。定义使表达更简单可控，并最终在 λD（后续章节介绍）中正式引入定义规则。

在8.11节中，作者提供了更多参考与扩展阅读方向。在传统逻辑中定义常被作为元语言缩写处理，而本书的方向是将定义严格形式化在类型理论中。哲学和语言学中也对定义问题有广泛讨论。Severi & Poll(1994)及Automath为定义在 λC 或相关类型理论中的处理提供了历史与技术背景。

通过这些讨论，本章为后续正式加入定义机制到 λC（成为 λD）打下基础，让统一定义格式和严格类型检查得以实现，助力真正意义上的数学和逻辑的完全形式化表达。
  
 Thought for a second
**概览（这段内容讲了什么）**：本段内容来自第9章的开头部分（9.1至9.3节），介绍了在 λC（Calculus of Constructions）系统中**加入定义（definitions）**的扩展过程，以构造出新的系统 λD0。作者首先回顾了为什么选择 λC 作为扩展基础，然后定义了 λD0 的表达式集合 EλD。接着讨论了如何在已有的类型判定系统（λC的判断式）中加入定义（描述性的定义），使得判定中可以有定义的环境 Δ。此外，还介绍了新的推导规则以支持定义的引入和使用，并重点说明了一个新的推导规则(def)——用于将定义加入环境Δ。

通过这些内容，读者能够了解在类型理论中正式引入定义的基本技术：引入新的环境Δ存放定义列表，让判断可以带着定义来工作。并初步探讨了加入定义后需要的新规则，以及未来会如何构建最终的 λD0 系统。

**逐段详解**：

### 9.1 Extension of λC to the system λD0

**本节要点**：

- λC是λ立方体中最强大的系统之一，已足够表达PAT解释的需求并能编码大部分数学推理。
- 现在要在 λC 上扩展定义机制，构造 λD0。
- λD0 中将有形式化的定义机制（称为描述性定义，不包括递归与归纳定义），这已足够应对大量逻辑与数学应用。
- 下一章会在 λD0 基础上再扩展，以允许更复杂的公理与假设，形成最终的 λD 系统。
接下来要正式定义 λD0 的表达式集合 EλD。

**EλD的定义**：在 λC 的表达式集合基础上，现在还允许使用常量（从集合 C 中取）。这样表达式为：
E_{\lambda D} = V |  | ∗ | (E_{\lambda D} E_{\lambda D}) | (λV : E_{\lambda D}. E_{\lambda D}) | (ΠV : E_{\lambda D}. E_{\lambda D}) | C(E_{\lambda D})
对比 λC，最大的不同是增加了 C(EλD) 形式，即可以有常量 C ，并且后面带参数列表(…)，构成新的表达式。

**Definition 9.1.2（描述性定义与环境）**：

- 一个描述性定义形如：
x:A  a(x) := M : N
这里 x:A 是上下文，a 是定义的常量名，x 是参数列表，M : N 是定义的主体与类型。
- 定义列表（环境）Δ是有限序列的定义，可空。
**Definition 9.1.3（定义的元素）**：给出一个定义 D = x:A  a(x):= M:N，它包含上下文 x:A、被定义常量 a 、定义体 M 和类型 N。

### 9.2 Judgements extended with definitions

**本节要点**：

- 在 λC 中，基本判断是 Γ ⊢ M:N。
- 在 λD0 中有定义列表 Δ 存在，每个判断扩展成带定义的判断：
Δ; Γ  M : N
读作：在环境 Δ 和上下文 Γ 下，M 的类型为 N。
**新增的复杂性**：

- M、N、Γ中的类型与项可能使用 Δ 中的被定义常量。
- Δ 包含定义 D1,…,Dk，这些定义可能相互依赖，也可能被 Γ 与 M : N 使用。
**如何适应 λC 的规则？**

- λC 的推导规则都是关于 Γ ⊢ M:N 的，现在都要改成 Δ; Γ  M:N 的形式。
- 同时必须加入新规则处理定义的引入与使用。
- 另外，conv（转换）规则也需修正。
下一节将介绍新的规则 (def) 与 (inst)。

### 9.3 The rule for adding a definition

**本节要点**：

- 首先介绍 (def) 规则，用于将新的定义 D 添加到环境 Δ 中。
- 假设已有 Δ; Γ  K : L 为正确判断（即 Δ,Γ 构成正确环境与上下文，K:L是可判定类型的项），现在想添加新定义 D 到 Δ，得到 Δ,D; Γ  K:L。
- 新定义 D = x:A  a(x):= M:N 必须是良构的，即在 Δ; x:A 下可以判断 M:N 成立。
- 且要求 a 在 Δ 中是全新常量，避免重复定义。
综上，(def) 规则类似为：

```less
(def)
Δ; Γ  K : L
Δ; x:A  M:N
---------------------------------
Δ, (x:A  a(x):=M:N); Γ  K : L
```

该规则说明：如果原本在 Δ;Γ 下有 K:L，现在我们加入定义 D（需要检查 D 本身的良构性：Δ;x:A  M:N），就获得扩展后的环境 Δ,D 下仍可推导 K:L。

这样 (def) 规则确保增加定义不会破坏已有判断的正确性，并维护定义的正确性。

**总结（这段内容总体讲了什么）**：第9章开头部分（9.1-9.3节）介绍了在 λC 中加入定义以构造 λD0 的基础步骤。首先定义了 λD0 的表达式系统 EλD，然后将判断扩展为 Δ; Γ  M:N 的形式，使得判断可依赖一个定义环境 Δ。接着介绍了 (def) 规则，用于在环境 Δ 上新增一个新的定义，该定义本身必须在 Δ,x:A 下是良构的 (M:N可判定)，并且被定义的常量 a 是新鲜的（未在 Δ 中出现过）。

这一过程为之后的章节引入定义的完整规则和对 axioms、axiomatic notions 的扩展（形成 λD 系统）打下了基础。通过这种形式化的定义引入，我们实现了一个有序的、受控的方式将定义嵌入到类型推断中，使 λC 系统更有表达能力，以匹配实际数学中定义与应用的方式。
  
 Thought for a second
**概览（这段内容讲了什么）**：这部分内容（第9.4节）讨论了在已经扩展出允许定义(environment中的定义)的系统中，**如何使用(inst)规则对定义进行实例化**。在前面我们介绍了(def)规则来将定义加入到环境Δ中，现在本节重点介绍了，当我们在环境Δ中已经有一个定义D（比如 `x:A  a(x) := M : N`）时，如何通过给参数列表(x1,...,xn)提供合适的表达式(U1,...,Un)来实例化`a(x)`为`a(U)`。本节详细分析了实例化参数列表时的类型约束条件，并最终得到了(inst)规则的形式。该规则保证在给定环境Δ和上下文Γ下，只要为定义的参数选择适当类型的实例表达式，就能在推导中引入 `a(U)` 并得到相应的类型 `N[x:=U]`。

另外，对于无参数定义的情形（参数列表为空），需要一个额外的条件（例如 Δ; Γ  ∗ : ），以确保上下文和环境的正确性。最终将有参与无参定义的实例化规则统一成一个 (inst) 规则。

**逐段详解**：

1. **引入实例化问题**：在先前的章节，介绍了在环境Δ中增加定义的方法(使用(def)规则)。现在则考虑如何在推导中使用这些定义。使用定义的关键在于对定义中的参数列表进行适当的实例化。一个定义通常形如：
x_1:A_1,\dots,x_n:A_n  a(x_1,\dots,x_n) := M : N.这里 $(x_1,...,x_n)$ 是参数列表，$A_i$是这些参数的类型，$M$是定义体（definiens），$N$是定义的类型。我们希望用特定的表达式 $(U_1,...,U_n)$ 来代换 $(x_1,...,x_n)$，从而得到新表达式 $a(U_1,...,U_n)$。
2. **实例化参数列表的要求**：如果要实例化参数列表 $(x_1,...,x_n)$ 为 $(U_1,...,U_n)$，需要确保类型匹配。首先看 $U_1$：
- $U_1$的类型必须是 $A_1$。接着看 $U_2$：
- 这里不能简单地说 $U_2 : A_2$ 因为 $A_2$中可能含有$x_1$。实例化 $(x_1 := U_1)$ 后，$A_2$应当替换$x_1$为$U_1$，即 $U_2$ 的类型应为 $A_2[x_1 := U_1]$。对 $U_3$：
- 同理，$U_3$的类型需为 $A_3[x_1 := U_1, x_2 := U_2]$。一般规律是：
$U_i : A_i[x_1 := U_1, \dots, x_{i-1} := U_{i-1}].$这保证了在处理第i个参数时，其类型约束条件已将前面参数的实例化考虑进去。
3. **简化描述及同时替换**：虽然严格来说每一步都是在 A_i 中对前面所有参数做替换，但由于参数列表 $(x_1,\dots,x_n)$在定义中是各自独立且按次序出现，我们可以将替换统一表示为一次同时替换 [x:=U] ，表示 [x_1 := U_1,...,x_n := U_n]。考虑到在定义中 $x_1,\dots,x_n$是新引入的上下文变量，不会在 $U_j$中出现（因为 $U_j$属于外部已给定的表达式，不依赖定义内部的新变量），因此同时替换和逐步替换效果一样。最终，我们将约束写成：
$U_i : A_i[x := U]$
对所有 $1 \le i \le n$。
4. **达成条件后的类型推断**：如果 $(U_1,...,U_n)$ 满足上面条件，即对每个 i 有 $\Delta; Γ  U_i : A_i[x:=U]$，那么就能在推导中使用定义 $a(x)$ 实例化为 $a(U)$。使用后，我们需要确定 $a(U)$的类型是什么。因为 $a(x)$ 的类型是 $N$，且 $N$ 中也可能含有 $x_i$，在实例化后，我们应将 $N$ 中的 $x_i$ 同样用对应的 $U_i$ 替换，即类型变为 $N[x:=U]$。因此得到：
Δ; Γ  a(U): N[x:=U].
5. **(inst)规则基本形式**：将这些内容综合，我们得到一个(inst)规则的雏形：\frac{Δ; Γ  U_i : A_i[x:=U]\text{ for all i, and possibly something else}}{Δ; Γ  a(U) : N[x:=U]}也就是说，要使用定义$a(x)$并用$U$实例化$x$，前提是要在 $Δ;Γ$ 下检查每个 $U_i$的类型匹配要求。
6. **处理空参数列表的特殊情况**：若定义 $a$ 没有参数列表，即 $n=0$，则无须替换和检查参数类型。然而，如果没有任何前提，就可以在 $Δ;Γ$ 下随意推出 $a() : N$，这可能导致不合适的推导。例如，如果定义中不要求任何条件，就可在任意上下文下引入 $a() : N$，这是不期望的。为解决这一点，本节提出，当参数列表为空时，需增加一个前提保证 $Δ;Γ$ 的正确性和良构性。一个简单的方法是要求：Δ; Γ  ∗ : 因为 $∗ : $ 是最基本可判定的陈述之一，能派上用场来确保 $Δ;Γ$ 的正确性（无论何时，如果能够推导出 $∗ : $，说明 $Δ;Γ$是良构的）。有了这一前提，当 $a$ 无参时，我们有：
(inst-zero)\quad \frac{Δ;Γ  ∗ : }{Δ; Γ  a() : N}
7. **将有参与无参两种情况统一**：最终将两种情况合并。对于有参情况，我们本来就有 $Δ; Γ  U : A[x:=U]$作为前提，它本身可以确保 $Δ;Γ$的良构性。对于无参情况，我们单独增加了 $Δ; Γ  ∗ : $ 作为前提来保证。因此统一的(inst)规则为：
(inst)\quad \frac{Δ; Γ  ∗ :  \quad Δ; Γ  U : A[x:=U]}{Δ; Γ  a(U):N[x:=U]}当参数列表为空时，$U$和 $A[x:=U]$是空列表，即无参时$(inst)$只剩下 $Δ; Γ  ∗ : $ 这个前提，对应之前的(inst-zero)规则。而有参时 $Δ; Γ  U : A[x:=U]$就是多个前提，包含类型检查，这些前提也会隐含 $Δ;Γ$是正确的，因此 $Δ; Γ  ∗ : $ 前提虽然存在，但与其他前提一起并不会增加额外的负担。简而言之，(inst)规则统一了有参和无参的定义实例化过程。
8. **关于递归定义的说明**：本节末尾提到，这里讨论的定义实例化不涉及递归定义的问题。递归定义将导致 $a$在 $M$或$N$中自身出现，引发更复杂的情况（本书中并没有考虑递归定义）。
**总结（这段内容总体讲了什么）**：本节（9.4节）主要讨论在λD0系统中使用(inst)规则实例化定义的方法。当有定义x:A  a(x):=M:N存在于环境Δ中时，为了从中得到 $a(U)$ 的正确类型，我们需要为每个参数 $x_i$提供合适的表达式 $U_i$，并确保类型匹配关系：
$U_i : A_i[x:=U]$

通过仔细分析类型替换与参数实例化的关系，本节得出了(inst)规则：

- 如果$a$有参数列表，那么在实例化前需检查 $U_i$ 的类型是否匹配经过替换后的 $A_i$。
- 如果$a$无参数列表，需要额外前提 $Δ;Γ  ∗:$ 来保证上下文与环境良构性。
最终(inst)规则统一了这两种情况。这让我们在类型理论中可以正式地从定义中得到实例化版本，从而在正式推导中使用已定义的定理、函数或命题，而无需在使用点重复复杂的检查，只要满足上述条件，即可在推导中引入 $a(U)$ 及其类型。
  
 Thought for a second
**概览（这段内容讲了什么）**：本节（9.5节）讨论了在加入定义的系统中如何处理定义项的“展开”（unfolding）与“折叠”（folding），并借此引入**δ-转换（δ-conversion）**的概念。之前我们已经有了通过定义（def）规则将定义加入环境、通过实例化（inst）规则使用定义。现在我们要进一步阐述定义如何与原表达式等价，即定义的被定义项a(x)应当等同于定义体M[x:=U]（当参数列表被U替换）。本节将定义这种等价性的基础机制：

- 首先介绍一阶的定义展开（δ-reduction）：如果有定义a(x):=M，则a(U)可被“展开”为M[x:=U]。
- 通过兼容性（compatibility）规则，允许在子表达式中进行定义展开。
- 从一阶展开扩展到多步展开和反向折叠，从而引入δ-转换（δ-conversion）：δ-转换使得由定义引入的表达式和其定义体互为可互换的等价项。
- 在有定义的环境下，这些δ-转换和β-转换类似，都可形成等价类，并可定义δ-正范式（δ-normal form），即当没有可展开的定义时的简化形式。
总结来说，本节为定义的等价性提供了一个类似于β-化简的转换关系 δ，使得定义项与其定义体在推导中可自由互换（通过展开或折叠）。这样，我们在后面就可以在转换规则（conv）中同时考虑β和δ转换，从而实现更强大的等式处理。

**逐段详解**：

1. **引入定义展开的动机**：在前面章节中，我们给出的规则(def)与(inst)允许加入定义、实例化定义。但还没有一个规则明确说明定义的“含义等价”如何在系统中体现。一个定义 `a(x):=M:N` 意义上是 a(x) 等价于 M[x:=U]（当实例化参数x为U时）。在数学中，我们期望 D(n) 在定义后就与其定义体（如正因子集合）等价。例如，`D(k)`就是 `{d ∈ N+ | d|k}`。同样，对于定义 `total(S,R) := ∀x,y∈S(R(x,y)∨R(y,x))`，`total(N,≤)`就应等价于 `∀x,y∈N(x≤y∨y≤x)`。如果没有一个机制将 a(U) 和 M[x:=U] 识别为同一事物，我们就无法从“证明了 ∀x,y(...）”得出“证明了 total(N,≤)”。所以需要一种与 β-转换类似的定义展开机制，称为 δ-转换（δ-conversion）。
2. **定义展开（δ-reduction）与 δ-conversion**：类似于β-约简：
- β-约简在 λ演算中通过对函数应用( (λx.M)N → M[x:=N] )实现表达式等价变换。
- 现在对定义而言，我们也想要相似的操作：a(U) → M[x:=U]，这称为定义展开（one-step δ-reduction）。这意味着只要环境Δ中有定义 `x:A  a(x):=M:N`，就可以在表达式中把 `a(U)` 替换为 `M[x:=U]`。这和β-化简类似，但这里展开的是定义的常量 a，而不是函数抽象 λ。
3. **定义展开的兼容性**：定义展开同样应具备在子表达式中进行的能力（类似β兼容性）。若 `M Δ→ M'` 表示在环境Δ下一步δ-约简，则：
- (M L) Δ→ (M' L)
- (L M) Δ→ (L M')
- (λx.M) Δ→ (λx.M')
- b(...,M,...) Δ→ b(...,M',...)这些是兼容性规则，使定义展开能发生在任意子表达式位置。
4. **备注关于记号**：使用 `Δ→` 表示一阶δ-约简，其实可以写成 `Δ→δ` 更清晰，但书中略了 δ。δ-reduction 指的是相对于环境Δ 的一阶约简步骤，意味着我们必须在当前Δ定义的上下文中才能展开 a(U)。
5. **从一阶约简到多阶约简、再到δ-转换**：与β-约简类似，我们将一阶δ-约简扩展为零或多步约简(Δ↠)和定义δ-转换(Δ=)。
- $M Δ↠ N$：表示 M 可以通过多步 δ-reduction 化简到 N。
- $M Δ= N$：表示 M 与 N 通过一系列δ-展开与折叠互相可达，是δ-可转换的。δ-转换是一个等价关系，可形成表达式的等价类。
6. **δ-正范式（δ-normal form）**：定义：
- 若在 M 中不存在可展开的常量（与定义匹配的 a(x)），则 M 是 δ-nf（δ正范式）。
- 如果 M 能通过 δ-转换化成δ-nf的某个表达式 L，则 M 被称为 δ-可规范化（δ-normalising），L即为M的δ-nf。这与 β-范式概念平行。我们希望通过δ-转换，使每个表达式能最终到达一个δ-nf（后面章节会证明δ范式存在且唯一）。
7. **例子**：书中给出一些例子来直观说明 δ-转换的作用。
- 首先假设在环境Δ中定义了 `a(x,y):= x² + y²`，`b(x,y):= 2·(x·y)`，`c(x,y):= a(x,y)+b(x,y)`，`lemma(x,y):= c(x,y) = (x+y)²`。
- 考虑表达式 `a(a(x,x), a(y,y))`：这里 `a(x,x)` 是可展开的，因为 a 已有定义。展开后可替换 `a(x,x)` 为 `x²+x²` 等等。通过反复展开，你会发现最终表达式可化为 `(x²+x²)²+(y²+y²)²`，没有剩余可展开的定义项（即 δ-nf）。
- 再看 `lemma(u,v)`：展开 `lemma(u,v)`首先 lemma(u,v) → c(u,v)=(u+v)²再展开 c(u,v) → a(u,v)+b(u,v)=(u+v)²继续展开 a(u,v)、b(u,v)，最终 lemma(u,v) 化为 (u²+v²)+2·(u·v)=(u+v)²。这些例子显示 δ-转换在简化表达式和使定义与定义体互相转换方面的实际应用。
**总结（这段内容讲解了什么）**：本节讲解了在有定义的类型系统（λD0）中，如何引入定义展开（δ-reduction）以及相应的δ-转换（δ-conversion）概念。通过 δ-reduction，我们可以将 `a(U)` 展开为 `M[x:=U]`，以实现被定义名与定义体的等价替换。这与 β-化简处理 λ抽象的过程类似，但 δ-转换是专门针对定义的。

在兼容性规则支持下，δ展开可以在任意子表达式中进行，进而定义了 δ-转换作为一个等价关系，使得表达式可以通过折叠/展开定义相互转换。我们还引入 δ-范式（当无剩余可展开的定义时的形式）作为 δ-转换的归宿。

本节为后续将 δ-转换融入系统中奠定基础。等到下一节（9.7节），将和 β-转换一起修改转换规则（conv）以考虑 δ-转换，从而在类型系统中自然地处理由定义引起的等价性。
  
 Thought for a second
**概览（这段内容讲了什么）**：本节（9.7和9.8节）介绍了如何在 λD0 系统中将定义引入的 δ-转换与原有的 β-转换相结合，并在最终的派生规则中体现出来。之前已建立了关于定义加入环境的(def)规则和定义实例化的(inst)规则，以及引入了δ-转换(δ-conversion)和β-转换(β-conversion)。现在作者将两种转换合并为βδ-转换(βδ-conversion)，并更新(conv)规则，使系统能够同时处理β与δ的等价性。最后以图9.3的形式给出 λD0 系统的全部推导规则，将定义与基本的 λC 系统结合起来，形成一个更完整、更灵活的类型系统。

**逐段详解**：

1. **扩展后的 Conversion 规则 (9.7节)**：在没有定义的 λC 系统中，有一个 (conv) 规则可以利用 β-转换 (=β) 来从 A:B 推导出 A:B' 当 B 与 B' 是 β-可转换的。引入定义后，我们有 δ-转换 (δ-conversion) 来体现定义的等价性。在 9.5 节中，已建立了 δ-转换 (Δ=) 的概念，即通过展开/折叠定义，使表达式在定义层面等价。现在我们希望能在 (conv) 规则中同时考虑 β-和 δ-转换。新的想法是：如果Δ; Γ  A : B且 $B Δ=β B'$（这里 Δ=β 表示既可用 β 转换也可用 δ 转换的等价关系），则也有Δ; Γ  A : B'。但是正如原来的 (conv) 规则一样，我们还需保证 B' 是良构的、有类型的，即需有 Δ; Γ  B : s 且 $B Δ=β B'$ 才能做转换。这样确保 B' 是良好类型的表达式，不会破坏系统的正确性。因此新的 (conv) 规则要求：
- Δ; Γ  A : B
- Δ; Γ  B : s （保证 B 可判定、合理）
- 若 $B Δ=β B'$则 Δ; Γ  A : B'。称之为(βδ-conv)规则。而后为简化，将其仍命名为 (conv)。
2. **β-约简在 λD0 中的兼容性 (Definition 9.7.1)**：这部分重申了 β-约简在 λD0 中的定义，与 λC 相比只是多了对带参数常量 a(U,M,V) 的兼容性，即 β-约简也可作用在参数列表中的子表达式上。具体来说，β-约简的一阶规则( (λx:K.M)N → M[x:=N] ) 不变，增加了兼容性条件，让 β-约简可作用于应用、抽象、Π类型和定义常量调用 a(U,M,V) 的内部表达式 M 上。如此，β-约简规则与 λC 保持一致，只是在新的上下文中也考虑带参数的常量。
3. **定义 βδ-转换 (Definition 9.7.2)**：βδ-转换是指既允许 β-变换（β-reduction / expansion）又允许 δ-变换（δ-reduction / expansion）的等价关系。即 M 与 N 若能通过一系列 β 或 δ 的展开与折叠步骤互相达到，则 M Δ=β N。这使系统更灵活：表达式的等价可由 β 与 δ 两种方式混合获得。例如，一个表达式可先用 δ-展开将定义化开，再用 β-约简对 λ 抽象化简，最后再 δ-折叠回另一定义形式，如果需要。
4. **最终 (conv) 规则 (Definition 9.7.3)**：将上述讨论浓缩到最终的 (conv) 规则：若 Δ; Γ  A : B 且 Δ; Γ  B : s 且 $B Δ=β B'$ 则 Δ; Γ  A : B'。这意味着类型检查中，如果 B 和 B' 是通过 β 和 δ 共同形成的等价，则可以将类型从 B 转换为 B'，完成类型的等价变换。
5. **λD0 派生规则总结 (9.8节)**：在图9.3中给出了 λD0 的完整推导规则集。与 λC 相比，多了以下变化：
- Judgement 格式从 Γ  M:N 扩展为 Δ; Γ  M:N，即环境 Δ 和上下文 Γ。
- 增加了 (def) 规则，在已知 Δ; Γ  K:L 和 Δ; x:A  M:N 的前提下，可以在 Δ 中添加定义 x:A  a(x):= M:N。
- 增加了 (inst) 规则，用于实例化定义 a(x) 为 a(U)，需要检查参数替换后类型匹配条件。
- (conv) 规则从单纯的 β-转换扩展为 βδ-转换，使定义展开和 λ 抽象简化两种转换方式皆可用来证明类型等价。其他规则 (var)、(weak)、(form)、(appl)、(abst)、(sort) 都基本与 λC 中相同，只是将判断扩展为 Δ; Γ 格式。对于 (sort) 规则，因为它相当于系统推导的起点，保持 Δ=∅ 和 Γ=∅，无特别修改。这样 λD0 就是 λC 的真正扩展版本，提供了定义机制和相应的等价转换规则，便于在复杂的数学形式化中方便使用定义和应用定理。
**总结（这段内容总体讲了什么）**：本部分将定义和 β-转换结合形成一个更强大的系统 λD0。在 9.7 节中，(conv) 规则被修改为考虑 δ-转换，使定义引入的等价性也能在类型变换中使用；加入 βδ-转换后系统更灵活。

在 9.8 节中，以表格形式（图9.3）展示了 λD0 的完整规则集。λD0 相当于 λC 的扩展版：

- Judgement 从 Γ 扩展为 Δ; Γ
- 新增(def)规则将定义加入环境
- 新增(inst)规则使用定义
- 将(conv)规则扩展为考虑 βδ-转换，从而实现由定义引入的等式与类型等价
最终，λD0 成为能同时处理函数抽象和定义展开的系统，在类型判断中天然支持定义和定理等式的引用与转换。
  
 Thought for a second
**概览（这段内容讲了什么）**：本节（9.9至9.11节）对已经构建的λD0系统的推导规则进行进一步审视和总结，并将前面讨论的思想与实践联系起来。9.9节首先更加深入地审查了λD0规则的相互关系和结构，指出(def)与(weak)的相似性、(var)与(inst)在角色上的隐性对应，以及(par)这个有用的派生规则的诞生。然后9.10节对整个章节作出总结：我们已经将定义(Definitions)引入λC扩展为λD0，并讨论了定义插入(def)、参数实例化(inst)、定义展开(δ-conversion)与合并β/δ转换的(conv)规则。最后9.11节参考文献部分谈到定义在类型理论与证明助手中的地位与历史背景。

通过本节，读者可以清楚地看到：

1. λD0系统中的规则有着精妙的对应关系，(weak)与(def)都为扩展上下文/环境的规则、(var)与(inst)分别为基本变量和已定义常量的类型赋予规则。
2. (par)是从已有规则推导而出的方便派生规则，免去重复推导。
3. 在整个 λD0 系统中，定义的概念已经获得严谨的形式化处理，既能在推导中添加定义，又能实例化和展开定义，从而使定义与类型推理自然结合。
**逐段详解**：

### 9.9 A closer look at the derivation rules of λD0

**深入观察(weak)与(def)的相似性**：

- (weak)规则用于在一个已成立的判断 Δ; Γ  A : B 的基础上，将上下文 Γ 扩展一行（添加 x : C），保持推导有效性不变。它在变量层面做弱化。
- (def)规则类似，用于在已成立判断 Δ; Γ  K : L 的基础上，将环境 Δ 扩展一行（添加 x : A  a(x) := M : N），保持判断有效性不变。它在定义层面做弱化。
(weak)与(def)的相似之处在于：

- 都是在已有合法推导的末尾增加一行声明/定义，从而扩大系统的知识面。
- (weak)是对上下文(variables and their types)的扩充，而(def)是对环境(定义列表)的扩充。
**(var)与(inst)规则的类比**：

- (var)规则：给出变量x在上下文中的类型A。条件是 x 是最后一条声明，以保证类型判定的一致性。它告诉我们如何从上下文末尾取得一个变量及其类型。
- (inst)规则：给出已定义常量 a(x) 的类型，当参数列表 x 用 U 实例化后可得到 a(U) 的类型 N[x:=U]，条件是U的类型匹配必须满足定义中给定的类型要求。
(var)与(inst)的对应：

- (var)为系统提供使用变量的方式，从上下文取得类型。
- (inst)为系统提供使用已定义常量的方式，从环境取得定义，再通过实参U满足类型要求后得到 a(U) 的类型。
这样，(var)与(inst)分别负责系统中两类基础构造（变量与定义常量）的类型赋予。

**关于(par)规则**：

- (var)规则可以视为告诉我们上下文最后一行 x:A 是派生出来的（上下文是良构的）。
- 对于定义 D ≡ x:A  a(x) := M:N，要想类似(var)规则那样“直接”得到 a(x):N，我们需要检查该定义是良构的，这在之前的规则中已隐含地可推导出来。
- 书中引入 (par) 作为一个派生规则(“多余但有用的简化”): 如果 Δ;x:A  M:N 已知，那么在将D加入环境后，我们立即有 Δ,D;x:A  a(x):N。这本质上只是从(def)与(conv)等规则推导得来的“快捷方式”。
(par)不是基本规则，而是从现有规则推导出来的，可在实际使用中提高方便性。

### 9.10 Conclusions

**本章总结**：

- 本章介绍了如何将描述性定义(Descriptive definitions)添加到 λC中，得到 λD0。
- 我们给出了增加定义(def)、参数实例化(inst)、定义展开(δ-conversion)的规则，以及将δ-conversion纳入(conv)规则，让定义的等价性与β-等价性共同作用，形成 βδ-转换(βδ-conversion)。
- 通过这种方式，所有的数学概念、断言、证明都可通过定义、参数列表和上下文无缝整合进系统，形式化地表达并验证。
- 引入定义和δ-转换使类型论更具表现力，更贴近“真实数学”中对定义的用法。
### 9.11 Further reading

**历史与参考**：

- N.G. de Bruijn最先将定义提升到形式系统内，而非只作为元语言工具，其Automath项目中定义机制很发达。
- 后续对于纯类型系统(PTS)的研究(如Kamareddine等人)将参数化定义引入其中。
- Coquand与Huet的 λC 最初并不包含正式定义机制，但实作的证明助手中却有这种功能，只是不正式化。
- 数学“书本”的累积方式与flag式自然演绎等概念都有相似之处。
- 本书使用的旗标格式与树状推导相互转换，也延续了之前章节的理念。
**总结（这段内容总体讲了什么）**：本节深入分析了 λD0 的推导规则，澄清各规则之间的相互关系和隐喻：(weak)与(def)都是“弱化”式的规则，一个用于扩展上下文，一个用于扩展定义环境；(var)与(inst)规则在分别处理基本变量与已定义常量的类型赋予方面具有对称意义。此外，定义允许我们通过(par)规则快速得到某些派生结论。

然后对全章进行总结，指出通过本章的构建，我们已经成功将描述性定义正式融入类型理论中（λC扩展为λD0），并引入 δ-转换与 β-转换的联合，使定义的展开/折叠具备与 β-转换同等地位的等价性处理能力。最后的参考讨论了定义在历史与其他类型理论系统中的位置。

通过这些讨论，读者可以清晰地了解到定义的引入在理论与实践层面如何统一，并为后续更广泛的数学形式化奠定基础。
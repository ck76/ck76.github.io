An Introduction to Functional Programming Through Lambda Calculus



### 目录 (Contents)

**Dover 版序言 (Preface to the Dover Edition)**  
**前言 (Preface)**  

**第一章: 介绍 (Chapter 1: Introduction)**  
1.1 编程中的名称和值 (Names and Values in Programming)  
1.2 在命令式和函数式语言中的名称和值 (Names and Values in Imperative and Functional Languages)  
1.3 在命令式和函数式语言中的执行顺序 (Execution Order in Imperative and Functional Languages)  
1.4 在命令式和函数式语言中的重复 (Repetition in Imperative and Functional Languages)  
1.5 函数式语言中的数据结构 (Data Structures in Functional Languages)  
1.6 将函数视为值 (Functions as Values)  
1.7 函数式语言的起源 (The Origins of Functional Languages)  
1.8 计算和计算理论 (Computing and the Theory of Computing)  
1.9 一种微积分 (A Calculus)  
**总结 (Summary)**  

**第二章: 微积分 (Chapter 2: A Calculus)**  
2.1 抽象 (Abstraction)  
2.2 编程语言中的抽象 (Abstraction in Programming Languages)  
2.3 介绍 λ 微积分 (Introducing Lambda Calculus)  
2.4 λ 表达式 (Lambda Expressions)  
2.5 简单的 λ 函数 (Simple Lambda Functions)  
2.6 引入新语法 (Introducing New Syntax)  
2.7 函数命名的符号和 β 约简 (Notations for Naming Functions and Beta Reduction)  
2.8 从函数中得到的函数 (Functions from Functions)  
2.9 参数选择和参数配对函数 (Argument Selection and Argument Pairing Functions)  
2.10 自由变量和绑定变量 (Free and Bound Variables)  
2.11 名称冲突和 α 转换 (Name Clashes and Alpha Conversion)  
2.12 通过 η 约简简化 (Simplification through Eta Reduction)  
**总结 (Summary)**  
**练习 (Exercises)**  

**第三章: 条件、布尔值和数字 (Chapter 3: Conditions, Booleans, and Numbers)**  
3.1 真值和条件表达式 (Truth Values and Conditional Expression)  
3.2 非 (NOT)  
3.3 与 (AND)  
3.4 或 (OR)  
3.5 自然数 (Natural Numbers)  
3.6 简化符号 (Simplified Notations)  
**总结 (Summary)**  
**练习 (Exercises)**  

**第四章: 递归和算术 (Chapter 4: Recursion and Arithmetic)**  
4.1 重复、迭代和递归 (Repetitions, Iteration, and Recursion)  
4.2 通过定义实现递归 (Recursion through Definitions)  
4.3 将函数传递给自身 (Passing a Function to Itself)  
4.4 应用序约简 (Applicative Order Reduction)  
4.5 递归函数 (Recursion Function)  
4.6 递归表示法 (Recursion Notation)  
4.7 算术运算 (Arithmetic Operations)  
**总结 (Summary)**  
**练习 (Exercises)**  

**第五章: 类型 (Chapter 5: Types)**  
5.1 类型与编程 (Types and Programming)  
5.2 类型作为对象和操作 (Types as Objects and Operations)  
5.3 表示类型化对象 (Representing Typed Objects)  
5.4 错误 (Errors)  
5.5 布尔值 (Booleans)  
5.6 类型化条件表达式 (Typed Conditional Expression)  
5.7 数字和算术 (Numbers and Arithmetic)  
5.8 字符 (Characters)  
5.9 重复类型检查 (Repetitive Type Checking)  
5.10 静态和动态类型检查 (Static and Dynamic Type Checking)  
5.11 中缀操作符 (Infix Operators)  
5.12 条件定义和结构匹配 (Case Definitions and Structure Matching)  
**总结 (Summary)**  
**练习 (Exercises)**  

**第六章: 列表和字符串 (Chapter 6: Lists and Strings)**  
6.1 列表 (Lists)  
6.2 列表表示 (List Representation)  
6.3 列表操作 (Operations on Lists)  
6.4 列表表示法 (List Notation)  
6.5 列表与求值 (Lists and Evaluation)  
6.6 从列表中删除 (Deletion from a List)  
6.7 列表比较 (List Comparison)  
6.8 字符串 (Strings)  
6.9 字符串比较 (String Comparison)  
6.10 数值字符串到数字的转换 (Numeric String to Number Conversion)  
6.11 列表的结构匹配 (Structure Matching with Lists)  
6.12 有序线性列表、插入与排序 (Ordered Linear Lists, Insertion, and Sorting)  
6.13 带索引的线性列表访问 (Indexed Linear List Access)  
6.14 映射函数 (Mapping Functions)  
**总结 (Summary)**  
**练习 (Exercises)**  

**第七章: 复合值和树 (Chapter 7: Composite Values and Trees)**  
7.1 复合值 (Composite Values)  
7.2 处理复合值序列 (Processing Composite Value Sequences)  
7.3 选择函数 (Selector Functions)  
7.4 广义结构匹配 (Generalized Structure Matching)  
7.5 局部定义 (Local Definitions)  
7.6 匹配复合值结果 (Matching Composite Value Results)  
7.7 列表低效 (List Inefficiency)  
7.8 树 (Trees)  
7.9 向有序二叉树中添加值 (Adding Values to Ordered Binary Trees)  
7.10 二叉树遍历 (Binary Tree Traversal)  
7.11 二叉树搜索 (Binary Tree Search)  
7.12 复合值的二叉树 (Binary Trees of Composite Values)  
7.13 二叉树效率 (Binary Tree Efficiency)  
7.14 柯里化和非柯里化函数 (Curried and Uncurried Functions)  
7.15 部分应用 (Partial Application)  
**总结 (Summary)**  
**练习 (Exercises)**  

**第八章: 求值 (Chapter 8: Evaluation)**  
8.1 终止与正常形式 (Termination and Normal Form)  
8.2 正常顺序 (Normal Order)  
8.3 应用顺序 (Applicative Order)  
8.4 应用顺序的一致使用 (Consistent Applicative Order Use)  
8.5 延迟求值 (Delaying Evaluation)  
8.6 求值终止、停机问题、求值等价和丘奇-罗塞尔定理 (Evaluation Termination, the Halting Problem, Evaluation Equivalence, and the Church-Rosser Theorems)  
8.7 无限对象 (Infinite Objects)  
8.8 惰性求值 (Lazy Evaluation)  
**总结 (Summary)**  
**练习 (Exercises)**  

**第九章: Standard ML 中的函数式编程 (Chapter 9: Functional Programming in Standard ML)**  
9.1 类型 (Types)  
9.2 列表 (Lists)  
9.3 元组 (Tuples)  
9.4 函数类型和表达式 (Function Types and Expressions)  
9.5 标准函数 (Standard Functions)  
9.6 比较运算符 (Comparison Operators)  
9.7 函数 (Functions)  
9.8 显式指定绑定变量的类型 (Making Bound Variables’ Types Explicit)  
9.9 定义 (Definitions)  
9.10 条件表达式 (Conditional Expressions)  
9.11 递归和函数定义 (Recursion and Function Definitions)  
9.12 元组选择 (Tuple Selection)  
9.13 模式匹配 (Pattern Matching)  
9.14 局部定义 (Local Definitions)  
9.15 类型表达式和缩写类型 (Type Expressions and Abbreviated Types)  
9.16 类型变量和多态 (Type Variables and Polymorphism)  
9.17 新类型 (New Types)  
9.18 树 (Trees)  
9.19 SML 中的 λ 微积分 (Lambda Calculus in SML)  
9.20 其他特性 (Other Features)  
**总结 (Summary)**  
**练习 (Exercises)**  

**第十章: 函数式编程与 LISP (Chapter 10: Functional Programming and LISP)**  
10.1 原子、数字和符号 (Atoms, Numbers, and Symbols)  
10.2 形式、表达式和函数应用 (Forms, Expressions, and Function Applications)  
10.3 逻辑 (Logic)  
10.4 算术和数字比较 (Arithmetic and Numeric Comparison)  
10.5 λ 函数 (Lambda Functions)  
10.6 全局定义 (Global Definitions)  
10.7 条件表达式 (Conditional Expressions)  
10.8 引用 (Quoting)  
10.9 列表 (Lists)  
10.10 列表选择 (List Selection)  
10.11 递归 (Recursion)  
10.12 局部定义 (Local Definitions)  
10.13 LISP 中的二叉树 (Binary Trees in LISP)  
10.14 动态作用域和词法作用域 (Dynamic and Lexical Scope)  
10.15 将函数作为值和参数 (Functions as Values and Arguments)  
10.16 符号、引用和求值 (Symbols, Quoting, and Evaluation)  
10.17 LISP 中的微积分 (Lambda Calculus in LISP)  
10.18 λ 微积分和 Scheme (Lambda Calculus and Scheme)  
10.19 其他特性 (Other Features)  
**总结 (Summary)**  
**练习 (Exercises)**  

**练习答案 (Answers to Exercises)**  
**参考文献 (Bibliography)**  
**索引 (Index)**  


---

### Contents (目录)
**Preface to the Dover Edition (《Dover 版序言》)**  
**Preface (前言)**  
**Chapter 1: Introduction (第一章: 介绍)**  
1.1 Names and Values in Programming (编程中的名称和值)  
1.2 Names and Values in Imperative and Functional Languages (在命令式和函数式语言中的名称和值)  
1.3 Execution Order in Imperative and Functional Languages (在命令式和函数式语言中的执行顺序)  
1.4 Repetition in Imperative and Functional Languages (在命令式和函数式语言中的重复)  
1.5 Data Structures in Functional Languages (函数式语言中的数据结构)  
1.6 Functions as Values (将函数视为值)  
1.7 The Origins of Functional Languages (函数式语言的起源)  
1.8 Computing and the Theory of Computing (计算和计算理论)  
1.9 A Calculus (一种微积分)  
**Summary (总结)**  

**Chapter 2: A Calculus (第二章: 微积分)**  
2.1 Abstraction (抽象)  
2.2 Abstraction in Programming Languages (编程语言中的抽象)  
2.3 Introducing Lambda Calculus (介绍 λ 微积分)  
2.4 Lambda Expressions (λ 表达式)  
2.5 Simple Lambda Functions (简单的 λ 函数)  
2.6 Introducing New Syntax (引入新语法)  
2.7 Notations for Naming Functions and Beta Reduction (函数命名的符号和 β 约简)  
2.8 Functions from Functions (从函数中得到的函数)  
2.9 Argument Selection and Argument Pairing Functions (参数选择和参数配对函数)  
2.10 Free and Bound Variables (自由变量和绑定变量)  
2.11 Name Clashes and Alpha Conversion (名称冲突和 α 转换)  
2.12 Simplification through Eta Reduction (通过 η 约简简化)  
**Summary (总结)**  
**Exercises (练习)**  

**Chapter 3: Conditions, Booleans, and Numbers (第三章: 条件、布尔值和数字)**  
3.1 Truth Values and Conditional Expression (真值和条件表达式)  
3.2 NOT (非)  
3.3 AND (与)  
3.4 OR (或)  
3.5 Natural Numbers (自然数)  
3.6 Simplified Notations (简化符号)  
**Summary (总结)**  
**Exercises (练习)**  

**Chapter 4: Recursion and Arithmetic (第四章: 递归和算术)**  
4.1 Repetitions, Iteration, and Recursion (重复、迭代和递归)  
4.2 Recursion through Definitions (通过定义实现递归)  
4.3 Passing a Function to Itself (将函数传递给自身)  
4.4 Applicative Order Reduction (应用序约简)  
4.5 Recursion Function (递归函数)  
4.6 Recursion Notation (递归表示法)  
4.7 Arithmetic Operations (算术运算)  
**Summary (总结)**  
**Exercises (练习)**  

**Chapter 5: Types (第五章: 类型)**  
5.1 Types and Programming (类型与编程)  
5.2 Types as Objects and Operations (类型作为对象和操作)  
5.3 Representing Typed Objects (表示类型化对象)  
5.4 Errors (错误)  
5.5 Booleans (布尔值)  
5.6 Typed Conditional Expression (类型化条件表达式)  
5.7 Numbers and Arithmetic (数字和算术)  
5.8 Characters (字符)  
5.9 Repetitive Type Checking (重复类型检查)  
5.10 Static and Dynamic Type Checking (静态和动态类型检查)  
5.11 Infix Operators (中缀操作符)  
5.12 Case Definitions and Structure Matching (条件定义和结构匹配)  
**Summary (总结)**  
**Exercises (练习)**  

**Chapter 6: Lists and Strings (第六章: 列表和字符串)**  
6.1 Lists (列表)  
6.2 List Representation (列表表示)  
6.3 Operations on Lists (列表操作)  
6.4 List Notation (列表表示法)  
6.5 Lists and Evaluation (列表与求值)  
6.6 Deletion from a List (从列表中删除)  
6.7 List Comparison (列表比较)  
6.8 Strings (字符串)  
6.9 String Comparison (字符串比较)  
6.10 Numeric String to Number Conversion (数值字符串到数字的转换)  
6.11 Structure Matching with Lists (列表的结构匹配)  
6.12 Ordered Linear Lists, Insertion, and Sorting (有序线性列表、插入与排序)  
6.13 Indexed Linear List Access (带索引的线性列表访问)  
6.14 Mapping Functions (映射函数)  
**Summary (总结)**  
**Exercises (练习)**  

**Chapter 7: Composite Values and Trees (第七章: 复合值和树)**  
7.1 Composite Values (复合值)  
7.2 Processing Composite Value Sequences (处理复合值序列)  
7.3 Selector Functions (选择函数)  
7.4 Generalized Structure Matching (广义结构匹配)  
7.5 Local Definitions (局部定义)  
7.6 Matching Composite Value Results (匹配复合值结果)  
7.7 List Inefficiency (列表低效)  
7.8 Trees (树)  
7.9 Adding Values to Ordered Binary Trees (向有序二叉树中添加值)  
7.10 Binary Tree Traversal (二叉树遍历)  
7.11 Binary Tree Search (二叉树搜索)  
7.12 Binary Trees of Composite Values (复合值的二叉树)  
7.13 Binary Tree Efficiency (二叉树效率)  
7.14 Curried and Uncurried Functions (柯里化和非柯里化函数)  
7.15 Partial Application (部分应用)  
**Summary (总结)**  
**Exercises (练习)**  

**Chapter 8: Evaluation (第八章: 求值)**  
8.1 Termination and Normal Form (终止与正常形式)  
8.2 Normal Order (正常顺序)  
8.3 Applicative Order (应用顺序)  
8.4 Consistent Applicative Order Use (应用顺序的一致使用)  
8.5 Delaying Evaluation (延迟求值)  
8.6 Evaluation Termination, the Halting Problem, Evaluation Equivalence, and the Church-Rosser Theorems (求值终止、停机问题、求值等价和丘奇-罗塞尔定理)  
8.7 Infinite Objects (无限对象)  
8.8 Lazy Evaluation (惰性求值)  
**Summary (总结)**  
**Exercises (练习)**  

**Chapter 9: Functional Programming in Standard ML (第九章: Standard ML 中的函数式编程)**  
9.1 Types (类型)  
9.2 Lists (列表)  
9.3 Tuples (元组)  
9.4 Function Types and Expressions (函数类型和表达式)  
9.5 Standard Functions (标准函数)  
9.6 Comparison Operators (比较运算符)  
9.7 Functions (函数)  
9.8 Making Bound Variables’ Types Explicit (显式指定绑定变量的类型)  
9.9 Definitions (定义)  
9.10 Conditional Expressions (条件表达式)  
9.11 Recursion and Function Definitions (递归和函数定义)  
9.12 Tuple Selection (元组选择)  
9.13 Pattern Matching (模式匹配)  
9.14 Local Definitions (局部定义)  
9.15 Type Expressions and Abbreviated Types (类型表达式和缩写类型)  
9.16 Type Variables and Polymorphism (类型变量和多态)  
9.17 New Types (新类型)  
9.18 Trees (树)  
9.19 Lambda Calculus in SML (SML 中的 λ 微积分)  
9.20 Other Features (其他特性)  
**Summary (总结)**  
**Exercises (练习)**  

**Chapter 10: Functional Programming and LISP (第十章: 函数式编程与 LISP)**  
10.1 Atoms, Numbers, and Symbols (原子、数字和符号)  
10.2 Forms, Expressions, and Function Applications (形式、表达式和函数应用)  
10.3 Logic (逻辑)  
10.4 Arithmetic and Numeric Comparison (算术和数字比较)  
10.5 Lambda Functions (λ 函数)  
10.6 Global Definitions (全局定义)  
10.7 Conditional Expressions (条件表达式)  
10.8 Quoting (引用)  
10.9 Lists (列表)  
10.10 List Selection (列表选择)  
10.11 Recursion (递归)  
10.12 Local Definitions (局部定义)  
10.13 Binary Trees in LISP (LISP 中的二叉树)  
10.14 Dynamic and Lexical Scope (动态作用域和词法作用域)  
10.15 Functions as Values and Arguments (将函数作为值
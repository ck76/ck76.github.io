Modern Compiler Implementation in C (Andrew W.Appel,with Jens Palsberg) è™ä¹¦ğŸ¯ğŸ“š

Modern Compiler Implementation in C

[toc]

---

### **å†…å®¹ (Contents)**

- **åºè¨€ (Preface)** ix

---

### **ç¬¬ä¸€éƒ¨åˆ†ï¼šç¼–è¯‘çš„åŸºç¡€ (Part I: Fundamentals of Compilation)**

#### ç¬¬1ç«  å¼•è¨€ (Introduction) 3  
- 1.1 æ¨¡å—ä¸æ¥å£ (Modules and Interfaces) 4  
- 1.2 å·¥å…·ä¸è½¯ä»¶ (Tools and Software) 5  
- 1.3 æ ‘è¯­è¨€çš„æ•°æ®ç»“æ„ (Data Structures for Tree Languages) 7  

#### ç¬¬2ç«  è¯æ³•åˆ†æ (Lexical Analysis) 16  
- 2.1 è¯æ³•è®°å· (Lexical Tokens) 17  
- 2.2 æ­£åˆ™è¡¨è¾¾å¼ (Regular Expressions) 18  
- 2.3 æœ‰é™è‡ªåŠ¨æœº (Finite Automata) 21  
- 2.4 éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº (Nondeterministic Finite Automata) 24  
- 2.5 Lexï¼šè¯æ³•åˆ†æå™¨ç”Ÿæˆå™¨ (Lex: A Lexical Analyzer Generator) 30  

#### ç¬¬3ç«  è¯­æ³•åˆ†æ (Parsing) 39  
- 3.1 ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³• (Context-Free Grammars) 41  
- 3.2 é¢„æµ‹åˆ†æ (Predictive Parsing) 46  
- 3.3 LR åˆ†æ (LR Parsing) 56  
- 3.4 ä½¿ç”¨è§£æå™¨ç”Ÿæˆå™¨ (Using Parser Generators) 69  
- 3.5 é”™è¯¯æ¢å¤ (Error Recovery) 76  

#### ç¬¬4ç«  æŠ½è±¡è¯­æ³• (Abstract Syntax) 88  
- 4.1 è¯­ä¹‰åŠ¨ä½œ (Semantic Actions) 88  
- 4.2 æŠ½è±¡è§£ææ ‘ (Abstract Parse Trees) 92  

#### ç¬¬5ç«  è¯­ä¹‰åˆ†æ (Semantic Analysis) 103  
- 5.1 ç¬¦å·è¡¨ (Symbol Tables) 103  
- 5.2 Tiger ç¼–è¯‘å™¨ä¸­çš„ç»‘å®š (Bindings for the Tiger Compiler) 112  
- 5.3 è¡¨è¾¾å¼çš„ç±»å‹æ£€æŸ¥ (Type-Checking Expressions) 115  
- 5.4 å£°æ˜çš„ç±»å‹æ£€æŸ¥ (Type-Checking Declarations) 118  

#### ç¬¬6ç«  æ´»åŠ¨è®°å½• (Activation Records) 125  
- 6.1 æ ˆå¸§ (Stack Frames) 127  
- 6.2 Tiger ç¼–è¯‘å™¨ä¸­çš„å¸§ (Frames in the Tiger Compiler) 135  

#### ç¬¬7ç«  ç¿»è¯‘ä¸ºä¸­é—´ä»£ç  (Translation to Intermediate Code) 150  
- 7.1 ä¸­é—´è¡¨ç¤ºæ ‘ (Intermediate Representation Trees) 151  
- 7.2 æ ‘çš„ç¿»è¯‘ (Translation into Trees) 154  
- 7.3 å£°æ˜ (Declarations) 170  

#### ç¬¬8ç«  åŸºæœ¬å—å’Œè½¨è¿¹ (Basic Blocks and Traces) 176  
- 8.1 è§„èŒƒåŒ–æ ‘ (Canonical Trees) 177  
- 8.2 é©¯æœæ¡ä»¶åˆ†æ”¯ (Taming Conditional Branches) 185  

#### ç¬¬9ç«  æŒ‡ä»¤é€‰æ‹© (Instruction Selection) 191  
- 9.1 æŒ‡ä»¤é€‰æ‹©ç®—æ³• (Algorithms for Instruction Selection) 194  
- 9.2 CISC æœºå™¨ (CISC Machines) 202  
- 9.3 Tiger ç¼–è¯‘å™¨çš„æŒ‡ä»¤é€‰æ‹© (Instruction Selection for the Tiger Compiler) 205  

#### ç¬¬10ç«  æ´»è·ƒæ€§åˆ†æ (Liveness Analysis) 218  
- 10.1 æ•°æ®æµæ–¹ç¨‹çš„è§£æ³• (Solution of Dataflow Equations) 220  
- 10.2 Tiger ç¼–è¯‘å™¨ä¸­çš„æ´»è·ƒæ€§ (Liveness in the Tiger Compiler) 229  

#### ç¬¬11ç«  å¯„å­˜å™¨åˆ†é… (Register Allocation) 235  
- 11.1 ç®€åŒ–çš„ç€è‰² (Coloring by Simplification) 236  
- 11.2 åˆå¹¶ (Coalescing) 239  
- 11.3 é¢„ç€è‰²èŠ‚ç‚¹ (Precolored Nodes) 243  
- 11.4 å›¾ç€è‰²å®ç° (Graph Coloring Implementation) 248  
- 11.5 æ ‘çš„å¯„å­˜å™¨åˆ†é… (Register Allocation for Trees) 257  

#### ç¬¬12ç«  é›†æˆ (Putting It All Together) 265  

---

### **ç¬¬äºŒéƒ¨åˆ†ï¼šé«˜çº§ä¸»é¢˜ (Part II: Advanced Topics)**

#### ç¬¬13ç«  åƒåœ¾å›æ”¶ (Garbage Collection) 273  
- 13.1 æ ‡è®°-æ¸…é™¤å›æ”¶ (Mark-and-Sweep Collection) 273  
- 13.2 å¼•ç”¨è®¡æ•° (Reference Counts) 278  
- 13.3 å¤åˆ¶å›æ”¶ (Copying Collection) 280  
- 13.4 åˆ†ä»£å›æ”¶ (Generational Collection) 285  
- 13.5 å¢é‡å›æ”¶ (Incremental Collection) 287  
- 13.6 Baker ç®—æ³• (Bakerâ€™s Algorithm) 290  
- 13.7 ç¼–è¯‘å™¨æ¥å£ (Interface to the Compiler) 291  

#### ç¬¬14ç«  é¢å‘å¯¹è±¡è¯­è¨€ (Object-Oriented Languages) 299  
- 14.1 ç±» (Classes) 299  
- 14.2 æ•°æ®å­—æ®µçš„å•ç»§æ‰¿ (Single Inheritance of Data Fields) 302  
- 14.3 å¤šç»§æ‰¿ (Multiple Inheritance) 304  
- 14.4 ç±»æˆå‘˜æµ‹è¯• (Testing Class Membership) 306  
- 14.5 ç§æœ‰å­—æ®µä¸æ–¹æ³• (Private Fields and Methods) 310  
- 14.6 æ— ç±»è¯­è¨€ (Classless Languages) 310  
- 14.7 é¢å‘å¯¹è±¡ç¨‹åºä¼˜åŒ– (Optimizing Object-Oriented Programs) 311  

#### ç¬¬15ç«  å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ (Functional Programming Languages) 315  
- 15.1 ç®€å•çš„å‡½æ•°å¼è¯­è¨€ (A Simple Functional Language) 316  
- 15.2 é—­åŒ… (Closures) 318  
- 15.3 ä¸å¯å˜å˜é‡ (Immutable Variables) 319  
- 15.4 å†…è”æ‰©å±• (Inline Expansion) 326  
- 15.5 é—­åŒ…è½¬æ¢ (Closure Conversion) 332  
- 15.6 é«˜æ•ˆå°¾é€’å½’ (Efficient Tail Recursion) 335  
- 15.7 æƒ°æ€§æ±‚å€¼ (Lazy Evaluation) 337  

#### ç¬¬16ç«  å¤šæ€ç±»å‹ (Polymorphic Types) 350  
- 16.1 å‚æ•°åŒ–å¤šæ€ (Parametric Polymorphism) 351  
- 16.2 ç±»å‹æ¨æ–­ (Type Inference) 359  
- 16.3 å¤šæ€å˜é‡çš„è¡¨ç¤º (Representation of Polymorphic Variables) 369  
- 16.4 é™æ€é‡è½½çš„è§£æ (Resolution of Static Overloading) 378  

#### ç¬¬17ç«  æ•°æ®æµåˆ†æ (Dataflow Analysis) 383  
- 17.1 æµåˆ†æçš„ä¸­é—´è¡¨ç¤º (Intermediate Representation for Flow Analysis) 384  
- 17.2 å„ç§æ•°æ®æµåˆ†æ (Various Dataflow Analyses) 387  
- 17.3 ä½¿ç”¨æ•°æ®æµåˆ†æè¿›è¡Œè½¬æ¢ (Transformations Using Dataflow Analysis) 392  
- 17.4 åŠ é€Ÿæ•°æ®æµåˆ†æ (Speeding Up Dataflow Analysis) 393  
- 17.5 åˆ«ååˆ†æ (Alias Analysis) 402  

#### ç¬¬18ç«  å¾ªç¯ä¼˜åŒ– (Loop Optimizations) 410  
- 18.1 æ”¯é…è€… (Dominators) 413  
- 18.2 å¾ªç¯ä¸å˜è®¡ç®— (Loop-Invariant Computations) 418  
- 18.3 å½’çº³å˜é‡ (Induction Variables) 419  
- 18.4 æ•°ç»„è¾¹ç•Œæ£€æŸ¥ (Array-Bounds Checks) 425  
- 18.5 å¾ªç¯å±•å¼€ (Loop Unrolling) 429  

#### ç¬¬19ç«  é™æ€å•èµ‹å€¼å½¢å¼ (Static Single-Assignment Form) 433  
- 19.1 è½¬æ¢ä¸º SSA å½¢å¼ (Converting to SSA Form) 436  
- 19.2 æ”¯é…æ ‘çš„é«˜æ•ˆè®¡ç®— (Efficient Computation of the Dominator Tree) 444  
- 19.3 ä½¿ç”¨ SSA çš„ä¼˜åŒ–ç®—æ³• (Optimization Algorithms Using SSA) 451  
- 19.4 æ•°ç»„ã€æŒ‡é’ˆå’Œå†…å­˜ (Arrays, Pointers, and Memory) 457  
- 19.5 æ§åˆ¶ä¾èµ–å›¾ (The Control-Dependence Graph) 459  
- 19.6 ä» SSA å½¢å¼è½¬æ¢å›æ™®é€šå½¢å¼ (Converting Back from SSA Form) 462  
- 19.7 å‡½æ•°å¼ä¸­é—´å½¢å¼ (A Functional Intermediate Form) 464  

#### ç¬¬20ç«  æµæ°´çº¿ä¸è°ƒåº¦ (Pipelining and Scheduling) 474  
- 20.1 æ— èµ„æºé™åˆ¶çš„å¾ªç¯è°ƒåº¦ (Loop Scheduling Without Resource Bounds) 478  
- 20.2 æœ‰èµ„æºé™åˆ¶çš„å¾ªç¯æµæ°´çº¿ (Resource-Bounded Loop Pipelining) 482  
- 20.3 åˆ†æ”¯é¢„æµ‹ (Branch Prediction) 490  

#### ç¬¬21ç«  å†…å­˜å±‚æ¬¡ç»“æ„ (The Memory Hierarchy) 498  
- 21.1 ç¼“å­˜ç»„ç»‡ (Cache Organization) 499  
- 21.2 ç¼“å­˜å—å¯¹é½ (Cache-Block Alignment) 502  
- 21.3 é¢„å– (Prefetching) 504  
- 21.4 å¾ªç¯ç½®æ¢ (Loop Interchange) 510  
- 21.5 é˜»å¡ (Blocking) 511  
- 21.6 åƒåœ¾å›æ”¶ä¸å†…å­˜å±‚æ¬¡ç»“æ„ (Garbage Collection and the Memory Hierarchy) 514  

---

### **é™„å½•ï¼šTiger è¯­è¨€å‚è€ƒæ‰‹å†Œ (Appendix: Tiger Language Reference Manual)** 518  
- A.1 è¯æ³•é—®é¢˜ (Lexical Issues) 518  
- A.2 å£°æ˜ (Declarations) 518  
- A.3 å˜é‡ä¸è¡¨è¾¾å¼ (Variables and Expressions) 521  
- A.4 æ ‡å‡†åº“ (Standard Library) 525  
- A.5 Tiger ç¨‹åºç¤ºä¾‹ (Sample Tiger Programs) 526  

---

### **å‚è€ƒæ–‡çŒ® (Bibliography)** 528  

---

### **ç´¢å¼• (Index)** 537  


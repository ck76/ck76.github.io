Programming with Types (Vlad Riscutia)



### 目录 (Contents)

**前言** (Preface)  
**致谢** (Acknowledgments)  
**关于本书** (About this book)  
**本书适合哪些读者** (Who should read this book)  
**本书的结构：导览图** (How this book is organized: a road map)  
**关于代码** (About the code)  
**关于作者** (About the author)  
**书籍论坛** (Book forum)  
**关于封面插图** (About the cover illustration)  
**Saint-Sauveur**

---

**第1章 类型简介** (Chapter 1: Introduction to Typing) 1  
1.1 本书面向读者 (Whom this book is for)  
1.2 为什么类型存在 (Why types exist)  
1.2.1 0和1 (0s and 1s)  
1.2.2 什么是类型和类型系统 (What are types and type systems?)  
1.3 类型系统的好处 (Benefits of type systems)  
1.3.1 正确性 (Correctness)  
1.3.2 不变性 (Immutability)  
1.3.3 封装性 (Encapsulation)  
1.3.4 可组合性 (Composability)  
1.3.5 可读性 (Readability)  
1.4 类型系统的种类 (Types of type systems)  
1.4.1 动态与静态类型 (Dynamic and static typing)  
1.4.2 弱类型与强类型 (Weak and strong typing)  
1.4.3 类型推断 (Type inference)  
1.5 本书内容简介 (In this book)  
总结 (Summary)

---

**第2章 基本类型** (Chapter 2: Basic Types) 19  
2.1 设计不返回值的函数 (Designing functions that don’t return values)  
2.1.1 空类型 (The empty type)  
2.1.2 单位类型 (The unit type)  
2.1.3 练习 (Exercises)  
2.2 布尔逻辑与短路运算 (Boolean logic and short circuits)  
2.2.1 布尔表达式 (Boolean expressions)  
2.2.2 短路求值 (Short circuit evaluation)  
2.2.3 练习 (Exercise)  
2.3 数字类型的常见陷阱 (Common pitfalls of numerical types)  
2.3.1 整数类型与溢出 (Integer types and overflow)  
2.3.2 浮点数与舍入 (Floating-point types and rounding)  
2.3.3 任意大数字 (Arbitrarily large numbers)  
2.3.4 练习 (Exercises)  
2.4 文本编码 (Encoding text)  
2.4.1 文本切割 (Breaking text)  
2.4.2 编码 (Encodings)  
2.4.3 编码库 (Encoding libraries)  
2.4.4 练习 (Exercises)  
2.5 用数组和引用构建数据结构 (Building data structures with arrays and references)  
2.5.1 固定大小的数组 (Fixed-size arrays)  
2.5.2 引用 (References)  
2.5.3 高效列表 (Efficient lists)  
2.5.4 二叉树 (Binary trees)  
2.5.5 关联数组 (Associative arrays)  
2.5.6 实现折中 (Implementation trade-offs)  
2.5.7 练习 (Exercise)  
总结 (Summary)  
练习答案 (Answers to exercises)

---

**第3章 组合** (Chapter 3: Composition) 19  
3.1 复合类型 (Compound types)  
3.1.1 元组 (Tuples)  
3.1.2 赋予意义 (Assigning meaning)  
3.1.3 保持不变 (Maintaining invariants)  
3.1.4 练习 (Exercise)  
3.2 用类型表达两者之一 (Expressing either-or with types)  
3.2.1 枚举 (Enumerations)  
3.2.2 可选类型 (Optional types)  
3.2.3 结果或错误 (Result or error)  
3.2.4 变体 (Variants)  
3.2.5 练习 (Exercises)  
3.3 访问者模式 (The visitor pattern)  
3.3.1 一个简单的实现 (A naïve implementation)  
3.3.2 使用访问者模式 (Using the visitor pattern)  
3.3.3 访问变体 (Visiting a variant)  
3.3.4 练习 (Exercise)  
3.4 代数数据类型 (Algebraic data types)  
3.4.1 乘积类型 (Product types)  
3.4.2 和类型 (Sum types)  
3.4.3 练习 (Exercises)  
总结 (Summary)  
练习答案 (Answers to exercises)

---

**第4章 类型安全** (Chapter 4: Type Safety)  
4.1 避免原始痴迷防止误解 (Avoiding primitive obsession to prevent misinterpretation)  
4.1.1 火星气候轨道器 (The Mars Climate Orbiter)  
4.1.2 原始痴迷反模式 (The primitive obsession antipattern)  
4.1.3 练习 (Exercise)  
4.2 强制约束 (Enforcing constraints)  
4.2.1 用构造函数强制约束 (Enforcing constraints with the constructor)  
4.2.2 用工厂方法强制约束 (Enforcing constraints with a factory)  
4.2.3 练习 (Exercise)  
4.3 增加类型信息 (Adding type information)  
4.3.1 类型转换 (Type casting)  
4.3.2 在类型系统之外跟踪类型 (Tracking types outside the type system)  
4.3.3 常见的类型转换 (Common type casts)  
4.3.4 练习 (Exercises)  
4.4 隐藏和恢复类型信息 (Hiding and restoring type information)  
4.4.1 异构集合 (Heterogenous collections)  
4.4.2 序列化 (Serialization)  
4.4.3 练习 (Exercises)  
总结 (Summary)  
练习答案 (Answers to exercises)

---

**第5章 函数类型** (Chapter 5: Function Types)  
5.1 一个简单的策略模式 (A simple strategy pattern)  
5.1.1 一个函数策略 (A functional strategy)  
5.1.2 为函数添加类型 (Typing functions)  
5.1.3 策略实现 (Strategy implementations)  
5.1.4 一级函数 (First-class functions)  
5.1.5 练习 (Exercises)  
5.2 没有switch语句的状态机 (A state machine without switch statements)  
5.2.1 早期编程类型 (Early Programming with Types)  
5.2.2 状态机 (State machines)  
5.2.3 状态机实现回顾 (State machine implementation recap)  
5.2.4 练习 (Exercises)  
5.3 用惰性值避免昂贵计算 (Avoiding expensive computation with lazy values)  
5.3.1 Lambda表达式 (Lambdas)  
5.3.2 练习 (Exercise)  
5.4 使用map、filter和reduce (Using map, filter, and reduce)  
5.4.1 map()函数 (map())  
5.4.2 filter()函数 (filter())  
5.4.3 reduce()函数 (reduce())  
5.4.4 库支持 (Library support)  
5.4.5 练习 (Exercises)  
5.5 函数式编程 (Functional programming)  
总结 (Summary)  
练习答案 (Answers to exercises)

---

**第6章 函数类型的高级应用** (Chapter 6: Advanced Applications of Function Types)  
6.1 一个简单的装饰模式 (A simple decorator pattern)  
6.1.1 一个函数装饰器 (A functional decorator)  
6.1.2 装饰器实现 (Decorator implementations)  
6.1.3 闭包 (Closures)  
6.1.4 练习 (Exercises)  
6.2 实现一个计数器 (Implementing a counter)  
6.2.1 面向对象的计数器 (An object-oriented counter)  
6.2.2 函数式计数器 (A functional counter)  
6.2.3 可恢复的计数器 (A resumable counter)  
6.2.4 计数器实现回顾 (Counter implementations recap)  
6.2.5 练习 (Exercises)  
6.3 异步执行长时间运行的操作 (Executing long-running operations asynchronously)  
6.3.1 同步执行 (Synchronous execution)  
6.3.2 异步执行：回调 (Asynchronous execution: callbacks)  
6.3.3 异步执行模型 (Asynchronous execution models)  
6.3.4 异步函数回顾 (Asynchronous functions recap)  
6.3.5 练习 (Exercises)  
6.4 简化异步代码 (Simplifying asynchronous code)  
6.4.1 链式promise (Chaining promises)  
6.4.2 创建promise (Creating promises)  
6.4.3 更多关于promise (More about promises)  
6.4.4 async/await (async/await)  
6.4.5 干净的异步代码回顾 (Clean asynchronous code recap)  
6.4.6 练习 (Exercises)  
总结 (Summary)  
练习答案 (Answers to exercises)

---

**第7章 子类型** (Chapter 7: Subtyping)  
7.1 在TypeScript中区分相似类型 (Distinguishing between similar types in TypeScript)  
7.1.1 结构化和名义子类型的优缺点 (Structural and nominal subtyping pros and cons)  
7.1.2 在TypeScript中模拟名义子类型 (Simulating nominal subtyping in TypeScript)  
7.1.3 练习 (Exercises)  
7.2 赋值任何类型 (Assigning anything to, assigning to anything)  
7.2.1 安全反序列化 (Safe deserialization)  
7.2.2 错误情况下的值 (Values for error cases)  
7.2.3 顶类型和底类型回顾 (Top and bottom types recap)  
7.2.4 练习 (Exercises)  
7.3 允许的替换 (Allowed substitutions)  
7.3.1 子类型与和类型 (Subtyping and sum types)  
7.3.2 子类型与集合 (Subtyping and collections)  
7.3.3 子类型与函数返回类型 (Subtyping and function return types)  
7.3.4 子类型与函数参数类型 (Subtyping and function argument types)  
7.3.5 协变与逆变回顾 (Variance recap)  
7.3.6 练习 (Exercises)  
总结 (Summary)  
练习答案 (Answers to exercises)

---

**第8章 面向对象编程的元素** (Chapter 8: Elements of Object-oriented Programming)  
8.1 用接口定义合同 (Defining contracts with interfaces)  
8.1.1 练习 (Exercises)  
8.2 继承数据和行为 (Inheriting data and behavior)  
8.2.1 is-a规则 (The is-a rule of thumb)  
8.2.2 建模层次结构 (Modeling a hierarchy)  
8.2.3 参数化表达式行为 (Parameterizing behavior of expressions)  
8.2.4 练习 (Exercises)  
8.3 组合数据和行为 (Composing data and behavior)  
8.3.1 has-a规则 (The has-a rule of thumb)  
8.3.2 复合类 (Composite classes)  
8.3.3 实现适配器模式 (Implementing the adapter pattern)  
8.3.4 练习 (Exercises)  
8.4 扩展数据和行为 (Extending data and behavior)  
8.4.1 用组合扩展行为 (Extending behavior with composition)  
8.4.2 用混入扩展行为 (Extending behavior with mix-ins)  
8.4.3 在TypeScript中使用混入 (Mix-in in TypeScript)  
8.4.4 练习 (Exercise)  
8.5 纯面向对象代码的替代方案 (Alternatives to purely object-oriented code)  
8.5.1 和类型 (Sum types)  
8.5.2 函数式编程 (Functional programming)  
8.5.3 泛型编程 (Generic programming)  
总结 (Summary)  
练习答案 (Answers to exercises)

---

**第9章 泛型数据结构** (Chapter 9: Generic Data Structures)  
9.1 解耦关注点 (Decoupling concerns)  
9.1.1 可复用的身份函数 (A reusable identity function)  
9.1.2 可选类型 (The optional type)  
9.1.3 泛型类型 (Generic types)  
9.1.4 练习 (Exercises)  
9.2 泛型数据布局 (Generic data layout)  
9.2.1 泛型数据结构 (Generic data structures)  
9.2.2 什么是数据结构 (What is a data structure?)  
9.2.3 练习 (Exercises)  
9.3 遍历任何数据结构 (Traversing any data structure)  
9.3.1 使用迭代器 (Using iterators)  
9.3.2 精简迭代代码 (Streamlining iteration code)  
9.3.3 迭代器回顾 (Iterators recap)  
9.3.4 练习 (Exercises)  
9.4 流数据 (Streaming data)  
9.4.1 处理流水线 (Processing pipelines)  
9.4.2 练习 (Exercises)  
总结 (Summary)  
练习答案 (Answers to exercises)

---

**第10章 泛型算法与迭代器** (Chapter 10: Generic Algorithms and Iterators)  
10.1 更好的map()、filter()、reduce() (Better map(), filter(), reduce())  
10.1.1 map()函数 (map())  
10.1.2 filter()函数 (filter())  
10.1.3 reduce()函数 (reduce())  
10.1.4 filter()/reduce()流水线 (filter()/reduce() pipeline)  
10.1.5 练习 (Exercises)  
10.2 常见算法 (Common algorithms)  
10.2.1 使用算法代替循环 (Algorithms instead of loops)  
10.2.2 实现流畅的流水线 (Implementing a fluent pipeline)  
10.2.3 练习 (Exercises)  
10.3 约束类型参数 (Constraining type parameters)  
10.3.1 使用类型约束的泛型数据结构 (Generic data structures with type constraints)  
10.3.2 使用类型约束的泛型算法 (Generic algorithms with type constraints)  
10.3.3 练习 (Exercise)  
10.4 使用迭代器高效实现反向与其他算法 (Efficient reverse and other algorithms using iterators)  
10.4.1 迭代器的构建模块 (Iterator building blocks)  
10.4.2 一个有用的find() (A useful find())  
10.4.3 一个高效的反向() (An efficient reverse())  
10.4.4 高效的元素检索 (Efficient element retrieval)  
10.4.5 迭代器回顾 (Iterator recap)  
10.4.6 练习 (Exercises)  
10.5 自适应算法 (Adaptive algorithms)  
10.5.1 练习 (Exercise)  
总结 (Summary)  
练习答案 (Answers to exercises)

---

**第11章 高阶类型及其他** (Chapter 11: Higher Kinded Types and Beyond)  
11.1 一个更通用的map函数 (An even more general map)  
11.1.1 处理结果或传播错误 (Processing results or propagating errors)  
11.1.2 混合函数应用 (Mix-and-match function application)  
11.1.3 函子与高阶类型 (Functors and higher kinded types)  
11.1.4 函数的函子 (Functors for functions)  
11.1.5 练习 (Exercise)  
11.2 Monad (Monads)  
11.2.1 结果或错误 (Result or error)  
11.2.2 map()和bind()的区别 (Difference between map() and bind())  
11.2.3 Monad模式 (The monad pattern)  
11.2.4 延续Monad (The continuation monad)  
11.2.5 列表Monad (The list monad)  
11.2.6 其他Monads (Other monads)  
11.2.7 练习 (Exercise)  
11.3 接下来学习什么？(Where to next?)  
11.3.1 函数式编程 (Functional programming)  
11.3.2 泛型编程 (Generic programming)  
11.3.3 高阶类型与范畴论 (Higher kinded types and category theory)  
11.3.4 依赖类型 (Dependent types)  
11.3.5 线性类型 (Linear types)  
总结 (Summary)  
练习答案 (Answers to exercises)

---

**附录 A TypeScript 安装与源码** (Appendix A: TypeScript Installation and Source Code)  
**附录 B TypeScript 备忘单** (Appendix B: TypeScript Cheat Sheet) 
[toc]



### 4 状态 (State)
#### 4.1 计算的效果 (Effects of Computation)

在计算中，不仅仅是计算产生的值 (value) 重要，计算的效果 (effect) 也同样关键。效果可以包括读取、打印或修改内存、文件系统的状态。尤其在现实世界的计算中，我们更关心计算的效果。因为如果计算没有任何显示或变化，计算的结果可能毫无实际意义。

**效果与值的区别**：
- **值 (Value)**：是计算的直接结果，例如一个数字、字符串、布尔值等。
- **效果 (Effect)**：是计算对系统状态的改变或外部交互，例如打印输出、修改内存、或更新文件。

效果往往是全局性的 (global)，它们影响整个系统状态或环境。因此，它们具有广泛的传播性，改变系统的后续计算行为。正因为这种全局影响，效果对整个计算环境都会造成影响。

#### 赋值与绑定的区别

- **绑定 (Binding)**：是将变量名与一个值关联起来，它通常是局部的 (local)，仅在某个作用域内可见。
- **赋值 (Assignment)**：则是将内存中的某个位置关联到一个新值，它可能是全局的 (global)，即在不同的过程或作用域中共享相同的内存位置。

通过赋值，不相关的过程可以共享相同的内存位置，从而共享数据。这种共享使得在过程调用之间保存状态成为可能。例如，一个过程可以修改一个位置中的值，另一个过程就能看到这种变化。

#### 存储模型 (Memory Model)

为了处理这些效果，我们将内存建模为一个 **从位置 (location) 到值的有限映射 (finite mapping)**。这个映射称为**存储器 (store)**，其中：
- **位置 (Location)**：是内存中可以存储值的一个具体地址或槽位。
- **可存储值 (Storable Values)**：是可以存储在位置中的值集合，这可能包括数字、字符串或其他复杂数据结构。

值得注意的是，在不同的编程语言中，可存储值的集合可能不同，这取决于语言设计。例如，有的语言可能限制某些数据类型不能被存储，而有的语言则允许复杂的结构存储。

#### 引用与位置的类比

在计算机科学中，我们使用**引用 (Reference)** 来指向内存中的某个位置。引用本身并不直接包含值，而是指向包含该值的存储位置。可以通过以下类比来理解：
- **位置 (Location)**：就像一个文件，存储着数据。
- **引用 (Reference)**：就像一个 URL，它指向一个文件（位置），但本身并不包含该文件的数据。

通过引用，多个过程或函数可以共享相同的内存位置，因此可以实现数据的共享与状态的持久化。引用有时也称为**左值 (L-values)**，与之相对的，**右值 (R-values)** 指的是表达式求值后的值。

#### 显式引用与隐式引用
在编程语言设计中，处理存储器的方式有两种主要方法：
1. **显式引用 (Explicit Reference)**：程序员明确使用引用数据结构来管理存储和赋值操作，通常通过指针或地址等数据结构来操作存储。
2. **隐式引用 (Implicit Reference)**：存储器的管理对程序员来说是隐藏的，语言会自动处理存储分配和引用管理。

这两种设计决定了编程语言处理存储状态的机制以及程序员如何与存储系统交互。

### 总结：
计算不仅产生值，还会引起状态的变化，即计算的效果 (effects)。在计算中，绑定是局部的，而赋值可以是全局的，通过赋值，多个过程可以共享内存中的信息。引用是指向内存位置的数据结构，使得数据可以被共享和修改。

### -----------------------------------------

### 4.2 EXPLICIT-REFS：显式引用语言

显式引用语言（**Explicit References**）允许程序员直接操作内存位置，通过引用来对存储器进行读取、修改等操作。在这种语言中，引用的管理由程序员显式进行，通常通过指针、内存地址等概念来操控。

#### 4.2.1 存储器传递规范

存储器模型是一种**从位置到值的有限映射**，我们通过存储器的传递来描述计算的过程。每一次计算不仅返回一个值，还返回更新后的存储器。这可以表示为：

$$
(value, store') = \text{evaluate}(expression, store)
$$

在这个规范中：
- `expression` 是我们需要求值的表达式。
- `store` 是计算前的存储器状态。
- `value` 是表达式的值。
- `store'` 是计算后的新存储器。

例如，假设我们有一个存储器包含两个位置，分别存储了数字 $5$ 和 $10$，在对某个表达式求值后，位置的值发生了改变，新的存储器状态会反映这种改变。

#### 4.2.2 定义显式引用操作

显式引用操作包含以下几个核心操作：
1. **创建引用 (allocate reference)**：分配一个新的内存位置，用来存储某个值。
2. **读取引用 (read reference)**：从一个存储位置中读取当前的值。
3. **写入引用 (write reference)**：将一个新值写入某个存储位置。

例如，创建一个引用可以表示为：

$$
(store', loc) = \text{allocate}(val, store)
$$

其中，`store'` 是分配新的存储位置后的存储器状态，`loc` 是该新位置的地址。

#### 4.2.3 实现

在实现显式引用语言时，我们需要考虑如何定义存储器数据结构，并实现分配、读取、写入等基本操作。一个基本的实现可以采用一个列表或字典，映射位置到存储值。

```scheme
;; 存储器数据结构：从位置到值的映射
(define store '())

;; 分配新的存储位置
(define (allocate val store)
  (let ((new-loc (length store)))  ;; 新的位置是当前存储器的长度
    (cons (cons new-loc val) store)))  ;; 返回新存储器和位置

;; 读取存储位置的值
(define (read-loc loc store)
  (cdr (assoc loc store)))  ;; 查找位置对应的值

;; 写入存储位置的新值
(define (write-loc loc val store)
  (let ((updated-store (assoc-set! store loc val)))  ;; 更新存储位置的值
    updated-store))
```

### 4.3 IMPLICIT-REFS：隐式引用语言

隐式引用语言（**Implicit References**）对程序员隐藏了存储器的管理。编译器或解释器自动管理引用和存储器操作，程序员不需要直接处理存储器位置。

#### 4.3.1 规范

隐式引用语言不直接暴露内存引用的细节。语言会自动为变量分配内存，并管理这些内存的生命周期。例如，在变量赋值时，程序员只看到变量的名字，但实际分配和引用内存的操作由语言底层自动处理。

#### 4.3.2 实现

在隐式引用语言的实现中，解释器或编译器会管理内存的分配、引用、和释放。程序员定义的变量在内部可能会自动关联到存储器中的某个位置。

```scheme
;; 隐式引用语言的简单实现
(define (evaluate expression env store)
  (cases expression
    ((var-exp var)
     (list (apply-env env var) store))  ;; 从环境中读取变量值
    ((assign-exp var val-exp)
     (let ((val (evaluate val-exp env store)))
       (list val (write-loc (apply-env env var) val store))))))
```

### 4.4 MUTABLE-PAIRS：可变序对语言

可变序对语言允许修改由 `cons` 构造的序对（pair），使其内部值可以在程序的不同阶段发生改变。

#### 4.4.1 实现

在可变序对语言中，`set-car!` 和 `set-cdr!` 操作可以用于改变序对中的内容。例如：

```scheme
;; 修改序对的 car 部分
(define (set-car! pair new-val)
  (set-car! pair new-val))

;; 修改序对的 cdr 部分
(define (set-cdr! pair new-val)
  (set-cdr! pair new-val))
```

这些操作允许程序员直接修改已有的序对，而不需要创建新的序对。

#### 4.4.2 可变序对的另一种表示

另一种表示可变序对的方式是使用显式引用，存储对 `car` 和 `cdr` 的引用。这种表示方法将 `car` 和 `cdr` 分别指向存储器中的不同位置，可以单独修改。

### 4.5 传参变体

参数传递是影响计算行为的重要概念。在不同的语言中，参数传递有不同的方式。

#### 4.5.1 按指调用（Call by Reference）

按指调用（**Call by Reference**）允许函数修改其参数的值，因为传递给函数的是参数的引用。这种方式与按值调用（**Call by Value**）不同，按值调用只会传递参数的副本，因此修改函数内部的参数不会影响外部的值。

在按指调用中，函数可以直接修改变量的原始值，因为函数接收到的是引用（类似于指针）。

```scheme
;; 按指调用的示例
(define (modify var-ref)
  (write-loc var-ref 42 store))  ;; 直接修改引用的值
```

### 总结

在这一章节中，我们探讨了计算中的**状态**和**效果**，并介绍了显式和隐式引用语言，以及可变序对和参数传递的变体。在这些扩展中，存储器的管理和变量的引用方式是核心内容，不同的设计方案可以显著影响语言的行为和性能。

### -----------------------------------------

<img src="https://p.ipic.vip/eug7sq.png" alt="6c127da6e667f1867023e496c4051505" style="zoom:53%;" />

### 4.2 EXPLICIT-REFS: 显式引用语言

在显式引用语言 (**Explicit References**) 中，引用被添加为一种新的表达值 (**ExpVal**)，允许程序员直接操作内存位置。语言提供了创建引用、解引用和修改引用内容的机制，使得变量的值可以通过内存中的位置来共享和修改。

#### 表达值和指代值的结构

显式引用语言扩展了表达值 (**ExpVal**) 和指代值 (**DenVal**) 的定义：

- **ExpVal** 是以下几种类型的并集：
  $$
  ExpVal = Int + Bool + Proc + Ref(ExpVal)
  $$
  其中，**Ref(ExpVal)** 表示引用，它指向内存中的一个位置，这个位置存储某种表达值。

- **DenVal**：在 EXPLICIT-REFS 语言中，指代值和表达值是相同的，所有可以作为表达值的内容也可以作为指代值：
  $$
  DenVal = ExpVal
  $$

#### 新增的引用操作

显式引用语言中，加入了三种新的操作来处理引用：
1. **newref**：分配一个新的内存位置，并返回该位置的引用。
2. **deref**：解引用操作，返回引用所指向位置中的内容。
3. **setref**：修改引用所指向位置的内容。

### 代码示例：`even` 和 `odd`

以下是一个使用 `newref`、`deref` 和 `setref` 的示例程序，展示了如何通过共享内存位置进行通信。这个程序定义了两个过程 `even` 和 `odd`，它们判断一个共享变量是否为偶数或奇数，并递归修改这个共享变量的值。

```scheme
let x = newref(0)  ;; 创建一个新的引用，初始值为 0
in letrec 
    even(dummy) = if zero?(deref(x))  ;; 如果 x 中的值是 0，则返回 1
                  then 1
                  else begin
                      setref(x, -(deref(x), 1));  ;; 否则，将 x 的值减 1
                      (odd 888)  ;; 调用 odd
                  end,
    odd(dummy) = if zero?(deref(x))  ;; 如果 x 中的值是 0，则返回 0
                 then 0
                 else begin
                     setref(x, -(deref(x), 1));  ;; 否则，将 x 的值减 1
                     (even 888)  ;; 调用 even
                 end
in begin 
    setref(x, 13);  ;; 初始化 x 为 13
    (odd 888)  ;; 调用 odd 过程，开始奇偶数判断
end
```

#### 解释：
- `x` 是一个共享的内存引用，用 `newref` 初始化为 0。通过 `deref(x)` 获取 `x` 的值，通过 `setref` 更新它。
- `even` 和 `odd` 两个过程通过修改 `x` 来共享状态，不直接依赖传入的参数。
- 整个程序的作用是通过递归调用 `even` 和 `odd`，最终判断 13 是否为奇数（返回 1）或偶数（返回 0）。

### 示例：创建隐藏状态的过程

接下来是一个通过引用保持隐藏状态的过程 `g`，它使用 `newref` 创建一个私有变量，记录 `g` 被调用的次数。

```scheme
let g = let counter = newref(0)  ;; 创建一个私有的计数器
in proc (dummy)
    begin
        setref(counter, -(deref(counter), -1));  ;; 计数器加 1
        deref(counter)  ;; 返回当前计数器的值
    end
in let a = (g 11)  ;; 第一次调用 g，返回 1
in let b = (g 11)  ;; 第二次调用 g，返回 2
in -(a,b)  ;; 返回 -1
```

#### 解释：
- 过程 `g` 内部的 `counter` 是一个共享状态，它在每次调用 `g` 时递增。由于 `counter` 是通过引用存储的，`g` 在每次调用时都能访问并更新它。
- `g` 的第一次调用返回 1，第二次调用返回 2，因此整个程序的值为 -1。

### EXPLICIT-REFS 中的嵌套引用

在 EXPLICIT-REFS 语言中，引用本身也是一种表达值，这意味着可以在一个位置存储另一个引用。例如：

```scheme
let x = newref(newref(0))  ;; 创建一个引用，指向另一个引用
in begin
    setref(deref(x), 11);  ;; 修改 x 所指的引用的内容
    deref(deref(x))  ;; 返回 x 所指的引用中的值
end
```

#### 解释：
- `x` 绑定到一个位置，这个位置存储着另一个位置的引用。通过 `deref(x)`，我们可以获取这个引用，并使用 `setref` 修改其内容。
- 最终 `deref(deref(x))` 返回存储在引用中的值，即 `11`。

### 练习 4.1 [⋆]：如果交换 `newref` 和 `proc` 的位置

假设我们将 `newref` 和 `proc` 的位置进行交换：

```scheme
let g = proc (dummy)  ;; 创建一个过程
          let counter = newref(0)  ;; 在过程体内创建计数器
          in begin
              setref(counter, -(deref(counter), -1));
              deref(counter)
          end
in let a = (g 11)
in let b = (g 11)
in -(a,b)
```

#### 解释：
- 在这种情况下，`counter` 在每次调用 `g` 时都会重新创建。这意味着每次调用 `g` 都会有一个新的计数器，因此 `a` 和 `b` 都会是 1。
- 最终的结果是 `-(a,b)` 等于 0，因为 `a` 和 `b` 都是 1。

### 总结

显式引用语言通过将引用作为表达值的一部分，引入了新的共享和修改状态的方式。通过 `newref`、`deref` 和 `setref`，程序可以在不同的过程之间共享数据，实现如递归、共享状态、隐藏信息等功能。这种共享机制在解决复杂问题时非常有用，但也带来了副作用和调试上的挑战。



### -----------------------------------------

### 4.2.1 存储器传递规范 (Store-Passing Specifications)

在 **EXPLICIT-REFS** 语言中，每个表达式都可能产生效果，即修改存储器 (store)。为了描述这种效果的行为，我们需要定义每次求值时使用的存储器以及求值后存储器的变化。

#### 存储器 (Store)

存储器是一种从**位置 (location)** 到**值 (value)** 的映射。我们用 $σ$ 表示任意存储器状态，用 $[l = v]σ$ 表示更新后的存储器，其中位置 $l$ 被映射到值 $v$，而其他位置的值与存储器 $σ$ 保持不变。$σ$ 的具体内容称为**存储器的状态 (state)**。

#### 存储器传递规范

在存储器传递规范中，存储器 $σ$ 作为参数传递给 `value-of` 函数，并且在计算后返回可能被修改的存储器状态。

#### 基本操作的规范

我们通过以下方式描述表达式的求值如何影响存储器。假设 `value-of` 是求值函数，它接收一个表达式、一个环境 $ρ$，以及当前存储器状态 $σ_0$。`value-of` 返回两个结果：一个是表达式的值 $val_1$，另一个是可能被修改的存储器状态 $σ_1$。我们可以写成：

$$
(value-of \ exp1 \ ρ \ σ_0) = (val_1, σ_1)
$$

这个等式断言，当环境为 $ρ$，存储器状态为 $σ_0$ 时，表达式 $exp1$ 的结果是 $val_1$，同时将存储器状态修改为 $σ_1$。

对于一些**无效果操作 (effect-free operations)**，如常量表达式 `const-exp`，存储器不会发生变化：

$$
(value-of \ (const-exp \ n) \ ρ \ σ) = (n, σ)
$$

这里，`const-exp` 的值为常量 $n$，而存储器状态保持不变。

#### 差值表达式 (diff-exp) 的存储器传递

差值表达式 `diff-exp` 展示了如何处理有顺序的操作。假设我们有两个表达式 `exp1` 和 `exp2`，并且每个表达式都可能修改存储器。我们依次求解这两个表达式，并更新存储器。

1. 首先，求解 $exp1$，存储器从初始状态 $σ_0$ 变为 $σ_1$，结果值为 $val_1$：
   $$
   (value-of \ (exp1) \ ρ \ σ_0) = (val_1, σ_1)
   $$

2. 接着，使用更新后的存储器 $σ_1$，求解 $exp2$，并将存储器状态更新为 $σ_2$，结果为 $val_2$：
   $$
   (value-of \ (exp2) \ ρ \ σ_1) = (val_2, σ_2)
   $$

3. 最后，差值表达式 `diff-exp` 的结果是 $val_1 - val_2$，存储器状态保持为 $σ_2$：
   $$
   (value-of \ (diff-exp \ exp1 \ exp2) \ ρ \ σ_0) = (\lceil \lfloor val_1 \rfloor - \lfloor val_2 \rfloor \rceil, σ_2)
   $$

#### 条件表达式 (if-exp) 的存储器传递

条件表达式 `if-exp` 的存储器传递稍微复杂一些，因为它有两个分支，选择哪个分支取决于条件表达式的值。

1. 首先，求解条件表达式 `exp1`，结果值为 $val_1$，并将存储器状态修改为 $σ_1$：
   $$
   (value-of \ (exp1) \ ρ \ σ_0) = (val_1, σ_1)
   $$

2. 接下来，根据 $val_1$ 的值选择分支：
   - 如果 $val_1$ 的布尔值为 $true$，则求解 `exp2`：
     $$
     (value-of \ (if-exp \ exp1 \ exp2 \ exp3) \ ρ \ σ_0) = (value-of \ exp2 \ ρ \ σ_1) \quad \text{if} \ (expval->bool \ val_1) = true
     $$
   - 如果 $val_1$ 的布尔值为 $false$，则求解 `exp3`：
     $$
     (value-of \ (if-exp \ exp1 \ exp2 \ exp3) \ ρ \ σ_0) = (value-of \ exp3 \ ρ \ σ_1) \quad \text{if} \ (expval->bool \ val_1) = false
     $$

### 总结

**存储器传递规范**提供了一种清晰的方式来描述计算中的状态变化。每个表达式的求值不仅会返回一个值，还会可能修改存储器状态。通过这种规范，我们能够系统地处理显式引用语言中的状态更新问题，同时保持对计算过程的精确描述。这种方法在引入有状态的计算模型时尤其有用，因为它允许我们显式地追踪计算对存储器的影响。

### -----------------------------------------

### 练习 4.2 [⋆] 写出 `zero?-exp` 的规范

`zero?-exp` 用来判断一个表达式的值是否为 0，返回布尔值。其存储器规范如下：

1. 首先，求解表达式 `exp1`，返回值 `val1` 和可能修改的存储器状态 `σ1`：
   $$
   (value-of \ (exp1) \ ρ \ σ_0) = (val_1, σ_1)
   $$

2. 如果 `val1` 是 0，则返回布尔值 `#t`，否则返回 `#f`，存储器状态保持为 `σ1`：
   $$
   (value-of \ (zero?-exp \ exp1) \ ρ \ σ_0)
   =
   \begin{cases}
   (\text{bool-val} \#t, σ_1) & \text{if} \ val_1 = 0 \\
   (\text{bool-val} \#f, σ_1) & \text{if} \ val_1 \neq 0
   \end{cases}
   $$

### 练习 4.3 [⋆] 写出 `call-exp` 的规范

`call-exp` 用于过程调用。假设 `call-exp` 调用一个过程 `rator`，传递一个参数 `rand`，其规范如下：

1. 首先，求解操作符 `rator`，得到的结果是一个过程 `proc1`，存储器状态变为 `σ1`：
   $$
   (value-of \ (rator) \ ρ \ σ_0) = (proc_1, σ_1)
   $$

2. 然后，求解操作数 `rand`，返回值 `val2`，存储器状态变为 `σ2`：
   $$
   (value-of \ (rand) \ ρ \ σ_1) = (val_2, σ_2)
   $$

3. 最后，调用过程 `proc1`，传入 `val2` 作为参数，得到最终结果 `val3` 和最终的存储器状态 `σ3`：
   $$
   (apply-procedure \ proc_1 \ val_2) = (val_3, σ_3)
   $$

4. 总体规范为：
   $$
   (value-of \ (call-exp \ rator \ rand) \ ρ \ σ_0) = (val_3, σ_3)
   $$

### 练习 4.4 [⋆⋆] 写出 `begin` 表达式的规范

`begin` 表达式依次求解多个表达式，并返回最后一个表达式的值。其规范如下：

1. 首先，依次求解每个表达式，并更新存储器：
   - 求解第一个表达式 `exp1`，返回值 `val1`，更新存储器状态为 `σ1`：
     $$
     (value-of \ (exp1) \ ρ \ σ_0) = (val_1, σ_1)
     $$
   - 接着求解 `exp2`，更新存储器状态为 `σ2`：
     $$
     (value-of \ (exp2) \ ρ \ σ_1) = (val_2, σ_2)
     $$
   - 继续求解其他表达式，依次更新存储器状态，直到最后一个表达式。

2. 最后，求解最后一个表达式 `exp_n`，返回结果 `val_n` 和最终的存储器状态 `σ_n`：
   $$
   (value-of \ (exp_n) \ ρ \ σ_{n-1}) = (val_n, σ_n)
   $$

3. `begin` 表达式的总体规范为：
   $$
   (value-of \ (begin \ exp1 \ ; \ exp2 \ ; \ ... \ ; \ exp_n) \ ρ \ σ_0) = (val_n, σ_n)
   $$

### 练习 4.5 [⋆⋆] 写出 `list` (ex3.10) 的规范

`list` 操作符接受任意数量的参数，并返回一个包含这些参数值的列表。其规范如下：

1. 首先，依次求解每个参数表达式 `exp1, exp2, ... exp_n`，并依次更新存储器状态：
   $$
   (value-of \ exp1 \ ρ \ σ_0) = (val_1, σ_1)
   $$
   $$
   (value-of \ exp2 \ ρ \ σ_1) = (val_2, σ_2)
   $$
   $$
   ...
   $$
   $$
   (value-of \ exp_n \ ρ \ σ_{n-1}) = (val_n, σ_n)
   $$

2. 将所有参数的值 `val1, val2, ... val_n` 组合成一个列表 `list-val`，最终返回该列表和最后的存储器状态：
   $$
   (list-val = (val_1, val_2, ..., val_n), σ_n)
   $$

3. 总体规范为：
   $$
   (value-of \ (list \ exp1 \ exp2 \ ... \ exp_n) \ ρ \ σ_0) = (list-val, σ_n)
   $$

### -----------------------------------------

### 4.2.2 定义显式引用操作 (EXPLICIT-REFS: Defining Explicit Reference Operations)

在 **EXPLICIT-REFS** 中，三种主要操作用于处理引用 (reference) 和存储器 (store)：`newref`、`deref` 和 `setref`。它们的语法如下：

- **newref**：分配一个新位置并返回其引用。
- **deref**：解引用，即获取引用指向位置处的内容。
- **setref**：将某个值存储到引用指向的位置。

下面我们详细说明它们的规范和行为。

#### `newref` 操作的规范

**语法：**

```scheme
Expression ::= newref (Expression)
newref-exp (exp1)
```

**行为：**

`newref-exp` 操作分配一个新的内存位置，并将表达式 `exp1` 的值存储在该位置中。存储器更新后，返回这个新位置的引用。

1. 先求解表达式 `exp1`，获取其值 `val` 和存储器的状态 `σ1`：
   $$
   (value-of \ exp1 \ ρ \ σ_0) = (val, \ σ_1)
   $$

2. 分配一个新的位置 $l$，并将 $val$ 存入该位置，返回引用 `ref-val l` 和更新后的存储器 `[l = val] \ σ_1`：
   $$
   (value-of \ (newref-exp \ exp1) \ ρ \ σ_0) = (\text{ref-val} \ l, [l=val] \ σ_1)
   $$

   其中 $l$ 是一个新的内存位置，不在 $σ_1$ 的定义域内。

#### `deref` 操作的规范

**语法：**

```scheme
Expression ::= deref (Expression)
deref-exp (exp1)
```

**行为：**

`deref-exp` 操作取一个引用并返回该引用指向的位置的值。

1. 先求解表达式 `exp1`，获取其值 `val` 和存储器状态 `σ1`：
   $$
   (value-of \ exp1 \ ρ \ σ_0) = (val, \ σ_1)
   $$

2. `exp1` 的值必须是一个位置引用 `l`。`deref-exp` 返回存储器状态 $σ_1$ 中位置 $l$ 的内容：
   $$
   (value-of \ (deref-exp \ exp1) \ ρ \ σ_0) = (\sigma_1(l), \ σ_1)
   $$

   存储器状态 $σ_1$ 保持不变。

#### `setref` 操作的规范

**语法：**

```scheme
Expression ::= setref (Expression , Expression)
setref-exp (exp1 exp2)
```

**行为：**

`setref-exp` 操作首先获取表达式 `exp1` 的值，该值是一个位置引用 $l$，然后获取 `exp2` 的值并将其存入位置 $l$。

1. 先求解表达式 `exp1`，得到位置引用 `l` 和存储器状态 $σ_1$：
   $$
   (value-of \ exp1 \ ρ \ σ_0) = (l, \ σ_1)
   $$

2. 接着，求解表达式 `exp2`，获取其值 `val` 和存储器状态 $σ_2$：
   $$
   (value-of \ exp2 \ ρ \ σ_1) = (val, \ σ_2)
   $$

3. 将 `val` 存入位置 $l$，更新存储器，并返回常量值 $23$ 表示求效果而非求值：
   $$
   (value-of \ (setref-exp \ exp1 \ exp2) \ ρ \ σ_0) = (\lceil 23 \rceil, [l = val] \ σ_2)
   $$

---

### 练习 4.6 [⋆] 修改 `setref-exp` 规则，让它返回右边表达式的值

如果我们希望 `setref-exp` 返回右边表达式的值 `val` 而不是常量 $23$，我们可以修改返回值的部分：

$$
(value-of \ (setref-exp \ exp1 \ exp2) \ ρ \ σ_0) = (val, [l = val] \ σ_2)
$$

这样，`setref-exp` 返回 `exp2` 的求值结果，并更新存储器。

---

### 练习 4.7 [⋆] 修改 `setref-exp` 规则，让它返回位置的原内容

如果我们希望 `setref-exp` 返回位置 $l$ 的原内容而不是常量 $23$，我们需要在更新存储器之前先保存原内容 `old-val`，然后返回它：

1. 在求解 `exp1` 后，获取位置 $l$ 并从存储器中取出 `old-val`：
   $$
   old\_val = σ_1(l)
   $$

2. 将 `val` 存入位置 $l$，并返回 `old-val`：

$$
(value-of \ (setref-exp \ exp1 \ exp2) \ ρ \ σ_0) = (old\_val, [l = val] \ σ_2)
$$

这样，`setref-exp` 会返回更新前位置 $l$ 的原内容。

### -----------------------------------------

### 4.2.3 实现显式引用操作 (Implementation of Explicit References)

在本节中，我们实现了 **EXPLICIT-REFS**，一个带有显式引用的语言。为了模拟存储器的行为，我们采用了一个简单的存储器模型，并使用 **Scheme** 中的全局变量来跟踪存储器状态。存储器中的每个位置存储一个值，而位置是通过引用来访问的。

我们不再像规范语言那样将存储器传递和返回，而是通过全局变量 **the-store** 记录存储器的状态，并对其进行操作。这一实现虽然低效，但可以模拟出语言中的存储器行为。接下来我们详细介绍代码实现和它的行为。

#### 存储器模型的实现

1. **存储器的定义**：
   存储器被实现为一个 **Scheme** 列表，其中的每个元素是存储的值。引用是一个整数，表示列表中的位置。通过列表索引可以获得或更新存储器中的值。

2. **全局变量存储器**：
   存储器的当前状态通过全局变量 **the-store** 存储。所有存储器相关的操作都将影响这个全局变量。

```scheme
;; 全局变量，用于保存存储器的当前状态
(define the-store 'uninitialized)

;; 获取存储器的当前状态
(define get-store
  (lambda ()
    the-store))

;; 初始化存储器为空
(define initialize-store!
  (lambda ()
    (set! the-store (empty-store))))

;; 存储器的初始状态为空列表
(define empty-store
  (lambda () '()))
```

#### 实现 `newref`, `deref`, 和 `setref`

##### 1. `newref`: 分配新引用
**`newref`** 负责在存储器中创建一个新位置，并将值存储到该位置。它通过在 **the-store** 列表末尾追加新值来实现。返回的引用是列表中新值的位置。

```scheme
;; newref: 为新值分配存储器位置并返回引用
(define newref
  (lambda (val)
    (let ((next-ref (length the-store)))  ;; 获取当前存储器长度作为新位置
      (set! the-store (append the-store (list val)))  ;; 将新值附加到存储器末尾
      next-ref)))  ;; 返回新位置的引用
```

##### 2. `deref`: 解引用
**`deref`** 获取一个引用，并返回该引用指向的位置的值。它通过列表索引（使用 **list-ref** 函数）从存储器中取出对应位置的值。

```scheme
;; deref: 获取引用指向位置的值
(define deref
  (lambda (ref)
    (list-ref the-store ref)))  ;; 通过索引获取存储器中对应位置的值
```

##### 3. `setref`: 设置引用值
**`setref!`** 用于更新存储器中的某个位置的值。它将新值存入指定的引用指向的位置。实现上，它通过递归遍历列表，将指定位置的值替换为新值。

```scheme
;; setref!: 将新值设置到指定的存储器位置
(define setref!
  (lambda (ref val)
    (set! the-store
      (letrec ((setref-inner
                 ;; 内部递归函数，用于更新存储器中指定位置的值
                 (lambda (store1 ref1)
                   (cond
                     ((null? store1)  ;; 如果位置无效，则报告错误
                      (report-invalid-reference ref the-store))
                     ((zero? ref1)  ;; 找到指定位置
                      (cons val (cdr store1)))  ;; 将新值放入该位置
                     (else  ;; 递归地处理存储器中的其他位置
                      (cons (car store1)
                            (setref-inner (cdr store1) (- ref1 1))))))))
        (setref-inner the-store ref)))))
```

#### `value-of-program` 过程的修改

`value-of-program` 是程序的求值入口。每次运行程序时，存储器会被初始化为空，并在程序执行时动态更新。

```scheme
;; value-of-program: 初始化存储器并开始求值程序
(define value-of-program
  (lambda (pgm)
    (initialize-store!)  ;; 初始化存储器
    (cases program pgm
      (a-program (exp1)
        (value-of exp1 (init-env))))))
```

#### 总结

在这个简单的存储器模型中，我们通过全局变量 **the-store** 来模拟存储器，并用列表来表示存储器状态。每次对引用的操作（如创建、获取和设置）都通过对列表的操作来实现，虽然效率较低，但能准确反映存储器效果。通过这些操作，我们实现了语言中的显式引用，并展示了如何通过共享存储器在不同函数或过程间传递状态。

#### 示例

例如，在实现了这些存储器操作后，我们可以运行这样的程序：

```scheme
let x = newref(newref(0))
in begin
  setref(deref(x), 11);
  deref(deref(x))
end
```

这段代码创建了一个引用指向另一个引用，并修改了存储器中嵌套的值。

### -----------------------------------------

### 4.2.3 实现显式引用操作：存储器模型的实现

在本节中，我们使用 **Scheme** 实现了显式引用语言 (**EXPLICIT-REFS**)，该语言支持创建和使用引用。为了模拟存储器，我们设计了一个存储器模型，并用 **Scheme** 的全局变量来模拟内存。虽然我们只在代码中使用一个全局存储器，但这种模型帮助我们实现了带有副作用（effect）的操作，例如内存读取和写入。

#### 核心思想

1. **存储器（Store）** 被表示为一个列表，每个元素代表存储器中的一个位置，可以存储某个值。
2. **引用（Reference）** 被实现为整数，它表示存储器列表中的索引位置。
3. **全局变量** `the-store` 保存当前的存储器状态。所有存储器的操作都基于它。
4. **操作**：我们定义了 `newref`, `deref`, 和 `setref!` 三个主要操作，用于创建新引用、解引用和更新引用。

#### 存储器的实现

我们通过下列代码实现了存储器操作：

```scheme
;; 初始化存储器为空列表
(define empty-store
  (lambda () '()))

;; 全局变量，用于保存存储器的当前状态
(define the-store 'uninitialized)

;; 获取当前存储器的状态
(define get-store
  (lambda () the-store))

;; 初始化存储器为新状态（即空列表）
(define initialize-store!
  (lambda ()
    (set! the-store (empty-store))))
```

这些过程实现了存储器的基本结构，并且允许我们通过全局变量 `the-store` 管理存储器的当前状态。

#### 引用操作的实现

##### 1. **newref**：分配新的引用
`newref` 负责创建一个新的存储器位置，并将其引用返回。它通过计算存储器列表的长度来确定新位置，并将新值附加到列表末尾。

```scheme
;; newref: 为新值分配存储器位置并返回引用
(define newref
  (lambda (val)
    (let ((next-ref (length the-store)))  ;; 新的位置是存储器的末尾
      (set! the-store (append the-store (list val)))  ;; 将值添加到存储器末尾
      next-ref)))  ;; 返回新的引用（即存储器的位置）
```

##### 2. **deref**：解引用
`deref` 通过传入的引用（即整数索引）查找存储器中的值。它使用 `list-ref` 函数从存储器中获取引用所指向的值。

```scheme
;; deref: 通过引用获取存储器位置的值
(define deref
  (lambda (ref)
    (list-ref the-store ref)))  ;; 从存储器中取出引用位置的值
```

##### 3. **setref!**：更新引用
`setref!` 将新的值存储到引用所指向的存储器位置。它递归遍历存储器列表，并在指定位置替换原有的值。

```scheme
;; setref!: 将新值存入引用位置
(define setref!
  (lambda (ref val)
    (set! the-store
      (letrec ((setref-inner
                 ;; 内部递归函数，用于更新存储器中指定位置的值
                 (lambda (store1 ref1)
                   (cond
                     ((null? store1)
                      (report-invalid-reference ref the-store))
                     ((zero? ref1)
                      (cons val (cdr store1)))  ;; 在找到的位置更新值
                     (else
                      (cons (car store1)
                            (setref-inner (cdr store1) (- ref1 1))))))))
        (setref-inner the-store ref)))))
```

#### 代码执行流程

每次程序运行时，首先调用 **`value-of-program`**，在其中初始化存储器为空，并开始求值程序。

```scheme
;; 初始化存储器并开始求值程序
(define value-of-program
  (lambda (pgm)
    (initialize-store!)  ;; 初始化存储器为空列表
    (cases program pgm
      (a-program (exp1)
        (value-of exp1 (init-env))))))
```

#### 示例程序

通过定义这些操作，我们可以处理如下的例子：

```scheme
let x = newref(newref(0))
in begin
  setref(deref(x), 11);  ;; 更新存储器的值
  deref(deref(x))  ;; 解引用，获取更新后的值
end
```

**解释：**
1. `newref(0)` 创建了一个新的存储器位置，初始值为 0。
2. `newref(newref(0))` 创建了另一个存储器位置，存储的是一个指向第一个位置的引用。
3. `setref(deref(x), 11)` 通过 `deref` 获取第一个位置的引用，并将其更新为 11。
4. `deref(deref(x))` 最终返回更新后的值 11。

#### 总结

通过这种简单的存储器模型，我们实现了对引用的操作。尽管这种实现相对低效，但它准确地模拟了引用和存储器的行为，展示了如何在编程语言中通过全局存储器处理状态和副作用。这些操作为进一步的语言扩展奠定了基础，比如支持复杂的状态管理和共享数据结构。

### -----------------------------------------

在 4.2.3 中，我们进一步讨论了显式引用语言 **EXPLICIT-REFS** 的实现，主要涉及如何在编程语言中处理内存操作的规范以及 Scheme 实现。接下来，我们将分析通过 Scheme 如何实现显式引用，并且探讨求值过程中的跟踪日志，以及传递存储器的解释器实现。

### 1. **显式引用操作语句的实现**

我们需要为 `newref-exp`, `deref-exp`, 和 `setref-exp` 实现相应的 Scheme 代码，这些操作涉及如何创建、解引用和更新存储器中的位置。

#### **newref-exp** 实现

`newref-exp` 创建一个新的存储器位置，并返回该位置的引用。

```scheme
(newref-exp
  (exp1)
  (let ((v1 (value-of exp1 env)))  ;; 求出操作数的值
    (ref-val (newref v1))))  ;; 创建引用，存储在新的位置
```

这个实现中，`value-of` 计算表达式 `exp1` 的值，接着通过 `newref` 分配一个新的存储器位置，并将值存储在该位置。最终返回该位置的引用。

#### **deref-exp** 实现

`deref-exp` 通过引用获取存储器中相应位置的值。

```scheme
(deref-exp
  (exp1)
  (let ((v1 (value-of exp1 env)))  ;; 求出操作数的值
    (let ((ref1 (expval->ref v1)))  ;; 将表达值转换为引用
      (deref ref1))))  ;; 通过引用解引用存储器中的值
```

这里，我们通过 `expval->ref` 提取表达值中的引用，然后通过 `deref` 从存储器中解引用该位置的值。

#### **setref-exp** 实现

`setref-exp` 更新引用所指向的位置内容。

```scheme
(setref-exp
  (exp1 exp2)
  (let ((ref (expval->ref (value-of exp1 env))))  ;; 提取引用
    (let ((val2 (value-of exp2 env)))  ;; 计算要存储的新值
      (begin
        (setref! ref val2)  ;; 更新引用位置的值
        (num-val 23)))))  ;; 返回任意值，示意操作成功
```

在这个实现中，`setref-exp` 首先计算两个操作数的值。第一个操作数必须是一个引用，`setref!` 将第二个操作数的值存储在该引用所指向的位置。这里为了突出随意性，返回了数值 23。

### 2. **求值跟踪日志**

图 4.4 和 4.5 给出了求值跟踪日志，它展示了表达式 `let x = newref(22) ...` 的执行过程。在这个过程中，我们可以看到 `newref`、`deref` 和 `setref!` 是如何作用于存储器的。以下是日志的解释：

- `newref(22)` 分配了位置 0，并将 `22` 存储在该位置。
- `let f = proc (z)` 创建了一个过程 `f`，该过程会创建一个新的存储器位置 `zz`，并通过解引用 `x` 来计算新的值。
- `setref!` 修改了存储器中的值，`f` 的调用通过对位置 `x` 的解引用和设置来更新存储器。

这些日志显示了存储器中值的变化及其操作顺序。

### 3. **传递存储器的解释器**

图 4.6 展示了带有显式存储器传递的解释器实现。我们使用 `answer` 数据类型来捕获求值的结果和更新后的存储器状态。

#### **answer 数据类型定义**

```scheme
(define-datatype answer answer?
  (an-answer
    (val exp-val?)  ;; 表达式求值的结果
    (store store?)))  ;; 存储器的当前状态
```

`answer` 类型包含了两个重要的部分：`val` 是求值结果，`store` 是求值后的存储器状态。

#### **value-of 函数**

```scheme
(value-of : Exp × Env × Sto → ExpVal)
(define value-of
  (lambda (exp env store)
    (cases expression exp
      (const-exp (num)
        (an-answer (num-val num) store))  ;; 返回常量表达式结果，不修改存储器
      (var-exp (var)
        (an-answer
          (apply-store store (apply-env env var))  ;; 查询环境中的变量
          store))
      ;; if 表达式处理
      (if-exp (exp1 exp2 exp3)
        (cases answer (value-of exp1 env store)  ;; 先计算条件
          (an-answer (val new-store)
            (if (expval->bool val)  ;; 判断条件的结果
                (value-of exp2 env new-store)  ;; 条件为真，计算 exp2
                (value-of exp3 env new-store))))))  ;; 条件为假，计算 exp3
      ;; deref-exp 处理
      (deref-exp (exp1)
        (cases answer (value-of exp1 env store)
          (an-answer (v1 new-store)
            (let ((ref1 (expval->ref v1)))
              (an-answer (deref ref1) new-store)))))  ;; 返回解引用的值
      ...)))
```

#### **解释器说明**

在解释器中，`value-of` 函数负责递归求值，并传递存储器状态。每个表达式在求值时都接收当前的存储器状态，并返回结果以及新的存储器状态。以下是不同表达式的处理逻辑：
- **`const-exp`**：常量表达式不修改存储器，直接返回结果。
- **`var-exp`**：变量表达式从环境中获取变量的值，并返回当前的存储器状态。
- **`if-exp`**：先计算条件表达式的值，根据其结果来决定是执行 `exp2` 还是 `exp3`，并且将更新的存储器传递下去。
- **`deref-exp`**：计算 `exp1`，将其结果作为引用进行解引用操作，并返回存储器中的值。

### 总结

在这一节中，我们通过 Scheme 实现了显式引用语言的基本操作，并展示了存储器在求值过程中的应用。通过全局存储器模型，我们能够准确模拟带有副作用的操作，如引用分配、解引用和更新。此外，传递存储器的解释器帮助我们了解如何在程序中处理存储器的状态变化。

### -----------------------------------------

### 练习 4.8 [⋆] 指出我们实现的存储器中，到底是哪些操作花费了线性时间而非常数时间

在我们之前的实现中，以下操作花费了线性时间：

1. **newref**: 新的引用通过在存储器列表的末尾添加一个新值来完成，这涉及复制整个存储器列表，导致时间复杂度为 $O(n)$，其中 $n$ 是存储器的大小。
   
   ```scheme
   (define newref
     (lambda (val)
       (let ((next-ref (length the-store))) ; 计算当前存储器长度
         (set! the-store (append the-store (list val))) ; 在末尾添加新元素，需复制整个存储器
         next-ref)))
   ```
   
2. **setref!**: 我们实现的 `setref!` 通过递归地构建一个新列表并替换目标位置的值。这种操作对于更新位置在存储器末尾的元素时，会导致线性时间的复杂度，因为需要遍历列表。

   ```scheme
   (define setref!
     (lambda (ref val)
       (set! the-store
         (letrec ((setref-inner
                     (lambda (store1 ref1)
                       (cond
                         ((null? store1)
                          (report-invalid-reference ref the-store))
                         ((zero? ref1)
                          (cons val (cdr store1))) ; 替换目标位置的值
                         (else
                          (cons (car store1)
                                (setref-inner (cdr store1) (- ref1 1))))))))
           (setref-inner the-store ref)))))
   ```

3. **deref**: 尽管 `deref` 操作的复杂度通常是常数时间，但在我们使用列表来表示存储器的实现中，解引用操作会随着存储器的增长线性增加，因为需要遍历列表直到找到正确的位置。

   ```scheme
   (define deref
     (lambda (ref)
       (list-ref the-store ref)))  ; 通过遍历获取引用处的值
   ```

### 练习 4.9 [⋆] 用 Scheme 向量表示存储器，从而实现常数时间操作。用这种表示会失去什么？

使用向量表示存储器可以将操作（如 `newref`、`setref!` 和 `deref`）的复杂度降低为常数时间 $O(1)$，因为向量允许在常数时间内访问或更新其元素。

#### 实现：

我们可以用 Scheme 的向量取代列表：

```scheme
(define the-store 'uninitialized)

(define initialize-store!
  (lambda ()
    (set! the-store (make-vector 10 'empty))))  ; 创建一个初始大小为 10 的空向量

(define newref
  (lambda (val)
    (let ((next-ref (vector-length the-store)))
      (vector-set! the-store next-ref val)  ; 在向量中存储新值
      next-ref)))

(define deref
  (lambda (ref)
    (vector-ref the-store ref)))  ; 直接访问向量元素

(define setref!
  (lambda (ref val)
    (vector-set! the-store ref val)))  ; 直接更新向量中的值
```

#### 失去的东西：

1. **动态扩展**：向量是定长的，如果存储器超出当前大小，就需要手动扩展向量。而扩展向量通常需要复制整个向量到一个更大的新向量中，这会产生潜在的性能瓶颈。

2. **内存消耗**：与列表相比，向量通常在初始化时就分配了固定大小的内存，因此可能会占用多余的空间，即使其中一部分向量是未使用的。

### 练习 4.10 [⋆] 实现 {ex4.4} 中定义的 `begin` 表达式

`begin` 表达式按顺序计算所有的子表达式，并返回最后一个子表达式的值。

#### 实现：

我们首先为 `begin` 表达式定义语法，并扩展解释器：

```scheme
(define-datatype expression expression?
  ;; 定义 begin 表达式
  (begin-exp
    (exp-list (list-of expression?))))

;; 修改解释器以处理 begin 表达式
(define value-of
  (lambda (exp env)
    (cases expression exp
      (begin-exp (exp-list)
        (let loop ((exps exp-list)
                   (env env)
                   (store the-store))
          (if (null? (cdr exps))  ; 如果是最后一个表达式
              (value-of (car exps) env)  ; 计算并返回最后一个表达式
              (begin
                (value-of (car exps) env)  ; 计算并忽略前面的表达式
                (loop (cdr exps) env store)))))))))
```

#### 解释：

1. `begin-exp` 包含一系列表达式，存储在 `exp-list` 中。
2. 在解释器中，我们递归计算 `exp-list` 中的每一个表达式，忽略前面的结果，只返回最后一个表达式的值。
3. `loop` 函数递归地计算每个表达式，直到只剩下一个表达式作为最后一个返回。

### 练习 4.11 [⋆] 实现 ex4.5 中的 `list`

`list` 是一个表达式，它接受多个参数并返回包含这些参数的列表。

#### 实现：

我们可以将 `list` 作为一系列表达式来计算，并将它们组合成一个 Scheme 列表。

```scheme
(define-datatype expression expression?
  (list-exp
    (exp-list (list-of expression?))))

;; 修改解释器以处理 list 表达式
(define value-of
  (lambda (exp env)
    (cases expression exp
      (list-exp (exp-list)
        (let loop ((exps exp-list)
                   (env env)
                   (acc '()))
          (if (null? exps)
              (reverse acc)  ; 返回倒序的累加结果
              (let ((val (value-of (car exps) env)))
                (loop (cdr exps) env (cons val acc)))))))))
```

#### 解释：

1. `list-exp` 包含一系列表达式，存储在 `exp-list` 中。
2. `loop` 函数递归地计算每个表达式的值，并将其累加到 `acc` 列表中。
3. 当所有表达式计算完成后，返回一个包含所有计算结果的列表。

### 练习 4.12 [⋆⋆⋆] 实现传递存储器的解释器

为了避免依赖 Scheme 的全局存储器，我们可以在解释器中使用显式的存储器传递，处理整个 EXPLICIT-REFS 语言。

```scheme
(define-datatype answer answer?
  (an-answer
   (val exp-val?)
   (store store?)))

(define value-of
  (lambda (exp env store)
    (cases expression exp
      (const-exp (num)
        (an-answer (num-val num) store))
      (var-exp (var)
        (an-answer (apply-env env var) store))
      (if-exp (exp1 exp2 exp3)
        (cases answer (value-of exp1 env store)
          (an-answer (val1 store1)
            (if (expval->bool val1)
                (value-of exp2 env store1)
                (value-of exp3 env store1)))))
      (newref-exp (exp1)
        (cases answer (value-of exp1 env store)
          (an-answer (val1 store1)
            (let ((ref (newref val1 store1)))
              (an-answer (ref-val ref) store1)))))
      ;; 更多操作...
      )))
```

#### 解释：

1. `an-answer` 包含了表达式的值和存储器。
2. 每次计算 `value-of` 时，都会返回一个包含值和新存储器的 `answer`。
3. 在传递存储器的情况下，每个表达式操作存储器并传递给下一个表达式。

### 练习 4.13 [⋆⋆⋆] 扩展前一道练习中的解释器，支持多参数过程

为了支持多参数过程，我们需要修改解释器，使其能够处理多个形参和多个实参。我们需要修改如下内容：

1. **扩展语法**：修改 `proc-exp` 和 `call-exp`，以支持多参数的过程定义和调用。
2. **修改解释器**：在 `value-of` 中处理带多个参数的过程定义和调用。

#### 1. 修改语法：

首先，我们修改过程定义和调用的语法，以支持多个参数。

```scheme
(define-datatype expression expression?
  ;; 多参数过程定义
  (proc-exp
    (vars (list-of identifier?))  ; 形参列表
    (body expression?))           ; 过程主体
  ;; 多参数过程调用
  (call-exp
    (rator expression?)           ; 操作符
    (rands (list-of expression?))) ; 实参列表
  ...)
```

#### 2. 修改解释器：

为了处理多参数过程的定义和调用，我们需要在解释器中进行以下修改：

- **处理多参数的 `proc-exp`**：扩展 `proc-exp` 以支持多个形参，并将这些形参与实参在环境中正确绑定。
- **处理多参数的 `call-exp`**：修改 `call-exp`，从环境中提取实参，并将其逐个传递给形参。

```scheme
(define value-of
  (lambda (exp env store)
    (cases expression exp
      ;; 处理多参数的过程定义
      (proc-exp (vars body)
        ;; 返回一个新的过程，保存当前环境，并绑定形参
        (an-answer (proc-val (procedure vars body env)) store))

      ;; 处理多参数的过程调用
      (call-exp (rator rands)
        (cases answer (value-of rator env store)
          (an-answer (proc-val (procedure vars body saved-env)) store1)
            (let loop ((params vars)
                       (args rands)
                       (env2 saved-env)
                       (store2 store1))
              (if (null? params)
                  ;; 当所有参数绑定完成后，求过程主体的值
                  (value-of body env2 store2)
                  (let ((arg-val (value-of (car args) env store2)))
                    (cases answer arg-val
                      (an-answer (val new-store)
                        ;; 将参数与对应的值绑定到环境中
                        (loop (cdr params) (cdr args)
                              (extend-env (car params) val env2)
                              new-store)))))))))))

```

#### 解释：

1. **`proc-exp`**：我们修改了过程定义部分，现在允许多个参数。返回的 `procedure` 保存了当前环境，并将多个形参存储在 `vars` 中。
2. **`call-exp`**：过程调用部分对 `rands` 中的每个实参进行求值，然后通过 `loop` 将它们与对应的形参在环境中绑定。最后在扩展后的环境中计算过程的主体。

#### 3. 测试用例：

我们可以用以下测试代码来验证多参数过程是否正常工作：

```scheme
(run "
let f = proc (x y z) -(x, -(y, z))
in (f 10 5 2)
")
```

解释：

- 在这个例子中，定义了一个接受三个参数的过程 `f`，然后传递了 10、5 和 2 作为实参，返回的结果是 `10 - (5 - 2) = 7`。

---

### 关键点：

- **环境扩展**：多参数过程的关键在于将实参与形参正确绑定到环境中。通过递归 `loop`，我们确保在每次调用过程中，实参和形参都被逐一绑定到环境中。
- **存储器传递**：存储器在整个过程中被正确传递和修改，这确保了对存储器进行的任何修改（如 `newref`、`deref`）能够保持一致性。

---

这使得我们的解释器能够支持多参数过程，并且兼容之前实现的显式引用等功能。在多参数过程中，每个参数的绑定、求值以及存储器的传递都得到了有效处理。

### -----------------------------------------

在 **4.3 IMPLICIT-REFS：隐式引用语言** 中，讨论了一种与显式引用不同的语言设计方式。隐式引用语言中，引用的操作被隐藏在语言的内部逻辑中，程序员不需要显式地在代码中处理内存分配、解引用、或者位置变更等操作。这种设计更接近于现代编程语言的内存管理模式，例如 **Scheme** 和 **Java**，其中变量自动映射到内存位置，并且在需要时自动处理引用。

### 主要概念

1. **显式引用 (Explicit Reference)** 和 **隐式引用 (Implicit Reference)** 之间的区别在于：
   - 在显式引用设计中，程序员必须明确处理内存的分配和访问。
   - 在隐式引用设计中，语言自动处理内存管理，程序员不直接接触这些底层操作。

2. **按值调用 (Call-by-value)**: 
   - 在这种策略下，函数参数是实际值，而不是引用。这意味着，程序员定义的每一个变量，都指向内存中的某一位置，该位置存储实际的值。
   - 每次绑定操作，例如函数调用或者 `let` 绑定，都会分配新的内存位置。
   
3. **可变变量 (Mutable Variable)**:
   - 变量可以在程序运行期间通过 `set` 表达式修改它们的值，这也是常见的现代编程语言的特性。例如在 Scheme 或 Python 中，变量可以在初次赋值后重新赋值。

### 设计中的核心变化

1. **表达值 (ExpVal)** 不再包括引用。即，表达值只包括原始的类型，如 `Int`，`Bool`，`Proc`。
   - $$ \text{ExpVal} = \text{Int} + \text{Bool} + \text{Proc} $$
   
2. **指代值 (DenVal)** 则包含引用到表达值的位置：
   - $$ \text{DenVal} = \text{Ref}(\text{ExpVal}) $$
   
   这样，每个变量绑定实际上是内存中某个位置的引用。

3. **set 赋值表达式**：
   - 语法：`set Identifier = Expression`。
   - 当程序执行 `set` 表达式时，它修改了存储器中某个位置的值。
   
### 实例程序示例

例如，以下程序通过 `set` 赋值修改内存中的值：

```scheme
let x = 5
in begin
  set x = 10;
  x
end
```

- 在这个程序中，`x` 在初始化时被绑定到内存位置 `l`，并存储值 `5`。
- 当执行 `set x = 10` 时，程序会修改 `l` 处的值，将其从 `5` 变为 `10`，之后 `x` 将返回 `10`。

这个例子体现了隐式引用的核心特点：变量自动分配内存位置，修改变量时只需要操作标识符，底层的内存操作被自动处理。

### IMPLICIT-REFS 的实现

1. **存储器模型**:
   在这种设计中，每个变量都被分配了一个引用到内存中某一位置的指针。存储器继续以列表或数组的形式存在。

2. **`set` 表达式的实现**:
   - `assign-exp`：该表达式实现了修改变量绑定值的机制。程序在环境中找到标识符 `Identifier`，找到该标识符对应的内存位置，然后将新的值存储到该位置。

### 解释器中的变化

对于隐式引用语言，解释器的变化集中在处理变量的方式上：

1. **变量表达式**（`var-exp`）：
   - 当访问变量时，解释器不再直接返回变量的值，而是通过存储器查找它的位置。
   - 这就意味着在解释器中，`var-exp` 的求值过程涉及两个步骤：
     1. 先在环境中找到变量对应的位置。
     2. 在存储器中找到该位置的值并返回。

2. **赋值表达式**（`set`）：
   - 执行 `set` 表达式时，解释器需要先找到标识符对应的内存位置，再将新值写入该位置。

### 核心操作的伪代码实现

#### `set` 表达式

```scheme
(define (value-of-set exp env store)
  (let* ((var (assign-exp-var exp))         ; 找到要赋值的变量
         (new-val (value-of (assign-exp-exp exp) env store)) ; 计算新值
         (ref (apply-env env var)))         ; 找到变量对应的引用
    (setref! ref new-val store)             ; 更新存储器
    new-val))                               ; 返回新值
```

#### `var-exp` 表达式

```scheme
(define (value-of-var var-exp env store)
  (let* ((ref (apply-env env var-exp))      ; 找到变量对应的内存位置
         (val (deref ref store)))           ; 解引用得到变量的值
    val))                                   ; 返回变量的值
```

#### `let-exp` 表达式

```scheme
(define (value-of-let let-exp env store)
  (let* ((var (let-exp-var let-exp))         ; 解析出变量名
         (exp1 (let-exp-exp let-exp))        ; 解析出绑定表达式
         (val (value-of exp1 env store))     ; 求出表达式值
         (ref (newref val store)))           ; 分配新位置给该变量
    (value-of (let-exp-body let-exp)         ; 在新的环境下求值
               (extend-env var ref env)      ; 扩展环境，绑定新引用
               store)))
```

### 总结

在 **IMPLICIT-REFS** 设计中，语言通过隐藏底层内存操作，为程序员简化了变量管理的过程。这种设计允许变量变得可变，同时保证了内存管理的透明性。与显式引用设计相比，隐式引用更适合于高层次的编程语言，例如 Java 或 Python，简化了对内存的直接操作，但也带来了一些内存管理的复杂性，例如垃圾回收。



### -----------------------------------------

### 4.3.1 规范（IMPLICIT-REFS 隐式引用语言）

在 **IMPLICIT-REFS（隐式引用语言）** 中，变量绑定在存储器的位置上，而不是直接与值绑定。当变量作为表达式时，解释器首先解引用该变量，也就是说，它首先找到变量在环境中的位置，然后从存储器中检索该位置存储的值。

#### 解引用规则

当变量作为表达式时，规则如下：

$$
(value-of (var-exp\ var)\ ρ\ σ) = (σ(ρ(var)),σ)
$$

- 解释：`var-exp` 是变量表达式，表示变量名 `var`。`ρ` 是当前环境，`σ` 是当前存储器状态。
  - 首先，解释器使用 `ρ` 查找变量 `var` 对应的位置。
  - 然后，解释器从存储器 `σ` 中找到该位置的值。
  - 返回的结果是该位置的值和未修改的存储器状态 `σ`。

#### 赋值表达式（`set`）

赋值表达式通过两个步骤完成：首先在环境中查找变量名 `var`，找到其对应的内存位置。然后对右侧表达式 `exp1` 求值，并将结果存储在该位置上。

赋值规则如下：

$$
(value-of (assign-exp\ var\ exp1)\ ρ\ σ_0) = (\lceil 27\rceil, [ρ(var) = val_1]σ_1)
$$

- 解释：`assign-exp` 是赋值表达式，`var` 是左侧变量，`exp1` 是右侧的表达式。
  - 首先，对 `exp1` 求值，结果为 `val_1`，存储器状态变为 `σ_1`。
  - 通过 `ρ(var)` 查找到 `var` 在存储器中的位置，并将 `val_1` 存储在该位置上。
  - 最终的返回值是常量 `27`，表示赋值的返回值是任意的，我们选择返回 `27` 来表明这个赋值是为了产生效果，而不是关心值。

#### 过程调用的规则

在过程调用中，调用过程时，变量会被绑定到存储器中的某个位置。新的规则如下：

$$
(apply-procedure (procedure\ var\ body\ ρ)\ val\ σ) = (value-of\ body\ [var = l]ρ\ [l = val]σ)
$$

- 解释：当调用一个过程时，形参 `var` 被绑定到存储器中的新位置 `l`。`val` 是传递给过程的实际参数，它被存储在该位置 `l`。
- 然后，过程主体 `body` 在新的环境 `[var = l]ρ` 和更新的存储器 `[l = val]σ` 中进行求值。

#### `let` 表达式的规则

`let` 表达式的求值需要先求出右边的表达式 `exp1`，将其结果存储在新的内存位置上，然后将变量 `var` 绑定到该内存位置，并在扩展的环境中求值 `let` 主体。

规则如下：

1. 对 `exp1` 求值，得到 `val_1` 和新存储器状态 `σ_1`。
2. 创建一个新的位置 `l`，并将 `val_1` 存储在位置 `l`。
3. 扩展环境，将 `var` 绑定到 `l`。
4. 在扩展后的环境和存储器中对 `body` 进行求值。

练习 4.14 要求写出 `let` 表达式的具体规则：

$$
(value-of\ (let-exp\ var\ exp1\ body)\ ρ\ σ_0) = (value-of\ body\ [var = l]ρ\ [l = val_1]σ_1)
$$

- 解释：
  - 对 `exp1` 在环境 `ρ` 和存储器 `σ_0` 中求值，得到值 `val_1` 和新的存储器状态 `σ_1`。
  - 将 `val_1` 存储在新的位置 `l` 中。
  - 扩展环境 `ρ`，将 `var` 绑定到 `l`。
  - 在扩展的环境和更新后的存储器中对 `body` 进行求值，得到最终的结果。

### 总结

IMPLICIT-REFS 的核心思想是变量总是绑定到内存位置上，因此对变量的操作必须首先找到其位置，再从存储器中取值或设置值。这种设计隐藏了显式引用中的内存管理细节，使得程序更加简洁和直观，但也引入了额外的间接访问（变量 -> 位置 -> 值）的步骤。

如果有进一步的代码实现需要，或对其他概念的深入理解，可以继续深入。

### -----------------------------------------

### 4.3.2 实现（IMPLICIT-REFS：隐式引用语言）

在 **IMPLICIT-REFS（隐式引用语言）** 中，每个变量都表示一个引用，即变量存储了它所对应的内存位置。我们需要修改解释器，使其能够处理这种按值调用、隐式引用的机制。以下是对该语言中变量绑定和引用的具体实现。

#### 变量引用的实现

在 IMPLICIT-REFS 语言中，`var-exp` 表达式（变量引用）需要被解引用，即找到变量在环境中对应的内存位置，然后通过存储器 `deref` 提取该位置上的值。

实现如下：

```scheme
(var-exp (var)
  ;; 在环境 env 中找到变量 var 所指向的内存位置，并进行解引用操作
  (deref (apply-env env var)))
```

- `apply-env`：从环境 `env` 中查找变量 `var` 的位置。
- `deref`：通过存储器解引用该位置，获取实际存储的值。

#### 赋值表达式的实现

`assign-exp` 表达式负责更新内存中某个位置的值。其实现包括两个步骤：首先查找变量 `var`，找到其位置；然后对右侧表达式 `exp1` 求值，并将结果存储到该位置。

实现如下：

```scheme
(assign-exp (var exp1)
  (begin
    ;; 查找变量 var 所对应的位置
    (setref! (apply-env env var)
             ;; 对 exp1 求值并将其存储到该位置
             (value-of exp1 env))
    ;; 返回值 27，表示赋值操作完成
    (num-val 27)))
```

- `setref!`：将 `exp1` 的值存储到变量 `var` 所指向的内存位置中。
- `num-val 27`：赋值操作的返回值为常量 27，表示赋值是为了效果而不是值。

#### 在变量绑定处创建引用

在 IMPLICIT-REFS 语言中，新的内存位置在每次变量绑定时创建。绑定操作出现在四个地方：初始环境、`let` 表达式、过程调用以及 `letrec` 表达式中。我们需要为这些地方添加创建引用的逻辑。

##### `let` 表达式的修改

在 `let` 表达式中，我们需要为每个新绑定的变量创建一个新的内存位置，并将 `exp1` 的值存储到该位置。

实现如下：

```scheme
(let-exp (var exp1 body)
  ;; 对右侧表达式 exp1 求值，并分配一个新的引用，将值存储到新位置
  (let ((val1 (value-of exp1 env)))
    (value-of body
              ;; 扩展环境，将 var 绑定到新创建的引用
              (extend-env var (newref val1) env))))
```

- `newref`：分配一个新的内存位置，并将 `val1` 存储到该位置。
- `extend-env`：扩展环境，将变量 `var` 绑定到新引用。

##### 过程调用的修改

在过程调用中，我们同样需要为过程的参数创建一个新的内存位置，存储传递的实际参数值。

实现如下：

```scheme
(apply-procedure : Proc × ExpVal → ExpVal
  (define apply-procedure
    (lambda (proc1 val)
      (cases proc proc1
        ;; 对过程参数 var 创建一个新的引用，将实际参数 val 存储到该位置
        (procedure (var body saved-env)
          (value-of body
                    (extend-env var (newref val) saved-env))))))
```

- `newref`：为过程参数分配一个新的内存位置，将参数值存储在该位置。
- `extend-env`：扩展环境，将过程的参数绑定到该引用。

##### `letrec` 表达式的修改

在 `letrec` 中，我们也需要修改 `extend-env-rec`，使其返回一个引用，并指向包含适当闭包的位置。

实现如下：

```scheme
(extend-env-rec (p-names b-vars p-bodies saved-env)
  (let ((n (location search-var p-names)))
    (if n
        ;; 为 letrec 中的过程创建新的引用，存储过程值
        (newref (proc-val (procedure
                           (list-ref b-vars n)
                           (list-ref p-bodies n)
                           env)))
        ;; 如果变量不在过程名列表中，则查找保存的环境
        (apply-env saved-env search-var))))
```

- `newref`：创建一个新的引用，指向包含过程闭包的内存位置。
- `location`：查找变量在绑定列表中的位置，返回对应的引用。

#### IMPLICIT-REFS 语言的求值日志

通过上述修改，我们可以跟踪 `IMPLICIT-REFS` 语言的求值过程。下面是一个简单的例子，演示了该语言中的变量分配和引用操作：

```scheme
> (run "
let f = proc (x) proc (y)
begin
  set x = -(x,-1);
  -(x,y)
end
in ((f 44) 33)")
```

求值过程中的日志输出：

```
newref: 分配位置 0
newref: 分配位置 1
newref: 分配位置 2
进入 let f
newref: 分配位置 3
进入 let f 主体，环境 =
((f 3) (i 0) (v 1) (x 2))
存储器 =
((0 #(struct:num-val 1))
(1 #(struct:num-val 5))
(2 #(struct:num-val 10))
(3 (procedure x ... ((i 0) (v 1) (x 2)))))
newref: 分配位置 4
进入 proc x 主体，环境 =
((x 4) (i 0) (v 1) (x 2))
存储器 =
((0 #(struct:num-val 1))
(1 #(struct:num-val 5))
(2 #(struct:num-val 10))
(3 (procedure x ... ((i 0) (v 1) (x 2))))
(4 #(struct:num-val 44)))
newref: 分配位置 5
进入 proc y 主体，环境 =
((y 5) (x 4) (i 0) (v 1) (x 2))
存储器 =
((0 #(struct:num-val 1))
(1 #(struct:num-val 5))
(2 #(struct:num-val 10))
(3 (procedure x ... ((i 0) (v 1) (x 2))))
(4 #(struct:num-val 44))
(5 #(struct:num-val 33)))
#(struct:num-val 12)
```

### 总结

IMPLICIT-REFS 语言通过让每个变量绑定到内存位置，实现了隐式的引用管理。这种设计使得变量的存储和赋值变得透明，程序员不再需要显式管理内存位置。我们通过修改解释器中的 `let`、`letrec` 和过程调用来实现这一机制。

如果你希望进一步探讨或需要更多代码实现，可以继续提供具体问题或代码段。

### -----------------------------------------

### 练习 4.15 [⋆] 解答
**问题:** 为什么在 `IMPLICIT-REFS（隐式引用语言）` 中，环境中的变量绑定到一般的整数，而不是像 `EXPLICIT-REFS（显式引用语言）` 中那样的表达值？

**解答思路:**

在 **IMPLICIT-REFS** 设计中，每个变量都指向内存中的位置，而不是直接指向值。这种设计中，变量本质上表示一个间接的存储引用。当对变量进行操作时，我们先从环境中查找该变量名，对应的位置就是存储引用，然后再通过引用访问该存储的值。

而在 **EXPLICIT-REFS** 中，引用是显式的表达值。程序员需要通过 `newref` 等操作手动创建内存位置引用，分配内存。因此，引用在 **EXPLICIT-REFS** 语言中是表达值的一部分。

在 **IMPLICIT-REFS** 中，环境中的变量绑定到整数（即存储位置），这是为了简化对存储器的管理。每个变量被视为一个指向特定内存位置的引用，而不是直接持有值。通过这种方式，程序可以隐式地进行引用的操作，而不需要程序员显式地管理存储器引用。

### 练习 4.16 [⋆] 解答
**问题:** 使用赋值产生递归过程，验证以下翻译可行：

**原始代码：**
```scheme
letrec times4(x) = 
  if zero?(x)
  then 0
  else -((times4 -(x,1)), -4)
in (times4 3)
```

**翻译版本：**
```scheme
let times4 = 0
in begin
  set times4 = proc (x)
    if zero?(x)
    then 0
    else -((times4 -(x,1)), -4);
  (times4 3);
end
```

**解答思路:**

手动跟踪翻译后的程序：

1. **初始状态:**
   - `times4` 初始化为 0：`let times4 = 0`。
   - 环境：`(times4 = 0)`。

2. **赋值操作:**
   - 使用 `set` 将 `times4` 赋值为一个递归过程:
     ```scheme
     set times4 = proc (x)
       if zero?(x)
       then 0
       else -((times4 -(x,1)), -4);
     ```
   - 此时，`times4` 被绑定到一个递归过程，环境更新为：`(times4 = (proc (x) ...))`。

3. **递归调用:**
   - 调用 `(times4 3)`，从递归过程开始：
     1. `x = 3`，`zero?(3)` 返回 `#f`，进入 `else` 分支。
     2. 计算 `times4 -(3,1)`，即调用 `(times4 2)`。
     3. 继续递归调用直到 `x = 0`，返回 0。然后反向计算所有结果：
        - `times4(1)` 返回 4，`times4(2)` 返回 8，最终 `times4(3)` 返回 12。

**结论:**
这种翻译可行，因为通过赋值操作，我们成功将递归过程赋给变量 `times4`，并且可以进行递归调用。

### 练习 4.17 [⋆⋆] 解答
**问题:** 写出规则并实现多参数过程和声明多变量的 `let` 表达式。

**解答思路:**

1. **多参数过程：**
   - 多参数过程定义时，每个参数都绑定到一个存储位置。调用时，传入的参数依次绑定到这些存储位置中，类似于单参数过程的处理。
   - 过程调用时，我们需要依次绑定所有参数到它们对应的变量。

2. **多变量 `let` 表达式：**
   - 对于多变量 `let`，需要一次性绑定多个变量到对应的值。我们依次对每个变量的表达式求值，并将结果绑定到相应的变量上。

**规则：**

1. **多参数过程：**
   ```scheme
   (apply-procedure (procedure (var1, var2, ...) body ρ) (val1, val2, ...) σ)
   = (value-of body [var1 = val1, var2 = val2, ...]ρ σ)
   ```
   解释：对过程调用时，传递多个参数，并将它们绑定到各自的变量名。

2. **多变量 `let`：**
   ```scheme
   (value-of (let-exp ((var1 exp1) (var2 exp2) ...) body) ρ σ)
   = (value-of body [var1 = val1, var2 = val2, ...]ρ σ)
   ```
   解释：`let` 表达式可以同时声明多个变量。每个变量的值通过各自的表达式求出，然后在扩展的环境中计算主体表达式。

**实现代码：**

```scheme
(let-exp (var-exp-list body)
  ;; 对多个表达式求值并将结果绑定到多个变量上
  (let ((vals (map (lambda (var-exp) (value-of (cdr var-exp) env)) var-exp-list)))
    (value-of body
              ;; 扩展环境，绑定多个变量到它们对应的值
              (extend-env-multi (map car var-exp-list) vals env))))
```

**多参数过程：**

```scheme
(apply-procedure : Proc × Listof(ExpVal) → ExpVal
  (define apply-procedure
    (lambda (proc1 vals)
      (cases proc proc1
        ;; 对多个变量绑定多个参数
        (procedure (vars body saved-env)
          (value-of body
                    (extend-env-multi vars vals saved-env))))))
```

### 练习 4.18 [⋆⋆] 解答
**问题:** 写出规则并实现声明多过程的 `letrec` 表达式。

**解答思路:**

- `letrec` 允许同时声明多个递归过程。多个过程的绑定在 `letrec` 块内部可互相递归调用。
- 处理 `letrec` 时，我们为每个过程分配一个位置，然后将其对应的过程绑定到该位置。

**规则：**
```scheme
(value-of (letrec-exp ((p1 (x1) body1) (p2 (x2) body2) ...) body) ρ σ)
= (value-of body [p1 = l1, p2 = l2, ...]ρ [l1 = proc(p1, body1, ρ), l2 = proc(p2, body2, ρ), ...]σ)
```
解释：每个过程在内存中有对应的存储位置，允许它们在 `letrec` 范围内互相递归。

---



### -----------------------------------------

### 练习 4.19 [⋆⋆] 解答
**问题:** 修改声明多过程的 `letrec` 实现，使每个闭包只生成一次，并且只分配一个位置。

**解答思路:**

在 `letrec` 中，多个过程可以互相递归调用，甚至是自我递归。因此，在递归时，必须确保每个过程只生成一次，并且每个过程只占用一个固定的存储位置。

要实现这一点，我们需要：
1. **预先分配存储位置**：在 `letrec` 的初始阶段，先为所有过程声明分配好位置，但暂时不求值它们的主体。
2. **延迟求值过程**：在所有存储位置都分配好之后，再填充每个位置的过程闭包。

### 实现思路：

1. **存储器分配**：首先为所有过程分配存储位置。
2. **延迟绑定闭包**：在填充存储时，不立即创建过程，而是延迟到所有位置都分配好以后再绑定过程。
3. **优化存储使用**：确保每个闭包只生成一次，并且递归调用时指向同一存储位置。

### 规则：

1. **过程位置的预分配**：
   - 我们首先为 `letrec` 中的每个过程分配存储位置，并扩展环境。
   ```scheme
   (value-of (letrec-exp ((p1 (x1) body1) (p2 (x2) body2) ...) body) ρ σ0)
   = let l1, l2, ... be new locations
   in value-of body [p1 = l1, p2 = l2, ...]ρ [l1 = proc(p1, body1, ρ), l2 = proc(p2, body2, ρ), ...]σ0
   ```

2. **延迟过程绑定**：
   - 在所有存储位置分配完毕后，再将对应的过程填入这些位置。每个过程只创建一次闭包，并存储在其预先分配的位置中。

### 实现代码：

```scheme
(letrec-exp (proc-list body)
  ;; 1. 先为所有过程分配位置
  (let* ((locs (map (lambda (_) (new-location)) proc-list))
         ;; 2. 将每个过程名与对应位置绑定
         (env2 (extend-env-multi (map car proc-list) locs env)))
    ;; 3. 在所有位置分配完后再创建闭包
    (for-each (lambda (proc loc)
                (let ((params (cadr proc))
                      (proc-body (caddr proc)))
                  (set-location! loc (proc-val (procedure params proc-body env2)))))
              proc-list
              locs)
    ;; 4. 在扩展的环境中求值 body
    (value-of body env2))))
```

**步骤解释**：
- **步骤 1**: 预先为 `letrec` 中的每个过程分配内存位置。
- **步骤 2**: 使用 `extend-env-multi` 扩展环境，将每个过程名称绑定到其分配的存储位置。
- **步骤 3**: 遍历每个过程，将闭包（`procedure`）填充到对应的存储位置。
- **步骤 4**: 在扩展后的环境中求值 `body`。

### 练习 4.20 [⋆⋆] 解答
**问题:** 修改语言，让 `let` 引入不可变变量，可变变量由 `letmutable` 表达式引入。

**解答思路:**

要实现 `letmutable`，需要区分可变和不可变的变量：
1. **不可变变量**：通过普通的 `let` 引入，不允许修改其绑定的值。
2. **可变变量**：通过 `letmutable` 引入，允许使用 `set` 进行赋值操作。

在环境设计中，我们将不可变变量直接绑定到表达值，而可变变量绑定到引用（即存储位置）。

### 规则：

1. **不可变变量的 `let`**：
   - 普通 `let` 表达式引入的变量绑定到具体的表达值，不允许后续修改。
   ```scheme
   (value-of (let-exp var exp1 body) ρ σ)
   = let val1 = value-of(exp1, ρ, σ)
   in value-of(body, [var = val1]ρ, σ)
   ```

2. **可变变量的 `letmutable`**：
   - `letmutable` 需要为变量分配一个存储位置，允许对该变量进行修改。
   ```scheme
   (value-of (letmutable-exp var exp1 body) ρ σ0)
   = let val1 = value-of(exp1, ρ, σ0)
     let l = new-location()
   in value-of(body, [var = l]ρ, [l = val1]σ0)
   ```

### 实现代码：

```scheme
(let-exp (var exp1 body)
  ;; 处理不可变变量，直接绑定表达值
  (let ((val1 (value-of exp1 env)))
    (value-of body (extend-env var val1 env))))

(letmutable-exp (var exp1 body)
  ;; 处理可变变量，先为其分配存储位置
  (let ((val1 (value-of exp1 env))
        (loc (new-location)))
    ;; 将变量绑定到存储位置
    (set-location! loc val1)
    (value-of body (extend-env var loc env))))
```

**步骤解释**：
- **不可变变量 (`let`)**：直接将表达值 `val1` 绑定到变量 `var`。
- **可变变量 (`letmutable`)**：先为变量 `var` 分配一个新存储位置，将 `val1` 存入该位置，再将位置绑定到变量。

### 练习 4.21 [⋆⋆] 解答
**问题:** 向语言添加动态赋值 (`setdynamic`)，使变量的赋值在一定范围内是临时的。

**解答思路:**

`setdynamic` 允许对变量进行临时赋值，只在特定表达式求值期间有效。这个操作必须：
1. 保存变量的原始值。
2. 在指定范围内使用新的值。
3. 执行完范围内的代码后恢复变量的原值。

### 规则：

```scheme
(value-of (setdynamic-exp var exp1 body) ρ σ0)
= let old-val = σ0(ρ(var))  ;; 保存原值
  let new-val = value-of(exp1, ρ, σ0)
  in let σ1 = [ρ(var) = new-val]σ0
     let result = value-of(body, ρ, σ1)
     in (result, [ρ(var) = old-val]σ1)  ;; 恢复原值
```

**解释：**
- 我们首先在存储器中查找 `var` 绑定的位置，并保存其当前的值 `old-val`。
- 然后，将 `exp1` 的结果赋值给 `var`，临时覆盖其原值。
- 在临时赋值期间，我们求 `body` 的值。
- 最后，恢复 `var` 的原值，并返回 `body` 的结果。

### 实现代码：

```scheme
(setdynamic-exp (var exp1 body)
  ;; 获取变量的原始值
  (let ((old-val (deref (apply-env env var)))
        (new-val (value-of exp1 env)))
    ;; 临时设置变量的新值
    (setref! (apply-env env var) new-val)
    ;; 求值 body 并保存结果
    (let ((result (value-of body env)))
      ;; 恢复原始值
      (setref! (apply-env env var) old-val)
      result)))
```

**步骤解释**：
- 首先获取变量的原始值 `old-val` 并临时赋值为 `exp1` 的结果。
- 然后求 `body` 的值并返回结果。
- 最后，恢复变量的原始值。

---



### -----------------------------------------

### 练习 4.22 [⋆⋆] 解答
**问题:** 扩展语言，使其建模面向语句的语言。

在之前的实现中，语言是面向表达式的，主要关注表达式的求值。现在我们要扩展语言，支持面向语句（statement-oriented）的编程范式，其中程序由一系列语句组成，语句可以修改存储器并产生效果。

### 语法扩展：

我们将引入下列语法规则，允许使用赋值语句、打印语句、条件语句、循环语句和块语句：

- **赋值语句**: `Identifier = Expression`
- **打印语句**: `print Expression`
- **块语句**: `{{Statement∗(;)}`
- **条件语句**: `if Expression Statement Statement`
- **循环语句**: `while Expression Statement`
- **变量声明**: `var {Identifier}∗(;)`

### 扩展后的语法规则：

```scheme
Program ::= Statement

Statement ::= Identifier = Expression
           ::= print Expression
           ::= {{Statement∗(;)}}
           ::= if Expression Statement Statement
           ::= while Expression Statement
           ::= var {Identifier}∗(;)
```

### 语义概述：

- **程序**: 由语句组成，不返回值，但可以修改存储器。
- **赋值语句**: 对指定变量进行赋值。
- **打印语句**: 打印表达式的值。
- **条件语句**: 根据条件表达式执行不同的语句。
- **循环语句**: 根据条件表达式循环执行语句。
- **块语句**: 定义一系列语句和局部变量，作用域仅限于块内部。
- **变量声明**: 为声明的变量分配未初始化的引用位置。

### 关键概念：

1. **结果不返回值**: 语句的执行结果不是值，而是存储器的修改或输出效果。
2. **环境与存储器**: 变量声明将变量绑定到引用位置，通过存储器操作实现值的更新和读取。

### 实现思路：

我们需要分别处理程序、语句和表达式。由于表达式仍然使用之前的 `IMPLICIT-REFS` 语言的实现，我们的重点是处理语句的执行和程序的整体控制流。

### 扩展后的解释器框架：

我们引入新的函数 `result-of`，用来处理语句。`value-of` 用于处理表达式，而 `result-of` 处理语句并返回新的存储器状态。

```scheme
(define result-of
  (lambda (stmt env store)
    (cases statement stmt
      ;; 处理赋值语句
      (assign-exp (var exp1)
        (let ((val1 (value-of exp1 env store)))
          (setref! (apply-env env var) val1)
          store))
      
      ;; 处理打印语句
      (print-exp (exp1)
        (let ((val1 (value-of exp1 env store)))
          (print val1)  ;; 假设有一个print函数
          store))
      
      ;; 处理 if 语句
      (if-exp (cond-exp then-stmt else-stmt)
        (let ((cond-val (value-of cond-exp env store)))
          (if (expval->bool cond-val)
              (result-of then-stmt env store)
              (result-of else-stmt env store))))
      
      ;; 处理 while 循环
      (while-exp (cond-exp body)
        (let loop ((store1 store))
          (let ((cond-val (value-of cond-exp env store1)))
            (if (expval->bool cond-val)
                (loop (result-of body env store1))
                store1))))
      
      ;; 处理变量声明
      (var-exp (vars body)
        ;; 为每个变量分配存储位置
        (let ((env2 (extend-env-multi vars (map (lambda (_) (new-location)) vars) env)))
          (result-of body env2 store)))
      
      ;; 处理块语句
      (block-exp (stmts)
        (result-of-seq stmts env store)))))
```

### 关键函数说明：

1. **赋值语句** (`assign-exp`): 处理赋值语句，将表达式的值存储到变量的引用位置。
2. **打印语句** (`print-exp`): 处理打印操作，求值表达式并将结果打印。
3. **条件语句** (`if-exp`): 根据条件表达式的值执行不同的语句分支。
4. **循环语句** (`while-exp`): 实现循环，通过递归方式不断检查条件并执行循环体。
5. **变量声明** (`var-exp`): 为一组变量分配存储位置，并将变量绑定到这些位置上。
6. **块语句** (`block-exp`): 处理块内的语句序列，局部作用域内执行语句。

### 实现示例：

#### 示例 1：变量声明、赋值和打印

```scheme
(run "var x, y; {x = 3; y = 4; print +(x, y)}")
```

1. **变量声明**：`var x, y` 为 `x` 和 `y` 分配存储位置。
2. **赋值语句**：`x = 3` 和 `y = 4` 将值存储到对应的位置。
3. **打印语句**：`print +(x, y)` 求值并打印 `7`。

#### 示例 2：while 循环

```scheme
(run "var x, y, z; {x = 3; y = 4; z = 0; while not(zero?(x)) {z = +(z, y); x = -(x, 1)}; print z}")
```

1. **变量声明**：`x, y, z` 分配存储位置。
2. **赋值**：初始化变量 `x = 3, y = 4, z = 0`。
3. **循环语句**：`while not(zero?(x)) {z = +(z, y); x = -(x, 1)}` 在 `x` 不为 0 时循环更新 `z` 的值，直到 `x = 0`。
4. **打印结果**：最后打印 `z` 的值，结果为 `12`。

#### 示例 3：块语句作用域

```scheme
(run "var x; {x = 3; print x; var x; {x = 4; print x}; print x}")
```

1. **外层块**：`x = 3` 将外层 `x` 赋值为 3，打印 3。
2. **内层块**：重新声明一个局部变量 `x`，在内层块中赋值为 `4` 并打印，作用域仅限于内层块。
3. **作用域恢复**：在内层块结束后，外层 `x` 仍为 3，因此再次打印 `3`。

#### 示例 4：过程和表达式的交互

```scheme
(run "var f, x; {f = proc(x, y) *(x, y); x = 3; print (f 4 x)}")
```

1. **过程声明**：定义一个过程 `f`，接收两个参数并返回乘积。
2. **变量赋值**：将 `x` 赋值为 3。
3. **过程调用**：调用 `f(4, x)`，计算 `4 * 3` 并打印结果 `12`。

### 小结：

- 我们通过扩展解释器，处理了面向语句的语言。在这个过程中，变量声明、赋值、打印、条件和循环都变成了语句操作。
- 通过引入 `result-of` 函数，分别处理程序中的不同语句类型，并返回新的存储器状态。
- 块语句的引入使我们能够创建局部作用域，提升了程序的灵活性和可读性。

### 练习 4.23 [⋆] 解答：read 语句

要实现 `read` 语句，我们可以扩展语言，添加如下规则：

1. **语法**:
   ```scheme
   Statement ::= read Identifier
   ```

2. **语义**:
   `read` 语句从输入中读取一个非负数并存入指定变量的存储位置。

3. **实现代码**:
   ```scheme
   (read-exp (var)
     (let ((input (read))) ;; 从输入读取一个值
       (setref! (apply-env env var) input)
       store))
   ```

### 练习 4.24 [⋆] 解答：do-while 语句

1. **语法**:
   ```scheme
   Statement ::= do Statement while Expression
   ```

2. **语义**:
   `do-while` 语句先执行一次主体，然后检查条件表达式决定是否继续循环。

3. **实现代码**:
   
   ```scheme
   (do-while-exp (body cond-exp)
	  (let
   		 loop ((store1 (result-of body env store)))
       (let ((cond-val (value-of cond-exp env store1)))
         (if (expval->bool cond-val)
             (loop (result-of body env store1))
             store1))))
   
   ```


### -----------------------------------------

### 练习 4.25 [⋆] 扩展块语句，允许初始化变量

**问题描述：**  
在之前的块语句中，变量是在进入块时声明的，但它们没有被初始化。我们现在要扩展块语句，允许在声明时初始化变量。这样我们可以在声明变量时直接给它们赋值，而不需要后续的赋值语句。

#### 实现思路：
1. **扩展语法：**
   现在，块语句的 `var` 声明可以携带初始值。语法规则需要扩展以支持 `var x = 3` 这样的声明。

   ```scheme
   Statement ::= var {Identifier = Expression}∗(;)
   ```

   - 每个变量在声明时可以带上一个初始值。
   - 我们需要在块语句中引入初始化的表达式。

2. **语义：**
   当一个块语句声明了变量并同时赋值时，我们需要在进入块之前为这些变量分配存储位置，并将初始值存储到相应的位置中。然后在块内执行主体语句。

3. **语法和实现：**
   - `var` 语句应当能够处理多变量声明。
   - 为每个变量分配存储位置，初始化时设置为指定的值。

#### 扩展后的解释器：

```scheme
(define result-of
  (lambda (stmt env store)
    (cases statement stmt
      
      ;; 处理已初始化变量声明的情况
      (var-exp (vars-exps body)
        ;; 提取变量和对应的表达式
        (let ((vars (map car vars-exps)) ;; 提取变量名
              (exps (map cadr vars-exps))) ;; 提取初始化表达式
          ;; 为每个变量计算初始值并创建存储位置
          (let ((init-vals (map (lambda (exp) (value-of exp env store)) exps)))
            ;; 将变量绑定到新的存储位置
            (let ((env2 (extend-env-multi vars (map newref init-vals) env)))
              (result-of body env2 store)))))
      
      ;; 其余语句保持不变...
      )))
```

#### 解释：

- **vars-exps** 是由变量名和表达式组成的列表。每个元素形如 `(var exp)`，即变量名与初始化表达式的配对。
- 我们首先计算所有初始化表达式的值，创建存储位置，并将这些位置与变量名绑定在环境中，然后进入块的主体部分。

#### 示例：

```scheme
(run "var x = 3, y = 4; {print +(x, y)}")
```

在这个例子中，我们声明了两个变量 `x` 和 `y`，并立即初始化它们的值为 `3` 和 `4`，最后打印 `x + y` 的结果 `7`。

---

### 练习 4.26 [⋆⋆⋆] 允许块语句中的互递归过程

**问题描述：**  
在这个练习中，我们需要扩展块语句，使其支持互递归过程的声明。互递归意味着两个或多个过程可以相互调用。

#### 实现思路：

1. **多过程声明：**  
   要让多个过程互相递归调用，过程的声明必须在进入块之前被处理。
   
2. **环境更新：**  
   在处理互递归时，我们必须确保在求值过程中，所有过程都已经可用，并且在它们的定义过程中可以相互引用。因此，我们需要一次性将所有过程绑定到环境中。

3. **语法扩展：**
   块语句的语法现在需要支持多个过程的声明。声明形式类似于 `letrec`，不过是在块语句中声明多个过程。

4. **实现关键点：**
   - 在块开始时，为每个过程创建存储位置。
   - 然后为每个过程分配闭包，并将闭包存储到相应的存储位置中。

#### 实现代码：

```scheme
(define result-of
  (lambda (stmt env store)
    (cases statement stmt
      
      ;; 处理互递归过程的声明
      (letrec-exp (procs body)
        ;; 提取过程名、参数和过程体
        (let ((proc-names (map car procs))
              (proc-params (map cadr procs))
              (proc-bodies (map caddr procs)))
          ;; 为每个过程分配存储位置
          (let ((locations (map (lambda (_) (newref 'uninitialized)) proc-names)))
            ;; 将所有过程名与存储位置绑定
            (let ((env2 (extend-env-multi proc-names locations env)))
              ;; 为每个过程分配闭包并存储到相应的位置
              (for-each (lambda (loc param body)
                          (setref! loc (proc-val (procedure param body env2))))
                        locations proc-params proc-bodies)
              ;; 执行块的主体
              (result-of body env2 store)))))
      
      ;; 其余语句保持不变...
      )))
```

#### 解释：

1. **letrec-exp** 负责处理多个过程的声明。
2. 我们首先为每个过程分配一个存储位置（初始化为 `'uninitialized'`）。
3. 然后，将过程名与存储位置绑定在环境中，这样每个过程可以相互引用。
4. 最后，我们为每个过程生成闭包并存储到相应的位置中，执行块的主体。

#### 示例：

```scheme
(run "
var even, odd;
{
  even = proc(x) if zero?(x) then 1 else odd(-(x,1));
  odd = proc(x) if zero?(x) then 0 else even(-(x,1));
  print (odd 13);
}")
```

在这个例子中，`even` 和 `odd` 是两个互递归过程。我们可以看到当调用 `odd(13)` 时，它会间接地调用 `even`，从而正确判断奇偶性并输出 `1`。

---

### 练习 4.27 [⋆⋆⋆] 添加子程序

**问题描述：**  
我们将进一步扩展语言，支持子程序的声明和调用。子程序类似于过程，但它不返回值，其主体由语句而非表达式组成。

#### 实现思路：

1. **子程序语法：**
   子程序与过程类似，但它只执行操作而不返回值。子程序的主体由语句组成，因此它的调用不应该参与表达式的计算。

2. **扩展语法：**

   ```scheme
   Statement ::= sub {Identifier}∗; Statement
   Statement ::= call Identifier
   ```

3. **语义：**
   - 子程序可以在块中声明，并执行一系列语句。
   - 子程序调用时，执行其主体，但不返回值。

4. **实现代码：**

```scheme
(define result-of
  (lambda (stmt env store)
    (cases statement stmt
      
      ;; 处理子程序的声明
      (subroutine-exp (sub-name body)
        (let ((loc (newref 'uninitialized)))
          (let ((env2 (extend-env sub-name loc env)))
            (setref! loc (sub-val body env2))
            store)))

      ;; 处理子程序调用
      (call-exp (sub-name)
        (let ((sub (apply-env env sub-name)))
          ;; 执行子程序主体
          (result-of (sub-body sub) env store)))
      
      ;; 其余语句保持不变...
      )))
```

#### 解释：

- **subroutine-exp**：处理子程序的声明，为子程序分配存储位置，并将子程序的主体存储。
- **call-exp**：执行子程序的主体，但不返回值。

#### 示例：

```scheme
(run "
var x;
sub mysub {x = 5; print x};
call mysub;
")
```

在这个示例中，子程序 `mysub` 将 `x` 赋值为 `5` 并打印它。程序运行后输出 `5`。

---

通过这些扩展，我们已经将面向语句的语言扩展到了一个更高的复杂度层次，支持了变量初始化、互递归、子程序等高级特性。这些特性能够提升语言的表达能力，使得更复杂的控制流和模块化变得可能。

### -----------------------------------------

### 4.4 MUTABLE-PAIRS: 可变序对语言

**背景：**

在许多编程语言中，像 Scheme 和 Lisp 等，列表和序对（pairs）是基本的数据结构。**不可变列表 (immutable lists)** 在早期的实现中占据了核心位置，意味着一旦创建，这些列表或序对不能再修改。而在某些应用场景中，**可变序对 (mutable pairs)** 提供了更强大的灵活性。

本节的任务是为 **IMPLICIT-REFS** 语言添加可变序对。与不可变序对不同，可变序对的元素可以通过 **set-left!** 和 **set-right!** 进行更新。

#### 操作概览：
1. **make-pair**：创建一个新的可变序对，包含两个表达值。
2. **left** 和 **right**：返回序对的左值或右值。
3. **setleft** 和 **setright**：修改序对的左值或右值。

#### 扩展后的域方程：
我们定义 **ExpVal** (表达值) 和 **DenVal** (指代值) 的扩展，包含了可变序对：
$$
\text{ExpVal} = \text{Int} + \text{Bool} + \text{Proc} + \text{MutPair}
$$
$$
\text{DenVal} = \text{Ref(ExpVal)}
$$
$$
\text{MutPair} = \text{Ref(ExpVal)} \times \text{Ref(ExpVal)}
$$

即，**MutPair** 是两个表达值引用（左和右），每个引用都指向内存中的某个存储位置。

---

### 实现思路：

我们需要为语言添加新的语法结构来支持可变序对，以及定义操作的行为。

#### 1. **语法扩展：**

```scheme
Expression ::= make-pair (Expression , Expression)
              | left (Expression)
              | right (Expression)
              | setleft (Expression , Expression)
              | setright (Expression , Expression)
```

#### 2. **语义：**

- **make-pair**：创建一个新的可变序对，并将两个表达值存储在内存中。
- **left** 和 **right**：分别返回序对的左元素和右元素。
- **setleft** 和 **setright**：修改序对的左元素或右元素，并返回 `Unspecified` 类型。

---

### 实现代码：

```scheme
(define value-of
  (lambda (exp env store)
    (cases expression exp

      ;; 处理 make-pair 操作
      (make-pair-exp (exp1 exp2)
        (let ((val1 (value-of exp1 env store))
              (val2 (value-of exp2 env store)))
          ;; 为序对的左值和右值分配存储位置
          (let ((left-ref (newref val1))
                (right-ref (newref val2)))
            (an-answer (pair-val left-ref right-ref) store))))

      ;; 处理 left 操作
      (left-exp (pair-exp)
        (let ((pair (value-of pair-exp env store)))
          ;; 通过解引用获取左值
          (let ((left-ref (pair-left pair)))
            (an-answer (deref left-ref) store))))

      ;; 处理 right 操作
      (right-exp (pair-exp)
        (let ((pair (value-of pair-exp env store)))
          ;; 通过解引用获取右值
          (let ((right-ref (pair-right pair)))
            (an-answer (deref right-ref) store))))

      ;; 处理 setleft 操作
      (setleft-exp (pair-exp new-left-exp)
        (let ((pair (value-of pair-exp env store))
              (new-left (value-of new-left-exp env store)))
          ;; 修改左值
          (let ((left-ref (pair-left pair)))
            (setref! left-ref new-left)
            (an-answer (num-val 23) store))))

      ;; 处理 setright 操作
      (setright-exp (pair-exp new-right-exp)
        (let ((pair (value-of pair-exp env store))
              (new-right (value-of new-right-exp env store)))
          ;; 修改右值
          (let ((right-ref (pair-right pair)))
            (setref! right-ref new-right)
            (an-answer (num-val 23) store))))
      
      ;; 其他表达式处理保持不变...
      )))
```

### 解释：

1. **make-pair-exp**：
   - `make-pair` 表达式会创建一个新的序对。我们分别计算两个表达式的值，创建两个存储位置并将其分别存储为序对的左值和右值。

2. **left-exp** 和 **right-exp**：
   - `left` 和 `right` 操作通过引用获取序对的左值和右值。我们先对序对表达式求值，获取到序对的引用，然后通过解引用得到相应的值。

3. **setleft-exp** 和 **setright-exp**：
   - 这些操作修改序对的左值或右值。我们先通过解引用获取序对的左值或右值的存储位置，然后用新值更新该存储位置。

---

### 示例运行：

1. **创建和访问可变序对：**

```scheme
(run "
let p = make-pair(1, 2)
in print(left(p))")
```
输出：
```
1
```

2. **修改可变序对的值：**

```scheme
(run "
let p = make-pair(1, 2)
in begin
  setleft(p, 10);
  print(left(p))
end")
```
输出：
```
10
```

在这个例子中，我们首先创建了一个可变序对 `p`，初始值为 `(1, 2)`。通过 `setleft` 操作，我们将序对的左值修改为 `10`，然后通过 `left(p)` 操作打印修改后的值。

---

### 总结：

- **可变序对 (Mutable pairs)** 提供了对序对元素的动态更新功能。在这种模型中，序对中的左右值分别被存储在内存中的独立位置，且可以通过 **setleft** 和 **setright** 操作进行修改。
- 与不可变结构相比，可变序对的操作更复杂，因为它们不仅涉及内存管理，还涉及如何有效更新存储位置。

通过实现这一扩展，我们引入了对数据结构的可变性支持，进一步增强了语言对更复杂程序的表达能力。这种可变性在许多实际编程场景中都是至关重要的，例如需要共享或更新状态的程序中。

### -----------------------------------------

### 4.4.1 可变序对的实现

在这里，我们将使用前面章节中的 **reference (引用)** 数据类型来实现 **可变序对 (mutable pairs)**。具体实现包括创建、访问和修改序对的左右值。

---

### 数据结构扩展：
我们将为表达值类型 **ExpVal** 添加新的变体 **mutpair-val**，用于表示可变序对。

#### 语法扩展：
```scheme
Expression ::= make-pair (Expression , Expression)
              | left (Expression)
              | right (Expression)
              | setleft (Expression , Expression)
              | setright (Expression , Expression)
```

#### 域方程更新：
我们定义 **MutPair** 类型为两个引用，分别指向序对的左值和右值。

$$
\text{ExpVal} = \text{Int} + \text{Bool} + \text{Proc} + \text{MutPair}
$$

$$
\text{DenVal} = \text{Ref(ExpVal)}
$$

$$
\text{MutPair} = \text{Ref(ExpVal)} \times \text{Ref(ExpVal)}
$$

这意味着 **MutPair** 是一个包含两个引用（左值和右值）的结构，每个引用指向内存中的某个位置。

---

### 实现代码：

我们将在解释器中为 `value-of` 函数添加五行代码，来处理 `make-pair`、`left`、`right`、`setleft` 和 `setright` 操作。

#### 数据结构定义：

```scheme
;; 定义表达值的数据类型，新增 mutpair-val 变体用于可变序对
(define-datatype exp-val exp-val?
  (num-val (n number?))    ;; 数字值
  (bool-val (b boolean?))  ;; 布尔值
  (proc-val (p procedure?)) ;; 过程
  (mutpair-val (left-ref reference?) (right-ref reference?))) ;; 可变序对
```

#### `value-of` 函数扩展：

```scheme
(define value-of
  (lambda (exp env store)
    (cases expression exp

      ;; 处理 make-pair 操作，创建新的可变序对
      (make-pair-exp (exp1 exp2)
        (let ((val1 (value-of exp1 env store))
              (val2 (value-of exp2 env store)))
          ;; 为序对的左值和右值分配存储位置
          (let ((left-ref (newref val1))
                (right-ref (newref val2)))
            (an-answer (mutpair-val left-ref right-ref) store))))

      ;; 处理 left 操作，返回可变序对的左值
      (left-exp (pair-exp)
        (let ((pair (value-of pair-exp env store)))
          (let ((left-ref (pair-left pair)))
            (an-answer (deref left-ref) store))))

      ;; 处理 right 操作，返回可变序对的右值
      (right-exp (pair-exp)
        (let ((pair (value-of pair-exp env store)))
          (let ((right-ref (pair-right pair)))
            (an-answer (deref right-ref) store))))

      ;; 处理 setleft 操作，修改可变序对的左值，返回 82
      (setleft-exp (pair-exp new-left-exp)
        (let ((pair (value-of pair-exp env store))
              (new-left (value-of new-left-exp env store)))
          ;; 修改左值
          (let ((left-ref (pair-left pair)))
            (setref! left-ref new-left)
            (an-answer (num-val 82) store))))

      ;; 处理 setright 操作，修改可变序对的右值，返回 83
      (setright-exp (pair-exp new-right-exp)
        (let ((pair (value-of pair-exp env store))
              (new-right (value-of new-right-exp env store)))
          ;; 修改右值
          (let ((right-ref (pair-right pair)))
            (setref! right-ref new-right)
            (an-answer (num-val 83) store))))

      ;; 其他表达式保持不变...
)))
```

---

### 解释代码：

1. **make-pair-exp**:
   - 首先对 `exp1` 和 `exp2` 求值，分别获取左右值。
   - 然后调用 `newref` 为这两个值创建存储位置（引用），并创建一个 **mutpair-val**，其中包含这两个引用。
   
2. **left-exp** 和 **right-exp**:
   - 首先对可变序对表达式求值，获取到 `mutpair-val`。
   - 然后通过 `pair-left` 和 `pair-right` 分别获取序对的左引用和右引用，再通过 `deref` 获取存储在这些引用中的实际值。

3. **setleft-exp** 和 **setright-exp**:
   - 首先对可变序对表达式和新的左/右值求值。
   - 通过 `pair-left` 或 `pair-right` 获取引用，并使用 `setref!` 将新的左/右值存储到该引用指向的存储位置中。
   - 返回任意值，分别是 `82` 和 `83`。

---

### 示例运行：

1. **创建并访问可变序对：**

```scheme
(run "
let p = make-pair(1, 2)
in print(left(p))")
```
输出：
```
1
```

2. **修改可变序对的左值：**

```scheme
(run "
let p = make-pair(1, 2)
in begin
  setleft(p, 10);
  print(left(p))
end")
```
输出：
```
10
```

3. **修改并访问序对的右值：**

```scheme
(run "
let p = make-pair(3, 4)
in begin
  setright(p, 20);
  print(right(p))
end")
```
输出：
```
20
```

---

### 总结：

通过扩展语言的解释器和数据结构，我们为 **IMPLICIT-REFS** 语言添加了可变序对的支持。**可变序对** 提供了灵活的结构，可以动态地更新左右值，从而使程序在处理复杂的数据时更加灵活。

### -----------------------------------------

理解解释器设计的核心在于逐步掌握不同层面的概念和技术，这包括从基本的语言解析和语义处理，到更高级的存储管理、作用域规则、递归调用等方面。为了帮助你更全面地理解和学习这个领域，我们将从**历史**、**理论**和**技术实现**三个角度出发，结合你正在阅读的《Essentials of Programming Languages》中的内容进行拓展讲解。

### 1. 解释器的历史背景和发展
#### 历史背景（History）
解释器（Interpreter）的概念可以追溯到编程语言发展的早期。最早的计算机使用汇编语言，需要将高层指令逐行转换成机器码。解释器就是这样一种工具，它能够**逐行**读取和执行源代码，而不是像编译器那样一次性转换为可执行的机器码。解释器的历史和编译器紧密相关，但它的执行方式更具动态性，适合早期对灵活性要求较高的编程任务。

解释器在许多高层语言中广泛使用，如**Lisp**、**Python**和**Ruby**。这些语言由于需要快速执行、实时调试和动态类型特性，解释器成为了实现这些特性的重要手段。

### 2. 解释器设计的理论基础
解释器设计的理论来自计算机科学中的几大领域：**计算理论（Theory of Computation）**、**语言学（Linguistics of Programming Languages）**、**语义学（Semantics）**、**类型理论（Type Theory）**等。

#### 语义学与抽象解释器（Semantics and Abstract Interpreters）
解释器的核心任务是赋予程序正确的**语义（semantics）**，也就是给出程序每一个表达式的确切意义。语义可以通过不同的方式定义：
- **操作语义（Operational Semantics, 操作语义）**：通过定义每个语句的执行步骤来赋予程序意义。
- **公理语义（Axiomatic Semantics, 公理语义）**：通过逻辑公式来表达程序的状态变化。
- **表示语义（Denotational Semantics, 表示语义）**：将程序映射为数学对象。

在解释器设计中，操作语义是最常用的，因为它直接定义了如何**执行**程序。这正是解释器的核心工作：根据操作语义，一步步解释和执行每个程序片段。

### 3. 扩展视野——如何理解解释器设计中的各个领域
为了拓宽对解释器设计的理解，让我们看一些与《Essentials of Programming Languages》中内容相关的领域。

#### 解释器与类型理论（Interpreter and Type Theory）
在解释器的设计中，**类型检查**（Type Checking）是一个至关重要的步骤。它确保程序中的每个部分在执行时符合语言的类型规则。**类型论（Type Theory）**是形式化地处理程序类型的数学基础。解释器中的类型系统通过静态类型检查和动态类型检查的结合，使程序在运行时和编译时都能够被正确理解。

在类型检查中，解释器会通过递归遍历程序的语法树，确保每个表达式、函数调用和赋值都满足类型要求。例如，在实现一个简单的整数类型检查器时，解释器可以用递归的方式确保每个操作符只接受整数作为参数：

```scheme
(define (type-check expr env)
  (cases expression expr
    (const-exp (n) 'int)
    (var-exp (var) (apply-env env var))
    (diff-exp (e1 e2)
      (if (and (equal? (type-check e1 env) 'int)
               (equal? (type-check e2 env) 'int))
          'int
          (error "Type error in subtraction")))))
```

在这个例子中，`type-check`函数检查表达式的类型是否匹配。如果不匹配，解释器将抛出类型错误。

#### 域论与同调代数（Domain Theory and Homotopy Type Theory）
在讨论类型系统的进一步理论基础时，**域论（Domain Theory）**是不可或缺的。它研究程序语义中的递归和不动点。递归调用在解释器设计中至关重要，尤其是在处理函数或过程调用时，解释器需要能够处理自调用或互递归。

**同调代数（Homotopy Algebra）**与**同调类型论（Homotopy Type Theory, HoTT）**为程序的类型系统提供了更深层的数学基础。HoTT 通过将类型和几何学中的空间等价性联系起来，提供了一种新的方式来理解程序语义，尤其是涉及到范畴论中的**函子（Functor）**和**自然变换（Natural Transformation）**时。

#### 群论与范畴论在解释器中的应用（Group Theory and Category Theory in Interpreter Design）
**群论（Group Theory）**提供了一个强大的数学工具来处理程序中的对称性和变换。在解释器中，这种数学结构可以应用于优化，例如通过寻找程序的对称性来减少重复计算。

**范畴论（Category Theory）**在解释器设计中也有广泛应用，尤其是在现代函数式编程语言如**Haskell**中。范畴论提供了一种抽象框架，通过**函子**和**单态（Monads）**，解释器可以通过这些结构处理复杂的控制流、状态管理和异步操作。

### 4. 解释器设计的代码实现
#### 基础解释器结构（Interpreter Structure）
每个解释器都有一些共同的组件：**解析器（Parser）**、**环境（Environment）**、**存储器（Store）**和**求值器（Evaluator）**。这些组件协同工作，解析程序，管理变量和存储，执行代码。

```scheme
(define (interpret program)
  (let ((parsed (parse program)))         ;; 解析源程序
    (eval parsed (init-env))))            ;; 求值并执行

(define (eval expr env)
  (cases expression expr
    (const-exp (n) n)                     ;; 常量直接返回
    (var-exp (v) (lookup-env env v))      ;; 查找环境中的变量
    (proc-exp (var body)                  ;; 处理过程表达式
      (proc-val (procedure var body env)))
    (call-exp (rator rand)                ;; 处理过程调用
      (let ((proc (eval rator env))
            (arg (eval rand env)))
        (apply-procedure proc arg)))))
```

这个代码展示了一个基本的解释器框架，其中的`interpret`函数负责将程序解析并求值。`eval`函数处理不同的表达式类型，并通过环境`env`进行变量查找和过程调用。

通过这种结构，解释器可以递归地处理函数、变量、控制结构等。

### 5. 扩展示例：多参数过程
在《Essentials of Programming Languages》中，处理多参数过程是解释器的一个挑战。让我们来看一个简单的多参数过程的解释器扩展：

```scheme
(define (eval expr env)
  (cases expression expr
    (const-exp (n) n)
    (var-exp (v) (lookup-env env v))
    (proc-exp (vars body)                    ;; 支持多参数
      (proc-val (procedure vars body env)))
    (call-exp (rator rands)                  ;; 多参数调用
      (let ((proc (eval rator env))
            (args (map (lambda (rand) (eval rand env)) rands)))
        (apply-procedure proc args)))))

(define (apply-procedure proc args)
  (cases procedure proc
    (procedure (vars body env)               ;; 将多参数绑定到环境中
      (eval body (extend-env (zip vars args) env)))))
```

在这个实现中，我们通过处理多个参数的`proc-exp`和`call-exp`扩展了解释器，使它能够处理多参数的过程。

### 总结
解释器设计是一个跨学科的领域，涵盖了计算机科学、数学和逻辑学等多个方面。你可以通过《Essentials of Programming Languages》学习解释器设计的基础知识，同时通过研究**类型论**、**范畴论**等理论背景，拓展你对解释器工作原理的理解。

### -----------------------------------------

### 4.4.2 可变序对的另一种表示
在上一节中，我们使用了两个独立的引用分别来表示序对的左右两部分。然而，这种方式没有利用到我们已知的序对信息：我们可以将序对的左边和右边统一在一起进行分配，而不需要单独为右边的值创建一个引用。右边的值总是位于左边的引用之后的位置，因此我们可以利用这种位置的连续性。

这意味着我们可以仅使用左侧的引用来表示整个序对：右侧的值可以通过计算左侧位置的偏移量获得。这样做可以更简洁地表示和管理序对。

#### 代码实现
通过这种新的表示方式，我们可以修改`make-pair`、`left`和`right`等操作，以更高效地操作序对。

```scheme
(define-datatype mutpair mutpair?
  ;; 仅保存左边的位置
  (a-pair
   (left-loc reference?))) ;; 使用左边的引用表示整个序对

;; 创建一个序对，左边和右边各占据一个相邻的位置
(define make-pair
  (lambda (val1 val2)
    (let ((left-loc (newref val1))) ;; 创建左边的引用
      (let ((right-loc (newref val2))) ;; 创建右边的引用
        left-loc))))  ;; 返回左边引用，右边可以通过偏移量计算

;; 获取序对左侧的值
(define left
  (lambda (p)
    (deref p))) ;; 直接解引用左侧

;; 获取序对右侧的值
(define right
  (lambda (p)
    (deref (+ 1 p)))) ;; 通过偏移量 1 获取右侧值

;; 设置序对左侧的值
(define setleft
  (lambda (p val)
    (setref! p val))) ;; 设置左侧值

;; 设置序对右侧的值
(define setright
  (lambda (p val)
    (setref! (+ 1 p) val))) ;; 通过偏移量 1 设置右侧值
```

### 详细讲解
#### 1. `make-pair`：
在这里，我们仍然为左边和右边的值各分配一个引用，但最终只返回左边的引用。右边的引用通过偏移 1 来表示，因为它总是位于左边的引用之后。这样的设计简化了内存管理。

#### 2. `left`：
我们可以通过直接解引用左边的引用来获取左侧的值。由于左侧引用直接存储了左边的值，所以不需要进一步的偏移或复杂操作。

#### 3. `right`：
对于右侧的值，我们通过将左边引用的位置偏移 1 来解引用右侧的值。通过这种方式，我们只需要一个引用便可以访问到序对的两个部分。

#### 4. `setleft` 和 `setright`：
设置左侧值和右侧值的逻辑类似。`setleft`直接修改左边的值，而`setright`通过偏移修改右侧的值。

这种优化使得我们不需要为序对分配两个独立的引用，可以减少内存的占用。

### 代码示例
下面是一个完整的例子，展示如何使用新的可变序对实现：

```scheme
> (run "
let glo = pair(11, 22)
in let f = proc (loc)
let d1 = setright(loc, left(loc))  ;; 把左边的值设置到右边
in let d2 = setleft(glo, 99)       ;; 设置全局变量 glo 的左值
in -(left(loc), right(loc))         ;; 计算左右值的差
in (f glo)")
```

这个程序的运行过程如下：
1. 初始化全局变量 `glo`，创建一个序对 `pair(11, 22)`，`11` 是左边的值，`22` 是右边的值。
2. 调用过程 `f`，该过程首先将 `loc`（即 `glo`）的左值（即 `11`）设置为右值，接着将 `glo` 的左值设置为 `99`。
3. 最后，计算 `loc` 的左右值之差。

### 示例运行日志

```plaintext
;; 为 glo 分配存储单元
newref: 分配位置 3  ;; 左侧存储位置
newref: 分配位置 4  ;; 右侧存储位置
;; 为序对 glo 分配存储单元
newref: 分配位置 5
进入 let glo 主体，环境 = ((glo 5))
存储器 = ((0 1), (3 11), (4 22))
进入 let f
;; 进入 let f 主体，调用过程 f
newref: 分配位置 6
```

通过这种设计，我们只需使用一个引用来代表整个序对，同时保留了对左侧和右侧的独立操作功能。

### 总结
这种设计通过使用偏移来管理序对中的左右值，简化了内存分配和引用操作。类似的优化思路可以应用于许多其他场景，如数组和其他数据结构的实现。通过这种优化，我们既可以保持操作的简洁性，又能够提高内存管理的效率。这是解释器设计中常见的一个优化策略：通过重用内存区域来减少冗余的分配和复制。

这种技术背后的思想源自于**编程语言实现（Implementation of Programming Languages）**领域中的**内存优化（Memory Optimization）**，尤其是在需要处理大量数据结构时，这种方法有助于提高程序的性能和可扩展性。

### -----------------------------------------

### 4.4.2 可变序对的另一种表示 (An Alternative Representation of Mutable Pairs)

在 4.4.2 节中，我们讨论了可变序对 (Mutable Pair) 的另一种实现方式。通常情况下，序对 (pair) 是由两个位置 (locations) 组成的，每个位置分别存储左侧和右侧的值。我们最初的实现使用了两个独立的引用 (references) 来表示序对的左右部分，但实际上这两者是同时分配的，不是独立的。这为我们提供了一个优化的机会：我们可以使用一个位置来表示序对，只需要引用序对的第一个位置，右侧的位置可以通过递增该引用来推导。

#### 序对表示与内存管理

可变序对的优化源于内存中数据的连续性：在大多数内存模型中，序对的两个元素是一起分配的，并且在物理上彼此相邻。因此，我们可以通过引用序对的第一个位置 (left-loc)，并通过加1的方式访问第二个位置 (right-loc)。这是一个经典的空间优化技术，通过减少不必要的引用操作提高效率。

#### 代码讲解

```scheme
(define-datatype mutpair mutpair?
  (a-pair
   (left-loc reference?)   ;; 左侧的位置引用
   (right-loc reference?))) ;; 右侧的位置引用
```

这段代码定义了可变序对的数据类型 $mutpair$，它由两个位置引用组成：$left-loc$ 和 $right-loc$。这与前面的表示方法一致，两个引用分别指向序对的两个部分。

#### `make-pair` 函数

```scheme
(make-pair : ExpVal × ExpVal → MutPair)

(define make-pair
  (lambda (val1 val2)
    (a-pair
     (newref val1)  ;; 为左侧值分配位置
     (newref val2)))) ;; 为右侧值分配位置
```

`make-pair` 用来创建一个可变序对。我们使用 `newref` 为左侧和右侧的值分别分配内存位置。函数返回一个新创建的 `a-pair`，它包含了两个位置引用。

#### `left` 和 `right` 函数

```scheme
(left : MutPair → ExpVal)

(define left
  (lambda (p)
    (cases mutpair p
      (a-pair (left-loc right-loc)
        (deref left-loc)))))  ;; 解引用获取左侧的值

(right : MutPair → ExpVal)

(define right
  (lambda (p)
    (cases mutpair p
      (a-pair (left-loc right-loc)
        (deref right-loc))))) ;; 解引用获取右侧的值
```

`left` 和 `right` 函数分别用于从可变序对中获取左侧和右侧的值。我们使用 `deref` 操作来解引用位置，得到存储在该位置的值。

#### `setleft` 和 `setright` 函数

```scheme
(setleft : MutPair × ExpVal → Unspecified)

(define setleft
  (lambda (p val)
    (cases mutpair p
      (a-pair (left-loc right-loc)
        (setref! left-loc val))))) ;; 更新左侧位置的值

(setright : MutPair × ExpVal → Unspecified)

(define setright
  (lambda (p val)
    (cases mutpair p
      (a-pair (left-loc right-loc)
        (setref! right-loc val))))) ;; 更新右侧位置的值
```

`setleft` 和 `setright` 用于更新可变序对中左侧和右侧的值。这里我们使用 `setref!` 操作来将新的值存储在指定的位置。

#### 优化版的可变序对实现

在优化版实现中，我们只使用一个位置来表示序对。左侧的值存在这个位置，右侧的值存在相邻的位置。因此，我们可以通过对 `left-loc` 加 1 来访问右侧的值。

```scheme
(make-pair : ExpVal × ExpVal → MutPair)

(define make-pair
  (lambda (val1 val2)
    (let ((ref1 (newref val1))) ;; 为左侧值分配位置
      (let ((ref2 (newref val2))) ;; 为右侧值分配位置
        ref1))))  ;; 返回左侧位置引用
```

在这个优化的版本中，`make-pair` 函数只分配一次位置来存储两个值。

```scheme
(left : MutPair → ExpVal)

(define left
  (lambda (p)
    (deref p))) ;; 左侧的值直接解引用

(right : MutPair → ExpVal)

(define right
  (lambda (p)
    (deref (+ 1 p)))) ;; 右侧的值通过左侧位置加 1 获得
```

`left` 函数解引用传入的引用，直接返回左侧的值；而 `right` 函数通过递增引用来访问右侧的值。

```scheme
(setleft : MutPair × ExpVal → Unspecified)

(define setleft
  (lambda (p val)
    (setref! p val))) ;; 更新左侧的值

(setright : MutPair × ExpVal → Unspecified)

(define setright
  (lambda (p val)
    (setref! (+ 1 p) val))) ;; 更新右侧的值
```

`setleft` 和 `setright` 函数分别用于更新左侧和右侧的值。我们使用 `setref!` 操作来设置值，右侧的值通过对左侧的位置加 1 来访问。

#### 进一步思考

这种基于单一引用的序对表示法具有一定的效率优势，因为减少了引用操作的数量。但它也带来了潜在的问题：这种表示方式假设序对的两部分在内存中是连续的。如果某些特殊的内存管理机制（如垃圾回收器）打破了这个假设，那么这种优化可能会失败。

因此，这种表示方式虽然在简单的内存模型中非常有效，但在更复杂的内存管理环境中可能需要更仔细的考虑。这也展示了内存管理与编程语言设计之间的复杂关系。

### 总结

我们讨论了如何通过优化内存布局来实现更高效的可变序对。通过使用一个引用来表示序对的左右部分，我们减少了内存操作的次数，提高了程序的效率。

### -----------------------------------------

### 练习 4.28 [⋆⋆] 五个可变序对操作的推理规则规范

首先，我们要为五个可变序对 (Mutable Pair) 操作定义推理规则规范。可变序对涉及以下五个基本操作：

1. **make-pair**: 创建一个包含两个位置的可变序对。
2. **left**: 获取可变序对的左侧元素。
3. **right**: 获取可变序对的右侧元素。
4. **setleft**: 更新可变序对的左侧元素。
5. **setright**: 更新可变序对的右侧元素。

#### 1. make-pair 规范

`make-pair` 创建一个新的可变序对，它接收两个表达值并返回一个包含两个位置的序对。

**推理规则规范**:

$$(\text{value-of } exp_1 \ ρ \ \sigma_0) = (v_1, \sigma_1)$$  
$$(\text{value-of } exp_2 \ ρ \ \sigma_1) = (v_2, \sigma_2)$$  
$$(\text{value-of } (\text{make-pair } exp_1 \ exp_2) \ ρ \ \sigma_0) = (\text{mutpair-val}(l_1, l_2), \sigma_3)$$

- 该规范描述了 `make-pair` 的行为：首先，计算第一个和第二个表达式的值 $v_1$ 和 $v_2$，接着为两个值分配新位置 $l_1$ 和 $l_2$。最终返回包含这两个引用的 `mutpair-val`。

#### 2. left 规范

`left` 操作返回可变序对的左侧值。

**推理规则规范**:

$$(\text{value-of } exp \ ρ \ \sigma_0) = (\text{mutpair-val}(l_1, l_2), \sigma_1)$$  
$$(\text{value-of } (\text{left } exp) \ ρ \ \sigma_0) = (\sigma_1(l_1), \sigma_1)$$

- 规范描述了 `left` 操作：解引用序对的左侧位置 $l_1$，并返回该位置存储的值。

#### 3. right 规范

`right` 操作返回可变序对的右侧值。

**推理规则规范**:

$$(\text{value-of } exp \ ρ \ \sigma_0) = (\text{mutpair-val}(l_1, l_2), \sigma_1)$$  
$$(\text{value-of } (\text{right } exp) \ ρ \ \sigma_0) = (\sigma_1(l_2), \sigma_1)$$

- `right` 操作的行为与 `left` 类似，解引用右侧位置 $l_2$ 并返回存储的值。

#### 4. setleft 规范

`setleft` 更新可变序对的左侧值。

**推理规则规范**:

$$(\text{value-of } exp_1 \ ρ \ \sigma_0) = (\text{mutpair-val}(l_1, l_2), \sigma_1)$$  
$$(\text{value-of } exp_2 \ ρ \ \sigma_1) = (v_2, \sigma_2)$$  
$$(\text{value-of } (\text{setleft } exp_1 \ exp_2) \ ρ \ \sigma_0) = (82, [l_1 = v_2]\sigma_2)$$

- `setleft` 操作首先解引用并找到 `mutpair-val` 的左侧位置 $l_1$，然后将 `exp_2` 的值 $v_2$ 存储到 $l_1$ 中，返回任意值 (这里是 82)。

#### 5. setright 规范

`setright` 更新可变序对的右侧值。

**推理规则规范**:

$$(\text{value-of } exp_1 \ ρ \ \sigma_0) = (\text{mutpair-val}(l_1, l_2), \sigma_1)$$  
$$(\text{value-of } exp_2 \ ρ \ \sigma_1) = (v_2, \sigma_2)$$  
$$(\text{value-of } (\text{setright } exp_1 \ exp_2) \ ρ \ \sigma_0) = (83, [l_2 = v_2]\sigma_2)$$

- `setright` 操作与 `setleft` 类似，更新右侧位置的值，并返回任意值 (这里是 83)。

---

### 练习 4.29 [⋆⋆] 添加数组操作符：newarray、arrayref 和 arrayset

我们为语言添加数组操作符，支持数组的创建、索引访问和修改。

#### 数组的表示

我们可以将数组表示为连续的位置引用序列。数组的长度是固定的，每个位置存储一个 `ExpVal` 值。我们定义如下：

```scheme
(define-datatype array array?
  (an-array
   (length number?)  ;; 数组的长度
   (locations (listof reference?)))) ;; 数组中位置引用的列表
```

数组表示为一组引用，每个引用对应数组的一个位置。

#### newarray 操作

`newarray` 创建一个数组，所有位置初始化为相同的值。

```scheme
(define newarray
  (lambda (size init-val)
    (an-array size  ;; 创建包含初始值的数组
              (map (lambda (i) (newref init-val))
                   (range 0 size))))) ;; 为每个索引分配一个位置引用
```

`newarray` 函数创建一个包含 `size` 长度的数组，所有位置初始化为 `init-val`。

#### arrayref 操作

`arrayref` 用来解引用数组的某个位置，返回该位置的值。

```scheme
(define arrayref
  (lambda (arr index)
    (let ((loc (list-ref (array-locations arr) index))) ;; 查找位置
      (deref loc)))) ;; 返回该位置的值
```

`arrayref` 根据给定的索引，返回数组中对应位置的值。

#### arrayset 操作

`arrayset` 用于更新数组的某个位置的值。

```scheme
(define arrayset
  (lambda (arr index val)
    (let ((loc (list-ref (array-locations arr) index))) ;; 查找位置
      (setref! loc val)))) ;; 更新位置上的值
```

`arrayset` 根据索引更新数组中指定位置的值。

#### 数组示例程序

程序片段如下：

```scheme
(run "
let a = newarray(2, -99)
    p = proc (x)
        let v = arrayref(x, 1)
        in arrayset(x, 1, -(v, -1))
in begin
    arrayset(a, 1, 0);
    (p a);
    (p a);
    arrayref(a, 1)
end")
```

这个程序首先创建一个长度为 2 的数组，初始化为 -99。然后定义了一个过程 `p`，该过程修改数组中的值。最终，数组索引 1 的值从 0 被更新为 2。

---

### 练习 4.30 [⋆⋆] 添加 arraylength 和索引检查

`arraylength` 返回数组的长度，并且我们需要确保 `arrayref` 和 `arrayset` 都会检查索引是否在合法范围内。

#### arraylength 操作

```scheme
(define arraylength
  (lambda (arr)
    (array-length arr)))  ;; 返回数组的长度
```

`arraylength` 返回数组的长度，时间复杂度为常数时间。

#### 索引检查

我们需要在 `arrayref` 和 `arrayset` 中添加索引检查，以确保索引在数组长度范围内。

```scheme
(define arrayref
  (lambda (arr index)
    (if (or (< index 0) (>= index (array-length arr))) ;; 检查索引是否合法
        (error "Index out of bounds")
        (let ((loc (list-ref (array-locations arr) index)))
          (deref loc)))))  ;; 返回数组中对应位置的值
```

类似地，在 `arrayset` 中：

```scheme
(define arrayset
  (lambda (arr index val)
    (if (or (< index 0) (>= index (array-length arr))) ;; 检查索引是否合法
        (error "Index out of bounds")
        (let ((loc (list-ref (array-locations arr) index)))
          (setref! loc val)))))
```

---

通过这些规则和实现，我们为语言添加了数组操作符和必要的检查机制，使得数组操作更加安全和有效。

### -----------------------------------------

在**4.5 传参变体**这一节，我们讨论了传递参数到过程（函数）中的不同机制。传递参数的方式影响着过程的行为和结果，尤其是在参数可能被修改或者共享时。通过不同的传参方式，我们可以优化某些情况下的性能，或者控制变量的行为。接下来，我们将详细讲解几种常见的传参方式，包括它们的机制和应用场景。

### 1. 自然传参 (Pass-by-Value)
自然传参是最常见的方式。在这种方式中，当我们调用一个过程时，实参的值被复制并传递给过程的形参。在函数体中，形参只是一个本地变量，修改它不会影响到外部的实参。

**机制**：
- 实参的表达值被计算后直接传递给过程。
- 形参是实参的副本，在函数内部对形参的操作不会影响外部的实参。

**优点**：
- 这种方式非常直观，使用简单，适用于大部分场景。
- 实参的变化只在函数内部发生，不会影响外部变量的状态。

**例子**：
```scheme
(define (increment x)
  (+ x 1))

(increment 5)  ;; 结果为 6, 但实参 5 并没有被修改
```

在这个例子中，传递给 `increment` 函数的是 `5` 的副本，函数对 `x` 的修改不会影响外部的 `5`。

### 2. 按值调用 (Call-by-Reference)
按值调用（或按引用传递）中，传递给过程的是实参的引用，而不是值本身。这样，函数内对形参的修改会直接影响外部的实参。

**机制**：
- 实参的引用被传递给过程。
- 过程内的形参是一个引用，指向外部的实参。
- 修改形参的值会影响实参本身。

**优点**：
- 适用于需要在函数内部修改实参的场景。
- 避免了值的复制，在处理大型数据结构时提高了效率。

**例子**：
```scheme
(define x 5)

(define (increment-ref x-ref)
  (set! x-ref (+ x-ref 1)))

(increment-ref x)  ;; 调用后，x 被修改为 6
```

在这个例子中，传递的是 `x` 的引用，`increment-ref` 函数中修改了 `x` 的值。

### 3. 按名调用 (Call-by-Name)
按名调用是一种较为特殊的传参方式。在这种方式下，实参不会在调用时立即被求值，而是在每次需要时进行求值。按名调用更像是传递一个表达式的引用，每次使用时才进行求值。

**机制**：
- 实参作为未计算的表达式传递，每次在形参使用时才进行计算。
- 类似于将实参的表达式在函数体内“展开”。

**优点**：
- 延迟计算，适合用于只在某些条件下需要计算的场景。
- 实现了懒求值 (Lazy Evaluation)。

**例子**：
```scheme
(define (expensive-computation x)
  (if (> x 0)
      (* x 2)
      0))

(define (use-computation cond)
  (if cond
      (expensive-computation 10)
      (expensive-computation -5)))
```

在这个例子中，`expensive-computation` 只有在需要时才会被计算。

### 4. 按需调用 (Call-by-Need)
按需调用是按名调用的一种变体，主要用于懒求值编程语言中。区别在于：按名调用每次使用时都会重新求值，而按需调用只会在第一次需要时计算，之后将计算结果缓存起来，用于后续的调用。

**机制**：
- 实参的表达式最初是未求值的，第一次使用时计算并缓存。
- 之后的使用直接返回缓存值，而不会再次计算。

**优点**：
- 结合了延迟求值和性能优化，只计算一次并缓存结果。
- 避免了不必要的重复计算，适合用于懒惰求值语言。

### 5. 按共享传递 (Call-by-Sharing)
按共享传递有时也被称为“按对象传递”或“按值传递”。在这种方式中，传递的是对象的引用（类似于按引用传递），但是引用的内容是不可变的。也就是说，过程可以修改它所接收到的对象的内容，但不能改变引用指向新的对象。

**机制**：
- 实参对象的引用被传递给过程。
- 对象的属性可以被修改，但引用本身不能被重新绑定。

**应用**：
- 这种方式广泛用于面向对象语言，如 Python 和 Java，在这些语言中，对象是按共享传递的。

### 总结

传参机制对过程调用中的形参与实参之间的关系有重要影响。选择不同的传参方式，决定了参数在函数内部的可变性和效率。例如：
- 自然传参是最常见和直观的方式，适合大多数场景；
- 按引用传递则适合需要在过程内修改外部数据的场景；
- 按名和按需传递可以延迟计算，适用于惰性求值的编程场景。

了解这些不同的传参方式，可以帮助我们更好地理解过程调用的本质以及如何设计灵活、高效的程序。

### -----------------------------------------

### 4.5.1 按指调用 (Call-by-Reference)

按指调用（Call-by-Reference）是一种传参方式，在这种方式下，传递给过程的不是变量的值，而是变量的位置。过程通过这个位置引用变量，当过程修改形参时，实际修改的是调用者变量的位置内容。这与按值调用不同，按值调用仅传递变量的副本，修改副本不会影响原始变量。

按指调用通过共享变量位置，允许过程修改外部变量，因此它在需要修改传递给过程的多个变量或交换值时非常有用。

### 按指调用的机制

在按指调用中，传递的不是变量值，而是变量的存储位置。这样，过程可以直接修改调用者的变量。我们通过调整 `apply-procedure` 和 `value-of-operand` 来实现按指调用。

#### 1. `apply-procedure` 修改

`apply-procedure` 的任务是调用传递给过程的参数。如果我们使用按指调用，那么它会接收一个位置（即引用），而不是直接接收值。这意味着我们需要在 `apply-procedure` 中根据传参方式决定是否要传递引用。

```scheme
apply-procedure : Proc × ExpVal → ExpVal
(define apply-procedure
  (lambda (proc1 val)
    (cases proc proc1
      (procedure (var body saved-env)
        ;; 这里的 `extend-env` 会将传递的参数绑定到环境中
        (value-of body (extend-env var val saved-env))))))
```

在这个过程中，我们检查是否需要将值转换为引用。这样，传递给 `procedure` 的 `val` 就可以是引用了。

#### 2. `value-of-operand` 的引入

为了支持按指调用，我们需要创建一个函数 `value-of-operand`，它的作用是根据实际情况决定是传递值本身，还是传递值所在的引用。如果是变量，我们将传递引用；如果是其他类型的表达式，我们会先求值，然后创建一个新位置来存储这个值。

```scheme
value-of-operand : Exp × Env → Ref
(define value-of-operand
  (lambda (exp env)
    (cases expression exp
      ;; 如果表达式是变量类型，直接返回变量的引用
      (var-exp (var) (apply-env env var))
      ;; 否则先求值，再将值存入新位置并返回引用
      (else (newref (value-of exp env))))))
```

这个函数负责检查操作数是否为变量，如果是变量，我们获取其引用（即存储位置），否则我们会计算表达式的值并为其分配新的位置。

#### 3. 修改 `call-exp` 过程

现在我们可以在 `call-exp` 中利用 `value-of-operand` 来处理按指调用：

```scheme
(call-exp
  (rator rand)
  (let ((proc (expval->proc (value-of rator env))) 
        (arg (value-of-operand rand env)))
    ;; 通过 `apply-procedure` 将形参绑定到传递的引用
    (apply-procedure proc arg)))
```

在这里，我们将操作数传递给 `value-of-operand` 以决定是传递值还是传递引用，然后调用 `apply-procedure` 将其作为参数传递给过程。

### 举例解释

考虑以下程序：

```scheme
(let p = proc (x) set x = 4
 in let a = 3
 in begin (p a); a end)
```

在按值调用时，过程 `p` 的形参 `x` 接收的是 `a` 的值（即 3），修改 `x` 不会影响 `a`，因此程序返回 3。

而在按指调用时，`x` 绑定到 `a` 的存储位置，修改 `x` 相当于修改 `a`。因此，过程 `p` 把 4 赋值给 `a`，最终程序返回 4。

### 按指调用的好处

1. **多返回值**：按指调用允许我们通过修改引用来返回多个值。比如，在需要修改多个变量时，按指调用能够在不返回值的情况下修改多个变量的状态。
   
2. **变量交换**：按指调用的一个常见用例是交换两个变量的值，如下例：

```scheme
(let swap = proc (x) proc (y)
       let temp = x
       in begin
           set x = y;
           set y = temp
          end
 in let a = 33
 in let b = 44
 in begin ((swap a) b); -(a,b) end)
```

通过按指调用，`swap` 函数交换了 `a` 和 `b` 的值，最终返回 11。

### 代码示例及注释

以下是 `apply-procedure` 和 `value-of-operand` 的实现：

```scheme
;; apply-procedure 负责应用过程
apply-procedure : Proc × ExpVal → ExpVal
(define apply-procedure
  (lambda (proc1 val)
    (cases proc proc1
      ;; 处理过程调用，将形参绑定到实际的引用或值
      (procedure (var body saved-env)
        (value-of body (extend-env var val saved-env))))))

;; value-of-operand 判断是否返回引用或值
value-of-operand : Exp × Env → Ref
(define value-of-operand
  (lambda (exp env)
    (cases expression exp
      ;; 如果是变量，返回引用
      (var-exp (var) (apply-env env var))
      ;; 否则求值，并创建新位置来存储
      (else (newref (value-of exp env))))))
```

通过 `value-of-operand`，我们实现了按指调用的核心逻辑。每次判断是否应该传递值还是传递引用，并据此修改对应的变量内容。

### 总结

按指调用是参数传递中的一种重要机制，它通过传递变量位置（引用），允许过程直接修改外部变量。这在处理复杂数据结构、多变量返回和变量交换时非常有用。然而，按指调用也可能引入别名问题（aliasing），使得程序的可读性和调试难度增加。因此，合理使用按指调用非常重要。

### -----------------------------------------

### 练习 4.31 [⋆] 写出 CALL-BY-REFERENCE 的推理规则规范

**Call-by-Reference**（按指调用）的推理规则规范描述了传递变量的存储位置，而不是变量的值。这使得被调过程可以直接操作调用者的变量。在这里，我们将定义几种常见表达式的推理规则。

1. **变量引用** (Variable Reference)
   
   在按指调用中，变量引用会解引用存储位置，返回存储器中该位置的值。

   $$ \frac{\text{value-of}(\text{var}, \rho, \sigma) = \rho(\text{var})}{\text{result} = \sigma(\rho(\text{var}))} $$

2. **赋值操作** (Assignment)

   在按指调用中，赋值操作将修改变量的存储位置的内容。

   $$ \frac{\text{value-of}(e_1, \rho, \sigma_0) = \sigma_0(l), \text{value-of}(e_2, \rho, \sigma_1) = v}{\text{value-of}(\text{assign-exp}, \rho, \sigma_0) = (v, [l = v]\sigma_1)} $$

3. **过程调用** (Procedure Application)

   在按指调用中，形参与实参指向相同的存储位置，所以修改形参将影响实参。

   $$ \frac{\text{value-of}(e_{\text{rator}}, \rho, \sigma_0) = \text{proc}, \text{value-of}(e_{\text{rand}}, \rho, \sigma_1) = \text{ref}}{\text{apply-procedure}(\text{proc}, \text{ref}, \sigma_1) = \text{value-of}(\text{body}, \rho', \sigma_2)} $$

   其中，$\rho'$ 是通过扩展环境 $\rho$，将过程的形参绑定到实际的存储位置。

### 练习 4.32 [⋆] 扩展语言 CALL-BY-REFERENCE，支持多参数过程

**多参数过程**的 CALL-BY-REFERENCE 版本要求传递多个参数的存储位置，使得每个形参都可以操作调用者提供的对应变量。

#### 规范

1. **多参数过程定义**：

   在过程定义中，每个形参都会与对应的实参位置绑定。

   $$ \text{value-of}(\text{proc}(\text{params}), \rho, \sigma) = \lambda(\text{params}) \rightarrow \text{body} $$

2. **多参数过程调用**：

   在过程调用时，每个形参会指向相应的实参存储位置。

   $$ \frac{\text{value-of}(e_{\text{rator}}, \rho, \sigma_0) = \text{proc}, \text{value-of}(e_{\text{rand}_i}, \rho, \sigma_i) = \text{ref}_i}{\text{apply-procedure}(\text{proc}, [\text{ref}_1, \ldots, \text{ref}_n], \sigma_n) = \text{value-of}(\text{body}, \rho', \sigma_{n+1})} $$

#### 实现示例

```scheme
(define apply-procedure
  (lambda (proc1 vals)
    (cases proc proc1
      (procedure (vars body saved-env)
        (value-of body (extend-envs vars vals saved-env))))))

(define value-of-operand
  (lambda (exp env)
    (cases expression exp
      (var-exp (var) (apply-env env var))
      (else (newref (value-of exp env))))))
```

通过扩展 `apply-procedure` 支持多个参数和多个存储引用。

### 练习 4.33 [⋆⋆] 扩展语言 CALL-BY-REFERENCE，也令其支持按值调用的过程

为了支持按值调用和按指调用共存，语言需要区分两种不同的传参方式。我们可以通过为过程增加一种标志来决定是按值传递还是按指传递。

#### 规范

1. **按值调用的过程**：

   在按值调用中，传递的是实参的值，而非位置。

   $$ \frac{\text{value-of}(e_{\text{rator}}, \rho, \sigma_0) = \text{proc}, \text{value-of}(e_{\text{rand}}, \rho, \sigma_1) = v}{\text{apply-procedure-value}(\text{proc}, v, \sigma_1) = \text{value-of}(\text{body}, \rho', \sigma_2)} $$

2. **按指调用的过程**：

   传递的是实参的存储位置。

   $$ \frac{\text{value-of}(e_{\text{rator}}, \rho, \sigma_0) = \text{proc}, \text{value-of}(e_{\text{rand}}, \rho, \sigma_1) = \text{ref}}{\text{apply-procedure-ref}(\text{proc}, \text{ref}, \sigma_1) = \text{value-of}(\text{body}, \rho', \sigma_2)} $$

#### 实现示例

```scheme
(define apply-procedure
  (lambda (proc1 val call-by-ref?)
    (cases proc proc1
      (procedure (var body saved-env)
        (if call-by-ref?
            (value-of body (extend-env var (apply-env env var) saved-env))
            (value-of body (extend-env var val saved-env)))))))
```

### 练习 4.34 [⋆] 给语言添加按指调用的 `let`，名为 `letref`

`letref` 是按指调用版的 `let`。它将绑定的变量指向现有的存储位置，使得后续的修改会影响调用者的变量。

#### 规范

1. **`letref` 绑定**：

   在 `letref` 中，变量绑定到已经存在的存储位置，而不是分配新的位置。

   $$ \text{value-of}(\text{letref var = e1 in body}, \rho, \sigma) = \text{value-of}(\text{body}, [\text{var} \mapsto \rho(e1)], \sigma) $$

#### 实现示例

```scheme
(define value-of-letref
  (lambda (var exp body env)
    ;; 不分配新位置，而是直接绑定到现有引用
    (let ((loc (apply-env env var)))
      (value-of body (extend-env var loc env)))))
```

### 结论

通过实现 CALL-BY-REFERENCE（按指调用）机制，我们能够让过程直接操作调用者的变量，从而允许传递多个值或修改外部变量。这种传参方式对特定场景，如交换变量值或通过过程返回多个值非常有用。

`letref` 的扩展让我们能够在按指调用中实现更多灵活的变量绑定，使得变量操作更加简洁高效。

### 练习 4.35 [⋆⋆] 

**目标**：扩展按值调用的框架，添加一种新表达式 `ref Identifier`，使得我们能够在按值调用的语言中享受按指调用的便利。实现的核心是允许通过变量引用来修改变量的值。

#### 规范

1. **新表达式 `ref`**：

   `ref` 用来创建一个指向某个变量的引用，这个引用可以在按值调用中传递，从而允许修改该变量的值。其语法定义为：

   ```scheme
   Expression ::= ref Identifier
   ref-exp (var)
   ```

2. **表达值 (ExpVal) 和指代值 (DenVal)**：

   - **表达值**：`ExpVal = Int + Bool + Proc`
   - **指代值**：`DenVal = Ref(ExpVal)` 

   这意味着，变量的值在存储中指向其位置，通过 `ref` 表达式，我们可以获得这个位置的引用。

#### 实现

1. **扩展表达式处理逻辑**：

   新表达式 `ref` 的实现类似于获取变量的存储位置，而不是变量的值。这允许我们在按值调用中使用按指调用的机制。

```scheme
(define value-of
  (lambda (exp env)
    (cases expression exp
      (ref-exp (var)
        ;; 返回变量的存储位置，而不是变量的值
        (apply-env env var))
      (other-exps ...))))
```

2. **示例：交换两个变量的值**：

   我们通过 `ref` 将变量 `a` 和 `b` 的引用传递给 `swap` 函数，实现类似按指调用的效果。

```scheme
(run "
let a = 3
b = 4
in let swap = proc (x) proc (y)
let temp = deref(x)
in begin
setref(x,deref(y));
setref(y,temp)
end
in begin ((swap ref a) ref b); -(a,b) end")
```

在此代码中，`ref` 将变量 `a` 和 `b` 的存储位置作为参数传递给 `swap`。这样，`swap` 函数能够直接修改 `a` 和 `b` 的值。程序返回 `-1`，因为 `a` 和 `b` 的值被成功交换。

#### 结果分析

该程序的结果为 $-1$，因为调用 `swap` 后，`a` 和 `b` 的值被交换。原来 `a = 3`，`b = 4`，调用 `swap` 后，`a = 4`，`b = 3`，因此 `-(a,b)` 的结果为 $3 - 4 = -1$。

### 练习 4.36 [⋆]

**目标**：扩展按指调用语言，处理数组的引用，使数组元素的引用能够通过 `swap` 函数进行交换。

#### 规范

1. **数组的处理**：

   数组元素的引用应该与变量的引用处理方式一致。即数组引用不传递其内容，而是传递数组元素的位置。

2. **扩展 `value-of-operand`**：

   修改 `value-of-operand`，使其能够正确处理数组引用。当操作数是数组引用时，我们需要传递引用的位置，而不是内容。

#### 实现

```scheme
(define value-of-operand
  (lambda (exp env)
    (cases expression exp
      (var-exp (var)
        ;; 对于变量，返回其存储位置
        (apply-env env var))
      (arrayref-exp (arr idx)
        ;; 对于数组引用，返回数组元素的位置
        (let ((array (value-of arr env))
              (index (value-of idx env)))
          (array-ref-loc array index)))
      (else
        ;; 对于其他表达式，求值并创建新引用
        (newref (value-of exp env))))))
```

#### 示例

1. **交换数组元素的值**：

   ```scheme
   (run "
   let a = newarray(2, -99)
   in let swap = proc (x) proc (y)
   let temp = deref(x)
   in begin
   setref(x,deref(y));
   setref(y,temp)
   end
   in begin ((swap (arrayref a 0)) (arrayref a 1)); arrayref(a 0) end")
   ```

   在这里，我们通过 `swap` 函数交换数组 `a` 中索引 `0` 和 `1` 处的值。

2. **嵌套数组引用**：

   ```scheme
   (run "
   let a = newarray(2, newarray(2, -99))
   in let swap = proc (x) proc (y)
   let temp = deref(x)
   in begin
   setref(x,deref(y));
   setref(y,temp)
   end
   in begin ((swap (arrayref a (arrayref a 0))) (arrayref a 1)); arrayref(a 0) end")
   ```

   这里，我们尝试嵌套数组引用，通过 `swap` 交换数组内部的元素。程序能够正常执行，因为 `arrayref` 会正确返回引用位置。

### 练习 4.37 [⋆⋆]

**目标**：实现按值和结果调用的机制，这种调用方式的不同点在于实参的值会在过程返回时被复制回原位置。

#### 规范

1. **按值和结果调用**：

   在这种调用方式中，实参的初始值会被复制到新的引用中，过程执行结束时，新的引用的值会被复制回原始的实参引用。

#### 实现

1. **扩展 `apply-procedure`**：

   修改 `apply-procedure`，使其在调用返回时将形参的值复制回实参的存储位置。

```scheme
(define apply-procedure
  (lambda (proc1 val result-ref?)
    (cases proc proc1
      (procedure (var body saved-env)
        (let ((temp-ref (newref val)))
          (let ((result (value-of body (extend-env var temp-ref saved-env))))
            ;; 在返回时，复制结果回实参位置
            (if result-ref?
                (setref! val (deref temp-ref)))
            result))))))
```

2. **示例**

```scheme
(run "
let swap = proc (x) proc (y)
let temp = deref(x)
in begin
setref(x,deref(y));
setref(y,temp)
end
in let a = 3
in let b = 4
in begin ((swap ref a) ref b); -(a,b) end")
```

在按值和结果调用的实现中，实参的值会被复制回去，类似于按指调用。这段代码会返回 `-1`。

#### 结果分析

通过按值和结果调用，变量的值会在过程结束后复制回去，确保最终的实参值与过程执行中的结果一致。

### -----------------------------------------

### 4.5.2 懒求值：按名调用和按需调用

在这一节中，我们探讨一种截然不同的参数传递机制，名为 **懒求值 (Lazy Evaluation)**。懒求值在某些情况下能极大提高程序的性能和灵活性，因为操作数的值直到过程主体需要时才会求取。

#### 概念概述：

- **按名调用 (Call-by-name)**：操作数的值在需要时才会求值。如果过程主体没有使用参数，那么操作数的值将永远不会被计算。这种方式延迟了表达式的求值，避免了不必要的计算。
  
- **按需调用 (Call-by-need)**：按名调用的增强版本。在按需调用中，操作数一旦求值，结果会被缓存起来以供后续使用。这种策略叫做 **助记法 (Memoization)**。

通过懒求值的参数传递机制，我们可以避免不必要的计算，尤其是在某些无限循环的情况下，懒求值能够使程序终止。例如：

```scheme
letrec infinite-loop (x) = infinite-loop(-(x,-1))
in let f = proc (z) 11
in (f (infinite-loop 0))
```

在按名调用下，`f` 过程不引用其参数，因此 `(f (infinite-loop 0))` 不会触发无限循环，程序返回 `11`。

### 实现思路

#### 1. **值箱 (Thunk)**

为了实现懒求值，我们引入了一种新的数据类型——**值箱 (Thunk)**。值箱包含一个表达式及其环境，只有当需要时才会对表达式求值。

```scheme
(define-datatype thunk thunk?
  (a-thunk
    (exp1 expression?)     ; 表达式
    (env environment?)))   ; 环境
```

#### 2. **指代值与表达值的区分**

在懒求值中，变量绑定到一个指代值，而指代值可以是未求值的表达式（即值箱）或已经求值的表达值。因此，指代值的定义如下：

- **DenVal**：`DenVal = Ref(ExpVal + Thunk)`
- **ExpVal**：`ExpVal = Int + Bool + Proc`

这意味着每个指代值要么是一个引用，要么是一个值箱。按名调用时，只有在过程引用该值时，才会对值箱求值。

#### 3. **按名调用的实现**

对于按名调用，我们需要延迟操作数的求值，并在必要时对值箱进行求值。

```scheme
(var-exp (var)
  (let ((ref1 (apply-env env var)))   ; 获取指代值
    (let ((val (deref ref1)))         ; 解引用，获取值或值箱
      (if (expval? val)               ; 如果是表达值，则返回
          val
          (value-of-thunk val)))))    ; 否则求值箱的值
```

#### 4. **按需调用的实现**

在按需调用中，我们进一步优化：如果一个值箱的值已经被求出，我们会将结果缓存到相应的存储位置，以避免重复求值。

```scheme
(var-exp (var)
  (let ((ref1 (apply-env env var)))    ; 获取指代值
    (let ((val (deref ref1)))          ; 解引用，获取值或值箱
      (if (expval? val)                ; 如果是表达值，则返回
          val
          (let ((val1 (value-of-thunk val)))  ; 否则求值箱的值
            (begin
              (setref! ref1 val1)      ; 将结果缓存到存储位置
              val1))))))
```

#### 5. **值箱求值**

当我们需要对值箱求值时，调用 `value-of-thunk` 函数，对值箱中的表达式进行求值。

```scheme
(define value-of-thunk
  (lambda (th)
    (cases thunk th
      (a-thunk (exp1 saved-env)
        (value-of exp1 saved-env)))))  ; 在保存的环境中求值表达式
```

### 关键概念和比较

1. **按名调用 (Call-by-name)**：表达式被延迟求值，直到参数被需要时才会求取。在 `var-exp` 中，如果一个变量指向一个未求值的值箱，它会在需要时被求值。

2. **按需调用 (Call-by-need)**：按名调用的改进版，通过 **助记法 (Memoization)** 优化，求值后将结果存储下来，避免重复求值。

3. **与即时求值的比较**：即时求值（或急切求值）总是立刻求出操作数的值，而懒求值推迟了这个过程，只有在使用参数时才会进行求值。这使得懒求值更高效，尤其是在一些递归调用或不必要的操作中。

### 示例

考虑如下示例：

```scheme
(run "
letrec infinite-loop (x) = infinite-loop(-(x,-1))
in let f = proc (z) 11
in (f (infinite-loop 0))")
```

使用按名调用时，`f` 的参数永远不会被求值，因为 `f` 的定义不需要它的参数。结果返回 `11`，而不是陷入无限递归。

### 总结

懒求值是编程语言中的一种延迟求值策略，通过将表达式的求值推迟到真正需要的时候，避免了不必要的计算。这种策略在无副作用的纯函数式编程中尤为有效，特别是在解决递归调用和避免不必要的复杂计算时。按名调用是基础，按需调用则在此基础上进行了优化。

### -----------------------------------------

### 解答：练习 4.38

#### 题目概述：

在练习 4.38 中，题目让我们比较 **按需调用 (Call-by-need)** 和 **按值调用 (Call-by-value)** 的区别。题目提供了一个递归构造器程序，并让我们分析该程序在按值调用和按需调用中的行为。

#### 提供的示例：

```scheme
let makerec = proc (f)
  let d = proc (x) (f (x x))
  in (f (d d))
in let maketimes4 = proc (f)
  proc (x)
    if zero?(x)
    then 0
    else -((f -(x,1)), -4)
in let times4 = (makerec maketimes4)
in (times4 3)
```

#### 问题分析：

1. **按需调用 (Call-by-need)**：
   - 在按需调用中，表达式在被真正使用之前不会求值。按需调用也会使用 **助记法 (Memoization)**，即一旦求值完成，结果会被存储，以避免重复计算。
   
2. **按值调用 (Call-by-value)**：
   - 按值调用会立即对操作数求值，因此即使表达式没有使用，值也会被计算。

这段代码中的关键部分是：

```scheme
let makerec = proc (f)
  let d = proc (x) (f (x x))
  in (f (d d))
```

这个代码的核心是在 `d` 中递归调用 `f`，其中 `(x x)` 构造了一个复杂的递归结构。

- **按需调用**：
  - 在按需调用中，函数 `f` 的参数只有在需要时才会求值。因此，这段递归的 `x x` 结构可能不会立即触发深度递归，除非 `f` 真正使用了 `x` 的值。
  
- **按值调用**：
  - 在按值调用中，`(x x)` 会立即求值，可能导致无限递归，特别是在 `d d` 中传递 `x` 时。按值调用的结果会陷入无限递归，导致程序无法终止。

### 解答思路：

我们分析程序在不同调用策略下的行为：

#### 1. **按需调用的行为**：
   - 由于按需调用只在必要时才会计算参数，因此当递归调用 `(d d)` 时，`f` 的值不会立即被递归展开。这允许递归结构以懒求值方式进行，避免了无限递归问题。因此，程序可以顺利运行并计算 `times4(3)` 的结果。

#### 2. **按值调用的行为**：
   - 按值调用会立即计算 `(x x)`，这将导致 `d d` 的立即递归展开，并导致无限递归。因此，程序在按值调用时会陷入无限递归，无法正常终止。

### 代码实现与解释：

```scheme
(let makerec = proc (f)            ; 定义递归构造器 makerec
  let d = proc (x)                 ; d 是一个递归的过程
    (f (x x))                      ; f 应用到 (x x) 递归调用
  in (f (d d))                     ; 调用 f，并把 (d d) 作为参数
in let maketimes4 = proc (f)       ; maketimes4 是用来创建 times4 过程的
  proc (x)                         ; 返回一个计算 4 倍数的过程
    if zero?(x)
    then 0                         ; 当 x 为 0 时返回 0
    else -((f -(x,1)), -4)          ; 否则递归调用 f，并进行减法计算
in let times4 = (makerec maketimes4) ; 创建 times4 过程
in (times4 3))                      ; 调用 times4 计算 4 的倍数
```

### 结论：

- **按需调用**：程序能正常运行，因为它延迟了参数的求值，不会在调用 `d d` 时立即展开递归。
- **按值调用**：程序将陷入无限递归，因为 `(x x)` 会被立即求值，导致递归展开。

---

### 解答：练习 4.39

#### 问题要求：

设计一个例子，使得 **按名调用 (Call-by-name)** 和 **按需调用 (Call-by-need)** 产生不同的答案。

#### 思路：

按名调用和按需调用的主要区别在于：按需调用会缓存计算结果，而按名调用则每次都会重新计算。因此，我们可以构造一个例子，其中某个表达式多次引用相同的参数，并在每次引用时计算的结果不同。

#### 示例代码：

```scheme
let x = proc () random()   ; 定义一个过程，每次调用生成随机数
in let f = proc (y) -(y, y) ; f 函数取两个 y 并做减法
in (f (x))                 ; 调用 f
```

#### 解释：

- **按名调用**：每次调用 `y` 时都会重新计算 `random()`，结果不同，因此 `y - y` 会返回不同的值（两次 `random()` 调用返回不同的值）。
- **按需调用**：第一次调用 `random()` 的值会被缓存，后续使用时不会重新求值，因此 `y - y` 的结果总是 0（因为缓存了相同的 `random()` 值）。

### 代码实现与解释：

```scheme
(let x = proc () random()          ; 定义一个生成随机数的过程
 in let f = proc (y) -(y, y)       ; f 函数取参数 y，并计算 y - y
 in (f (x)))                       ; 调用 f 并传入 (x)
```

### 结论：

- **按名调用**：每次调用 `y` 时，`random()` 会返回不同的值，因此 `y - y` 不会是 0。
- **按需调用**：`random()` 只会调用一次，结果被缓存，`y - y` 结果总是 0。

---

### 解答：练习 4.40

#### 题目要求：

修改 `value-of-operand`，使其避免为常量和过程生成值箱。

#### 思路：

在懒求值中，只有在表达式需要延迟求值时，我们才创建值箱。对于常量和过程，显然不需要创建值箱，因为它们的值是确定的，无需延迟计算。因此，我们可以检查表达式类型，避免为常量和过程创建值箱。

#### 代码实现：

```scheme
(define value-of-operand
  (lambda (exp env)
    (cases expression exp
      (var-exp (var) (apply-env env var))      ; 变量的值直接从环境获取
      (const-exp (val) (newref val))           ; 常量直接返回
      (proc-exp (params body)                  ; 过程也直接返回
        (newref (proc-val (procedure params body env))))
      (else (newref (a-thunk exp env)))))      ; 其他表达式使用值箱
```

#### 解释：

- **常量表达式 (const-exp)**：直接将值存储，而不是创建值箱。
- **过程表达式 (proc-exp)**：直接将过程的定义存储，而不是创建值箱。
- **其他表达式**：使用懒求值，创建值箱，并延迟求值。

### 结论：

通过对常量和过程进行特殊处理，避免不必要的值箱创建，从而优化懒求值的效率。

---

### 解答：练习 4.41

#### 按名调用和按需调用的推理规则规范

按名调用和按需调用的推理规则类似，但在按需调用中，我们引入了缓存计算结果的机制。我们将通过规则规范来定义它们的不同点。

- **按名调用 (Call-by-name)**：
  - 操作数在每次使用时重新计算。
  
- **按需调用 (Call-by-need)**：
  - 操作数第一次求值时，计算结果被缓存，后续使用时直接返回缓存值。

#### 规则规范

##### 按名调用：

```
(value-of (var-exp var) ρ σ) = (σ(ρ(var)), σ)
```

##### 按需调用：

```
(value-of (var-exp var) ρ σ) = 
  if (σ(ρ(var)) is Thunk)
    then (val, [ρ(var) = val]σ)
    else (σ(ρ(var)), σ)
```

#### 结论：

- **按名调用**：每次使用时重新计算。
- **按需调用**：第一次计算后缓存结果，后续直接返回。

---

### 解答：练习 4.42

#### 给按需调用解释器添加懒求值的 `let`

#### 代码实现：

```scheme
(let-exp (var exp1 body)
  (let ((val

1 (newref (a-thunk exp1 env))))    ; 创建值箱
    (value-of body (extend-env var val1 env)))) ; 延迟求值
```

#### 解释：

在 `let` 表达式中，`exp1` 被包装为一个值箱，并在需要时才求值。

### -----------------------------------------



### -----------------------------------------

### -----------------------------------------

### -----------------------------------------

### -----------------------------------------

### -----------------------------------------


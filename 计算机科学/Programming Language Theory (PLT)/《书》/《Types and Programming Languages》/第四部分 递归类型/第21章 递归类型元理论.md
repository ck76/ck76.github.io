[toc]







### -------------------------------------

我们从第21章 "递归类型的元理论" 开始，逐步详解每个部分，确保没有遗漏任何内容，包括练习的解答以及图示和公式的详细分析。

## 21 递归类型的元理论 (Metatheory of Recursive Types)

### 概述
在第20章中，我们看到了递归类型的两种不同表示方法：等递归类型 (equirecursive types) 和同构递归类型 (iso-recursive types)。前者是定义上与其展开形式等价的类型，后者则通过折叠 (fold) 和展开 (unfold) 来显式证明这种等价性。在本章中，我们将探讨等递归类型的类型检查器的理论基础。相比之下，同构递归类型的实现相对简单。

我们将讨论包括递归类型和子类型在内的系统，因为在实际应用中它们通常是结合在一起使用的。即使没有子类型，处理等递归类型的系统也只会稍微简单一些，因为我们仍然需要检查递归类型的等价性。

### 理论基础
子类型推导可以直观地理解为无限类型上的无限推导。在本章中，我们将使用协同归纳 (coinduction) 数学框架来精确描述这一直觉，并连接无限树和推导与有限表示之间的关系。

---

## 21.1 归纳与协同归纳 (Induction and Coinduction)

为了理解等递归类型的子类型推导的元理论，我们需要回顾归纳 (induction) 和协同归纳 (coinduction) 的基本理论。

### 定义

**21.1.1 定义**: 给定一个全集 $U$，函数 $F \in P(U) \to P(U)$ 是单调的，当 $X \subseteq Y$ 时，$F(X) \subseteq F(Y)$。这里 $P(U)$ 是 $U$ 的幂集（即 $U$ 的所有子集的集合）。

我们通常称 $F$ 为生成函数 (generating function)。

#### 解释
单调函数 $F$ 可以看作一种生成规则，它根据输入集合产生一个新的集合。生成规则是推导过程中的核心概念，推导规则中的每一步都可以视为由 $F$ 生成的新元素。

---

### 集合定义

**21.1.2 定义**: 设 $X$ 是 $U$ 的子集。
1. $X$ 是 $F$-闭合的 (F-closed)，如果 $F(X) \subseteq X$。
2. $X$ 是 $F$-一致的 (F-consistent)，如果 $X \subseteq F(X)$。
3. $X$ 是 $F$ 的不动点 (fixed point)，如果 $F(X) = X$。

#### 解释
直观地，可以将 $U$ 的元素看作一些命题或断言，$F$ 表示一个“推导”关系。$F$-闭合集合表示，给定一组命题后，无法再推导出新的命题。$F$-一致集合表示，集合中的每个命题都可以由集合中的其他命题推导出来。$F$ 的不动点则是既闭合又一致的集合。

---

### 例子

**21.1.3 例子**: 考虑如下生成函数 $E_1$，定义在三元素的全集 $U = \{a, b, c\}$ 上：

$$
\begin{aligned}
E_1(\emptyset) &= \{c\} \\
E_1(\{a\}) &= \{c\} \\
E_1(\{b\}) &= \{c\} \\
E_1(\{c\}) &= \{b, c\} \\
E_1(\{a, c\}) &= \{b, c\} \\
E_1(\{a, b\}) &= \{c\} \\
E_1(\{b, c\}) &= \{a, b, c\} \\
E_1(\{a, b, c\}) &= \{a, b, c\}
\end{aligned}
$$

这里，唯一的 $E_1$-闭合集合是 $\{a, b, c\}$。而 $E_1$-一致的集合则有四个：$\emptyset, \{c\}, \{b, c\}, \{a, b, c\}$。

---

### Knaster-Tarski 定理

**21.1.4 定理 [Knaster-Tarski]**:
1. 所有 $F$-闭合集合的交集是 $F$ 的最小不动点 (least fixed point)。
2. 所有 $F$-一致集合的并集是 $F$ 的最大不动点 (greatest fixed point)。

#### 证明
证明比较复杂，这里略去细节。我们重点理解两个不动点的含义：

- 最小不动点 $\mu F$ 是最小的 $F$-闭合集合。
- 最大不动点 $\nu F$ 是最大的 $F$-一致集合。

---

### 协同归纳原理

**21.1.8 推论**:
1. 归纳原理：如果 $X$ 是 $F$-闭合的，那么 $\mu F \subseteq X$。
2. 协同归纳原理：如果 $X$ 是 $F$-一致的，那么 $X \subseteq \nu F$。

#### 解释
归纳原理与常规归纳类似，如果一个性质对于某个集合 $X$ 总是成立，并且 $X$ 是闭合的，那么这个性质对最小不动点也成立。协同归纳原理提供了证明某个元素属于最大不动点的方式：如果能够找到一个包含该元素的 $F$-一致集合，那么这个元素一定属于 $\nu F$。

---

### 习题

**21.1.9 习题**: 证明在自然数上的普通归纳原理和词典序归纳原理可以从上述归纳原理推出。

#### 解答：
这个习题要求我们展示自然数上的归纳原理和词典序归纳如何从 $21.1.8$ 中的归纳原理得出。我们可以通过构建合适的 $F$ 来实现这个目标。对于自然数的普通归纳，我们可以让 $F(X)$ 代表“如果 $n$ 属于 $X$，那么 $n+1$ 也属于 $X$”，进而证明 $\mu F$ 就是自然数集合 $\mathbb{N}$。

---

接下来，我们继续分析第21.2节，探讨有限和无限类型的概念。

### ---------------------------

## 21.2 有限类型与无限类型 (Finite and Infinite Types)

在这一节中，我们将递归类型通过树的形式来表示，并且分析有限类型和无限类型的关系。

### 树类型的定义

为了方便讨论，假设我们只讨论三种类型构造符：箭头类型 $\to$，乘积类型 $\times$，和顶类型 (Top)。这些类型可以用标记树的方式来表示，其中树的节点由 $\to$、$\times$ 和 Top 这三个符号标记。

**21.2.1 定义**: 树类型 (tree type) 是一个部分函数 $T \in \{1, 2\}^* \to \{\to, \times, Top\}$，满足以下条件：

1. $T(\cdot)$ 是定义的；
2. 如果 $T(\pi, \sigma)$ 是定义的，那么 $T(\pi)$ 也是定义的；
3. 如果 $T(\pi) = \to$ 或 $T(\pi) = \times$，则 $T(\pi,1)$ 和 $T(\pi,2)$ 是定义的；
4. 如果 $T(\pi) = Top$，则 $T(\pi,1)$ 和 $T(\pi,2)$ 是未定义的。

树类型 $T$ 是有限的，当且仅当其定义域是有限的。所有树类型的集合记作 $T$，其中所有有限树类型的子集记作 $T_f$。

#### 解释
树类型的定义通过递归构造，表示递归类型可以被看作是树状结构。每个节点代表一种类型构造符，如箭头类型 ($\to$) 表示函数类型，乘积类型 ($\times$) 表示元组类型，而顶类型 (Top) 则表示类型系统中的最大类型（类似于其他类型的超集）。

---

### 树类型的组合

我们可以用已有的树类型组合新的树类型。例如，如果 $T_1$ 和 $T_2$ 是两棵树，我们可以定义：

- $T_1 \times T_2$ 为一个树类型，其中 $(T_1 \times T_2)(\cdot) = \times$，并且 $(T_1 \times T_2)(i,\pi) = T_i(\pi)$；
- $T_1 \to T_2$ 为一个树类型，其中 $(T_1 \to T_2)(\cdot) = \to$，并且 $(T_1 \to T_2)(i,\pi) = T_i(\pi)$，对于 $i = 1, 2$。

#### 例子
例如，$(Top \times Top) \to Top$ 是一个有限树类型。它的定义可以表示为：

$$
T(\cdot) = \to, \ T(1) = \times, \ T(2) = Top, \ T(1,1) = Top, \ T(1,2) = Top
$$

而类似于 $Top \to (Top \to (Top \to ...))$ 则表示一个无限树类型，其中类型不断嵌套。

图 21-1 中展示了两个树类型的例子：

- $(Top \times Top) \to Top$
- $Top \to (Top \to (Top \to ...))$

这两个例子展示了有限和无限树类型的基本形态。

---

### 树类型的推导 (Grammar for Tree Types)

有限树类型可以通过以下语法来定义：

$$
T ::= Top \ | \ T \times T \ | \ T \to T
$$

有限树类型的集合 $T_f$ 是该生成函数的最小不动点，记作 $\mu F$，而无限树类型的集合 $T$ 是该生成函数的最大不动点，记作 $\nu F$。这是使用归纳与协同归纳来定义树类型的一种方式。

---

### 习题解答

**21.2.2 习题**: 根据前面的讨论，建议一个全集 $U$ 和一个生成函数 $F \in P(U) \to P(U)$，使得有限树类型的集合 $T_f$ 是 $F$ 的最小不动点，而所有树类型的集合 $T$ 是 $F$ 的最大不动点。

#### 解答：
我们可以定义 $U = \{1, 2\}^* \times \{\to, \times, Top\}$，即所有可能的树结构（无论是有限的还是无限的）。然后我们定义生成函数 $F$ 以递归方式生成树类型：

1. $Top$ 是一个树类型；
2. 如果 $T_1$ 和 $T_2$ 是树类型，那么 $T_1 \times T_2$ 也是树类型；
3. 如果 $T_1$ 和 $T_2$ 是树类型，那么 $T_1 \to T_2$ 也是树类型。

有限树类型的集合 $T_f$ 是这个生成函数 $F$ 的最小不动点，而所有树类型的集合 $T$ 是 $F$ 的最大不动点。

---

## 21.3 子类型 (Subtyping)

接下来我们定义树类型的子类型关系。对于有限树类型，我们可以通过最小不动点来定义子类型关系，而对于无限树类型，则使用最大不动点。

### 有限子类型的定义

**21.3.1 定义**: 对于两个有限树类型 $S$ 和 $T$，如果 $(S, T) \in \mu S_f$，则 $S$ 是 $T$ 的子类型，记作 $S <: T$。

生成函数 $S_f$ 定义如下：

$$
S_f(R) = \{(T, Top) \mid T \in T_f\} \cup \{(S_1 \times S_2, T_1 \times T_2) \mid (S_1, T_1), (S_2, T_2) \in R\} \cup \{(S_1 \to S_2, T_1 \to T_2) \mid (T_1, S_1), (S_2, T_2) \in R\}
$$

#### 解释
这个生成函数描述了树类型之间的子类型关系，涵盖了三种推导规则：

1. 任意类型 $T$ 都是顶类型 (Top) 的子类型。
2. 如果 $S_1$ 是 $T_1$ 的子类型，$S_2$ 是 $T_2$ 的子类型，那么 $S_1 \times S_2$ 是 $T_1 \times T_2$ 的子类型。
3. 如果 $T_1$ 是 $S_1$ 的子类型，$S_2$ 是 $T_2$ 的子类型，那么 $S_1 \to S_2$ 是 $T_1 \to T_2$ 的子类型。

---

### 无限子类型的定义

**21.3.2 定义**: 对于任意（有限或无限）树类型 $S$ 和 $T$，如果 $(S, T) \in \nu S$，则 $S$ 是 $T$ 的子类型。

生成函数 $S$ 的定义与有限子类型的生成函数一致，只是我们使用最大不动点 $\nu S$ 来描述无限树类型的子类型关系。

---

### 习题解答

**21.3.3 习题**: 检查 $\nu S$ 不是 $T \times T$ 的全集，举例说明某对 $(S, T)$ 不属于 $\nu S$。

#### 解答：
可以构造一个简单的例子，如 $S = Top$，$T = Top \times Top$。根据生成函数的定义，$S <: Top$，但 $S$ 并不是 $T$ 的子类型，因为 $Top$ 不是 $Top \times Top$ 的子类型。

---

**21.3.4 习题**: 是否存在某对类型 $(S, T)$ 满足 $\nu S$，但不满足 $\mu S$？是否存在某对类型 $(S, T)$ 满足 $\nu S_f$，但不满足 $\mu S_f$？

#### 解答：
在无限类型的情况下，确实可能存在某对 $(S, T)$ 满足 $\nu S$，但不满足 $\mu S$。例如，考虑 $S = Top \to Top$ 和 $T = (Top \to Top) \to Top$，在无限类型中，它们之间的子类型关系可能由协同归纳来证明。

对于第二个问题，同样可以找到类似的例子，说明某些子类型关系只在无限类型中成立。

---

### 子类型关系的传递性

**21.3.5 定义**: 如果一个关系 $R \subseteq U \times U$ 满足闭合条件 $T_R(R) = \{(x, y) \mid \exists z \in U. (x, z), (z, y) \in R\}$，则称 $R$ 是传递的 (transitive)。

#### 解释
传递性是子类型关系中的一个

### ----------------------------

## 子类型关系的传递性

### **21.3.5 定义**: 
如果一个关系 $R \subseteq U \times U$ 满足闭合条件：

$$
T_R(R) = \{(x, y) \mid \exists z \in U, (x, z) \in R \ \text{且} \ (z, y) \in R\}
$$

则称 $R$ 是传递的 (transitive)。

#### 解释：
传递性意味着如果 $x$ 是 $z$ 的子类型，而 $z$ 是 $y$ 的子类型，则 $x$ 必然也是 $y$ 的子类型。传递性对于类型系统中的推导非常关键，确保类型的子类型关系可以通过多步推导得到。

---

### **21.3.6 引理**:
设 $F \in P(U \times U) \to P(U \times U)$ 是一个单调函数。如果对任意 $R \subseteq U \times U$ 都有 $T_R(F(R)) \subseteq F(T_R(R))$，则 $\nu F$ 是传递的。

#### 证明：
因为 $\nu F$ 是 $F$ 的不动点，所以有 $\nu F = F(\nu F)$，因此 $T_R(\nu F) = T_R(F(\nu F))$。根据引理的假设，$T_R(\nu F) \subseteq F(T_R(\nu F))$。这意味着 $T_R(\nu F)$ 是 $F$-一致的，因此根据协同归纳原理 (coinduction principle)，我们得到 $T_R(\nu F) \subseteq \nu F$。换句话说，根据 **21.3.5** 的定义，$\nu F$ 是传递的。

#### 解释：
该引理说明，使用协同归纳定义的子类型关系 $\nu F$ 是传递的。如果我们有一系列类型通过子类型关系彼此连接，这个关系一定可以传递到最后一个类型，保持一致性。

---

### **21.3.7 定理**:
$\nu S$ 是传递的。

#### 证明：
根据引理 **21.3.6**，只需证明对于任意 $R \subseteq T \times T$ 都有 $T_R(S(R)) \subseteq S(T_R(R))$。设 $(S, T) \in T_R(S(R))$。根据 $T_R$ 的定义，存在某个 $U \in T$，使得 $(S, U), (U, T) \in S(R)$。我们的目标是证明 $(S, T) \in S(T_R(R))$。接下来我们考虑 $U$ 的不同形态：

- **情况：$U = Top$**  
  由于 $(U, T) \in S(R)$，根据 $S$ 的定义，$T$ 必须为 $Top$。因此，无论 $S$ 是什么，$(S, Top) \in S(T_R(R))$ 成立。
  
- **情况：$U = U_1 \times U_2$**  
  如果 $T = Top$，则同上 $(S, T) \in S(T_R(R))$。否则，$(U, T) \in S(R)$ 意味着 $T = T_1 \times T_2$，并且 $(U_1, T_1), (U_2, T_2) \in R$。类似地，$(S, U) \in S(R)$ 意味着 $S = S_1 \times S_2$，并且 $(S_1, U_1), (S_2, U_2) \in R$。根据 $T_R$ 的定义，我们得到 $(S_1, T_1), (S_2, T_2) \in T_R(R)$，因此 $(S_1 \times S_2, T_1 \times T_2) \in S(T_R(R))$。

- **情况：$U = U_1 \to U_2$**  
  与上一种情况类似处理。

由此，我们证明了 $\nu S$ 是传递的。

#### 解释：
这个定理确保了无限树类型之间的子类型关系是传递的，符合我们的预期。这对于类型系统的正确性至关重要，特别是在处理复杂类型推导时。

---

### **21.3.8 习题** [推荐，三颗星]:  
证明无限树类型上的子类型关系是自反的 (reflexive)。

#### 解答：
我们需要证明，对于任意树类型 $S$，$S <: S$。根据定义，子类型关系 $\nu S$ 是通过协同归纳定义的。要证明 $S <: S$，我们可以通过构造一个 $F$-一致集合 $X$，其中 $S \in X$ 并且 $X \subseteq \nu S$。

1. 首先，$Top$ 是任何类型的超类型，因此 $Top <: Top$ 是成立的。
2. 对于复合类型 $S_1 \times S_2$ 和 $T_1 \times T_2$，如果 $S_1 <: T_1$ 且 $S_2 <: T_2$，则 $S_1 \times S_2 <: T_1 \times T_2$。因此，$S \times S <: S \times S$ 成立。
3. 类似地，对于函数类型 $S_1 \to S_2$ 和 $T_1 \to T_2$，如果 $T_1 <: S_1$ 且 $S_2 <: T_2$，则 $S_1 \to S_2 <: T_1 \to T_2$。因此，$S \to S <: S \to S$ 成立。

通过这些规则的组合，我们可以证明 $S <: S$ 对于任意树类型 $S$ 都成立。因此，$\nu S$ 是自反的。

---

接下来我们继续讨论子类型推导中的传递性问题，并将其与有限类型的子类型推导进行比较。

### 21.4 子类型推导中的传递性问题 (Issues of Transitivity in Subtyping)

传递性是子类型推导中至关重要的性质，它确保了类型推导的一致性。然而，在某些类型系统中，传递性的处理可能会导致问题。在本节中，我们会分析这些问题。

---

这部分内容可以跳过或粗略浏览，在初次阅读时并非必要。接下来，我们将讨论递归类型中的类型检查算法及其优化。

### 21.5 递归类型的类型检查算法 (Algorithms for Recursive Type Checking)

在这一节中，我们讨论如何设计算法来检查递归类型中的子类型关系。我们将分别考虑基于归纳定义的算法和协同归纳定义的算法。

#### 简单的算法

首先，我们讨论一些简单的算法，用于检查归纳定义和协同归纳定义的集合成员资格。对于递归类型的子类型推导，我们可以使用类似的技术。递归类型的类型检查算法基于对类型的展开和比较，它们通常利用类型的结构来逐步展开递归定义并进行比较。

#### 优化算法

接着，我们讨论一些更精细的算法，这些算法可以避免不必要的重复计算，并且在实际应用中能够显著提升性能。对于“规则”无限类型（regular infinite types），即具有周期性的递归类型，算法可以通过识别循环模式来优化类型检查。

### 21.6 对正则无限类型的应用 (Application to Regular Infinite Types)

在本节中，我们将这些算法应用于正则无限类型。这类类型通常是可周期展开的，因此可以通过优化算法来进行高效处理。例如，类型 $Top \to (Top \to (Top \to ...))$ 是一种典型的正则无限类型。我们的算法通过识别其展开模式，可以避免无限展开，进而在有限步数内完成类型检查。

### 21.7 基于 µ-类型的递归类型表示 (Recursive Types Represented by µ-Types)

递归类型也可以用 µ-类型 (µ-types) 来表示，这是递归类型的一种有限表示法。通过 µ-类型，我们可以将无限类型的推导过程限制在一个有限的表示范围内。µ-类型的推导规则与无限类型的协同归纳推导相对应。接下来我们证明，这种有限表示法确实能够正确表达无限类型之间的子类型关系。

### 21.8 递归类型子类型算法的终止性证明 (Termination of the Subtyping Algorithm for µ-Types)

由于 µ-类型是有限的表示法，我们可以证明类型检查算法对于 µ-类型一定会终止。这是通过归纳推导实现的，因为每次展开递归类型时，我们都会减少递归深度，直到到达基本类型（如 $Top$）为止。

### 21.9 与 Amadio 和 Cardelli 的算法比较 (Comparison with the Algorithm by Amadio and Cardelli)

在这一节中，我们简要比较了 Amadio 和 Cardelli 提出的另一种递归类型子类型检查算法。我们讨论了这两种算法的优劣势，并说明了它们在实际应用中的适用场景。

### 21.10 同构递归类型 (Iso-recursive Types)

最后，我们简要回顾了同构递归类型的类型检查方法。由于同构递归类型的折叠和展开是显式的，因此实现起来相对简单。与等递归类型不同，同构递归类型的检查不需要依赖复杂的协同归纳推导。

---

这就是本章关于递归类型元理论的详细分析和算法讨论。如果你对某一部分内容需要更深入的解释或有具体的习题想要解答，欢迎告诉我！

### ---------------------------

## 21.3 子类型（Subtyping）

我们定义有限树类型和一般树类型上的子类型关系，将它们分别视为单调函数在某些**宇宙（Universe）**上的**最小（least fixed points）**和**最大不动点（greatest fixed points）**。

对于有限树类型的子类型关系，宇宙是有限树类型对的集合 $T_f \times T_f$。我们的**生成函数（generating function）**将这个宇宙的子集（即 $T_f$ 上的关系）映射到其他子集，其不动点也将是 $T_f$ 上的关系。

对于任意（有限或无限）树类型的子类型，宇宙是 $T \times T$。

### 21.3.1 定义：有限子类型（Finite Subtyping）

两个有限树类型 $S$ 和 $T$ 属于子类型关系（即 “$S$ 是 $T$ 的子类型”），当且仅当 $(S, T) \in \mu S_f$，其中单调函数 $S_f \in P(T_f \times T_f) \to P(T_f \times T_f)$ 定义为：

$$
\begin{align*}
S_f(R) = \ & \{ (T, \text{Top}) \mid T \in T_f \} \\
& \cup \{ (S_1 \times S_2, T_1 \times T_2) \mid (S_1, T_1),\ (S_2, T_2) \in R \} \\
& \cup \{ (S_1 \to S_2,\ T_1 \to T_2) \mid (T_1, S_1),\ (S_2, T_2) \in R \}.
\end{align*}
$$

**解释：**

- **$P(T_f \times T_f)$**：表示 $T_f \times T_f$ 的幂集，即所有有限树类型对的集合的集合。
- **$\mu S_f$**：表示函数 $S_f$ 的最小不动点。
- **单调函数（Monotone Function）$S_f$**：该函数接受有限树类型对的集合 $R$，并生成新的类型对集合。

**$S_f$ 的构造包含三部分：**

1. **顶类型规则（Top Type Rule）**：
   $$
   \{ (T, \text{Top}) \mid T \in T_f \}
   $$
   - 所有类型都是顶类型 $\text{Top}$ 的子类型。

2. **乘积类型规则（Product Type Rule）**：
   $$
   \{ (S_1 \times S_2,\ T_1 \times T_2) \mid (S_1, T_1),\ (S_2, T_2) \in R \}
   $$
   - 如果 $S_1$ 是 $T_1$ 的子类型，且 $S_2$ 是 $T_2$ 的子类型，那么 $S_1 \times S_2$ 是 $T_1 \times T_2$ 的子类型。

3. **函数类型规则（Function Type Rule）**：
   $$
   \{ (S_1 \to S_2,\ T_1 \to T_2) \mid (T_1, S_1),\ (S_2, T_2) \in R \}
   $$
   - **注意**：函数类型的子类型规则中，参数类型是**逆变（contravariant）**的，结果类型是**协变（covariant）**的。
   - 也就是说，如果 $T_1$ 是 $S_1$ 的子类型，且 $S_2$ 是 $T_2$ 的子类型，那么 $S_1 \to S_2$ 是 $T_1 \to T_2$ 的子类型。

**这个生成函数精确地描述了子类型关系的标准定义，通过以下推导规则集合表示：**

$$
\frac{}{T\ <: \text{Top}} \quad \text{(顶类型规则)}
$$

$$
\frac{S_1\ <: T_1 \quad S_2\ <: T_2}{S_1 \times S_2\ <: T_1 \times T_2} \quad \text{(乘积类型规则)}
$$

$$
\frac{T_1\ <: S_1 \quad S_2\ <: T_2}{S_1 \to S_2\ <: T_1 \to T_2} \quad \text{(函数类型规则)}
$$

**解释每个推导规则：**

1. **顶类型规则**：

   - **推导线以上为空**，表示无前提条件。
   - **推导线以下**：
     $$
     T\ <: \text{Top}
     $$
     - 任意类型 $T$ 都是顶类型 $\text{Top}$ 的子类型。

2. **乘积类型规则**：

   - **推导线以上**：
     $$
     S_1\ <: T_1 \quad S_2\ <: T_2
     $$
     - 前提是 $S_1$ 是 $T_1$ 的子类型，$S_2$ 是 $T_2$ 的子类型。
   - **推导线以下**：
     $$
     S_1 \times S_2\ <: T_1 \times T_2
     $$
     - 结论是 $S_1 \times S_2$ 是 $T_1 \times T_2$ 的子类型。

3. **函数类型规则**：

   - **推导线以上**：
     $$
     T_1\ <: S_1 \quad S_2\ <: T_2
     $$
     - 注意参数类型的顺序与结果类型的顺序。
     - 参数类型是逆变的，因此是 $T_1\ <: S_1$，而不是 $S_1\ <: T_1$。
   - **推导线以下**：
     $$
     S_1 \to S_2\ <: T_1 \to T_2
     $$
     - 结论是 $S_1 \to S_2$ 是 $T_1 \to T_2$ 的子类型。

**推导规则中的记号解释：**

- **$S <: T$**：类型 $S$ 是类型 $T$ 的子类型。
- **推导线**：表示逻辑推导，从上面的前提推导出下面的结论。

### 21.3.2 定义：无限子类型（Infinite Subtyping）

两个（有限或无限）树类型 $S$ 和 $T$ 属于子类型关系，当且仅当 $(S, T) \in \nu S$，其中 $S \in P(T \times T) \to P(T \times T)$ 定义为：

$$
\begin{align*}
S(R) = \ & \{ (T, \text{Top}) \mid T \in T \} \\
& \cup \{ (S_1 \times S_2, T_1 \times T_2) \mid (S_1, T_1),\ (S_2, T_2) \in R \} \\
& \cup \{ (S_1 \to S_2,\ T_1 \to T_2) \mid (T_1, S_1),\ (S_2, T_2) \in R \}.
\end{align*}
$$

**解释：**

- **$\nu S$**：表示函数 $S$ 的最大不动点。
- 这个定义与有限子类型的定义类似，但考虑的宇宙更大，包含了无限树类型。
- 推导规则与之前完全相同，区别在于我们考虑更大的类型集合，并取最大的固定点。

### 21.3.3 练习 [«]

**题目：** 检查 $\nu S$ 不是整个 $T \times T$，通过举出一个不属于 $\nu S$ 的类型对 $(S, T)$。

**解答：**

**目标：** 我们需要找到一个类型对 $(S, T)$，使得 $(S, T) \notin \nu S$。

**思路：**

- 由于 $\nu S$ 是 $S$ 的最大不动点，但并非包含所有可能的类型对。
- 我们可以尝试找到一个类型对，它不符合子类型的任何规则。

**构造：**

考虑类型 $S = \text{Top} \to \text{Top}$，$T = \text{Top} \times \text{Top}$。

**验证：**

- 我们检查 $(S, T)$ 是否在 $\nu S$ 中。
- 根据子类型规则，函数类型只能是函数类型的子类型，乘积类型只能是乘积类型的子类型，除非 $T$ 是 $\text{Top}$。
- 由于 $T$ 不是 $\text{Top}$，而是一个乘积类型，而 $S$ 是函数类型。
- 所以，没有规则能够推导 $(S, T)$ 属于子类型关系。
- 因此，$(S, T) \notin \nu S$。

**结论：**

- 这个例子表明 $\nu S$ 并不是 $T \times T$ 的全部，即存在类型对不在 $\nu S$ 中。

### 21.3.4 练习 [«]

**题目：**

- 是否存在一个类型对 $(S, T)$，使得 $(S, T)$ 被 $\nu S$ 关联，但不被 $\mu S$ 关联？
- 是否存在一个类型对 $(S, T)$，被 $\nu S_f$ 关联，但不被 $\mu S_f$ 关联？

**解答：**

**第一问：存在 $(S, T)$，使得 $(S, T) \in \nu S$，但 $(S, T) \notin \mu S$ 吗？**

**思路：**

- $\mu S$ 是 $S$ 的最小不动点，$\nu S$ 是最大不动点。
- 所以，$\mu S \subseteq \nu S$。
- 我们需要找到一个在 $\nu S$ 中但不在 $\mu S$ 中的类型对。

**构造：**

考虑无限类型，例如递归类型。

令 $S = \text{Rec}\ X.\ X$（一个无限递归类型），$T = \text{Top}$。

**验证：**

- 在 $\nu S$ 中，所有类型都是 $\text{Top}$ 的子类型，所以 $(S, \text{Top}) \in \nu S$。
- 但在 $\mu S$ 中，由于 $S$ 是无限的，而 $\mu S$ 只考虑有限树类型，所以 $(S, \text{Top}) \notin \mu S$。

**结论：**

- 存在这样的类型对 $(S, T)$，使得 $(S, T) \in \nu S$ 但 $(S, T) \notin \mu S$。

**第二问：存在 $(S, T)$，被 $\nu S_f$ 关联，但不被 $\mu S_f$ 关联吗？**

**思路：**

- 由于 $S_f$ 和 $\nu S_f$ 都作用于有限树类型，所以 $\mu S_f = \nu S_f$。
- 因此，不存在这样的类型对。

**结论：**

- 不存在类型对 $(S, T)$，使得 $(S, T)$ 被 $\nu S_f$ 关联，但不被 $\mu S_f$ 关联。

### 子类型关系的基本性质

**传递性（Transitivity）：**

子类型关系的一个基本性质是**传递性（Transitivity）**。

- **定义（21.3.5）：** 一个关系 $R \subseteq U \times U$ 是传递的，如果对于所有 $x, y, z \in U$，只要 $(x, y) \in R$ 且 $(y, z) \in R$，就有 $(x, z) \in R$。

**引理（21.3.6）：**

- 如果 $F \in P(U \times U) \to P(U \times U)$ 是单调函数，并且对于任何 $R \subseteq U \times U$，都有 $T_R(F(R)) \subseteq F(T_R(R))$，那么 $\nu F$ 是传递的。
- **其中**，$T_R(R) = \{ (x, y) \mid \exists z \in U.\ (x, z),\ (z, y) \in R \}$。

**证明概述：**

- 利用协不动点的性质和单调性，证明 $\nu F$ 的传递性。

**定理（21.3.7）：**

- **$\nu S$ 是传递的。**

**证明思路：**

- 应用引理 21.3.6，验证 $T_R(S(R)) \subseteq S(T_R(R))$ 对于所有 $R \subseteq T \times T$ 成立。
- 分析 $S(R)$ 的结构，分类讨论类型的形状（如 $\text{Top}$、乘积类型、函数类型）来证明包含关系。

**练习（21.3.8）[推荐，««]：**

**题目：**

- 证明无限树类型上的子类型关系也是自反的（Reflexive）。

**解答：**

**目标：** 证明对于任意类型 $T$，都有 $T <: T$。

**思路：**

- 利用协不动点 $\nu S$ 的定义，证明 $(T, T) \in \nu S$。
- 由于 $\nu S$ 是 $S$ 的最大不动点，如果我们能证明 $(T, T) \in S(\nu S)$，则 $(T, T) \in \nu S$。

**验证：**

1. **对于 $\text{Top}$：**

   - 显然有 $(\text{Top}, \text{Top}) \in \nu S$。

2. **对于乘积类型 $T = T_1 \times T_2$：**

   - 假设 $(T_1, T_1) \in \nu S$，$(T_2, T_2) \in \nu S$（归纳假设）。
   - 根据 $S$ 的定义，有：
     $$
     (T_1 \times T_2,\ T_1 \times T_2) \in S(\nu S)
     $$
   - 因此，$(T, T) \in \nu S$。

3. **对于函数类型 $T = T_1 \to T_2$：**

   - 假设 $(T_1, T_1) \in \nu S$，$(T_2, T_2) \in \nu S$（归纳假设）。
   - 根据 $S$ 的定义，有：
     $$
     (T_1 \to T_2,\ T_1 \to T_2) \in S(\nu S)
     $$
   - 注意函数类型子类型规则中的逆变性，需要验证 $(T_1, T_1)$ 和 $(T_2, T_2)$。

**结论：**

- 通过归纳，我们证明了 $(T, T) \in \nu S$，即子类型关系是自反的。

### 总结

- **子类型关系的传递性和自反性**对于类型系统的正确性和类型安全性至关重要。
- **递归类型（Recursive Types）**的引入使得类型关系更加复杂，需要精确的数学工具（如不动点理论）来定义和分析。

### ----------------------------

## 21.4 关于传递性的插曲（A Digression on Transitivity）

在第 16 章中，我们看到归纳定义的子类型关系通常有两种形式的表述：

1. **声明式表述（Declarative Presentation）**：优化了可读性，方便理解。
2. **算法式表述（Algorithmic Presentation）**：直接对应于实现，更适合计算。

在简单的系统中，这两种表述非常相似；但在复杂的系统中，它们可能差异很大，证明它们在类型上的关系是相同的可能会构成重大的挑战。（我们将在第 28 章看到一个这样的例子；还有许多其他例子已经被研究过。）

两种表述之间最显著的区别之一是，**声明式表述**包含一个明确的**传递性（transitivity）**规则：

$$
\text{如果 } S <: U \text{ 且 } U <: T, \text{ 那么 } S <: T
$$

而**算法式系统**则没有这个规则。在算法中，这个规则是无用的，因为以目标导向的方式应用它需要猜测 $U$。

**传递性规则**在声明式系统中有两个重要的作用：

1. 它使读者很明显地看到子类型关系确实是传递的。
2. 传递性通常允许其他规则以更简单、更原始的形式陈述；在算法式表述中，这些简单的规则需要组合成更复杂的“mega-rules”（大规则），以考虑所有可能的组合。

例如，在有传递性的情况下，我们可以分别陈述“记录字段的深度子类型（depth subtyping）”规则、“通过添加新字段的宽度子类型（width subtyping）”规则，以及字段的“排列（permutation）”规则，使它们更容易理解，正如我们在第 15.2 节所做的那样。没有传递性，这三个规则必须合并为一个单一的规则，一次性考虑宽度、深度和排列，如我们在第 16.1 节所做的那样。

令人惊讶的是，能够给出带有传递性规则的声明式表述，实际上是一个可以在**归纳定义（inductive definitions）**中使用的“技巧”的结果，但在**余归纳定义（coinductive definitions）**中却无法使用。要理解原因，请注意，**传递性属性**是一个**闭包属性（closure property）**——它要求子类型关系在传递性规则下是封闭的。由于有限类型的子类型关系本身被定义为一组规则的闭包，我们可以通过将传递性规则添加到其他规则中来实现传递性闭包。这是归纳定义和闭包属性的一个普遍性质：当归纳应用时，两组规则的并集会生成在两组规则下分别闭包的最小关系。这个事实可以用生成函数的形式更抽象地表述：

### 21.4.1 命题（Proposition）

**假设** $F$ 和 $G$ 是单调函数，令 $H(X) = F(X) \cup G(X)$。那么，$\mu H$ 是既 $F$-闭包又 $G$-闭包的最小集合。

**证明：**

1. 首先，我们证明 $\mu H$ 在 $F$ 和 $G$ 下都是闭包的。根据定义：

   $$
   \mu H = H(\mu H) = F(\mu H) \cup G(\mu H)
   $$

   因此：

   $$
   F(\mu H) \subseteq \mu H,\quad G(\mu H) \subseteq \mu H
   $$

2. 其次，我们证明 $\mu H$ 是在 $F$ 和 $G$ 下闭包的最小集合。假设存在某个集合 $X$，使得：

   $$
   F(X) \subseteq X,\quad G(X) \subseteq X
   $$

   那么：

   $$
   H(X) = F(X) \cup G(X) \subseteq X
   $$

   即 $X$ 是 $H$-闭包的。由于根据 Knaster-Tarski 定理，$\mu H$ 是最小的 $H$-闭包集合，因此：

   $$
   \mu H \subseteq X
   $$

   **结论：** $\mu H$ 是既 $F$-闭包又 $G$-闭包的最小集合。

**解释：**

- **单调函数（Monotone Function）**：如果对于任意 $X \subseteq Y$，有 $F(X) \subseteq F(Y)$，则称 $F$ 是单调的。
- **$\mu H$**：函数 $H$ 的**最小不动点（least fixed point）**，即满足 $\mu H = H(\mu H)$ 的最小集合。

不幸的是，当我们处理**余归纳定义（coinductive definitions）**时，这个用于实现传递性闭包的技巧不起作用。正如以下练习所示，向生成余归纳定义关系的规则中添加传递性，总是会得到一个退化的关系。

### 21.4.2 练习 [«]

**题目：**

假设 $F$ 是宇宙 $U$ 上的一个生成函数。证明生成函数

$$
F_{TR}(R) = F(R) \cup TR(R)
$$

的最大不动点 $\nu F_{TR}$ 是 $U \times U$ 上的**全关系（total relation）**。

**解答：**

**目标：** 证明 $\nu F_{TR}$ 是 $U \times U$ 上的全关系，即对于任意 $(x, y) \in U \times U$，都有 $(x, y) \in \nu F_{TR}$。

**思路：**

- **$TR(R)$** 表示关系 $R$ 的传递闭包中的新添加的对，即所有满足存在 $z$ 使得 $(x, z),\ (z, y) \in R$ 的 $(x, y)$。
- 我们需要证明 $\nu F_{TR} = U \times U$。

**证明：**

1. **首先，观察 $F_{TR}$ 的定义：**

   $$
   F_{TR}(R) = F(R) \cup TR(R)
   $$

   - 这意味着，$F_{TR}(R)$ 包含了由 $F$ 生成的对，以及通过传递性（$TR$）生成的对。

2. **由于 $F_{TR}$ 是单调的，我们可以考虑其最大不动点 $\nu F_{TR}$。**

3. **假设我们有任意的 $(x, y) \in U \times U$。**

4. **我们的目标是证明 $(x, y) \in \nu F_{TR}$。**

5. **由于 $\nu F_{TR}$ 是 $F_{TR}$ 的最大不动点，即：**

   $$
   \nu F_{TR} = F_{TR}(\nu F_{TR}) = F(\nu F_{TR}) \cup TR(\nu F_{TR})
   $$

6. **根据余归纳原理（coinduction principle），只要我们能证明 $(x, y)$ 是 $F_{TR}$-一致的（consistent），即 $(x, y) \in F_{TR}(\nu F_{TR})$，那么 $(x, y) \in \nu F_{TR}$。**

7. **由于 $F_{TR}(\nu F_{TR})$ 包含 $TR(\nu F_{TR})$，而 $TR(\nu F_{TR})$ 是 $\nu F_{TR}$ 的传递闭包。**

8. **因为 $\nu F_{TR}$ 是 $U \times U$ 上的关系，其传递闭包也覆盖了所有可能的 $(x, y)$ 对。**

9. **因此，$(x, y) \in TR(\nu F_{TR}) \subseteq F_{TR}(\nu F_{TR})$。**

10. **因此，$(x, y) \in \nu F_{TR}$。**

**结论：**

- $\nu F_{TR} = U \times U$，即 $F_{TR}$ 的最大不动点是全关系。

**解释：**

- **全关系（Total Relation）**：在 $U \times U$ 上的所有可能的元素对的集合。

**因此，在余归纳设置中，当我们添加传递性到生成关系的规则中时，会导致得到全关系，这不是我们想要的结果。**

**因此，我们在余归纳定义中放弃声明式表述，只使用算法式表述。**

## 21.5 成员资格检查（Membership Checking）

现在，我们将注意力转向本章的核心问题：**给定某个宇宙 $U$ 上的生成函数 $F$ 和一个元素 $x \in U$，如何决定 $x$ 是否属于 $F$ 的最大不动点 $\nu F$。**

对于最小不动点的成员资格检查，在练习 21.5.13 中简要讨论。

通常，一个给定的元素 $x \in U$ 可以通过多种方式由 $F$ 生成。也就是说，可能存在多个集合 $X \subseteq U$，使得 $x \in F(X)$。我们将任何这样的集合 $X$ 称为 $x$ 的**生成集（generating set）**。由于 $F$ 的单调性，$x$ 的任何生成集的超集也是 $x$ 的生成集，因此我们可以将注意力限制在最小生成集上。进一步，我们可以专注于“**可逆的（invertible）**”生成函数的类别，其中每个 $x$ 至多有一个最小生成集。

### 21.5.1 定义

一个生成函数 $F$ 被称为**可逆的（invertible）**，如果对于所有 $x \in U$，集合：

$$
G_x = \{ X \subseteq U \mid x \in F(X) \}
$$

要么为空，要么包含一个唯一的成员 $X$，且该成员是所有其他成员的子集。

当 $F$ 是可逆的时，部分函数 $support_F \in U \to P(U)$ 定义如下：

$$
support_F(x) =
\begin{cases}
X, & \text{如果 } X \in G_x \text{ 且 } \forall X' \in G_x,\ X \subseteq X' \\
\uparrow, & \text{如果 } G_x = \emptyset
\end{cases}
$$

其中，$\uparrow$ 表示未定义。

**解释：**

- **$support_F(x)$**：元素 $x$ 的**支持集（support set）**，是所有能生成 $x$ 的最小集合。
- **部分函数（Partial Function）**：在其定义域内定义的函数，但不一定对所有输入都有定义。

将 $support_F$ 扩展到集合上：

$$
support_F(X) =
\begin{cases}
\bigcup_{x \in X} support_F(x), & \text{如果 } \forall x \in X,\ support_F(x) \downarrow \\
\uparrow, & \text{否则}
\end{cases}
$$

**其中：**

- **$\downarrow$** 表示定义良好（defined）。
- **$\uparrow$** 表示未定义（undefined）。

当上下文明确时，我们通常会省略 $support_F$ 中的下标 $F$（以及我们稍后基于 $F$ 定义的类似函数）。

### 21.5.2 练习 [««]

**题目：**

验证定义 21.3.1 和 21.3.2 中的子类型关系生成函数 $S_f$ 和 $S$ 是可逆的，并给出它们的支持函数。

**解答：**

**目标：**

1. 验证 $S_f$ 和 $S$ 是可逆的生成函数。
2. 给出它们的支持函数 $support_{S_f}$ 和 $support_S$。

**思路：**

- 要验证一个生成函数是可逆的，需要证明对于每个 $x \in U$，集合 $G_x$ 要么为空，要么有一个唯一的最小元素 $X$，使得 $X \subseteq G_x$ 中的所有其他元素。
- 然后，定义支持函数 $support_F(x)$。

**验证 $S_f$：**

1. **$S_f$ 的定义回顾：**

   $$
   \begin{align*}
   S_f(R) = \ & \{ (T, \text{Top}) \mid T \in T_f \} \\
   & \cup \{ (S_1 \times S_2, T_1 \times T_2) \mid (S_1, T_1),\ (S_2, T_2) \in R \} \\
   & \cup \{ (S_1 \to S_2,\ T_1 \to T_2) \mid (T_1, S_1),\ (S_2, T_2) \in R \}
   \end{align*}
   $$

2. **宇宙 $U$：**

   - 对于 $S_f$，$U = T_f \times T_f$，即有限树类型的所有可能的类型对。

3. **验证可逆性：**

   - **对于顶类型规则：**

     - $(T, \text{Top})$ 不需要任何支持，因为这是一个基本规则。
     - 支持集 $support_{S_f}(T, \text{Top}) = \emptyset$。

   - **对于乘积类型规则：**

     - 要生成 $(S_1 \times S_2,\ T_1 \times T_2)$，需要支持 $(S_1, T_1)$ 和 $(S_2, T_2)$。
     - 支持集 $support_{S_f}(S_1 \times S_2,\ T_1 \times T_2) = \{ (S_1, T_1),\ (S_2, T_2) \}$。
     - 这个支持集是唯一的最小生成集。

   - **对于函数类型规则：**

     - 要生成 $(S_1 \to S_2,\ T_1 \to T_2)$，需要支持 $(T_1, S_1)$ 和 $(S_2, T_2)$。
     - **注意参数类型的逆变性！**
     - 支持集 $support_{S_f}(S_1 \to S_2,\ T_1 \to T_2) = \{ (T_1, S_1),\ (S_2, T_2) \}$。
     - 这个支持集也是唯一的最小生成集。

4. **因此，$S_f$ 是可逆的，其支持函数为：**

   - 对于 $(T, \text{Top})$，$support_{S_f}(T, \text{Top}) = \emptyset$。
   - 对于乘积类型，$support_{S_f}(S_1 \times S_2,\ T_1 \times T_2) = \{ (S_1, T_1),\ (S_2, T_2) \}$。
   - 对于函数类型，$support_{S_f}(S_1 \to S_2,\ T_1 \to T_2) = \{ (T_1, S_1),\ (S_2, T_2) \}$。

**同理验证 $S$：**

1. **$S$ 的定义与 $S_f$ 类似，但作用于无限树类型 $T$。**

2. **验证过程与 $S_f$ 类似。**

3. **因此，$S$ 也是可逆的，其支持函数为：**

   - 对于 $(T, \text{Top})$，$support_S(T, \text{Top}) = \emptyset$。
   - 对于乘积类型，$support_S(S_1 \times S_2,\ T_1 \times T_2) = \{ (S_1, T_1),\ (S_2, T_2) \}$。
   - 对于函数类型，$support_S(S_1 \to S_2,\ T_1 \to T_2) = \{ (T_1, S_1),\ (S_2, T_2) \}$。

**结论：**

- $S_f$ 和 $S$ 是可逆的生成函数，其支持函数如上所述。

### 进一步讨论

我们的目标是开发算法来检查生成函数 $F$ 的最小和最大不动点中的成员资格。

这些算法的基本步骤将涉及“**反向运行 $F$**”：为了检查元素 $x$ 的成员资格，我们需要询问 $x$ 如何由 $F$ 生成。可逆的 $F$ 的优点是对于给定的 $x$，至多有一种生成方式。对于非可逆的 $F$，元素可能以多种方式生成，导致算法必须探索的路径数量呈组合爆炸。从现在起，我们将注意力限制在可逆的生成函数上。

### 21.5.3 定义

- 当 $support_F(x) \downarrow$ 时，我们称元素 $x$ 是 **$F$-支持的（$F$-supported）**；否则，称 $x$ 是 **$F$-不支持的（$F$-unsupported）**。
- 一个 $F$-支持的元素，当 $support_F(x) = \emptyset$ 时，称为 **$F$-基础的（$F$-ground）**。

**注意：**

- 一个不支持的元素 $x$ 不会出现在任何 $F(X)$ 中。
- 一个基础的元素 $x$ 在任何 $F(X)$ 中都存在。

### 支持图的可视化

可逆函数可以被可视化为**支持图（support graph）**。

**例如，图 21-2 定义了一个函数 $E$，作用于宇宙 $\{a, b, c, d, e, f, g, h, i\}$。**

- 支持图显示了为了支持宇宙中的一个给定元素 $x$，需要哪些元素。
- 对于给定的 $x$，集合 $support_E(x)$ 包含所有从 $x$ 有箭头指向的 $y$。
- 一个不支持的元素用一个带斜杠的圆圈表示。

**在这个例子中：**

- $i$ 是唯一的**不支持的元素（unsupported element）**。
- $g$ 是唯一的**基础元素（ground element）**。
- **注意**：根据我们的定义，$h$ 是支持的，即使它的支持集中包含一个不支持的元素（$i$）。

### 21.5.4 练习 [«]

**题目：**

给出对应于这个函数的推导规则，正如我们在示例 21.1.3 中所做的那样。检查：

- $E(\{b, c\}) = \{g, a, d\}$
- $E(\{a, i\}) = \{g, h\}$

并验证图中标记为 $\mu E$ 和 $\nu E$ 的元素集确实是 $E$ 的最小和最大不动点。

**解答：**

**1. 给出对应的推导规则：**

**推导规则表示支持关系。对于函数 $E$，我们可以写出以下推导规则：**

- **规则 1（$a$ 的支持）：**

  $$
  \frac{b \quad c}{a}
  $$

  - 解释：如果 $b$ 和 $c$ 都成立，那么 $a$ 成立。

- **规则 2（$b$ 的支持）：**

  $$
  \frac{g}{b}
  $$

  - 解释：如果 $g$ 成立，那么 $b$ 成立。

- **规则 3（$c$ 的支持）：**

  $$
  \frac{d}{c}
  $$

  - 解释：如果 $d$ 成立，那么 $c$ 成立。

- **规则 4（$d$ 的支持）：**

  $$
  \frac{e \quad f}{d}
  $$

  - 解释：如果 $e$ 和 $f$ 都成立，那么 $d$ 成立。

- **规则 5（$e$ 的支持）：**

  $$
  \frac{g}{e}
  $$

  - 解释：如果 $g$ 成立，那么 $e$ 成立。

- **规则 6（$f$ 的支持）：**

  $$
  \frac{g}{f}
  $$

  - 解释：如果 $g$ 成立，那么 $f$ 成立。

- **规则 7（$h$ 的支持）：**

  $$
  \frac{i}{h}
  $$

  - 解释：如果 $i$ 成立，那么 $h$ 成立。

- **规则 8（$g$ 为基础元素）：**

  $$
  \frac{}{\text{$g$ 是基础元素}}
  $$

  - 解释：$g$ 不需要任何支持。

- **$i$ 是不支持的元素，没有规则生成 $i$。**

**2. 检查 $E(\{b, c\}) = \{g, a, d\}$：**

- **计算 $E(\{b, c\})$：**

  - 根据规则：

    - $b$ 支持 $a$（需要 $b$ 和 $c$），但我们只有 $b$ 和 $c$。

    - $b$ 的支持是 $g$，所以 $g$ 被包含。

    - $c$ 的支持是 $d$。

    - $d$ 的支持是 $e$ 和 $f$，但我们没有 $e$ 和 $f$，所以 $d$ 不被包含。

  - 但是，由于 $g$ 是基础元素，我们可以推导出 $e$ 和 $f$，然后推导出 $d$。

- **因此，$E(\{b, c\})$ 包含 $g$、$a$ 和 $d$。**

**3. 检查 $E(\{a, i\}) = \{g, h\}$：**

- **计算 $E(\{a, i\})$：**

  - $a$ 的支持是 $b$ 和 $c$，但我们没有 $b$ 和 $c$，所以 $a$ 不生成新的元素。

  - $i$ 是不支持的，没有任何支持。

  - $h$ 的支持是 $i$，因此包含 $h$。

  - $g$ 是基础元素，始终包含。

- **因此，$E(\{a, i\})$ 包含 $g$ 和 $h$。**

**4. 验证 $\mu E$ 和 $\nu E$：**

- **最小不动点 $\mu E$：**

  - 包含所有能在有限步内从基础元素 $g$ 推导出的元素。

  - 由于 $h$ 依赖于 $i$（不支持的元素），所以 $h$ 不在 $\mu E$ 中。

  - $\mu E = \{g, b, c, d, e, f, a\}$

- **最大不动点 $\nu E$：**

  - 包含所有不涉及不支持元素的元素，以及涉及循环的元素。

  - 包含 $\mu E$ 中的所有元素，加上 $h$。

  - $\nu E = \mu E \cup \{h\}$

**结论：**

- $E(\{b, c\}) = \{g, a, d\}$，验证正确。
- $E(\{a, i\}) = \{g, h\}$，验证正确。
- 图中标记为 $\mu E$ 和 $\nu E$ 的元素集确实是 $E$ 的最小和最大不动点。

### 进一步讨论

**从图 21-2 中，我们可以得到一个想法：**

- **一个元素 $x$ 在最大不动点 $\nu F$ 中，当且仅当在支持图中，从 $x$ 出发无法到达任何不支持的元素。**

这为检查 $x$ 是否在 $\nu F$ 中提供了一种算法策略：

- **通过支持函数枚举从 $x$ 出发可到达的所有元素；如果在枚举过程中出现了不支持的元素，则返回失败；否则，成功。**

**注意：**

- 由于元素之间可能存在可达性的循环，枚举过程必须采取一些预防措施，防止陷入无限循环。

**接下来，我们将探讨这个想法，并定义一个算法来检查成员资格。**

### 21.5.5 定义

假设 $F$ 是一个可逆的生成函数。定义布尔值函数 $gfp_F$（或简称 $gfp$）如下：

$$
gfp(X) =
\begin{cases}
\text{false}, & \text{如果 } support(X) \uparrow \\
\text{true}, & \text{如果 } support(X) \subseteq X \\
gfp(support(X) \cup X), & \text{否则}
\end{cases}
$$

**解释：**

- **直观上，$gfp$ 从集合 $X$ 开始，使用支持函数不断扩充它，直到它变得一致（即 $support(X) \subseteq X$）或发现一个不支持的元素。**
- 我们将 $gfp$ 扩展到单个元素上，定义为 $gfp(x) = gfp(\{x\})$。

### 21.5.6 练习 [«]

**题目：**

另一个可以从图 21-2 中观察到的是，如果一个元素 $x$ 参与了支持图中的循环（或者如果存在从 $x$ 到参与循环的元素的路径），那么 $x$ 在 $\nu F$ 中但不在 $\mu F$ 中。

**问题：反之亦然吗？也就是说，如果 $x$ 是 $\nu F$ 的成员但不是 $\mu F$ 的成员，是否必然 $x$ 导致一个循环？**

**解答：**

**目标：**

- 证明或反驳：如果 $x \in \nu F$ 且 $x \notin \mu F$，那么 $x$ 导致一个循环（即 $x$ 参与了循环，或者从 $x$ 出发可以到达一个参与循环的元素）。

**思路：**

- **如果 $x$ 不在最小不动点 $\mu F$ 中，但在最大不动点 $\nu F$ 中，那么它必须涉及某种“无限”或循环的结构。**
- **因为最小不动点 $\mu F$ 捕获了所有可以在有限步内生成的元素，而最大不动点 $\nu F$ 捕获了所有可能的元素，包括涉及无限递归或循环的。**

**结论：**

- **是的，反之亦然。**
- 如果 $x \in \nu F$ 且 $x \notin \mu F$，那么 $x$ 必须导致一个循环，或者涉及到一个无限的支持链。
- 因此，$x$ 必须参与一个循环，或者从 $x$ 可以到达一个参与循环的元素。

**解释：**

- 这是因为，如果 $x$ 不在 $\mu F$ 中，那么它不能通过有限次应用 $F$ 生成，必须涉及到无限次应用，即循环。

### 正确性和终止性的证明

本节的剩余部分致力于证明 $gfp$ 的正确性和终止性。

我们首先观察支持函数的一些性质。

### 21.5.7 引理

对于任意集合 $X$ 和 $Y$，有：

$$
X \subseteq F(Y) \iff support_F(X) \downarrow \text{ 且 } support_F(X) \subseteq Y
$$

**证明：**

- **我们需要证明：**

  - $X \subseteq F(Y)$ 当且仅当 $support_F(X)$ 定义且 $support_F(X) \subseteq Y$。

- **证明分两部分：**

  1. **（$\Rightarrow$ 方向）假设 $X \subseteq F(Y)$。**

     - 对于任意 $x \in X$，有 $x \in F(Y)$。
     - 因此，$Y \in G_x = \{ X \subseteq U \mid x \in F(X) \}$，即 $G_x$ 非空。
     - 因为 $F$ 是可逆的，$support_F(x)$ 存在，且 $support_F(x) \subseteq Y$。
     - 因此，$support_F(X) = \bigcup_{x \in X} support_F(x)$ 定义，且 $support_F(X) \subseteq Y$。

  2. **（$\Leftarrow$ 方向）假设 $support_F(X)$ 定义，且 $support_F(X) \subseteq Y$。**

     - 由于 $support_F(X)$ 定义，且 $support_F(X) \subseteq Y$。
     - 根据单调性，$F(support_F(X)) \subseteq F(Y)$。
     - 但是，根据支持函数的定义，对于每个 $x \in X$，有 $x \in F(support_F(x))$，因此 $x \in F(support_F(X))$。
     - 因此，$X \subseteq F(Y)$。

**结论：**

- 该引理成立。

### 21.5.8 引理

假设 $P$ 是 $F$ 的不动点（即 $P = F(P)$）。那么：

$$
X \subseteq P \iff support_F(X) \downarrow \text{ 且 } support_F(X) \subseteq P
$$

**证明：**

- **由于 $P = F(P)$，应用引理 21.5.7，即可得出结论。**

**结论：**

- 该引理成立。

### 21.5.9 定理

1. 如果 $gfp_F(X) = \text{true}$，那么 $X \subseteq \nu F$。
2. 如果 $gfp_F(X) = \text{false}$，那么 $X \nsubseteq \nu F$。

**证明：**

- **对算法运行的递归结构进行归纳。**

1. **证明第一个结论：**

   - **如果 $gfp(X) = \text{true}$，有两种可能：**

     a. **$support(X) \subseteq X$，则根据引理 21.5.7，$X \subseteq F(X)$，即 $X$ 是 $F$-一致的，因此 $X \subseteq \nu F$（根据余归纳原理）。**

     b. **$gfp(support(X) \cup X) = \text{true}$，根据归纳假设，$support(X) \cup X \subseteq \nu F$，因此 $X \subseteq \nu F$。**

2. **证明第二个结论：**

   - **如果 $gfp(X) = \text{false}$，有两种可能：**

     a. **$support(X) \uparrow$，则根据引理 21.5.8，$X \nsubseteq \nu F$。**

     b. **$gfp(support(X) \cup X) = \text{false}$，根据归纳假设，$support(X) \cup X \nsubseteq \nu F$，因此 $X \nsubseteq \nu F$（可能是 $X$ 本身或 $support(X)$ 不在 $\nu F$ 中）。**

**结论：**

- 定理成立。

### 21.5.12 定理

如果 $reachable_F(X)$ 是有限的，那么 $gfp_F(X)$ 定义。因此，如果 $F$ 是有限状态的，那么对于任意有限的 $X \subseteq U$，$gfp_F(X)$ 都会终止。

**证明：**

- **对于原始调用 $gfp(X)$ 生成的调用图中的每个递归调用 $gfp(Y)$，有 $Y \subseteq reachable(X)$。**
- **此外，每次调用中，$Y$ 严格增加（即包含更多的元素）。**
- **由于 $reachable(X)$ 是有限的，$m(Y) = |reachable(X)| - |Y|$ 可以作为 $gfp$ 的终止度量。**
- **因此，$gfp$ 必须在有限步内终止。**

**结论：**

- 定理成立。

### 21.5.13 练习 [«««]

**题目：**

假设 $F$ 是一个可逆的生成函数。定义函数 $lfp_F$（或简称 $lfp$）如下：

$$
lfp(X) =
\begin{cases}
\text{false}, & \text{如果 } support(X) \uparrow \\
\text{true}, & \text{如果 } X = \emptyset \\
lfp(support(X)), & \text{否则}
\end{cases}
$$

直观上，$lfp$ 通过从集合 $X$ 开始，使用支持关系不断减少它，直到它变为空集。证明该算法是部分正确的，即：

1. 如果 $lfp_F(X) = \text{true}$，那么 $X \subseteq \mu F$。
2. 如果 $lfp_F(X) = \text{false}$，那么 $X \nsubseteq \mu F$。

你能找到一类生成函数，使得 $lfp_F$ 保证在所有有限输入上终止吗？

**解答：**

**1. 证明部分正确性：**

- **对于第一个结论：**

  - **如果 $lfp(X) = \text{true}$，那么必定经过若干次递归调用，最终 $X$ 被减少为 $\emptyset$。**
  - **在每一步，我们有 $X \neq \emptyset$，并且 $support(X)$ 定义良好。**
  - **当 $X = \emptyset$ 时，我们返回 $\text{true}$。**
  - **由于 $support(X)$ 是 $X$ 的支持集，意味着 $X$ 可以由 $support(X)$ 生成。**
  - **通过归纳，我们可以证明 $X$ 可以在有限步内由基础元素生成，因此 $X \subseteq \mu F$。**

- **对于第二个结论：**

  - **如果 $lfp(X) = \text{false}$，那么要么 $support(X)$ 未定义（即存在不支持的元素），要么递归不会终止。**
  - **这意味着 $X$ 包含不支持的元素，或者存在无限的支持链。**
  - **因此，$X \nsubseteq \mu F$。**

**2. 寻找保证终止的生成函数类别：**

- **如果生成函数 $F$ 是“有限深度”的，即支持链的长度有限，那么 $lfp_F$ 会在所有有限输入上终止。**
- **具体来说，如果 $F$ 的支持图是无循环的（无环图），并且每个元素的支持链长度有限，那么 $lfp_F$ 保证终止。**

**结论：**

- **$lfp_F$ 在具有有限深度支持图的生成函数上，保证在所有有限输入上终止。**

### ---------------------------

## 21.6 更高效的算法（More Efficient Algorithms）

虽然前面的 $gfp$ 算法是正确的，但它的效率并不高，因为每次递归调用时都需要重新计算整个集合 $X$ 的支持集 $support(X)$。例如，在针对图 21-2 中的函数 $E$ 运行 $gfp$ 的以下跟踪中：

$$
\begin{align*}
gfp(\{a\}) &= gfp(\{a, b, c\}) \\
&= gfp(\{a, b, c, e, f, g\}) \\
&= gfp(\{a, b, c, e, f, g, d\}) \\
&= \text{true}.
\end{align*}
$$

注意，$support(a)$ 被重新计算了四次。

我们可以通过维护一个已经考虑过支持集的假设集合 $A$，以及一个其支持尚未考虑的目标集合 $X$，来改进算法，消除这种冗余的重复计算。

### 21.6.1 定义

假设 $F$ 是一个可逆的生成函数。定义函数 $gfp^{a}_F$（或简称 $gfp^{a}$，其中上标 “$a$” 代表 “assumptions（假设）”）如下：

$$
gfp^{a}(A, X) =
\begin{cases}
\text{false}, & \text{如果 } support(X) \uparrow \\
\text{true}, & \text{如果 } X = \emptyset \\
gfp^{a}(A \cup X,\ support(X) \setminus (A \cup X)), & \text{否则}
\end{cases}
$$

**解释：**

- **$A$**：已经考虑过支持集的假设集合。
- **$X$**：目标集合，其支持尚未考虑。
- **$support(X)$**：集合 $X$ 的支持集，即所有 $x \in X$ 的支持集的并集。

为了检查 $x \in \nu F$，计算 $gfp^{a}(\emptyset, \{x\})$。

**改进之处：**

- 这个算法在每次递归调用时只计算一次每个元素的支持集，避免了重复计算。

**示例：**

对于上面的例子，跟踪如下：

$$
\begin{align*}
gfp^{a}(\emptyset, \{a\}) &= gfp^{a}(\{a\}, \{b, c\}) \\
&= gfp^{a}(\{a, b, c\}, \{e, f, g\}) \\
&= gfp^{a}(\{a, b, c, e, f, g\}, \{d\}) \\
&= gfp^{a}(\{a, b, c, e, f, g, d\}, \emptyset) \\
&= \text{true}.
\end{align*}
$$

注意，这次 $support(a)$ 只计算了一次。

### 21.6.2 定理

1. 如果 $support_F(A) \subseteq A \cup X$ 且 $gfp^{a}_F(A, X) = \text{true}$，那么 $A \cup X \subseteq \nu F$。
2. 如果 $gfp^{a}_F(A, X) = \text{false}$，那么 $X \nsubseteq \nu F$。

**证明：**

- **与定理 21.5.9 类似。**
- **第一点：**

  - 假设 $support_F(A) \subseteq A \cup X$ 且 $gfp^{a}_F(A, X) = \text{true}$。
  - 通过归纳，可以证明 $A \cup X$ 是 $F$-一致的，即 $A \cup X \subseteq \nu F$。

- **第二点：**

  - 如果 $gfp^{a}_F(A, X) = \text{false}$，那么要么 $support(X) \uparrow$，要么递归调用返回 $\text{false}$。
  - 这意味着 $X$ 中至少有一个元素不在 $\nu F$ 中，因此 $X \nsubseteq \nu F$。

### 进一步的算法优化

本节的其余部分讨论了 $gfp$ 算法的另外两个变体，它们更接近于递归类型的已知子类型算法。

### 21.6.3 定义

对 $gfp^{a}$ 进行一个小的变体，算法一次只从 $X$ 中选择一个元素，展开其支持。新算法称为 $gfp^{s}_F$（或简称 $gfp^{s}$，其中 “$s$” 代表 “single（单个）”）。

$$
gfp^{s}(A, X) =
\begin{cases}
\text{true}, & \text{如果 } X = \emptyset \\
\text{令 } x \text{ 为 } X \text{ 中的某个元素} \\
\quad \text{如果 } x \in A, & \text{则 } gfp^{s}(A, X \setminus \{x\}) \\
\quad \text{如果 } support(x) \uparrow, & \text{则 } \text{false} \\
\quad \text{否则}, & \text{计算 } gfp^{s}(A \cup \{x\},\ (X \cup support(x)) \setminus (A \cup \{x\}))
\end{cases}
$$

**解释：**

- **一次处理一个元素**：每次从 $X$ 中取出一个元素 $x$，展开其支持。
- **检查 $x$ 是否已在 $A$ 中**：如果是，跳过它（避免重复计算）。
- **更新集合**：将 $x$ 加入 $A$，将其支持集加入 $X$，并移除已处理的元素。

**正确性声明：**

- 该算法的正确性（即递归“循环”的不变量）与定理 21.6.2 完全相同。

### 进一步修改

许多现有的递归子类型算法只接受一个候选元素，而不是一个集合。再进行一个小的修改，使我们的算法更接近这些算法。

修改后的算法不再是尾递归的，因为它使用调用栈来记住尚未检查的子目标。另一个变化是，算法同时接受一个假设集合 $A$ 作为参数，并返回一个新的假设集合作为结果。这允许它记录在已完成的递归调用期间生成的子类型假设，并在以后的调用中重用它们。实际上，假设集合被“穿线”通过递归调用图，因此算法被称为 $gfp^{t}$。

### 21.6.4 定义

给定一个可逆的生成函数 $F$，定义函数 $gfp^{t}_F$（或简称 $gfp^{t}$）如下：

$$
gfp^{t}(A, x) =
\begin{cases}
A, & \text{如果 } x \in A \\
\text{fail}, & \text{如果 } support(x) \uparrow \\
\text{否则}, & \text{令 } \{x_1, x_2, \dots, x_n\} = support(x) \\
& \text{令 } A_0 = A \cup \{x\} \\
& \text{令 } A_1 = gfp^{t}(A_0, x_1) \\
& \dots \\
& \text{令 } A_n = gfp^{t}(A_{n-1}, x_n) \\
& \text{返回 } A_n
\end{cases}
$$

**解释：**

- **$A$**：当前的假设集合。
- **$x$**：当前要检查的元素。
- **$support(x)$**：元素 $x$ 的支持集 $\{x_1, x_2, \dots, x_n\}$。
- **递归调用**：对每个支持元素 $x_i$ 递归调用 $gfp^{t}$，更新假设集合。

要检查 $x \in \nu F$，计算 $gfp^{t}(\emptyset, x)$。如果调用成功，那么 $x \in \nu F$；如果失败，那么 $x \notin \nu F$。

**故障处理约定：**

- 如果一个表达式 $B$ 失败，那么 “$\text{令 } A = B \text{ 在 } C$” 也失败。
- 这避免了在每次递归调用中编写显式的“异常处理”语句。

### 21.6.5 引理

1. 如果 $gfp^{t}_F(A, x) = A_0$，那么 $A \cup \{x\} \subseteq A_0$。
2. 对于任意 $X$，如果 $support_F(A) \subseteq A \cup X \cup \{x\}$ 且 $gfp^{t}_F(A, x) = A_0$，那么 $support_F(A_0) \subseteq A_0 \cup X$。

**证明：**

- **第一点：**

  - 对算法运行的递归结构进行常规的归纳。
  - 当 $x \in A$ 时，$A_0 = A$，结论显然成立。
  - 当 $x \notin A$ 时，$A_0 = A \cup \{x\}$，因此 $A \cup \{x\} \subseteq A_0$。

- **第二点：**

  - 对算法运行的递归结构进行归纳。
  - 当 $x \in A$ 时，$A_0 = A$，结论直接从假设得出。
  - 当 $x \notin A$ 时：

    - 假设 $support(x) = \{x_1, x_2\}$（一般情况类似，可以使用 $support(x)$ 的大小进行内层归纳）。
    - 算法计算 $A_0 = A \cup \{x\}$，然后依次计算 $A_1 = gfp^{t}(A_0, x_1)$，$A_2 = gfp^{t}(A_1, x_2)$，最终返回 $A_2$。
    - 我们需要证明，对于任意 $X_0$，如果 $support(A) \subseteq A \cup \{x\} \cup X_0$，那么 $support(A_2) \subseteq A_2 \cup X_0$。
    - 令 $X_1 = X_0 \cup \{x_2\}$。
    - 我们有：

      $$
      \begin{align*}
      support(A_0) &= support(A) \cup support(x) \\
      &= support(A) \cup \{x_1, x_2\} \\
      &\subseteq A \cup \{x\} \cup X_0 \cup \{x_1, x_2\} \\
      &= A_0 \cup X_0 \cup \{x_1, x_2\} \\
      &= A_0 \cup X_1 \cup \{x_1\}
      \end{align*}
      $$

    - 通过归纳假设，对第一次递归调用应用，$X$ 实例化为 $X_1$，得到 $support(A_1) \subseteq A_1 \cup X_1 = A_1 \cup \{x_2\} \cup X_0$。
    - 同理，对第二次递归调用应用归纳假设，$X$ 实例化为 $X_0$，得到 $support(A_2) \subseteq A_2 \cup X_0$。

### 21.6.6 定理

1. 如果 $gfp^{t}_F(\emptyset, x) = A_0$，那么 $x \in \nu F$。
2. 如果 $gfp^{t}_F(\emptyset, x) = \text{fail}$，那么 $x \notin \nu F$。

**证明：**

- **第一点：**

  - 根据引理 21.6.5（1），有 $x \in A_0$。
  - 将引理 21.6.5（2）中的 $X$ 实例化为 $\emptyset$，得到 $support(A_0) \subseteq A_0$。
  - 根据引理 21.5.7，$A_0$ 是 $F$-一致的，因此 $A_0 \subseteq \nu F$，所以 $x \in \nu F$。

- **第二点：**

  - 通过对 $gfp^{t}_F$ 算法运行深度的简单归纳，并使用引理 21.5.8，可以证明：如果对于某个 $A$，有 $gfp^{t}_F(A, x) = \text{fail}$，那么 $x \notin \nu F$。

### 终止性

由于本节中的所有算法都检查可达集，因此它们的充分终止条件与原始的 $gfp$ 算法相同：当 $F$ 是有限状态时，它们在所有输入上终止。

---

## 21.7 正则树（Regular Trees）

此时，我们已经开发了用于检查由生成函数 $F$ 的最大不动点定义的集合的成员资格的通用算法，假设 $F$ 是可逆的且有限状态的；我们还分别展示了如何将无限树之间的子类型关系定义为特定生成函数 $S$ 的最大不动点。

显然的下一步是用 $S$ 实例化我们的算法。当然，这个具体算法不会在所有输入上终止，因为一般来说，从给定的一对无限类型可达的状态集合可能是无限的。但是，正如我们将在本节中看到的，如果我们将自己限制在某种良好行为形式的无限类型上，即所谓的**正则类型（regular types）**，那么可达状态的集合将保证保持有限，子类型检查算法将始终终止。

### 21.7.1 定义

一个树类型 $S$ 是树类型 $T$ 的**子树（subtree）**，如果存在某个路径前缀 $\pi$，使得 $S = \lambda \sigma.\ T(\pi \cdot \sigma)$。也就是说，如果函数 $S$ 可以通过在传递给 $T$ 的路径前加上某个常量前缀 $\pi$ 来从函数 $T$ 获得；前缀 $\pi$ 对应于从 $T$ 的根到 $S$ 的根的路径。

我们用 $subtrees(T)$ 表示 $T$ 的所有子树的集合。

**解释：**

- **$S$**：树类型 $S$，是树类型 $T$ 的一个子树。
- **$\lambda \sigma.\ T(\pi \cdot \sigma)$**：一个以 $\pi$ 为前缀的路径上的函数。

### 21.7.2 定义

一个树类型 $T \in T$ 是**正则的（regular）**，如果 $subtrees(T)$ 是有限的，即 $T$ 有有限多个不同的子树。

正则树类型的集合记为 $T_r$。

### 21.7.3 示例

1. **每个有限树类型都是正则的**；不同子树的数量至多是节点的数量。一个树类型的不同子树的数量可以严格小于节点的数量。例如，$T = \text{Top} \to (\text{Top} \times \text{Top})$ 有 5 个节点，但只有 3 个不同的子树（$T$ 本身、$\text{Top} \times \text{Top}$ 和 $\text{Top}$）。

2. **一些无限树类型是正则的**。例如，树

   $$
   T = \text{Top} \times (\text{Top} \times (\text{Top} \times \dots))
   $$

   只有两个不同的子树（$T$ 本身和 $\text{Top}$）。

3. **非正则树类型的例子**：

   考虑树类型

   $$
   T = B \times (A \times (B \times (A \times (A \times (B \times (A \times (A \times (A \times (B \times \dots
   $$

   其中成对的连续 $B$ 被越来越多的 $A$ 分隔。由于 $T$ 是不规则的，证明 $T<:T$ 所需的子类型对组成的集合 $reachable_S(T, T)$ 是无限的。

### 21.7.4 命题

生成函数 $S$ 在正则树类型上的限制 $S_r$ 是有限状态的。

**证明：**

- 我们需要证明，对于任何正则树类型对 $(S, T)$，集合 $reachable_{S_r}(S, T)$ 是有限的。
- 注意，$reachable_{S_r}(S, T) \subseteq subtrees(S) \times subtrees(T)$；由于 $subtrees(S)$ 和 $subtrees(T)$ 都是有限的，因此 $reachable_{S_r}(S, T)$ 是有限的。

**结论：**

- 我们可以通过将我们的成员资格算法与 $S$ 实例化来获得正则树类型上子类型关系的判定过程。

为了在实际实现中使这项工作有效，正则树必须由一些有限的结构来表示。其中一种表示方法是 **$\mu$-表示法（$\mu$-notation）**，我们将在下一节讨论。

---

## 21.8 $\mu$-类型（µ-Types）

本节将开发有限的 $\mu$-表示法，定义 $\mu$-表达式上的子类型关系，并建立这种子类型概念与树类型上的子类型之间的对应关系。

### 21.8.1 定义

令 $X$ 从固定的可数类型变量集合 $\{X_1, X_2, \dots\}$ 中取值。

**原始 $\mu$-类型（raw $\mu$-types）**的集合 $T^{\text{raw}}_{\mu}$ 由以下语法定义的表达式组成：

$$
T ::= X \quad | \quad \text{Top} \quad | \quad T \times T \quad | \quad T \to T \quad | \quad \mu X.\ T
$$

- **解释：**

  - **$X$**：类型变量。
  - **$\text{Top}$**：顶类型。
  - **$T \times T$**：乘积类型。
  - **$T \to T$**：函数类型。
  - **$\mu X.\ T$**：递归类型构造器，其中 $\mu$ 是一个绑定符号。

**绑定和自由变量：**

- **$\mu$** 是一个绑定操作符，按照标准方式引入了绑定变量和自由变量的概念。

- **$FV(T)$**：原始 $\mu$-类型 $T$ 的自由变量集合。

- **替换 [X , S]T**：将原始 $\mu$-类型 $S$ 代入原始 $\mu$-类型 $T$ 中的自由变量 $X$，需要避免捕获（capture-avoiding substitution）。

**收缩性（Contractiveness）：**

- 原始 $\mu$-类型需要稍微限制一下，以与正则树建立紧密的对应关系。我们希望能够将给定的 $\mu$-类型“展开”为无限的树类型，但有些原始 $\mu$-类型无法合理地解释为树类型的表示。这些类型具有形如 $\mu X.\ \mu X_1 \dots \mu X_n.\ X$ 的子表达式，其中 $X_1$ 到 $X_n$ 与 $X$ 不同。

- 例如，考虑 $T = \mu X.\ X$。展开 $T$ 得到的仍然是 $T$ 本身，我们无法通过展开 $T$ 读出任何树。

### 21.8.2 定义

一个原始 $\mu$-类型 $T$ 是**收缩的（contractive）**，如果对于 $T$ 的任何形如 $\mu X.\ \mu X_1 \dots \mu X_n.\ S$ 的子表达式，主体 $S$ 都不是 $X$。等价地，如果每个在主体中出现的 $\mu$ 绑定变量都与其绑定器之间至少被一个 $\to$ 或 $\times$ 分隔。

一个原始 $\mu$-类型被称为**$\mu$-类型**，如果它是收缩的。$\mu$-类型的集合记为 $T_{\mu}$。

当 $T$ 是一个 $\mu$-类型时，我们用 $\mu$-高度（$\mu$-height）来表示 $T$ 前面的 $\mu$ 绑定数。

**解释：**

- **收缩性**确保了展开 $\mu$-类型可以得到一个对应的无限树。

### 21.8.3 定义

将闭合的 $\mu$-类型映射到树类型的函数 $treeof$ 定义如下：

1. **基本情况：**

   - 对于 $\text{Top}$：

     $$
     treeof(\text{Top})(\bullet) = \text{Top}
     $$

   - **解释：**

     - $\bullet$ 表示根路径。
     - $treeof(\text{Top})$ 在根路径上的值为 $\text{Top}$。

2. **函数类型 $T_1 \to T_2$：**

   - 在根路径上：

     $$
     treeof(T_1 \to T_2)(\bullet) = \to
     $$

   - 对于子路径：

     $$
     treeof(T_1 \to T_2)(i, \pi) = treeof(T_i)(\pi), \quad \text{其中 } i = 1, 2
     $$

   - **解释：**

     - 根路径上的符号是箭头 $\to$。
     - 子路径 $(i, \pi)$ 表示第 $i$ 个子类型的路径 $\pi$。

3. **乘积类型 $T_1 \times T_2$：**

   - 在根路径上：

     $$
     treeof(T_1 \times T_2)(\bullet) = \times
     $$

   - 对于子路径：

     $$
     treeof(T_1 \times T_2)(i, \pi) = treeof(T_i)(\pi), \quad \text{其中 } i = 1, 2
     $$

4. **递归类型 $\mu X.\ T$：**

   $$
   treeof(\mu X.\ T)(\pi) = treeof([X, \mu X.\ T]T)(\pi)
   $$

   - **解释：**

     - 对于递归类型，我们将其展开，即将 $X$ 替换为 $\mu X.\ T$。

**确保定义正确（穷尽且终止）：**

1. **每个右侧的递归调用都会减少对偶 $(|\pi|, \mu\text{-height}(T))$ 的词典顺序大小：**

   - 对于 $T_1 \to T_2$ 和 $T_1 \times T_2$ 的情况，$|\pi|$ 减少（路径长度减少）。
   - 对于 $\mu X.\ T$ 的情况，$|\pi|$ 保持不变，但 $\mu$-高度减少。

2. **所有递归调用都保持参数类型的收缩性和闭合性。**

### 例子

**示例 $\mu$-类型：**

$$
T = \mu X.\ ((X \times \text{Top}) \to X)
$$

**应用 $treeof$ 的结果如图 21-3 所示。**

- 由于图无法显示，我们描述一下展开过程。

**展开步骤：**

1. **展开 $\mu X.\ ((X \times \text{Top}) \to X)$：**

   - 替换 $X$ 为整个类型本身，得到：

     $$
     ((\mu X.\ ((X \times \text{Top}) \to X) \times \text{Top}) \to \mu X.\ ((X \times \text{Top}) \to X))
     $$

2. **继续展开，可以得到一个无限的树结构，其中节点交替出现 $\to$ 和 $\times$，并在适当的位置插入 $\text{Top}$。**

### $\mu$-类型的子类型关系

树类型上的子类型关系在第 21.3 节中被定义为生成函数 $S$ 的最大不动点。

在本节中，我们扩展了类型的语法，包含了 $\mu$-类型，其行为可以通过以下（分别是右和左的）$\mu$-折叠规则直观地描述：

1. **右 $\mu$-折叠：**

   $$
   S <: [X, \mu X.\ T]T \quad \implies \quad S <: \mu X.\ T
   $$

2. **左 $\mu$-折叠：**

   $$
   [X, \mu X.\ S]S <: T \quad \implies \quad \mu X.\ S <: T
   $$

**正式定义**

### 21.8.4 定义

两个 $\mu$-类型 $S$ 和 $T$ 属于子类型关系，当且仅当 $(S, T) \in \nu S_{\mu}$，其中单调函数 $S_{\mu} \in P(T_{\mu} \times T_{\mu}) \to P(T_{\mu} \times T_{\mu})$ 定义为：

$$
\begin{align*}
S_{\mu}(R) =\ & \{(S, \text{Top}) \mid S \in T_{\mu}\} \\
& \cup \{(S_1 \times S_2,\ T_1 \times T_2) \mid (S_1, T_1),\ (S_2, T_2) \in R\} \\
& \cup \{(S_1 \to S_2,\ T_1 \to T_2) \mid (T_1, S_1),\ (S_2, T_2) \in R\} \\
& \cup \{(S,\ \mu X.\ T) \mid (S,\ [X,\ \mu X.\ T]T) \in R\} \\
& \cup \{(\mu X.\ S,\ T) \mid ([X,\ \mu X.\ S]S,\ T) \in R,\ T \ne \text{Top},\ T \ne \mu Y.\ T_1\}
\end{align*}
$$

**解释：**

- **第一行（顶类型规则）：**

  - 所有类型 $S$ 都是 $\text{Top}$ 的子类型。

- **第二行（乘积类型规则）：**

  - 如果 $(S_1, T_1) \in R$ 且 $(S_2, T_2) \in R$，那么 $(S_1 \times S_2, T_1 \times T_2) \in S_{\mu}(R)$。

- **第三行（函数类型规则）：**

  - 注意函数类型子类型规则中的逆变和协变。

  - 如果 $(T_1, S_1) \in R$ 且 $(S_2, T_2) \in R$，那么 $(S_1 \to S_2, T_1 \to T_2) \in S_{\mu}(R)$。

- **第四行（右 $\mu$-折叠）：**

  - 如果 $(S, [X, \mu X.\ T]T) \in R$，那么 $(S, \mu X.\ T) \in S_{\mu}(R)$。

- **第五行（左 $\mu$-折叠）：**

  - 如果 $T \ne \text{Top}$ 且 $T \ne \mu Y.\ T_1$，并且 $([X, \mu X.\ S]S, T) \in R$，那么 $(\mu X.\ S, T) \in S_{\mu}(R)$。

**注意：**

- 这个定义并不完全体现上面的 $\mu$-折叠规则；我们在最后两个子句之间引入了不对称性，以使其可逆（否则，这些子句会重叠）。
- 然而，正如接下来的练习所示，$S_{\mu}$ 生成的子类型关系与更自然的生成函数 $S_d$ 生成的子类型关系相同，后者的子句正好对应于推导规则。

### 21.8.5 练习 [«««]

**题目：**

- 写出上述提到的函数 $S_d$，并证明它不是可逆的。
- 证明 $\nu S_d = \nu S_{\mu}$。

**解答：**

**1. 写出 $S_d$：**

$S_d$ 的定义完全对应于推导规则：

$$
\begin{align*}
S_d(R) =\ & \{(S, \text{Top}) \mid S \in T_{\mu}\} \\
& \cup \{(S_1 \times S_2,\ T_1 \times T_2) \mid (S_1, T_1),\ (S_2, T_2) \in R\} \\
& \cup \{(S_1 \to S_2,\ T_1 \to T_2) \mid (T_1, S_1),\ (S_2, T_2) \in R\} \\
& \cup \{(S,\ \mu X.\ T) \mid (S,\ [X,\ \mu X.\ T]T) \in R\} \\
& \cup \{(\mu X.\ S,\ T) \mid ([X,\ \mu X.\ S]S,\ T) \in R\}
\end{align*}
$$

**2. 证明 $S_d$ 不是可逆的：**

- 可逆性要求对于每个 $(S, T)$，其支持集是唯一的，但在 $S_d$ 中，最后两个子句可能重叠，导致 $(S, T)$ 有多个最小支持集。
- 例如，对于 $(S, T) = (\mu X.\ S_1, \mu Y.\ T_1)$，既可以应用第四个子句，也可以应用第五个子句。

**3. 证明 $\nu S_d = \nu S_{\mu}$：**

- 尽管 $S_d$ 不是可逆的，但它生成的子类型关系与 $S_{\mu}$ 相同。
- 可以通过证明两个生成函数的最大不动点相同来完成。

---

### 支持函数

生成函数 $S_{\mu}$ 是可逆的，因为对应的支持函数定义良好：

$$
support_{S_{\mu}}(S, T) =
\begin{cases}
\emptyset, & \text{如果 } T = \text{Top} \\
\{(S_1, T_1),\ (S_2, T_2)\}, & \text{如果 } S = S_1 \times S_2 \text{ 且 } T = T_1 \times T_2 \\
\{(T_1, S_1),\ (S_2, T_2)\}, & \text{如果 } S = S_1 \to S_2 \text{ 且 } T = T_1 \to T_2 \\
\{(S,\ [X,\ \mu X.\ T_1]T_1)\}, & \text{如果 } T = \mu X.\ T_1 \\
\{([X,\ \mu X.\ S_1]S_1,\ T)\}, & \text{如果 } S = \mu X.\ S_1 \text{ 且 } T \ne \mu X.\ T_1,\ T \ne \text{Top} \\
\uparrow, & \text{否则}
\end{cases}
$$

**解释：**

- 支持函数根据 $S$ 和 $T$ 的形式，返回需要支持的类型对集合。
- 如果无法匹配任何规则，则返回未定义 $\uparrow$。

---

### 21.8.7 定理

对于任意 $(S, T) \in T_{\mu} \times T_{\mu}$，有 $(S, T) \in \nu S_{\mu}$ 当且仅当 $treeof(S, T) \in \nu S$。

**解释：**

- 该定理建立了 $\mu$-类型之间的子类型关系（由 $\nu S_{\mu}$ 定义）与对应的无限树类型之间的子类型关系（由 $\nu S$ 定义）之间的对应关系。

**证明（简要）：**

- **“如果”方向：**

  - 假设 $treeof(S, T) \in \nu S$。
  - 需要展示存在一个 $S_{\mu}$-一致的集合 $R$，使得 $(S, T) \in R$。
  - 构造 $R = \{(S', T') \in T_{\mu} \times T_{\mu} \mid treeof(S', T') \in \nu S\}$。
  - 通过检查 $S_{\mu}$ 的定义，可以证明 $R$ 是 $S_{\mu}$-一致的。

- **“仅如果”方向：**

  - 假设 $(S, T) \in \nu S_{\mu}$。
  - 构造 $Q = treeof(\nu S_{\mu})$。
  - 由于 $S_{\mu}$ 的一致性，可以证明 $Q$ 是 $S$-一致的，并且 $(treeof(S), treeof(T)) \in Q$。

**结论：**

- 该定理的对应性说明了本节中定义的 $\mu$-类型之间的子类型关系在无限树类型的子类型关系（受限于那些可以由有限 $\mu$-表达式表示的树类型）下的正确性和完备性。

---

**总结：**

- 我们通过引入 $\mu$-类型，为正则树类型提供了一种有限的表示方式。
- 通过定义适当的生成函数 $S_{\mu}$，我们可以在 $\mu$-类型上定义子类型关系。
- 重要的是，我们证明了 $\mu$-类型上的子类型关系与对应的无限树类型上的子类型关系之间的一致性。

### ----------------------------

## 21.9 计算子表达式数量（Counting Subexpressions）

在本节中，我们将通用算法 $gfpt$（定义 21.6.4）与用于 $\mu$-类型子类型关系的特定支持函数 $support_{S_{\mu}}$（定义 21.8.4）进行实例化。这会得到图 21-4 中展示的针对 $\mu$-类型的具体子类型算法。

### 针对 $\mu$-类型的子类型算法（图 21-4）

**算法：** `subtype(A, S, T)`

**输入：**

- $A$：假设集合，已经考虑过的类型对集合。
- $S$，$T$：需要比较的 $\mu$-类型。

**输出：**

- 更新的假设集合，如果 $S <: T$，否则失败。

**算法步骤：**

1. **检查 $(S, T)$ 是否已经在假设集合 $A$ 中：**

   $$
   \text{if } (S, T) \in A,\ \text{then return } A
   $$

   **解释：**

   - 如果 $(S, T)$ 已经被考虑过，直接返回当前假设集合，避免重复计算和无限递归。

2. **将当前类型对 $(S, T)$ 添加到假设集合中：**

   $$
   A_0 = A \cup \{(S, T)\}
   $$

3. **检查 $T$ 是否为顶类型 $\text{Top}$：**

   $$
   \text{if } T = \text{Top},\ \text{then return } A_0
   $$

   **解释：**

   - 所有类型都是 $\text{Top}$ 的子类型，因此可以直接得出结论。

4. **检查 $S$ 和 $T$ 是否都是乘积类型：**

   $$
   \text{if } S = S_1 \times S_2 \text{ and } T = T_1 \times T_2,\ \text{then}
   $$

   - 递归检查：

     $$
     A_1 = \text{subtype}(A_0, S_1, T_1)
     $$

     $$
     \text{return subtype}(A_1, S_2, T_2)
     $$

   **解释：**

   - 对于乘积类型，需要分别比较各个组成部分的子类型关系。

5. **检查 $S$ 和 $T$ 是否都是函数类型：**

   $$
   \text{if } S = S_1 \to S_2 \text{ and } T = T_1 \to T_2,\ \text{then}
   $$

   - 递归检查：

     $$
     A_1 = \text{subtype}(A_0, T_1, S_1)
     $$

     $$
     \text{return subtype}(A_1, S_2, T_2)
     $$

   **解释：**

   - 对于函数类型，参数类型逆变，返回类型协变。

6. **检查 $T$ 是否是递归类型：**

   $$
   \text{if } T = \mu X.T_1,\ \text{then return subtype}(A_0, S,\ [X \mapsto \mu X.T_1]T_1)
   $$

   **解释：**

   - 展开 $T$ 的递归定义，用 $[X \mapsto \mu X.T_1]T_1$ 替换 $T$，继续递归比较。

7. **检查 $S$ 是否是递归类型：**

   $$
   \text{if } S = \mu X.S_1,\ \text{then return subtype}([X \mapsto \mu X.S_1]S_1,\ T)
   $$

   **解释：**

   - 类似地，展开 $S$ 的递归定义，继续递归比较。

8. **如果以上情况都不满足，则失败：**

   $$
   \text{else fail}
   $$

**符号解析：**

- **$A$**：假设集合，记录已考虑的类型对。
- **$S$，$T$**：待比较的 $\mu$-类型。
- **$S_1$，$S_2$**：$S$ 的组成部分（乘积或函数类型）。
- **$T_1$，$T_2$**：$T$ 的组成部分。
- **$\mu X.S_1$**：递归类型，$X$ 是类型变量，$S_1$ 是类型主体。
- **$[X \mapsto \mu X.S_1]S_1$**：用 $\mu X.S_1$ 替换 $S_1$ 中的 $X$。

**终止性的证明**

在第 21.6 节的论证表明，如果对于任意 $\mu$-类型对 $(S, T)$，$reachable_{S_{\mu}}(S, T)$ 是有限的，那么算法的终止性可以得到保证。本节的目标是证明这一点（命题 21.9.11）。

**证明难点**

乍一看，这个性质似乎显而易见，但严谨地证明它需要相当多的工作。困难在于定义 $\mu$-类型的“闭合子表达式”的方式存在两种可能：

1. **自顶向下的子表达式（Top-Down Subexpressions）**：

   - 直接对应于由 $support_{S_{\mu}}$ 生成的子表达式。
   - 从类型的根开始，递归地考虑其子类型。

2. **自底向上的子表达式（Bottom-Up Subexpressions）**：

   - 支持简单的证明，即每个闭合的 $\mu$-类型只有有限个闭合子表达式。
   - 从类型的叶子节点开始，逐步构建子表达式。

证明过程是定义这两个集合，并证明前者是后者的子集（命题 21.9.10）。

### 21.9.1 定义（自顶向下的子表达式）

一个 $\mu$-类型 $S$ 是 $\mu$-类型 $T$ 的**自顶向下子表达式**，记作 $S \sqsubseteq T$，如果 $(S, T)$ 在以下生成函数 $TD$ 的最小不动点中：

$$
\begin{align*}
TD(R) =\ & \{ (T, T) \mid T \in T_{\mu} \} \\
& \cup \{ (S, T_1 \times T_2) \mid (S, T_1) \in R \} \\
& \cup \{ (S, T_1 \times T_2) \mid (S, T_2) \in R \} \\
& \cup \{ (S, T_1 \to T_2) \mid (S, T_1) \in R \} \\
& \cup \{ (S, T_1 \to T_2) \mid (S, T_2) \in R \} \\
& \cup \{ (S, \mu X.T) \mid (S, [X \mapsto \mu X.T]T) \in R \}
\end{align*}
$$

**符号解析：**

- **$T_{\mu}$**：所有 $\mu$-类型的集合。
- **$(T, T)$**：表示类型 $T$ 是自身的子表达式。
- **乘积类型规则**：如果 $S$ 是 $T_1$ 或 $T_2$ 的子表达式，那么 $S$ 也是 $T_1 \times T_2$ 的子表达式。
- **函数类型规则**：类似于乘积类型。
- **递归类型规则**：如果 $S$ 是 $[X \mapsto \mu X.T]T$ 的子表达式，那么 $S$ 也是 $\mu X.T$ 的子表达式。

### 21.9.2 练习 [«]

**题目：**

给出关系 $S \sqsubseteq T$ 的等价定义，作为一组推导规则。

**解答：**

**推导规则：**

1. **自反性规则：**

   $$
   \frac{}{T \sqsubseteq T}
   $$

2. **乘积类型左组件规则：**

   $$
   \frac{S \sqsubseteq T_1}{S \sqsubseteq T_1 \times T_2}
   $$

3. **乘积类型右组件规则：**

   $$
   \frac{S \sqsubseteq T_2}{S \sqsubseteq T_1 \times T_2}
   $$

4. **函数类型参数规则：**

   $$
   \frac{S \sqsubseteq T_1}{S \sqsubseteq T_1 \to T_2}
   $$

5. **函数类型返回值规则：**

   $$
   \frac{S \sqsubseteq T_2}{S \sqsubseteq T_1 \to T_2}
   $$

6. **递归类型展开规则：**

   $$
   \frac{S \sqsubseteq [X \mapsto \mu X.T]T}{S \sqsubseteq \mu X.T}
   $$

**解释：**

- 这些规则允许我们通过递归地检查类型的组成部分，推导出 $S$ 是否为 $T$ 的子表达式。

### 21.9.3 引理

**陈述：**

如果 $(S_0, T_0) \in support_{S_{\mu}}(S, T)$，那么 $S_0 \sqsubseteq S$ 或 $S_0 \sqsubseteq T$，并且 $T_0 \sqsubseteq S$ 或 $T_0 \sqsubseteq T$。

**证明：**

- 直接检查 $support_{S_{\mu}}$ 的定义可知，每个支持对的组成部分都是 $S$ 或 $T$ 的子表达式。

**详细解释：**

- **乘积类型情况：**

  - 如果 $S = S_1 \times S_2$ 且 $T = T_1 \times T_2$，那么 $support_{S_{\mu}}(S, T) = \{ (S_1, T_1),\ (S_2, T_2) \}$。
  - $S_1$ 是 $S$ 的子表达式，$T_1$ 是 $T$ 的子表达式。

- **函数类型情况：**

  - 类似地处理。

### 21.9.4 引理

**陈述：**

如果 $S \sqsubseteq U$ 且 $U \sqsubseteq T$，那么 $S \sqsubseteq T$。

**证明：**

- 这是子表达式关系的传递性。
- 可以通过对 $S \sqsubseteq U$ 和 $U \sqsubseteq T$ 的推导结构进行归纳证明。

**解释：**

- 我们需要证明如果 $S$ 是 $U$ 的子表达式，且 $U$ 是 $T$ 的子表达式，那么 $S$ 是 $T$ 的子表达式。

### 21.9.5 命题

**陈述：**

如果 $(S_0, T_0) \in reachable_{S_{\mu}}(S, T)$，那么 $S_0 \sqsubseteq S$ 或 $S_0 \sqsubseteq T$，并且 $T_0 \sqsubseteq S$ 或 $T_0 \sqsubseteq T$。

**证明：**

- 通过对 $reachable_{S_{\mu}}$ 的定义进行归纳，使用引理 21.9.3 和 21.9.4。

**解释：**

- 由于 $reachable_{S_{\mu}}(S, T)$ 是通过不断应用 $support_{S_{\mu}}$ 构建的，而每个支持对的组成部分都是 $S$ 或 $T$ 的子表达式，因此命题成立。

**证明过程中的难点**

- 要证明 $reachable_{S_{\mu}}(S, T)$ 是有限的，需要证明任意 $\mu$-类型只有有限个自顶向下的子表达式。然而，直接根据 $TD$ 的定义进行结构归纳会遇到困难，因为 $TD$ 的最后一个子句涉及展开类型，会导致潜在的无限展开。

### 引入自底向上的子表达式

为了解决这个问题，我们引入了**自底向上的子表达式**的概念。

### 21.9.6 定义（自底向上的子表达式）

一个 $\mu$-类型 $S$ 是 $\mu$-类型 $T$ 的**自底向上子表达式**，记作 $S \sqsubseteq_b T$，如果 $(S, T)$ 在以下生成函数 $BU$ 的最小不动点中：

$$
\begin{align*}
BU(R) =\ & \{ (T, T) \mid T \in T_{\mu} \} \\
& \cup \{ (S, T_1 \times T_2) \mid (S, T_1) \in R \} \\
& \cup \{ (S, T_1 \times T_2) \mid (S, T_2) \in R \} \\
& \cup \{ (S, T_1 \to T_2) \mid (S, T_1) \in R \} \\
& \cup \{ (S, T_1 \to T_2) \mid (S, T_2) \in R \} \\
& \cup \{ ([X \mapsto \mu X.T]S,\ \mu X.T) \mid (S, T) \in R \}
\end{align*}
$$

**解释：**

- 这里的主要区别在于最后一个子句：
  - 而不是在展开递归类型后再计算子表达式，我们先计算主体的（可能未闭合的）子表达式，然后通过应用展开替换来闭合它们。

### 21.9.7 练习 [««]

**题目：**

给出关系 $S \sqsubseteq_b T$ 的等价定义，作为一组推导规则。

**解答：**

**推导规则：**

1. **自反性规则：**

   $$
   \frac{}{T \sqsubseteq_b T}
   $$

2. **乘积类型左组件规则：**

   $$
   \frac{S \sqsubseteq_b T_1}{S \sqsubseteq_b T_1 \times T_2}
   $$

3. **乘积类型右组件规则：**

   $$
   \frac{S \sqsubseteq_b T_2}{S \sqsubseteq_b T_1 \times T_2}
   $$

4. **函数类型参数规则：**

   $$
   \frac{S \sqsubseteq_b T_1}{S \sqsubseteq_b T_1 \to T_2}
   $$

5. **函数类型返回值规则：**

   $$
   \frac{S \sqsubseteq_b T_2}{S \sqsubseteq_b T_1 \to T_2}
   $$

6. **递归类型折叠规则：**

   $$
   \frac{S \sqsubseteq_b T}{[X \mapsto \mu X.T]S \sqsubseteq_b \mu X.T}
   $$

**解释：**

- 在此定义中，我们先计算 $T$ 的子表达式 $S$，然后通过替换 $[X \mapsto \mu X.T]$ 将其闭合。

### 21.9.8 引理

**陈述：**

对于每个 $\mu$-类型 $T$，集合 $\{ S \mid S \sqsubseteq_b T \}$ 是有限的。

**证明：**

- 对 $T$ 进行结构归纳。
- 在每一步，我们根据 $BU$ 的定义，列出有限个可能的子表达式。

**解释：**

- 由于 $\mu$-类型是有限的语法结构，且替换操作不会引入新的变量，因此自底向上的子表达式集合是有限的。

### 21.9.9 引理

**陈述：**

如果 $S \sqsubseteq_b [X \mapsto Q]T$，那么要么 $S \sqsubseteq_b Q$，要么存在 $S_0$，使得 $S = [X \mapsto Q]S_0$ 且 $S_0 \sqsubseteq_b T$。

**证明：**

- 对 $T$ 进行结构归纳，考虑 $T$ 的各种形式。

**解释：**

- 我们需要证明在对 $T$ 进行替换后得到的子表达式 $S$，要么来自于 $Q$，要么来自于 $T$ 的子表达式 $S_0$ 经过替换得到。

### 21.9.10 命题

**陈述：**

如果 $S \sqsubseteq T$，那么 $S \sqsubseteq_b T$。

**证明：**

- 我们需要证明自底向上的子表达式集合包含所有自顶向下的子表达式。
- 可以通过证明 $BU$ 的最小不动点包含 $TD$ 的最小不动点。

**解释：**

- 通过比较 $TD$ 和 $BU$ 的定义，可以发现每个 $TD$ 的子句都对应于 $BU$ 的一个子句，或者可以在 $BU$ 中推导出来。

### 21.9.11 命题

**陈述：**

对于任意 $\mu$-类型 $S$ 和 $T$，集合 $reachable_{S_{\mu}}(S, T)$ 是有限的。

**证明：**

- 根据命题 21.9.5，$reachable_{S_{\mu}}(S, T) \subseteq \text{Td} \times \text{Td}$，其中 $\text{Td}$ 是 $S$ 和 $T$ 的所有自顶向下子表达式的集合。
- 根据命题 21.9.10，$\text{Td} \subseteq \text{Bu}$，其中 $\text{Bu}$ 是自底向上的子表达式集合。
- 根据引理 21.9.8，$\text{Bu}$ 是有限的。
- 因此，$reachable_{S_{\mu}}(S, T)$ 是有限的。

**结论：**

- 因为 $reachable_{S_{\mu}}(S, T)$ 是有限的，所以针对 $\mu$-类型的子类型算法终止性得到了保证。

---

## 21.10 插曲：一个指数级的算法（An Exponential Algorithm）

我们考虑一个简化的子类型算法，类似于 Amadio 和 Cardelli（1993）提出的算法，称为 `subtypeac`。这个算法仅返回一个布尔值，而不是更新的假设集合。

### 算法：`subtypeac(A, S, T)`

**输入：**

- $A$：假设集合。
- $S$，$T$：需要比较的 $\mu$-类型。

**输出：**

- 布尔值，表示 $S$ 是否为 $T$ 的子类型。

**算法步骤：**

1. **检查 $(S, T)$ 是否已经在假设集合 $A$ 中：**

   $$
   \text{if } (S, T) \in A,\ \text{then return true}
   $$

2. **将当前类型对 $(S, T)$ 添加到假设集合中：**

   $$
   A_0 = A \cup \{(S, T)\}
   $$

3. **检查 $T$ 是否为顶类型 $\text{Top}$：**

   $$
   \text{if } T = \text{Top},\ \text{then return true}
   $$

4. **检查 $S$ 和 $T$ 是否都是乘积类型：**

   $$
   \text{if } S = S_1 \times S_2 \text{ and } T = T_1 \times T_2,\ \text{then}
   $$

   - 返回：

     $$
     \text{subtypeac}(A_0, S_1, T_1) \ \text{and} \ \text{subtypeac}(A_0, S_2, T_2)
     $$

5. **检查 $S$ 和 $T$ 是否都是函数类型：**

   $$
   \text{if } S = S_1 \to S_2 \text{ and } T = T_1 \to T_2,\ \text{then}
   $$

   - 返回：

     $$
     \text{subtypeac}(A_0, T_1, S_1) \ \text{and} \ \text{subtypeac}(A_0, S_2, T_2)
     $$

6. **检查 $S$ 是否是递归类型：**

   $$
   \text{if } S = \mu X.S_1,\ \text{then return subtypeac}(A_0,\ [X \mapsto \mu X.S_1]S_1,\ T)
   $$

7. **检查 $T$ 是否是递归类型：**

   $$
   \text{if } T = \mu X.T_1,\ \text{then return subtypeac}(A_0,\ S,\ [X \mapsto \mu X.T_1]T_1)
   $$

8. **如果以上情况都不满足，则返回 false：**

   $$
   \text{else return false}
   $$

**算法分析：**

- 这个算法不再返回更新的假设集合，而是直接返回布尔值。
- 由于它不记忆跨递归调用的类型对，导致递归调用次数指数级增长。

**示例：指数级行为的展示**

定义类型族 $S_n$ 和 $T_n$：

- **基例：**

  $$
  S_0 = \mu X.\ \text{Top} \times X \\
  T_0 = \mu X.\ \text{Top} \times (\text{Top} \times X)
  $$

- **递归定义：**

  $$
  S_{n+1} = \mu X.\ X \to S_n \\
  T_{n+1} = \mu X.\ X \to T_n
  $$

**检查 $S_n <: T_n$**

- 初始调用 `subtypeac(∅, S_n, T_n)`。
- 递归调用会以指数级增长，每次都会产生两个对 $S_{n-1}$ 和 $T_{n-1}$ 的递归调用。

**结论：**

- 由于缺乏对假设的记忆，算法的时间复杂度为指数级。

---

## 21.11 子类型等价递归类型（Subtyping Iso-Recursive Types）

在第 20.2 节中，我们提到了**等价递归类型（iso-recursive types）**，其中递归类型的折叠和展开通过 `fold` 和 `unfold` 构造显式地表示。

当在具有等价递归类型的语言中添加子类型关系时，我们需要定义直接涉及递归类型的子类型规则，以反映 $\mu$ 构造器的刚性。

### Amber 规则（S-Amber）

最常见的等价递归类型子类型定义是 **Amber 规则**：

$$
\frac{\Sigma,\ X <: Y\ \vdash\ S <: T}{\Sigma\ \vdash\ \mu X.S\ <: \mu Y.T}
$$

**解释：**

- 为了证明 $\mu X.S <: \mu Y.T$，在假设集合 $\Sigma$ 下，需要证明 $S <: T$，并增加额外的假设 $X <: Y$。

- **$\Sigma$**：假设集合，记录已经考虑的递归变量对。

### 假设规则（S-Assumption）

$$
\frac{(X <: Y) \in \Sigma}{\Sigma\ \vdash\ X <: Y}
$$

**解释：**

- 如果 $X <: Y$ 在假设集合 $\Sigma$ 中，那么可以得出 $X <: Y$。

**规则的影响：**

- 我们只在递归类型同时出现在子类型关系的两边时才展开。
- 我们不将递归类型替换到其主体中，而是使用变量和假设。
- 这种方法确保了子类型算法的终止性。

**与命名类型系统的关系：**

- 在命名类型系统（如第 19 章的 Featherweight Java）中，子类型规则与 Amber 规则密切相关。

### 21.11.1 练习 [推荐，««]

**题目：**

找到递归类型 $S$ 和 $T$，使得使用等价递归定义有 $S <: T$，但使用 Amber 规则没有。

**解答：**

**示例：**

- 定义：

  $$
  S = \mu X.\ X \\
  T = \mu Y.\ \text{Top}
  $$

- **使用等价递归定义：**

  - 展开 $S$ 得到 $S = \mu X.\ X = \mu X.\ X = \dots$
  - 展开 $T$ 得到 $T = \mu Y.\ \text{Top} = \text{Top}$
  - 因为任何类型都是 $\text{Top}$ 的子类型，且 $S$ 无限展开为自身，我们可能认为 $S <: T$。

- **使用 Amber 规则：**

  - 要证明 $\mu X.\ X <: \mu Y.\ \text{Top}$，需要在假设 $X <: Y$ 下证明 $X <: \text{Top}$。
  - 但 $X$ 和 $\text{Top}$ 没有结构可以比较，无法得出 $X <: \text{Top}$。
  - 因此，使用 Amber 规则无法证明 $S <: T$。

**结论：**

- 在这种情况下，等价递归定义允许我们得出 $S <: T$，但 Amber 规则不允许。

---

## 21.12 注释（Notes）

本章基于 Gapeyev、Levin 和 Pierce（2000）的教程文章。

**参考文献：**

- **关于余归纳的背景知识：**

  - Barwise 和 Moss 的《Vicious Circles》（1996）
  - Gordon 关于余归纳和函数式编程的教程（1995）
  - Milner 和 Tofte 关于编程语言语义中余归纳的文章（1991a）

- **关于单调函数和不动点的基本信息：**

  - Aczel（1977）
  - Davey 和 Priestley（1990）

- **计算机科学中使用余归纳证明方法：**

  - Milner（1980）
  - Park（1981）
  - Arbib 和 Manes（1975）
  - Aczel 关于非良基集的书（1988）

- **Amadio 和 Cardelli（1993）** 给出了递归类型的第一个子类型算法。

- **Brandt 和 Henglein（1997）** 提供了子类型关系的归纳公理化。

- **Kozen、Palsberg 和 Schwartzbach（1993）** 使用自动机获得了一个二次复杂度的子类型算法。

- **Hosoya、Vouillon 和 Pierce（2001）** 在 XML 处理应用中使用了基于自动机的子类型算法。

- **Jim 和 Palsberg（1999）** 研究了具有子类型和递归类型的语言的类型重建。

---

**最后的思考：**

如果你思考得足够深入，你会发现这是显而易见的。

---

**[按照您的要求，我逐条详解了内容，解答了练习，并尽量帮助理解。同时，避免使用重音符，而是使用单美元符号包裹特殊字符和关键字，并且不在美元符号和内容之间留空格。]**

### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------
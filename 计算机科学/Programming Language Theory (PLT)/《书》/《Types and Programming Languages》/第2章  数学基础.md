[toc]



### 2 数学预备知识 (Mathematical Preliminaries)

在深入讲解之前，我们需要建立一些常用的符号和基本的数学概念。大多数读者可以快速浏览此章节，并在需要时返回参考。

### 2.1 集合、关系与函数 (Sets, Relations, and Functions)

#### 2.1.1 定义: 集合的符号 (Notation for Sets)

我们使用标准的集合符号：
- 使用花括号表示集合的元素，例如 $ \{...\} $。
- **构造法**(Comprehension)用于从一个集合构造另一个集合，例如 $ \{x \in S \mid ... \} $，表示从集合 $S$ 中选择满足条件的元素。
- 使用符号 $ \emptyset $ 表示**空集**(Empty Set)。
- 集合 $S$ 和 $T$ 的**差集**(Set Difference)写作 $S \setminus T$，表示 $S$ 中的元素不属于 $T$。
- 集合 $S$ 的大小（即元素的个数）写作 $|S|$。
- 集合 $S$ 的**幂集**(Powerset)，即 $S$ 的所有子集的集合，写作 $P(S)$。

#### 2.1.2 定义: 自然数和可数性 (Natural Numbers and Countability)

**自然数集**(Set of Natural Numbers) $ \{0, 1, 2, 3, 4, 5, \dots\} $ 用符号 $ \mathbb{N} $ 表示。  
一个集合被称为**可数**(Countable)，当它的元素可以与自然数集 $ \mathbb{N} $ 形成一一对应的关系时。

#### 2.1.3 定义: 多元关系 (N-place Relations)

给定集合 $S_1, S_2, ..., S_n$，一个 $n$ 元关系 (n-place relation) 是一个**集合** $R \subseteq S_1 \times S_2 \times ... \times S_n$，其元素是来自 $S_1$ 到 $S_n$ 的元组。我们说 $s_1 \in S_1, ..., s_n \in S_n$ 通过关系 $R$ 相关联，若 $ (s_1, ..., s_n) \in R$。

#### 2.1.4 定义: 谓词 (Predicates)

一个集合 $S$ 上的**一元关系**(One-place Relation) 称为 $S$ 上的**谓词**(Predicate)。如果 $s \in S$ 且 $s \in P$，我们说 $P$ 对 $s$ 为真。为强调这一直观理解，我们经常写作 $P(s)$ 而不是 $s \in P$，并将 $P$ 视为一个将 $S$ 中的元素映射到真值的函数。

#### 2.1.5 定义: 二元关系 (Binary Relations)

集合 $S$ 和 $T$ 上的**二元关系**(Binary Relation) 称为 $R$，我们经常写作 $s \ R \ t$，而不是 $(s, t) \in R$。当 $S$ 和 $T$ 是相同的集合 $U$ 时，我们称 $R$ 是 $U$ 上的二元关系。

#### 2.1.6 定义: 混合符号语法 (Mixfix Concrete Syntax)

为了可读性，对于三元或多元关系，我们通常使用“混合符号语法” (Mixfix Concrete Syntax)。例如，在第九章中**简单类型λ演算** (Simply Typed Lambda-calculus) 的**类型关系**(Typing Relation) 使用 $\Gamma \vdash s : T$ 来表示“ $ (\Gamma, s, T) $ 是类型关系中的三元组”。

#### 2.1.7 定义: 关系的定义域和值域 (Domain and Range of Relations)

集合 $S$ 和 $T$ 上关系 $R$ 的**定义域**(Domain) 记作 $dom(R)$，表示 $S$ 中的元素 $s$ 使得存在 $t$ 满足 $ (s, t) \in R$。  
$R$ 的**值域**(Range) 记作 $range(R)$，表示 $T$ 中的元素 $t$ 使得存在 $s$ 满足 $ (s, t) \in R$。

#### 2.1.8 定义: 部分函数与全函数 (Partial and Total Functions)

集合 $S$ 到 $T$ 上的关系 $R$ 被称为 $S$ 到 $T$ 的**部分函数**(Partial Function)，如果对于每个 $s \in S$，若 $ (s, t_1) \in R $ 且 $ (s, t_2) \in R $，则 $ t_1 = t_2 $。  
如果进一步满足 $dom(R) = S$，则称 $R$ 是 $S$ 到 $T$ 的**全函数**(Total Function)。

#### 2.1.9 定义: 未定义与失败 (Undefinedness and Failure)

若部分函数 $R$ 在 $s \in S$ 上定义，即 $s \in dom(R)$，则称 $f(s) \downarrow$，否则称 $f(s) \uparrow$。  
在某些实现章节中，我们还会定义在某些输入上可能失败的函数。我们用 $f(x) = fail$ 表示函数 $f$ 在输入 $x$ 上返回失败结果。  
正式地，一个可能失败的函数从集合 $S$ 到 $T$，可以看作是从 $S$ 到 $T \cup \{fail\}$ 的函数。

#### 2.1.10 定义: 保持谓词的关系 (Preserving Predicates in Relations)

设 $R$ 是集合 $S$ 上的二元关系，$P$ 是 $S$ 上的谓词。若对于所有 $s, s' \in S$，若 $s R s'$ 并且 $P(s)$ 为真，则 $P(s')$ 也为真，则称谓词 $P$ 被关系 $R$ **保持**(Preserved)。

---

以上是集合、关系和函数的基础定义。接下来，如果你有进一步需要解释的内容，欢迎继续提问！

### ---------------------------

### 2.2 有序集合 (Ordered Sets)

#### 2.2.1 定义: 关系的基本性质 (Basic Properties of Relations)

在集合 $S$ 上的**二元关系** $R$ 有如下几种基本性质：

- **自反性**(Reflexive): 如果对于集合 $S$ 中的每个元素 $s$，都有 $s \ R \ s$（或 $ (s, s) \in R $），则关系 $R$ 是自反的。
- **对称性**(Symmetric): 如果 $s \ R \ t$ 意味着 $t \ R \ s$，对于 $S$ 中的所有 $s$ 和 $t$，则关系 $R$ 是对称的。
- **传递性**(Transitive): 如果 $s \ R \ t$ 且 $t \ R \ u$ 意味着 $s \ R \ u$，则关系 $R$ 是传递的。
- **反对称性**(Antisymmetric): 如果 $s \ R \ t$ 且 $t \ R \ s$ 意味着 $s = t$，则关系 $R$ 是反对称的。

#### 2.2.2 定义: 预序与偏序 (Preorders and Partial Orders)

- **预序**(Preorder): 在集合 $S$ 上，若关系 $R$ 是自反的且传递的，则称 $R$ 是 $S$ 上的预序。预序常用符号 $ \leq $ 或 $ \sqsubseteq $ 表示。我们写作 $s < t$ 表示 $s \leq t$ 且 $s \neq t$。
- **偏序**(Partial Order): 在 $S$ 上的预序若同时具有反对称性，则称为**偏序**。如果偏序 $ \leq $ 对 $S$ 中的任意元素 $s$ 和 $t$ 都有 $s \leq t$ 或 $t \leq s$，则称 $ \leq $ 是**全序**(Total Order)。

#### 2.2.3 定义: 上确界与下确界 (Joins and Meets)

设 $ \leq $ 是集合 $S$ 上的偏序，$s$ 和 $t$ 是 $S$ 中的元素。

- 元素 $j \in S$ 被称为 $s$ 和 $t$ 的**上确界**(Join)或**最小上界**(Least Upper Bound)，如果：
  1. $s \leq j$ 且 $t \leq j$；
  2. 对于任意 $k \in S$，若 $s \leq k$ 且 $t \leq k$，则有 $j \leq k$。
  
- 元素 $m \in S$ 被称为 $s$ 和 $t$ 的**下确界**(Meet)或**最大下界**(Greatest Lower Bound)，如果：
  1. $m \leq s$ 且 $m \leq t$；
  2. 对于任意 $n \in S$，若 $n \leq s$ 且 $n \leq t$，则有 $n \leq m$。

#### 2.2.4 定义: 等价关系 (Equivalence Relations)

一个集合 $S$ 上的关系 $R$ 如果是**自反**(Reflexive)、**传递**(Transitive)且**对称**(Symmetric)的，则称为 $S$ 上的**等价关系**(Equivalence Relation)。

#### 2.2.5 定义: 闭包 (Closures)

设 $R$ 是集合 $S$ 上的二元关系。

- $R$ 的**自反闭包**(Reflexive Closure) 是包含 $R$ 的最小自反关系 $R_0$，即对于任意包含 $R$ 的其他自反关系 $R_{00}$，有 $R_0 \subseteq R_{00}$。
- $R$ 的**传递闭包**(Transitive Closure) 是包含 $R$ 的最小传递关系 $R_+$。
- $R$ 的**自反传递闭包**(Reflexive and Transitive Closure) 是包含 $R$ 的最小自反且传递的关系，记作 $R^*$。

#### 2.2.6 练习: 自反闭包 (Reflexive Closure)

假设给定集合 $S$ 上的关系 $R$，定义关系 $R_0$ 如下：
$$
R_0 = R \cup \{(s, s) \mid s \in S \}
$$
也就是说，$R_0$ 包含 $R$ 中的所有元素以及形如 $ (s, s) $ 的所有对。证明 $R_0$ 是 $R$ 的自反闭包。

#### 2.2.7 练习: 传递闭包 (Transitive Closure)

更为构造性地定义 $R$ 的**传递闭包**。我们首先定义一系列的集合 $R_0, R_1, R_2, \dots$：
- $R_0 = R$；
- $R_{i+1} = R_i \cup \{(s, u) \mid \exists t, (s, t) \in R_i \ \text{且} \ (t, u) \in R_i\}$。

也就是说，$R_{i+1}$ 是通过将从 $R_i$ 中现有的配对通过一步传递性规则得到的新的配对添加到 $R_i$ 中构造的。最后，定义关系 $R_+ $ 为所有 $R_i$ 的并集：
$$
R_+ = \bigcup_i R_i
$$
证明 $R_+ $ 确实是 $R$ 的传递闭包。

#### 2.2.8 练习: 保持性 (Preservation)

假设 $R$ 是集合 $S$ 上的二元关系，$P$ 是 $S$ 上的谓词，并且 $P$ 被 $R$ **保持**(Preserved)。证明 $P$ 也被 $R^*$（即 $R$ 的自反传递闭包）保持。

#### 2.2.9 定义: 递减链 (Decreasing Chains)

假设 $ \leq $ 是集合 $S$ 上的预序。一个**递减链**(Decreasing Chain) 是 $S$ 中的元素序列 $s_1, s_2, s_3, \dots$，其中每个序列成员严格小于其前一个成员，即对于每个 $i$，都有 $s_{i+1} < s_i$。递减链可以是有限的或无限的，但我们主要关心的是无限的递减链。

#### 2.2.10 定义: 良基序 (Well-founded Orders)

假设 $ \leq $ 是集合 $S$ 上的预序。如果 $ \leq $ 中不包含**无限递减链**(Infinite Decreasing Chains)，则称 $ \leq $ 是**良基的**(Well-founded)。例如，普通的自然数顺序 $0 < 1 < 2 < 3 < \dots$ 是良基的，但整数上的同样顺序 $ \dots < -3 < -2 < -1 < 0 < 1 < 2 < 3 < \dots$ 则不是。我们有时省略提及 $ \leq $ 并直接称 $S$ 为**良基集合**(Well-founded Set)。

---

以上是第 2.2 节有关有序集合的所有定义、性质和练习的详细解释。如果你有更多问题或需要进一步的解释，欢迎继续提问！

### ----------------------------

### 2.3 序列 (Sequences)

#### 2.3.1 定义: 序列的表示与操作

- **序列**(Sequence) 是通过列出其元素并用逗号分隔的方式书写。例如，一个序列可以写作 $a_1, a_2, a_3, \dots$。  
- 在序列的操作中，**逗号**既用于表示**连接**(Cons Operation)，即将元素添加到序列的任一端，也用于表示**拼接**(Append Operation)，即将两个序列合并。

##### 例子：
- 设 $a = 3, 2, 1$ 和 $b = 5, 6$，则：
  - $0, a$ 表示序列 $0, 3, 2, 1$，即在序列 $a$ 的前端添加元素 $0$。
  - $a, 0$ 表示序列 $3, 2, 1, 0$，即在序列 $a$ 的末端添加元素 $0$。
  - $b, a$ 表示序列 $5, 6, 3, 2, 1$，即将序列 $b$ 和 $a$ 拼接。

在讨论序列时，使用逗号同时表示“连接”和“拼接”操作是不会引起混淆的，只要我们不涉及**序列的序列**(Sequences of Sequences)。

- 数字 $1$ 到 $n$ 的序列可以简写为 $1..n$，例如 $1..3$ 表示序列 $1, 2, 3$。
- 序列 $a$ 的**长度**(Length) 写作 $|a|$。例如，序列 $3, 2, 1$ 的长度为 $3$。
- **空序列**(Empty Sequence) 可以写作 $•$ 或留空表示。
- 一个序列是另一个序列的**置换**(Permutation)，如果它包含完全相同的元素，只是顺序可能不同。

### 2.4 归纳法 (Induction)

在编程语言理论中，**归纳法证明**(Proofs by Induction) 随处可见，就像在大部分计算机科学领域一样。很多这样的证明都基于以下几个原则。

#### 2.4.1 公理: 自然数上的普通归纳原理 (Principle of Ordinary Induction on Natural Numbers)

假设 $P$ 是自然数上的一个**谓词**(Predicate)，则归纳原理如下：

- 如果 $P(0)$ 为真，并且对于所有 $i$，$P(i)$ 为真意味着 $P(i + 1)$ 也为真，那么 $P(n)$ 对于所有自然数 $n$ 都成立。

这个原理对应于通常的**自然数归纳法**(Mathematical Induction)，它说明了如何通过验证基本情况和归纳步来证明一个命题对所有自然数成立。

#### 2.4.2 公理: 自然数上的完全归纳原理 (Principle of Complete Induction on Natural Numbers)

假设 $P$ 是自然数上的一个谓词，则**完全归纳原理**如下：

- 如果对于每个自然数 $n$，假设 $P(i)$ 对所有 $i < n$ 都为真，我们可以证明 $P(n)$，那么 $P(n)$ 对所有自然数 $n$ 都成立。

完全归纳原理是普通归纳原理的一个推广。在普通归纳中，我们只需要依赖前一个自然数的性质，而在完全归纳中，我们可以依赖所有小于 $n$ 的自然数的性质。

#### 2.4.3 定义: 字典序 (Lexicographic Order)

**字典序**(Lexicographic Order)（也称为**词典顺序**）定义如下：对于自然数对 $(m, n)$ 和 $(m', n')$，当且仅当 $m < m'$ 或 $m = m'$ 且 $n \leq n'$ 时，$(m, n) \leq (m', n')$。

字典序常用于将多个比较条件结合起来，例如比较两个字符串或自然数对。

#### 2.4.4 公理: 字典序归纳原理 (Principle of Lexicographic Induction)

假设 $P$ 是自然数对上的一个谓词，则**字典序归纳原理**如下：

- 如果对于每个自然数对 $(m, n)$，假设对于所有 $(m', n') < (m, n)$，$P(m', n')$ 为真，我们可以证明 $P(m, n)$，那么 $P(m, n)$ 对所有自然数对 $(m, n)$ 都成立。

**字典序归纳原理**用于嵌套归纳证明(Proofs by Nested Induction)，即在归纳证明中引入**内部归纳**(Inner Induction)步骤。  
它可以推广到三元组、四元组甚至更多元组的字典序归纳。

#### 结构归纳法 (Structural Induction)

在第 3 章的定理 3.3.4 中，我们将介绍另一种**归纳证明**的形式，称为**结构归纳法**(Structural Induction)。结构归纳法对于证明树结构（例如项或类型推导）的性质特别有用。

在第 21 章中，我们将更详细地探讨归纳推理的数学基础，并看到所有这些特定的归纳原则其实都是一个更深刻的思想的实例。

### 2.5 背景读物 (Background Reading)

如果本章中总结的内容对你来说不熟悉，可以从一些背景材料开始阅读。关于归纳法的直观解释，**Winskel** 的书(1993) 是一个特别好的选择。**Davey 和 Priestley** (1990) 的书在开篇部分有对有序集合的优秀回顾。**Halmos** (1987) 是介绍基本集合论的一个很好的入门书籍。

---

**详解总结：**

1. **序列**是用逗号分隔的元素组成的，逗号操作可以表示连接和拼接操作。
2. **自然数归纳法**和**完全归纳法**是两种不同的归纳原理，分别依赖于前一个自然数或所有小于当前数的自然数的性质。
3. **字典序**用于自然数对的比较，可以推广到多元组。
4. **字典序归纳原理**是嵌套归纳的基础，并可以推广到多元组。
5. **结构归纳法**是特别适用于树状结构证明的归纳形式。

如果你有需要进一步详解的内容，请继续提供问题！

### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------
[toc]



### 第6章 无名项的表示 (Nameless Representation of Terms)

#### 6.1 项和上下文 (Terms and Contexts)

在上一章中，我们采用了“**按绑定变量重命名等价**”的方式来处理Lambda项。这意味着绑定变量的名字可以在任何时候被重命名，以便于替换操作或为了其他方便的原因。这样，我们可以根据需要随意更改绑定变量的名称。这种方法在讨论基本概念和证明时非常有效，但在实际实现中，我们需要为每个项选择一种唯一的表示，特别是需要决定如何表示变量的出现。

---

为此，我们需要一种方法，使得变量的出现直接指向它们的绑定者，而不是依赖于变量的名称。这就是 **Nicolas de Bruijn** 在1972年提出的著名技术，称为 **de Bruijn 指数**。

**de Bruijn 的思想：**

- **核心概念**：使用自然数来替代变量名，其中数字 $k$ 表示“由第 $k$ 个封闭的 $\lambda$ 绑定的变量”。
- **示例**：
  - 普通的项 $\lambda x.\ x$ 对应的无名项表示为 $\lambda.\ 0$。
  - 项 $\lambda x.\ \lambda y.\ x\ (\ y\ x\ )$ 对应的无名项表示为 $\lambda.\ \lambda.\ 1\ (0\ 1)$。
- **术语**：
  - **无名项 (Nameless Terms)**：使用 de Bruijn 指数的Lambda项。
  - **de Bruijn 指数**：项中的数值变量，表示绑定的层次关系。

**注意**：编译器设计者有时将这种概念称为“**静态距离 (Static Distances)**”。

---

#### **习题 6.1.1 [«]：将以下组合子写成对应的无名项。**

给定以下组合子：

1. $c_0 = \lambda s.\ \lambda z.\ z$；
2. $c_2 = \lambda s.\ \lambda z.\ s\ (s\ z)$；
3. $\text{plus} = \lambda m.\ \lambda n.\ \lambda s.\ \lambda z.\ m\ s\ (\ n\ z\ s\ )$；
4. $\text{fix} = \lambda f.\ (\lambda x.\ f\ (\lambda y.\ (x\ x)\ y\ ))\ (\lambda x.\ f\ (\lambda y.\ (x\ x)\ y\ ))$；
5. $\text{foo} = (\lambda x.\ (\lambda x.\ x))\ (\lambda x.\ x)$。

**解答：**

1. **$c_0 = \lambda s.\ \lambda z.\ z$**

   - 第一个 $\lambda s$：引入一个绑定，深度增加1。
   - 第二个 $\lambda z$：再引入一个绑定，深度增加1。
   - 在 $\lambda z$ 的作用域内，只有一个变量 $z$，对应于最新的绑定，索引为 $0$。

   **无名项表示**：$\lambda.\ \lambda.\ 0$

2. **$c_2 = \lambda s.\ \lambda z.\ s\ (s\ z)$**

   - 两个绑定，与上一个相同。
   - 在 $\lambda z$ 的作用域内：
     - $s$：对应于第二个绑定的变量，索引为 $1$。
     - $z$：对应于最新的绑定，索引为 $0$。
     - 所以，$s\ (s\ z)$ 表示为 $1\ (1\ 0)$。

   **无名项表示**：$\lambda.\ \lambda.\ 1\ (1\ 0)$

3. **$\text{plus} = \lambda m.\ \lambda n.\ \lambda s.\ \lambda z.\ m\ s\ (\ n\ z\ s\ )$**

   - 共有四个绑定，依次为 $m$、$n$、$s$、$z$。
   - 在 $\lambda z$ 的作用域内：
     - $m$：索引为 $3$。
     - $n$：索引为 $2$。
     - $s$：索引为 $1$。
     - $z$：索引为 $0$。
     - 表达式 $m\ s\ (\ n\ z\ s\ )$ 对应于 $3\ 1\ (\ 2\ 0\ 1\ )$。

   **无名项表示**：$\lambda.\ \lambda.\ \lambda.\ \lambda.\ 3\ 1\ (\ 2\ 0\ 1\ )$

4. **$\text{fix} = \lambda f.\ (\lambda x.\ f\ (\lambda y.\ (x\ x)\ y\ ))\ (\lambda x.\ f\ (\lambda y.\ (x\ x)\ y\ ))$**

   - 最外层 $\lambda f$：引入绑定，深度为1。
   - 考虑内部的结构：
     - 第一个 $\lambda x$：索引为 $0$（因为进入了新的 $\lambda$）。
     - 在 $\lambda y$ 的作用域内：
       - $x$：索引为 $1$（从内到外，$y$ 的外层是 $x$）。
       - $f$：索引为 $2$（最外层的 $\lambda f$）。
     - 整个结构重复两次。

   **无名项表示**：

   $$
   \lambda.\ (\lambda.\ 2\ (\lambda.\ (\ 1\ 1\ )\ 0\ ))\ (\lambda.\ 2\ (\lambda.\ (\ 1\ 1\ )\ 0\ ))
   $$

5. **$\text{foo} = (\lambda x.\ (\lambda x.\ x))\ (\lambda x.\ x)$**

   - 外层的 $\lambda x$，内部又有一个 $\lambda x$。
   - 第一个 $\lambda x$ 内的 $\lambda x$，其 $x$ 索引为 $0$。
   - 外层 $\lambda x$ 内部的 $x$ 索引为 $1$。

   **无名项表示**：

   $$
   (\lambda.\ (\lambda.\ 0))\ (\lambda.\ 0)
   $$

---

#### **正式定义无名项的语法**

无名项的语法与普通项的语法几乎完全相同，唯一的区别是我们需要仔细跟踪每个项可能包含的自由变量数量。

**6.1.2 定义 [项 (Terms)]：**

- **T** 是由集合 $\{ T_0, T_1, T_2, \dots \}$ 组成的最小族，其中：
  1. 对于 $0 \leq k < n$，$k \in T_n$；
  2. 如果 $t_1 \in T_n$ 且 $n > 0$，那么 $\lambda.\ t_1 \in T_{n-1}$；
  3. 如果 $t_1 \in T_n$ 且 $t_2 \in T_n$，那么 $(t_1\ t_2) \in T_n$。

**解释：**

- **$T_n$**：表示最多包含 $n$ 个自由变量的项集合。
- **变量索引范围**：自由变量的索引从 $0$ 到 $n-1$。
- **封闭项 (Closed Terms)**：如果一个项没有自由变量（即闭项），那么它属于所有的 $T_n$。

**重要性质：**

- 每个（闭的）普通项都有唯一的 de Bruijn 表示。
- 如果两个普通项在绑定变量重命名下等价，那么它们的 de Bruijn 表示也相同。

---

#### **处理含有自由变量的项**

当处理含有自由变量的项时，我们需要引入**命名上下文 (Naming Context)** 的概念。

**示例：**

- 要表示 $\lambda x.\ y\ x$ 作为无名项。
  - $x$ 是绑定变量，可以处理。
  - $y$ 是自由变量，没有绑定，我们需要知道它在上下文中的位置。
  

**解决方案：**

- 定义一个命名上下文 $\Gamma$，为自由变量指定 de Bruijn 指数。

**6.1.3 定义 [命名上下文]：**

- 设 $x_0, x_1, \dots, x_n$ 是变量名。
- 命名上下文 $\Gamma = x_n, x_{n-1}, \dots, x_0$，将 de Bruijn 指数 $i$ 分配给每个 $x_i$。
- **注意**：序列中最右边的变量分配索引 $0$。

**示例：**

- 给定上下文 $\Gamma = x, y, z, a, b$，对应的索引为：

  $$
  \begin{align*}
  x &\mapsto 4 \\
  y &\mapsto 3 \\
  z &\mapsto 2 \\
  a &\mapsto 1 \\
  b &\mapsto 0
  \end{align*}
  $$

- 在这个上下文下：

  - $x\ (y\ z)$ 表示为 $4\ (3\ 2)$。
  - $\lambda w.\ y\ w$ 表示为 $\lambda.\ 4\ 0$。
  - $\lambda w.\ \lambda a.\ x$ 表示为 $\lambda.\ \lambda.\ 6$。

---

#### **习题 6.1.4 [««« 3]：以类似于定义 3.2.3 的方式，给出 $n$ 项集合的另一种构造，并证明它与上述定义等价。**

**解答：**

**提示：**

- 定义 3.2.3 是关于算术表达式的语法定义，这里需要以类似的方式构造 $n$ 项集合。
- 需要证明新构造的集合与之前的定义产生相同的项。

**构造：**

- **基础情况**：
  - **变量**：对于每个 $0 \leq k < n$，$k$ 是 $n$ 项。
- **归纳步骤**：
  - 如果 $t \in T_{n-1}$，那么 $\lambda.\ t \in T_n$。
  - 如果 $t_1, t_2 \in T_n$，那么 $(t_1\ t_2) \in T_n$。

**证明等价性：**

- **与原定义的区别**：
  - 原定义在构造 $\lambda.\ t$ 时，$t \in T_n$，结果在 $T_{n-1}$。
  - 新的构造中，$\lambda.\ t$ 从 $T_{n-1}$ 到 $T_n$。
- **调整新构造**：
  - 修改新构造，使得如果 $t \in T_n$，则 $\lambda.\ t \in T_{n-1}$。
- **证明**：
  - 通过数学归纳法，证明两种定义生成的项集合相同。

---

#### **习题 6.1.5 [推荐, «««]：**

1. **定义函数 $\text{removenames}_\Gamma(t)$**，它接受一个命名上下文 $\Gamma$ 和一个普通项 $t$（其中 $FV(t) \subseteq \text{dom}(\Gamma)$），并产生对应的无名项。
2. **定义函数 $\text{restorenames}_\Gamma(t)$**，它接受一个无名项 $t$ 和命名上下文 $\Gamma$，并生成一个普通项。

**要求：**

- 这两个函数应该满足：
  - 对于任何无名项 $t$，有 $\text{removenames}_\Gamma(\text{restorenames}_\Gamma(t)) = t$。
  - 对于任何普通项 $t$，有 $\text{restorenames}_\Gamma(\text{removenames}_\Gamma(t)) = t$，在绑定变量重命名的意义下。

**解答：**

1. **定义 $\text{removenames}_\Gamma(t)$：**

   - **输入**：命名上下文 $\Gamma$，普通项 $t$。
   - **过程**：
     - 对于变量：
       - 如果变量 $x$ 是自由变量，在 $\Gamma$ 中查找其索引 $i$，替换为 $i$。
     - 对于抽象 $\lambda x.\ t_1$：
       - 增加上下文 $\Gamma' = x, \Gamma$（将 $x$ 添加到 $\Gamma$ 的左边）。
       - 递归调用 $\text{removenames}_{\Gamma'}(t_1)$。
       - 结果为 $\lambda.\ t_1'$。
     - 对于应用 $t_1\ t_2$：
       - 分别递归调用 $\text{removenames}_\Gamma(t_1)$ 和 $\text{removenames}_\Gamma(t_2)$。
       - 结果为 $t_1'\ t_2'$。

2. **定义 $\text{restorenames}_\Gamma(t)$：**

   - **输入**：无名项 $t$，命名上下文 $\Gamma$。
   - **过程**：
     - 对于索引 $k$：
       - 如果 $k < |\Gamma|$，从 $\Gamma$ 中获取索引为 $k$ 的变量名 $x$。
       - 如果 $k \geq |\Gamma|$，表示需要生成新的绑定变量名。
     - 对于抽象 $\lambda.\ t_1$：
       - 选择一个不在 $\Gamma$ 中的变量名 $x$。
       - 增加上下文 $\Gamma' = x, \Gamma$。
       - 递归调用 $\text{restorenames}_{\Gamma'}(t_1)$。
       - 结果为 $\lambda x.\ t_1'$。
     - 对于应用 $t_1\ t_2$：
       - 分别递归调用 $\text{restorenames}_\Gamma(t_1)$ 和 $\text{restorenames}_\Gamma(t_2)$。
       - 结果为 $t_1'\ t_2'$。

**验证性质：**

- **对于无名项 $t$**：

  - 计算 $\text{removenames}_\Gamma(\text{restorenames}_\Gamma(t))$。
  - 由于 $\text{restorenames}_\Gamma(t)$ 恢复了原始的变量名，重新移除名字后，应得到原始的无名项 $t$。

- **对于普通项 $t$**：

  - 计算 $\text{restorenames}_\Gamma(\text{removenames}_\Gamma(t))$。
  - 由于可能存在绑定变量的重命名，结果在绑定变量重命名的意义下等价于 $t$。

---

#### **关于术语的注释**

- **严格来说**，我们不能简单地说“某个 $t \in T$”，因为我们需要指定 $t$ 可能具有的自由变量的数量。
- **实践中**，我们通常会有一个固定的命名上下文 $\Gamma$，然后稍微滥用符号，写 $t \in T$，意思是 $t \in T_n$，其中 $n$ 是 $\Gamma$ 的长度。

---

#### 6.2 **移位和替换 (Shifting and Substitution)**

我们的下一个任务是定义无名项上的替换操作 $[k \mapsto s]t$。为此，我们需要一个辅助操作，称为**移位 (Shifting)**，它重新编号项中自由变量的索引。

---

**移位的必要性：**

- 当替换深入到 $\lambda$ 抽象中时，例如 $[1 \mapsto s](\lambda.\ 2)$，替换发生的上下文比原来的多了一个变量，我们需要调整 $s$ 中自由变量的索引，以确保它们在新上下文中仍然引用相同的变量。
- 需要小心的是，不能简单地将 $s$ 中的每个变量索引都加一，因为这可能会错误地影响 $s$ 中的绑定变量。

---

**6.2.1 定义 [移位 (Shifting)]：**

- **$\uparrow^d_c(t)$** 表示对项 $t$ 进行从 **截断值 (cutoff)** $c$ 开始的 $d$ 次移位。

- **规则：**

  1. **变量：**

     $$
     \uparrow^d_c(k) =
     \begin{cases}
     k, & \text{如果 } k < c \\
     k + d, & \text{如果 } k \geq c
     \end{cases}
     $$

  2. **抽象：**

     $$
     \uparrow^d_c(\lambda.\ t_1) = \lambda.\ \uparrow^d_{c+1}(t_1)
     $$

  3. **应用：**

     $$
     \uparrow^d_c(t_1\ t_2) = \uparrow^d_c(t_1)\ \uparrow^d_c(t_2)
     $$

- **简化表示：**

  - 当 $c = 0$ 时，记作 $\uparrow^d(t) = \uparrow^d_0(t)$。

**解释：**

- **截断值 $c$**：表示移位操作从哪个层次的绑定开始。
- **d**：表示移位的位数，即索引增加的数量。
- **目的**：确保在替换过程中，$s$ 中的自由变量在新的上下文中引用正确的变量。

---

#### **习题 6.2.2 [«]：**

1. 计算 $\uparrow^2(\lambda.\ \lambda.\ 1\ (0\ 2))$。

   **解答：**

   - 首先，我们有项 $\lambda.\ \lambda.\ 1\ (0\ 2)$。
   - 应用 $\uparrow^2$（即 $\uparrow^2_0$）到整个项。

   **步骤：**

   - 对于最外层的 $\lambda$，进入其主体，截断值 $c$ 增加1。
   - 第二个 $\lambda$，截断值 $c$ 增加1，变为2。
   - 对于变量：
     - 变量 $1$（在截断值 $c=2$ 下）：
       - $1 < 2$，所以保持不变，仍为 $1$。
     - 变量 $0$（同理）：
       - $0 < 2$，保持不变，仍为 $0$。
     - 变量 $2$（$2 \geq 2$）：
       - $2 + 2 = 4$。

   **结果：**

   $$
   \lambda.\ \lambda.\ 1\ (0\ 4)
   $$

2. 计算 $\uparrow^2(\lambda.\ 0\ 1\ (\lambda.\ 0\ 1\ 2))$。

   **解答：**

   **步骤：**

   - 对于最外层的 $\lambda$，截断值 $c = 0 + 1 = 1$。
   - 对于变量 $0$ 和 $1$：
     - $0 < 1$，保持不变。
     - $1 \geq 1$，所以 $1 + 2 = 3$。
   - 对于内部的 $\lambda$，截断值 $c = 1 + 1 = 2$。
     - 变量 $0$：
       - $0 < 2$，保持不变。
     - 变量 $1$：
       - $1 < 2$，保持不变。
     - 变量 $2$：
       - $2 \geq 2$，所以 $2 + 2 = 4$。

   **结果：**

   $$
   \lambda.\ 0\ 3\ (\lambda.\ 0\ 1\ 4)
   $$

---

#### **习题 6.2.3 [«« 3]：证明如果 $t$ 是 $n$ 项，则 $\uparrow^d_c(t)$ 是 $(n + d)$ 项。**

**解答：**

**目标：**

- 证明对于任意 $n$ 项 $t$，$\uparrow^d_c(t)$ 是 $(n + d)$ 项。

**证明思路：**

- **变量情况：**
  - 如果 $k < c$，$\uparrow^d_c(k) = k$，索引不变，项的自由变量数不变。
  - 如果 $k \geq c$，$\uparrow^d_c(k) = k + d$，索引增加 $d$，因此自由变量的最大索引增加了 $d$。

- **抽象情况：**
  - 对于 $\lambda.\ t_1$，$\uparrow^d_c(\lambda.\ t_1) = \lambda.\ \uparrow^d_{c+1}(t_1)$。
  - 进入抽象后，截断值 $c$ 增加 1。
  - 自由变量的数量不受抽象影响，但索引可能增加 $d$。

- **应用情况：**
  - 对于 $t_1\ t_2$，分别对 $t_1$ 和 $t_2$ 应用移位操作。
  - 自由变量的数量取两者的最大值。

**结论：**

- 在移位过程中，自由变量的最大索引增加了 $d$，因此项的自由变量数量增加了 $d$。
- 因此，$\uparrow^d_c(t)$ 是 $(n + d)$ 项。

---

#### **替换操作的定义**

现在，我们准备定义替换操作 $[j \mapsto s]t$。

- **目的**：在项 $t$ 中，用项 $s$ 替换索引为 $j$ 的变量。

**6.2.4 定义 [替换 (Substitution)]：**

- **变量：**

  $$
  [j \mapsto s]k =
  \begin{cases}
  s, & \text{如果 } k = j \\
  k, & \text{否则}
  \end{cases}
  $$

- **抽象：**

  $$
  [j \mapsto s](\lambda.\ t_1) = \lambda.\ [j + 1 \mapsto \uparrow^1(s)]t_1
  $$

- **应用：**

  $$
  [j \mapsto s](t_1\ t_2) = ([j \mapsto s]t_1)\ ([j \mapsto s]t_2)
  $$

**解释：**

- **替换变量 $k$：**
  - 如果 $k$ 等于要替换的索引 $j$，则替换为 $s$。
  - 否则，保持 $k$ 不变。
- **处理抽象时**，需要将替换的索引 $j$ 增加 1，同时将替换项 $s$ 进行一次移位 $\uparrow^1(s)$，以适应新的上下文。

---

#### **习题 6.2.5 [«]：将以下替换操作转换为无名形式，假设全局上下文为 $\Gamma = a, b$，并使用上述定义计算结果。答案是否对应于第5.3节中对普通项的替换定义？**

1. $[b \mapsto a]\ (b\ (\lambda x.\ \lambda y.\ b))$
2. $[b \mapsto a\ (\lambda z.\ a)]\ (b\ (\lambda x.\ b))$
3. $[b \mapsto a]\ (\lambda b.\ b\ a)$
4. $[b \mapsto a]\ (\lambda a.\ b\ a)$

**解答：**

首先，为了将这些替换操作转换为无名形式，我们需要知道上下文中变量的索引。

**上下文 $\Gamma = a, b$：**

- $a \mapsto 1$
- $b \mapsto 0$

---

**问题1：$[b \mapsto a]\ (b\ (\lambda x.\ \lambda y.\ b))$**

**步骤：**

- 将项转换为无名形式：

  - $b$：索引 $0$。
  - $a$：索引 $1$。
  - $\lambda x$ 引入新的绑定，索引计数增加。
  - $\lambda y$ 再次引入绑定。
  - 内部的 $b$：索引 $0$（全局上下文中的 $b$）。

- 无名形式：

  $$
  0\ (\lambda.\ \lambda.\ 2)
  $$

- 替换 $[0 \mapsto 1]$，因为 $b$ 的索引为 $0$，$a$ 的索引为 $1$。

- 应用替换：

  - 对于外层的 $0$（$b$）：

    $$
    [0 \mapsto 1](0) = 1
    $$

  - 对于内部的 $\lambda.\ \lambda.\ 2$：

    - 进入第一个 $\lambda$，替换索引 $j$ 增加 1，$j = 1$，$s$ 移位：$\uparrow^1(1) = 2$。
    - 进入第二个 $\lambda$，$j = 2$，$s$ 移位：$\uparrow^1(2) = 3$。
    - 内部的 $2$（对应全局的 $b$），$[2 \mapsto 3](2) = 3$。

- 替换后的结果：

  $$
  1\ (\lambda.\ \lambda.\ 3)
  $$

**对应的普通项：**

- 恢复变量名：

  - 索引 $1$：$a$。
  - 索引 $3$：由于上下文中只有 $a$ 和 $b$，需要引入新的变量名。

- 因此，替换结果与原定义一致。

---

**问题2：$[b \mapsto a\ (\lambda z.\ a)]\ (b\ (\lambda x.\ b))$**

**步骤：**

- 转换为无名形式：

  - 原项：$0\ (\lambda.\ 1)$

- 替换项 $a\ (\lambda z.\ a)$：

  - 转换为无名形式：

    - $\lambda z.\ a$ 转换为 $\lambda.\ 2$（$a$ 的索引为 $1$，新的绑定增加，索引变为 $2$）。
  - 整个替换项为 $1\ (\lambda.\ 2)$。

- 应用替换 $[0 \mapsto 1\ (\lambda.\ 2)]$：

  - 外层的 $0$ 替换为 $1\ (\lambda.\ 2)$。
  - 内部的 $\lambda.\ 1$，替换索引增加：

    - 进入 $\lambda$，$j = 1$，$s$ 移位：$\uparrow^1(1\ (\lambda.\ 2))$。

- 最终结果：

  $$
  (1\ (\lambda.\ 2))\ (\lambda.\ 1)
  $$

---

**问题3：$[b \mapsto a]\ (\lambda b.\ b\ a)$**

**步骤：**

- 转换为无名形式：

  - 外层 $\lambda b$，新的绑定，$b$ 的索引为 $0$，$a$ 的索引为 $1$。

  $$
  \lambda.\ 0\ 1
  $$

- 应用替换 $[0 \mapsto 1]$：

  - 进入 $\lambda$，替换索引 $j$ 增加 1，$j = 1$，$s$ 移位：$\uparrow^1(1) = 2$。

  - 内部的 $0$（新的 $b$），$[1 \mapsto 2](0) = 0$（$0 \ne j$）。

  - 内部的 $1$（$a$），$[1 \mapsto 2](1) = 1$。

- 替换后的结果：

  $$
  \lambda.\ 0\ 1
  $$

- 结果与原项相同，因为替换的 $b$ 被内部的绑定 $b$ 屏蔽了。

---

**问题4：$[b \mapsto a]\ (\lambda a.\ b\ a)$**

**步骤：**

- 转换为无名形式：

  - 外层 $\lambda a$，新的绑定，$a$ 的索引为 $0$，$b$ 的索引为 $1$。

  $$
  \lambda.\ 1\ 0
  $$

- 应用替换 $[0 \mapsto 1]$：

  - 进入 $\lambda$，替换索引 $j$ 增加 1，$j = 1$，$s$ 移位：$\uparrow^1(1) = 2$。

  - 内部的 $1$（$b$），$[1 \mapsto 2](1) = 2$。

  - 内部的 $0$（新的 $a$），$[1 \mapsto 2](0) = 0$。

- 替换后的结果：

  $$
  \lambda.\ 2\ 0
  $$

**对应的普通项：**

- 恢复变量名：

  - 索引 $2$：需要引入新的变量名，可能为 $c$。
  - 索引 $0$：绑定的 $a$。

- 替换结果与原定义一致。

---

#### **习题 6.2.6 [«« 3]：证明如果 $s$ 和 $t$ 是 $n$ 项且 $j \leq n$，那么 $[j \mapsto s]t$ 是 $n$ 项。**

**解答：**

**目标：**

- 证明替换后得到的项仍然是 $n$ 项。

**证明思路：**

- **变量情况**：

  - 如果替换发生，$s$ 是 $n$ 项，替换后的项不增加自由变量的数量。

- **抽象情况**：

  - 在 $\lambda.\ t_1$ 中，$[j \mapsto s](\lambda.\ t_1) = \lambda.\ [j + 1 \mapsto \uparrow^1(s)]t_1$。

  - $s$ 被移位 $\uparrow^1(s)$，其自由变量的数量增加 1，但由于进入了新的抽象，整体的自由变量数量保持不变。

- **应用情况**：

  - 替换分别在 $t_1$ 和 $t_2$ 中进行，自由变量的最大数量不超过 $n$。

**结论：**

- 替换操作不会增加项的自由变量数量，替换后的项仍然是 $n$ 项。

---

#### **习题 6.2.7 [« 3]：拿一张纸，在不看上述替换和移位定义的情况下，重新推导它们。**

**解答：**

**思路：**

- **移位操作**需要调整项中自由变量的索引，以适应上下文的变化。

- **替换操作**需要在项中用另一个项替换某个变量，同时确保变量索引正确。

**步骤：**

1. **移位 (Shifting)**：

   - 目的：当上下文发生变化（如进入新的 $\lambda$ 抽象）时，调整自由变量的索引。

   - 定义：

     - 对于变量 $k$：

       - 如果 $k < c$（即绑定在截断值 $c$ 之前），则保持不变。

       - 如果 $k \geq c$，则索引增加 $d$。

     - 对于抽象 $\lambda.\ t$，截断值 $c$ 增加 1，递归应用移位。

     - 对于应用 $t_1\ t_2$，分别递归应用移位。

2. **替换 (Substitution)**：

   - 目的：在项中用另一个项替换某个变量。

   - 定义：

     - 对于变量 $k$：

       - 如果 $k = j$，则替换为 $s$。

       - 否则，保持 $k$ 不变。

     - 对于抽象 $\lambda.\ t$：

       - 替换索引 $j$ 增加 1。

       - 替换项 $s$ 进行移位 $\uparrow^1(s)$。

       - 递归应用替换。

     - 对于应用 $t_1\ t_2$，分别递归应用替换。

---

#### **习题 6.2.8 [推荐, «««]：无名项上的替换定义应与我们对普通项的替换定义一致。（1）需要证明什么定理以严格证明这种对应关系？（2）证明它。**

**解答：**

1. **需要证明的定理：**

   - **定理**：对于任何普通项 $t$、替换项 $s$ 和命名上下文 $\Gamma$，都有：

     $$
     \text{removenames}_\Gamma([x \mapsto s]t) = [j \mapsto \text{removenames}_\Gamma(s)]\ (\text{removenames}_\Gamma(t))
     $$

     - 其中，$x$ 在上下文 $\Gamma$ 中对应索引 $j$。

2. **证明：**

   - 使用数学归纳法对项 $t$ 的结构进行证明。

   - **基例**：

     - **变量 $x$**：

       - 如果 $t = x$，则有两种情况：

         - 如果 $x = y$，则 $[x \mapsto s]x = s$。

           - 对应于无名项：$[j \mapsto \text{removenames}_\Gamma(s)]j = \text{removenames}_\Gamma(s)$。

         - 如果 $x \ne y$，则 $[x \mapsto s]y = y$。

           - 对应于无名项：$[j \mapsto \text{removenames}_\Gamma(s)]k = k$（$k \ne j$）。

   - **归纳步骤**：

     - **抽象 $\lambda y.\ t_1$**：

       - 有 $[x \mapsto s](\lambda y.\ t_1) = \lambda y.\ [x \mapsto s]t_1$，当 $y \ne x$ 且 $y \notin FV(s)$。

       - 对应的无名项：

         - $\text{removenames}_\Gamma(\lambda y.\ t_1) = \lambda.\ \text{removenames}_{\Gamma'}(t_1)$，其中 $\Gamma' = y, \Gamma$。

         - 替换索引 $j$ 增加 1，替换项移位 $\uparrow^1(\text{removenames}_\Gamma(s))$。

       - 根据归纳假设，替换在 $t_1$ 中保持一致。

     - **应用 $t_1\ t_2$**：

       - 有 $[x \mapsto s](t_1\ t_2) = [x \mapsto s]t_1\ [x \mapsto s]t_2$。

       - 对应的无名项也是分别替换。

   - **结论**：

     - 通过归纳，证明替换操作在普通项和无名项之间保持一致。

---

### 6.3 **求值 (Evaluation)**

为了在无名项上定义求值关系，我们需要修改的是 beta-约简规则，因为它是涉及变量名的地方。

---

**关键点：**

- 在约简 redex（可约项）时，绑定变量被“消耗”掉，即在替换后，绑定变量不再存在。
- 因此，我们需要调整替换结果中的变量索引，考虑到上下文的变化。

**示例：**

- 考虑项：

  $$
  (\lambda.\ 1\ 0\ 2)\ (\lambda.\ 0) \longrightarrow 0\ (\lambda.\ 0)\ 1
  $$

  - 注意，我们需要在替换后对结果进行负移位 $\uparrow^{-1}$。

---

**修正后的 beta-约简规则：**

- **规则 E-AppAbs：**

  $$
  (\lambda.\ t_{12})\ v_2 \longrightarrow \uparrow^{-1}([0 \mapsto \uparrow^1(v_2)]t_{12})
  $$

  - 在替换后，对结果进行一次负移位，以调整变量索引。

---

#### **习题 6.3.1 [«]：我们是否需要担心该规则中的负移位可能会产生包含负索引的不良格式的项？**

**解答：**

- **不需要担心**，因为负移位只会减少自由变量的索引，而不会影响绑定变量的索引。
- 在正确的上下文中，变量索引不会变为负值。

---

#### **习题 6.3.2 [«««]：de Bruijn 的原始文章实际上包含了两种无名项的表示提议：本文介绍的 de Bruijn 指数（从内到外编号 lambda 绑定），以及 de Bruijn 层级（从外到内编号绑定）。例如，项 $\lambda x.\ (\lambda y.\ x\ y)\ x$ 用 de Bruijn 指数表示为 $\lambda.\ (\lambda.\ 1\ 0)\ 0$，用 de Bruijn 层级表示为 $\lambda.\ (\lambda.\ 0\ 1)\ 0$。精确定义这种变体，并证明使用指数和层级表示的项是同构的（即，每个都可以唯一地从另一个恢复）。**

**解答：**

1. **定义 de Bruijn 层级：**

   - **概念**：使用自然数表示变量，其中数字 $k$ 表示“从最外层开始的第 $k$ 个 $\lambda$ 绑定的变量”。
   - **计数方式**：从外到内，最外层的绑定变量索引为 $0$。

2. **示例：**

   - 项 $\lambda x.\ (\lambda y.\ x\ y)\ x$：

     - **de Bruijn 指数**：$\lambda.\ (\lambda.\ 1\ 0)\ 0$

     - **de Bruijn 层级**：$\lambda.\ (\lambda.\ 0\ 1)\ 0$

3. **证明同构性：**

   - **构建映射**：

     - 从 de Bruijn 指数到层级：

       - 层级索引 $k_{level} = n_{binders} - 1 - k_{index}$，其中 $n_{binders}$ 是总的绑定数量。

     - 从层级到指数：

       - 指数索引 $k_{index} = n_{binders} - 1 - k_{level}$。

   - **示例验证**：

     - 对于 $\lambda.\ (\lambda.\ 1\ 0)\ 0$：

       - 总绑定数量 $n_{binders} = 2$。

       - 变量索引转换：

         - $k_{level} = 2 - 1 - k_{index}$

         - $k_{level}(1) = 0$

         - $k_{level}(0) = 1$

       - 得到层级表示 $\lambda.\ (\lambda.\ 0\ 1)\ 0$

   - **结论**：

     - 两种表示之间存在一一对应的关系，可以相互转换。

---

### **总结**

- **无名项表示**：通过使用 de Bruijn 指数，我们消除了变量名，直接使用数字表示变量的绑定关系。
- **移位和替换**：定义了在无名项上进行移位和替换的操作，确保在替换和求值过程中变量索引的正确性。
- **求值规则**：修改了 beta-约简规则，以适应无名项的替换操作，并确保求值过程的正确性。

---

**如果您对上述内容有任何疑问或需要进一步的解释，请随时提问！**

### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------
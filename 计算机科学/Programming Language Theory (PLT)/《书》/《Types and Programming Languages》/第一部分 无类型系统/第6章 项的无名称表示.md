[toc]



### 第6章 无名项的表示 (Nameless Representation of Terms)

#### 6.1 项和上下文 (Terms and Contexts)

在上一章中，我们采用了“**按绑定变量重命名等价**”的方式来处理Lambda项。这意味着绑定变量的名字可以在任何时候被重命名，以便于替换操作或为了其他方便的原因。这样，我们可以根据需要随意更改绑定变量的名称。这种方法在讨论基本概念和证明时非常有效，但在实际实现中，我们需要为每个项选择一种唯一的表示，特别是需要决定如何表示变量的出现。

---

为此，我们需要一种方法，使得变量的出现直接指向它们的绑定者，而不是依赖于变量的名称。这就是 **Nicolas de Bruijn** 在1972年提出的著名技术，称为 **de Bruijn 指数**。

**de Bruijn 的思想：**

- **核心概念**：使用自然数来替代变量名，其中数字 $k$ 表示“由第 $k$ 个封闭的 $\lambda$ 绑定的变量”。
- **示例**：
  - 普通的项 $\lambda x.\ x$ 对应的无名项表示为 $\lambda.\ 0$。
  - 项 $\lambda x.\ \lambda y.\ x\ (\ y\ x\ )$ 对应的无名项表示为 $\lambda.\ \lambda.\ 1\ (0\ 1)$。
- **术语**：
  - **无名项 (Nameless Terms)**：使用 de Bruijn 指数的Lambda项。
  - **de Bruijn 指数**：项中的数值变量，表示绑定的层次关系。

**注意**：编译器设计者有时将这种概念称为“**静态距离 (Static Distances)**”。



### -------------------------------

**普通项**（Named Terms）和**无名项**（Nameless Terms）是两种不同的表达形式，特别是在处理 Lambda 演算等基于函数的表达式时。为了理解它们的区别，我们需要从变量绑定和表达式简化的角度来进行分析。

### **普通项 (Named Terms) vs 无名项 (Nameless Terms) 对比表**

| **角度**         | **普通项 (Named Terms)**                                     | **无名项 (Nameless Terms)**                                  |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **定义**         | 普通项使用**变量名称**（如 $x$, $y$, $z$）来表示自由变量和绑定变量。 | 无名项使用**索引**（通常是 de Bruijn 指数）来表示变量的绑定和作用域。 |
| **变量绑定**     | 变量通过名称绑定，变量的作用域由其命名的 $lambda$ 表达式定义。 | 变量通过整数索引绑定，表示变量到其绑定 $lambda$ 的距离。     |
| **常见形式**     | $lambda\ x.x$ 或 $lambda\ y.(y\ z)$ 等形式，显示变量名称。   | $lambda\ .0$ 或 $lambda\ (lambda\ .1\ 0)$，使用 de Bruijn 索引代替变量名。 |
| **优点**         | 代码易于阅读和理解，变量名清晰反映其含义和作用。             | 避免了变量捕获问题，无需进行 $alpha$ 转换来避免变量名冲突。  |
| **缺点**         | 在变量重命名时，需要使用 $alpha$ 转换来避免变量名冲突。      | 使用索引可能不直观，特别是在表达式嵌套较深时可读性较差。     |
| **应用场景**     | 常用于书写和理解 Lambda 演算等需要清晰变量名的理论和代码。   | 常用于编译器和解释器实现，方便处理变量替换和作用域管理。     |
| **重命名变量**   | 需要通过 $alpha$ 转换进行重命名，避免名称冲突。              | 无需重命名变量，索引天然避免了变量名冲突。                   |
| **典型应用**     | 变量名用于推导、书写和分析，如在数学证明、程序逻辑中。       | 无名项用于实际计算的简化形式，常见于编译器和解释器中的中间表示。 |
| **处理自由变量** | 自由变量使用显式名称，便于跟踪和识别。                       | 自由变量可以使用全局编号或其他方式跟踪。                     |
| **变量捕获问题** | 变量名在替换时可能导致捕获，需要通过 $alpha$ 转换避免。      | 索引形式避免了变量捕获的问题，无需 $alpha$ 转换。            |

### **普通项 (Named Terms)**

**普通项**是我们在书写 Lambda 表达式或其他形式化系统时常用的方式。变量通过名称进行表示，表达式清晰地展示了哪些变量是自由的，哪些是绑定的。常见的例子包括：

- $lambda\ x.x$：表示接收参数 $x$ 并返回 $x$。
- $lambda\ x.(x\ y)$：表示接收参数 $x$ 并返回 $x$ 应用到 $y$ 上，其中 $y$ 是自由变量。

普通项的优势在于它非常直观、易于理解和推导。然而，普通项存在一些问题：
- 变量名冲突：在嵌套表达式中，可能会出现不同作用域中同名变量的情况，这会导致冲突。例如：

  ```plaintext
  (lambda x.(lambda x.x))
  ```

  在这个表达式中，内层的 $x$ 和外层的 $x$ 是不同的。为了避免变量捕获，需要使用 $alpha$ 转换将内层 $x$ 重命名为其他名称。

### **无名项 (Nameless Terms)**

**无名项**采用了不同的策略，通过使用 **de Bruijn 指数** 来消除变量名。每个变量不再通过名称表示，而是通过一个整数来表示它相对于绑定的 $lambda$ 的距离。

#### de Bruijn 指数：

- **定义**：de Bruijn 指数是一种通过整数编号来表示 Lambda 表达式中的变量。编号表示该变量到其绑定的 $lambda$ 的距离。
- **优势**：无名项的形式天然避免了变量捕获问题，无需进行复杂的变量重命名。由于变量是通过整数表示，因此在表达式求值或变量替换时，操作更加简化。

例如：

- **普通项** $lambda\ x.x$ 对应的 **无名项** 是 $lambda\ .0$。这里的 $0$ 表示它是最近的绑定变量（即与当前的 $lambda$ 绑定的变量）。
- **普通项** $lambda\ x.(lambda\ y.x)$ 对应的 **无名项** 是 $lambda\ .(lambda\ .1)$。其中，内层的 $1$ 表示它引用的是外层 $lambda$ 绑定的变量 $x$。

### **变量捕获与 $alpha$ 转换**

- **普通项** 在进行替换时容易出现**变量捕获**问题。例如，在表达式 $lambda\ x.(lambda\ y.x)$ 中，如果我们用 $z$ 替换外层的 $x$，需要确保 $z$ 不会与内部作用域的 $y$ 冲突。这时需要通过 $alpha$ 转换来重命名内部变量。
- **无名项** 则不会有这种问题，因为变量是通过索引表示的，替换时不会涉及到名称重命名。

### **示例对比：普通项 vs 无名项**

#### 1. 普通项

```plaintext
(lambda x. (lambda y. x)) (lambda z. z)
```

这个表达式的含义是将第一个函数 $(lambda x.(lambda y.x))$ 应用到第二个函数 $(lambda z.z)$。

#### 2. 无名项

将上述普通项转换为无名项，结果为：

```plaintext
(lambda . (lambda . 1)) (lambda . 0)
```

在无名项中：
- 第一个 $lambda . (lambda . 1)$ 的 $1$ 表示引用的是外层 $lambda$ 绑定的变量。
- 第二个 $lambda . 0$ 是一个恒等函数，表示返回自己。

### **总结**

- **普通项**：使用变量名称来标识绑定和自由变量，易于理解和书写，但需要处理变量名冲突和变量捕获问题。
- **无名项**：通过索引表示变量，避免了变量捕获和重命名的复杂性，适合编译器和解释器实现。

无名项简化了变量绑定和替换的处理过程，而普通项则更加直观，适合人类阅读和书写。这两种表达形式各有应用场景，理解它们的差异有助于更好地掌握 Lambda 演算及其在编程语言中的应用。

### ------------------------------

---

#### **习题 6.1.1 [«]：将以下组合子写成对应的无名项。**

给定以下组合子：

1. $c_0 = \lambda s.\ \lambda z.\ z$；
2. $c_2 = \lambda s.\ \lambda z.\ s\ (s\ z)$；
3. $\text{plus} = \lambda m.\ \lambda n.\ \lambda s.\ \lambda z.\ m\ s\ (\ n\ z\ s\ )$；
4. $\text{fix} = \lambda f.\ (\lambda x.\ f\ (\lambda y.\ (x\ x)\ y\ ))\ (\lambda x.\ f\ (\lambda y.\ (x\ x)\ y\ ))$；
5. $\text{foo} = (\lambda x.\ (\lambda x.\ x))\ (\lambda x.\ x)$。

**解答：**

1. **$c_0 = \lambda s.\ \lambda z.\ z$**

   - 第一个 $\lambda s$：引入一个绑定，深度增加1。
   - 第二个 $\lambda z$：再引入一个绑定，深度增加1。
   - 在 $\lambda z$ 的作用域内，只有一个变量 $z$，对应于最新的绑定，索引为 $0$。

   **无名项表示**：$\lambda.\ \lambda.\ 0$

2. **$c_2 = \lambda s.\ \lambda z.\ s\ (s\ z)$**

   - 两个绑定，与上一个相同。
   - 在 $\lambda z$ 的作用域内：
     - $s$：对应于第二个绑定的变量，索引为 $1$。
     - $z$：对应于最新的绑定，索引为 $0$。
     - 所以，$s\ (s\ z)$ 表示为 $1\ (1\ 0)$。

   **无名项表示**：$\lambda.\ \lambda.\ 1\ (1\ 0)$

3. **$\text{plus} = \lambda m.\ \lambda n.\ \lambda s.\ \lambda z.\ m\ s\ (\ n\ z\ s\ )$**

   - 共有四个绑定，依次为 $m$、$n$、$s$、$z$。
   - 在 $\lambda z$ 的作用域内：
     - $m$：索引为 $3$。
     - $n$：索引为 $2$。
     - $s$：索引为 $1$。
     - $z$：索引为 $0$。
     - 表达式 $m\ s\ (\ n\ z\ s\ )$ 对应于 $3\ 1\ (\ 2\ 0\ 1\ )$。

   **无名项表示**：$\lambda.\ \lambda.\ \lambda.\ \lambda.\ 3\ 1\ (\ 2\ 0\ 1\ )$

4. **$\text{fix} = \lambda f.\ (\lambda x.\ f\ (\lambda y.\ (x\ x)\ y\ ))\ (\lambda x.\ f\ (\lambda y.\ (x\ x)\ y\ ))$**

   - 最外层 $\lambda f$：引入绑定，深度为1。
   - 考虑内部的结构：
     - 第一个 $\lambda x$：索引为 $0$（因为进入了新的 $\lambda$）。
     - 在 $\lambda y$ 的作用域内：
       - $x$：索引为 $1$（从内到外，$y$ 的外层是 $x$）。
       - $f$：索引为 $2$（最外层的 $\lambda f$）。
     - 整个结构重复两次。

   **无名项表示**：

   $$
   \lambda.\ (\lambda.\ 2\ (\lambda.\ (\ 1\ 1\ )\ 0\ ))\ (\lambda.\ 2\ (\lambda.\ (\ 1\ 1\ )\ 0\ ))
   $$

5. **$\text{foo} = (\lambda x.\ (\lambda x.\ x))\ (\lambda x.\ x)$**

   - 外层的 $\lambda x$，内部又有一个 $\lambda x$。
   - 第一个 $\lambda x$ 内的 $\lambda x$，其 $x$ 索引为 $0$。
   - 外层 $\lambda x$ 内部的 $x$ 索引为 $1$。

   **无名项表示**：

   $$
   (\lambda.\ (\lambda.\ 0))\ (\lambda.\ 0)
   $$

---

#### **正式定义无名项的语法**

无名项的语法与普通项的语法几乎完全相同，唯一的区别是我们需要仔细跟踪每个项可能包含的自由变量数量。

**6.1.2 定义 [项 (Terms)]：**

- **T** 是由集合 $\{ T_0, T_1, T_2, \dots \}$ 组成的最小族，其中：
  1. 对于 $0 \leq k < n$，$k \in T_n$；
  2. 如果 $t_1 \in T_n$ 且 $n > 0$，那么 $\lambda.\ t_1 \in T_{n-1}$；
  3. 如果 $t_1 \in T_n$ 且 $t_2 \in T_n$，那么 $(t_1\ t_2) \in T_n$。

**解释：**

- **$T_n$**：表示最多包含 $n$ 个自由变量的项集合。
- **变量索引范围**：自由变量的索引从 $0$ 到 $n-1$。
- **封闭项 (Closed Terms)**：如果一个项没有自由变量（即闭项），那么它属于所有的 $T_n$。

**重要性质：**

- 每个（闭的）普通项都有唯一的 de Bruijn 表示。
- 如果两个普通项在绑定变量重命名下等价，那么它们的 de Bruijn 表示也相同。

---

#### **处理含有自由变量的项**

当处理含有自由变量的项时，我们需要引入**命名上下文 (Naming Context)** 的概念。

**示例：**

- 要表示 $\lambda x.\ y\ x$ 作为无名项。
  - $x$ 是绑定变量，可以处理。
  - $y$ 是自由变量，没有绑定，我们需要知道它在上下文中的位置。
  

**解决方案：**

- 定义一个命名上下文 $\Gamma$，为自由变量指定 de Bruijn 指数。

**6.1.3 定义 [命名上下文]：**

- 设 $x_0, x_1, \dots, x_n$ 是变量名。
- 命名上下文 $\Gamma = x_n, x_{n-1}, \dots, x_0$，将 de Bruijn 指数 $i$ 分配给每个 $x_i$。
- **注意**：序列中最右边的变量分配索引 $0$。

**示例：**

- 给定上下文 $\Gamma = x, y, z, a, b$，对应的索引为：

  $$
  \begin{align*}
  x &\mapsto 4 \\
  y &\mapsto 3 \\
  z &\mapsto 2 \\
  a &\mapsto 1 \\
  b &\mapsto 0
  \end{align*}
  $$

- 在这个上下文下：

  - $x\ (y\ z)$ 表示为 $4\ (3\ 2)$。
  - $\lambda w.\ y\ w$ 表示为 $\lambda.\ 4\ 0$。
  - $\lambda w.\ \lambda a.\ x$ 表示为 $\lambda.\ \lambda.\ 6$。

---

#### **习题 6.1.4 [««« 3]：以类似于定义 3.2.3 的方式，给出 $n$ 项集合的另一种构造，并证明它与上述定义等价。**

**解答：**

**提示：**

- 定义 3.2.3 是关于算术表达式的语法定义，这里需要以类似的方式构造 $n$ 项集合。
- 需要证明新构造的集合与之前的定义产生相同的项。

**构造：**

- **基础情况**：
  - **变量**：对于每个 $0 \leq k < n$，$k$ 是 $n$ 项。
- **归纳步骤**：
  - 如果 $t \in T_{n-1}$，那么 $\lambda.\ t \in T_n$。
  - 如果 $t_1, t_2 \in T_n$，那么 $(t_1\ t_2) \in T_n$。

**证明等价性：**

- **与原定义的区别**：
  - 原定义在构造 $\lambda.\ t$ 时，$t \in T_n$，结果在 $T_{n-1}$。
  - 新的构造中，$\lambda.\ t$ 从 $T_{n-1}$ 到 $T_n$。
- **调整新构造**：
  - 修改新构造，使得如果 $t \in T_n$，则 $\lambda.\ t \in T_{n-1}$。
- **证明**：
  - 通过数学归纳法，证明两种定义生成的项集合相同。

---

#### **习题 6.1.5 [推荐, «««]：**

1. **定义函数 $\text{removenames}_\Gamma(t)$**，它接受一个命名上下文 $\Gamma$ 和一个普通项 $t$（其中 $FV(t) \subseteq \text{dom}(\Gamma)$），并产生对应的无名项。
2. **定义函数 $\text{restorenames}_\Gamma(t)$**，它接受一个无名项 $t$ 和命名上下文 $\Gamma$，并生成一个普通项。

**要求：**

- 这两个函数应该满足：
  - 对于任何无名项 $t$，有 $\text{removenames}_\Gamma(\text{restorenames}_\Gamma(t)) = t$。
  - 对于任何普通项 $t$，有 $\text{restorenames}_\Gamma(\text{removenames}_\Gamma(t)) = t$，在绑定变量重命名的意义下。

**解答：**

1. **定义 $\text{removenames}_\Gamma(t)$：**

   - **输入**：命名上下文 $\Gamma$，普通项 $t$。
   - **过程**：
     - 对于变量：
       - 如果变量 $x$ 是自由变量，在 $\Gamma$ 中查找其索引 $i$，替换为 $i$。
     - 对于抽象 $\lambda x.\ t_1$：
       - 增加上下文 $\Gamma' = x, \Gamma$（将 $x$ 添加到 $\Gamma$ 的左边）。
       - 递归调用 $\text{removenames}_{\Gamma'}(t_1)$。
       - 结果为 $\lambda.\ t_1'$。
     - 对于应用 $t_1\ t_2$：
       - 分别递归调用 $\text{removenames}_\Gamma(t_1)$ 和 $\text{removenames}_\Gamma(t_2)$。
       - 结果为 $t_1'\ t_2'$。

2. **定义 $\text{restorenames}_\Gamma(t)$：**

   - **输入**：无名项 $t$，命名上下文 $\Gamma$。
   - **过程**：
     - 对于索引 $k$：
       - 如果 $k < |\Gamma|$，从 $\Gamma$ 中获取索引为 $k$ 的变量名 $x$。
       - 如果 $k \geq |\Gamma|$，表示需要生成新的绑定变量名。
     - 对于抽象 $\lambda.\ t_1$：
       - 选择一个不在 $\Gamma$ 中的变量名 $x$。
       - 增加上下文 $\Gamma' = x, \Gamma$。
       - 递归调用 $\text{restorenames}_{\Gamma'}(t_1)$。
       - 结果为 $\lambda x.\ t_1'$。
     - 对于应用 $t_1\ t_2$：
       - 分别递归调用 $\text{restorenames}_\Gamma(t_1)$ 和 $\text{restorenames}_\Gamma(t_2)$。
       - 结果为 $t_1'\ t_2'$。

**验证性质：**

- **对于无名项 $t$**：

  - 计算 $\text{removenames}_\Gamma(\text{restorenames}_\Gamma(t))$。
  - 由于 $\text{restorenames}_\Gamma(t)$ 恢复了原始的变量名，重新移除名字后，应得到原始的无名项 $t$。

- **对于普通项 $t$**：

  - 计算 $\text{restorenames}_\Gamma(\text{removenames}_\Gamma(t))$。
  - 由于可能存在绑定变量的重命名，结果在绑定变量重命名的意义下等价于 $t$。

---

#### **关于术语的注释**

- **严格来说**，我们不能简单地说“某个 $t \in T$”，因为我们需要指定 $t$ 可能具有的自由变量的数量。
- **实践中**，我们通常会有一个固定的命名上下文 $\Gamma$，然后稍微滥用符号，写 $t \in T$，意思是 $t \in T_n$，其中 $n$ 是 $\Gamma$ 的长度。

---

### ---------------------------------

在无名项（使用 de Bruijn 指数）的表示中，处理**含有自由变量的项**和**没有自由变量的项**的方式有所不同。由于无名项通过索引而不是变量名来表示绑定的变量，处理自由变量时需要一种不同的方法来标识它们。

### **含有自由变量的项 vs 没有自由变量的项 对比表**

| **角度**           | **含有自由变量的项**                                         | **没有自由变量的项**                                   |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------ |
| **定义**           | 项中包含至少一个未被任何 $lambda$ 绑定的变量。               | 项中的所有变量都被局部的 $lambda$ 表达式绑定。         |
| **处理方式**       | 自由变量通常使用某种全局编号或保留名称来标识，并与局部绑定区分。 | 所有变量通过 de Bruijn 指数表示，直接使用整数处理。    |
| **典型表达式**     | $lambda\ y. x$ （$x$ 是自由变量，未被绑定）。                | $lambda\ x. (lambda\ y. x)$ （所有变量都被绑定）。     |
| **de Bruijn 指数** | 自由变量不会有对应的 de Bruijn 指数，通常通过外部标记或编号。 | 绑定变量使用整数索引表示，例如 $lambda . 0$。          |
| **优点**           | 自由变量可以保持与全局环境的关系，便于后续求值。             | 无需特殊处理，所有变量都局部绑定，适合局部替换和求值。 |
| **缺点**           | 需要额外的机制来区分自由变量和绑定变量，增加了复杂性。       | 变量的作用范围完全局限在表达式内部，无法访问外部环境。 |

### **处理没有自由变量的项**

在没有自由变量的 Lambda 表达式中，所有变量都被某个 $lambda$ 表达式绑定。这种情况下，所有变量都可以通过**de Bruijn 指数**来唯一确定其绑定的 $lambda$，并且不涉及外部变量。我们可以简单地通过整数表示来替换变量名。

#### **示例：**

考虑以下 Lambda 表达式：

$$lambda\ x.(lambda\ y.x)$$

- 这是一个没有自由变量的项。
- $x$ 是由外层 $lambda\ x$ 绑定，$y$ 是由内层 $lambda\ y$ 绑定。
- 该表达式的无名项表示为：

$$lambda.(lambda.1)$$

在这里：
- 第一个 $lambda$ 绑定了 $x$，所以 $x$ 在内层中被表示为 $1$，即它引用了外层的 $lambda$ 绑定的变量。
- 内层的 $lambda$ 绑定了 $y$，但是 $y$ 没有被使用，所以它没有出现在无名项的表示中。

### **处理含有自由变量的项**

含有自由变量的项意味着存在至少一个变量没有被当前的 $lambda$ 表达式绑定。在这种情况下，自由变量不能使用**de Bruijn 指数**来表示，因为它们不在当前作用域中绑定。我们需要一种机制来区分自由变量和绑定变量，常见的处理方式包括：

1. **使用全局编号**：自由变量可以使用全局索引或编号来区分，比如使用负数或其他特殊的标记来表示这些变量。
2. **保持变量名称**：在某些实现中，自由变量依然保留名称，而绑定变量则使用 de Bruijn 指数。这可以避免将自由变量和局部变量混淆。

#### **示例：**

考虑以下 Lambda 表达式：

$$lambda\ y.x$$

- 在这个表达式中，$x$ 是自由变量，$y$ 是局部绑定变量。
- 由于 $x$ 没有被 $lambda$ 绑定，它是自由变量，而 $y$ 被当前的 $lambda$ 绑定。

在无名项的表示中，这个表达式可以写作：

$$lambda . x$$

- $y$ 是由当前的 $lambda$ 绑定，所以没有显式表示出来，而 $x$ 作为自由变量保留它的名称，或者可以使用全局索引来表示。

#### **使用全局编号的方式：**

如果采用全局编号，可能会将 $x$ 表示为一个特别的索引值，比如：

$$lambda . -1$$

在这个例子中：
- 自由变量 $x$ 使用 $-1$ 来表示，表示它不在当前的 $lambda$ 绑定中。
- 局部绑定变量 $y$ 没有被使用。

### **自由变量的替换**

在处理自由变量时，如果需要对表达式进行替换操作，处理会变得稍微复杂一些。由于自由变量不受局部 $lambda$ 的影响，我们需要确保替换操作不会误改自由变量。

#### **示例：**

对于表达式：

$$lambda\ y.(lambda\ z.x\ y)$$

- $x$ 是自由变量。
- $y$ 和 $z$ 分别由各自的 $lambda$ 绑定。

无名项的表示可能是：

$$lambda . (lambda . -1\ 1)$$

- 自由变量 $x$ 表示为 $-1$，因为它不在当前的绑定中。
- $y$ 和 $z$ 分别使用 de Bruijn 指数进行索引。

在替换时，我们需要确保只替换那些由当前 $lambda$ 绑定的变量，不影响自由变量。

### **总结**

- **没有自由变量的项**：所有变量都由当前的 $lambda$ 表达式绑定，使用 de Bruijn 指数可以轻松处理这些变量的替换和求值。
- **含有自由变量的项**：自由变量无法使用 de Bruijn 指数直接表示，通常需要通过全局编号或保留名称的方式来处理。自由变量的替换和求值需要额外的关注，确保它们不会被误改。

两种类型的项处理方式各有特点，无名项通过使用整数简化了绑定变量的处理，但对于自由变量，需要特殊机制来区分和管理。



### -----------------------------------

#### 6.2 **移位和替换 (Shifting and Substitution)**

在 Lambda 演算和无名项的表示中，**移位（Shifting）**和**替换（Substitution）**是处理绑定变量和自由变量时的两个关键操作。它们帮助我们处理变量的作用域、绑定和替换关系，特别是在使用 de Bruijn 指数表示变量时。

### 1. **移位 (Shifting)**

移位（Shifting）是指在无名项（使用 de Bruijn 指数）表示中，将变量的 de Bruijn 索引增加或减少，从而调整它在不同作用域中的表示。

#### **移位的原因：**
- 当我们将一个项嵌入到另一个项的内部时，该项中的绑定结构会发生变化。特别是当一个项被置于新的 $lambda$ 内部时，项中的自由变量需要根据新的作用域进行调整，这时候就需要对自由变量的索引进行移位。
- 移位通常用于在进行变量替换时，确保自由变量的正确表示，不受新作用域的影响。

#### **移位的操作：**
- **向上移位**：通常是在表达式中引入新的 $lambda$ 时，对自由变量的 de Bruijn 索引加 1。因为表达式嵌套到了更深的作用域中，自由变量的索引相应地增加。
- **向下移位**：在某些操作（如变量替换）后，可能需要减少索引以保持表达式的正确性。

#### **移位函数 (Shifting Function)：**
移位的核心是根据当前的深度，调整变量的 de Bruijn 索引。

假设我们有一个项 $t$，并希望将该项的所有自由变量索引加 1（即向上移位），我们可以定义如下的移位函数：

- **定义**：
  - $shift\ d\ t$，其中 $d$ 是移位量，$t$ 是表达式。
  - 移位会遍历项中的每个变量，并对其索引进行调整。

- **例子**：

对于项 $lambda.(lambda.1)$，如果我们向其内部引入一个新 $lambda$，项中的自由变量的索引就需要向上移位：

$$lambda.(lambda.(shift\ 1\ 1))$$

这个表达式经过移位后会变为：

$$lambda.(lambda.2)$$

因为原本引用外层第一个绑定变量的索引 $1$，在引入一个新 $lambda$ 后，需要增加到 $2$。

#### **移位的递归算法：**

移位操作需要遍历整个项的结构，并递归地调整每个变量的索引。

**算法的伪代码**：

```plaintext
shift(d, t) =
  case t of
    Var(x, n) -> 如果 x >= c，则将 x + d；否则保持 x 不变
    Abs(x, t1) -> 对 t1 进行移位，移位量为 d，深度增加 1
    App(t1, t2) -> 对 t1 和 t2 进行移位，移位量为 d
```

### --------------------------------

好的！我来详细解释这个 **移位 (Shifting)** 操作的算法。移位是无名项中处理 de Bruijn 指数的一项关键操作，主要用于在嵌套函数（Lambda 表达式）中，调整变量的 de Bruijn 索引，以正确处理变量的作用域。

我们一步一步来解释你提到的伪代码。

### **1. 什么是移位 (Shifting)?**

移位是指在表达式中对**自由变量**的 de Bruijn 索引进行调整。具体来说，当我们把一个项放到一个新的、更深的嵌套中（比如在一个新的 $lambda$ 之内），自由变量的索引需要增加，以反映其与新的 $lambda$ 绑定的距离。

举个例子：

假设我们有一个表达式 `lambda . 0`，表示一个简单的恒等函数。这个项中的变量 `0` 是由最近的 $lambda$ 绑定的。

现在如果我们想把这个恒等函数放到另一个 $lambda$ 表达式里，比如说 `lambda y. (lambda . 0)`，此时内部的变量 `0` 仍然应该指向原来的 $lambda$，但是由于我们多了一层嵌套，它需要变成 `1`。这个就是移位操作的核心：通过调整索引，保持变量与其 $lambda$ 的正确绑定关系。

### **2. 移位算法详解**

你提到的移位算法的伪代码是：

```plaintext
shift(d, t) =
  case t of
    Var(x, n) -> 如果 x >= c，则将 x + d；否则保持 x 不变
    Abs(x, t1) -> 对 t1 进行移位，移位量为 d，深度增加 1
    App(t1, t2) -> 对 t1 和 t2 进行移位，移位量为 d
```

现在我们逐条解释每个部分。

#### **移位函数的输入和输出：**

- $d$ 是移位的量（通常是正数），表示我们希望自由变量的 de Bruijn 索引增加多少。
- $t$ 是一个项（term），可能是一个变量（$Var$）、一个抽象（$Abs$，即 Lambda 表达式），或者是一个应用（$App$）。

移位操作会对项 $t$ 中的自由变量索引进行调整，返回移位后的项。

#### **逐条解释伪代码**

1. **变量 (Var) 情况：**

   ```plaintext
   Var(x, n) -> 如果 x >= c，则将 x + d；否则保持 x 不变
   ```

   - 🥑$x$ 是变量的 de Bruijn 索引，$n$ 是上下文的大小（即当前作用域的层数）。
   - $c$ 是一个深度计数器，表示当前变量相对于它的 $lambda$ 表达式的层次。

   **逻辑解释：**

   - 当我们处理一个变量时，如果该变量的索引 $x$ 大于等于当前深度 $c$，那么它是一个自由变量，需要将它的索引增加 $d$。这是因为我们将这个自由变量嵌套到新的、更深的作用域中，距离它的绑定 $lambda$ 更远了。
   - 🥑如果 $x < c$，则说明这个变量是一个绑定变量（即它在当前或更内层的 $lambda$ 作用域中被绑定），不需要移位。

   **例子：**

   假设我们有一个变量 `Var(0, 1)`，表示它是一个自由变量，当前上下文深度为 1。我们希望将其移位 $d = 1$：

   - 如果 $x = 0$ 并且 $c = 0$，那么我们应该保持 $x$ 不变，因为这是绑定变量。
   - 如果 $x = 1$，它是一个自由变量，我们需要将其移位，结果是 $x = 1 + d = 1 + 1 = 2$。

2. **抽象 (Abs) 情况：**

   ```plaintext
   Abs(x, t1) -> 对 t1 进行移位，移位量为 d，深度增加 1
   ```

   - $Abs(x, t1)$ 表示一个 $lambda$ 表达式，它绑定了变量 $x$，其主体是 $t1$。

   **逻辑解释：**

   - 对于 $lambda$ 表达式，它引入了一个新的绑定变量，因此在递归处理其主体 $t1$ 时，我们要将当前深度 $c$ 增加 1。
   - 这意味着在 $t1$ 中，绑定的变量层级发生了变化，所以我们在继续递归移位操作时，深度需要相应增加。

   **例子：**

   假设我们有一个表达式 `Abs("x", Var(0, 1))`，其中 `Var(0, 1)` 表示变量 `x` 是由这个 $lambda$ 表达式绑定的。

   - 对这个表达式进行移位时，因为 `x` 是绑定变量，所以我们不需要对它的索引进行移位。
   - 但是我们递归处理 $t1$ 时，深度 $c$ 增加 1。

3. **应用 (App) 情况：**

   ```plaintext
   App(t1, t2) -> 对 t1 和 t2 进行移位，移位量为 d
   ```

   - $App(t1, t2)$ 表示一个应用，其中 $t1$ 是函数，$t2$ 是参数。

   **逻辑解释：**

   - 对于应用表达式，移位操作分别应用到 $t1$ 和 $t2$。这意味着我们对应用的两个子项都需要进行相同的移位操作。

   **例子：**

   假设我们有一个应用 `App(Var(1, 2), Var(0, 2))`，即应用一个自由变量 `Var(1)` 到一个绑定变量 `Var(0)`：

   - 移位时，我们分别处理两个子项：对自由变量 `Var(1)` 进行移位，它的索引将变成 `2`；对绑定变量 `Var(0)` 不进行移位。

### ---------------------------

好的！我们一步一步详细讲解 **移位 (Shifting)** 的具体过程，使用 Lambda 表达式：

$$ \lambda x. (\lambda y. x) $$

并将其转换为无名项的形式，应用 **移位** 操作。我们假设移位量 $d = 1$。

### **第一步：将表达式转换为无名项表示**

首先，我们将这个表达式转换为 **de Bruijn 索引**表示的无名项。我们从最外层的变量开始编号。

$$ \lambda x. (\lambda y. x) $$

- $x$ 是外层的绑定变量，索引为 1。
- $y$ 是内层的绑定变量，索引为 0。
- 内层表达式引用的是外层的 $x$，因此内层的 $x$ 的索引为 1。

转换后的无名项表示为：

$$ \lambda . (\lambda . 1) $$

这个无名项的结构如下：
- 最外层的 $lambda$ 绑定了第一个变量，后面没有用到。
- 内层的 $lambda$ 绑定了变量 $y$，变量 $x$ 被引用，使用 de Bruijn 索引 1，表示引用了外层的 $lambda$ 绑定的变量。

### **第二步：解释移位操作**

现在我们要对这个无名项进行移位操作。**移位** 的作用是：当我们把这个表达式嵌入到更深的作用域时，需要对**自由变量**的 de Bruijn 索引进行调整，确保它们仍然正确引用外层的绑定变量。

假设我们想将这个表达式嵌入到另一个更深的作用域中，我们需要对其中的**自由变量**进行移位操作。

### **第三步：移位过程 (Shifting Process)**

我们应用的移位操作是：**移位量 $d = 1$**。这个移位量表示我们希望将表达式嵌入一个更深的作用域，因此自由变量的索引需要增加 1。

我们递归地对每个部分进行移位操作。

#### **处理最外层的 $lambda$**

表达式的最外层是：

$$ \lambda . (\lambda . 1) $$

- 当前深度 $c = 0$。
- 由于 $lambda$ 是绑定操作，它引入了一个新的绑定变量，所以我们对其内部的表达式进行递归处理，深度 $c$ 增加 1。

#### **处理内层的 $lambda$**

现在我们处理内层表达式：

$$ \lambda . 1 $$

- 当前深度 $c = 1$。
- 由于我们又遇到一个 $lambda$，这意味着我们再次进入了一个新的作用域，所以深度 $c$ 增加 1，再次对其内部的表达式进行递归处理。

#### **处理变量 $1$**

此时，我们进入了最里面的表达式：

$$ 1 $$

- 当前深度 $c = 2$。
- 变量 $1$ 的 de Bruijn 索引是 1，它引用的是外层的 $lambda x$，而非当前的 $lambda y$。

接下来，我们根据移位规则来处理这个变量：
- 因为变量 $1$ 的 de Bruijn 索引 $x = 1$，而当前深度 $c = 2$，我们有 $x < c$，表示它是一个**绑定变量**，而不是自由变量。
- 因此，这个变量**不需要移位**。

### **第四步：最终结果**

由于整个表达式中没有自由变量，因此移位操作不影响这个表达式。移位后的无名项与原始无名项相同：

$$ \lambda . (\lambda . 1) $$

### **总结：移位的关键**

在这个例子中，我们通过递归遍历表达式的每个部分，对每个变量应用移位规则：

1. 当遇到 $lambda$ 表达式时，进入一个新的作用域，深度 $c$ 增加 1。
2. 当遇到变量时，通过比较变量的 de Bruijn 索引 $x$ 和当前深度 $c$ 来判断是否需要移位：
   - 如果 $x \geq c$，说明它是自由变量，需要移位。
   - 如果 $x < c$，说明它是绑定变量，不需要移位。

由于这个表达式中所有变量都是绑定变量，因此没有进行实际的移位操作，结果保持不变。

如果表达式中存在自由变量，则它们的索引会根据移位量 $d$ 进行调整。

希望这个逐步讲解能帮助你理解移位过程！如果还有疑问，欢迎继续提问。

### -------------------------------

### **3. 总结与示例**

#### **移位的例子：**

考虑表达式：

```plaintext
lambda x. (lambda y. x)
```

使用 de Bruijn 索引表示为：

```plaintext
Abs(Abs(Var(1, 2)))
```

在这个表达式中，`x` 被绑定在最外层的 $lambda$，它的 de Bruijn 索引为 1。我们对这个表达式进行移位 $d = 1$，得到：

```plaintext
shift(1, Abs(Abs(Var(1, 2))))
```

移位结果为：

```plaintext
Abs(Abs(Var(2, 3)))
```

- 这里，变量 `x` 的索引从 `1` 增加到了 `2`，因为它现在处于更深的嵌套中。

### **4. 关键点总结**

- **移位 (Shifting)** 是为了在改变作用域时，调整自由变量的 de Bruijn 索引，使其保持对正确的 $lambda$ 绑定的引用。
- 在**变量**的情况下，只有自由变量（索引大于或等于当前深度 $c$ 的变量）才会被移位。
- 在**抽象**（$lambda$ 表达式）的情况下，递归处理时深度增加 1。
- 在**应用**的情况下，递归地对函数和参数进行移位。

希望通过这些解释，你能更好地理解移位操作的工作原理和它在处理无名项中的应用。如果你还有疑问，随时告诉我！

### -----------------------------------

在移位操作中，**$c$** 表示的是**当前的深度**，即当前正在处理的表达式相对于最外层作用域的层数。它是一个递归过程中传递的变量，用于追踪当前我们位于哪个作用域层次。这个深度是非常重要的，因为它决定了哪些变量是自由的，哪些变量是绑定的。

### **解释 $c$ 的作用：**

- 在 Lambda 演算中，每引入一个新的 $lambda$ 表达式时，就会绑定一个新的变量，并且作用域的深度 $c$ 会增加 1。
- 如果我们遇到一个变量，其 de Bruijn 索引 $x$ 小于当前深度 $c$，那么该变量是**绑定变量**，因为它是在更内层的 $lambda$ 中被绑定的。此时，我们不需要对它进行移位操作。
- 如果 $x$ 大于或等于当前的深度 $c$，则该变量是**自由变量**，我们需要对它的 de Bruijn 索引进行移位，以反映它的自由状态在新的作用域中的变化。

### **$c$ 的具体意义：**

- **$c$ 是当前正在处理的深度**。它帮助我们判断当前变量是自由的还是绑定的。
- 在处理 Lambda 表达式时，每遇到一个新的 $lambda$，就会将 $c$ 加 1。因为每个新的 $lambda$ 表示引入了一个新的绑定变量，这会增加作用域的嵌套深度。

### **例子：**

假设我们有以下表达式：

$$t = lambda\ x. (lambda\ y. x)$$

该表达式可以表示为：

$$t = Abs(Abs(Var(1, 2)))$$

在这里：
- 外层 $lambda\ x$ 绑定了 $x$。
- 内层 $lambda\ y$ 绑定了 $y$，但内部表达式 `Var(1)` 引用了外层绑定的 $x$，它的 de Bruijn 索引为 1。
- 当前深度 $c$ 随着递归进入表达式时会增加。

如果我们对这个表达式进行移位操作（比如移位 $d = 1$），则递归处理时的过程如下：

1. **处理外层 $Abs(Abs(Var(1, 2)))$**：当前深度 $c = 0$，处理的是外层 $lambda$。
   - 遇到 $Abs$，递归处理其内部表达式，深度 $c$ 增加 1。

2. **处理内层 $Abs(Var(1, 2))$**：当前深度 $c = 1$，处理的是内层 $lambda$。
   - 遇到变量 $Var(1)$，判断其索引 $1$ 是否大于等于当前深度 $c = 1$。因为 $1 = 1$，这个变量是一个**自由变量**，需要对其进行移位操作，结果变成 $Var(2)$。
   - 由于递归进入了内层 $Abs$，深度再次增加，变为 $c = 2$。

### **总结 $c$ 的作用**：

- **$c$** 是一个递归过程中的计数器，表示当前的作用域深度。
- 在递归过程中，每遇到一个新的 $lambda$，$c$ 会增加 1，表示当前进入了一个更深的作用域。
- 通过比较变量的 de Bruijn 索引 $x$ 和当前深度 $c$，我们可以判断该变量是**自由变量**还是**绑定变量**：
  - 如果 $x \geq c$，表示该变量是自由变量，可能需要移位。
  - 如果 $x < c$，表示该变量是绑定变量，不需要移位。

希望这样解释后，你能理解 $c$ 的作用及其在移位过程中的意义！

### ----------------------------------

### -2. **替换 (Substitution)**

替换（Substitution）是指在 Lambda 表达式中，将某个变量替换为另一个项。

#### **替换的原因：**
- 替换是 Lambda 演算中最常见的操作之一，特别是在进行函数应用时。替换的主要目的是将一个自由变量替换为某个具体的值或项。
- 当我们进行 $lambda$ 表达式应用时，我们需要将函数体中的绑定变量替换为函数的实际参数。

#### **替换的操作：**
- 替换需要确保变量的作用域不会混淆。在进行替换时，可能需要对内部的变量索引进行调整，避免出现**变量捕获**的问题。
- 通常情况下，**替换操作需要结合移位来确保自由变量的正确处理。**

#### **替换函数 (Substitution Function)：**
替换操作的定义为：

- **定义**：
  - $subst\ j\ s\ t$，表示将项 $t$ 中 de Bruijn 索引为 $j$ 的变量替换为项 $s$。

- **例子**：

考虑表达式 $lambda.(lambda.1)$，如果我们希望将外层的变量替换为 $lambda.z$，我们需要进行如下替换操作：

$$subst\ 0\ (lambda.z)\ (lambda.(lambda.1))$$

替换结果为：

$$lambda.(lambda.(lambda.z))$$

#### **替换的递归算法：**

替换操作与移位类似，也需要递归地遍历项的结构，同时确保替换时不会改变自由变量的作用域。

**算法的伪代码**：

```plaintext
subst(j, s, t) =
  case t of
    Var(x, n) -> 如果 x = j，则用 s 替换 x；否则保持不变
    Abs(x, t1) -> 递归地对 t1 进行替换，深度增加 1
    App(t1, t2) -> 对 t1 和 t2 进行递归替换
```

#### **替换结合移位的示例：**

假设我们有以下表达式：

$$t = lambda.(lambda.(App(Var(1), Var(0))))$$

如果我们想将变量 1 替换为某个项 $s$，我们需要首先对项 $s$ 进行移位操作，然后进行替换：

$$subst\ 1\ s\ t$$

具体操作如下：

1. 对 $s$ 进行移位操作（向上移位），使其适应当前的作用域。
2. 将 $t$ 中 de Bruijn 索引为 1 的变量替换为移位后的 $s$。

### **替换与移位的组合使用**

在 Lambda 演算中，替换和移位通常是结合使用的。在进行变量替换时，需要先对插入的项进行移位，以确保自由变量的正确性。然后，再进行替换操作。

#### **步骤**：
1. **移位**：在进行替换之前，需要先对替换项（也就是实际参数）进行移位，确保它能够正确嵌入到新的作用域中。
2. **替换**：然后，将目标项中的绑定变量替换为新的项。

#### **示例：**
考虑以下 Lambda 表达式：

$$lambda.(lambda.1)$$

如果我们希望将外层的变量（de Bruijn 指数 1）替换为 $lambda.z$，替换过程如下：

1. 对 $lambda.z$ 进行移位：

$$shift(1, lambda.z) = lambda.z$$  （因为 $lambda.z$ 没有自由变量）

2. 进行替换操作：

$$subst(1, lambda.z, lambda.(lambda.1)) = lambda.(lambda.(lambda.z))$$

### **总结**

- **移位 (Shifting)**：在表达式中引入新的作用域时，调整自由变量的 de Bruijn 索引，确保变量在新的上下文中正确表示。
- **替换 (Substitution)**：将某个绑定变量替换为一个具体的项，通常结合移位操作，确保替换项与原表达式的作用域匹配。

这两个操作是处理 Lambda 演算和无名项的核心步骤，特别是在涉及嵌套函数和作用域时，它们确保了表达式中的变量绑定和自由变量的正确性。

### --------------------------------------

我们的下一个任务是定义无名项上的替换操作 $[k \mapsto s]t$。为此，我们需要一个辅助操作，称为**移位 (Shifting)**，它重新编号项中自由变量的索引。

---

**移位的必要性：**

- 当替换深入到 $\lambda$ 抽象中时，例如 $[1 \mapsto s](\lambda.\ 2)$，替换发生的上下文比原来的多了一个变量，我们需要调整 $s$ 中自由变量的索引，以确保它们在新上下文中仍然引用相同的变量。
- 需要小心的是，不能简单地将 $s$ 中的每个变量索引都加一，因为这可能会错误地影响 $s$ 中的绑定变量。

---

**6.2.1 定义 [移位 (Shifting)]：**

- **$\uparrow^d_c(t)$** 表示对项 $t$ 进行从 **截断值 (cutoff)** $c$ 开始的 $d$ 次移位。

- **规则：**

  1. **变量：**

     $$
     \uparrow^d_c(k) =
     \begin{cases}
     k, & \text{如果 } k < c \\
     k + d, & \text{如果 } k \geq c
     \end{cases}
     $$

  2. **抽象：**

     $$
     \uparrow^d_c(\lambda.\ t_1) = \lambda.\ \uparrow^d_{c+1}(t_1)
     $$

  3. **应用：**

     $$
     \uparrow^d_c(t_1\ t_2) = \uparrow^d_c(t_1)\ \uparrow^d_c(t_2)
     $$

- **简化表示：**

  - 当 $c = 0$ 时，记作 $\uparrow^d(t) = \uparrow^d_0(t)$。

**解释：**

- **截断值 $c$**：表示移位操作从哪个层次的绑定开始。
- **d**：表示移位的位数，即索引增加的数量。
- **目的**：确保在替换过程中，$s$ 中的自由变量在新的上下文中引用正确的变量。

---

#### **习题 6.2.2 [«]：**

1. 计算 $\uparrow^2(\lambda.\ \lambda.\ 1\ (0\ 2))$。

   **解答：**

   - 首先，我们有项 $\lambda.\ \lambda.\ 1\ (0\ 2)$。
   - 应用 $\uparrow^2$（即 $\uparrow^2_0$）到整个项。

   **步骤：**

   - 对于最外层的 $\lambda$，进入其主体，截断值 $c$ 增加1。
   - 第二个 $\lambda$，截断值 $c$ 增加1，变为2。
   - 对于变量：
     - 变量 $1$（在截断值 $c=2$ 下）：
       - $1 < 2$，所以保持不变，仍为 $1$。
     - 变量 $0$（同理）：
       - $0 < 2$，保持不变，仍为 $0$。
     - 变量 $2$（$2 \geq 2$）：
       - $2 + 2 = 4$。

   **结果：**

   $$
   \lambda.\ \lambda.\ 1\ (0\ 4)
   $$

2. 计算 $\uparrow^2(\lambda.\ 0\ 1\ (\lambda.\ 0\ 1\ 2))$。

   **解答：**

   **步骤：**

   - 对于最外层的 $\lambda$，截断值 $c = 0 + 1 = 1$。
   - 对于变量 $0$ 和 $1$：
     - $0 < 1$，保持不变。
     - $1 \geq 1$，所以 $1 + 2 = 3$。
   - 对于内部的 $\lambda$，截断值 $c = 1 + 1 = 2$。
     - 变量 $0$：
       - $0 < 2$，保持不变。
     - 变量 $1$：
       - $1 < 2$，保持不变。
     - 变量 $2$：
       - $2 \geq 2$，所以 $2 + 2 = 4$。

   **结果：**

   $$
   \lambda.\ 0\ 3\ (\lambda.\ 0\ 1\ 4)
   $$

---

#### **习题 6.2.3 [«« 3]：证明如果 $t$ 是 $n$ 项，则 $\uparrow^d_c(t)$ 是 $(n + d)$ 项。**

**解答：**

**目标：**

- 证明对于任意 $n$ 项 $t$，$\uparrow^d_c(t)$ 是 $(n + d)$ 项。

**证明思路：**

- **变量情况：**
  - 如果 $k < c$，$\uparrow^d_c(k) = k$，索引不变，项的自由变量数不变。
  - 如果 $k \geq c$，$\uparrow^d_c(k) = k + d$，索引增加 $d$，因此自由变量的最大索引增加了 $d$。

- **抽象情况：**
  - 对于 $\lambda.\ t_1$，$\uparrow^d_c(\lambda.\ t_1) = \lambda.\ \uparrow^d_{c+1}(t_1)$。
  - 进入抽象后，截断值 $c$ 增加 1。
  - 自由变量的数量不受抽象影响，但索引可能增加 $d$。

- **应用情况：**
  - 对于 $t_1\ t_2$，分别对 $t_1$ 和 $t_2$ 应用移位操作。
  - 自由变量的数量取两者的最大值。

**结论：**

- 在移位过程中，自由变量的最大索引增加了 $d$，因此项的自由变量数量增加了 $d$。
- 因此，$\uparrow^d_c(t)$ 是 $(n + d)$ 项。

---

#### **替换操作的定义**

现在，我们准备定义替换操作 $[j \mapsto s]t$。

- **目的**：在项 $t$ 中，用项 $s$ 替换索引为 $j$ 的变量。

**6.2.4 定义 [替换 (Substitution)]：**

- **变量：**

  $$
  [j \mapsto s]k =
  \begin{cases}
  s, & \text{如果 } k = j \\
  k, & \text{否则}
  \end{cases}
  $$

- **抽象：**

  $$
  [j \mapsto s](\lambda.\ t_1) = \lambda.\ [j + 1 \mapsto \uparrow^1(s)]t_1
  $$

- **应用：**

  $$
  [j \mapsto s](t_1\ t_2) = ([j \mapsto s]t_1)\ ([j \mapsto s]t_2)
  $$

**解释：**

- **替换变量 $k$：**
  - 如果 $k$ 等于要替换的索引 $j$，则替换为 $s$。
  - 否则，保持 $k$ 不变。
- **处理抽象时**，需要将替换的索引 $j$ 增加 1，同时将替换项 $s$ 进行一次移位 $\uparrow^1(s)$，以适应新的上下文。

---

#### **习题 6.2.5 [«]：将以下替换操作转换为无名形式，假设全局上下文为 $\Gamma = a, b$，并使用上述定义计算结果。答案是否对应于第5.3节中对普通项的替换定义？**

1. $[b \mapsto a]\ (b\ (\lambda x.\ \lambda y.\ b))$
2. $[b \mapsto a\ (\lambda z.\ a)]\ (b\ (\lambda x.\ b))$
3. $[b \mapsto a]\ (\lambda b.\ b\ a)$
4. $[b \mapsto a]\ (\lambda a.\ b\ a)$

**解答：**

首先，为了将这些替换操作转换为无名形式，我们需要知道上下文中变量的索引。

**上下文 $\Gamma = a, b$：**

- $a \mapsto 1$
- $b \mapsto 0$

---

**问题1：$[b \mapsto a]\ (b\ (\lambda x.\ \lambda y.\ b))$**

**步骤：**

- 将项转换为无名形式：

  - $b$：索引 $0$。
  - $a$：索引 $1$。
  - $\lambda x$ 引入新的绑定，索引计数增加。
  - $\lambda y$ 再次引入绑定。
  - 内部的 $b$：索引 $0$（全局上下文中的 $b$）。

- 无名形式：

  $$
  0\ (\lambda.\ \lambda.\ 2)
  $$

- 替换 $[0 \mapsto 1]$，因为 $b$ 的索引为 $0$，$a$ 的索引为 $1$。

- 应用替换：

  - 对于外层的 $0$（$b$）：

    $$
    [0 \mapsto 1](0) = 1
    $$

  - 对于内部的 $\lambda.\ \lambda.\ 2$：

    - 进入第一个 $\lambda$，替换索引 $j$ 增加 1，$j = 1$，$s$ 移位：$\uparrow^1(1) = 2$。
    - 进入第二个 $\lambda$，$j = 2$，$s$ 移位：$\uparrow^1(2) = 3$。
    - 内部的 $2$（对应全局的 $b$），$[2 \mapsto 3](2) = 3$。

- 替换后的结果：

  $$
  1\ (\lambda.\ \lambda.\ 3)
  $$

**对应的普通项：**

- 恢复变量名：

  - 索引 $1$：$a$。
  - 索引 $3$：由于上下文中只有 $a$ 和 $b$，需要引入新的变量名。

- 因此，替换结果与原定义一致。

---

**问题2：$[b \mapsto a\ (\lambda z.\ a)]\ (b\ (\lambda x.\ b))$**

**步骤：**

- 转换为无名形式：

  - 原项：$0\ (\lambda.\ 1)$

- 替换项 $a\ (\lambda z.\ a)$：

  - 转换为无名形式：

    - $\lambda z.\ a$ 转换为 $\lambda.\ 2$（$a$ 的索引为 $1$，新的绑定增加，索引变为 $2$）。
  - 整个替换项为 $1\ (\lambda.\ 2)$。

- 应用替换 $[0 \mapsto 1\ (\lambda.\ 2)]$：

  - 外层的 $0$ 替换为 $1\ (\lambda.\ 2)$。
  - 内部的 $\lambda.\ 1$，替换索引增加：

    - 进入 $\lambda$，$j = 1$，$s$ 移位：$\uparrow^1(1\ (\lambda.\ 2))$。

- 最终结果：

  $$
  (1\ (\lambda.\ 2))\ (\lambda.\ 1)
  $$

---

**问题3：$[b \mapsto a]\ (\lambda b.\ b\ a)$**

**步骤：**

- 转换为无名形式：

  - 外层 $\lambda b$，新的绑定，$b$ 的索引为 $0$，$a$ 的索引为 $1$。

  $$
  \lambda.\ 0\ 1
  $$

- 应用替换 $[0 \mapsto 1]$：

  - 进入 $\lambda$，替换索引 $j$ 增加 1，$j = 1$，$s$ 移位：$\uparrow^1(1) = 2$。

  - 内部的 $0$（新的 $b$），$[1 \mapsto 2](0) = 0$（$0 \ne j$）。

  - 内部的 $1$（$a$），$[1 \mapsto 2](1) = 1$。

- 替换后的结果：

  $$
  \lambda.\ 0\ 1
  $$

- 结果与原项相同，因为替换的 $b$ 被内部的绑定 $b$ 屏蔽了。

---

**问题4：$[b \mapsto a]\ (\lambda a.\ b\ a)$**

**步骤：**

- 转换为无名形式：

  - 外层 $\lambda a$，新的绑定，$a$ 的索引为 $0$，$b$ 的索引为 $1$。

  $$
  \lambda.\ 1\ 0
  $$

- 应用替换 $[0 \mapsto 1]$：

  - 进入 $\lambda$，替换索引 $j$ 增加 1，$j = 1$，$s$ 移位：$\uparrow^1(1) = 2$。

  - 内部的 $1$（$b$），$[1 \mapsto 2](1) = 2$。

  - 内部的 $0$（新的 $a$），$[1 \mapsto 2](0) = 0$。

- 替换后的结果：

  $$
  \lambda.\ 2\ 0
  $$

**对应的普通项：**

- 恢复变量名：

  - 索引 $2$：需要引入新的变量名，可能为 $c$。
  - 索引 $0$：绑定的 $a$。

- 替换结果与原定义一致。

---

#### **习题 6.2.6 [«« 3]：证明如果 $s$ 和 $t$ 是 $n$ 项且 $j \leq n$，那么 $[j \mapsto s]t$ 是 $n$ 项。**

**解答：**

**目标：**

- 证明替换后得到的项仍然是 $n$ 项。

**证明思路：**

- **变量情况**：

  - 如果替换发生，$s$ 是 $n$ 项，替换后的项不增加自由变量的数量。

- **抽象情况**：

  - 在 $\lambda.\ t_1$ 中，$[j \mapsto s](\lambda.\ t_1) = \lambda.\ [j + 1 \mapsto \uparrow^1(s)]t_1$。

  - $s$ 被移位 $\uparrow^1(s)$，其自由变量的数量增加 1，但由于进入了新的抽象，整体的自由变量数量保持不变。

- **应用情况**：

  - 替换分别在 $t_1$ 和 $t_2$ 中进行，自由变量的最大数量不超过 $n$。

**结论：**

- 替换操作不会增加项的自由变量数量，替换后的项仍然是 $n$ 项。

---

#### **习题 6.2.7 [« 3]：拿一张纸，在不看上述替换和移位定义的情况下，重新推导它们。**

**解答：**

**思路：**

- **移位操作**需要调整项中自由变量的索引，以适应上下文的变化。

- **替换操作**需要在项中用另一个项替换某个变量，同时确保变量索引正确。

**步骤：**

1. **移位 (Shifting)**：

   - 目的：当上下文发生变化（如进入新的 $\lambda$ 抽象）时，调整自由变量的索引。

   - 定义：

     - 对于变量 $k$：

       - 如果 $k < c$（即绑定在截断值 $c$ 之前），则保持不变。

       - 如果 $k \geq c$，则索引增加 $d$。

     - 对于抽象 $\lambda.\ t$，截断值 $c$ 增加 1，递归应用移位。

     - 对于应用 $t_1\ t_2$，分别递归应用移位。

2. **替换 (Substitution)**：

   - 目的：在项中用另一个项替换某个变量。

   - 定义：

     - 对于变量 $k$：

       - 如果 $k = j$，则替换为 $s$。

       - 否则，保持 $k$ 不变。

     - 对于抽象 $\lambda.\ t$：

       - 替换索引 $j$ 增加 1。

       - 替换项 $s$ 进行移位 $\uparrow^1(s)$。

       - 递归应用替换。

     - 对于应用 $t_1\ t_2$，分别递归应用替换。

---

#### **习题 6.2.8 [推荐, «««]：无名项上的替换定义应与我们对普通项的替换定义一致。（1）需要证明什么定理以严格证明这种对应关系？（2）证明它。**

**解答：**

1. **需要证明的定理：**

   - **定理**：对于任何普通项 $t$、替换项 $s$ 和命名上下文 $\Gamma$，都有：

     $$
     \text{removenames}_\Gamma([x \mapsto s]t) = [j \mapsto \text{removenames}_\Gamma(s)]\ (\text{removenames}_\Gamma(t))
     $$

     - 其中，$x$ 在上下文 $\Gamma$ 中对应索引 $j$。

2. **证明：**

   - 使用数学归纳法对项 $t$ 的结构进行证明。

   - **基例**：

     - **变量 $x$**：

       - 如果 $t = x$，则有两种情况：

         - 如果 $x = y$，则 $[x \mapsto s]x = s$。

           - 对应于无名项：$[j \mapsto \text{removenames}_\Gamma(s)]j = \text{removenames}_\Gamma(s)$。

         - 如果 $x \ne y$，则 $[x \mapsto s]y = y$。

           - 对应于无名项：$[j \mapsto \text{removenames}_\Gamma(s)]k = k$（$k \ne j$）。

   - **归纳步骤**：

     - **抽象 $\lambda y.\ t_1$**：

       - 有 $[x \mapsto s](\lambda y.\ t_1) = \lambda y.\ [x \mapsto s]t_1$，当 $y \ne x$ 且 $y \notin FV(s)$。

       - 对应的无名项：

         - $\text{removenames}_\Gamma(\lambda y.\ t_1) = \lambda.\ \text{removenames}_{\Gamma'}(t_1)$，其中 $\Gamma' = y, \Gamma$。

         - 替换索引 $j$ 增加 1，替换项移位 $\uparrow^1(\text{removenames}_\Gamma(s))$。

       - 根据归纳假设，替换在 $t_1$ 中保持一致。

     - **应用 $t_1\ t_2$**：

       - 有 $[x \mapsto s](t_1\ t_2) = [x \mapsto s]t_1\ [x \mapsto s]t_2$。

       - 对应的无名项也是分别替换。

   - **结论**：

     - 通过归纳，证明替换操作在普通项和无名项之间保持一致。

---

#### 6.3 **求值 (Evaluation)**

为了在无名项上定义求值关系，我们需要修改的是 beta-约简规则，因为它是涉及变量名的地方。

---

**关键点：**

- 在约简 redex（可约项）时，绑定变量被“消耗”掉，即在替换后，绑定变量不再存在。
- 因此，我们需要调整替换结果中的变量索引，考虑到上下文的变化。

**示例：**

- 考虑项：

  $$
  (\lambda.\ 1\ 0\ 2)\ (\lambda.\ 0) \longrightarrow 0\ (\lambda.\ 0)\ 1
  $$

  - 注意，我们需要在替换后对结果进行负移位 $\uparrow^{-1}$。

---

**修正后的 beta-约简规则：**

- **规则 E-AppAbs：**

  $$
  (\lambda.\ t_{12})\ v_2 \longrightarrow \uparrow^{-1}([0 \mapsto \uparrow^1(v_2)]t_{12})
  $$

  - 在替换后，对结果进行一次负移位，以调整变量索引。

---

#### **习题 6.3.1 [«]：我们是否需要担心该规则中的负移位可能会产生包含负索引的不良格式的项？**

**解答：**

- **不需要担心**，因为负移位只会减少自由变量的索引，而不会影响绑定变量的索引。
- 在正确的上下文中，变量索引不会变为负值。

---

#### **习题 6.3.2 [«««]：de Bruijn 的原始文章实际上包含了两种无名项的表示提议：本文介绍的 de Bruijn 指数（从内到外编号 lambda 绑定），以及 de Bruijn 层级（从外到内编号绑定）。例如，项 $\lambda x.\ (\lambda y.\ x\ y)\ x$ 用 de Bruijn 指数表示为 $\lambda.\ (\lambda.\ 1\ 0)\ 0$，用 de Bruijn 层级表示为 $\lambda.\ (\lambda.\ 0\ 1)\ 0$。精确定义这种变体，并证明使用指数和层级表示的项是同构的（即，每个都可以唯一地从另一个恢复）。**

**解答：**

1. **定义 de Bruijn 层级：**

   - **概念**：使用自然数表示变量，其中数字 $k$ 表示“从最外层开始的第 $k$ 个 $\lambda$ 绑定的变量”。
   - **计数方式**：从外到内，最外层的绑定变量索引为 $0$。

2. **示例：**

   - 项 $\lambda x.\ (\lambda y.\ x\ y)\ x$：

     - **de Bruijn 指数**：$\lambda.\ (\lambda.\ 1\ 0)\ 0$

     - **de Bruijn 层级**：$\lambda.\ (\lambda.\ 0\ 1)\ 0$

3. **证明同构性：**

   - **构建映射**：

     - 从 de Bruijn 指数到层级：

       - 层级索引 $k_{level} = n_{binders} - 1 - k_{index}$，其中 $n_{binders}$ 是总的绑定数量。

     - 从层级到指数：

       - 指数索引 $k_{index} = n_{binders} - 1 - k_{level}$。

   - **示例验证**：

     - 对于 $\lambda.\ (\lambda.\ 1\ 0)\ 0$：

       - 总绑定数量 $n_{binders} = 2$。

       - 变量索引转换：

         - $k_{level} = 2 - 1 - k_{index}$

         - $k_{level}(1) = 0$

         - $k_{level}(0) = 1$

       - 得到层级表示 $\lambda.\ (\lambda.\ 0\ 1)\ 0$

   - **结论**：

     - 两种表示之间存在一一对应的关系，可以相互转换。

---

### **总结**

- **无名项表示**：通过使用 de Bruijn 指数，我们消除了变量名，直接使用数字表示变量的绑定关系。
- **移位和替换**：定义了在无名项上进行移位和替换的操作，确保在替换和求值过程中变量索引的正确性。
- **求值规则**：修改了 beta-约简规则，以适应无名项的替换操作，并确保求值过程的正确性。

---

**如果您对上述内容有任何疑问或需要进一步的解释，请随时提问！**

### ---------------------------

好的！为了清楚区分 **de Bruijn 指数** 和 **de Bruijn 层级**，我将从多个角度（定义、编号方式、应用场景、优缺点、例子）进行详细对比，展示它们的差异和使用情况。表格中的内容将用 $key word$ 来标注特殊字符和关键字。

### **对比表：de Bruijn 指数 vs de Bruijn 层级**

| **角度**         | **de Bruijn 指数**                                           | **de Bruijn 层级**                                           |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **定义**         | $de\ Bruijn\ 指数$ 是从**内到外**编号的方式，编号表示从变量到其绑定的 $lambda$ 的距离。 | $de\ Bruijn\ 层级$ 是从**外到内**编号，编号表示 $lambda$ 绑定变量的位置。 |
| **编号方式**     | 从当前变量向上，逐级查找其绑定的 $lambda$ 表达式，距离越远，编号越大。 | 从最外层的 $lambda$ 开始编号，最外层的变量编号为 0，越内层编号越大。 |
| **计算过程**     | 计算过程中变量的 $de\ Bruijn\ 指数$ 通过递归向上查找绑定的层次。 | 编号从外部开始，遇到新 $lambda$ 时逐步递增。                 |
| **应用场景**     | 在实现递归的表达式求值和变量绑定时，方便快速定位变量绑定。   | 在解释器设计中，帮助理解变量在不同层级的作用域。             |
| **优点**         | 紧凑、明确，可以通过简单的整数表示变量绑定关系。             | 易于理解变量的作用范围，特别是在多层嵌套 $lambda$ 的情况下。 |
| **缺点**         | 当表达式层次较深时，编号可能很大，影响可读性。               | 编号从外部逐渐变大，可能在层级较多时难以追踪。               |
| **表达式的表示** | 使用 $de\ Bruijn\ 指数$ 的表达式省略了变量名，通过整数来表示变量位置。 | 使用 $de\ Bruijn\ 层级$ 的表达式以逐层递增的编号来表示变量位置。 |
| **典型应用**     | 用于编译器和解释器中的自由变量绑定、替换、求值。             | 常用于静态分析、作用域管理和上下文跟踪。                     |
| **处理绑定变量** | $de\ Bruijn\ 指数$ 更适合动态环境中处理绑定变量和自由变量的替换。 | $de\ Bruijn\ 层级$ 更适合静态的上下文处理，能够清晰地跟踪层次关系。 |
| **例子**         | 在表达式 $((lambda\ x.(lambda\ y.x))\ z)$ 中，$x$ 的 $de\ Bruijn\ 指数$ 为 1。 | 在同样的表达式中，$x$ 的 $de\ Bruijn\ 层级$ 为 0，$y$ 的层级为 1。 |

### **示例表达式：**

考虑以下 Lambda 表达式：

$$((lambda\ x.(lambda\ y.x))\ z)$$

#### 1. **使用 de Bruijn 指数**：
- 在这个表达式中：
  - $x$ 的 $de\ Bruijn\ 指数$ 是 1，因为它距离它绑定的 $lambda\ x$ 只有一步。
  - $y$ 的 $de\ Bruijn\ 指数$ 是 0，因为它是当前最内层的绑定变量。

#### 2. **使用 de Bruijn 层级**：
- 在这个表达式中：
  - $x$ 的 $de\ Bruijn\ 层级$ 是 0，因为它是最外层的绑定变量。
  - $y$ 的 $de\ Bruijn\ 层级$ 是 1，因为它是在 $x$ 的 $lambda$ 之内的一个绑定变量。

### 总结

- **de Bruijn 指数** 是从内到外追溯变量的绑定关系，非常适合表达式求值和动态处理绑定。
- **de Bruijn 层级** 是从外到内编号的方式，更适合静态分析和层次较清晰的场景。
- 通过这两种方式，可以更好地处理和分析 Lambda 表达式中的变量作用域和绑定关系。

希望这个对比表能够清楚地展示 $de\ Bruijn\ 指数$ 和 $de\ Bruijn\ 层级$ 的区别与应用！

### ----------------------------

好的！我们将从头开始，详细讲解**移位 (Shifting)** 的概念和它在 Lambda 演算（特别是使用 **de Bruijn 指数** 的无名项表示）中的作用和操作。整个过程将从基础定义到具体应用，逐步展开。

---

### **1. 什么是移位 (Shifting)?**

在 Lambda 演算中，移位操作的目的是为了调整**自由变量**的**de Bruijn 指数**，使它们在表达式嵌套或移动到更深的作用域时，保持正确的绑定关系。

#### **de Bruijn 指数简介**：
- 在普通 Lambda 表达式中，变量是通过名字（如 $x$, $y$）来表示的。然而，使用变量名有时会引发问题，例如变量名冲突和捕获问题。
- **de Bruijn 指数** 是一种消除变量名的方法，用整数表示变量相对于其绑定 $lambda$ 的距离。例如，`0` 表示最内层的绑定变量，`1` 表示引用了外层的绑定变量，依此类推。

#### **移位的基本概念**：
- 移位的主要目的是处理**自由变量**。当表达式中的自由变量被嵌套到新的作用域中（即更深的 $lambda$ 中）时，必须调整它们的 de Bruijn 索引，表示它们与新的作用域的距离发生了变化。
- 绑定变量不受影响，因为它们的作用域已经在当前 $lambda$ 中被绑定。

---

### **2. 移位的场景与动机**

移位操作通常出现在两种场景中：

1. **嵌套表达式**：当我们将一个表达式嵌入到另一个表达式中时，表达式中的自由变量会相对于新的上下文变得更远，因此需要调整这些自由变量的 de Bruijn 索引。
   
   例如：如果我们有一个自由变量 $x$，其索引为 0。当这个自由变量被放入一个新的 $lambda$ 表达式时，它的索引需要增加，表示它现在处于更深的作用域中。

2. **替换操作**：在 Lambda 演算中，替换是将某个绑定变量替换为另一个表达式。为了防止自由变量被错误地捕获，替换时需要对替换项进行移位操作，确保它的自由变量保持正确的绑定关系。

---

### **3. 移位操作的定义**

我们可以将移位看作是一个递归操作，它遍历表达式中的每个部分，根据当前的上下文深度调整变量的索引。移位函数的形式可以表示为：

$$shift(d, t)$$

- **$d$** 是移位的量，表示我们希望将自由变量的索引增加多少。
- **$t$** 是表达式（项，term），可能是一个变量 ($Var$)、一个抽象 ($Abs$)，或者是一个应用 ($App$)。

#### **递归定义：**

移位操作需要递归地遍历表达式的结构，处理每个变量和表达式。

- **变量 (Var)**：如果变量是自由变量（即它的索引大于或等于当前深度 $c$），则将其索引增加 $d$。否则，变量是绑定变量，不需要移位。
  
  规则：如果 $x \geq c$，则将 $x$ 替换为 $x + d$；否则保持 $x$ 不变。

- **抽象 (Abs)**：对于 Lambda 抽象 $lambda$，递归处理它的主体部分，同时将深度 $c$ 增加 1，因为我们进入了一个新的绑定层次。

- **应用 (App)**：对于应用项 $App(t1, t2)$，递归地对 $t1$ 和 $t2$ 分别进行移位。

---

### **4. 具体的移位算法**

#### **伪代码形式**：

```plaintext
shift(d, t, c) =
  case t of
    Var(x, n) ->
      if x >= c then Var(x + d, n + d)  (* 自由变量，移位索引 *)
      else Var(x, n)                    (* 绑定变量，不移位 *)
      
    Abs(x, t1) ->
      Abs(x, shift(d, t1, c + 1))       (* 对主体进行移位，深度加 1 *)
      
    App(t1, t2) ->
      App(shift(d, t1, c), shift(d, t2, c))  (* 对应用项的两个子项递归移位 *)
```

#### **参数解释**：

- **$d$**：移位量，表示我们希望自由变量的 de Bruijn 索引增加多少。
- **$t$**：项，表示当前正在处理的 Lambda 表达式。
- **$c$**：当前的深度，表示我们当前位于哪个层次的 $lambda$ 表达式中。初始时通常为 0。

#### **详细步骤**：

1. **变量 (Var) 情况**：
   - 如果变量的索引 $x$ 大于或等于当前深度 $c$，则它是一个自由变量，需要将索引 $x$ 增加 $d$。
   - 如果 $x < c$，则它是一个绑定变量，不需要移位。

2. **抽象 (Abs) 情况**：
   - 每遇到一个新的 $lambda$，我们就进入了一个新的作用域。为了保持正确的索引，深度 $c$ 需要增加 1，并递归处理主体。

3. **应用 (App) 情况**：
   - 应用项的左右子项分别进行移位操作。每个子项都需要根据当前的深度 $c$ 递归地移位。

---

### **5. 移位示例：**

让我们通过一个具体的例子来演示移位的过程。

#### **示例表达式：**

考虑表达式：

$$ \lambda x. (\lambda y. x) $$

这可以转换为 de Bruijn 索引的无名项表示：

$$ Abs(Abs(Var(1, 2))) $$

- $x$ 是由最外层的 $lambda$ 绑定的，其 de Bruijn 索引为 1。
- $y$ 是由内层的 $lambda$ 绑定的，其 de Bruijn 索引为 0。

现在，假设我们要对这个表达式进行移位操作，移位量 $d = 1$。

#### **移位过程：**

1. **处理最外层的 $Abs$**：

   最外层是一个抽象 $Abs$，表示 $lambda x$。

   - 当前深度 $c = 0$。
   - 我们递归处理其主体，深度 $c$ 增加 1，变为 $c = 1$。

2. **处理内层的 $Abs$**：

   内层是另一个抽象 $Abs$，表示 $lambda y$。

   - 当前深度 $c = 1$。
   - 递归处理它的主体，深度 $c$ 再次增加 1，变为 $c = 2$。

3. **处理变量 $Var(1)$**：

   现在我们处理变量 $Var(1)$，它引用的是外层的 $lambda x$，索引为 1。

   - 当前深度 $c = 2$。
   - 因为变量 $1$ 的索引 $1$ 小于当前深度 $c = 2$，说明它是一个绑定变量，不需要移位。

因此，经过移位操作后，结果仍然是：

$$ Abs(Abs(Var(1, 3))) $$

这里 $Var(1)$ 保持不变，因为它是一个绑定变量。

---

### **6. 何时需要移位？**

移位操作的典型应用场景包括：

1. **嵌套表达式**：当我们将一个含有自由变量的表达式嵌套到更深的作用域中时，需要对这些自由变量进行移位操作。
   
   例如：如果我们有一个自由变量 $x$，其索引为 0，当它被嵌入到一个新的 $lambda$ 表达式中时，它的索引应增加到 1。

2. **替换操作**：在进行替换时，新的替换项中的自由变量需要进行移位，确保它们在新的作用域中保持正确的绑定关系。

---

### **7. 结论与回顾**

- **移位 (Shifting)** 是 Lambda 演算中的一种基本操作，尤其是在使用 de Bruijn 索引表示的无名项中，它用于处理变量在不同作用域中的引用问题。
- 移位的主要目的是调整**自由变量**的 de Bruijn 索引，以反映它们在嵌套或替换过程中的作用域变化。
- 通过递归处理表达式的每个部分，我们可以确保自由变量正确移位，而绑定变量保持不变。

希望

通过这个详细的讲解，你已经对移位的概念和操作有了全面的理解。如果还有任何问题，欢迎继续提问！

### ---------------------------

**de Bruijn 指数 (de Bruijn Indices)** 和 **de Bruijn 层级 (de Bruijn Levels)** 是两种不同的无名变量表示方式，它们都用于消除 Lambda 演算中的变量名称，但方式略有不同。为了帮助你理解它们的区别，我将提供详细的讲解和几个例子进行对比。

---

### **1. de Bruijn 指数 (de Bruijn Indices)**

**de Bruijn 指数**通过整数来表示**变量的相对深度**，也就是从**当前的 $lambda$ 绑定到该变量的距离**。离当前 $lambda$ 最近的变量用 `0` 表示，离当前 $lambda$ 再远一层的变量用 `1` 表示，依此类推。

#### **de Bruijn 指数的特点**：
- 索引从 `0` 开始，表示当前作用域中的最内层绑定的变量。
- 更高的索引表示变量与其绑定的 $lambda$ 之间的距离增加。

#### **示例**：

考虑表达式：

$$ \lambda x. (\lambda y. x) $$

在这个表达式中，$x$ 是外层的 $lambda$ 绑定的变量，$y$ 是内层的 $lambda$ 绑定的变量。

- 使用 **de Bruijn 指数** 表示：
  
  $$ \lambda. (\lambda. 1) $$

  解释：
  - 最内层的 $lambda y$ 绑定的变量 $y$ 被表示为 `0`，但是 `y` 没有被使用。
  - 内层表达式 `x` 被引用，它是外层的 $lambda x$ 绑定的变量，因此它的 de Bruijn 索引是 `1`，表示它引用了外层的 $lambda$。

#### **另一个例子：**

$$ \lambda x. (\lambda y. (\lambda z. x)) $$

- 使用 **de Bruijn 指数** 表示：

  $$ \lambda. (\lambda. (\lambda. 2)) $$

  解释：
  - 这里有三层嵌套的 $lambda$ 表达式。
  - 最内层的表达式引用了最外层的变量 $x$，它与当前的 $lambda$ 相隔两层，因此其索引是 `2`。

---

### **2. de Bruijn 层级 (de Bruijn Levels)**

**de Bruijn 层级**则表示变量相对于整个表达式的**全局位置**，而不是相对于当前 $lambda$ 的距离。每个变量的层级表示它在整个表达式中被绑定的深度。

#### **de Bruijn 层级的特点**：
- 层级从外到内编号，表示该变量是在整体表达式的第几层被绑定的。
- 层级是从整个表达式的**最外层**往内数，而不是相对于当前 $lambda$ 表达式。

#### **示例**：

我们还是使用相同的表达式：

$$ \lambda x. (\lambda y. x) $$

- 使用 **de Bruijn 层级** 表示：

  $$ \lambda. (\lambda. 0) $$

  解释：
  - 这里 $x$ 是在表达式的第 0 层绑定的（即最外层的 $lambda$），所以它的层级是 `0`。
  - 内层的 $lambda y$ 没有使用变量。

#### **另一个例子：**

$$ \lambda x. (\lambda y. (\lambda z. x)) $$

- 使用 **de Bruijn 层级** 表示：

  $$ \lambda. (\lambda. (\lambda. 0)) $$

  解释：
  - 变量 $x$ 是在最外层的 $lambda$ 表达式绑定的，因此它的层级是 `0`，即使它出现在最内层的 $lambda$ 表达式中。

---

### **3. 对比与区别**

| **对比点**       | **de Bruijn 指数 (de Bruijn Indices)**                       | **de Bruijn 层级 (de Bruijn Levels)**                |
| ---------------- | ------------------------------------------------------------ | ---------------------------------------------------- |
| **变量表示方式** | 表示变量相对于其绑定的 $lambda$ 的距离                       | 表示变量相对于整个表达式的全局位置                   |
| **编号顺序**     | 从内到外，索引从当前 $lambda$ 开始计数，离当前 $lambda$ 越近索引越小 | 从外到内，索引表示变量在哪一层 $lambda$ 被绑定       |
| **常用场景**     | 常用于局部处理，如替换和局部作用域的分析                     | 常用于全局分析，特别是在需要全局变量绑定信息的场景   |
| **变量捕获问题** | 通过相对位置处理绑定变量和自由变量的引用                     | 通过全局层级处理绑定变量，不容易受到局部作用域的影响 |
| **计算复杂度**   | 每次引用都需要根据作用域动态计算                             | 引用是全局的，绑定关系可以直接通过层级确定           |

---

### **4. 实例对比**

#### **例 1**：

```text
λx. (λy. x)
```

- **de Bruijn 指数表示**：

  ```text
  λ. (λ. 1)
  ```

  - `1` 表示 $x$ 是外层绑定的变量，离当前 $lambda y$ 一层。

- **de Bruijn 层级表示**：

  ```text
  λ. (λ. 0)
  ```

  - `0` 表示 $x$ 是在第 0 层绑定的，即最外层。

#### **例 2**：

```text
λx. (λy. (λz. x))
```

- **de Bruijn 指数表示**：

  ```text
  λ. (λ. (λ. 2))
  ```

  - `2` 表示 $x$ 与当前 $lambda z$ 相隔两层，是外层的 $lambda x$ 绑定的。

- **de Bruijn 层级表示**：

  ```text
  λ. (λ. (λ. 0))
  ```

  - `0` 表示 $x$ 是在最外层绑定的。

#### **例 3：更多复杂表达式**

考虑更复杂的表达式：

```text
λx. (λy. (λz. y z x))
```

- **de Bruijn 指数表示**：

  ```text
  λ. (λ. (λ. 1 0 2))
  ```

  解释：
  - `1` 表示 $y$ 是内层绑定的变量，与当前 $lambda z$ 相隔一层。
  - `0` 表示 $z$ 是最内层绑定的变量。
  - `2` 表示 $x$ 是外层绑定的变量。

- **de Bruijn 层级表示**：

  ```text
  λ. (λ. (λ. 1 0 0))
  ```

  解释：
  - `1` 表示 $y$ 是在第 1 层被绑定的变量。
  - `0` 表示 $z$ 和 $x$，它们分别在当前层（第 2 层）和最外层（第 0 层）绑定。

---

### **5. 总结**

- **de Bruijn 指数** 是一种**局部视角**，它表示变量相对于当前作用域的距离，适合局部分析和替换操作。
- **de Bruijn 层级** 是一种**全局视角**，表示变量在哪一层被绑定，适合全局分析和对绑定关系的全局理解。

两者的主要区别在于它们如何表示变量的绑定关系：**de Bruijn 指数** 是相对的，随作用域的变化而动态调整；而 **de Bruijn 层级** 是全局的，固定表示某个变量在整个表达式中的绑定层次。

### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------
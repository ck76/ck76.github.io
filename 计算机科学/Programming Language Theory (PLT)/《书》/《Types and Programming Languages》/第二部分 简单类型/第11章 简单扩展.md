[toc]



### 第11章 **简单扩展** (Simple Extensions)

本章介绍了简单类型 λ 演算（Simply Typed Lambda-Calculus）的几个常用扩展，这些扩展在类型层面有直接的处理方法。贯穿本章的一个重要主题是**派生形式**（derived forms）的概念。

---

#### 11.1 **基本类型** (Base Types)

**概述：**

- **基本类型**（Base Types）是编程语言提供的一些简单的、无结构的值的集合，如数字（numbers）、布尔值（booleans）或字符（characters）。
- 我们已经详细研究了自然数和布尔值；语言设计者可以以相同的方式添加任意多的基本类型。

**添加新的基本类型：**

- 除了之前的 $Bool$ 和 $Nat$，我们有时还会使用基本类型 $String$（字符串，如 `"hello"`）和 $Float$（浮点数，如 `3.14159`）来丰富示例。

**抽象化基本类型：**

- 出于理论目的，我们通常将特定基本类型的细节抽象掉，假设我们的语言配备了一组**未解释的**（uninterpreted）或**未知的**基本类型集合 $A$，且没有任何对它们的基本操作。
- 这可以通过将 $A$ 的元素（由元变量 $A$ 代表）包含在类型的集合中来实现，如 **图11-1** 所示。

---

**图11-1：未解释的基本类型**

$$
\text{扩展 λ→ (9-1)} \\
\text{新语法形式} \\
T ::= \ldots\ \text{types:} \\
\quad A \quad \text{base type}
$$

---

**解释：**

- 使用字母 $A$ 来表示基本类型（Base Types），而不是 $B$，以避免与布尔类型 $Bool$ 混淆。
- 可以将 $A$ 视为**原子类型**（atomic types），这是基本类型的另一种称呼，因为就类型系统而言，它们没有内部结构。

**未解释的类型有用吗？**

- 尽管我们无法直接命名其元素，但我们仍然可以绑定范围在基本类型上的变量。
- 例如，函数：

  $$
  \lambda x:A.\ x;
  $$

  是类型为 $A \rightarrow A$ 的恒等函数（identity function）。

- 同样，函数：

  $$
  \lambda x:B.\ x;
  $$

  是类型为 $B \rightarrow B$ 的恒等函数。

- 还有函数：

  $$
  \lambda f:A \rightarrow A.\ \lambda x:A.\ f(f(x));
  $$

  是一个将某个给定函数 $f$ 在参数 $x$ 上重复两次的函数，类型为 $(A \rightarrow A) \rightarrow A \rightarrow A$。

---

#### 11.2 **单位类型** (The Unit Type)

**概述：**

- 另一个有用的基本类型是**单位类型**（Unit Type），记作 $Unit$，其元素只有一个，常用在 ML 家族的语言中。
- 与前一节的未解释基本类型不同，$Unit$ 类型以最简单的方式进行解释：我们显式地引入一个单一的元素——项常量 $unit$（小写的 $u$）。

**新语法形式（图11-2）：**

$$
\text{扩展 λ→ (9-1)} \\
\text{新语法形式} \\
t ::= \ldots\ \text{terms:} \\
\quad unit \quad \text{constant unit} \\
v ::= \ldots\ \text{values:} \\
\quad unit \quad \text{constant unit} \\
T ::= \ldots\ \text{types:} \\
\quad Unit \quad \text{unit type}
$$

**新类型规则：**

- 类型规则 $T\text{-Unit}$：

  $$
  \frac{}{\Gamma \vdash unit : Unit} \quad (T\text{-Unit})
  $$

- 该规则表示 $unit$ 是类型 $Unit$ 的一个元素。

**派生形式：**

- 顺序（sequencing）：$t_1; t_2$，定义为：

  $$
  t_1; t_2 \overset{\text{def}}{=} (\lambda x:Unit.\ t_2)\ t_1 \quad \text{其中 } x \notin FV(t_2)
  $$

  - 这里 $x$ 是一个不在 $t_2$ 的自由变量（free variables）集合中的新变量。

---

**图11-2：单位类型**

$$
\text{扩展 λ→ (9-1)} \\
\text{新语法形式} \\
t ::= \ldots\ \text{terms:} \\
\quad unit \quad \text{常量 } unit \\
v ::= \ldots\ \text{values:} \\
\quad unit \quad \text{常量 } unit \\
T ::= \ldots\ \text{types:} \\
\quad Unit \quad \text{单位类型} \\
\text{新类型规则 } \Gamma \vdash t : T \\
\frac{}{\Gamma \vdash unit : Unit} \quad (T\text{-Unit}) \\
\text{新派生形式} \\
t_1; t_2 \overset{\text{def}}{=} (\lambda x:Unit.\ t_2)\ t_1 \quad \text{其中 } x \notin FV(t_2)
$$

---

**解释：**

- 我们将 $unit$ 添加到可能的计算结果值的集合中——实际上，$unit$ 是求值类型为 $Unit$ 的表达式唯一可能的结果。
- 即使在纯函数式语言中，$Unit$ 类型也不是完全没有意义的，但它的主要应用是在具有副作用的语言中，例如对引用单元（reference cells）的赋值（assignment）——我们将在第13章中回到这个主题。
- 在这样的语言中，我们关心的往往是表达式的副作用，而不是其结果；$Unit$ 是此类表达式的适当结果类型。
- 这种对 $Unit$ 的使用类似于 C 和 Java 等语言中的 `void` 类型。名称 `void` 暗示了与空类型 $Bot$（参见§15.4）的联系，但 `void` 的用法实际上更接近于我们的 $Unit$。

---

#### 11.3 **派生形式：顺序和通配符** (Derived Forms: Sequencing and Wildcards)

**顺序（Sequencing）：**

- 在具有副作用的语言中，通常需要按顺序求值两个或多个表达式。
- 顺序符号 $t_1; t_2$ 的效果是先求值 $t_1$，丢弃其无关紧要的结果，然后继续求值 $t_2$。

**形式化顺序的两种方法：**

1. **添加新的语法和规则：**

   - 将 $t_1; t_2$ 作为项语法的新备选项。
   - 添加两个求值规则：

     1. **$E\text{-Seq}$**：

        $$
        \frac{t_1 \rightarrow t_1'}{t_1; t_2 \rightarrow t_1'; t_2} \quad (E\text{-Seq})
        $$

        - 如果 $t_1$ 可以求值到 $t_1'$，那么 $t_1; t_2$ 可以求值到 $t_1'; t_2$。

     2. **$E\text{-SeqNext}$**：

        $$
        \frac{}{unit; t_2 \rightarrow t_2} \quad (E\text{-SeqNext})
        $$

        - 当 $t_1$ 求值到 $unit$ 时，$unit; t_2$ 直接求值为 $t_2$。

   - 添加一个类型规则：

     - **$T\text{-Seq}$**：

       $$
       \frac{\Gamma \vdash t_1 : Unit \quad \Gamma \vdash t_2 : T_2}{\Gamma \vdash t_1; t_2 : T_2} \quad (T\text{-Seq})
       $$

       - 如果 $t_1$ 的类型为 $Unit$，$t_2$ 的类型为 $T_2$，则 $t_1; t_2$ 的类型为 $T_2$。

2. **将 $t_1; t_2$ 视为一个缩写（abbreviation）：**

   - 认为 $t_1; t_2$ 是项 $(\lambda x:Unit.\ t_2)\ t_1$ 的缩写，其中变量 $x$ 被选择为新鲜的（即不同于 $t_2$ 的所有自由变量）。

**等价性和证明：**

- **直觉上**，这两种表示对程序员来说是等价的：顺序构造的高级类型和求值规则可以从 $t_1; t_2$ 被展开为 $(\lambda x:Unit.\ t_2)\ t_1$ 中推导出来。
- **形式化证明**可以通过证明类型和求值都与缩写的展开“可交换”来捕获这种对应关系。

---

**定理11.3.1（顺序是一个派生形式）：**

- **陈述：**

  - 记 $\lambda_E$（“$E$”表示外部语言）为具有 $Unit$ 类型、顺序构造和规则 $E\text{-Seq}$、$E\text{-SeqNext}$、$T\text{-Seq}$ 的简单类型 λ 演算。
  - 记 $\lambda_I$（“$I$”表示内部语言）为仅具有 $Unit$ 的简单类型 λ 演算。
  - 定义从外部语言到内部语言的展开函数 $e$，通过将每个 $t_1; t_2$ 替换为 $(\lambda x:Unit.\ t_2)\ t_1$，其中 $x$ 在每种情况下都是新鲜的。
  - 对于 $\lambda_E$ 的每个项 $t$，有：
    1. $t \rightarrow_E t'$ 当且仅当 $e(t) \rightarrow_I e(t')$。
    2. $\Gamma \vdash_E t : T$ 当且仅当 $\Gamma \vdash_I e(t) : T$。
  - 其中，$\lambda_E$ 和 $\lambda_I$ 的求值和类型关系分别用下标 $E$ 和 $I$ 注明。

- **证明：**

  - 每个“当且仅当”的每个方向都可以通过对 $t$ 的结构的直接归纳来进行。

**解释：**

- 定理11.3.1 证明了我们使用“派生形式”这一术语的合理性，因为它表明顺序构造的类型和求值行为可以从更基本的抽象和应用操作中推导出来。
- 引入像顺序这样的派生形式，而不是作为完整的语言构造的好处在于，我们可以扩展**表面语法**（即程序员实际用来编写程序的语言），而不增加需要证明类型安全性定理的内部语言的复杂性。
- 这种语言特性描述的分解方法可以在 Algol 60 报告（Naur et al., 1963）中找到，并在许多最近的语言定义中被大量使用，特别是标准 ML 的定义（Milner, Tofte, and Harper, 1990; Milner, Tofte, Harper, and MacQueen, 1997）。

**派生形式的术语：**

- 派生形式通常被称为**语法糖**（syntactic sugar），遵循 Landin 的说法。
- 将派生形式替换为其低级定义被称为**脱糖**（desugaring）。

---

**通配符（Wildcard）：**

- 另一个在后续示例中有用的派生形式是用于变量绑定器的“通配符”约定。
- 当我们想要编写一个“哑元”（dummy）的 λ 抽象，其中参数变量实际上并未在抽象的主体中使用时，这种情况经常发生（例如，在通过脱糖创建的顺序项中）。
- 在这种情况下，不必显式地为绑定变量选择一个名称是很烦人的；相反，我们希望将其替换为一个通配符绑定器，记作 `_`。
- 即，我们将 $\lambda\ _:S.\ t$ 作为 $\lambda x:S.\ t$ 的缩写，其中 $x$ 是不出现在 $t$ 中的某个变量。

---

#### **习题11.3.2 [«]**

**题目：**

- 给出通配符抽象的类型和求值规则，并证明它们可以从上述缩写中推导出来。

**解答：**

**1. 给出通配符抽象的类型和求值规则**

- **新语法形式：**

  $$
  t ::= \ldots\ \mid \lambda\ _:T.\ t \quad \text{通配符抽象}
  $$

- **类型规则：**

  - **$T\text{-AbsWildcard}$：**

    $$
    \frac{\Gamma \vdash t : T_2}{\Gamma \vdash \lambda\ _:T_1.\ t : T_1 \rightarrow T_2} \quad (T\text{-AbsWildcard})
    $$

    - 由于通配符 `_` 不出现在 $t$ 中，我们不需要在类型环境 $\Gamma$ 中添加任何绑定。

- **求值规则：**

  - 通配符抽象在求值时与普通的 λ 抽象相同，因为求值规则并不依赖于变量名。

  - **应用规则 $E\text{-AppAbs}$：**

    $$
    \frac{}{\left( \lambda\ _:T_{11}.\ t_{12} \right)\ v_2 \rightarrow t_{12}} \quad (E\text{-AppAbsWildcard})
    $$

    - 当应用一个通配符抽象时，由于参数不在主体中使用，直接返回主体 $t_{12}$。

**2. 证明它们可以从缩写中推导出来**

- **通配符抽象的缩写：**

  $$
  \lambda\ _:T_1.\ t \overset{\text{def}}{=} \lambda x:T_1.\ t \quad \text{其中 } x \notin FV(t)
  $$

- **类型规则的推导：**

  - 根据缩写，将通配符抽象展开为标准的 λ 抽象。

  - 使用类型规则 $T\text{-Abs}$：

    $$
    \frac{\Gamma , x:T_1 \vdash t : T_2}{\Gamma \vdash \lambda x:T_1.\ t : T_1 \rightarrow T_2} \quad (T\text{-Abs})
    $$

  - 由于 $x \notin FV(t)$，$t$ 中不包含 $x$，因此我们可以从 $\Gamma$ 推导出 $\Gamma , x:T_1 \vdash t : T_2$，因为 $x$ 未被使用。

  - 但是，根据弱化引理（引理9.3.7）：

    - 如果 $\Gamma \vdash t : T_2$，那么对于任何 $x \notin \text{dom}(\Gamma)$，都有 $\Gamma , x:T_1 \vdash t : T_2$。

  - 因此，类型规则 $T\text{-AbsWildcard}$ 可以从 $T\text{-Abs}$ 和弱化引理推导出来。

- **求值规则的推导：**

  - 求值规则不涉及类型，因此求值规则可以直接应用。

  - 通配符抽象与普通的 λ 抽象在求值时行为相同，因为变量名在求值过程中并不重要。

---

**总结：**

- 我们通过添加新的语法形式和规则，定义了通配符抽象的类型和求值规则。
- 然后，通过将通配符抽象展开为标准的 λ 抽象，使用已有的类型规则和弱化引理，我们证明了这些规则可以从缩写中推导出来。

---

### **附加习题解答**

#### **习题11.2.1 [«««]**

**题目：**

- 是否有办法在只有基本类型 $Unit$ 的简单类型 λ 演算中构造一系列项 $t_1, t_2, \ldots$，使得对于每个 $n$，项 $t_n$ 的大小至多为 $O(n)$，但需要至少 $O(2^n)$ 步求值才能达到正常形式？

**解答：**

**目标：**

- 构造一系列项 $t_n$，满足：

  1. 对于每个 $n$，项 $t_n$ 的大小为 $O(n)$。
  2. 求值 $t_n$ 到正常形式需要至少 $O(2^n)$ 步。

**思路：**

- 我们需要在简单类型 λ 演算中构造一个项，其求值步骤呈指数级增长。

- 由于只有基本类型 $Unit$，我们需要利用函数的嵌套和应用来实现这一点。

**构造：**

- 定义项 $t_n$ 为一个高阶函数，不断嵌套应用自身。

- 具体地，我们可以定义：

  $$
  t_n = (\lambda f:Unit \rightarrow Unit.\ f\ f)\ (\lambda f:Unit \rightarrow Unit.\ f\ f)
  $$

  - 但是这样的项在简单类型 λ 演算中是不可类型化的，因为类型系统不允许函数自身作为参数。

- 为了在简单类型系统中构造需要指数步求值的项，我们可以使用**教堂数**（Church numerals）的概念。

**教堂数的构造：**

- 在 λ 演算中，教堂数 $n$ 表示为：

  $$
  \text{cn}_n = \lambda f:T \rightarrow T.\ \lambda x:T.\ f^n(x)
  $$

  - 其中 $f^n$ 表示函数 $f$ 的 $n$ 次复合。

- 在我们的情况下，由于只有 $Unit$ 类型，我们可以令 $T = Unit$。

- 定义恒等函数：

  $$
  I = \lambda x:Unit.\ x
  $$

- 定义函数 $G = \lambda f:Unit \rightarrow Unit.\ f\ f$

  - 但在简单类型系统中，这个函数不可类型化。

- **改进方案：**

  - 我们可以定义一个能够模拟指数级增长的项，例如使用固定组合子。

- **有限的可能性：**

  - 由于简单类型 λ 演算是强规范化的（strongly normalizing），所有类型良好的项都保证在有限步内归约到正常形式。

- **结论：**

  - **在只有基本类型 $Unit$ 的简单类型 λ 演算中，不可能构造满足题目要求的项序列。**

- **理由：**

  - 因为在简单类型 λ 演算中，所有类型良好的项都是强规范化的，其归约步骤的数量是多项式级别的，无法达到指数级增长。

---

### **小结**

- 本章介绍了简单类型 λ 演算的几个常用扩展，包括未解释的基本类型、单位类型和派生形式（如顺序和通配符）。
- 我们探讨了如何使用派生形式来扩展语言的表面语法，而不增加内部语言的复杂性，从而有助于证明类型安全性等性质。
- 通过对习题的解答，我们加深了对这些概念的理解，并认识到简单类型 λ 演算的限制和特性。

---

**参考文献：**

- Naur, P., et al. (1963). Report on the Algorithmic Language ALGOL 60.
- Milner, R., Tofte, M., & Harper, R. (1990). The Definition of Standard ML.
- Milner, R., Tofte, M., Harper, R., & MacQueen, D. (1997). The Definition of Standard ML (Revised).

---

**如果您对上述内容有任何疑问，或者希望进一步讨论，请随时提出！**

### ---------------------------

### 第11章 **简单扩展** (Simple Extensions)

---

本章介绍了简单类型 λ 演算（Simply Typed Lambda-Calculus）的几个常用扩展，这些扩展在类型层面有直接的处理方法。贯穿本章的一个重要主题是**派生形式**（derived forms）的概念。

---

#### 11.4 **类型断言** (Ascription)

**概述：**

- 类型断言（Ascription）是一个简单但常用的特性，它允许我们显式地为给定的项指定一个特定的类型。
- 我们使用 `t \text{ as } T` 来表示“将类型 $T$ 断言给项 $t$”。
- 类型规则 $T\text{-Ascribe}$ 和求值规则 $E\text{-Ascribe}$ 定义了类型断言的行为。

---

##### **图11-3：类型断言**

$$
\text{→ as 扩展 λ→ (9-1)}
$$

**新语法形式**

$$
\begin{align*}
t &::= \ldots\ \text{terms:} \\
&\quad t\ \text{as}\ T \quad \text{ascription}
\end{align*}
$$

**新求值规则** $t \rightarrow t'$

1. **$E\text{-Ascribe}$：**

   $$
   \frac{}{\textcolor{blue}{v_1\ \text{as}\ T\ \rightarrow\ v_1}} \quad (E\text{-Ascribe})
   $$

   - 当项为值 $v_1$ 断言类型 $T$ 时，直接去掉类型断言，返回 $v_1$。

2. **$E\text{-Ascribe1}$：**

   $$
   \frac{t_1 \rightarrow t_1'}{\textcolor{blue}{t_1\ \text{as}\ T\ \rightarrow\ t_1'\ \text{as}\ T}} \quad (E\text{-Ascribe1})
   $$

   - 如果 $t_1$ 可以求值为 $t_1'$，那么 $t_1\ \text{as}\ T$ 可以求值为 $t_1'\ \text{as}\ T$。

**新类型规则** $\Gamma \vdash t : T$

- **$T\text{-Ascribe}$：**

  $$
  \frac{\Gamma \vdash t_1 : T}{\textcolor{blue}{\Gamma \vdash t_1\ \text{as}\ T : T}} \quad (T\text{-Ascribe})
  $$

  - 如果 $t_1$ 的类型是 $T$，那么 $t_1\ \text{as}\ T$ 的类型也是 $T$。

---

**解释：**

- **用途：**

  - **文档化**：在大型复合表达式中，使用类型断言可以帮助读者跟踪子表达式的类型，提高程序的可读性。
  - **调试**：当编写复杂表达式时，程序员可能不清楚所有子表达式的类型，添加类型断言可以明确程序员的想法，有助于定位类型错误的来源。
  - **控制类型打印**：在类型检查器中，类型断言可以用于控制复杂类型的打印方式，例如使用类型缩写。

- **类型检查行为：**

  - 在处理类型断言 $t\ \text{as}\ T$ 时，类型检查器首先展开 $T$ 中的任何类型缩写，验证 $t$ 的类型确实是 $T$，然后将 $T$ 本身（精确到书写形式）作为类型断言的类型。

- **求值行为：**

  - 求值时，类型断言不会影响项的求值过程，它在求值时被简单地丢弃。

---

**示例：**

- 定义类型缩写：

  $$
  \text{UU} = Unit \rightarrow Unit;
  $$

- 使用类型缩写的项：

  $$
  (\lambda f:\text{UU}.\ f\ unit)\ (\lambda x:Unit.\ x);
  $$

- 控制类型打印：

  - 如果希望类型打印为 $\text{UU} \rightarrow \text{UU}$，可以：

    1. 更改抽象中的类型注释：

       $$
       \lambda f:\text{UU}.\ f;
       $$

    2. 或者对整个抽象添加类型断言：

       $$
       (\lambda f:Unit \rightarrow Unit.\ f)\ \text{as}\ \text{UU} \rightarrow \text{UU};
       $$

---

#### **习题11.4.1 [推荐, ««]**

**题目：**

1. 展示如何将类型断言表示为一个派生形式。证明这里给出的“官方”类型和求值规则在适当的意义下对应于你的定义。
2. 假设我们没有给出规则 $E\text{-Ascribe}$ 和 $E\text{-Ascribe1}$，而是给出了一个“急切的”规则：

   $$
   \frac{}{\textcolor{blue}{t_1\ \text{as}\ T\ \rightarrow\ t_1}} \quad (E\text{-AscribeEager})
   $$

   立即在遇到类型断言时丢弃它。类型断言还能被视为一个派生形式吗？

---

**解答：**

**1. 将类型断言表示为派生形式**

- **定义：**

  将类型断言 $t\ \text{as}\ T$ 视为项 $t$ 的一个缩写，即：

  $$
  t\ \text{as}\ T \overset{\text{def}}{=} (\lambda x:T.\ x)\ t
  $$

  - 其中，$\lambda x:T.\ x$ 是类型为 $T \rightarrow T$ 的恒等函数。

- **证明对应性：**

  - **类型规则对应性：**

    - **展开后的项：** $(\lambda x:T.\ x)\ t$

    - **类型推导：**

      1. 假设 $\Gamma \vdash t : T$。

      2. 通过 $T\text{-Abs}$，我们有：

         $$
         \frac{\Gamma , x:T \vdash x : T}{\Gamma \vdash \lambda x:T.\ x : T \rightarrow T} \quad (T\text{-Abs})
         $$

      3. 通过 $T\text{-App}$，我们有：

         $$
         \frac{\Gamma \vdash \lambda x:T.\ x : T \rightarrow T \quad \Gamma \vdash t : T}{\Gamma \vdash (\lambda x:T.\ x)\ t : T} \quad (T\text{-App})
         $$

      - 这与类型断言的类型规则 $T\text{-Ascribe}$ 一致。

  - **求值规则对应性：**

    - **展开后的项求值：**

      1. 对于值 $v$：

         $$
         (\lambda x:T.\ x)\ v \rightarrow [x \mapsto v]\ x = v \quad (E\text{-AppAbs})
         $$

         - 这对应于 $E\text{-Ascribe}$，即 $v\ \text{as}\ T \rightarrow v$。

      2. 对于非值 $t$：

         - 如果 $t$ 还可以求值，即 $t \rightarrow t'$，则：

           $$
           (\lambda x:T.\ x)\ t \rightarrow (\lambda x:T.\ x)\ t' \quad (E\text{-App1})
           $$

         - 这对应于 $E\text{-Ascribe1}$，即 $t\ \text{as}\ T \rightarrow t'\ \text{as}\ T$。

**2. 使用急切的求值规则**

- **新的求值规则：**

  $$
  \frac{}{\textcolor{blue}{t_1\ \text{as}\ T\ \rightarrow\ t_1}} \quad (E\text{-AscribeEager})
  $$

- **分析：**

  - 现在，类型断言在遇到时立即被丢弃，无论 $t_1$ 是否为值。

- **能否作为派生形式？**

  - **不能**。

  - **理由：**

    - 在我们的派生形式中，类型断言被定义为 $(\lambda x:T.\ x)\ t$。

    - 但在展开后，$(\lambda x:T.\ x)\ t$ 的求值需要先对 $t$ 进行求值，直到它成为值，然后才能应用 $E\text{-AppAbs}$。

    - 因此，展开后的项在求值时，类型断言不会立即被丢弃，而是等待 $t$ 求值完成。

  - **结论：**

    - 如果类型断言的求值规则是急切的，则它不能被表示为上述派生形式。

---

#### 11.5 **Let 绑定** (Let Bindings)

**概述：**

- 在编写复杂表达式时，给某些子表达式命名可以避免重复，提高可读性。
- 大多数语言都提供一种或多种方式来实现这一点。
- 在 ML 中，我们使用 `let x = t_1 \text{ in } t_2` 来表示“求值表达式 $t_1$，将结果值绑定到名称 $x$，然后在求值 $t_2$ 时使用该绑定”。

---

##### **图11-4：Let 绑定**

$$
\text{→ let 扩展 λ→ (9-1)}
$$

**新语法形式**

$$
\begin{align*}
t &::= \ldots\ \text{terms:} \\
&\quad \text{let } x = t_1\ \text{in}\ t_2 \quad \text{let binding}
\end{align*}
$$

**新求值规则** $t \rightarrow t'$

1. **$E\text{-LetV}$：**

   $$
   \frac{}{\textcolor{blue}{\text{let } x = v_1\ \text{in}\ t_2\ \rightarrow\ [x \mapsto v_1] t_2}} \quad (E\text{-LetV})
   $$

   - 当 $t_1$ 求值为值 $v_1$ 时，将 $x$ 替换为 $v_1$，然后继续求值 $t_2$。

2. **$E\text{-Let}$：**

   $$
   \frac{t_1 \rightarrow t_1'}{\textcolor{blue}{\text{let } x = t_1\ \text{in}\ t_2\ \rightarrow\ \text{let } x = t_1'\ \text{in}\ t_2}} \quad (E\text{-Let})
   $$

   - 如果 $t_1$ 可以求值为 $t_1'$，则更新 $t_1$，继续保持 let 绑定。

**新类型规则** $\Gamma \vdash t : T$

- **$T\text{-Let}$：**

  $$
  \frac{\Gamma \vdash t_1 : T_1 \quad \Gamma , x : T_1 \vdash t_2 : T_2}{\textcolor{blue}{\Gamma \vdash \text{let } x = t_1\ \text{in}\ t_2 : T_2}} \quad (T\text{-Let})
  $$

  - 首先计算 $t_1$ 的类型 $T_1$，然后在扩展了 $x : T_1$ 的上下文中计算 $t_2$ 的类型 $T_2$。

---

**解释：**

- **求值顺序：**

  - 我们的 let 绑定选择了**传值调用**（call-by-value）的求值顺序，即 let 绑定的项必须在开始求值 let 主体之前被完全求值。

- **类型检查过程：**

  - 通过计算 $t_1$ 的类型 $T_1$，然后在扩展了 $x : T_1$ 的上下文中计算 $t_2$ 的类型 $T_2$。

---

#### **习题11.5.1 [推荐, «««]**

**题目：**

- `letexercise` 类型检查器（可在书的网络资源中找到）是一个不完整的 let 表达式实现：提供了基本的解析和打印函数，但 `eval1` 和 `typeof` 函数中缺少了对 `TmLet` 的子句（取而代之的是匹配所有内容并使用断言失败使程序崩溃的虚拟子句）。
- 完成它。

---

**解答：**

**1. 完善 `eval1` 函数中的 `TmLet` 子句**

```ocaml
let rec eval1 ctx t =
  match t with
  | TmLet(fi, x, t1, t2) ->
      if isval ctx t1 then
        let v1 = t1 in
        termSubstTop v1 t2
      else
        let t1' = eval1 ctx t1 in
        TmLet(fi, x, t1', t2)
  | _ -> (* existing cases *)
```

- **解释：**

  - 如果 `t1` 是值，则将 `x` 替换为 `v1`（`t1` 的值）并继续求值 `t2`。
  - 如果 `t1` 不是值，则对 `t1` 进行一步求值，然后构造新的 `TmLet`。

**2. 完善 `typeof` 函数中的 `TmLet` 子句**

```ocaml
let rec typeof ctx t =
  match t with
  | TmLet(fi, x, t1, t2) ->
      let tyT1 = typeof ctx t1 in
      let ctx' = addbinding ctx x (VarBind(tyT1)) in
      typeof ctx' t2
  | _ -> (* existing cases *)
```

- **解释：**

  - 首先计算 `t1` 的类型 `tyT1`。
  - 将 `x : tyT1` 添加到上下文中，得到新的上下文 `ctx'`。
  - 在新的上下文中计算 `t2` 的类型。

---

#### **Let 是否可以定义为派生形式？**

**答案：**

- **是的**，正如 Landin 所展示的，let 可以被定义为派生形式，但细节比我们对顺序和类型断言所做的要微妙一些。

**定义：**

- 将 `let x = t_1 \text{ in } t_2` 定义为：

  $$
  \text{let } x = t_1\ \text{in}\ t_2 \overset{\text{def}}{=} (\lambda x:T_1.\ t_2)\ t_1
  $$

  - 注意右边的缩写中包含了类型注释 $T_1$，而左边的 let 表达式中没有。

**问题：**

- 如果我们将派生形式在编译器的解析阶段进行脱糖，那么解析器如何知道在解糖后的内部语言项中的 $\lambda$ 上生成类型注释 $T_1$？

**答案：**

- 这个信息来自类型检查器！
- 我们通过计算 $t_1$ 的类型来发现所需的类型注释。

**形式化：**

- let 构造是一个与之前看到的派生形式略有不同的派生形式：我们应该将其视为类型推导上的一个转换，而不是项上的转换。

**推导转换：**

- 使用 let 的推导：

  $$
  \frac{
    \Gamma \vdash t_1 : T_1 \quad \Gamma , x : T_1 \vdash t_2 : T_2
  }{\Gamma \vdash \text{let } x = t_1\ \text{in}\ t_2 : T_2} \quad (T\text{-Let})
  $$

- 转换为使用抽象和应用的推导：

  $$
  \frac{
    \Gamma , x : T_1 \vdash t_2 : T_2 \quad \Gamma \vdash t_1 : T_1
  }{
    \Gamma \vdash (\lambda x:T_1.\ t_2)\ t_1 : T_2
  } \quad (T\text{-App})
  $$

**结论：**

- let 比我们之前看到的其他派生形式“派生得少一些”：我们可以通过脱糖来推导其求值行为，但其类型行为必须内置于内部语言中。

---

#### **习题11.5.2 [««]**

**题目：**

- 定义 let 作为派生形式的另一种方法可能是立即“执行”它——即将 `let x = t_1 \text{ in } t_2` 视为替换后的主体 `[x \mapsto t_1] t_2` 的缩写。这是个好主意吗？

---

**解答：**

**答案：**

- **这不是一个好主意。**

**理由：**

- 如果直接将 let 定义为替换后的项 `[x \mapsto t_1] t_2`，则会改变程序的语义，特别是在存在副作用或非严格求值的情况下。

- **举例说明：**

  - 假设 $t_1$ 有副作用或计算成本高昂的操作。
  - 直接替换可能会导致 $t_1$ 被求值多次，而不是预期的只求值一次。

- **对比：**

  - 正确的 let 绑定语义要求 $t_1$ 在开始求值 $t_2$ 之前被求值一次，并将结果绑定到 $x$。

- **结论：**

  - 将 let 直接定义为替换是不正确的，因为它改变了程序的求值顺序和副作用行为。

---

#### 11.6 **对偶** (Pairs)

**概述：**

- 为了在语言中表示多个值的集合，我们可以引入**对偶类型**（Product Type），允许将多个值组合在一起。
- 对偶类型也称为乘积类型。

---

##### **图11-5：对偶**

$$
\text{→ } \times \text{ 扩展 λ→ (9-1)}
$$

**新语法形式**

$$
\begin{align*}
t &::= \ldots\ \text{terms:} \\
&\quad \{ t_1,\ t_2 \} \quad \text{pair} \\
&\quad t.\!1 \quad \text{first projection} \\
&\quad t.\!2 \quad \text{second projection} \\
v &::= \ldots\ \text{values:} \\
&\quad \{ v_1,\ v_2 \} \quad \text{pair value} \\
T &::= \ldots\ \text{types:} \\
&\quad T_1 \times T_2 \quad \text{product type}
\end{align*}
$$

**新求值规则** $t \rightarrow t'$

1. **$E\text{-PairBeta1}$：**

   $$
   \frac{}{\textcolor{blue}{\{ v_1,\ v_2 \}.\!1\ \rightarrow\ v_1}} \quad (E\text{-PairBeta1})
   $$

   - 从对偶中投影第一分量。

2. **$E\text{-PairBeta2}$：**
   $$
   \frac{}{\textcolor{blue}{\{ v_1,\ v_2 \}.\!2\ \rightarrow\ v_2}} \quad (E\text{-PairBeta2})
   $$
   
   - 从对偶中投影第二分量。
   
3. **$E\text{-Proj1}$：**

   $$
   \frac{t_1 \rightarrow t_1'}{\textcolor{blue}{t_1.\!1\ \rightarrow\ t_1'.\!1}} \quad (E\text{-Proj1})
   $$

   - 对于非值的投影，对被投影的项求值。

4. **$E\text{-Proj2}$：**

   $$
   \frac{t_1 \rightarrow t_1'}{\textcolor{blue}{t_1.\!2\ \rightarrow\ t_1'.\!2}} \quad (E\text{-Proj2})
   $$

5. **$E\text{-Pair1}$：**

   $$
   \frac{t_1 \rightarrow t_1'}{\textcolor{blue}{\{ t_1,\ t_2 \} \rightarrow \{ t_1',\ t_2 \}}} \quad (E\text{-Pair1})
   $$

   - 对于对偶的第一个分量，若不是值，则对其求值。

6. **$E\text{-Pair2}$：**

   $$
   \frac{t_2 \rightarrow t_2'}{\textcolor{blue}{\{ v_1,\ t_2 \} \rightarrow \{ v_1,\ t_2' \}}} \quad (E\text{-Pair2})
   $$

   - 当第一个分量是值，第二个分量不是值时，对第二个分量求值。

**新类型规则** $\Gamma \vdash t : T$

1. **$T\text{-Pair}$：**

   $$
   \frac{\Gamma \vdash t_1 : T_1 \quad \Gamma \vdash t_2 : T_2}{\textcolor{blue}{\Gamma \vdash \{ t_1,\ t_2 \} : T_1 \times T_2}} \quad (T\text{-Pair})
   $$

   - 对偶的类型是其分量类型的乘积。

2. **$T\text{-Proj1}$：**

   $$
   \frac{\Gamma \vdash t_1 : T_{11} \times T_{12}}{\textcolor{blue}{\Gamma \vdash t_1.\!1 : T_{11}}} \quad (T\text{-Proj1})
   $$

   - 从类型为 $T_{11} \times T_{12}$ 的项中投影第一分量，类型为 $T_{11}$。

3. **$T\text{-Proj2}$：**

   $$
   \frac{\Gamma \vdash t_1 : T_{11} \times T_{12}}{\textcolor{blue}{\Gamma \vdash t_1.\!2 : T_{12}}} \quad (T\text{-Proj2})
   $$

---

**解释：**

- **对偶的构造和解构：**

  - 使用 ${ t_1,\ t_2 }$ 构造一个对偶，包含两个分量 $t_1$ 和 $t_2$。
  - 使用 `t.\!1` 和 `t.\!2` 从对偶中提取第一和第二分量。

- **求值顺序：**

  - 对于对偶的构造，先对第一个分量求值，然后对第二个分量求值。
  - 对于投影，如果被投影的项不是值，先对其求值。

- **类型系统：**

  - 对偶类型 $T_1 \times T_2$ 表示分量类型的乘积。
  - 投影操作的类型根据被投影的分量类型确定。

---

### **总结**

- 本章介绍了简单类型 λ 演算的几个重要扩展，包括类型断言、let 绑定和对偶。
- 通过详细的类型规则和求值规则，我们理解了这些构造在类型系统和求值语义中的作用。
- 我们还探讨了派生形式的概念，以及在语言设计中如何使用派生形式来扩展语言的表面语法，而不增加内部语言的复杂性。

---

**如果您对上述内容有任何疑问，或者希望进一步讨论，请随时提出！**

### ----------------------------

### 11.6 Pairs

#### 概述
在编程语言中，构建复合数据结构的方式很多，其中最简单的是**对**（pair），也称为**笛卡尔积**（Cartesian product）形式。对的形式让我们可以将两个值组合成一个，并能从组合中提取每个单独的值。在这一节中，我们将探讨对的定义、如何通过**投射**（projection）操作来提取对的元素，以及它的类型规则。

#### 语法与类型规则
我们引入了两种新的形式：
- **Pairing**（对的构建）：通过写作 $ \{t_1, t_2\} $ 来构建一个对。
- **Projection**（投射）：通过写作 $ t.1 $ 和 $ t.2 $ 从对 $ t $ 中提取第一个或第二个元素。

在类型系统中，我们引入了新的类型构造符：$ T_1 \times T_2 $，即**积类型**（product type），它表示类型 $ T_1 $ 和 $ T_2 $ 的乘积。投射操作的规则则相对简单：$ t.1 $ 返回 $ t $ 的第一个元素，$ t.2 $ 返回 $ t $ 的第二个元素。

#### 具体规则

**新语法形式**：

$$
t ::= \ldots \mid \{t_1, t_2\} \mid t.1 \mid t.2
$$

- $ \{t_1, t_2\} $：表示一个包含两个元素的对。
- $ t.1 $ 和 $ t.2 $：分别表示从对 $ t $ 中提取第一个和第二个元素。

**新值规则**：

$$
v ::= \ldots \mid \{v_1, v_2\}
$$

这意味着 $ \{v_1, v_2\} $ 是一个值，前提是 $ v_1 $ 和 $ v_2 $ 本身都是值。

**新类型规则**：

- **T-Pair**：
  $$
  \frac{\Gamma \vdash t_1 : T_1 \quad \Gamma \vdash t_2 : T_2}{\Gamma \vdash \{t_1, t_2\} : T_1 \times T_2}
  $$
  意思是，若 $ t_1 $ 的类型是 $ T_1 $ 且 $ t_2 $ 的类型是 $ T_2 $，则 $ \{t_1, t_2\} $ 的类型为 $ T_1 \times T_2 $。

- **T-Proj1**：
  $$
  \frac{\Gamma \vdash t : T_1 \times T_2}{\Gamma \vdash t.1 : T_1}
  $$
  意思是，若 $ t $ 的类型是 $ T_1 \times T_2 $，则 $ t.1 $ 的类型为 $ T_1 $。

- **T-Proj2**：
  $$
  \frac{\Gamma \vdash t : T_1 \times T_2}{\Gamma \vdash t.2 : T_2}
  $$
  类似地，若 $ t $ 的类型是 $ T_1 \times T_2 $，则 $ t.2 $ 的类型为 $ T_2 $。

#### 新的求值规则

- **E-PairBeta1**：
  $$
  \{v_1, v_2\}.1 \rightarrow v_1
  $$
  若对的第一个元素已经是值，则 $ \{v_1, v_2\}.1 $ 直接化简为 $ v_1 $。

- **E-PairBeta2**：
  $$
  \{v_1, v_2\}.2 \rightarrow v_2
  $$
  同样地，$ \{v_1, v_2\}.2 $ 化简为 $ v_2 $。

- **E-Proj1**：
  $$
  t_1 \rightarrow t_1' \quad t_1.1 \rightarrow t_1'.1
  $$
  意思是，如果 $ t_1 $ 能求值为 $ t_1' $，那么 $ t_1.1 $ 也能求值为 $ t_1'.1 $。

- **E-Proj2**：
  类似地：
  $$
  t_1 \rightarrow t_1' \quad t_1.2 \rightarrow t_1'.2
  $$

- **E-Pair1**：
  $$
  t_1 \rightarrow t_1' \quad \{t_1, t_2\} \rightarrow \{t_1', t_2\}
  $$

- **E-Pair2**：
  $$
  t_2 \rightarrow t_2' \quad \{v_1, t_2\} \rightarrow \{v_1, t_2'\}
  $$

这些规则定义了如何逐步对对的各个元素进行求值。

#### 习题讲解
**习题 11.8.1**：
题目要求我们将 $E-ProjRcd$ 规则写得更明确，以下是更明确的表述：

- **更明确的 $E-ProjRcd$ 规则**：
  $$
  \frac{t = \{l_1 = v_1, \ldots, l_n = v_n\} \quad j \in \{1, \ldots, n\}}{t.l_j \rightarrow v_j}
  $$

  这表明，如果 $ t $ 是一个记录，并且 $ j $ 是其第 $ j $ 个字段的标签，那么 $ t.l_j $ 化简为 $ t $ 中第 $ j $ 个字段的值。

---

### 11.7 Tuples

#### 概述
**元组**（tuple）是对的推广，它允许我们将任意数量的值组合成一个复合值。元组的类型是各个元素的类型构成的产品类型。与对类似，元组也有构造与投射操作。我们将定义 n 元组，允许 n 可以为任何整数。

#### 语法与类型规则

**新语法形式**：

$$
t ::= \ldots \mid \{t_i \mid i \in 1..n\} \mid t.i
$$

这里，$ \{t_i \mid i \in 1..n\} $ 表示一个 n 元组，$ t.i $ 表示从元组 $ t $ 中提取第 $ i $ 个元素。

**新值规则**：

$$
v ::= \ldots \mid \{v_i \mid i \in 1..n\}
$$

这意味着 $ \{v_i \mid i \in 1..n\} $ 是一个元组值，前提是 $ v_i $ 都是值。

**新类型规则**：

- **T-Tuple**：
  $$
  \frac{\forall i \in 1..n, \Gamma \vdash t_i : T_i}{\Gamma \vdash \{t_i \mid i \in 1..n\} : \{T_i \mid i \in 1..n\}}
  $$
  该规则说明，若每个 $ t_i $ 都有类型 $ T_i $，则元组 $ \{t_i\} $ 的类型为 $ \{T_i\} $。

- **T-Proj**：
  $$
  \frac{\Gamma \vdash t : \{T_i \mid i \in 1..n\}}{\Gamma \vdash t.j : T_j}
  $$
  若 $ t $ 的类型是元组 $ \{T_i \} $，则 $ t.j $ 的类型为 $ T_j $。

---

### 11.8 Records

#### 概述
**记录**（record）是对元组的推广，不同于元组中的元素按位置排列，记录的元素通过标签（label）标识。记录与元组的类型规则类似，但允许通过标签提取元素，而不是通过位置。

#### 语法与类型规则

**新语法形式**：

$$
t ::= \ldots \mid \{l_i = t_i \mid i \in 1..n\} \mid t.l
$$

**新值规则**：

$$
v ::= \ldots \mid \{l_i = v_i \mid i \in 1..n\}
$$

**新类型规则**：

- **T-Rcd**：
  $$
  \frac{\forall i \in 1..n, \Gamma \vdash t_i : T_i}{\Gamma \vdash \{l_i = t_i \mid i \in 1..n\} : \{l_i : T_i \mid i \in 1..n\}}
  $$

- **T-Proj**：$$
  \frac{\Gamma \vdash t : \{l_i : T_i \mid i \in 1..n\}}{\Gamma \vdash t.l_j : T_j}$$

---

接下来，请继续逐步提供后续内容，我会继续按要求详解。

### ---------------------------

### 11.9 Sums (和类型和差异类型）

#### 概述
在许多程序中，我们需要处理**异构集合**（heterogeneous collections）的值。例如，二叉树的节点可以是叶节点或是有两个子节点的内部节点。类似地，列表中的一个单元可以是 $nil$（空列表）或者是一个带有头和尾的 $cons$ 单元。此外，编译器的抽象语法树的节点可以表示变量、抽象或应用等。为了处理这种编程需求，类型论中引入了**变体类型**（variant types），也称为**和类型**（sum types）。

**和类型**提供了一种方式，允许我们将两个不同的类型组合成一个新的类型，使得新类型的值可以来自其中任意一个组成类型。通过为和类型的每个分支打上不同的标记（例如 $inl$ 和 $inr$），我们可以区分元素是来自和类型的哪个部分。

#### 新的语法与规则

**新语法形式**：

$$
t ::= \ldots \mid inl\ t \mid inr\ t \mid case\ t\ of\ inl\ x_1 \Rightarrow t_1\ |\ inr\ x_2 \Rightarrow t_2
$$

- $inl\ t$：将 $t$ 打上左标签（left tagging），表示它属于和类型的左分支。
- $inr\ t$：将 $t$ 打上右标签（right tagging），表示它属于和类型的右分支。
- $case\ t\ of\ inl\ x_1 \Rightarrow t_1\ |\ inr\ x_2 \Rightarrow t_2$：**分支表达式**，根据 $t$ 的标签选择执行哪个分支。

**值的定义**：

$$
v ::= \ldots \mid inl\ v \mid inr\ v
$$

即带标签的值 $inl\ v$ 和 $inr\ v$ 也都是值。

**类型系统中新增的类型构造符**：

$$
T ::= \ldots \mid T_1 + T_2
$$

$T_1 + T_2$ 表示和类型（sum type），表示一个类型的值可以是 $T_1$ 的值打上 $inl$ 标签，或是 $T_2$ 的值打上 $inr$ 标签。

#### 求值规则
**求值规则**定义了如何对和类型的表达式进行求值。关键的求值规则如下：

- **E-CaseInl**：
  $$
  case\ (inl\ v_0)\ of\ inl\ x_1 \Rightarrow t_1\ |\ inr\ x_2 \Rightarrow t_2 \rightarrow [x_1 \mapsto v_0]t_1
  $$

  如果我们在一个 `case` 表达式中遇到一个带 $inl$ 标签的值 $v_0$，则 $case$ 表达式选择执行 $t_1$，并将 $v_0$ 赋给 $x_1$。

- **E-CaseInr**：
  $$
  case\ (inr\ v_0)\ of\ inl\ x_1 \Rightarrow t_1\ |\ inr\ x_2 \Rightarrow t_2 \rightarrow [x_2 \mapsto v_0]t_2
  $$

  类似地，如果 $t_0$ 是一个带 $inr$ 标签的值 $v_0$，则执行 $t_2$，并将 $v_0$ 赋给 $x_2$。

- **E-Case**：
  $$
  t_0 \rightarrow t_0'\quad case\ t_0\ of\ inl\ x_1 \Rightarrow t_1\ |\ inr\ x_2 \Rightarrow t_2 \rightarrow case\ t_0'\ of\ inl\ x_1 \Rightarrow t_1\ |\ inr\ x_2 \Rightarrow t_2
  $$

  当 $t_0$ 还未完全化简时，继续对 $t_0$ 求值。

- **E-Inl**：
  $$
  t_1 \rightarrow t_1'\quad inl\ t_1 \rightarrow inl\ t_1'
  $$

  对 $inl$ 的参数求值。

- **E-Inr**：
  $$
  t_1 \rightarrow t_1'\quad inr\ t_1 \rightarrow inr\ t_1'
  $$

  类似地，对 $inr$ 的参数求值。

#### 类型规则
**和类型**的类型规则主要涉及如何为 $inl$ 和 $inr$ 标签赋类型，以及如何判断 `case` 表达式的类型。

- **T-Inl**：
  $$
  \frac{\Gamma \vdash t_1 : T_1}{\Gamma \vdash inl\ t_1 : T_1 + T_2}
  $$

  如果 $t_1$ 的类型是 $T_1$，那么 $inl\ t_1$ 的类型是 $T_1 + T_2$。

- **T-Inr**：
  $$
  \frac{\Gamma \vdash t_1 : T_2}{\Gamma \vdash inr\ t_1 : T_1 + T_2}
  $$

  类似地，如果 $t_1$ 的类型是 $T_2$，则 $inr\ t_1$ 的类型是 $T_1 + T_2$。

- **T-Case**：
  $$
  \frac{\Gamma \vdash t_0 : T_1 + T_2 \quad \Gamma, x_1 : T_1 \vdash t_1 : T \quad \Gamma, x_2 : T_2 \vdash t_2 : T}{\Gamma \vdash case\ t_0\ of\ inl\ x_1 \Rightarrow t_1 \ |\ inr\ x_2 \Rightarrow t_2 : T}
  $$

  如果 $t_0$ 的类型是 $T_1 + T_2$，并且 $t_1$ 和 $t_2$ 的类型都是 $T$，那么 $case$ 表达式的类型也是 $T$。

#### 例子

假设我们有两种地址类型：

```text
PhysicalAddr = {firstlast:String, addr:String};
VirtualAddr = {name:String, email:String};
```

我们可以定义一个新的类型 `Addr = PhysicalAddr + VirtualAddr;`，来表示一种可以包含这两种地址类型的和类型。如果 `pa` 是一个 `PhysicalAddr`，我们可以通过 `inl pa` 将它转换为类型 `Addr`。

```haskell
getName = λa:Addr.
  case a of
    inl x ⇒ x.firstlast
  | inr y ⇒ y.name;
```

在这个函数中，`a` 的类型是 `Addr`，我们根据 `a` 的标签选择不同的分支来提取名字。

---

### 习题 11.9.1

**题目**：`if` 表达式可以看作是 `case` 表达式的一种退化形式，试将 `true`、`false` 和 `if` 用和类型和 `Unit` 表示出来。

#### 解答：

我们可以通过将 `true` 和 `false` 看作 `Unit` 的标签来重写 `if` 语句。用和类型表达 `true` 和 `false` 的新定义如下：

```text
true  = inl unit as Unit + Unit;
false = inr unit as Unit + Unit;
```

这意味着，`true` 是一个带有左标签的 `Unit`，而 `false` 是一个带有右标签的 `Unit`。接下来，我们可以用 `case` 表达式来重写 `if` 语句：

```text
if t1 then t2 else t3
=
case t1 of
  inl unit ⇒ t2
| inr unit ⇒ t3
```

这样，我们就将 `if` 表达式定义为对一个和类型的模式匹配，其中 $t1$ 要么是 $inl unit$（对应 `true`），要么是 $inr unit$（对应 `false`）。

#### 解析：

- 通过使用和类型 $Unit + Unit$，我们可以为 `true` 和 `false` 提供一个统一的类型框架。
- `if` 语句通过模式匹配来选择是执行 $t2$ 还是 $t3$，这类似于使用 `case` 表达式对和类型进行模式匹配的方式。

---

### Sums and Uniqueness of Types

在这一节中，我们还讨论了**类型唯一性**（Uniqueness of Types）的问题。在纯 λ→ 系统中，每个项都有唯一的类型，但在引入和类型后，这一性质不再成立。原因是，$inl$ 和 $inr$ 构造函数允许我们将一个值注

入到多个不同的和类型中。

例如，$inl\ 5$ 可以具有 $Nat + Bool$ 类型，也可以具有 $Nat + Nat$ 类型。因此，我们无法通过直接自下而上地构建类型推断规则来实现类型检查算法，因为单个值可能对应多个类型。

为了解决这个问题，书中提出了三种可能的解决方案：
1. **复杂化类型检查算法**：通过引入某种机制来“猜测”类型。
2. **引入子类型**：允许所有可能的类型通过子类型关系统一表示。
3. **显式类型注解**：要求程序员提供显式的类型注解来消除歧义。

---

请继续提供后续内容，我会继续逐条详解。

### ----------------------------

### 11.10 Variants

#### 概述

在前面我们已经介绍了二元的和类型 $T_1 + T_2$，但现实中，我们经常需要更多的选择。**变体类型（Variants）**是和类型的泛化，它允许我们定义带有多个标签的变体。例如，地址类型可以是**物理地址**或者**虚拟地址**，我们可以定义如下变体类型：

$$
Addr = \langle physical: PhysicalAddr, virtual: VirtualAddr \rangle
$$

其中，每个标签（例如 $physical$ 或 $virtual$）对应不同的类型。**变体类型**与**记录类型（Records）**类似，区别在于变体类型是“可选的”，即它的值只能属于某一个分支，而记录类型的所有字段都必须同时存在。

#### 新的语法和规则

**新的语法形式**：

$$
t ::= \ldots \mid \langle l = t \rangle \text{ as } T \mid \text{case } t \text{ of } \langle l_i = x_i \rangle \Rightarrow t_i
$$

- $\langle l = t \rangle \text{ as } T$：将值 $t$ 以标签 $l$ 打包，标记为类型 $T$ 的变体。
- $\text{case } t \text{ of } \langle l_i = x_i \rangle \Rightarrow t_i$：对变体 $t$ 进行模式匹配，根据 $t$ 所带的标签选择相应的分支。

**新的类型定义**：

$$
T ::= \ldots \mid \langle l_i : T_i \rangle
$$

变体类型 $\langle l_i : T_i \rangle$ 是由多个标签及其对应类型构成的类型。例如，$\langle physical: PhysicalAddr, virtual: VirtualAddr \rangle$。

#### 求值规则

变体类型的求值规则如下：

- **E-CaseVariant**：
  $$
  \text{case } (\langle l_j = v_j \rangle \text{ as } T) \text{ of } \langle l_i = x_i \rangle \Rightarrow t_i \rightarrow [x_j \mapsto v_j] t_j
  $$

  如果我们在 `case` 表达式中遇到标签为 $l_j$ 的值 $\langle l_j = v_j \rangle$，则选择相应的分支 $t_j$，并将 $v_j$ 绑定到 $x_j$。

- **E-Case**：
  $$
  t_0 \rightarrow t_0'\quad \text{case } t_0 \text{ of } \langle l_i = x_i \rangle \Rightarrow t_i \rightarrow \text{case } t_0' \text{ of } \langle l_i = x_i \rangle \Rightarrow t_i
  $$

  当 `case` 表达式的参数还没有完全化简时，继续对它求值。

- **E-Variant**：
  $$
  t_i \rightarrow t_i'\quad \langle l_i = t_i \rangle \text{ as } T \rightarrow \langle l_i = t_i' \rangle \text{ as } T
  $$

  对标签 $l_i$ 的值 $t_i$ 进行求值。

#### 类型规则

变体类型的类型规则如下：

- **T-Variant**：
  $$
  \frac{\Gamma \vdash t_j : T_j}{\Gamma \vdash \langle l_j = t_j \rangle \text{ as } \langle l_i : T_i \rangle : \langle l_i : T_i \rangle}
  $$

  如果 $t_j$ 的类型是 $T_j$，则 $\langle l_j = t_j \rangle \text{ as } \langle l_i : T_i \rangle$ 的类型为 $\langle l_i : T_i \rangle$。

- **T-Case**：
  $$
  \frac{\Gamma \vdash t_0 : \langle l_i : T_i \rangle \quad \forall i, \Gamma, x_i : T_i \vdash t_i : T}{\Gamma \vdash \text{case } t_0 \text{ of } \langle l_i = x_i \rangle \Rightarrow t_i : T}
  $$

  如果 $t_0$ 的类型是 $\langle l_i : T_i \rangle$，并且所有分支 $t_i$ 的类型都是 $T$，则整个 `case` 表达式的类型也是 $T$。

#### 示例

假设我们有以下地址类型：

```text
Addr = <physical: PhysicalAddr, virtual: VirtualAddr>;
```

其中，`PhysicalAddr` 和 `VirtualAddr` 分别是物理地址和虚拟地址的类型。我们可以构造一个物理地址的变体实例：

```text
a = <physical=pa> as Addr;
```

这里，`a` 的类型是 `Addr`，它包含一个物理地址 `pa`。接着，我们可以编写一个函数来提取地址中的名字：

```haskell
getName = λa:Addr.
  case a of
    <physical=x> ⇒ x.firstlast
  | <virtual=y> ⇒ y.name;
```

这个函数的类型是 `Addr → String`，它通过模式匹配来提取物理或虚拟地址中的名字。

#### Option 类型和枚举类型

**Option 类型**是一种非常有用的变体类型。例如，`OptionalNat = <none:Unit, some:Nat>` 表示一个值可以是一个自然数（用 `some` 标签标记），或者是空值 `none`（用 `Unit` 类型表示）。这与许多编程语言中的 `Option` 或 `Maybe` 类型类似。

我们可以使用 `OptionalNat` 定义一个函数表：

```haskell
Table = Nat → OptionalNat;

emptyTable = λn:Nat. <none=unit> as OptionalNat;

extendTable = λt:Table. λm:Nat. λv:Nat.
  λn:Nat.
  if equal n m then <some=v> as OptionalNat else t n;
```

在这个例子中，`emptyTable` 是一个空表，它对任何输入都返回 `none`。`extendTable` 则是一个扩展表的函数，它为表中增加或更新一个键值对。

#### 枚举类型

枚举类型是变体类型的一个特例，每个标签都与 `Unit` 类型关联。比如，表示一周工作日的枚举类型可以定义为：

```haskell
Weekday = <monday:Unit, tuesday:Unit, wednesday:Unit, thursday:Unit, friday:Unit>;
```

这个枚举类型中的每个值都是带有 `Unit` 的变体，例如 `<monday=unit>`。

#### 单字段变体

单字段变体是指仅包含一个标签的变体类型。例如：

```haskell
DollarAmount = <dollars:Float>;
EuroAmount = <euros:Float>;
```

这种定义的变体可以确保不同的类型（如美元和欧元）不会被混淆使用。例如，`dollars2euros` 函数只能接受 `DollarAmount` 类型的参数，无法错误地传入 `EuroAmount`。

---

### 练习 11.10.1

**题目**：给定一个变体类型 $OptionalNat = \langle none:Unit, some:Nat \rangle$，定义一个查找表（Table）的扩展函数，并处理查找表中缺少值的情况。

#### 解答：

定义一个查找表的扩展函数 `extendTable` 和一个处理缺失值的查询函数 `lookupTable` 如下：

```haskell
extendTable = λt:Table. λm:Nat. λv:Nat.
  λn:Nat.
  if equal n m then <some=v> as OptionalNat else t n;

lookupTable = λt:Table. λn:Nat.
  case t n of
    <none=u> ⇒ 999
  | <some=v> ⇒ v;
```

- `extendTable` 函数接受一个表 `t`，一个键 `m`，一个值 `v`，以及一个待查的键 `n`，如果 $n = m$，则返回 `v`，否则查询表中已有的值。
- `lookupTable` 函数用于查找表中键 `n` 的值，如果该键不存在（返回 `none`），则返回默认值 `999`，否则返回对应的值。

#### 解析：

- 使用变体类型，我们能够处理值缺失的情况，并通过 `case` 表达式提供默认值。
- 变体类型确保了不同的分支是互斥的，避免了不正确的类型使用。

---

请继续提供后续内容，我会继续逐条详解。

### ---------------------------

### 11.11 General Recursion

递归函数是大多数编程语言中的基础特性之一。在无类型的lambda演算中，我们通过fix组合子定义递归函数。在类型化的环境中，递归函数可以类似地定义，但我们需要显式地添加 `fix` 作为一个新的原语（primitive），因为在简单类型lambda演算中我们无法定义递归函数。我们来看具体的规则和示例。

#### 11.11.1 fix 原语的定义

`fix` 是一个固定点组合子，它通过不断自我应用来实现递归计算。为了能够支持递归定义，我们引入了 `fix`，其求值规则和类型规则如下：

**新的语法形式**：

$$
t ::= \ldots \mid \text{fix} t
$$

**新的求值规则**：

- **E-FixBeta**：
  $$
  \text{fix} (\lambda x:T_1.t_2) \rightarrow [x \mapsto (\text{fix} (\lambda x:T_1.t_2))]t_2
  $$

  当我们应用 `fix` 于一个lambda表达式时，求值通过将自身作为参数传递给该lambda表达式来继续。

- **E-Fix**：
  $$
  t_1 \rightarrow t_1' \quad \text{fix} t_1 \rightarrow \text{fix} t_1'
  $$

  当 `fix` 应用于一个未完全求值的表达式时，我们对该表达式继续求值。

**新的类型规则**：

- **T-Fix**：
  $$
  \frac{\Gamma \vdash t_1 : T_1 \rightarrow T_1}{\Gamma \vdash \text{fix} t_1 : T_1}
  $$

  该规则表明，如果 $t_1$ 的类型是 $T_1 \rightarrow T_1$，那么 `fix t_1` 的类型是 $T_1$。

此外，`fix` 也可以用于定义递归函数的派生形式，如 `letrec`，它可以定义为：
$$
\text{letrec } x : T_1 = t_1 \text{ in } t_2 \quad \equiv \quad \text{let } x = \text{fix} (\lambda x : T_1 . t_1) \text{ in } t_2
$$

---

#### 示例：定义递归函数

通过 `fix`，我们可以定义递归函数，如判断一个数是否为偶数的函数 `iseven`。

定义生成函数 `ff`：

$$
ff = \lambda ie:Nat \rightarrow Bool. \lambda x:Nat.
  \text{if } \text{iszero } x \text{ then true else if iszero } (\text{pred } x) \text{ then false else } ie (\text{pred}(\text{pred } x))
$$

`ff` 生成一个新的 `iseven` 函数，该函数通过递归调用 `ie` 来处理较小的数字。

使用 `fix` 来定义 `iseven`：

$$
iseven = \text{fix } ff
$$

这样，我们可以计算 $iseven(7)$ 得到 `false`，表示7不是偶数。

---

#### 练习 11.11.1：使用 fix 定义 equal、plus、times 和 factorial

**解答**：

1. **equal**：检查两个数是否相等

$$
equal = \text{fix } (\lambda eq:Nat \rightarrow Nat \rightarrow Bool. \lambda x:Nat. \lambda y:Nat.
  \text{if iszero } x \text{ then iszero } y \text{ else if iszero } y \text{ then false else } eq (\text{pred } x) (\text{pred } y))
$$

2. **plus**：两个自然数相加

$$
plus = \text{fix } (\lambda p:Nat \rightarrow Nat \rightarrow Nat. \lambda x:Nat. \lambda y:Nat.
  \text{if iszero } x \text{ then } y \text{ else } p (\text{pred } x) (\text{succ } y))
$$

3. **times**：两个自然数相乘

$$
times = \text{fix } (\lambda t:Nat \rightarrow Nat \rightarrow Nat. \lambda x:Nat. \lambda y:Nat.
  \text{if iszero } x \text{ then 0 else } plus \, y \, (t (\text{pred } x) y))
$$

4. **factorial**：阶乘

$$
factorial = \text{fix } (\lambda f:Nat \rightarrow Nat. \lambda x:Nat.
  \text{if iszero } x \text{ then 1 else times \, x \, (f (\text{pred } x))})
$$

这些函数都使用 `fix` 实现递归，`equal` 比较两个数是否相等，`plus` 和 `times` 分别计算加法和乘法，而 `factorial` 计算阶乘。

---

#### 练习 11.11.2：使用 letrec 重写 plus、times 和 factorial

**解答**：

我们可以使用 `letrec` 来代替 `fix` 定义递归函数：

1. **plus** 使用 `letrec`：

$$
\text{letrec } plus:Nat \rightarrow Nat \rightarrow Nat = \lambda x:Nat. \lambda y:Nat.
  \text{if iszero } x \text{ then } y \text{ else } plus (\text{pred } x) (\text{succ } y)
$$

2. **times** 使用 `letrec`：

$$
\text{letrec } times:Nat \rightarrow Nat \rightarrow Nat = \lambda x:Nat. \lambda y:Nat.
  \text{if iszero } x \text{ then 0 else } plus \, y \, (times (\text{pred } x) y)
$$

3. **factorial** 使用 `letrec`：

$$
\text{letrec } factorial:Nat \rightarrow Nat = \lambda x:Nat.
  \text{if iszero } x \text{ then 1 else times \, x \, (factorial (\text{pred } x))}
$$

---

#### 11.12 列表（Lists）

在编程语言中，列表是一种重要的数据结构。**列表类型** $List T$ 表示一个包含 $T$ 类型元素的有限长度列表。我们可以使用 `nil[T]` 来表示空列表，使用 `cons[T] t_1 t_2` 来将元素 $t_1$ 添加到列表 $t_2$ 的前面。

**新的语法形式**：

$$
t ::= \ldots \mid \text{nil}[T] \mid \text{cons}[T] t_1 t_2 \mid \text{isnil}[T] t \mid \text{head}[T] t \mid \text{tail}[T] t
$$

**新的求值规则**：

- **E-Cons1**：
  $$
  t_1 \rightarrow t_1' \quad \text{cons}[T] t_1 t_2 \rightarrow \text{cons}[T] t_1' t_2
  $$

- **E-IsnilNil**：
  $$
  \text{isnil}[S](\text{nil}[T]) \rightarrow \text{true}
  $$

- **E-HeadCons**：
  $$
  \text{head}[S](\text{cons}[T] v_1 v_2) \rightarrow v_1
  $$

**新的类型规则**：

- **T-Nil**：
  $$
  \Gamma \vdash \text{nil}[T_1] : \text{List } T_1
  $$

- **T-Cons**：
  $$
  \frac{\Gamma \vdash t_1 : T_1 \quad \Gamma \vdash t_2 : \text{List } T_1}{\Gamma \vdash \text{cons}[T_1] t_1 t_2 : \text{List } T_1}
  $$

- **T-Isnil**：
  $$
  \Gamma \vdash t_1 : \text{List } T_1 \quad \Gamma \vdash \text{isnil}[T_1] t_1 : \text{Bool}
  $$

这些规则允许我们定义和操作列表。通过这些规则，列表可以被构建、检查是否为空、访问其头部和尾部。

---

#### 练习 11.12.1：验证简单类型lambda演算中带有布尔值和列表的进展性（Progress）和保持性（Preservation）

**解答**：

进展性（Progress）证明表明，在良类型的表达式中，要么该表达式是值，要么它可以继续求值。保持性（Preservation）证明表明，在良类型的表达式中，若其经过求值步骤后得到一个新表达式，则新表达式的类型与原表达式的类型相同。

---

请继续提供后续内容，我将

逐条详细讲解。

### ----------------------------

### 11.6 对（Pairs）

#### 概述

大多数编程语言都提供了构建复合数据结构的多种方式，其中最简单的是**对**（pair）或更一般的**元组**（tuple）。在这一节中，我们将探讨对的形式化定义，以及如何在简单类型λ演算中添加对的支持。

#### 语法与类型规则

我们引入新的语法和类型构造，以支持对的创建和操作。

**新语法形式**：

- **项（terms）**：
  $$
  t ::= \ldots \mid \{ t_1, t_2 \} \mid t.1 \mid t.2
  $$
  - $\{ t_1, t_2 \}$：表示对的构造，包含两个元素 $t_1$ 和 $t_2$。
  - $t.1$：表示从对 $t$ 中提取第一个元素（投射）。
  - $t.2$：表示从对 $t$ 中提取第二个元素。

- **值（values）**：
  $$
  v ::= \ldots \mid \{ v_1, v_2 \}
  $$
  - $\{ v_1, v_2 \}$：当 $v_1$ 和 $v_2$ 都是值时，$\{ v_1, v_2 \}$ 也是一个值。

- **类型（types）**：
  $$
  T ::= \ldots \mid T_1 \times T_2
  $$
  - $T_1 \times T_2$：对的类型，表示由类型 $T_1$ 和 $T_2$ 组成的积类型（product type）。

#### 求值规则

**求值规则**定义了如何对新的项进行计算：

1. **E-PairBeta1**：
   $$
   \{ v_1, v_2 \}.1 \rightarrow v_1
   $$
   - 当我们对一个完全求值的对应用 `.1` 时，结果是第一个元素 $v_1$。

2. **E-PairBeta2**：
   $$
   \{ v_1, v_2 \}.2 \rightarrow v_2
   $$
   - 类似地，应用 `.2` 时，结果是第二个元素 $v_2$。

3. **E-Proj1**：
   $$
   t_1 \rightarrow t_1' \quad t_1.1 \rightarrow t_1'.1
   $$
   - 如果 $t_1$ 可以进一步求值，那么 $t_1.1$ 也可以进一步求值。

4. **E-Proj2**：
   $$
   t_1 \rightarrow t_1' \quad t_1.2 \rightarrow t_1'.2
   $$
   - 类似地，$t_1.2$ 也可以继续求值。

5. **E-Pair1**：
   $$
   t_1 \rightarrow t_1' \quad \{ t_1, t_2 \} \rightarrow \{ t_1', t_2 \}
   $$
   - 对的第一个元素 $t_1$ 可以先求值。

6. **E-Pair2**：
   $$
   t_2 \rightarrow t_2' \quad \{ v_1, t_2 \} \rightarrow \{ v_1, t_2' \}
   $$
   - 当第一个元素已经是值时，继续对第二个元素 $t_2$ 求值。

这些规则确保了对的元素按照从左到右的顺序求值。

#### 类型规则

**类型规则**定义了如何为新的项分配类型：

1. **T-Pair**（对的构造）：
   $$
   \frac{\Gamma \vdash t_1 : T_1 \quad \Gamma \vdash t_2 : T_2}{\Gamma \vdash \{ t_1, t_2 \} : T_1 \times T_2}
   $$
   - 如果 $t_1$ 的类型是 $T_1$，$t_2$ 的类型是 $T_2$，那么对 $\{ t_1, t_2 \}$ 的类型是 $T_1 \times T_2$。

2. **T-Proj1**（第一投射）：
   $$
   \frac{\Gamma \vdash t : T_1 \times T_2}{\Gamma \vdash t.1 : T_1}
   $$
   - 如果 $t$ 的类型是 $T_1 \times T_2$，那么 $t.1$ 的类型是 $T_1$。

3. **T-Proj2**（第二投射）：
   $$
   \frac{\Gamma \vdash t : T_1 \times T_2}{\Gamma \vdash t.2 : T_2}
   $$
   - 类似地，$t.2$ 的类型是 $T_2$。

#### 示例

考虑以下复合项：

$$
\{ \text{pred } 4, \ \text{if true then false else false} \}.1
$$

求值步骤如下：

1. 计算对的第一个元素：
   $$
   \{ 3, \ \text{if true then false else false} \}.1
   $$
2. 计算对的第二个元素（由于第一个元素已经是值，可以继续）：
   $$
   \{ 3, \ \text{false} \}.1
   $$
3. 应用投射：
   $$
   3
   $$

#### 说明

- 对的元素必须是值，这保证了当对被作为函数参数传递时，其元素已经被完全求值。
- 求值顺序是从左到右的，首先求值左侧的元素，然后是右侧的元素。

---

### 11.7 元组（Tuples）

#### 概述

元组是对的自然推广，可以包含任意数量的元素（n元组）。例如，$\{1, 2, \text{true}\}$ 是一个三元组，包含两个自然数和一个布尔值，其类型为 $\{ \text{Nat}, \text{Nat}, \text{Bool} \}$。

#### 语法与类型规则

**新语法形式**：

- **项（terms）**：
  $$
  t ::= \ldots \mid \{ t_i \}_{i=1}^n \mid t.i
  $$
  - $\{ t_i \}_{i=1}^n$：表示一个包含 $n$ 个元素的元组。
  - $t.i$：表示从元组 $t$ 中提取第 $i$ 个元素。

- **值（values）**：
  $$
  v ::= \ldots \mid \{ v_i \}_{i=1}^n
  $$
  - 当所有 $v_i$ 都是值时，元组 $\{ v_i \}_{i=1}^n$ 是一个值。

- **类型（types）**：
  $$
  T ::= \ldots \mid \{ T_i \}_{i=1}^n
  $$
  - 元组类型，由各元素的类型组成。

#### 求值规则

1. **E-ProjTuple**（投射）：
   $$
   \{ v_i \}_{i=1}^n . j \rightarrow v_j
   $$
   - 当元组中的所有元素都是值时，投射操作直接返回第 $j$ 个元素。

2. **E-Proj**：
   $$
   t_1 \rightarrow t_1' \quad t_1 . i \rightarrow t_1' . i
   $$
   - 当元组还未完全求值时，继续对其求值。

3. **E-Tuple**：
   $$
   t_j \rightarrow t_j' \quad \{ v_i \}_{i=1}^{j-1}, t_j, t_k \}_{k=j+1}^n \rightarrow \{ v_i \}_{i=1}^{j-1}, t_j', t_k \}_{k=j+1}^n
   $$
   - 从左到右依次求值元组的元素。

#### 类型规则

1. **T-Tuple**（元组的构造）：
   $$
   \frac{\forall i, \Gamma \vdash t_i : T_i}{\Gamma \vdash \{ t_i \}_{i=1}^n : \{ T_i \}_{i=1}^n}
   $$
   - 如果每个 $t_i$ 的类型是 $T_i$，则元组的类型是 $\{ T_i \}_{i=1}^n$。

2. **T-Proj**（投射）：
   $$
   \frac{\Gamma \vdash t : \{ T_i \}_{i=1}^n}{\Gamma \vdash t.j : T_j}
   $$
   - 从元组类型中提取第 $j$ 个元素的类型。

#### 说明

- 元组可以是空的（$n = 0$），这时表示空元组 $\{\}$。
- 一元元组（$n = 1$）与单独的值是不同的，例如 $\{ 5 \}$ 与 $5$ 是不同的，前者是元组，可以进行投射操作。

---

### 11.8 记录（Records）

#### 概述

记录是元组的进一步推广，允许为每个字段指定标签（label）。记录中的元素通过标签来标识，而不是通过位置。

例如：

- $\{ x = 5 \}$ 是一个记录，其类型为 $\{ x : \text{Nat} \}$。
- $\{ \text{partno} = 5524, \ \text{cost} = 30.27 \}$ 是一个记录，其类型为 $\{ \text{partno} : \text{Nat}, \ \text{cost} : \text{Float} \}$。

#### 语法与类型规则

**新语法形式**：

- **项（terms）**：
  $$
  t ::= \ldots \mid \{ l_i = t_i \}_{i=1}^n \mid t.l
  $$
  - $\{ l_i = t_i \}_{i=1}^n$：记录的构造，包含带标签的字段。
  - $t.l$：从记录 $t$ 中提取标签为 $l$ 的字段。

- **值（values）**：
  $$
  v ::= \ldots \mid \{ l_i = v_i \}_{i=1}^n
  $$
  - 当所有 $v_i$ 都是值时，记录也是一个值。

- **类型（types）**：
  $$
  T ::= \ldots \mid \{ l_i : T_i \}_{i=1}^n
  $$

#### 求值规则

1. **E-ProjRcd**（记录的投射）：
   $$
   \{ l_i = v_i \}_{i=1}^n . l_j \rightarrow v_j
   $$
   - 当记录中的所有字段都是值时，投射操作返回对应标签的值。

2. **E-Proj**：
   $$
   t_1 \rightarrow t_1' \quad t_1 . l \rightarrow t_1' . l
   $$
   - 当记录还未完全求值时，继续对其求值。

3. **E-Rcd**：
   $$
   t_j \rightarrow t_j' \quad \{ l_i = v_i \}_{i=1}^{j-1}, \ l_j = t_j, \ l_k = t_k \}_{k=j+1}^n \rightarrow \{ l_i = v_i \}_{i=1}^{j-1}, \ l_j = t_j', \ l_k = t_k \}_{k=j+1}^n
   $$
   - 从左到右依次求值记录的字段。

#### 类型规则

1. **T-Rcd**（记录的构造）：
   $$
   \frac{\forall i, \Gamma \vdash t_i : T_i}{\Gamma \vdash \{ l_i = t_i \}_{i=1}^n : \{ l_i : T_i \}_{i=1}^n}
   $$
   - 如果每个 $t_i$ 的类型是 $T_i$，则记录的类型是 $\{ l_i : T_i \}_{i=1}^n$。

2. **T-Proj**（投射）：
   $$
   \frac{\Gamma \vdash t : \{ l_i : T_i \}_{i=1}^n}{\Gamma \vdash t.l_j : T_j}
   $$
   - 从记录类型中提取标签为 $l_j$ 的字段的类型。

#### 说明

- 在记录中，标签的顺序是有意义的，即 $\{ \text{partno} = 5524, \ \text{cost} = 30.27 \}$ 与 $\{ \text{cost} = 30.27, \ \text{partno} = 5524 \}$ 被视为不同的记录，类型也不同。
- 在一些语言中，记录的字段顺序不影响其类型和含义，但在我们的定义中，顺序是重要的。
- 可以将元组视为一种特殊的记录，其中的标签是自然数（位置）。

---

### 习题 11.8.1

**题目**：将规则 E-ProjRcd 写得更加明确，以便比较。

#### 解答

原始的 E-ProjRcd 规则较为简略，我们可以将其写得更加明确：

**更明确的 E-ProjRcd 规则**：

- 前提条件：

  - 记录 $\{ l_1 = v_1, \ldots, l_n = v_n \}$，其中所有 $v_i$ 都是值。
  - 标签 $l_j$ 是记录中的某个标签，即 $j \in \{1, 2, \ldots, n\}$。

- 求值规则：

  $$
  \{ l_1 = v_1, \ldots, l_n = v_n \} . l_j \rightarrow v_j
  $$

- 解释：

  - 当对一个完全求值的记录应用投射操作 $t.l_j$ 时，直接返回对应标签的值 $v_j$。

#### 解析

- 这样写使得规则更加明确，显示了具体的记录结构和投射操作的结果。
- 通过列出所有的标签和对应的值，可以清晰地看到投射操作的行为。

---

### 习题 11.8.2

**题目**：在我们的记录表示中，投射操作一次只能提取一个字段。许多高级编程语言提供了一种模式匹配（pattern matching）语法，可以一次提取所有字段，使得一些程序可以更简洁地表达。模式通常也可以嵌套，允许从复杂的嵌套数据结构中轻松提取部分。

我们可以通过在未类型化的λ演算中添加一个新的模式类别，以及一个新的语法构造来实现记录的模式匹配。（参见图 11-8）

**要求**：

1. 为新添加的构造给出类型规则（在此过程中可以对语法进行任何必要的更改）。
2. 为整个演算概述类型保持性（type preservation）和进展性（progress）的证明。（不需要完整的证明，只需按照正确的顺序给出所需引理的陈述。）

#### 解答

**第1步：给出类型规则**

首先，我们需要定义模式（patterns）的语法和匹配规则，然后为新的 `let p = t_1 in t_2` 构造给出类型规则。

**新语法形式**：

- **模式（patterns）**：
  $$
  p ::= x \mid \{ l_i = p_i \}_{i=1}^n
  $$
  - $x$：变量模式。
  - $\{ l_i = p_i \}_{i=1}^n$：记录模式，包含多个字段模式。

- **项（terms）**：
  $$
  t ::= \ldots \mid \text{let } p = t_1 \text{ in } t_2
  $$

**匹配规则**：

- **M-Var**（变量模式）：
  $$
  \text{match}(x, v) = [ x \mapsto v ]
  $$
  - 变量模式始终成功匹配，将变量 $x$ 绑定到值 $v$。

- **M-Rcd**（记录模式）：
  $$
  \text{match}(\{ l_i = p_i \}_{i=1}^n, \{ l_i = v_i \}_{i=1}^n) = \sigma_1 \cup \ldots \cup \sigma_n
  $$
  - 对于每个 $i$，匹配子模式 $p_i$ 与对应的值 $v_i$，得到替换 $\sigma_i$。
  - 最终的替换是所有 $\sigma_i$ 的并集。

**类型规则**：

- **T-LetP**（模式绑定）：
  $$
  \frac{\Gamma \vdash t_1 : T_p \quad \Gamma, \Gamma_p \vdash t_2 : T}{\Gamma \vdash \text{let } p = t_1 \text{ in } t_2 : T}
  $$
  - 首先，$t_1$ 的类型是 $T_p$。
  - 然后，根据模式 $p$ 和 $T_p$，推导出新的上下文 $\Gamma_p$，其中包含模式中绑定的变量及其类型。
  - 在扩展的上下文 $\Gamma, \Gamma_p$ 下，$t_2$ 的类型是 $T$。

**模式的类型规则**：

- **P-Var**（变量模式）：
  $$
  \text{typeof\_pattern}(x, T) = \{ x : T \}
  $$
  - 变量模式绑定变量 $x$，其类型为 $T$。

- **P-Rcd**（记录模式）：
  $$
  \text{typeof\_pattern}(\{ l_i = p_i \}_{i=1}^n, \{ l_i : T_i \}_{i=1}^n) = \bigcup_{i=1}^n \text{typeof\_pattern}(p_i, T_i)
  $$
  - 对于记录模式，模式的类型是对应字段类型的集合。

**第2步：概述类型保持性和进展性的证明**

- **类型保持性（Type Preservation）**：

  - **定理**：如果 $\Gamma \vdash t : T$，且 $t \rightarrow t'$，那么 $\Gamma \vdash t' : T$。

  - **证明思路**：

    - 对于新的 `let p = t_1 \text{ in } t_2` 构造，需要证明：

      - 当 $t_1$ 是值时，匹配成功后，替换后的 $t_2$ 在扩展的上下文下类型正确。

      - 当 $t_1$ 还未求值完毕时，继续对 $t_1$ 求值，类型不变。

- **进展性（Progress）**：

  - **定理**：如果 $\emptyset \vdash t : T$，则 $t$ 要么是值，要么存在 $t'$ 使得 $t \rightarrow t'$。

  - **证明思路**：

    - 对于新的构造：

      - 如果 `let p = t_1 \text{ in } t_2`，且 $t_1$ 是值，那么根据匹配规则，可以计算出替换，然后继续求值。

      - 如果 $t_1$ 不是值，则根据求值规则，对 $t_1$ 进行求值。

---

#### 解析

通过引入模式匹配，我们可以一次从记录中提取多个字段，简化了程序的书写。类型规则需要考虑模式与值的对应，以及如何在类型上下文中添加模式中绑定的变量。

---

### 总结

在这一系列章节中，我们扩展了简单类型λ演算，添加了对、元组、记录以及模式匹配等构造。通过详细的语法、求值规则和类型规则，我们理解了这些扩展如何在理论上定义，以及在编程语言中如何使用。同时，我们解答了相关的习题，加深了对概念的理解。

---

**如果您对上述内容有任何疑问，或者希望深入探讨某个具体部分，请随时提问！**

### ---------------------------

### 11.9 和类型（Sums）

#### 概述

许多程序需要处理**异构集合**（heterogeneous collections）的值。例如，二叉树的节点可以是叶子节点，或者是具有两个子节点的内部节点；类似地，列表的单元可以是 `nil`（空）或者一个包含头和尾的 `cons` 单元；在编译器的抽象语法树中，一个节点可以表示变量、抽象、应用等。支持这种编程的类型理论机制是**变体类型**（variant types）。

#### 语法与类型规则

**新语法形式**：

- **项（terms）**：
  $$
  t ::= \ldots \mid \text{inl } t \mid \text{inr } t \mid \text{case } t \text{ of } \text{inl } x \Rightarrow t \mid \text{inr } x \Rightarrow t
  $$
  - $\text{inl } t$：左标签的标记（tagging）。
  - $\text{inr } t$：右标签的标记。
  - $\text{case } t \text{ of } \text{inl } x \Rightarrow t_1 \mid \text{inr } x \Rightarrow t_2$：**case**表达式，根据 $t$ 的标签选择执行哪个分支。

- **值（values）**：
  $$
  v ::= \ldots \mid \text{inl } v \mid \text{inr } v
  $$
  - $\text{inl } v$：左标签的标记值。
  - $\text{inr } v$：右标签的标记值。

- **类型（types）**：
  $$
  T ::= \ldots \mid T + T
  $$
  - $T_1 + T_2$：和类型（sum type）。

#### 求值规则

**新求值规则**：

1. **E-CaseInl**：
   $$
   \text{case } (\text{inl } v_0) \text{ of } \text{inl } x_1 \Rightarrow t_1 \mid \text{inr } x_2 \Rightarrow t_2 \rightarrow [x_1 \mapsto v_0] t_1
   $$
   - 当 $\text{case}$ 的参数是左标签的值 $\text{inl } v_0$ 时，选择第一个分支，绑定 $x_1$ 为 $v_0$，然后执行 $t_1$。

2. **E-CaseInr**：
   $$
   \text{case } (\text{inr } v_0) \text{ of } \text{inl } x_1 \Rightarrow t_1 \mid \text{inr } x_2 \Rightarrow t_2 \rightarrow [x_2 \mapsto v_0] t_2
   $$
   - 当 $\text{case}$ 的参数是右标签的值 $\text{inr } v_0$ 时，选择第二个分支，绑定 $x_2$ 为 $v_0$，然后执行 $t_2$。

3. **E-Case**：
   $$
   t_0 \rightarrow t_0' \quad \text{case } t_0 \text{ of } \text{inl } x_1 \Rightarrow t_1 \mid \text{inr } x_2 \Rightarrow t_2 \rightarrow \text{case } t_0' \text{ of } \text{inl } x_1 \Rightarrow t_1 \mid \text{inr } x_2 \Rightarrow t_2
   $$
   - 当 $\text{case}$ 的参数 $t_0$ 还未完全求值时，先对 $t_0$ 进行求值。

4. **E-Inl**：
   $$
   t_1 \rightarrow t_1' \quad \text{inl } t_1 \rightarrow \text{inl } t_1'
   $$
   - 对 $\text{inl}$ 的参数 $t_1$ 进行求值。

5. **E-Inr**：
   $$
   t_1 \rightarrow t_1' \quad \text{inr } t_1 \rightarrow \text{inr } t_1'
   $$
   - 对 $\text{inr}$ 的参数 $t_1$ 进行求值。

#### 类型规则

**新类型规则**：

1. **T-Inl**：
   $$
   \frac{\Gamma \vdash t_1 : T_1}{\Gamma \vdash \text{inl } t_1 : T_1 + T_2}
   $$
   - 如果 $t_1$ 的类型是 $T_1$，则 $\text{inl } t_1$ 的类型是 $T_1 + T_2$。

2. **T-Inr**：
   $$
   \frac{\Gamma \vdash t_1 : T_2}{\Gamma \vdash \text{inr } t_1 : T_1 + T_2}
   $$
   - 如果 $t_1$ 的类型是 $T_2$，则 $\text{inr } t_1$ 的类型是 $T_1 + T_2$。

3. **T-Case**：
   $$
   \frac{\Gamma \vdash t_0 : T_1 + T_2 \quad \Gamma, x_1 : T_1 \vdash t_1 : T \quad \Gamma, x_2 : T_2 \vdash t_2 : T}{\Gamma \vdash \text{case } t_0 \text{ of } \text{inl } x_1 \Rightarrow t_1 \mid \text{inr } x_2 \Rightarrow t_2 : T}
   $$
   - 如果 $t_0$ 的类型是 $T_1 + T_2$，并且在扩展了上下文的情况下，$t_1$ 和 $t_2$ 的类型都是 $T$，那么整个 $\text{case}$ 表达式的类型是 $T$。

#### 示例

假设我们有以下两种类型，用于表示不同类型的地址簿记录：

- **PhysicalAddr**（物理地址）：
  $$
  \text{PhysicalAddr} = \{ \text{firstlast} : \text{String}, \ \text{addr} : \text{String} \}
  $$

- **VirtualAddr**（虚拟地址）：
  $$
  \text{VirtualAddr} = \{ \text{name} : \text{String}, \ \text{email} : \text{String} \}
  $$

我们想要统一处理这两种类型的记录（例如，创建一个包含两种记录的列表）。为此，我们引入一个和类型：

$$
\text{Addr} = \text{PhysicalAddr} + \text{VirtualAddr}
$$

这样，$\text{Addr}$ 类型的元素要么是一个 $\text{PhysicalAddr}$，要么是一个 $\text{VirtualAddr}$。

如果我们有一个物理地址记录 $\text{pa}$，那么我们可以通过 $\text{inl } \text{pa}$ 将其标记为 $\text{Addr}$ 类型的一个元素。

类似地，我们可以定义一个函数 $\text{getName}$ 来从 $\text{Addr}$ 类型的值中提取名字：

$$
\text{getName} = \lambda a : \text{Addr}. \ \text{case } a \text{ of } \text{inl } x \Rightarrow x.\text{firstlast} \mid \text{inr } y \Rightarrow y.\text{name}
$$

当参数 $a$ 是一个带有 $\text{inl}$ 标签的 $\text{PhysicalAddr}$ 时，$\text{case}$ 表达式会选择第一个分支，绑定 $x$ 为 $\text{PhysicalAddr}$ 的值，然后返回 $x.\text{firstlast}$。

当 $a$ 是一个带有 $\text{inr}$ 标签的 $\text{VirtualAddr}$ 时，$\text{case}$ 表达式会选择第二个分支，绑定 $y$ 为 $\text{VirtualAddr}$ 的值，然后返回 $y.\text{name}$。

因此，$\text{getName}$ 函数的类型是 $\text{Addr} \rightarrow \text{String}$。

#### 习题 11.9.1

**题目**：注意到 $\text{case}$ 的类型规则与图 8-1 中 $\text{if}$ 的规则的相似性：$\text{if}$ 可以被看作是一种退化形式的 $\text{case}$，其中没有信息传递给分支。通过使用和类型和 $\text{Unit}$，将 $\text{true}$、$\text{false}$ 和 $\text{if}$ 定义为派生形式，以形式化这一直觉。

**解答**：

我们可以使用和类型 $\text{Unit} + \text{Unit}$ 来定义布尔值 $\text{true}$ 和 $\text{false}$，以及 $\text{if}$ 表达式。

- 定义 $\text{Bool}$ 类型：
  $$
  \text{Bool} = \text{Unit} + \text{Unit}
  $$

- 定义 $\text{true}$ 和 $\text{false}$：
  $$
  \text{true} = \text{inl } \text{unit} : \text{Bool}
  $$
  $$
  \text{false} = \text{inr } \text{unit} : \text{Bool}
  $$

- 定义 $\text{if}$ 表达式：
  $$
  \text{if } t_1 \text{ then } t_2 \text{ else } t_3 = \text{case } t_1 \text{ of } \text{inl } \_ \Rightarrow t_2 \mid \text{inr } \_ \Rightarrow t_3
  $$

在这个定义中，我们将 $\text{Bool}$ 类型表示为 $\text{Unit} + \text{Unit}$，即一个和类型，其中左分支和右分支都与 $\text{Unit}$ 类型相关联。

- $\text{true}$ 是左分支的 $\text{Unit}$ 值，即 $\text{inl unit}$。
- $\text{false}$ 是右分支的 $\text{Unit}$ 值，即 $\text{inr unit}$。

$\text{if}$ 表达式通过对 $t_1$ 进行 $\text{case}$ 分析，如果是 $\text{inl}$，则执行 $t_2$，否则执行 $t_3$。

这样，我们就形式化地将 $\text{true}$、$\text{false}$ 和 $\text{if}$ 定义为使用和类型和 $\text{Unit}$ 的派生形式。

#### 和类型与类型唯一性

大多数纯 λ→ 系统的类型关系的性质都可以扩展到带有和类型的系统，但有一个重要的性质失效了：**类型唯一性定理**（定理 9.3.3）。问题出在标记构造 $\text{inl}$ 和 $\text{inr}$。

例如，类型规则 **T-Inl** 表示，一旦我们证明 $t_1$ 是 $T_1$ 的元素，那么对于任意类型 $T_2$，我们都可以推导出 $\text{inl } t_1$ 是 $T_1 + T_2$ 的元素。

例如，我们可以推导出：

- $\text{inl } 5 : \text{Nat} + \text{Nat}$
- $\text{inl } 5 : \text{Nat} + \text{Bool}$

还有无穷多个其他类型。

类型唯一性的失败意味着我们不能简单地“自下而上地读取规则”来构建类型检查算法，就像我们之前对所有特性所做的那样。

#### 解决方案

在这个时候，我们有多种选择：

1. **复杂化类型检查算法**：我们可以让类型检查算法更复杂，以某种方式“猜测” $T_2$ 的值。具体地说，我们在这个点上将 $T_2$ 保持不确定，尝试在之后发现它的值应该是什么。这样的技术将在我们讨论类型重建（第 22 章）时详细探讨。

2. **引入子类型**：我们可以改进类型语言，使得所有可能的 $T_2$ 的值都能够以某种方式统一表示。当我们讨论子类型（第 15 章）时，将探讨这种选择。

3. **显式类型注解**：我们可以要求程序员提供一个显式的注解，以指明所期望的 $T_2$ 类型。这种选择是最简单的，而且实际上并不像看起来那么不实用，因为在完整的语言设计中，这些显式注解通常可以“搭载”（piggyback）在其他语言构造上，从而基本上是隐形的（我们将在下一节中回到这一点）。现在我们采用这个选项。

#### 改进的和类型定义

**图 11-10** 展示了相对于**图 11-9** 所需的扩展。我们不再只是写 $\text{inl } t$ 或 $\text{inr } t$，而是写作 $\text{inl } t \text{ as } T$ 或 $\text{inr } t \text{ as } T$，其中 $T$ 指定了我们希望注入的元素所属的整个和类型。

**新语法形式**：

- **项（terms）**：
  $$
  t ::= \ldots \mid \text{inl } t \text{ as } T \mid \text{inr } t \text{ as } T
  $$
  - $\text{inl } t \text{ as } T$：带左标签的标记，类型注解为 $T$。
  - $\text{inr } t \text{ as } T$：带右标签的标记，类型注解为 $T$。

- **值（values）**：
  $$
  v ::= \ldots \mid \text{inl } v \text{ as } T \mid \text{inr } v \text{ as } T
  $$
  - 带有类型注解的标记值。

#### 新的求值规则

1. **E-CaseInl**：
   $$
   \text{case } (\text{inl } v_0 \text{ as } T_0) \text{ of } \text{inl } x_1 \Rightarrow t_1 \mid \text{inr } x_2 \Rightarrow t_2 \rightarrow [x_1 \mapsto v_0] t_1
   $$

2. **E-CaseInr**：
   $$
   \text{case } (\text{inr } v_0 \text{ as } T_0) \text{ of } \text{inl } x_1 \Rightarrow t_1 \mid \text{inr } x_2 \Rightarrow t_2 \rightarrow [x_2 \mapsto v_0] t_2
   $$

3. **E-Inl**：
   $$
   t_1 \rightarrow t_1' \quad \text{inl } t_1 \text{ as } T_2 \rightarrow \text{inl } t_1' \text{ as } T_2
   $$

4. **E-Inr**：
   $$
   t_1 \rightarrow t_1' \quad \text{inr } t_1 \text{ as } T_2 \rightarrow \text{inr } t_1' \text{ as } T_2
   $$

#### 新的类型规则

1. **T-Inl**：
   $$
   \frac{\Gamma \vdash t_1 : T_1}{\Gamma \vdash \text{inl } t_1 \text{ as } T_1 + T_2 : T_1 + T_2}
   $$

2. **T-Inr**：
   $$
   \frac{\Gamma \vdash t_1 : T_2}{\Gamma \vdash \text{inr } t_1 \text{ as } T_1 + T_2 : T_1 + T_2}
   $$

这些类型规则使用声明的和类型作为注入的类型，在检查注入的项确实属于和类型的适当分支之后。

通过这种方式，我们解决了类型唯一性的问题，因为注入的和类型 $T_1 + T_2$ 是明确指定的。

---

以上就是对第 11.9 节的详细解释，包括所有的语法、求值规则和类型规则，以及对相关习题的解答。

### ----------------------------

**11.10 变体（Variants）**

在编程语言中，变体（又称为标签联合类型或和类型）允许我们定义可以持有不同类型值的类型，每个值都带有一个标签，用于标识其类型。这类似于如何将二元和类型（如 $T1 + T2$）泛化为带标签的变体，就像乘积类型（如 $T1 \times T2$）泛化为带标签的记录一样。

**将二元和类型泛化为带标签的变体**

- **二元和类型**：传统上，二元和类型 $T1 + T2$ 表示一个值可以是类型 $T1$ 或类型 $T2$，但没有显式的标签。

- **带标签的变体**：为了泛化这一点，我们引入标签来标识每个变体。我们将 $T1 + T2$ 写成 $\langle l1:T1, l2:T2 \rangle$，其中 $l1$ 和 $l2$ 是分别与类型 $T1$ 和 $T2$ 关联的标签。

- **标记值**：当构造变体类型的值时，我们使用标签来标记这些值。我们将 $\text{inl } t$ 作为 $T1 + T2$ 写成 $\langle l1 = t \rangle$ 作为 $\langle l1:T1, l2:T2 \rangle$。

- **案例分析**：在对变体值进行案例分析时，我们使用与变体类型定义中相同的标签。我们不再使用 $\text{inl}$ 和 $\text{inr}$ 来标记分支，而是使用 $l1$ 和 $l2$。

**示例：**

让我们考虑一个示例，我们定义一个地址类型，该类型可以是物理地址（PhysicalAddr）或虚拟地址（VirtualAddr）。

1. **定义变体类型：**

   $$
   \text{Addr} = \langle \text{physical}: \text{PhysicalAddr}, \text{virtual}: \text{VirtualAddr} \rangle;
   $$

   这里，$\text{Addr}$ 是一个具有两个标签的变体类型：

   - $\text{physical}$，关联类型 $\text{PhysicalAddr}$
   - $\text{virtual}$，关联类型 $\text{VirtualAddr}$

2. **创建一个变体值：**

   $$
   a = \langle \text{physical} = pa \rangle \ \text{as} \ \text{Addr};
   $$

   $$
   \vdash a : \text{Addr}
   $$

   - 我们创建了一个类型为 $\text{Addr}$ 的值 $a$，通过使用标签 $\text{physical}$ 标记一个 $\text{PhysicalAddr}$ 值 $pa$。
   - 符号 $\vdash a : \text{Addr}$ 表示 $a$ 的类型是 $\text{Addr}$。

3. **定义一个带有案例分析的函数：**

   $$
   \begin{align*}
   \text{getName} =\ & \lambda a: \text{Addr}. \\
   & \text{case } a \ \text{of} \\
   & \quad \langle \text{physical} = x \rangle \Rightarrow x.\text{firstlast} \\
   & | \ \langle \text{virtual} = y \rangle \Rightarrow y.\text{name};
   \end{align*}
   $$

   $$
   \vdash \text{getName} : \text{Addr} \to \text{String}
   $$

   - $\text{getName}$ 是一个函数，接受一个 $\text{Addr}$，返回一个 $\text{String}$。
   - 它对 $a$ 进行案例分析：
     - 如果 $a$ 被标签 $\text{physical}$ 标记，它提取 $x$，并计算 $x.\text{firstlast}$。
     - 如果 $a$ 被标签 $\text{virtual}$ 标记，它提取 $y$，并计算 $y.\text{name}$。

**变体的形式化定义（图 11-11）**

变体的形式化定义包括语法、求值规则和类型规则。

**图 11-11：变体**

该图扩展了简单类型的 $\lambda$ 演算（记为 $\lambda\to$），加入了变体。

**新的语法形式：**

- **项（$t$）：**

  $$
  t ::= \ldots \ |\ \langle l = t \rangle \ \text{as} \ T\ |\ \text{case } t \ \text{of}\ \langle l_i = x_i \rangle \Rightarrow t_i\ (i \in 1..n)
  $$

  - **标记（Tagging）**：$\langle l = t \rangle \ \text{as} \ T$ 通过使用标签 $l$ 将 $t$ 标记为类型 $T$ 的变体值。
  - **案例表达式（Case Expression）**：$\text{case } t \ \text{of}\ \langle l_i = x_i \rangle \Rightarrow t_i$ 表示对 $t$ 的案例分析，使用模式 $\langle l_i = x_i \rangle$ 及对应的表达式 $t_i$。

- **类型（$T$）：**

  $$
  T ::= \ldots \ |\ \langle l_i: T_i \ (i \in 1..n) \rangle
  $$

  - **变体类型（Variant Types）**：$\langle l_i: T_i \rangle$ 表示具有标签 $l_i$ 和对应类型 $T_i$ 的变体类型。

**新的求值规则（$t \to t'$）：**

1. **（E-CaseVariant）：**

   $$
   \frac{}{\text{case } (\langle l_j = v_j \rangle \ \text{as} \ T) \ \text{of}\ \langle l_i = x_i \rangle \Rightarrow t_i\ (i \in 1..n) \to [x_j \mapsto v_j] t_j}
   $$

   - 当求值一个案例表达式，且被分析的项是一个标记值 $\langle l_j = v_j \rangle \ \text{as} \ T$ 时，我们在案例分支中找到匹配的标签 $l_j$。
   - 我们将 $v_j$ 替换到对应的表达式 $t_j$ 中。

2. **（E-Case）：**

   $$
   \frac{t_0 \to t_0'}{\text{case } t_0 \ \text{of}\ \langle l_i = x_i \rangle \Rightarrow t_i \to \text{case } t_0' \ \text{of}\ \langle l_i = x_i \rangle \Rightarrow t_i}
   $$

   - 如果 $t_0$ 可以一步求值到 $t_0'$，那么整个案例表达式求值为 $\text{case } t_0' \ \text{of}\ \langle l_i = x_i \rangle \Rightarrow t_i$。

3. **（E-Variant）：**

   $$
   \frac{t_i \to t_i'}{\langle l_i = t_i \rangle \ \text{as} \ T \to \langle l_i = t_i' \rangle \ \text{as} \ T}
   $$

   - 如果 $t_i$ 可以求值到 $t_i'$，那么标记值相应地求值。

**新的类型规则（$\Gamma \vdash t : T$）：**

1. **（T-Variant）：**

   $$
   \frac{\Gamma \vdash t_j : T_j}{\Gamma \vdash \langle l_j = t_j \rangle \ \text{as} \ \langle l_i: T_i \rangle : \langle l_i: T_i \rangle}
   $$

   - 如果 $t_j$ 的类型为 $T_j$，那么标记值 $\langle l_j = t_j \rangle \ \text{as} \ \langle l_i: T_i \rangle$ 的类型为变体类型 $\langle l_i: T_i \rangle$。

2. **（T-Case）：**

   $$
   \frac{\Gamma \vdash t_0 : \langle l_i: T_i \rangle \quad \forall i,\ \Gamma, x_i: T_i \vdash t_i : T}{\Gamma \vdash \text{case } t_0 \ \text{of}\ \langle l_i = x_i \rangle \Rightarrow t_i : T}
   $$

   - 如果 $t_0$ 的类型为变体类型 $\langle l_i: T_i \rangle$，且每个分支 $t_i$ 在扩展了 $x_i: T_i$ 的上下文中具有类型 $T$，那么整个案例表达式的类型为 $T$。

**关键点：**

- 在变体类型中，标签的顺序是重要的。
- 标签作为变体类型的构造器，它们在构造变体值和模式匹配中使用。

---

**选项类型（Options）**

变体在表示可选值时特别有用——即值可能存在也可能不存在。

**定义一个可选类型：**

$$
\text{OptionalNat} = \langle \text{none}: \text{Unit}, \text{some}: \text{Nat} \rangle;
$$

- $\text{OptionalNat}$ 是一个变体类型，有两种可能性：
  - $\text{none}$，标记为 $\text{Unit}$，表示值的缺失。
  - $\text{some}$，标记为 $\text{Nat}$，表示存在一个自然数。

**使用可选类型：**

- **创建一个空表：**

  $$
  \text{Table} = \text{Nat} \to \text{OptionalNat};
  $$

  $$
  \text{emptyTable} = \lambda n: \text{Nat}. \langle \text{none} = \text{unit} \rangle \ \text{as} \ \text{OptionalNat};
  $$

  $$
  \vdash \text{emptyTable} : \text{Table}
  $$

  - $\text{Table}$ 是一个从 $\text{Nat}$ 到 $\text{OptionalNat}$ 的函数类型，表示一个映射。
  - $\text{emptyTable}$ 是一个始终返回 $\text{none}$ 的函数，表示一个空的映射。

- **扩展表：**

  $$
  \begin{align*}
  \text{extendTable} =\ & \lambda t: \text{Table}. \lambda m: \text{Nat}. \lambda v: \text{Nat}. \\
  & \lambda n: \text{Nat}. \\
  & \quad \text{if } \text{equal } n\ m\ \text{then}\ \langle \text{some} = v \rangle \ \text{as} \ \text{OptionalNat} \\
  & \quad \text{else } t\ n;
  \end{align*}
  $$

  $$
  \vdash \text{extendTable} : \text{Table} \to \text{Nat} \to \text{Nat} \to \text{Table}
  $$

  - $\text{extendTable}$ 接受一个表 $t$，一个键 $m$，和一个值 $v$。
  - 它返回一个新的表，将 $m$ 映射到 $v$，其他查找则委托给 $t$。

- **使用案例分析处理可选值：**

  $$
  x = \text{case } t(5) \ \text{of} \\
  \quad \langle \text{none} = u \rangle \Rightarrow 999 \\
  | \ \langle \text{some} = v \rangle \Rightarrow v;
  $$

  - 当在表中查找一个值时，我们进行案例分析。
  - 如果结果是 $\text{none}$，我们提供一个默认值（例如 $999$）。
  - 如果结果是 $\text{some}\ v$，我们使用值 $v$。

**与其他语言的类比：**

- 像 OCaml 这样的语言内置了对可选类型的支持。
- 在 C、C++ 和 Java 等语言中，$\text{null}$ 值实际上可以看作一种可选类型，其中一个变量可以包含类型 $T$ 的对象，或是 $\text{null}$（即 $\text{Option}(T)$）。

---

**枚举类型（Enumerations）**

变体类型的两个“退化情况”值得特别提及：枚举类型和单字段变体。

**定义枚举类型：**

$$
\begin{align*}
\text{Weekday} =\ \langle & \text{monday}: \text{Unit},\ \text{tuesday}: \text{Unit},\ \text{wednesday}: \text{Unit}, \\
& \text{thursday}: \text{Unit},\ \text{friday}: \text{Unit} \rangle;
\end{align*}
$$

- $\text{Weekday}$ 是一个变体类型，表示工作周的天数。
- 每一天都与 $\text{Unit}$ 类型关联，因此每个标签的唯一可能值是 $\text{unit}$。

**使用枚举类型：**

- **创建值：**

  - 类型为 $\text{Weekday}$ 的值示例：

    $$
    \langle \text{monday} = \text{unit} \rangle \ \text{as} \ \text{Weekday}
    $$

    $$
    \langle \text{tuesday} = \text{unit} \rangle \ \text{as} \ \text{Weekday}
    $$

- **定义针对枚举类型的函数：**

  $$
  \begin{align*}
  \text{nextBusinessDay} =\ & \lambda w: \text{Weekday}. \\
  & \text{case } w \ \text{of} \\
  & \quad \langle \text{monday} = x \rangle \Rightarrow \langle \text{tuesday} = \text{unit} \rangle \ \text{as} \ \text{Weekday} \\
  & | \ \langle \text{tuesday} = x \rangle \Rightarrow \langle \text{wednesday} = \text{unit} \rangle \ \text{as} \ \text{Weekday} \\
  & | \ \langle \text{wednesday} = x \rangle \Rightarrow \langle \text{thursday} = \text{unit} \rangle \ \text{as} \ \text{Weekday} \\
  & | \ \langle \text{thursday} = x \rangle \Rightarrow \langle \text{friday} = \text{unit} \rangle \ \text{as} \ \text{Weekday} \\
  & | \ \langle \text{friday} = x \rangle \Rightarrow \langle \text{monday} = \text{unit} \rangle \ \text{as} \ \text{Weekday};
  \end{align*}
  $$

  - $\text{nextBusinessDay}$ 计算下一个工作日，在星期五之后循环回星期一。

**关于语法的注意：**

- 这里使用的具体语法较为冗长。
- 一些语言提供了针对枚举类型的特殊语法，使其更简洁和易读。

---

**单字段变体（Single-Field Variants）**

具有单个标签的变体类型可以用于创建不同的类型，即使它们的底层类型相同。

**定义单字段变体：**

$$
\text{DollarAmount} = \langle \text{dollars}: \text{Float} \rangle;
$$

$$
\text{EuroAmount} = \langle \text{euros}: \text{Float} \rangle;
$$

- 这些类型表示不同货币的金额。
- 尽管它们都基于 $\text{Float}$，但由于它们的标签不同，因而是不同的类型。

**安全的货币转换函数：**

- **美元到欧元：**

  $$
  \begin{align*}
  \text{dollars2euros} =\ & \lambda d: \text{DollarAmount}. \\
  & \text{case } d \ \text{of} \ \langle \text{dollars} = x \rangle \Rightarrow \\
  & \quad \langle \text{euros} = \text{timesfloat } x\ 1.1325 \rangle \ \text{as} \ \text{EuroAmount};
  \end{align*}
  $$

  $$
  \vdash \text{dollars2euros} : \text{DollarAmount} \to \text{EuroAmount}
  $$

- **欧元到美元：**

  $$
  \begin{align*}
  \text{euros2dollars} =\ & \lambda e: \text{EuroAmount}. \\
  & \text{case } e \ \text{of} \ \langle \text{euros} = x \rangle \Rightarrow \\
  & \quad \langle \text{dollars} = \text{timesfloat } x\ 0.883 \rangle \ \text{as} \ \text{DollarAmount};
  \end{align*}
  $$

  $$
  \vdash \text{euros2dollars} : \text{EuroAmount} \to \text{DollarAmount}
  $$

- **使用这些函数：**

  $$
  \text{mybankbalance} = \langle \text{dollars} = 39.50 \rangle \ \text{as} \ \text{DollarAmount};
  $$

  $$
  \text{euros2dollars} \ (\text{dollars2euros} \ \text{mybankbalance});
  $$

  $$
  \vdash \langle \text{dollars} = 39.49990125 \rangle \ \text{as} \ \text{DollarAmount} : \text{DollarAmount}
  $$

  - 类型系统确保了货币转换的正确性。
  - 如果尝试错误的使用，例如连续两次将美元转换为欧元，会导致类型错误：

    $$
    \text{dollars2euros} \ (\text{dollars2euros} \ \text{mybankbalance});
    $$

    $$
    \vdash \text{Error: parameter type mismatch}
    $$

**益处：**

- 防止混淆底层类型相同但含义不同的值。
- 类型系统在不增加运行时开销的情况下强制执行正确的使用。

---

**变体与数据类型（Variants vs. Datatypes）**

变体与像 ML 语言中的数据类型类似，但也有显著的区别。

**ML 数据类型的等价形式：**

```ocaml
type T = l1 of T1
       | l2 of T2
       | ...
       | ln of Tn
```

**区别：**

1. **大小写约定：**

   - 在 OCaml 中，类型以小写字母开头，构造器（标签）以大写字母开头。
   - 为了清晰起见，我们可以忽略这一点，使用我们自己的约定。

2. **类型注解：**

   - OCaml 在使用构造器构造值时，不需要类型注解。
   - 由于标签在数据类型内是唯一的，因此类型可以被推断。
   - 在我们的变体系统中，我们需要在标记值时指定类型。

3. **省略 $\text{Unit}$ 类型：**

   - 当 OCaml 中的构造器类型为 $\text{Unit}$ 时，可以省略 $\text{of Unit}$ 部分。
   - 这简化了枚举类型的定义。

4. **OCaml 数据类型的附加特性：**

   - **递归类型：**
     - 数据类型可以是递归的，允许像列表这样的定义。
     - 示例：

       ```ocaml
       type NatList = nil
                    | cons of Nat * NatList
       ```

   - **参数化类型：**
     - 数据类型可以在类型变量上参数化。
     - 示例：

       ```ocaml
       type 'a List = nil
                    | cons of 'a * 'a List
       ```

     - 这里的 `'a` 是一个类型变量，允许定义任意类型的列表。

---

**变体作为不交并（Variants as Disjoint Unions）**

变体和和类型通常被称为**不交并**，因为它们将多个类型组合为一个，同时通过标记保持它们的区别。

- **不交并**：组合的类型包括来自各个类型的所有元素，但它们被标记以指示其来源。
- **标记的目的**：确保来自不同类型的值不会被混淆。
- **联合类型（Union Types）**：相比之下，联合类型（如第 15.7 节所述）可能在没有标记的情况下组合类型，可能导致潜在的歧义。

---

**动态类型（Type Dynamic）**

在静态类型语言中，有些情况下数据的类型在编译时无法确定，例如处理外部数据源或进程间通信时。

- **动态类型**：可以引入一个特殊的类型 $\text{Dynamic}$，其值是一个值与其类型标签的对，即 $(v, T)$，其中 $v : T$。
- **类型判断构造（Typecase Constructs）**：这些允许在运行时以类型安全的方式检查 $\text{Dynamic}$ 值的类型。
- **无限不交并**：$\text{Dynamic}$ 类型可以被视为一个无限的变体类型，每个可能的类型作为一个标签。

---

**11.11 通用递归（General Recursion）**

递归允许函数调用自身，能够定义复杂的计算，如阶乘或斐波那契数。

**Fix 组合子：**

- 在无类型的 $\lambda$ 演算中，使用 $\text{fix}$ 组合子实现递归。
- 在类型化的环境中，$\text{fix}$ 不能作为一个项来定义，因为类型限制，所以将其作为一个原语引入。

**使用 $\text{fix}$ 定义递归函数：**

- **函数生成器 $ff$：**

  $$
  \begin{align*}
  ff =\ & \lambda ie: \text{Nat} \to \text{Bool}. \\
  & \lambda x: \text{Nat}. \\
  & \quad \text{if } \text{iszero } x\ \text{then } \text{true} \\
  & \quad \text{else if } \text{iszero } (\text{pred } x)\ \text{then } \text{false} \\
  & \quad \text{else } ie\ (\text{pred } (\text{pred } x));
  \end{align*}
  $$

  $$
  \vdash ff : (\text{Nat} \to \text{Bool}) \to \text{Nat} \to \text{Bool}
  $$

  - $ff$ 是一个高阶函数，给定 $\text{iseven}$ 函数的一个近似 $ie$，返回一个更好的近似。

- **使用 $\text{fix}$ 定义 $\text{iseven}$：**

  $$
  \text{iseven} = \text{fix } ff;
  $$

  $$
  \vdash \text{iseven} : \text{Nat} \to \text{Bool}
  $$

  - $\text{fix } ff$ 计算 $ff$ 的不动点，得到完全定义的 $\text{iseven}$ 函数。

- **使用 $\text{iseven}$：**

  $$
  \text{iseven}\ 7;
  $$

  $$
  \vdash \text{false} : \text{Bool}
  $$

**直觉：**

- $\text{fix}$ 操作符找到一个点，在该点上将函数应用于自身会产生相同的函数，有效地捕获了递归。

**$\text{fix}$ 的形式化定义（图 11-12）：**

**图 11-12：通用递归**

**新的语法形式：**

- **项（$t$）：**

  $$
  t ::= \ldots \ |\ \text{fix } t
  $$

  - $\text{fix } t$ 表示 $t$ 的不动点。

**新的求值规则（$t \to t'$）：**

1. **（E-FixBeta）：**

   $$
   \frac{}{\text{fix } (\lambda x: T1.\ t2) \to [x \mapsto \text{fix } (\lambda x: T1.\ t2)]\ t2}
   $$

   - $\text{fix}$ 作用于一个 lambda 抽象时，通过将自身替换到其主体中来化简。

2. **（E-Fix）：**

   $$
   \frac{t_1 \to t_1'}{\text{fix } t_1 \to \text{fix } t_1'}
   $$

   - 如果 $t_1$ 可以求值到 $t_1'$，那么 $\text{fix } t_1$ 求值到 $\text{fix } t_1'$。

**新的类型规则（$\Gamma \vdash t : T$）：**

- **（T-Fix）：**

  $$
  \frac{\Gamma \vdash t_1 : T1 \to T1}{\Gamma \vdash \text{fix } t_1 : T1}
  $$

  - 如果 $t_1$ 是从 $T1$ 到 $T1$ 的函数，那么 $\text{fix } t_1$ 的类型为 $T1$。

**派生形式：**

- **$\text{letrec}$：**

  $$
  \text{letrec } x: T1 = t1\ \text{in}\ t2 \equiv \text{let } x = \text{fix } (\lambda x: T1.\ t1)\ \text{in}\ t2
  $$

  - 为递归绑定提供了方便的语法。

---

**练习 11.11.1：** 使用 $\text{fix}$ 定义 $\text{equal}$、$\text{plus}$、$\text{times}$ 和 $\text{factorial}$。

**解答：**

1. **定义 $\text{equal}$：**

   $$
   \begin{align*}
   \text{equal} =\ & \text{fix } (\lambda eq: \text{Nat} \to \text{Nat} \to \text{Bool}. \\
   & \quad \lambda n: \text{Nat}. \lambda m: \text{Nat}. \\
   & \quad \text{if } \text{iszero } n\ \text{then } \text{iszero } m \\
   & \quad \text{else if } \text{iszero } m\ \text{then } \text{false} \\
   & \quad \text{else } eq\ (\text{pred } n)\ (\text{pred } m));
   \end{align*}
   $$

   $$
   \vdash \text{equal} : \text{Nat} \to \text{Nat} \to \text{Bool}
   $$

   - 递归比较两个自然数是否相等。

2. **定义 $\text{plus}$：**

   $$
   \begin{align*}
   \text{plus} =\ & \text{fix } (\lambda pl: \text{Nat} \to \text{Nat} \to \text{Nat}. \\
   & \quad \lambda n: \text{Nat}. \lambda m: \text{Nat}. \\
   & \quad \text{if } \text{iszero } n\ \text{then } m \\
   & \quad \text{else } \text{succ } (pl\ (\text{pred } n)\ m));
   \end{align*}
   $$

   $$
   \vdash \text{plus} : \text{Nat} \to \text{Nat} \to \text{Nat}
   $$

   - 递归地将两个自然数相加。

3. **定义 $\text{times}$：**

   $$
   \begin{align*}
   \text{times} =\ & \text{fix } (\lambda tm: \text{Nat} \to \text{Nat} \to \text{Nat}. \\
   & \quad \lambda n: \text{Nat}. \lambda m: \text{Nat}. \\
   & \quad \text{if } \text{iszero } n\ \text{then } 0 \\
   & \quad \text{else } \text{plus } m\ (tm\ (\text{pred } n)\ m));
   \end{align*}
   $$

   $$
   \vdash \text{times} : \text{Nat} \to \text{Nat} \to \text{Nat}
   $$

   - 使用递归加法来乘两个自然数。

4. **定义 $\text{factorial}$：**

   $$
   \begin{align*}
   \text{factorial} =\ & \text{fix } (\lambda fac: \text{Nat} \to \text{Nat}. \\
   & \quad \lambda n: \text{Nat}. \\
   & \quad \text{if } \text{iszero } n\ \text{then } 1 \\
   & \quad \text{else } \text{times } n\ (fac\ (\text{pred } n)));
   \end{align*}
   $$

   $$
   \vdash \text{factorial} : \text{Nat} \to \text{Nat}
   $$

   - 递归地计算一个自然数的阶乘。

---

**使用 $\text{letrec}$ 定义递归函数：**

**练习 11.11.2：** 使用 $\text{letrec}$ 重写你在练习 11.11.1 中的 $\text{plus}$、$\text{times}$ 和 $\text{factorial}$ 定义。

**解答：**

1. **使用 $\text{letrec}$ 定义 $\text{plus}$：**

   $$
   \text{letrec } \text{plus}: \text{Nat} \to \text{Nat} \to \text{Nat} = \\
   \quad \lambda n: \text{Nat}. \lambda m: \text{Nat}. \\
   \quad \text{if } \text{iszero } n\ \text{then } m \\
   \quad \text{else } \text{succ } (\text{plus}\ (\text{pred } n)\ m) \\
   \text{in} \ \ldots
   $$

   - 可以在需要的地方使用 $\text{plus}$。

2. **使用 $\text{letrec}$ 定义 $\text{times}$：**

   $$
   \text{letrec } \text{times}: \text{Nat} \to \text{Nat} \to \text{Nat} = \\
   \quad \lambda n: \text{Nat}. \lambda m: \text{Nat}. \\
   \quad \text{if } \text{iszero } n\ \text{then } 0 \\
   \quad \text{else } \text{plus } m\ (\text{times}\ (\text{pred } n)\ m) \\
   \text{in} \ \ldots
   $$

3. **使用 $\text{letrec}$ 定义 $\text{factorial}$：**

   $$
   \text{letrec } \text{factorial}: \text{Nat} \to \text{Nat} = \\
   \quad \lambda n: \text{Nat}. \\
   \quad \text{if } \text{iszero } n\ \text{then } 1 \\
   \quad \text{else } \text{times } n\ (\text{factorial}\ (\text{pred } n)) \\
   \text{in} \ \ldots
   $$

   - 使用 $\text{letrec}$ 简化了定义，使其更易读。

---

**11.12 列表（Lists）**

列表是一种基本的数据结构，表示元素的序列。

**定义列表：**

- 对于任何类型 $T$，$\text{List}\ T$ 是包含类型为 $T$ 的元素的列表类型。

**图 11-13：列表**

**新的语法形式：**

- **项（$t$）：**

  $$
  t ::= \ldots\ |\ \text{nil}[T]\ |\ \text{cons}[T]\ t\ t\ |\ \text{isnil}[T]\ t\ |\ \text{head}[T]\ t\ |\ \text{tail}[T]\ t
  $$

  - $\text{nil}[T]$：类型为 $\text{List}\ T$ 的空列表。
  - $\text{cons}[T]\ t_1\ t_2$：通过将元素 $t_1$ 添加到列表 $t_2$ 的前面来构造列表。
  - $\text{isnil}[T]\ t$：检查列表 $t$ 是否为空。
  - $\text{head}[T]\ t$：获取列表 $t$ 的第一个元素。
  - $\text{tail}[T]\ t$：获取去掉第一个元素的列表 $t$。

- **值（$v$）：**

  $$
  v ::= \ldots\ |\ \text{nil}[T]\ |\ \text{cons}[T]\ v\ v
  $$

  - 值包括空列表和由值构造的列表。

- **类型（$T$）：**

  $$
  T ::= \ldots\ |\ \text{List}\ T
  $$

  - $\text{List}\ T$ 表示元素类型为 $T$ 的列表类型。

**新的求值规则（$t \to t'$）：**

1. **构造列表：**

   - **（E-Cons1）：**

     $$
     \frac{t_1 \to t_1'}{\text{cons}[T]\ t_1\ t_2 \to \text{cons}[T]\ t_1'\ t_2}
     $$

   - **（E-Cons2）：**

     $$
     \frac{t_2 \to t_2'}{\text{cons}[T]\ v_1\ t_2 \to \text{cons}[T]\ v_1\ t_2'}
     $$

2. **检查空列表：**

   - **（E-IsnilNil）：**

     $$
     \frac{}{\text{isnil}[S]\ (\text{nil}[T]) \to \text{true}}
     $$

   - **（E-IsnilCons）：**

     $$
     \frac{}{\text{isnil}[S]\ (\text{cons}[T]\ v_1\ v_2) \to \text{false}}
     $$

   - **（E-Isnil）：**

     $$
     \frac{t_1 \to t_1'}{\text{isnil}[T]\ t_1 \to \text{isnil}[T]\ t_1'}
     $$

3. **访问列表元素：**

   - **（E-HeadCons）：**

     $$
     \frac{}{\text{head}[S]\ (\text{cons}[T]\ v_1\ v_2) \to v_1}
     $$

   - **（E-Head）：**

     $$
     \frac{t_1 \to t_1'}{\text{head}[T]\ t_1 \to \text{head}[T]\ t_1'}
     $$

   - **（E-TailCons）：**

     $$
     \frac{}{\text{tail}[S]\ (\text{cons}[T]\ v_1\ v_2) \to v_2}
     $$

   - **（E-Tail）：**

     $$
     \frac{t_1 \to t_1'}{\text{tail}[T]\ t_1 \to \text{tail}[T]\ t_1'}
     $$

**新的类型规则（$\Gamma \vdash t : T$）：**

1. **（T-Nil）：**

   $$
   \frac{}{\Gamma \vdash \text{nil}[T1] : \text{List}\ T1}
   $$

2. **（T-Cons）：**

   $$
   \frac{\Gamma \vdash t_1 : T1 \quad \Gamma \vdash t_2 : \text{List}\ T1}{\Gamma \vdash \text{cons}[T1]\ t_1\ t_2 : \text{List}\ T1}
   $$

3. **（T-Isnil）：**

   $$
   \frac{\Gamma \vdash t_1 : \text{List}\ T11}{\Gamma \vdash \text{isnil}[T11]\ t_1 : \text{Bool}}
   $$

4. **（T-Head）：**

   $$
   \frac{\Gamma \vdash t_1 : \text{List}\ T11}{\Gamma \vdash \text{head}[T11]\ t_1 : T11}
   $$

5. **（T-Tail）：**

   $$
   \frac{\Gamma \vdash t_1 : \text{List}\ T11}{\Gamma \vdash \text{tail}[T11]\ t_1 : \text{List}\ T11}
   $$

---

**练习 11.12.1：** 验证对于带有布尔类型和列表的简单类型 $\lambda$ 演算，进展（Progress）和保持（Preservation）定理成立。

**解答：**

- **进展定理**：每个良类型的项要么是一个值，要么可以根据求值规则进行一步求值。

  - 对于列表，我们需要证明像 $\text{cons}$、$\text{isnil}$、$\text{head}$ 和 $\text{tail}$ 这样的操作满足进展性质。
  - 由于求值规则涵盖了列表的所有可能形式，且类型规则确保项是良构的，因此进展定理成立。

- **保持定理**：如果一个良类型的项 $t$ 类型为 $T$，且 $t \to t'$，那么 $t'$ 也具有类型 $T$。

  - 我们验证每个求值规则都保持类型。
  - 例如，在（E-Cons1）中，如果 $\text{cons}[T]\ t_1\ t_2$ 类型为 $\text{List}\ T$，且 $t_1 \to t_1'$，那么 $t_1'$ 类型为 $T$，因此 $\text{cons}[T]\ t_1'\ t_2$ 仍然类型为 $\text{List}\ T$。

---

**练习 11.12.2：** 这里的列表表示包含了许多不必要的类型注解，因为类型规则可以很容易地从上下文中推导出这些注解。是否可以删除所有的类型注解？

**解答：**

- 并非所有类型注解都可以删除，但许多都可以被推断。
- 例如，在 $\text{cons}\ t_1\ t_2$ 中，如果我们知道 $t_2$ 的类型是 $\text{List}\ T1$，那么 $t_1$ 必须类型为 $T1$，因此 $\text{cons}\ t_1\ t_2$ 类型为 $\text{List}\ T1$。
- 然而，在像 $\text{nil}[T]$ 这样的情况下，我们需要指定类型 $T$，因为单独的 $\text{nil}$ 不提供足够的信息。
- 类似地，在函数中，如果元素的类型无法从上下文中清楚地得知，则需要类型注解。

---

**结论**

变体和列表是类型系统中强大的构造，允许对具有不同结构的数据进行灵活而安全的操作。通过有效地使用标签和类型，我们可以利用类型系统来防止错误，并编写更健壮的程序。

**进一步阅读：**

- 关于不动点算子和递归的更多信息，参见 Klop（1980）和 Winskel（1993）。
- 类型算子和高级类型系统特性将在第 29 章讨论。

### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------
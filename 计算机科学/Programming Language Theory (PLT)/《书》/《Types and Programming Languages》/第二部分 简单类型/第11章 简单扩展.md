[toc]



### 第11章 **简单扩展** (Simple Extensions)

本章介绍了简单类型 λ 演算（Simply Typed Lambda-Calculus）的几个常用扩展，这些扩展在类型层面有直接的处理方法。贯穿本章的一个重要主题是**派生形式**（derived forms）的概念。

---

#### 11.1 **基本类型** (Base Types)

**概述：**

- **基本类型**（Base Types）是编程语言提供的一些简单的、无结构的值的集合，如数字（numbers）、布尔值（booleans）或字符（characters）。
- 我们已经详细研究了自然数和布尔值；语言设计者可以以相同的方式添加任意多的基本类型。

**添加新的基本类型：**

- 除了之前的 $Bool$ 和 $Nat$，我们有时还会使用基本类型 $String$（字符串，如 $"hello"$）和 $Float$（浮点数，如 $3.14159$）来丰富示例。

**抽象化基本类型：**

- 出于理论目的，我们通常将特定基本类型的细节抽象掉，假设我们的语言配备了一组**未解释的**（uninterpreted）或**未知的**基本类型集合 $A$，且没有任何对它们的基本操作。
- 这可以通过将 $A$ 的元素（由元变量 $A$ 代表）包含在类型的集合中来实现，如 **图11-1** 所示。

---

**图11-1：未解释的基本类型**

$$
\text{扩展 λ→ (9-1)} \\
\text{新语法形式} \\
T ::= \ldots\ \text{types:} \\
\quad A \quad \text{base type}
$$

---

**解释：**

- 使用🥑字母 $A$ 来表示基本类型（Base Types），而不是 $B$，以避免与布尔类型 $Bool$ 混淆。
- 可以将 $A$ 视为**原子类型**（atomic types），这是基本类型的另一种称呼，因为就类型系统而言，它们没有内部结构。

**未解释的类型有用吗？**

- 尽管我们无法直接命名其元素，但我们仍然可以绑定范围在基本类型上的变量。
- 例如，函数：

  $$
  \lambda x:A.\ x;
  $$

  是类型为 $A \rightarrow A$ 的恒等函数（identity function）。

- 同样，函数：

  $$
  \lambda x:B.\ x;
  $$

  是类型为 $B \rightarrow B$ 的恒等函数。

- 还有函数：

  $$
  \lambda f:A \rightarrow A.\ \lambda x:A.\ f(f(x));
  $$

  是一个将某个给定函数 $f$ 在参数 $x$ 上重复两次的函数，类型为 $(A \rightarrow A) \rightarrow A \rightarrow A$。

---

#### 11.2 **单位类型** (The Unit Type)

**概述：**

- 另一个有用的基本类型是**单位类型**（Unit Type），记作 $Unit$，其元素只有一个，常用在 ML 家族的语言中。
- 与前一节的未解释基本类型不同，$Unit$ 类型以最简单的方式进行解释：我们显式地引入一个单一的元素——项常量 $unit$（小写的 $u$）。

**新语法形式（图11-2）：**

$$
\text{扩展 λ→ (9-1)} \\
\text{新语法形式} \\
t ::= \ldots\ \text{terms:} \\
\quad unit \quad \text{constant unit} \\
v ::= \ldots\ \text{values:} \\
\quad unit \quad \text{constant unit} \\
T ::= \ldots\ \text{types:} \\
\quad Unit \quad \text{unit type}
$$

**新类型规则：**

- 类型规则 $T\text{-Unit}$：

  $$
  \frac{}{\Gamma \vdash unit : Unit} \quad (T\text{-Unit})
  $$

- 该规则表示 $unit$ 是类型 $Unit$ 的一个元素。

**派生形式：**

- 顺序（sequencing）：$t_1; t_2$，定义为：

  $$
  t_1; t_2 \overset{\text{def}}{=} (\lambda x:Unit.\ t_2)\ t_1 \quad \text{其中 } x \notin FV(t_2)
  $$

  - 这里 $x$ 是一个不在 $t_2$ 的自由变量（free variables）集合中的新变量。

---

**图11-2：单位类型**

$$
\text{扩展 λ→ (9-1)} \\
\text{新语法形式} \\
t ::= \ldots\ \text{terms:} \\
\quad unit \quad \text{常量 } unit \\
v ::= \ldots\ \text{values:} \\
\quad unit \quad \text{常量 } unit \\
T ::= \ldots\ \text{types:} \\
\quad Unit \quad \text{单位类型} \\
\text{新类型规则 } \Gamma \vdash t : T \\
\frac{}{\Gamma \vdash unit : Unit} \quad (T\text{-Unit}) \\
\text{新派生形式} \\
t_1; t_2 \overset{\text{def}}{=} (\lambda x:Unit.\ t_2)\ t_1 \quad \text{其中 } x \notin FV(t_2)
$$

---

**解释：**

- 我们将 $unit$ 添加到可能的计算结果值的集合中——实际上，$unit$ 是求值类型为 $Unit$ 的表达式唯一可能的结果。
- 即使在纯函数式语言中，$Unit$ 类型也不是完全没有意义的，但它的主要应用是在🥑具有副作用的语言中，例如对引用单元（reference cells）的赋值（assignment）——我们将在第13章中回到这个主题。
- 🥑在这样的语言中，我们关心的往往是表达式的副作用，而不是其结果；$Unit$ 是此类表达式的适当🥑结果类型。
- 这种对 $Unit$ 的使用类似于 C 和 Java 等语言中的 $void$ 类型。名称 $void$ 暗示了与空类型 $Bot$（参见§15.4）的联系，但 $void$ 的用法实际上更接近于我们的 $Unit$。

---

#### 11.3 **派生形式：顺序和通配符** (Derived Forms: Sequencing and Wildcards)

**顺序（Sequencing）：**

- 在具有副作用的语言中，通常需要按顺序求值两个或多个表达式。
- 顺序符号 $t_1; t_2$ 的效果是先求值 $t_1$，丢弃其无关紧要的结果，然后继续求值 $t_2$。

**形式化顺序的两种方法：**

1. **添加新的语法和规则：**

   - 将 $t_1; t_2$ 作为项语法的新备选项。
   - 添加两个求值规则：

     1. **$E\text{-Seq}$**：

        $$
        \frac{t_1 \rightarrow t_1'}{t_1; t_2 \rightarrow t_1'; t_2} \quad (E\text{-Seq})
        $$

        - 如果 $t_1$ 可以求值到 $t_1'$，那么 $t_1; t_2$ 可以求值到 $t_1'; t_2$。

     2. **$E\text{-SeqNext}$**：

        $$
        \frac{}{unit; t_2 \rightarrow t_2} \quad (E\text{-SeqNext})
        $$

        - 当 $t_1$ 求值到 $unit$ 时，$unit; t_2$ 直接求值为 $t_2$。

   - 添加一个类型规则：

     - **$T\text{-Seq}$**：

       $$
       \frac{\Gamma \vdash t_1 : Unit \quad \Gamma \vdash t_2 : T_2}{\Gamma \vdash t_1; t_2 : T_2} \quad (T\text{-Seq})
       $$

       - 如果 $t_1$ 的类型为 $Unit$，$t_2$ 的类型为 $T_2$，则 $t_1; t_2$ 的类型为 $T_2$。

2. **将 $t_1; t_2$ 视为一个缩写（abbreviation）：**

   - 认为 $t_1; t_2$ 是项 $(\lambda x:Unit.\ t_2)\ t_1$ 的缩写，其中变量 $x$ 被选择为新鲜的（即不同于 $t_2$ 的所有自由变量）。

**等价性和证明：**

- **直觉上**，这两种表示对程序员来说是等价的：🥑🥑🥑顺序构造的高级类型和求值规则可以从 $t_1; t_2$ 被展开为 $(\lambda x:Unit.\ t_2)\ t_1$ 中推导出来。
- **形式化证明**可以通过证明类型和求值都与缩写的展开“可交换”来捕获这种对应关系。

---

**定理11.3.1（顺序是一个派生形式）：**

- **陈述：**

  - 记 $\lambda_E$（“$E$”表示外部语言）为具有 $Unit$ 类型、顺序构造和规则 $E\text{-Seq}$、$E\text{-SeqNext}$、$T\text{-Seq}$ 的简单类型 λ 演算。
  - 记 $\lambda_I$（“$I$”表示内部语言）为**仅**具有 $Unit$ 的简单类型 λ 演算。
  - 定义从外部语言到内部语言的展开函数 $e$，通过将每个 $t_1; t_2$ 替换为 $(\lambda x:Unit.\ t_2)\ t_1$，其中 $x$ 在每种情况下都是新鲜的。
  - 对于 $\lambda_E$ 的每个项 $t$，有：
    1. $t \rightarrow_E t'$ 当且仅当 $e(t) \rightarrow_I e(t')$。
    2. $\Gamma \vdash_E t : T$ 当且仅当 $\Gamma \vdash_I e(t) : T$。
  - 其中，$\lambda_E$ 和 $\lambda_I$ 的求值和类型关系分别用下标 $E$ 和 $I$ 注明。

- **证明：**

  - 每个“当且仅当”的每个方向都可以通过对 $t$ 的结构的直接归纳来进行。

**解释：**

- 定理11.3.1 证明了我们使用“派生形式”这一术语的合理性，因为它表明顺序构造的类型和求值行为可以从更基本的抽象和应用操作中推导出来。
- 引入像顺序这样的派生形式，而不是作为完整的语言构造的好处在于，我们可以扩展**表面语法**（即程序员实际用来编写程序的语言），而不增加需要证明类型安全性定理的内部语言的复杂性。
- 这种语言特性描述的分解方法可以在 Algol 60 报告（Naur et al., 1963）中找到，并在许多最近的语言定义中被大量使用，特别是标准 ML 的定义（Milner, Tofte, and Harper, 1990; Milner, Tofte, Harper, and MacQueen, 1997）。

**派生形式的术语：**

- 🥑🥑🥑派生形式通常被称为**语法糖**（syntactic sugar），遵循 Landin 的说法。
- 🥑🥑🥑🥑🥑🥑将派生形式替换为其低级定义被称为**脱糖**（desugaring）。

### -----------------------------------------

这段表述探讨了“派生形式”（derived forms）在编程语言设计中的意义，并解释了其使用的合理性和益处。以下是详细解释：

### **定理11.3.1 的解释：**

- **派生形式的合理性：**  
  定理 11.3.1 证明了引入派生形式是合理的。它展示了🥑🥑“顺序构造”（sequencing construct）——比如程序中多个操作的按顺序执行——可以从更基本的构造中推导出来，如函数的抽象（abstraction）和应用（application）。这意味着顺序操作不是语言的基本构造，而是通过已有的更基本操作来实现的，这正是派生形式的意义：它们是通过现有构造推导出来的，作为程序员编写代码时的简化工具。

### **派生形式的益处：**

- **表面语法的扩展：**  
  派生形式的引入允许语言的**表面语法**扩展，表面语法是程序员实际使用的语言结构。比如，程序员可以用更简单的顺序表达式编写代码，而不必关心其背后是如何实现的。
  
- **不增加内部复杂性：**  
  尽管派生形式让语言使用变得更直观和方便，但它并没有增加语言内部的复杂性，特别是**类型安全性定理**（type safety theorem）的证明难度。语言的核心构造（基础的抽象和应用）仍然保持不变，而派生形式只是在编写代码时对这些基础构造的简化。

### **历史背景和例子：**

- **Algol 60 报告中的分解方法：**  
  这种将语言特性分解为派生形式的方法最早可以追溯到 **Algol 60** 报告（Naur et al., 1963）。在 Algol 60 中，🥑🥑许多语言构造被定义为派生形式，而不是作为基本操作，这使得语言更加简洁，易于理解和扩展。
  
- 🥑也就是许多都被定义为语法糖
  
- **标准 ML 中的使用：**  
  标准 ML 的语言定义（Milner et al., 1990 和 1997）也广泛使用了这种方法。在标准 ML 中，许多复杂的语言特性是通过组合更简单的基本操作实现的。通过引入派生形式，语言的定义变得更加清晰，而其核心结构仍然保持相对简洁。

### **术语解释：**

- **派生形式与语法糖（Syntactic Sugar）：**  
  派生形式也被称为**语法糖**（syntactic sugar）。这个术语源自 Landin 的研究。语法糖的意义在于，它们使得语言的语法对程序员而言更加友好，但不改变语言的核心功能。语法糖只是对底层功能的一种更易理解的表示方法。

- **脱糖（Desugaring）：**  
  **脱糖**（desugaring）是指将派生形式替换为其底层定义的过程。例如，编译器在编译代码时，可能会将程序员使用的语法糖形式转化为其底层的抽象和应用操作，这就是脱糖的过程。这种技术确保了派生形式在内部实际上是由基本的语言构造实现的，而不会增加实现的复杂性。

### **总结：**

派生形式是编程语言设计中的一种简化技术，它允许语言的表面语法更加简洁和易于使用，而不会增加语言内部的复杂性，特别是在类型安全性等方面的证明工作。派生形式本质上是语法糖，编译时通过脱糖处理将其转换为基础构造。在编程语言的发展过程中，这种方法已被广泛应用，极大地提升了语言的易用性和可维护性。



### ----------------------

---

**通配符（Wildcard）：**

- 另一个在后续示例中有用的派生形式是用于变量绑定器的“通配符”约定。
- 当我们想要编写一个“哑元”（dummy）的 λ 抽象，其中参数变量实际上并未在抽象的主体中使用时，这种情况经常发生（例如，在通过脱糖创建的顺序项中）。
- 在这种情况下，不必显式地为绑定变量选择一个名称是很烦人的；相反，我们希望将其替换为一个通配符绑定器，记作 $\_$。
- 即，我们将 $\lambda\ _:S.\ t$ 作为 $\lambda x:S.\ t$ 的缩写，其中 $x$ 是不出现在 $t$ 中的某个变量。

---

#### **习题11.3.2 [«]**

**题目：**

- 给出通配符抽象的类型和求值规则，并证明它们可以从上述缩写中推导出来。

**解答：**

**1. 给出通配符抽象的类型和求值规则**

- **新语法形式：**

  $$
  t ::= \ldots\ \mid \lambda\ _:T.\ t \quad \text{通配符抽象}
  $$

- **类型规则：**

  - **$T\text{-AbsWildcard}$：**

    $$
    \frac{\Gamma \vdash t : T_2}{\Gamma \vdash \lambda\ _:T_1.\ t : T_1 \rightarrow T_2} \quad (T\text{-AbsWildcard})
    $$

    - 由于通配符 $\_$ 不出现在 $t$ 中，我们不需要在类型环境 $\Gamma$ 中添加任何绑定。

- **求值规则：**

  - 通配符抽象在求值时与普通的 λ 抽象相同，因为求值规则并不依赖于变量名。

  - **应用规则 $E\text{-AppAbs}$：**

    $$
    \frac{}{\left( \lambda\ _:T_{11}.\ t_{12} \right)\ v_2 \rightarrow t_{12}} \quad (E\text{-AppAbsWildcard})
    $$

    - 当应用一个通配符抽象时，由于参数不在主体中使用，直接返回主体 $t_{12}$。

**2. 证明它们可以从缩写中推导出来**

- **通配符抽象的缩写：**

  $$
  \lambda\ _:T_1.\ t \overset{\text{def}}{=} \lambda x:T_1.\ t \quad \text{其中 } x \notin FV(t)
  $$

- **类型规则的推导：**

  - 根据缩写，将通配符抽象展开为标准的 λ 抽象。

  - 使用类型规则 $T\text{-Abs}$：

    $$
    \frac{\Gamma , x:T_1 \vdash t : T_2}{\Gamma \vdash \lambda x:T_1.\ t : T_1 \rightarrow T_2} \quad (T\text{-Abs})
    $$

  - 由于 $x \notin FV(t)$，$t$ 中不包含 $x$，因此我们可以从 $\Gamma$ 推导出 $\Gamma , x:T_1 \vdash t : T_2$，因为 $x$ 未被使用。

  - 但是，根据弱化引理（引理9.3.7）：

    - 如果 $\Gamma \vdash t : T_2$，那么对于任何 $x \notin \text{dom}(\Gamma)$，都有 $\Gamma , x:T_1 \vdash t : T_2$。

  - 因此，类型规则 $T\text{-AbsWildcard}$ 可以从 $T\text{-Abs}$ 和弱化引理推导出来。

- **求值规则的推导：**

  - 求值规则不涉及类型，因此求值规则可以直接应用。

  - 通配符抽象与普通的 λ 抽象在求值时行为相同，因为变量名在求值过程中并不重要。

---

**总结：**

- 我们通过添加新的语法形式和规则，定义了通配符抽象的类型和求值规则。
- 然后，通过将通配符抽象展开为标准的 λ 抽象，使用已有的类型规则和弱化引理，我们证明了这些规则可以从缩写中推导出来。

### -------------------

**弱化引理**（Weakening Lemma）

#### **定义和背景：**

**弱化引理**是🥑类型理论和证明理论中的一个重要定理，它表明在类型系统中，如果一个项在某个上下文中是可类型化的，那么在这个上下文中增加不相关的假设（即引入额外的变量或类型假设）后，该项仍然是可类型化的。🥑**弱化**指的是向上下文中添加🥑额外的假设，而不影响原本的推导结论。

换句话说，弱化引理表明，如果一个类型推导在某个上下文下成立，那么添加无关的额外假设不会破坏该推导的正确性。

#### **形式化表述：**

假设我们有一个项 $t$ 和上下文 $\Gamma$ 以及 $\Gamma'$，如果在上下文 $\Gamma$ 下，项 $t$ 有类型 $T$，即：

$$
\Gamma \vdash t : T
$$

那么在一个扩展了 $\Gamma$ 的上下文 $\Gamma' \cup \Gamma$ 中，$t$ 仍然有类型 $T$：

$$
\Gamma' \cup \Gamma \vdash t : T
$$

其中，$\Gamma'$ 包含的是不影响 $t$ 类型推导的额外假设。

#### **重要性：**

- **证明的一致性：** 弱化引理帮助我们在类型推导的过程中，🥑🥑确保在增加新的上下文假设时不会影响已有的证明。这保证了类型系统在扩展上下文时的稳定性。
  
- **类型系统的健全性：** 弱化引理对于类型系统的健全性（soundness）证明非常重要。在证明类型系统的某些性质时，我们常常需要假设扩展的上下文不会影响原来的推导，因此弱化引理为这样的证明提供了基础。

- **递归定义和扩展语言特性的合理性：** 在设计语言时，往往需要引入新的语言特性或操作符，这些扩展在进行类型检查时不能影响现有的规则。弱化引理确保了这种引入不会破坏系统的类型安全性。

#### **证明思路：**

弱化引理的证明通常是通过**结构归纳法**（structural induction）来完成的。大致思路如下：

1. **基础情况（Base Case）：** 对于最简单的情况下，例如常量项，它们的类型推导不依赖于上下文中的变量，因此，向上下文添加额外假设不影响常量的类型推导。
   
2. **递归情况（Inductive Case）：** 对于复杂的项，如函数应用、条件表达式等，我们可以假设这些子项的类型推导在上下文 $\Gamma$ 下成立，并且递归地证明向上下文添加额外假设不会影响它们的类型推导。通过对这些更复杂的项应用递归假设，完成整个项的类型推导不变性证明。

#### **举例：**

考虑一个简单的 λ 演算表达式：$t = \lambda x. x$，它的类型为 $T = \text{Bool} \to \text{Bool}$，并且在空上下文 $\Gamma = \emptyset$ 下有类型推导：

$$
\emptyset \vdash (\lambda x: \text{Bool}. x) : \text{Bool} \to \text{Bool}
$$

根据弱化引理，我们可以在上下文中添加额外的假设（例如，某个不相关变量 $y$ 的类型假设）：

$$
\{y : \text{Nat}\} \vdash (\lambda x: \text{Bool}. x) : \text{Bool} \to \text{Bool}
$$

即使在新上下文中加入了对 $y$ 的假设，$\lambda x. x$ 的类型仍然是 $\text{Bool} \to \text{Bool}$，这个额外的假设不会影响它的类型推导。

#### **结论：**

弱化引理是类型系统中保证类型推导稳定性和一致性的关键定理。它确保了在类型推导的过程中，向上下文中添加无关的假设不会影响现有的类型推导结果。这一特性为类型系统的健全性证明以及扩展语言特性提供了理论基础。

### ----------------------

### 如何理解语法糖及其在通配符抽象中的使用

**语法糖**（Syntactic Sugar）指的是编程语言中为了让代码更易读、书写更简洁而引入的简化形式。这些简化形式在编译或解释时会被替换成语言中的标准结构或底层实现。尽管这些简化形式让程序员的代码看起来更加直观，但从语言本质上讲，它们并没有增加任何新的功能或改变语言的基础行为。它们最终都会“展开”或“脱糖”成等价的、更基本的语言构造。

### 通配符抽象和语法糖的使用

这段话具体讨论了**通配符抽象**（Wildcard Abstraction），这是语言中的一种特性，它可能是为了简化程序员的编程体验而引入的一种语法糖。

#### **第一步：定义通配符抽象**

首先，语言设计者通过为通配符抽象定义**新的语法形式和规则**，将其引入到语言中。这些规则包括：

- **类型规则：** 描述了通配符抽象的类型推导方式，定义了如何为包含通配符的表达式确定类型。
- **求值规则：** 描述了通配符抽象在求值时应如何展开为更基本的表达式，并解释其行为。

例如，假设我们有通配符抽象 $f(x, \_)$，其中 $\_$ 是一个通配符。语言设计者可能会定义一套规则，规定通配符的类型可以如何推导，以及求值时如何处理通配符。

#### **第二步：展开为标准 λ 抽象**

接下来，设计者使用**标准 λ 抽象**来解释通配符抽象。通配符抽象并不是语言的一个基础特性，而是语法糖。因此，它必须被**展开**或**脱糖**为标准的 λ 抽象，这就是"语法糖"的意义所在。

例如，通配符抽象 $f(x, \_)$ 可能会被展开为一个标准的 λ 抽象：

$$
f(x, y) \quad \text{（其中 $y$ 是一个新变量，取代了通配符 $\_$）}
$$

通过这种展开方式，通配符抽象实际上是通过语言中已有的基础构造（如 λ 抽象）来实现的。

#### **第三步：使用已有的类型规则和弱化引理**

一旦通配符抽象被展开为标准的 λ 抽象，语言中**已有的类型规则**就可以应用到这种展开后的形式上了。这意味着，无需为通配符抽象专门设计一整套全新的类型推导规则，语言现有的类型推导机制已经足够了。

此外🥑🥑🥑，**弱化引理**（Weakening Lemma）也可以帮助证明，通配符抽象的类型推导不会破坏原有的类型系统。如果我们在已有的上下文中引入通配符抽象，然后将其展开为标准的 λ 抽象，弱化引理保证了原有类型推导的稳定性。

#### **证明通配符规则的可推导性**

通过以上的步骤，我们可以证明，通配符抽象的类型和求值行为都是基于已有的 λ 抽象和类型系统。这意味着，通配符规则并不是一种“新的”或“独立的”规则，而是可以通过展开为标准 λ 抽象和应用现有类型规则来推导的。

### **总结：语法糖的作用**

1. **简化编程体验：** 语法糖提供了更直观的编写方式，简化了代码的书写和阅读体验，比如使用通配符让函数定义更加简洁。
  
2. **内部处理标准化：** 在编译或求值阶段，语法糖会被“脱糖”（desugaring），转化为语言的标准表达方式，在本质上与语言的基础结构一致。

3. **类型系统稳定性：** 使用已有的类型规则和引理（如弱化引理）可以证明，语法糖不会影响语言的类型安全性。这意味着，无论我们引入多少语法糖，类型系统的核心性质不会改变。

通过这种方式，语言设计者可以在不增加语言复杂性的情况下，扩展语言的功能，让开发者的编程体验更为简便。

### ------------------------------

---

### **附加习题解答**

#### **习题11.2.1 [«««]**

**题目：**

- 是否有办法在只有基本类型 $Unit$ 的简单类型 λ 演算中构造一系列项 $t_1, t_2, \ldots$，使得对于每个 $n$，项 $t_n$ 的大小至多为 $O(n)$，但需要至少 $O(2^n)$ 步求值才能达到正常形式？

**解答：**

**目标：**

- 构造一系列项 $t_n$，满足：

  1. 对于每个 $n$，项 $t_n$ 的大小为 $O(n)$。
  2. 求值 $t_n$ 到正常形式需要至少 $O(2^n)$ 步。

**思路：**

- 我们需要在简单类型 λ 演算中构造一个项，其求值步骤呈指数级增长。

- 由于只有基本类型 $Unit$，我们需要利用函数的嵌套和应用来实现这一点。

**构造：**

- 定义项 $t_n$ 为一个高阶函数，不断嵌套应用自身。

- 具体地，我们可以定义：

  $$
  t_n = (\lambda f:Unit \rightarrow Unit.\ f\ f)\ (\lambda f:Unit \rightarrow Unit.\ f\ f)
  $$

  - 但是这样的项在简单类型 λ 演算中是不可类型化的，因为类型系统不允许函数自身作为参数。

- 为了在简单类型系统中构造需要指数步求值的项，我们可以使用**教堂数**（Church numerals）的概念。

**教堂数的构造：**

- 在 λ 演算中，教堂数 $n$ 表示为：

  $$
  \text{cn}_n = \lambda f:T \rightarrow T.\ \lambda x:T.\ f^n(x)
  $$

  - 其中 $f^n$ 表示函数 $f$ 的 $n$ 次复合。

- 在我们的情况下，由于只有 $Unit$ 类型，我们可以令 $T = Unit$。

- 定义恒等函数：

  $$
  I = \lambda x:Unit.\ x
  $$

- 定义函数 $G = \lambda f:Unit \rightarrow Unit.\ f\ f$

  - 但在简单类型系统中，这个函数不可类型化。

- **改进方案：**

  - 我们可以定义一个能够模拟指数级增长的项，例如使用固定组合子。

- **有限的可能性：**

  - 由于简单类型 λ 演算是强规范化的（strongly normalizing），所有类型良好的项都保证在有限步内归约到正常形式。

- **结论：**

  - **在只有基本类型 $Unit$ 的简单类型 λ 演算中，不可能构造满足题目要求的项序列。**

- **理由：**

  - 因为在简单类型 λ 演算中，所有类型良好的项都是强规范化的，其归约步骤的数量是多项式级别的，无法达到指数级增长。

---

### **小结**

- 本章介绍了简单类型 λ 演算的几个常用扩展，包括未解释的基本类型、单位类型和派生形式（如顺序和通配符）。
- 我们探讨了如何使用派生形式来扩展语言的表面语法，而不增加内部语言的复杂性，从而有助于证明类型安全性等性质。
- 通过对习题的解答，我们加深了对这些概念的理解，并认识到简单类型 λ 演算的限制和特性。

---

**参考文献：**

- Naur, P., et al. (1963). Report on the Algorithmic Language ALGOL 60.
- Milner, R., Tofte, M., & Harper, R. (1990). The Definition of Standard ML.
- Milner, R., Tofte, M., Harper, R., & MacQueen, D. (1997). The Definition of Standard ML (Revised).

---

**如果您对上述内容有任何疑问，或者希望进一步讨论，请随时提出！**

### ---------------------------

### 第11章 **简单扩展** (Simple Extensions)

---

本章介绍了简单类型 λ 演算（Simply Typed Lambda-Calculus）的几个常用扩展，这些扩展在类型层面有直接的处理方法。贯穿本章的一个重要主题是🥑🥑🥑🥑**派生形式**（derived forms）的概念。

### ---------------------------

### **派生形式**（Derived Forms）详解

**派生形式**（Derived Forms）在编程语言设计中是指通过**已有的基础构造**推导出来的简化形式。这些形式并不是语言中的核心构造，而是使用基础构造的组合或简化来帮助程序员更容易编写代码。这些形式也常被称为**语法糖**（Syntactic Sugar），它们在语言实现时通常会被**脱糖**（Desugaring）为等价的基础形式。

#### **核心概念**：

1. **简化编写过程：**  
   派生形式的目的是让语言的使用更加直观和简便。它提供了程序员更高层次的抽象，使得代码表达更为简洁、清晰。例如，条件表达式 $if \, t1 \, then \, t2 \, else \, t3$ 可以看作是一种派生形式，它实际上可以通过更基本的逻辑操作来实现。

2. **不改变语言的功能：**  
   尽管派生形式让编写代码更加简单，它并没有改变语言的核心表达能力。派生形式始终可以**通过基础构造来表示**，并且不引入新的特性或功能。

3. **语法糖的本质：**  
   派生形式就是“语法糖”的一种体现。语法糖的作用是通过封装已有的语言构造，提供更好的书写体验。例如，许多编程语言中引入的列表推导式（List Comprehension）就是派生形式，虽然这种形式提供了生成列表的简便语法，但它可以通过循环和条件语句来实现。

#### **派生形式的作用：**

1. **扩展表面语法（Surface Syntax）：**  
   派生形式可以扩展语言的表面语法，而不增加语言核心的复杂性。表面语法是指程序员实际编写代码时使用的语法。派生形式允许程序员通过更高层次的语法构造来表达一些常见的模式，而不需要直接使用底层的构造。

2. **增强可读性和可维护性：**  
   使用派生形式可以使代码更加简洁、可读，减少重复代码和错误。例如，$let \, x = e1 \, in \, e2$ 是许多语言中常见的派生形式，它简化了局部变量绑定的表达方式，而实际上可以通过函数应用来实现。

3. **减少学习负担：**  
   派生形式通过提供更直观的语法，降低了程序员学习和掌握语言的难度。程序员可以使用这些形式编写代码，而不必了解底层的复杂实现，从而使语言对初学者更加友好。

#### **派生形式的定义与展开**：

1. **定义派生形式：**  
   在语言设计中，派生形式通过一套明确的语法和类型规则来定义。例如，假设我们定义了派生形式 $x \gets e$，表示将表达式 $e$ 的值赋给变量 $x$。在底层实现中，它可能被展开为一个更基本的操作，如 $x := e$。

2. **展开派生形式（Desugaring）：**  
   派生形式最终会被“脱糖”，也就是展开为其对应的基础构造。编译器在处理派生形式时，会将它转换为语言核心构造的组合。例如，$if \, t1 \, then \, t2 \, else \, t3$ 可能会被展开为基于逻辑运算符的低级实现。

#### **派生形式与类型系统的关系：**

派生形式的引入不仅影响语法设计，也可能涉及类型系统的扩展。使用派生形式时，通常需要为它们定义类型规则。然而，由于派生形式会被展开为基础构造，实际的类型推导只需应用到这些基础构造上。这意味着派生形式不需要为每种类型规则重新定义。

#### **举例：**

- **条件表达式**：  
  在许多语言中，$if \, t1 \, then \, t2 \, else \, t3$ 是一个派生形式。它提供了更直观的条件判断写法，但在底层可能被实现为一系列逻辑运算或分支指令。

- **函数调用简化**：  
  在一些函数式编程语言中，$f(x)$ 是一个派生形式，它实际可以通过 λ 表达式来实现，如 $\lambda x. f(x)$。

#### **总结：**

派生形式在编程语言中扮演了重要角色，它让程序员能够通过简化的语法编写更清晰的代码，而不会增加语言核心的复杂性。通过“脱糖”机制，派生形式最终会被转化为基础构造，这确保了它们与语言的核心系统保持一致。



🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑

在许多编程语言中，$let \, x = e1 \, in \, e2$ 这一表达式是一种常见的**派生形式**。它的作用是：首先计算表达式 $e1$，然后将其结果绑定到变量 $x$，接着在表达式 $e2$ 中使用这个变量 $x$。这个语法结构提供了方便的局部变量绑定方式，使得程序员可以在不污染全局作用域的情况下使用临时变量。

然而，这种简化的表达方式实际上可以通过**函数应用**来实现。也就是说，$let \, x = e1 \, in \, e2$ 可以等价地表示为 $\lambda x. e2 \, (e1)$。这是将 $e1$ 作为参数传递给匿名函数 $\lambda x. e2$，其中 $x$ 是 $e1$ 的局部绑定变量，并且 $e2$ 是在这个局部上下文中计算的表达式。

### 具体步骤：

1. **$let$ 形式**：  
   $let \, x = e1 \, in \, e2$ 表示先计算 $e1$，然后在 $e2$ 中使用 $x$ 绑定为 $e1$ 的值。

2. **转换为函数应用**：  
   它等价于一个匿名函数 $\lambda x. e2$，这个函数的参数是 $x$，然后将 $e1$ 作为参数传递给这个函数。

3. **最终等式**：  
   $\lambda x. e2 \, (e1)$，这个表达式中，$e1$ 作为实参传递给 $\lambda x. e2$，相当于在函数体 $e2$ 中使用 $e1$ 的结果。

### 例子：

假设有 $let \, x = 3 \, in \, x + 1$，该表达式可以转换为 $\lambda x. x + 1 \, (3)$。计算 $x + 1$ 时，$x$ 的值是 $3$，结果为 $4$。

通过这种方式，我们可以看出，$let$ 绑定本质上是一种派生形式，它通过函数应用来实现变量的局部绑定和作用域控制。

### ---------------------------------------

---

#### 11.4 **类型断言** (Ascription)

**概述：**

- 类型断言（Ascription）是一个简单但常用的特性，它允许我们显式地为给定的项指定一个特定的类型。
- 我们使用 $t \text{ as } T$ 来表示“将类型 $T$ 断言给项 $t$”。
- 类型规则 $T\text{-Ascribe}$ 和求值规则 $E\text{-Ascribe}$ 定义了类型断言的行为。

---

##### **图11-3：类型断言**

$$
\text{→ as 扩展 λ→ (9-1)}
$$

**新语法形式**

$$
\begin{align*}
t &::= \ldots\ \text{terms:} \\
&\quad t\ \text{as}\ T \quad \text{ascription}
\end{align*}
$$

**新求值规则** $t \rightarrow t'$

1. **$E\text{-Ascribe}$：**

   $$
   \frac{}{\textcolor{blue}{v_1\ \text{as}\ T\ \rightarrow\ v_1}} \quad (E\text{-Ascribe})
   $$

   - 当项为值 $v_1$ 断言类型 $T$ 时，直接去掉类型断言，返回 $v_1$。

2. **$E\text{-Ascribe1}$：**

   $$
   \frac{t_1 \rightarrow t_1'}{\textcolor{blue}{t_1\ \text{as}\ T\ \rightarrow\ t_1'\ \text{as}\ T}} \quad (E\text{-Ascribe1})
   $$

   - 如果 $t_1$ 可以求值为 $t_1'$，那么 $t_1\ \text{as}\ T$ 可以求值为 $t_1'\ \text{as}\ T$。

**新类型规则** $\Gamma \vdash t : T$

- **$T\text{-Ascribe}$：**

  $$
  \frac{\Gamma \vdash t_1 : T}{\textcolor{blue}{\Gamma \vdash t_1\ \text{as}\ T : T}} \quad (T\text{-Ascribe})
  $$

  - 如果 $t_1$ 的类型是 $T$，那么 $t_1\ \text{as}\ T$ 的类型也是 $T$。

---

**解释：**

- **用途：**

  - **文档化**：在大型复合表达式中，使用类型断言可以帮助读者跟踪子表达式的类型，提高程序的可读性。
  - **调试**：当编写复杂表达式时，程序员可能不清楚所有子表达式的类型，添加类型断言可以明确程序员的想法，有助于定位类型错误的来源。
  - **控制类型打印**：在类型检查器中，类型断言可以用于控制复杂类型的打印方式，例如使用类型缩写。

- **类型检查行为：**

  - 在处理类型断言 $t\ \text{as}\ T$ 时，类型检查器首先展开 $T$ 中的任何类型缩写，验证 $t$ 的类型确实是 $T$，然后将 $T$ 本身（精确到书写形式）作为类型断言的类型。

- **求值行为：**

  - 求值时，类型断言不会影响项的求值过程，它在求值时被简单地丢弃。

---

**示例：**

- 定义类型缩写：

  $$
  \text{UU} = Unit \rightarrow Unit;
  $$

- 使用类型缩写的项：

  $$
  (\lambda f:\text{UU}.\ f\ unit)\ (\lambda x:Unit.\ x);
  $$

- 控制类型打印：

  - 如果希望类型打印为 $\text{UU} \rightarrow \text{UU}$，可以：

    1. 更改抽象中的类型注释：

       $$
       \lambda f:\text{UU}.\ f;
       $$

    2. 或者对整个抽象添加类型断言：

       $$
       (\lambda f:Unit \rightarrow Unit.\ f)\ \text{as}\ \text{UU} \rightarrow \text{UU};
       $$

---

#### **习题11.4.1 [推荐, ««]**

**题目：**

1. 🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑

   1. 展示如何将类型断言表示为一个派生形式。证明这里给出的“官方”类型和求值规则在适当的意义下对应于你的定义。

2. 假设我们没有给出规则 $E\text{-Ascribe}$ 和 $E\text{-Ascribe1}$，而是给出了一个“急切的”规则：

   $$
   \frac{}{\textcolor{blue}{t_1\ \text{as}\ T\ \rightarrow\ t_1}} \quad (E\text{-AscribeEager})
   $$

   立即在遇到类型断言时丢弃它。类型断言还能被视为一个派生形式吗？

---

**解答：**

**1. 将类型断言表示为派生形式**

- **定义：**

  将类型断言 $t\ \text{as}\ T$ 视为项 $t$ 的一个缩写，即：

  $$
  t\ \text{as}\ T \overset{\text{def}}{=} (\lambda x:T.\ x)\ t
  $$

  - 其中，$\lambda x:T.\ x$ 是类型为 $T \rightarrow T$ 的恒等函数。

- **证明对应性：**

  - **类型规则对应性：**

    - **展开后的项：** $(\lambda x:T.\ x)\ t$

    - **类型推导：**

      1. 假设 $\Gamma \vdash t : T$。

      2. 通过 $T\text{-Abs}$，我们有：

         $$
         \frac{\Gamma , x:T \vdash x : T}{\Gamma \vdash \lambda x:T.\ x : T \rightarrow T} \quad (T\text{-Abs})
         $$

      3. 通过 $T\text{-App}$，我们有：

         $$
         \frac{\Gamma \vdash \lambda x:T.\ x : T \rightarrow T \quad \Gamma \vdash t : T}{\Gamma \vdash (\lambda x:T.\ x)\ t : T} \quad (T\text{-App})
         $$

      - 这与类型断言的类型规则 $T\text{-Ascribe}$ 一致。

  - **求值规则对应性：**

    - **展开后的项求值：**

      1. 对于值 $v$：

         $$
         (\lambda x:T.\ x)\ v \rightarrow [x \mapsto v]\ x = v \quad (E\text{-AppAbs})
         $$

         - 这对应于 $E\text{-Ascribe}$，即 $v\ \text{as}\ T \rightarrow v$。

      2. 对于非值 $t$：

         - 如果 $t$ 还可以求值，即 $t \rightarrow t'$，则：

           $$
           (\lambda x:T.\ x)\ t \rightarrow (\lambda x:T.\ x)\ t' \quad (E\text{-App1})
           $$

         - 这对应于 $E\text{-Ascribe1}$，即 $t\ \text{as}\ T \rightarrow t'\ \text{as}\ T$。

**2. 使用急切的求值规则**

- **新的求值规则：**

  $$
  \frac{}{\textcolor{blue}{t_1\ \text{as}\ T\ \rightarrow\ t_1}} \quad (E\text{-AscribeEager})
  $$

- **分析：**

  - 现在，类型断言在遇到时立即被丢弃，无论 $t_1$ 是否为值。

- **能否作为派生形式？**

  - **不能**。

  - **理由：**

    - 在我们的派生形式中，类型断言被定义为 $(\lambda x:T.\ x)\ t$。

    - 但在展开后，$(\lambda x:T.\ x)\ t$ 的求值需要先对 $t$ 进行求值，直到它成为值，然后才能应用 $E\text{-AppAbs}$。

    - 因此，展开后的项在求值时，类型断言不会立即被丢弃，而是等待 $t$ 求值完成。

  - **结论：**

    - 如果类型断言的求值规则是急切的，则它不能被表示为上述派生形式。

### ------------------------------

这个问题讨论的是如何处理**类型断言（Ascription）**，以及给定不同求值规则时，类型断言是否还能被视为一种派生形式。我们逐步解释一下这些内容。

### 1. **类型断言是什么？**

类型断言（Ascription）是对一个表达式明确声明其类型的一种方式。通常，它是为了**增强可读性**或**帮助编译器理解类型信息**。例如，表达式 `t as T` 意思是 "表达式 `t` 被断言为类型 `T`"。这种断言并不会改变 `t` 的值，但可以增加类型信息。

### 2. **两种不同的规则：E-Ascribe 和 E-AscribeEager**

这个问题给出了两种不同的处理类型断言的求值规则：

#### **2.1. "官方"规则：**

在通常的情况下（即 "官方" 给出的规则），类型断言的求值规则（$E\text{-Ascribe}$ 和 $E\text{-Ascribe1}$）不会立即丢弃类型断言，而是逐步求值：

1. **$E\text{-Ascribe1}$**：在求值过程中，如果表达式 `t` 还没有完全求值，那么我们首先对 `t` 进行求值。

   $$
   \frac{t_1 \rightarrow t_1'}{t_1\ \text{as}\ T \rightarrow t_1'\ \text{as}\ T} \quad (E\text{-Ascribe1})
   $$

2. **$E\text{-Ascribe}$**：当 `t_1` 完全求值之后，如果 `t_1` 已经是一个值（通常是常量），那么断言 `t_1 as T` 最终只是返回 `t_1` 本身，但类型信息仍然保留在推导中。

   $$
   \frac{}{\text{if}\ t_1\ \text{is a value}, t_1\ \text{as}\ T \rightarrow t_1} \quad (E\text{-Ascribe})
   $$

这两个规则的设计确保在类型断言过程中，首先对表达式 `t_1` 完全求值，直到 `t_1` 变成值后，才将断言丢弃。

#### **2.2. "急切"规则（E-AscribeEager）：**

这里的问题提出了另一种求值规则，即急切地在一开始就直接丢弃类型断言。这就是规则 $E\text{-AscribeEager}$ 的意思：

$$
\frac{}{\textcolor{blue}{t_1\ \text{as}\ T\ \rightarrow\ t_1}} \quad (E\text{-AscribeEager})
$$

根据这个规则，在程序一遇到类型断言 `t_1 as T` 时，**立即**丢弃断言，继续求值 `t_1`。换句话说，断言不对 `t_1` 的求值产生任何影响，只是立刻被忽略。

### 3. **是否仍可以将类型断言视为派生形式？**

#### **派生形式的定义：**

**派生形式**通常是通过现有的基本语法和规则来定义的一种简化形式。对于类型断言来说，之所以可以视为派生形式，是因为它不会改变求值的结果，只是增加了类型信息。

#### **问题的核心：**

- 如果我们采用 $E\text{-Ascribe}$ 和 $E\text{-Ascribe1}$ 规则，类型断言的求值是逐步的，并且类型信息在推导过程中被保留，因此**类型断言是一个派生形式**。
- 然而，如果采用 $E\text{-AscribeEager}$ 规则，在遇到类型断言时立即丢弃类型信息，那么这个断言没有对求值过程产生任何作用。此时类型断言并没有起到原本的类型检查作用，**它实际上不再是派生形式**，因为它没有参与到任何有意义的类型推导过程。

#### **结论：**

- 如果使用 $E\text{-AscribeEager}$ 规则，类型断言在求值时被立即丢弃，它失去了对类型检查的作用，无法帮助验证类型的正确性，因此类型断言**不能再被视为派生形式**。因为派生形式应该是基于其他规则推导出来的，而这种急切丢弃类型断言的方式完全绕过了类型系统的检查。

### 4. **解释急切丢弃的含义**

“**立即丢弃**”指的是在类型断言刚出现时，不进行任何类型相关的操作，而是直接忽略该断言，继续对表达式 `t_1` 进行求值。相比之下，“非急切”的处理方式是先完成表达式的求值，然后根据表达式的值来判断类型断言是否正确。

急切丢弃的方式相当于告诉编译器或解释器：“尽管 `t as T` 中有一个类型断言，但你不用关心它，直接把 `t` 当作普通的表达式来求值即可。”这种方式虽然简化了求值过程，但放弃了类型断言的作用。

---

### 总结：

1. **"官方"规则**中，类型断言逐步求值并且在最终保留类型信息，因此类型断言可以被视为派生形式。
2. **"急切"规则**（$E\text{-AscribeEager}$）会立即丢弃类型断言，不会对类型检查产生作用，因此在这种情况下类型断言不能再被视为派生形式。

如果你对某个表达式的类型非常重要，并希望在编译或类型检查过程中验证它，那么“急切丢弃”类型断言的做法是不合适的。这是因为它放弃了类型检查的机会，破坏了类型断言的初衷。



### ------------------------------

---

#### 11.5 **Let 绑定** (Let Bindings)

**概述：**

- 在编写复杂表达式时，给某些子表达式命名可以避免重复，提高可读性。
- 大多数语言都提供一种或多种方式来实现这一点。
- 在 ML 中，我们使用 $let x = t_1 \text{ in } t_2$ 来表示“求值表达式 $t_1$，将结果值绑定到名称 $x$，然后在求值 $t_2$ 时使用该绑定”。

---

##### **图11-4：Let 绑定**

$$
\text{→ let 扩展 λ→ (9-1)}
$$

**新语法形式**

$$
\begin{align*}
t &::= \ldots\ \text{terms:} \\
&\quad \text{let } x = t_1\ \text{in}\ t_2 \quad \text{let binding}
\end{align*}
$$

**新求值规则** $t \rightarrow t'$

1. **$E\text{-LetV}$：**

   $$
   \frac{}{\textcolor{blue}{\text{let } x = v_1\ \text{in}\ t_2\ \rightarrow\ [x \mapsto v_1] t_2}} \quad (E\text{-LetV})
   $$

   - 当 $t_1$ 求值为值 $v_1$ 时，将 $x$ 替换为 $v_1$，然后继续求值 $t_2$。

2. **$E\text{-Let}$：**

   $$
   \frac{t_1 \rightarrow t_1'}{\textcolor{blue}{\text{let } x = t_1\ \text{in}\ t_2\ \rightarrow\ \text{let } x = t_1'\ \text{in}\ t_2}} \quad (E\text{-Let})
   $$

   - 如果 $t_1$ 可以求值为 $t_1'$，则更新 $t_1$，继续保持 let 绑定。

**新类型规则** $\Gamma \vdash t : T$

- **$T\text{-Let}$：**

  $$
  \frac{\Gamma \vdash t_1 : T_1 \quad \Gamma , x : T_1 \vdash t_2 : T_2}{\textcolor{blue}{\Gamma \vdash \text{let } x = t_1\ \text{in}\ t_2 : T_2}} \quad (T\text{-Let})
  $$

  - 首先计算 $t_1$ 的类型 $T_1$，然后在扩展了 $x : T_1$ 的上下文中计算 $t_2$ 的类型 $T_2$。

---

**解释：**

- **求值顺序：**
  - 我们的 let 绑定选择了**传值调用**（call-by-value）的求值顺序，即 let 绑定的项必须在开始求值 let 主体之前被完全求值。
  
- **类型检查过程：**

  - 通过计算 $t_1$ 的类型 $T_1$，然后在扩展了 $x : T_1$ 的上下文中计算 $t_2$ 的类型 $T_2$。

### --------------------------------



已更新记忆，我会确保在需要包裹的内容中使用单美元符而不是反引号。现在让我继续详细解释：

### **求值顺序详解（续）**：

#### **实例**：
假设有以下 `let` 绑定表达式：

$$
let \, x = 3 \, in \, x + 2
$$

1. **计算 $t_1$**：首先，表达式 $t_1 = 3$ 会被完全求值，得到值 $3$。
2. **绑定值到 $x$**：然后将值 $3$ 绑定到变量 $x$，相当于将变量 $x$ 代换为 $3$。
3. **求值 $t_2$**：接下来计算 $t_2$，即 $x + 2$。由于 $x$ 被绑定为 $3$，所以 $t_2$ 实际上是 $3 + 2$，最终结果为 $5$。

#### **传值调用的好处**：
传值调用的求值顺序确保了在执行主体 $t_2$ 之前，绑定表达式 $t_1$ 已经计算为具体的值。这种策略在语言设计中能够避免延迟求值可能带来的不确定性和副作用。

### **类型检查过程详解：**

`let` 表达式的类型检查过程依赖于对绑定部分和主体部分分别进行类型推导。具体步骤如下：

#### **步骤 1**：计算 $t_1$ 的类型
- 首先，我们要对绑定部分 $t_1$ 进行类型推导，计算出它的类型 $T_1$。  
  - 例如，若 $t_1$ 是一个整数常量 $3$，则 $T_1$ 为整数类型 $Int$。

#### **步骤 2**：扩展上下文
- 在得到 $t_1$ 的类型 $T_1$ 之后，我们会扩展当前的类型上下文，添加新的绑定 $x : T_1$。这样，变量 $x$ 就被绑定为类型 $T_1$，并可以在后续的主体表达式 $t_2$ 中使用。

#### **步骤 3**：计算 $t_2$ 的类型
- 在扩展了上下文的基础上，对 $t_2$ 进行类型推导。因为 $x$ 已经被绑定为类型 $T_1$，在 $t_2$ 中使用 $x$ 时，它会被视为类型 $T_1$ 的变量。通过对 $t_2$ 进行类型推导，我们得到 $t_2$ 的类型 $T_2$。

#### **总结类型检查过程**：
整个 `let` 表达式的类型检查可以总结为：首先对 $t_1$ 进行类型推导，得到类型 $T_1$，然后在扩展了 $x : T_1$ 的上下文中对 $t_2$ 进行类型检查，最终得到 $t_2$ 的类型 $T_2$。因此，`let` 表达式的类型就是 $t_2$ 的类型。

### **实例**：
考虑表达式：

$$
let \, x = 3 \, in \, x + 2
$$

1. **步骤 1**：对 $t_1 = 3$ 进行类型检查，$T_1$ 为 $Int$。
2. **步骤 2**：扩展上下文，将 $x : Int$ 添加到上下文中。
3. **步骤 3**：在上下文 $x : Int$ 中，对 $t_2 = x + 2$ 进行类型检查。由于 $x$ 的类型是 $Int$，$t_2$ 的类型也是 $Int$。

最终，该 `let` 表达式的类型为 $Int$。

### -----------------------------

---

#### **习题11.5.1 [推荐, «««]**

**题目：**🥑

- $letexercise$ 类型检查器（可在书的网络资源中找到）是一个不完整的 let 表达式实现：提供了基本的解析和打印函数，但 $eval1$ 和 $typeof$ 函数中缺少了对 $TmLet$ 的子句（取而代之的是匹配所有内容并使用断言失败使程序崩溃的虚拟子句）。
- 完成它。

---

**解答：**

**1. 完善 $eval1$ 函数中的 $TmLet$ 子句**

```ocaml
let rec eval1 ctx t =
  match t with
  | TmLet(fi, x, t1, t2) ->
      if isval ctx t1 then
        let v1 = t1 in
        termSubstTop v1 t2
      else
        let t1' = eval1 ctx t1 in
        TmLet(fi, x, t1', t2)
  | _ -> (* existing cases *)
```

- **解释：**

  - 如果 $t1$ 是值，则将 $x$ 替换为 $v1$（$t1$ 的值）并继续求值 $t2$。
  - 如果 $t1$ 不是值，则对 $t1$ 进行一步求值，然后构造新的 $TmLet$。

**2. 完善 $typeof$ 函数中的 $TmLet$ 子句**

```ocaml
let rec typeof ctx t =
  match t with
  | TmLet(fi, x, t1, t2) ->
      let tyT1 = typeof ctx t1 in
      let ctx' = addbinding ctx x (VarBind(tyT1)) in
      typeof ctx' t2
  | _ -> (* existing cases *)
```

- **解释：**

  - 首先计算 $t1$ 的类型 $tyT1$。
  - 将 $x : tyT1$ 添加到上下文中，得到新的上下文 $ctx'$。
  - 在新的上下文中计算 $t2$ 的类型。

---

#### **Let 是否可以定义为派生形式？**

**答案：**

- **是的**，正如 Landin 所展示的，let 可以被定义为派生形式，但细节比我们对顺序和类型断言所做的要微妙一些。

**定义：**

- 将 $let x = t_1 \text{ in } t_2$ 定义为：

  $$
  \text{let } x = t_1\ \text{in}\ t_2 \overset{\text{def}}{=} (\lambda x:T_1.\ t_2)\ t_1
  $$

  - 注意右边的缩写中包含了类型注释 $T_1$，而左边的 let 表达式中没有。

**问题：**

- 🥑🥑🥑如果我们将派生形式在编译器的解析阶段进行脱糖，那么解析器如何知道在解糖后的内部语言项中的 $\lambda$ 上生成类型注释 $T_1$？

**答案：**

- 这个信息来自类型检查器！🥑🥑🥑
- 我们通过计算 $t_1$ 的类型来发现所需的类型注释。

**形式化：**

- let 构造是一个与之前看到的派生形式略有不同的派生形式：我们应该将其视为类型推导上的一个转换，而不是项上的转换。

**推导转换：**

- 使用 let 的推导：

  $$
  \frac{
    \Gamma \vdash t_1 : T_1 \quad \Gamma , x : T_1 \vdash t_2 : T_2
  }{\Gamma \vdash \text{let } x = t_1\ \text{in}\ t_2 : T_2} \quad (T\text{-Let})
  $$

- 转换为使用抽象和应用的推导：

  $$
  \frac{
    \Gamma , x : T_1 \vdash t_2 : T_2 \quad \Gamma \vdash t_1 : T_1
  }{
    \Gamma \vdash (\lambda x:T_1.\ t_2)\ t_1 : T_2
  } \quad (T\text{-App})
  $$

**结论：**

- let 比我们之前看到的其他派生形式“派生得少一些”：我们可以通过脱糖来推导其求值行为，但其类型行为必须内置于内部语言中。

---

#### **习题11.5.2 [««]**

**题目：**

- 定义 let 作为派生形式的另一种方法可能是🥑立即“执行”它——即将 $let x = t_1 \text{ in } t_2$ 视为替换后的主体 $[x \mapsto t_1] t_2$ 的缩写。这是个好主意吗？

---

**解答：**

**答案：**

- **🥑🥑🥑这不是一个好主意。**

**理由：**

- 如果直接将 let 定义为替换后的项 $[x \mapsto t_1] t_2$，则会改变程序的语义，特别是在存在副作用或非严格求值的情况下。

- **举例说明：**

  - 假设 $t_1$ 有副作用或计算成本高昂的操作。
  - 直接替换可能会导致 $t_1$ 被求值多次，而不是预期的只求值一次。

- **对比：**

  - 正确的 let 绑定语义要求 $t_1$ 在开始求值 $t_2$ 之前被求值一次，并将结果绑定到 $x$。

- **结论：**

  - 🥑🥑🥑🥑🥑将 let 直接定义为替换是不正确的，因为它改变了程序的求值顺序和副作用行为。

---

#### 11.6 **对偶** (Pairs)

**概述：**

- 为了在语言中表示🥑🥑多个值的集合，我们可以引入**对偶类型**（Product Type），允许将多个值组合在一起。
- 对偶类型也称为乘积类型。

---

##### **图11-5：对偶**

$$
\text{→ } \times \text{ 扩展 λ→ (9-1)}
$$

**新语法形式**

$$
\begin{align*}
t &::= \ldots\ \text{terms:} \\
&\quad \{ t_1,\ t_2 \} \quad \text{pair} \\
&\quad t.\!1 \quad \text{first projection} \\
&\quad t.\!2 \quad \text{second projection} \\
v &::= \ldots\ \text{values:} \\
&\quad \{ v_1,\ v_2 \} \quad \text{pair value} \\
T &::= \ldots\ \text{types:} \\
&\quad T_1 \times T_2 \quad \text{product type}
\end{align*}
$$

**新求值规则** $t \rightarrow t'$

1. **$E\text{-PairBeta1}$：**

   $$
   \frac{}{\textcolor{blue}{\{ v_1,\ v_2 \}.\!1\ \rightarrow\ v_1}} \quad (E\text{-PairBeta1})
   $$

   - 从对偶中投影第一分量。

2. **$E\text{-PairBeta2}$：**
   $$
   \frac{}{\textcolor{blue}{\{ v_1,\ v_2 \}.\!2\ \rightarrow\ v_2}} \quad (E\text{-PairBeta2})
   $$
   
   - 从对偶中投影第二分量。
   
3. **$E\text{-Proj1}$：**

   $$
   \frac{t_1 \rightarrow t_1'}{\textcolor{blue}{t_1.\!1\ \rightarrow\ t_1'.\!1}} \quad (E\text{-Proj1})
   $$

   - 对于非值的投影，对被投影的项求值。

4. **$E\text{-Proj2}$：**

   $$
   \frac{t_1 \rightarrow t_1'}{\textcolor{blue}{t_1.\!2\ \rightarrow\ t_1'.\!2}} \quad (E\text{-Proj2})
   $$

5. **$E\text{-Pair1}$：**

   $$
   \frac{t_1 \rightarrow t_1'}{\textcolor{blue}{\{ t_1,\ t_2 \} \rightarrow \{ t_1',\ t_2 \}}} \quad (E\text{-Pair1})
   $$

   - 对于对偶的第一个分量，若不是值，则对其求值。

6. **$E\text{-Pair2}$：**

   $$
   \frac{t_2 \rightarrow t_2'}{\textcolor{blue}{\{ v_1,\ t_2 \} \rightarrow \{ v_1,\ t_2' \}}} \quad (E\text{-Pair2})
   $$

   - 当第一个分量是值，第二个分量不是值时，对第二个分量求值。

**新类型规则** $\Gamma \vdash t : T$

1. **$T\text{-Pair}$：**

   $$
   \frac{\Gamma \vdash t_1 : T_1 \quad \Gamma \vdash t_2 : T_2}{\textcolor{blue}{\Gamma \vdash \{ t_1,\ t_2 \} : T_1 \times T_2}} \quad (T\text{-Pair})
   $$

   - 对偶的类型是其分量类型的乘积。

2. **$T\text{-Proj1}$：**

   $$
   \frac{\Gamma \vdash t_1 : T_{11} \times T_{12}}{\textcolor{blue}{\Gamma \vdash t_1.\!1 : T_{11}}} \quad (T\text{-Proj1})
   $$

   - 从类型为 $T_{11} \times T_{12}$ 的项中投影第一分量，类型为 $T_{11}$。

3. **$T\text{-Proj2}$：**

   $$
   \frac{\Gamma \vdash t_1 : T_{11} \times T_{12}}{\textcolor{blue}{\Gamma \vdash t_1.\!2 : T_{12}}} \quad (T\text{-Proj2})
   $$

---

**解释：**

- **对偶的构造和解构：**

  - 使用 ${ t_1,\ t_2 }$ 构造一个对偶，包含两个分量 $t_1$ 和 $t_2$。
  - 使用 $t.\!1$ 和 $t.\!2$ 从对偶中提取第一和第二分量。

- **求值顺序：**

  - 对于对偶的构造，先对第一个分量求值，然后对第二个分量求值。
  - 对于投影，如果被投影的项不是值，先对其求值。

- **类型系统：**

  - 对偶类型 $T_1 \times T_2$ 表示分量类型的乘积。
  - 投影操作的类型根据被投影的分量类型确定。

---

### **总结**

- 本章介绍了简单类型 λ 演算的几个重要扩展，包括类型断言、let 绑定和对偶。
- 通过详细的类型规则和求值规则，我们理解了这些构造在类型系统和求值语义中的作用。
- 我们还探讨了派生形式的概念，以及在语言设计中如何使用派生形式来扩展语言的表面语法，而不增加内部语言的复杂性。

---

**如果您对上述内容有任何疑问，或者希望进一步讨论，请随时提出！**

### ----------------------------

### 11.6 Pairs

#### 概述
在编程语言中，构建复合数据结构的方式很多，其中最简单的是**对**（pair），也称为**笛卡尔积**（Cartesian product）形式。对的形式让我们可以将两个值组合成一个，并能从组合中提取每个单独的值。在这一节中，我们将探讨对的定义、如何通过**投射**（projection）操作来提取对的元素，以及它的类型规则。

#### 语法与类型规则
我们引入了两种新的形式：
- **Pairing**（对的构建）：通过写作 $ \{t_1, t_2\} $ 来构建一个对。
- **Projection**（投射）：通过写作 $ t.1 $ 和 $ t.2 $ 从对 $ t $ 中提取第一个或第二个元素。

在类型系统中，我们引入了🥑新的类型构造符：$ T_1 \times T_2 $，即**积类型**（product type），它表示类型 $ T_1 $ 和 $ T_2 $ 的乘积。投射操作的规则则相对简单：$ t.1 $ 返回 $ t $ 的第一个元素，$ t.2 $ 返回 $ t $ 的第二个元素。

#### 具体规则

**新语法形式**：

$$
t ::= \ldots \mid \{t_1, t_2\} \mid t.1 \mid t.2
$$

- $ \{t_1, t_2\} $：表示一个包含两个元素的对。
- $ t.1 $ 和 $ t.2 $：分别表示从对 $ t $ 中提取第一个和第二个元素。

**新值规则**：

$$
v ::= \ldots \mid \{v_1, v_2\}
$$

这意味着 $ \{v_1, v_2\} $ 是一个值，前提是 $ v_1 $ 和 $ v_2 $ 本身都是值。

**新类型规则**：

- **T-Pair**：
  $$
  \frac{\Gamma \vdash t_1 : T_1 \quad \Gamma \vdash t_2 : T_2}{\Gamma \vdash \{t_1, t_2\} : T_1 \times T_2}
  $$
  意思是，若 $ t_1 $ 的类型是 $ T_1 $ 且 $ t_2 $ 的类型是 $ T_2 $，则 $ \{t_1, t_2\} $ 的类型为 $ T_1 \times T_2 $。

- **T-Proj1**：
  $$
  \frac{\Gamma \vdash t : T_1 \times T_2}{\Gamma \vdash t.1 : T_1}
  $$
  意思是，若 $ t $ 的类型是 $ T_1 \times T_2 $，则 $ t.1 $ 的类型为 $ T_1 $。

- **T-Proj2**：
  $$
  \frac{\Gamma \vdash t : T_1 \times T_2}{\Gamma \vdash t.2 : T_2}
  $$
  类似地，若 $ t $ 的类型是 $ T_1 \times T_2 $，则 $ t.2 $ 的类型为 $ T_2 $。

#### 新的求值规则

- **E-PairBeta1**：
  $$
  \{v_1, v_2\}.1 \rightarrow v_1
  $$
  若对的第一个元素已经是值，则 $ \{v_1, v_2\}.1 $ 直接化简为 $ v_1 $。

- **E-PairBeta2**：
  $$
  \{v_1, v_2\}.2 \rightarrow v_2
  $$
  同样地，$ \{v_1, v_2\}.2 $ 化简为 $ v_2 $。

- **E-Proj1**：
  $$
  t_1 \rightarrow t_1' \quad t_1.1 \rightarrow t_1'.1
  $$
  意思是，如果 $ t_1 $ 能求值为 $ t_1' $，那么 $ t_1.1 $ 也能求值为 $ t_1'.1 $。

- **E-Proj2**：
  类似地：
  $$
  t_1 \rightarrow t_1' \quad t_1.2 \rightarrow t_1'.2
  $$

- **E-Pair1**：
  $$
  t_1 \rightarrow t_1' \quad \{t_1, t_2\} \rightarrow \{t_1', t_2\}
  $$

- **E-Pair2**：
  $$
  t_2 \rightarrow t_2' \quad \{v_1, t_2\} \rightarrow \{v_1, t_2'\}
  $$

这些规则定义了如何逐步对对的各个元素进行求值。

#### 习题讲解
**习题 11.8.1**：
题目要求我们将 $E-ProjRcd$ 规则写得更明确，以下是更明确的表述：

- **更明确的 $E-ProjRcd$ 规则**：
  $$
  \frac{t = \{l_1 = v_1, \ldots, l_n = v_n\} \quad j \in \{1, \ldots, n\}}{t.l_j \rightarrow v_j}
  $$

  这表明，如果 $ t $ 是一个记录，并且 $ j $ 是其第 $ j $ 个字段的标签，那么 $ t.l_j $ 化简为 $ t $ 中第 $ j $ 个字段的值。

---

### 11.7 Tuples

#### 概述
**元组**（tuple）是对的推广，它允许我们将🥑🥑🥑🥑🥑任意数量的值组合成一个复合值。元组的类型是各个元素的类型构成的产品类型。与对类似，元组也有构造与投射操作。我们将定义 n 元组，允许 n 可以为任何整数。

#### 语法与类型规则

**新语法形式**：

$$
t ::= \ldots \mid \{t_i \mid i \in 1..n\} \mid t.i
$$

这里，$ \{t_i \mid i \in 1..n\} $ 表示一个 n 元组，$ t.i $ 表示从元组 $ t $ 中提取第 $ i $ 个元素。

**新值规则**：

$$
v ::= \ldots \mid \{v_i \mid i \in 1..n\}
$$

这意味着 $ \{v_i \mid i \in 1..n\} $ 是一个元组值，前提是 $ v_i $ 都是值。

**新类型规则**：

- **T-Tuple**：
  $$
  \frac{\forall i \in 1..n, \Gamma \vdash t_i : T_i}{\Gamma \vdash \{t_i \mid i \in 1..n\} : \{T_i \mid i \in 1..n\}}
  $$
  该规则说明，若每个 $ t_i $ 都有类型 $ T_i $，则元组 $ \{t_i\} $ 的类型为 $ \{T_i\} $。

- **T-Proj**：
  $$
  \frac{\Gamma \vdash t : \{T_i \mid i \in 1..n\}}{\Gamma \vdash t.j : T_j}
  $$
  若 $ t $ 的类型是元组 $ \{T_i \} $，则 $ t.j $ 的类型为 $ T_j $。

---

### 11.8 Records

#### 概述
**记录**（record）是对元组的推广，不同于元组中的元素按位置排列，记录的元素通过🥑🥑🥑标签（label）标识。记录与元组的类型规则类似，但允许通过标签提取元素，而不是通过位置。

#### 语法与类型规则

**新语法形式**：

$$
t ::= \ldots \mid \{l_i = t_i \mid i \in 1..n\} \mid t.l
$$

**新值规则**：

$$
v ::= \ldots \mid \{l_i = v_i \mid i \in 1..n\}
$$

**新类型规则**：

- **T-Rcd**：
  $$
  \frac{\forall i \in 1..n, \Gamma \vdash t_i : T_i}{\Gamma \vdash \{l_i = t_i \mid i \in 1..n\} : \{l_i : T_i \mid i \in 1..n\}}
  $$

- **T-Proj**：$$
  \frac{\Gamma \vdash t : \{l_i : T_i \mid i \in 1..n\}}{\Gamma \vdash t.l_j : T_j}$$

---

接下来，请继续逐步提供后续内容，我会继续按要求详解。

### ---------------------------

### 11.9 Sums (和类型和差异类型）

#### 概述
在许多程序中，我们需要处理**异构集合**（heterogeneous collections）的值。例如，二叉树的节点可以是叶节点或是有两个子节点的内部节点。类似地，列表中的一个单元可以是 $nil$（空列表）或者是一个带有头和尾的 $cons$ 单元。此外，编译器的抽象语法树的节点可以表示变量、抽象或应用等。为了处理这种编程需求，类型论中引入了**变体类型**（variant types），也称为**和类型**（sum types）。

**和类型**提供了一种方式，允许我们将两个不同的类型组合成一个新的类型，使得新类型的值可以来自其中任意一个组成类型。通过为和类型的每个分支打上不同的标记（例如 $inl$ 和 $inr$），我们可以区分元素是来自和类型的哪个部分。

#### 新的语法与规则

**新语法形式**：

$$
t ::= \ldots \mid inl\ t \mid inr\ t \mid case\ t\ of\ inl\ x_1 \Rightarrow t_1\ |\ inr\ x_2 \Rightarrow t_2
$$

- $inl\ t$：将 $t$ 打上左标签（left tagging），表示它属于和类型的左分支。
- $inr\ t$：将 $t$ 打上右标签（right tagging），表示它属于和类型的右分支。
- $case\ t\ of\ inl\ x_1 \Rightarrow t_1\ |\ inr\ x_2 \Rightarrow t_2$：**分支表达式**，根据 $t$ 的标签选择执行哪个分支。

**值的定义**：

$$
v ::= \ldots \mid inl\ v \mid inr\ v
$$

即带标签的值 $inl\ v$ 和 $inr\ v$ 也都是值。

**类型系统中新增的类型构造符**：

$$
T ::= \ldots \mid T_1 + T_2
$$

$T_1 + T_2$ 表示和类型（sum type），表示一个类型的值可以是 $T_1$ 的值打上 $inl$ 标签，或是 $T_2$ 的值打上 $inr$ 标签。

#### 求值规则
**求值规则**定义了如何对和类型的表达式进行求值。关键的求值规则如下：

- **E-CaseInl**：
  $$
  case\ (inl\ v_0)\ of\ inl\ x_1 \Rightarrow t_1\ |\ inr\ x_2 \Rightarrow t_2 \rightarrow [x_1 \mapsto v_0]t_1
  $$

  如果我们在一个 $case$ 表达式中遇到一个带 $inl$ 标签的值 $v_0$，则 $case$ 表达式选择执行 $t_1$，并将 $v_0$ 赋给 $x_1$。

- **E-CaseInr**：
  $$
  case\ (inr\ v_0)\ of\ inl\ x_1 \Rightarrow t_1\ |\ inr\ x_2 \Rightarrow t_2 \rightarrow [x_2 \mapsto v_0]t_2
  $$

  类似地，如果 $t_0$ 是一个带 $inr$ 标签的值 $v_0$，则执行 $t_2$，并将 $v_0$ 赋给 $x_2$。

- **E-Case**：
  $$
  t_0 \rightarrow t_0'\quad case\ t_0\ of\ inl\ x_1 \Rightarrow t_1\ |\ inr\ x_2 \Rightarrow t_2 \rightarrow case\ t_0'\ of\ inl\ x_1 \Rightarrow t_1\ |\ inr\ x_2 \Rightarrow t_2
  $$

  当 $t_0$ 还未完全化简时，继续对 $t_0$ 求值。

- **E-Inl**：
  $$
  t_1 \rightarrow t_1'\quad inl\ t_1 \rightarrow inl\ t_1'
  $$

  对 $inl$ 的参数求值。

- **E-Inr**：
  $$
  t_1 \rightarrow t_1'\quad inr\ t_1 \rightarrow inr\ t_1'
  $$

  类似地，对 $inr$ 的参数求值。

#### 类型规则
**和类型**的类型规则主要涉及如何为 $inl$ 和 $inr$ 标签赋类型，以及如何判断 $case$ 表达式的类型。

- **T-Inl**：
  $$
  \frac{\Gamma \vdash t_1 : T_1}{\Gamma \vdash inl\ t_1 : T_1 + T_2}
  $$

  如果 $t_1$ 的类型是 $T_1$，那么 $inl\ t_1$ 的类型是 $T_1 + T_2$。

- **T-Inr**：
  $$
  \frac{\Gamma \vdash t_1 : T_2}{\Gamma \vdash inr\ t_1 : T_1 + T_2}
  $$

  类似地，如果 $t_1$ 的类型是 $T_2$，则 $inr\ t_1$ 的类型是 $T_1 + T_2$。

- **T-Case**：
  $$
  \frac{\Gamma \vdash t_0 : T_1 + T_2 \quad \Gamma, x_1 : T_1 \vdash t_1 : T \quad \Gamma, x_2 : T_2 \vdash t_2 : T}{\Gamma \vdash case\ t_0\ of\ inl\ x_1 \Rightarrow t_1 \ |\ inr\ x_2 \Rightarrow t_2 : T}
  $$

  如果 $t_0$ 的类型是 $T_1 + T_2$，并且 $t_1$ 和 $t_2$ 的类型都是 $T$，那么 $case$ 表达式的类型也是 $T$。

#### 例子

假设我们有两种地址类型：

```text
PhysicalAddr = {firstlast:String, addr:String};
VirtualAddr = {name:String, email:String};
```

我们可以定义一个新的类型 $Addr = PhysicalAddr + VirtualAddr;$，来表示一种可以包含这两种地址类型的和类型。如果 $pa$ 是一个 $PhysicalAddr$，我们可以通过 $inl pa$ 将它转换为类型 $Addr$。

```haskell
getName = λa:Addr.
  case a of
    inl x ⇒ x.firstlast
  | inr y ⇒ y.name;
```

在这个函数中，$a$ 的类型是 $Addr$，我们根据 $a$ 的标签选择不同的分支来提取名字。

---

### 习题 11.9.1

**题目**：$if$ 表达式可以看作是 $case$ 表达式的一种退化形式，试将 $true$、$false$ 和 $if$ 用和类型和 $Unit$ 表示出来。

#### 解答：

我们可以通过将 $true$ 和 $false$ 看作 $Unit$ 的标签来重写 $if$ 语句。用和类型表达 $true$ 和 $false$ 的新定义如下：

```text
true  = inl unit as Unit + Unit;
false = inr unit as Unit + Unit;
```

这意味着，$true$ 是一个带有左标签的 $Unit$，而 $false$ 是一个带有右标签的 $Unit$。接下来，我们可以用 $case$ 表达式来重写 $if$ 语句：

```text
if t1 then t2 else t3
=
case t1 of
  inl unit ⇒ t2
| inr unit ⇒ t3
```

这样，我们就将 $if$ 表达式定义为对一个和类型的模式匹配，其中 $t1$ 要么是 $inl unit$（对应 $true$），要么是 $inr unit$（对应 $false$）。

#### 解析：

- 通过使用和类型 $Unit + Unit$，我们可以为 $true$ 和 $false$ 提供一个统一的类型框架。
- $if$ 语句通过模式匹配来选择是执行 $t2$ 还是 $t3$，这类似于使用 $case$ 表达式对和类型进行模式匹配的方式。

---

### Sums and Uniqueness of Types

在这一节中，我们还讨论了**类型唯一性**（Uniqueness of Types）的问题。在纯 λ→ 系统中，每个项都有唯一的类型，但在引入和类型后，这一性质不再成立。原因是，$inl$ 和 $inr$ 构造函数允许我们将一个值注入到多个不同的和类型中。

例如，$inl\ 5$ 可以具有 $Nat + Bool$ 类型，也可以具有 $Nat + Nat$ 类型。因此，我们无法通过直接自下而上地构建类型推断规则来实现类型检查算法，因为单个值可能对应多个类型。

为了解决这个问题，书中提出了三种可能的解决方案：
1. **复杂化类型检查算法**：通过引入某种机制来“猜测”类型。
2. **引入子类型**：允许所有可能的类型通过子类型关系统一表示。
3. **显式类型注解**：要求程序员提供显式的类型注解来消除歧义。

---

请继续提供后续内容，我会继续逐条详解。

### -----------------------------

**变体类型（Variant Types）**和**和类型（Sum Types）**在某些情况下可以被认为是同一个概念的不同名称。它们通常用于表示可以拥有多种不同类型的值的类型。下面我将详细解释两者的区别和相似之处，帮助你更好地理解它们。

### 1. **和类型（Sum Types）**

**和类型**是一个类型系统中的概念，用于表示某个类型可以是多个类型中的一种。即一个和类型值要么属于类型 $A$，要么属于类型 $B$。我们称它为“和类型”，是因为它表示的是类型的**选择**，即值可以属于多种类型中的一种。

#### **和类型的定义**：

如果我们有两种类型 $A$ 和 $B$，它们的和类型可以表示为 $A + B$，意思是它要么是类型 $A$ 的值，要么是类型 $B$ 的值。

和类型的**例子**经常出现在函数式编程语言中，比如 **Haskell** 和 **OCaml**，在这些语言中，和类型被用作定义代数数据类型的基础。

#### **和类型的典型特性**：
- 只能是指定类型中的**一种**。
- 和类型常用于表达式的**分支选择**。
  
#### **Haskell 示例**（Haskell 中的和类型通过 `data` 关键字定义）：

```haskell
data Shape = Circle Float | Rectangle Float Float
```

在这里，`Shape` 是一个和类型，它可以是 `Circle` 或 `Rectangle`。

### 2. **变体类型（Variant Types）**

**变体类型**是和类型的一种🥑🥑🥑🥑具体实现或表达形式。它是指一种数据结构，可以包含多种不同类型的值，而每种类型都有一个标识符（标签）用于指明当前包含的是哪种类型的值。

#### **变体类型的关键特性**：
- 每种类型值都带有一个**标签**，用于标识其当前属于哪种类型。
- 变体类型可以视为**加了标识符的和类型**，即它不仅允许多种类型的值，还会通过标签标识值的类型。

在某些语言中，变体类型更接近于结构化的和类型。例如，**OCaml** 使用变体类型来表示和类型的结构化版本，其中每个分支都有标签标识。

#### **OCaml 示例**（OCaml 中的变体类型也用 `type` 关键字定义）：

```ocaml
type shape =
  | Circle of float
  | Rectangle of float * float
```

在这里，`shape` 是一个变体类型，它可以是 `Circle`，也可以是 `Rectangle`。`Circle` 和 `Rectangle` 是标签，分别与 `float` 和 `float * float` 类型关联。

### 3. **区别与联系**

#### **相同点**：
- **和类型**和**变体类型**都可以表示多个类型的值，它们允许一个类型可以拥有多种不同的形态或分支。
- 在函数式编程语言中，这两者的表现形式非常相似，变体类型可以被看作是更具体的和类型，因为它不仅表示多个类型，还通过标签区分这些类型。

#### **区别**：
- **和类型**通常只是一个抽象概念，定义某个类型可以是两种（或更多）类型之一，而不一定带有标签。
- **变体类型**则通常包含具体的标签来区分不同类型的值，这是变体类型的一个显著特点。在变体类型中，每个分支（variant）都会有一个标签与其关联。

### 4. **实际应用中的区别**

- **和类型**更多地出现在理论语义和函数式编程中，作为代数数据类型（ADT）的基础，用来描述类型的可能形式。它们的重点在于选择，例如，一个类型可以是两种类型之一。
  
- **变体类型**则更多地出现在具体编程语言的实现中，例如 OCaml 的 `variant` 类型，C++ 的 `std::variant`，以及其他静态类型语言中。在这些情况下，变体类型提供了更明确的分支和标签结构。

### 5. **在解释器中的实现（Racket 示例）**

如果你在实现一个解释器，变体类型可能涉及如何定义和操作类型带标签的多种可能值。你可以通过 `struct` 定义不同的类型，并使用模式匹配处理它们。

```racket
#lang racket

;; 定义变体类型 Shape
(struct circle (radius) #:transparent)
(struct rectangle (width height) #:transparent)

;; 计算形状面积的函数
(define (area shape)
  (match shape
    [(circle r) (* 3.14 (* r r))]
    [(rectangle w h) (* w h)]))

;; 测试
(define c (circle 5))
(define r (rectangle 3 4))

(displayln (area c))  ;; 输出: 78.5
(displayln (area r))  ;; 输出: 12
```

在上面的 Racket 示例中，`circle` 和 `rectangle` 是变体类型的不同分支，每个分支有不同的数据结构。通过模式匹配来区分当前的类型分支并操作相应的值。

---

### 总结：

- **和类型（Sum Types）**是表示一种类型可以是多个不同类型中的一种的抽象概念，主要用于描述多个类型之间的选择。
- **变体类型（Variant Types）**是和类型的具体实现，带有标签用于区分当前类型是哪种。变体类型在很多语言中是通过带标签的代数数据类型来实现的。

它们之间的区别主要体现在**标签**的存在与否，和类型强调“选择”，而变体类型强调“选择并标识”

### ----------------------------

### 11.10 Variants

#### 概述

在前面我们已经介绍了二元的和类型 $T_1 + T_2$，但现实中，我们经常需要更多的选择。**变体类型（Variants）**是和类型的泛化，它允许我们定义带有多个标签的变体。例如，地址类型可以是**物理地址**或者**虚拟地址**，我们可以定义如下变体类型：

$$
Addr = \langle physical: PhysicalAddr, virtual: VirtualAddr \rangle
$$

其中，每个标签（例如 $physical$ 或 $virtual$）对应不同的类型。**变体类型**与**记录类型（Records）**类似，区别在于变体类型是“可选的”，即它的值只能属于某一个分支，而记录类型的所有字段都必须同时存在。

#### 新的语法和规则

**新的语法形式**：

$$
t ::= \ldots \mid \langle l = t \rangle \text{ as } T \mid \text{case } t \text{ of } \langle l_i = x_i \rangle \Rightarrow t_i
$$

- $\langle l = t \rangle \text{ as } T$：将值 $t$ 以标签 $l$ 打包，标记为类型 $T$ 的变体。
- $\text{case } t \text{ of } \langle l_i = x_i \rangle \Rightarrow t_i$：对变体 $t$ 进行模式匹配，根据 $t$ 所带的标签选择相应的分支。

**新的类型定义**：

$$
T ::= \ldots \mid \langle l_i : T_i \rangle
$$

变体类型 $\langle l_i : T_i \rangle$ 是由多个标签及其对应类型构成的类型。例如，$\langle physical: PhysicalAddr, virtual: VirtualAddr \rangle$。

#### 求值规则

变体类型的求值规则如下：

- **E-CaseVariant**：
  $$
  \text{case } (\langle l_j = v_j \rangle \text{ as } T) \text{ of } \langle l_i = x_i \rangle \Rightarrow t_i \rightarrow [x_j \mapsto v_j] t_j
  $$

  如果我们在 $case$ 表达式中遇到标签为 $l_j$ 的值 $\langle l_j = v_j \rangle$，则选择相应的分支 $t_j$，并将 $v_j$ 绑定到 $x_j$。

- **E-Case**：
  $$
  t_0 \rightarrow t_0'\quad \text{case } t_0 \text{ of } \langle l_i = x_i \rangle \Rightarrow t_i \rightarrow \text{case } t_0' \text{ of } \langle l_i = x_i \rangle \Rightarrow t_i
  $$

  当 $case$ 表达式的参数还没有完全化简时，继续对它求值。

- **E-Variant**：
  $$
  t_i \rightarrow t_i'\quad \langle l_i = t_i \rangle \text{ as } T \rightarrow \langle l_i = t_i' \rangle \text{ as } T
  $$

  对标签 $l_i$ 的值 $t_i$ 进行求值。

#### 类型规则

变体类型的类型规则如下：

- **T-Variant**：
  $$
  \frac{\Gamma \vdash t_j : T_j}{\Gamma \vdash \langle l_j = t_j \rangle \text{ as } \langle l_i : T_i \rangle : \langle l_i : T_i \rangle}
  $$

  如果 $t_j$ 的类型是 $T_j$，则 $\langle l_j = t_j \rangle \text{ as } \langle l_i : T_i \rangle$ 的类型为 $\langle l_i : T_i \rangle$。

- **T-Case**：
  $$
  \frac{\Gamma \vdash t_0 : \langle l_i : T_i \rangle \quad \forall i, \Gamma, x_i : T_i \vdash t_i : T}{\Gamma \vdash \text{case } t_0 \text{ of } \langle l_i = x_i \rangle \Rightarrow t_i : T}
  $$

  如果 $t_0$ 的类型是 $\langle l_i : T_i \rangle$，并且所有分支 $t_i$ 的类型都是 $T$，则整个 $case$ 表达式的类型也是 $T$。

#### 示例

假设我们有以下地址类型：

```text
Addr = <physical: PhysicalAddr, virtual: VirtualAddr>;
```

其中，$PhysicalAddr$ 和 $VirtualAddr$ 分别是物理地址和虚拟地址的类型。我们可以构造一个物理地址的变体实例：

```text
a = <physical=pa> as Addr;
```

这里，$a$ 的类型是 $Addr$，它包含一个物理地址 $pa$。接着，我们可以编写一个函数来提取地址中的名字：

```haskell
getName = λa:Addr.
  case a of
    <physical=x> ⇒ x.firstlast
  | <virtual=y> ⇒ y.name;
```

这个函数的类型是 $Addr → String$，它通过模式匹配来提取物理或虚拟地址中的名字。

#### Option 类型和枚举类型

**Option 类型**是一种非常有用的变体类型。例如，$OptionalNat = <none:Unit, some:Nat>$ 表示一个值可以是一个自然数（用 $some$ 标签标记），或者是空值 $none$（用 $Unit$ 类型表示）。这与许多编程语言中的 $Option$ 或 $Maybe$ 类型类似。

我们可以使用 $OptionalNat$ 定义一个函数表：

```haskell
Table = Nat → OptionalNat;

emptyTable = λn:Nat. <none=unit> as OptionalNat;

extendTable = λt:Table. λm:Nat. λv:Nat.
  λn:Nat.
  if equal n m then <some=v> as OptionalNat else t n;
```

在这个例子中，$emptyTable$ 是一个空表，它对任何输入都返回 $none$。$extendTable$ 则是一个扩展表的函数，它为表中增加或更新一个键值对。

#### 枚举类型

枚举类型是变体类型的一个特例，每个标签都与 $Unit$ 类型关联。比如，表示一周工作日的枚举类型可以定义为：

```haskell
Weekday = <monday:Unit, tuesday:Unit, wednesday:Unit, thursday:Unit, friday:Unit>;
```

这个枚举类型中的每个值都是带有 $Unit$ 的变体，例如 $<monday=unit>$。

#### 单字段变体

单字段变体是指仅包含一个标签的变体类型。例如：

```haskell
DollarAmount = <dollars:Float>;
EuroAmount = <euros:Float>;
```

这种定义的变体可以确保不同的类型（如美元和欧元）不会被混淆使用。例如，$dollars2euros$ 函数只能接受 $DollarAmount$ 类型的参数，无法错误地传入 $EuroAmount$。

---

### 练习 11.10.1

**题目**：给定一个变体类型 $OptionalNat = \langle none:Unit, some:Nat \rangle$，定义一个查找表（Table）的扩展函数，并处理查找表中缺少值的情况。

#### 解答：

定义一个查找表的扩展函数 $extendTable$ 和一个处理缺失值的查询函数 $lookupTable$ 如下：

```haskell
extendTable = λt:Table. λm:Nat. λv:Nat.
  λn:Nat.
  if equal n m then <some=v> as OptionalNat else t n;

lookupTable = λt:Table. λn:Nat.
  case t n of
    <none=u> ⇒ 999
  | <some=v> ⇒ v;
```

- $extendTable$ 函数接受一个表 $t$，一个键 $m$，一个值 $v$，以及一个待查的键 $n$，如果 $n = m$，则返回 $v$，否则查询表中已有的值。
- $lookupTable$ 函数用于查找表中键 $n$ 的值，如果该键不存在（返回 $none$），则返回默认值 $999$，否则返回对应的值。

#### 解析：

- 使用变体类型，我们能够处理值缺失的情况，并通过 $case$ 表达式提供默认值。
- 变体类型确保了不同的分支是互斥的，避免了不正确的类型使用。

---

请继续提供后续内容，我会继续逐条详解。

### ---------------------------

### 11.11 General Recursion

🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑递归函数是大多数编程语言中的基础特性之一。在无类型的lambda演算中，我们通过fix组合子定义递归函数。在类型化的环境中，递归函数可以类似地定义，但我们需要显式地添加 $fix$ 作为一个新的原语（primitive），因为在简单类型lambda演算中我们无法定义递归函数。我们来看具体的规则和示例。

#### 11.11.1 fix 原语的定义

$fix$ 是一个固定点组合子，它通过不断自我应用来实现递归计算。为了能够支持递归定义，我们引入了 $fix$，其求值规则和类型规则如下：

**新的语法形式**：

$$
t ::= \ldots \mid \text{fix} \              t
$$

**新的求值规则**：

- **E-FixBeta**：
  $$
  \text{fix} (\lambda x:T_1.t_2) \rightarrow [x \mapsto (\text{fix} (\lambda x:T_1.t_2))]t_2
  $$

  当我们应用 $fix$ 于一个lambda表达式时，求值通过将自身作为参数传递给该lambda表达式来继续。

- **E-Fix**：
  $$
  t_1 \rightarrow t_1' \quad \text{fix} t_1 \rightarrow \text{fix} t_1'
  $$

  当 $fix$ 应用于一个未完全求值的表达式时，我们对该表达式继续求值。

**新的类型规则**：

- **T-Fix**：
  $$
  \frac{\Gamma \vdash t_1 : T_1 \rightarrow T_1}{\Gamma \vdash \text{fix} t_1 : T_1}
  $$

  该规则表明，如果 $t_1$ 的类型是 $T_1 \rightarrow T_1$，那么 $fix t_1$ 的类型是 $T_1$。

此外，$fix$ 也可以用于定义递归函数的派生形式，如 $letrec$，它可以定义为：
$$
\text{letrec } x : T_1 = t_1 \text{ in } t_2 \quad \equiv \quad \text{let } x = \text{fix} (\lambda x : T_1 . t_1) \text{ in } t_2
$$

---

#### 示例：定义递归函数

通过 $fix$，我们可以定义递归函数，如判断一个数是否为偶数的函数 $iseven$。

定义生成函数 $ff$：

$$
ff = \lambda ie:Nat \rightarrow Bool. \lambda x:Nat.
  \text{if } \text{iszero } x \text{ then true else if iszero } (\text{pred } x) \text{ then false else } ie (\text{pred}(\text{pred } x))
$$

$ff$ 生成一个新的 $iseven$ 函数，该函数通过递归调用 $ie$ 来处理较小的数字。

使用 $fix$ 来定义 $iseven$：

$$
iseven = \text{fix } ff
$$

这样，我们可以计算 $iseven(7)$ 得到 $false$，表示7不是偶数。

---

#### 练习 11.11.1：使用 fix 定义 equal、plus、times 和 factorial

**解答**：

1. **equal**：检查两个数是否相等

$$
equal = \text{fix } (\lambda eq:Nat \rightarrow Nat \rightarrow Bool. \lambda x:Nat. \lambda y:Nat.
  \text{if iszero } x \text{ then iszero } y \text{ else if iszero } y \text{ then false else } eq (\text{pred } x) (\text{pred } y))
$$

2. **plus**：两个自然数相加

$$
plus = \text{fix } (\lambda p:Nat \rightarrow Nat \rightarrow Nat. \lambda x:Nat. \lambda y:Nat.
  \text{if iszero } x \text{ then } y \text{ else } p (\text{pred } x) (\text{succ } y))
$$

3. **times**：两个自然数相乘

$$
times = \text{fix } (\lambda t:Nat \rightarrow Nat \rightarrow Nat. \lambda x:Nat. \lambda y:Nat.
  \text{if iszero } x \text{ then 0 else } plus \, y \, (t (\text{pred } x) y))
$$

4. **factorial**：阶乘

$$
factorial = \text{fix } (\lambda f:Nat \rightarrow Nat. \lambda x:Nat.
  {if iszero } x { then 1 else times \, x \, (f (\text{pred } x))})
$$

这些函数都使用 $fix$ 实现递归，$equal$ 比较两个数是否相等，$plus$ 和 $times$ 分别计算加法和乘法，而 $factorial$ 计算阶乘。

---

#### 练习 11.11.2：使用 letrec 重写 plus、times 和 factorial

**解答**：

我们可以使用 $letrec$ 来代替 $fix$ 定义递归函数：

1. **plus** 使用 $letrec$：

$$
\text{letrec } plus:Nat \rightarrow Nat \rightarrow Nat = \lambda x:Nat. \lambda y:Nat.
  \text{if iszero } x \text{ then } y \text{ else } plus (\text{pred } x) (\text{succ } y)
$$

2. **times** 使用 $letrec$：

$$
\text{letrec } times:Nat \rightarrow Nat \rightarrow Nat = \lambda x:Nat. \lambda y:Nat.
  \text{if iszero } x \text{ then 0 else } plus \, y \, (times (\text{pred } x) y)
$$

3. **factorial** 使用 $letrec$：

$$
\text{letrec } factorial:Nat \rightarrow Nat = \lambda x:Nat.
  {if iszero } x { then 1 else times \, x \, (factorial (\text{pred } x))}
$$

---

#### 11.12 列表（Lists）

在编程语言中，列表是一种重要的数据结构。**列表类型** $List T$ 表示一个包含 $T$ 类型元素的有限长度列表。我们可以使用 $nil[T]$ 来表示空列表，使用 $cons[T] t_1 t_2$ 来将元素 $t_1$ 添加到列表 $t_2$ 的前面。

**新的语法形式**：

$$
t ::= \ldots \mid \text{nil}[T] \mid \text{cons}[T] t_1 t_2 \mid \text{isnil}[T] t \mid \text{head}[T] t \mid \text{tail}[T] t
$$

**新的求值规则**：

- **E-Cons1**：
  $$
  t_1 \rightarrow t_1' \quad \text{cons}[T] t_1 t_2 \rightarrow \text{cons}[T] t_1' t_2
  $$

- **E-IsnilNil**：
  $$
  \text{isnil}[S](\text{nil}[T]) \rightarrow \text{true}
  $$

- **E-HeadCons**：
  $$
  \text{head}[S](\text{cons}[T] v_1 v_2) \rightarrow v_1
  $$

**新的类型规则**：

- **T-Nil**：
  $$
  \Gamma \vdash \text{nil}[T_1] : \text{List } T_1
  $$

- **T-Cons**：
  $$
  \frac{\Gamma \vdash t_1 : T_1 \quad \Gamma \vdash t_2 : \text{List } T_1}{\Gamma \vdash \text{cons}[T_1] t_1 t_2 : \text{List } T_1}
  $$

- **T-Isnil**：
  $$
  \Gamma \vdash t_1 : \text{List } T_1 \quad \Gamma \vdash \text{isnil}[T_1] t_1 : \text{Bool}
  $$

这些规则允许我们定义和操作列表。通过这些规则，列表可以被构建、检查是否为空、访问其头部和尾部。

---

#### 练习 11.12.1：验证简单类型lambda演算中带有布尔值和列表的进展性（Progress）和保持性（Preservation）

**解答**：

进展性（Progress）证明表明，在良类型的表达式中，要么该表达式是值，要么它可以继续求值。保持性（Preservation）证明表明，在良类型的表达式中，若其经过求值步骤后得到一个新表达式，则新表达式的类型与原表达式的类型相同。

---

请继续提供后续内容，我将

逐条详细讲解。

### ----------------------------

### 11.6 对（Pairs）

#### 概述

大多数编程语言都提供了构建复合数据结构的多种方式，其中最简单的是**对**（pair）或更一般的**元组**（tuple）。在这一节中，我们将探讨对的形式化定义，以及如何在简单类型λ演算中添加对的支持。

#### 语法与类型规则

我们引入新的语法和类型构造，以支持对的创建和操作。

**新语法形式**：

- **项（terms）**：
  $$
  t ::= \ldots \mid \{ t_1, t_2 \} \mid t.1 \mid t.2
  $$
  - $\{ t_1, t_2 \}$：表示对的构造，包含两个元素 $t_1$ 和 $t_2$。
  - $t.1$：表示从对 $t$ 中提取第一个元素（投射）。
  - $t.2$：表示从对 $t$ 中提取第二个元素。

- **值（values）**：
  $$
  v ::= \ldots \mid \{ v_1, v_2 \}
  $$
  - $\{ v_1, v_2 \}$：当 $v_1$ 和 $v_2$ 都是值时，$\{ v_1, v_2 \}$ 也是一个值。

- **类型（types）**：
  $$
  T ::= \ldots \mid T_1 \times T_2
  $$
  - $T_1 \times T_2$：对的类型，表示由类型 $T_1$ 和 $T_2$ 组成的积类型（product type）。

#### 求值规则

**求值规则**定义了如何对新的项进行计算：

1. **E-PairBeta1**：
   $$
   \{ v_1, v_2 \}.1 \rightarrow v_1
   $$
   - 当我们对一个完全求值的对应用 $.1$ 时，结果是第一个元素 $v_1$。

2. **E-PairBeta2**：
   $$
   \{ v_1, v_2 \}.2 \rightarrow v_2
   $$
   - 类似地，应用 $.2$ 时，结果是第二个元素 $v_2$。

3. **E-Proj1**：
   $$
   t_1 \rightarrow t_1' \quad t_1.1 \rightarrow t_1'.1
   $$
   - 如果 $t_1$ 可以进一步求值，那么 $t_1.1$ 也可以进一步求值。

4. **E-Proj2**：
   $$
   t_1 \rightarrow t_1' \quad t_1.2 \rightarrow t_1'.2
   $$
   - 类似地，$t_1.2$ 也可以继续求值。

5. **E-Pair1**：
   $$
   t_1 \rightarrow t_1' \quad \{ t_1, t_2 \} \rightarrow \{ t_1', t_2 \}
   $$
   - 对的第一个元素 $t_1$ 可以先求值。

6. **E-Pair2**：
   $$
   t_2 \rightarrow t_2' \quad \{ v_1, t_2 \} \rightarrow \{ v_1, t_2' \}
   $$
   - 当第一个元素已经是值时，继续对第二个元素 $t_2$ 求值。

这些规则确保了对的元素按照从左到右的顺序求值。

#### 类型规则

**类型规则**定义了如何为新的项分配类型：

1. **T-Pair**（对的构造）：
   $$
   \frac{\Gamma \vdash t_1 : T_1 \quad \Gamma \vdash t_2 : T_2}{\Gamma \vdash \{ t_1, t_2 \} : T_1 \times T_2}
   $$
   - 如果 $t_1$ 的类型是 $T_1$，$t_2$ 的类型是 $T_2$，那么对 $\{ t_1, t_2 \}$ 的类型是 $T_1 \times T_2$。

2. **T-Proj1**（第一投射）：
   $$
   \frac{\Gamma \vdash t : T_1 \times T_2}{\Gamma \vdash t.1 : T_1}
   $$
   - 如果 $t$ 的类型是 $T_1 \times T_2$，那么 $t.1$ 的类型是 $T_1$。

3. **T-Proj2**（第二投射）：
   $$
   \frac{\Gamma \vdash t : T_1 \times T_2}{\Gamma \vdash t.2 : T_2}
   $$
   - 类似地，$t.2$ 的类型是 $T_2$。

#### 示例

考虑以下复合项：

$$
\{ \text{pred } 4, \ \text{if true then false else false} \}.1
$$

求值步骤如下：

1. 计算对的第一个元素：
   $$
   \{ 3, \ \text{if true then false else false} \}.1
   $$
2. 计算对的第二个元素（由于第一个元素已经是值，可以继续）：
   $$
   \{ 3, \ \text{false} \}.1
   $$
3. 应用投射：
   $$
   3
   $$

#### 说明

- 对的元素必须是值，这保证了当对被作为函数参数传递时，其元素已经被完全求值。
- 求值顺序是从左到右的，首先求值左侧的元素，然后是右侧的元素。

---

### 11.7 元组（Tuples）

#### 概述

元组是对的自然推广，可以包含任意数量的元素（n元组）。例如，$\{1, 2, \text{true}\}$ 是一个三元组，包含两个自然数和一个布尔值，其类型为 $\{ \text{Nat}, \text{Nat}, \text{Bool} \}$。

#### 语法与类型规则

**新语法形式**：

- **项（terms）**：
  $$
  t ::= \ldots \mid \{ t_i \}_{i=1}^n \mid t.i
  $$
  - $\{ t_i \}_{i=1}^n$：表示一个包含 $n$ 个元素的元组。
  - $t.i$：表示从元组 $t$ 中提取第 $i$ 个元素。

- **值（values）**：
  $$
  v ::= \ldots \mid \{ v_i \}_{i=1}^n
  $$
  - 当所有 $v_i$ 都是值时，元组 $\{ v_i \}_{i=1}^n$ 是一个值。

- **类型（types）**：
  $$
  T ::= \ldots \mid \{ T_i \}_{i=1}^n
  $$
  - 元组类型，由各元素的类型组成。

#### 求值规则

1. **E-ProjTuple**（投射）：
   $$
   \{ v_i \}_{i=1}^n . j \rightarrow v_j
   $$
   - 当元组中的所有元素都是值时，投射操作直接返回第 $j$ 个元素。

2. **E-Proj**：
   $$
   t_1 \rightarrow t_1' \quad t_1 . i \rightarrow t_1' . i
   $$
   - 当元组还未完全求值时，继续对其求值。

3. **E-Tuple**：
   $$
   t_j \rightarrow t_j' \quad \{ v_i \}_{i=1}^{j-1}, t_j, t_k \}_{k=j+1}^n \rightarrow \{ v_i \}_{i=1}^{j-1}, t_j', t_k \}_{k=j+1}^n
   $$
   - 从左到右依次求值元组的元素。

#### 类型规则

1. **T-Tuple**（元组的构造）：
   $$
   \frac{\forall i, \Gamma \vdash t_i : T_i}{\Gamma \vdash \{ t_i \}_{i=1}^n : \{ T_i \}_{i=1}^n}
   $$
   - 如果每个 $t_i$ 的类型是 $T_i$，则元组的类型是 $\{ T_i \}_{i=1}^n$。

2. **T-Proj**（投射）：
   $$
   \frac{\Gamma \vdash t : \{ T_i \}_{i=1}^n}{\Gamma \vdash t.j : T_j}
   $$
   - 从元组类型中提取第 $j$ 个元素的类型。

#### 说明

- 元组可以是空的（$n = 0$），这时表示空元组 $\{\}$。
- 一元元组（$n = 1$）与单独的值是不同的，例如 $\{ 5 \}$ 与 $5$ 是不同的，前者是元组，可以进行投射操作。

---

### 11.8 记录（Records）

#### 概述

记录是元组的进一步推广，允许为每个字段指定标签（label）。记录中的元素通过标签来标识，而不是通过位置。

例如：

- $\{ x = 5 \}$ 是一个记录，其类型为 $\{ x : \text{Nat} \}$。
- $\{ \text{partno} = 5524, \ \text{cost} = 30.27 \}$ 是一个记录，其类型为 $\{ \text{partno} : \text{Nat}, \ \text{cost} : \text{Float} \}$。

#### 语法与类型规则

**新语法形式**：

- **项（terms）**：
  $$
  t ::= \ldots \mid \{ l_i = t_i \}_{i=1}^n \mid t.l
  $$
  - $\{ l_i = t_i \}_{i=1}^n$：记录的构造，包含带标签的字段。
  - $t.l$：从记录 $t$ 中提取标签为 $l$ 的字段。

- **值（values）**：
  $$
  v ::= \ldots \mid \{ l_i = v_i \}_{i=1}^n
  $$
  - 当所有 $v_i$ 都是值时，记录也是一个值。

- **类型（types）**：
  $$
  T ::= \ldots \mid \{ l_i : T_i \}_{i=1}^n
  $$

#### 求值规则

1. **E-ProjRcd**（记录的投射）：
   $$
   \{ l_i = v_i \}_{i=1}^n . l_j \rightarrow v_j
   $$
   - 当记录中的所有字段都是值时，投射操作返回对应标签的值。

2. **E-Proj**：
   $$
   t_1 \rightarrow t_1' \quad t_1 . l \rightarrow t_1' . l
   $$
   - 当记录还未完全求值时，继续对其求值。

3. **E-Rcd**：
   $$
   t_j \rightarrow t_j' \quad \{ l_i = v_i \}_{i=1}^{j-1}, \ l_j = t_j, \ l_k = t_k \}_{k=j+1}^n \rightarrow \{ l_i = v_i \}_{i=1}^{j-1}, \ l_j = t_j', \ l_k = t_k \}_{k=j+1}^n
   $$
   - 从左到右依次求值记录的字段。

#### 类型规则

1. **T-Rcd**（记录的构造）：
   $$
   \frac{\forall i, \Gamma \vdash t_i : T_i}{\Gamma \vdash \{ l_i = t_i \}_{i=1}^n : \{ l_i : T_i \}_{i=1}^n}
   $$
   - 如果每个 $t_i$ 的类型是 $T_i$，则记录的类型是 $\{ l_i : T_i \}_{i=1}^n$。

2. **T-Proj**（投射）：
   $$
   \frac{\Gamma \vdash t : \{ l_i : T_i \}_{i=1}^n}{\Gamma \vdash t.l_j : T_j}
   $$
   - 从记录类型中提取标签为 $l_j$ 的字段的类型。

#### 说明

- 在记录中，标签的顺序是有意义的，即 $\{ \text{partno} = 5524, \ \text{cost} = 30.27 \}$ 与 $\{ \text{cost} = 30.27, \ \text{partno} = 5524 \}$ 被视为不同的记录，类型也不同。
- 在一些语言中，记录的字段顺序不影响其类型和含义，但在我们的定义中，顺序是重要的。
- 可以将元组视为一种特殊的记录，其中的标签是自然数（位置）。

---

### 习题 11.8.1

**题目**：将规则 E-ProjRcd 写得更加明确，以便比较。

#### 解答

原始的 E-ProjRcd 规则较为简略，我们可以将其写得更加明确：

**更明确的 E-ProjRcd 规则**：

- 前提条件：

  - 记录 $\{ l_1 = v_1, \ldots, l_n = v_n \}$，其中所有 $v_i$ 都是值。
  - 标签 $l_j$ 是记录中的某个标签，即 $j \in \{1, 2, \ldots, n\}$。

- 求值规则：

  $$
  \{ l_1 = v_1, \ldots, l_n = v_n \} . l_j \rightarrow v_j
  $$

- 解释：

  - 当对一个完全求值的记录应用投射操作 $t.l_j$ 时，直接返回对应标签的值 $v_j$。

#### 解析

- 这样写使得规则更加明确，显示了具体的记录结构和投射操作的结果。
- 通过列出所有的标签和对应的值，可以清晰地看到投射操作的行为。

---

### 习题 11.8.2

**题目**：在我们的记录表示中，投射操作一次只能提取一个字段。许多高级编程语言提供了一种模式匹配（pattern matching）语法，可以一次提取所有字段，使得一些程序可以更简洁地表达。模式通常也可以嵌套，允许从复杂的嵌套数据结构中轻松提取部分。

我们可以通过在未类型化的λ演算中添加一个新的模式类别，以及一个新的语法构造来实现记录的模式匹配。（参见图 11-8）

**要求**：

1. 为新添加的构造给出类型规则（在此过程中可以对语法进行任何必要的更改）。
2. 为整个演算概述类型保持性（type preservation）和进展性（progress）的证明。（不需要完整的证明，只需按照正确的顺序给出所需引理的陈述。）

#### 解答

**第1步：给出类型规则**

首先，我们需要定义模式（patterns）的语法和匹配规则，然后为新的 $let p = t_1 in t_2$ 构造给出类型规则。

**新语法形式**：

- **模式（patterns）**：
  $$
  p ::= x \mid \{ l_i = p_i \}_{i=1}^n
  $$
  - $x$：变量模式。
  - $\{ l_i = p_i \}_{i=1}^n$：记录模式，包含多个字段模式。

- **项（terms）**：
  $$
  t ::= \ldots \mid \text{let } p = t_1 \text{ in } t_2
  $$

**匹配规则**：

- **M-Var**（变量模式）：
  $$
  \text{match}(x, v) = [ x \mapsto v ]
  $$
  - 变量模式始终成功匹配，将变量 $x$ 绑定到值 $v$。

- **M-Rcd**（记录模式）：
  $$
  \text{match}(\{ l_i = p_i \}_{i=1}^n, \{ l_i = v_i \}_{i=1}^n) = \sigma_1 \cup \ldots \cup \sigma_n
  $$
  - 对于每个 $i$，匹配子模式 $p_i$ 与对应的值 $v_i$，得到替换 $\sigma_i$。
  - 最终的替换是所有 $\sigma_i$ 的并集。

**类型规则**：

- **T-LetP**（模式绑定）：
  $$
  \frac{\Gamma \vdash t_1 : T_p \quad \Gamma, \Gamma_p \vdash t_2 : T}{\Gamma \vdash \text{let } p = t_1 \text{ in } t_2 : T}
  $$
  - 首先，$t_1$ 的类型是 $T_p$。
  - 然后，根据模式 $p$ 和 $T_p$，推导出新的上下文 $\Gamma_p$，其中包含模式中绑定的变量及其类型。
  - 在扩展的上下文 $\Gamma, \Gamma_p$ 下，$t_2$ 的类型是 $T$。

**模式的类型规则**：

- **P-Var**（变量模式）：
  $$
  \text{typeof\_pattern}(x, T) = \{ x : T \}
  $$
  - 变量模式绑定变量 $x$，其类型为 $T$。

- **P-Rcd**（记录模式）：
  $$
  \text{typeof\_pattern}(\{ l_i = p_i \}_{i=1}^n, \{ l_i : T_i \}_{i=1}^n) = \bigcup_{i=1}^n \text{typeof\_pattern}(p_i, T_i)
  $$
  - 对于记录模式，模式的类型是对应字段类型的集合。

**第2步：概述类型保持性和进展性的证明**

- **类型保持性（Type Preservation）**：

  - **定理**：如果 $\Gamma \vdash t : T$，且 $t \rightarrow t'$，那么 $\Gamma \vdash t' : T$。

  - **证明思路**：

    - 对于新的 $let p = t_1 \text{ in } t_2$ 构造，需要证明：

      - 当 $t_1$ 是值时，匹配成功后，替换后的 $t_2$ 在扩展的上下文下类型正确。

      - 当 $t_1$ 还未求值完毕时，继续对 $t_1$ 求值，类型不变。

- **进展性（Progress）**：

  - **定理**：如果 $\emptyset \vdash t : T$，则 $t$ 要么是值，要么存在 $t'$ 使得 $t \rightarrow t'$。

  - **证明思路**：

    - 对于新的构造：

      - 如果 $let p = t_1 \text{ in } t_2$，且 $t_1$ 是值，那么根据匹配规则，可以计算出替换，然后继续求值。

      - 如果 $t_1$ 不是值，则根据求值规则，对 $t_1$ 进行求值。

---

#### 解析

通过引入模式匹配，我们可以一次从记录中提取多个字段，简化了程序的书写。类型规则需要考虑模式与值的对应，以及如何在类型上下文中添加模式中绑定的变量。

---

### 总结

在这一系列章节中，我们扩展了简单类型λ演算，添加了对、元组、记录以及模式匹配等构造。通过详细的语法、求值规则和类型规则，我们理解了这些扩展如何在理论上定义，以及在编程语言中如何使用。同时，我们解答了相关的习题，加深了对概念的理解。

---

**如果您对上述内容有任何疑问，或者希望深入探讨某个具体部分，请随时提问！**

### ---------------------------

### 11.9 和类型（Sums）

#### 概述

许多程序需要处理**异构集合**（heterogeneous collections）的值。例如，二叉树的节点可以是叶子节点，或者是具有两个子节点的内部节点；类似地，列表的单元可以是 $nil$（空）或者一个包含头和尾的 $cons$ 单元；在编译器的抽象语法树中，一个节点可以表示变量、抽象、应用等。支持这种编程的类型理论机制是**变体类型**（variant types）。

#### 语法与类型规则

**新语法形式**：

- **项（terms）**：
  $$
  t ::= \ldots \mid \text{inl } t \mid \text{inr } t \mid \text{case } t \text{ of } \text{inl } x \Rightarrow t \mid \text{inr } x \Rightarrow t
  $$
  - $\text{inl } t$：左标签的标记（tagging）。
  - $\text{inr } t$：右标签的标记。
  - $\text{case } t \text{ of } \text{inl } x \Rightarrow t_1 \mid \text{inr } x \Rightarrow t_2$：**case**表达式，根据 $t$ 的标签选择执行哪个分支。

- **值（values）**：
  $$
  v ::= \ldots \mid \text{inl } v \mid \text{inr } v
  $$
  - $\text{inl } v$：左标签的标记值。
  - $\text{inr } v$：右标签的标记值。

- **类型（types）**：
  $$
  T ::= \ldots \mid T + T
  $$
  - $T_1 + T_2$：和类型（sum type）。

#### 求值规则

**新求值规则**：

1. **E-CaseInl**：
   $$
   \text{case } (\text{inl } v_0) \text{ of } \text{inl } x_1 \Rightarrow t_1 \mid \text{inr } x_2 \Rightarrow t_2 \rightarrow [x_1 \mapsto v_0] t_1
   $$
   - 当 $\text{case}$ 的参数是左标签的值 $\text{inl } v_0$ 时，选择第一个分支，绑定 $x_1$ 为 $v_0$，然后执行 $t_1$。

2. **E-CaseInr**：
   $$
   \text{case } (\text{inr } v_0) \text{ of } \text{inl } x_1 \Rightarrow t_1 \mid \text{inr } x_2 \Rightarrow t_2 \rightarrow [x_2 \mapsto v_0] t_2
   $$
   - 当 $\text{case}$ 的参数是右标签的值 $\text{inr } v_0$ 时，选择第二个分支，绑定 $x_2$ 为 $v_0$，然后执行 $t_2$。

3. **E-Case**：
   $$
   t_0 \rightarrow t_0' \quad \text{case } t_0 \text{ of } \text{inl } x_1 \Rightarrow t_1 \mid \text{inr } x_2 \Rightarrow t_2 \rightarrow \text{case } t_0' \text{ of } \text{inl } x_1 \Rightarrow t_1 \mid \text{inr } x_2 \Rightarrow t_2
   $$
   - 当 $\text{case}$ 的参数 $t_0$ 还未完全求值时，先对 $t_0$ 进行求值。

4. **E-Inl**：
   $$
   t_1 \rightarrow t_1' \quad \text{inl } t_1 \rightarrow \text{inl } t_1'
   $$
   - 对 $\text{inl}$ 的参数 $t_1$ 进行求值。

5. **E-Inr**：
   $$
   t_1 \rightarrow t_1' \quad \text{inr } t_1 \rightarrow \text{inr } t_1'
   $$
   - 对 $\text{inr}$ 的参数 $t_1$ 进行求值。

#### 类型规则

**新类型规则**：

1. **T-Inl**：
   $$
   \frac{\Gamma \vdash t_1 : T_1}{\Gamma \vdash \text{inl } t_1 : T_1 + T_2}
   $$
   - 如果 $t_1$ 的类型是 $T_1$，则 $\text{inl } t_1$ 的类型是 $T_1 + T_2$。

2. **T-Inr**：
   $$
   \frac{\Gamma \vdash t_1 : T_2}{\Gamma \vdash \text{inr } t_1 : T_1 + T_2}
   $$
   - 如果 $t_1$ 的类型是 $T_2$，则 $\text{inr } t_1$ 的类型是 $T_1 + T_2$。

3. **T-Case**：
   $$
   \frac{\Gamma \vdash t_0 : T_1 + T_2 \quad \Gamma, x_1 : T_1 \vdash t_1 : T \quad \Gamma, x_2 : T_2 \vdash t_2 : T}{\Gamma \vdash \text{case } t_0 \text{ of } \text{inl } x_1 \Rightarrow t_1 \mid \text{inr } x_2 \Rightarrow t_2 : T}
   $$
   - 如果 $t_0$ 的类型是 $T_1 + T_2$，并且在扩展了上下文的情况下，$t_1$ 和 $t_2$ 的类型都是 $T$，那么整个 $\text{case}$ 表达式的类型是 $T$。

#### 示例

假设我们有以下两种类型，用于表示不同类型的地址簿记录：

- **PhysicalAddr**（物理地址）：
  $$
  \text{PhysicalAddr} = \{ \text{firstlast} : \text{String}, \ \text{addr} : \text{String} \}
  $$

- **VirtualAddr**（虚拟地址）：
  $$
  \text{VirtualAddr} = \{ \text{name} : \text{String}, \ \text{email} : \text{String} \}
  $$

我们想要统一处理这两种类型的记录（例如，创建一个包含两种记录的列表）。为此，我们引入一个和类型：

$$
\text{Addr} = \text{PhysicalAddr} + \text{VirtualAddr}
$$

这样，$\text{Addr}$ 类型的元素要么是一个 $\text{PhysicalAddr}$，要么是一个 $\text{VirtualAddr}$。

如果我们有一个物理地址记录 $\text{pa}$，那么我们可以通过 $\text{inl } \text{pa}$ 将其标记为 $\text{Addr}$ 类型的一个元素。

类似地，我们可以定义一个函数 $\text{getName}$ 来从 $\text{Addr}$ 类型的值中提取名字：

$$
\text{getName} = \lambda a : \text{Addr}. \ \text{case } a \text{ of } \text{inl } x \Rightarrow x.\text{firstlast} \mid \text{inr } y \Rightarrow y.\text{name}
$$

当参数 $a$ 是一个带有 $\text{inl}$ 标签的 $\text{PhysicalAddr}$ 时，$\text{case}$ 表达式会选择第一个分支，绑定 $x$ 为 $\text{PhysicalAddr}$ 的值，然后返回 $x.\text{firstlast}$。

当 $a$ 是一个带有 $\text{inr}$ 标签的 $\text{VirtualAddr}$ 时，$\text{case}$ 表达式会选择第二个分支，绑定 $y$ 为 $\text{VirtualAddr}$ 的值，然后返回 $y.\text{name}$。

因此，$\text{getName}$ 函数的类型是 $\text{Addr} \rightarrow \text{String}$。

#### 习题 11.9.1

**题目**：注意到 $\text{case}$ 的类型规则与图 8-1 中 $\text{if}$ 的规则的相似性：$\text{if}$ 可以被看作是一种退化形式的 $\text{case}$，其中没有信息传递给分支。通过使用和类型和 $\text{Unit}$，将 $\text{true}$、$\text{false}$ 和 $\text{if}$ 定义为派生形式，以形式化这一直觉。

**解答**：

我们可以使用和类型 $\text{Unit} + \text{Unit}$ 来定义布尔值 $\text{true}$ 和 $\text{false}$，以及 $\text{if}$ 表达式。

- 定义 $\text{Bool}$ 类型：
  $$
  \text{Bool} = \text{Unit} + \text{Unit}
  $$

- 定义 $\text{true}$ 和 $\text{false}$：
  $$
  \text{true} = \text{inl } \text{unit} : \text{Bool}
  $$
  $$
  \text{false} = \text{inr } \text{unit} : \text{Bool}
  $$

- 定义 $\text{if}$ 表达式：
  $$
  \text{if } t_1 \text{ then } t_2 \text{ else } t_3 = \text{case } t_1 \text{ of } \text{inl } \_ \Rightarrow t_2 \mid \text{inr } \_ \Rightarrow t_3
  $$

在这个定义中，我们将 $\text{Bool}$ 类型表示为 $\text{Unit} + \text{Unit}$，即一个和类型，其中左分支和右分支都与 $\text{Unit}$ 类型相关联。

- $\text{true}$ 是左分支的 $\text{Unit}$ 值，即 $\text{inl unit}$。
- $\text{false}$ 是右分支的 $\text{Unit}$ 值，即 $\text{inr unit}$。

$\text{if}$ 表达式通过对 $t_1$ 进行 $\text{case}$ 分析，如果是 $\text{inl}$，则执行 $t_2$，否则执行 $t_3$。

这样，我们就形式化地将 $\text{true}$、$\text{false}$ 和 $\text{if}$ 定义为使用和类型和 $\text{Unit}$ 的派生形式。

#### 和类型与类型唯一性

大多数纯 λ→ 系统的类型关系的性质都可以扩展到带有和类型的系统，但有一个重要的性质失效了：**类型唯一性定理**（定理 9.3.3）。问题出在标记构造 $\text{inl}$ 和 $\text{inr}$。

例如，类型规则 **T-Inl** 表示，一旦我们证明 $t_1$ 是 $T_1$ 的元素，那么对于任意类型 $T_2$，我们都可以推导出 $\text{inl } t_1$ 是 $T_1 + T_2$ 的元素。

例如，我们可以推导出：

- $\text{inl } 5 : \text{Nat} + \text{Nat}$
- $\text{inl } 5 : \text{Nat} + \text{Bool}$

还有无穷多个其他类型。

类型唯一性的失败意味着我们不能简单地“自下而上地读取规则”来构建类型检查算法，就像我们之前对所有特性所做的那样。

#### 解决方案

在这个时候，我们有多种选择：

1. **复杂化类型检查算法**：我们可以让类型检查算法更复杂，以某种方式“猜测” $T_2$ 的值。具体地说，我们在这个点上将 $T_2$ 保持不确定，尝试在之后发现它的值应该是什么。这样的技术将在我们讨论类型重建（第 22 章）时详细探讨。

2. **引入子类型**：我们可以改进类型语言，使得所有可能的 $T_2$ 的值都能够以某种方式统一表示。当我们讨论子类型（第 15 章）时，将探讨这种选择。

3. **显式类型注解**：我们可以要求程序员提供一个显式的注解，以指明所期望的 $T_2$ 类型。这种选择是最简单的，而且实际上并不像看起来那么不实用，因为在完整的语言设计中，这些显式注解通常可以“搭载”（piggyback）在其他语言构造上，从而基本上是隐形的（我们将在下一节中回到这一点）。现在我们采用这个选项。

#### 改进的和类型定义

**图 11-10** 展示了相对于**图 11-9** 所需的扩展。我们不再只是写 $\text{inl } t$ 或 $\text{inr } t$，而是写作 $\text{inl } t \text{ as } T$ 或 $\text{inr } t \text{ as } T$，其中 $T$ 指定了我们希望注入的元素所属的整个和类型。

**新语法形式**：

- **项（terms）**：
  $$
  t ::= \ldots \mid \text{inl } t \text{ as } T \mid \text{inr } t \text{ as } T
  $$
  - $\text{inl } t \text{ as } T$：带左标签的标记，类型注解为 $T$。
  - $\text{inr } t \text{ as } T$：带右标签的标记，类型注解为 $T$。

- **值（values）**：
  $$
  v ::= \ldots \mid \text{inl } v \text{ as } T \mid \text{inr } v \text{ as } T
  $$
  - 带有类型注解的标记值。

#### 新的求值规则

1. **E-CaseInl**：
   $$
   \text{case } (\text{inl } v_0 \text{ as } T_0) \text{ of } \text{inl } x_1 \Rightarrow t_1 \mid \text{inr } x_2 \Rightarrow t_2 \rightarrow [x_1 \mapsto v_0] t_1
   $$

2. **E-CaseInr**：
   $$
   \text{case } (\text{inr } v_0 \text{ as } T_0) \text{ of } \text{inl } x_1 \Rightarrow t_1 \mid \text{inr } x_2 \Rightarrow t_2 \rightarrow [x_2 \mapsto v_0] t_2
   $$

3. **E-Inl**：
   $$
   t_1 \rightarrow t_1' \quad \text{inl } t_1 \text{ as } T_2 \rightarrow \text{inl } t_1' \text{ as } T_2
   $$

4. **E-Inr**：
   $$
   t_1 \rightarrow t_1' \quad \text{inr } t_1 \text{ as } T_2 \rightarrow \text{inr } t_1' \text{ as } T_2
   $$

#### 新的类型规则

1. **T-Inl**：
   $$
   \frac{\Gamma \vdash t_1 : T_1}{\Gamma \vdash \text{inl } t_1 \text{ as } T_1 + T_2 : T_1 + T_2}
   $$

2. **T-Inr**：
   $$
   \frac{\Gamma \vdash t_1 : T_2}{\Gamma \vdash \text{inr } t_1 \text{ as } T_1 + T_2 : T_1 + T_2}
   $$

这些类型规则使用声明的和类型作为注入的类型，在检查注入的项确实属于和类型的适当分支之后。

通过这种方式，我们解决了类型唯一性的问题，因为注入的和类型 $T_1 + T_2$ 是明确指定的。

---

以上就是对第 11.9 节的详细解释，包括所有的语法、求值规则和类型规则，以及对相关习题的解答。

### ----------------------------

**11.10 变体（Variants）**

在编程语言中，变体（又称为标签联合类型或和类型）允许我们定义可以持有不同类型值的类型，每个值都带有一个标签，用于标识其类型。这类似于如何将二元和类型（如 $T1 + T2$）泛化为带标签的变体，就像乘积类型（如 $T1 \times T2$）泛化为带标签的记录一样。

**将二元和类型泛化为带标签的变体**

- **二元和类型**：传统上，二元和类型 $T1 + T2$ 表示一个值可以是类型 $T1$ 或类型 $T2$，但没有显式的标签。

- **带标签的变体**：为了泛化这一点，我们引入标签来标识每个变体。我们将 $T1 + T2$ 写成 $\langle l1:T1, l2:T2 \rangle$，其中 $l1$ 和 $l2$ 是分别与类型 $T1$ 和 $T2$ 关联的标签。

- **标记值**：当构造变体类型的值时，我们使用标签来标记这些值。我们将 $\text{inl } t$ 作为 $T1 + T2$ 写成 $\langle l1 = t \rangle$ 作为 $\langle l1:T1, l2:T2 \rangle$。

- **案例分析**：在对变体值进行案例分析时，我们使用与变体类型定义中相同的标签。我们不再使用 $\text{inl}$ 和 $\text{inr}$ 来标记分支，而是使用 $l1$ 和 $l2$。

**示例：**

让我们考虑一个示例，我们定义一个地址类型，该类型可以是物理地址（PhysicalAddr）或虚拟地址（VirtualAddr）。

1. **定义变体类型：**

   $$
   \text{Addr} = \langle \text{physical}: \text{PhysicalAddr}, \text{virtual}: \text{VirtualAddr} \rangle;
   $$

   这里，$\text{Addr}$ 是一个具有两个标签的变体类型：

   - $\text{physical}$，关联类型 $\text{PhysicalAddr}$
   - $\text{virtual}$，关联类型 $\text{VirtualAddr}$

2. **创建一个变体值：**

   $$
   a = \langle \text{physical} = pa \rangle \ \text{as} \ \text{Addr};
   $$

   $$
   \vdash a : \text{Addr}
   $$

   - 我们创建了一个类型为 $\text{Addr}$ 的值 $a$，通过使用标签 $\text{physical}$ 标记一个 $\text{PhysicalAddr}$ 值 $pa$。
   - 符号 $\vdash a : \text{Addr}$ 表示 $a$ 的类型是 $\text{Addr}$。

3. **定义一个带有案例分析的函数：**

   $$
   \begin{align*}
   \text{getName} =\ & \lambda a: \text{Addr}. \\
   & \text{case } a \ \text{of} \\
   & \quad \langle \text{physical} = x \rangle \Rightarrow x.\text{firstlast} \\
   & | \ \langle \text{virtual} = y \rangle \Rightarrow y.\text{name};
   \end{align*}
   $$

   $$
   \vdash \text{getName} : \text{Addr} \to \text{String}
   $$

   - $\text{getName}$ 是一个函数，接受一个 $\text{Addr}$，返回一个 $\text{String}$。
   - 它对 $a$ 进行案例分析：
     - 如果 $a$ 被标签 $\text{physical}$ 标记，它提取 $x$，并计算 $x.\text{firstlast}$。
     - 如果 $a$ 被标签 $\text{virtual}$ 标记，它提取 $y$，并计算 $y.\text{name}$。

**变体的形式化定义（图 11-11）**

变体的形式化定义包括语法、求值规则和类型规则。

**图 11-11：变体**

该图扩展了简单类型的 $\lambda$ 演算（记为 $\lambda\to$），加入了变体。

**新的语法形式：**

- **项（$t$）：**

  $$
  t ::= \ldots \ |\ \langle l = t \rangle \ \text{as} \ T\ |\ \text{case } t \ \text{of}\ \langle l_i = x_i \rangle \Rightarrow t_i\ (i \in 1..n)
  $$

  - **标记（Tagging）**：$\langle l = t \rangle \ \text{as} \ T$ 通过使用标签 $l$ 将 $t$ 标记为类型 $T$ 的变体值。
  - **案例表达式（Case Expression）**：$\text{case } t \ \text{of}\ \langle l_i = x_i \rangle \Rightarrow t_i$ 表示对 $t$ 的案例分析，使用模式 $\langle l_i = x_i \rangle$ 及对应的表达式 $t_i$。

- **类型（$T$）：**

  $$
  T ::= \ldots \ |\ \langle l_i: T_i \ (i \in 1..n) \rangle
  $$

  - **变体类型（Variant Types）**：$\langle l_i: T_i \rangle$ 表示具有标签 $l_i$ 和对应类型 $T_i$ 的变体类型。

**新的求值规则（$t \to t'$）：**

1. **（E-CaseVariant）：**

   $$
   \frac{}{\text{case } (\langle l_j = v_j \rangle \ \text{as} \ T) \ \text{of}\ \langle l_i = x_i \rangle \Rightarrow t_i\ (i \in 1..n) \to [x_j \mapsto v_j] t_j}
   $$

   - 当求值一个案例表达式，且被分析的项是一个标记值 $\langle l_j = v_j \rangle \ \text{as} \ T$ 时，我们在案例分支中找到匹配的标签 $l_j$。
   - 我们将 $v_j$ 替换到对应的表达式 $t_j$ 中。

2. **（E-Case）：**

   $$
   \frac{t_0 \to t_0'}{\text{case } t_0 \ \text{of}\ \langle l_i = x_i \rangle \Rightarrow t_i \to \text{case } t_0' \ \text{of}\ \langle l_i = x_i \rangle \Rightarrow t_i}
   $$

   - 如果 $t_0$ 可以一步求值到 $t_0'$，那么整个案例表达式求值为 $\text{case } t_0' \ \text{of}\ \langle l_i = x_i \rangle \Rightarrow t_i$。

3. **（E-Variant）：**

   $$
   \frac{t_i \to t_i'}{\langle l_i = t_i \rangle \ \text{as} \ T \to \langle l_i = t_i' \rangle \ \text{as} \ T}
   $$

   - 如果 $t_i$ 可以求值到 $t_i'$，那么标记值相应地求值。

**新的类型规则（$\Gamma \vdash t : T$）：**

1. **（T-Variant）：**

   $$
   \frac{\Gamma \vdash t_j : T_j}{\Gamma \vdash \langle l_j = t_j \rangle \ \text{as} \ \langle l_i: T_i \rangle : \langle l_i: T_i \rangle}
   $$

   - 如果 $t_j$ 的类型为 $T_j$，那么标记值 $\langle l_j = t_j \rangle \ \text{as} \ \langle l_i: T_i \rangle$ 的类型为变体类型 $\langle l_i: T_i \rangle$。

2. **（T-Case）：**

   $$
   \frac{\Gamma \vdash t_0 : \langle l_i: T_i \rangle \quad \forall i,\ \Gamma, x_i: T_i \vdash t_i : T}{\Gamma \vdash \text{case } t_0 \ \text{of}\ \langle l_i = x_i \rangle \Rightarrow t_i : T}
   $$

   - 如果 $t_0$ 的类型为变体类型 $\langle l_i: T_i \rangle$，且每个分支 $t_i$ 在扩展了 $x_i: T_i$ 的上下文中具有类型 $T$，那么整个案例表达式的类型为 $T$。

**关键点：**

- 在变体类型中，标签的顺序是重要的。
- 标签作为变体类型的构造器，它们在构造变体值和模式匹配中使用。

---

**选项类型（Options）**

变体在表示可选值时特别有用——即值可能存在也可能不存在。

**定义一个可选类型：**

$$
\text{OptionalNat} = \langle \text{none}: \text{Unit}, \text{some}: \text{Nat} \rangle;
$$

- $\text{OptionalNat}$ 是一个变体类型，有两种可能性：
  - $\text{none}$，标记为 $\text{Unit}$，表示值的缺失。
  - $\text{some}$，标记为 $\text{Nat}$，表示存在一个自然数。

**使用可选类型：**

- **创建一个空表：**

  $$
  \text{Table} = \text{Nat} \to \text{OptionalNat};
  $$

  $$
  \text{emptyTable} = \lambda n: \text{Nat}. \langle \text{none} = \text{unit} \rangle \ \text{as} \ \text{OptionalNat};
  $$

  $$
  \vdash \text{emptyTable} : \text{Table}
  $$

  - $\text{Table}$ 是一个从 $\text{Nat}$ 到 $\text{OptionalNat}$ 的函数类型，表示一个映射。
  - $\text{emptyTable}$ 是一个始终返回 $\text{none}$ 的函数，表示一个空的映射。

- **扩展表：**

  $$
  \begin{align*}
  \text{extendTable} =\ & \lambda t: \text{Table}. \lambda m: \text{Nat}. \lambda v: \text{Nat}. \\
  & \lambda n: \text{Nat}. \\
  & \quad \text{if } \text{equal } n\ m\ \text{then}\ \langle \text{some} = v \rangle \ \text{as} \ \text{OptionalNat} \\
  & \quad \text{else } t\ n;
  \end{align*}
  $$

  $$
  \vdash \text{extendTable} : \text{Table} \to \text{Nat} \to \text{Nat} \to \text{Table}
  $$

  - $\text{extendTable}$ 接受一个表 $t$，一个键 $m$，和一个值 $v$。
  - 它返回一个新的表，将 $m$ 映射到 $v$，其他查找则委托给 $t$。

- **使用案例分析处理可选值：**

  $$
  x = \text{case } t(5) \ \text{of} \\
  \quad \langle \text{none} = u \rangle \Rightarrow 999 \\
  | \ \langle \text{some} = v \rangle \Rightarrow v;
  $$

  - 当在表中查找一个值时，我们进行案例分析。
  - 如果结果是 $\text{none}$，我们提供一个默认值（例如 $999$）。
  - 如果结果是 $\text{some}\ v$，我们使用值 $v$。

**与其他语言的类比：**

- 像 OCaml 这样的语言内置了对可选类型的支持。
- 在 C、C++ 和 Java 等语言中，$\text{null}$ 值实际上可以看作一种可选类型，其中一个变量可以包含类型 $T$ 的对象，或是 $\text{null}$（即 $\text{Option}(T)$）。

---

**枚举类型（Enumerations）**

变体类型的两个“退化情况”值得特别提及：枚举类型和单字段变体。

**定义枚举类型：**

$$
\begin{align*}
\text{Weekday} =\ \langle & \text{monday}: \text{Unit},\ \text{tuesday}: \text{Unit},\ \text{wednesday}: \text{Unit}, \\
& \text{thursday}: \text{Unit},\ \text{friday}: \text{Unit} \rangle;
\end{align*}
$$

- $\text{Weekday}$ 是一个变体类型，表示工作周的天数。
- 每一天都与 $\text{Unit}$ 类型关联，因此每个标签的唯一可能值是 $\text{unit}$。

**使用枚举类型：**

- **创建值：**

  - 类型为 $\text{Weekday}$ 的值示例：

    $$
    \langle \text{monday} = \text{unit} \rangle \ \text{as} \ \text{Weekday}
    $$

    $$
    \langle \text{tuesday} = \text{unit} \rangle \ \text{as} \ \text{Weekday}
    $$

- **定义针对枚举类型的函数：**

  $$
  \begin{align*}
  \text{nextBusinessDay} =\ & \lambda w: \text{Weekday}. \\
  & \text{case } w \ \text{of} \\
  & \quad \langle \text{monday} = x \rangle \Rightarrow \langle \text{tuesday} = \text{unit} \rangle \ \text{as} \ \text{Weekday} \\
  & | \ \langle \text{tuesday} = x \rangle \Rightarrow \langle \text{wednesday} = \text{unit} \rangle \ \text{as} \ \text{Weekday} \\
  & | \ \langle \text{wednesday} = x \rangle \Rightarrow \langle \text{thursday} = \text{unit} \rangle \ \text{as} \ \text{Weekday} \\
  & | \ \langle \text{thursday} = x \rangle \Rightarrow \langle \text{friday} = \text{unit} \rangle \ \text{as} \ \text{Weekday} \\
  & | \ \langle \text{friday} = x \rangle \Rightarrow \langle \text{monday} = \text{unit} \rangle \ \text{as} \ \text{Weekday};
  \end{align*}
  $$

  - $\text{nextBusinessDay}$ 计算下一个工作日，在星期五之后循环回星期一。

**关于语法的注意：**

- 这里使用的具体语法较为冗长。
- 一些语言提供了针对枚举类型的特殊语法，使其更简洁和易读。

---

**单字段变体（Single-Field Variants）**

具有单个标签的变体类型可以用于创建不同的类型，即使它们的底层类型相同。

**定义单字段变体：**

$$
\text{DollarAmount} = \langle \text{dollars}: \text{Float} \rangle;
$$

$$
\text{EuroAmount} = \langle \text{euros}: \text{Float} \rangle;
$$

- 这些类型表示不同货币的金额。
- 尽管它们都基于 $\text{Float}$，但由于它们的标签不同，因而是不同的类型。

**安全的货币转换函数：**

- **美元到欧元：**

  $$
  \begin{align*}
  \text{dollars2euros} =\ & \lambda d: \text{DollarAmount}. \\
  & \text{case } d \ \text{of} \ \langle \text{dollars} = x \rangle \Rightarrow \\
  & \quad \langle \text{euros} = \text{timesfloat } x\ 1.1325 \rangle \ \text{as} \ \text{EuroAmount};
  \end{align*}
  $$

  $$
  \vdash \text{dollars2euros} : \text{DollarAmount} \to \text{EuroAmount}
  $$

- **欧元到美元：**

  $$
  \begin{align*}
  \text{euros2dollars} =\ & \lambda e: \text{EuroAmount}. \\
  & \text{case } e \ \text{of} \ \langle \text{euros} = x \rangle \Rightarrow \\
  & \quad \langle \text{dollars} = \text{timesfloat } x\ 0.883 \rangle \ \text{as} \ \text{DollarAmount};
  \end{align*}
  $$

  $$
  \vdash \text{euros2dollars} : \text{EuroAmount} \to \text{DollarAmount}
  $$

- **使用这些函数：**

  $$
  \text{mybankbalance} = \langle \text{dollars} = 39.50 \rangle \ \text{as} \ \text{DollarAmount};
  $$

  $$
  \text{euros2dollars} \ (\text{dollars2euros} \ \text{mybankbalance});
  $$

  $$
  \vdash \langle \text{dollars} = 39.49990125 \rangle \ \text{as} \ \text{DollarAmount} : \text{DollarAmount}
  $$

  - 类型系统确保了货币转换的正确性。
  - 如果尝试错误的使用，例如连续两次将美元转换为欧元，会导致类型错误：

    $$
    \text{dollars2euros} \ (\text{dollars2euros} \ \text{mybankbalance});
    $$

    $$
    \vdash \text{Error: parameter type mismatch}
    $$

**益处：**

- 防止混淆底层类型相同但含义不同的值。
- 类型系统在不增加运行时开销的情况下强制执行正确的使用。

---

**变体与数据类型（Variants vs. Datatypes）**

变体与像 ML 语言中的数据类型类似，但也有显著的区别。

**ML 数据类型的等价形式：**

```ocaml
type T = l1 of T1
       | l2 of T2
       | ...
       | ln of Tn
```

**区别：**

1. **大小写约定：**

   - 在 OCaml 中，类型以小写字母开头，构造器（标签）以大写字母开头。
   - 为了清晰起见，我们可以忽略这一点，使用我们自己的约定。

2. **类型注解：**

   - OCaml 在使用构造器构造值时，不需要类型注解。
   - 由于标签在数据类型内是唯一的，因此类型可以被推断。
   - 在我们的变体系统中，我们需要在标记值时指定类型。

3. **省略 $\text{Unit}$ 类型：**

   - 当 OCaml 中的构造器类型为 $\text{Unit}$ 时，可以省略 $\text{of Unit}$ 部分。
   - 这简化了枚举类型的定义。

4. **OCaml 数据类型的附加特性：**

   - **递归类型：**
     - 数据类型可以是递归的，允许像列表这样的定义。
     - 示例：

       ```ocaml
       type NatList = nil
                    | cons of Nat * NatList
       ```

   - **参数化类型：**
     - 数据类型可以在类型变量上参数化。
     - 示例：

       ```ocaml
       type 'a List = nil
                    | cons of 'a * 'a List
       ```

     - 这里的 $'a$ 是一个类型变量，允许定义任意类型的列表。

---

**变体作为不交并（Variants as Disjoint Unions）**

变体和和类型通常被称为**不交并**，因为它们将多个类型组合为一个，同时通过标记保持它们的区别。

- **不交并**：组合的类型包括来自各个类型的所有元素，但它们被标记以指示其来源。
- **标记的目的**：确保来自不同类型的值不会被混淆。
- **联合类型（Union Types）**：相比之下，联合类型（如第 15.7 节所述）可能在没有标记的情况下组合类型，可能导致潜在的歧义。

---

**动态类型（Type Dynamic）**

在静态类型语言中，有些情况下数据的类型在编译时无法确定，例如处理外部数据源或进程间通信时。

- **动态类型**：可以引入一个特殊的类型 $\text{Dynamic}$，其值是一个值与其类型标签的对，即 $(v, T)$，其中 $v : T$。
- **类型判断构造（Typecase Constructs）**：这些允许在运行时以类型安全的方式检查 $\text{Dynamic}$ 值的类型。
- **无限不交并**：$\text{Dynamic}$ 类型可以被视为一个无限的变体类型，每个可能的类型作为一个标签。

---

**11.11 通用递归（General Recursion）**

递归允许函数调用自身，能够定义复杂的计算，如阶乘或斐波那契数。

**Fix 组合子：**

- 在无类型的 $\lambda$ 演算中，使用 $\text{fix}$ 组合子实现递归。
- 在类型化的环境中，$\text{fix}$ 不能作为一个项来定义，因为类型限制，所以将其作为一个原语引入。

**使用 $\text{fix}$ 定义递归函数：**

- **函数生成器 $ff$：**

  $$
  \begin{align*}
  ff =\ & \lambda ie: \text{Nat} \to \text{Bool}. \\
  & \lambda x: \text{Nat}. \\
  & \quad \text{if } \text{iszero } x\ \text{then } \text{true} \\
  & \quad \text{else if } \text{iszero } (\text{pred } x)\ \text{then } \text{false} \\
  & \quad \text{else } ie\ (\text{pred } (\text{pred } x));
  \end{align*}
  $$

  $$
  \vdash ff : (\text{Nat} \to \text{Bool}) \to \text{Nat} \to \text{Bool}
  $$

  - $ff$ 是一个高阶函数，给定 $\text{iseven}$ 函数的一个近似 $ie$，返回一个更好的近似。

- **使用 $\text{fix}$ 定义 $\text{iseven}$：**

  $$
  \text{iseven} = \text{fix } ff;
  $$

  $$
  \vdash \text{iseven} : \text{Nat} \to \text{Bool}
  $$

  - $\text{fix } ff$ 计算 $ff$ 的不动点，得到完全定义的 $\text{iseven}$ 函数。

- **使用 $\text{iseven}$：**

  $$
  \text{iseven}\ 7;
  $$

  $$
  \vdash \text{false} : \text{Bool}
  $$

**直觉：**

- $\text{fix}$ 操作符找到一个点，在该点上将函数应用于自身会产生相同的函数，有效地捕获了递归。

**$\text{fix}$ 的形式化定义（图 11-12）：**

**图 11-12：通用递归**

**新的语法形式：**

- **项（$t$）：**

  $$
  t ::= \ldots \ |\ \text{fix } t
  $$

  - $\text{fix } t$ 表示 $t$ 的不动点。

**新的求值规则（$t \to t'$）：**

1. **（E-FixBeta）：**

   $$
   \frac{}{\text{fix } (\lambda x: T1.\ t2) \to [x \mapsto \text{fix } (\lambda x: T1.\ t2)]\ t2}
   $$

   - $\text{fix}$ 作用于一个 lambda 抽象时，通过将自身替换到其主体中来化简。

2. **（E-Fix）：**

   $$
   \frac{t_1 \to t_1'}{\text{fix } t_1 \to \text{fix } t_1'}
   $$

   - 如果 $t_1$ 可以求值到 $t_1'$，那么 $\text{fix } t_1$ 求值到 $\text{fix } t_1'$。

**新的类型规则（$\Gamma \vdash t : T$）：**

- **（T-Fix）：**

  $$
  \frac{\Gamma \vdash t_1 : T1 \to T1}{\Gamma \vdash \text{fix } t_1 : T1}
  $$

  - 如果 $t_1$ 是从 $T1$ 到 $T1$ 的函数，那么 $\text{fix } t_1$ 的类型为 $T1$。

**派生形式：**

- **$\text{letrec}$：**

  $$
  \text{letrec } x: T1 = t1\ \text{in}\ t2 \equiv \text{let } x = \text{fix } (\lambda x: T1.\ t1)\ \text{in}\ t2
  $$

  - 为递归绑定提供了方便的语法。

---

**练习 11.11.1：** 使用 $\text{fix}$ 定义 $\text{equal}$、$\text{plus}$、$\text{times}$ 和 $\text{factorial}$。

**解答：**

1. **定义 $\text{equal}$：**

   $$
   \begin{align*}
   \text{equal} =\ & \text{fix } (\lambda eq: \text{Nat} \to \text{Nat} \to \text{Bool}. \\
   & \quad \lambda n: \text{Nat}. \lambda m: \text{Nat}. \\
   & \quad \text{if } \text{iszero } n\ \text{then } \text{iszero } m \\
   & \quad \text{else if } \text{iszero } m\ \text{then } \text{false} \\
   & \quad \text{else } eq\ (\text{pred } n)\ (\text{pred } m));
   \end{align*}
   $$

   $$
   \vdash \text{equal} : \text{Nat} \to \text{Nat} \to \text{Bool}
   $$

   - 递归比较两个自然数是否相等。

2. **定义 $\text{plus}$：**

   $$
   \begin{align*}
   \text{plus} =\ & \text{fix } (\lambda pl: \text{Nat} \to \text{Nat} \to \text{Nat}. \\
   & \quad \lambda n: \text{Nat}. \lambda m: \text{Nat}. \\
   & \quad \text{if } \text{iszero } n\ \text{then } m \\
   & \quad \text{else } \text{succ } (pl\ (\text{pred } n)\ m));
   \end{align*}
   $$

   $$
   \vdash \text{plus} : \text{Nat} \to \text{Nat} \to \text{Nat}
   $$

   - 递归地将两个自然数相加。

3. **定义 $\text{times}$：**

   $$
   \begin{align*}
   \text{times} =\ & \text{fix } (\lambda tm: \text{Nat} \to \text{Nat} \to \text{Nat}. \\
   & \quad \lambda n: \text{Nat}. \lambda m: \text{Nat}. \\
   & \quad \text{if } \text{iszero } n\ \text{then } 0 \\
   & \quad \text{else } \text{plus } m\ (tm\ (\text{pred } n)\ m));
   \end{align*}
   $$

   $$
   \vdash \text{times} : \text{Nat} \to \text{Nat} \to \text{Nat}
   $$

   - 使用递归加法来乘两个自然数。

4. **定义 $\text{factorial}$：**

   $$
   \begin{align*}
   \text{factorial} =\ & \text{fix } (\lambda fac: \text{Nat} \to \text{Nat}. \\
   & \quad \lambda n: \text{Nat}. \\
   & \quad \text{if } \text{iszero } n\ \text{then } 1 \\
   & \quad \text{else } \text{times } n\ (fac\ (\text{pred } n)));
   \end{align*}
   $$

   $$
   \vdash \text{factorial} : \text{Nat} \to \text{Nat}
   $$

   - 递归地计算一个自然数的阶乘。

---

**使用 $\text{letrec}$ 定义递归函数：**

**练习 11.11.2：** 使用 $\text{letrec}$ 重写你在练习 11.11.1 中的 $\text{plus}$、$\text{times}$ 和 $\text{factorial}$ 定义。

**解答：**

1. **使用 $\text{letrec}$ 定义 $\text{plus}$：**

   $$
   \text{letrec } \text{plus}: \text{Nat} \to \text{Nat} \to \text{Nat} = \\
   \quad \lambda n: \text{Nat}. \lambda m: \text{Nat}. \\
   \quad \text{if } \text{iszero } n\ \text{then } m \\
   \quad \text{else } \text{succ } (\text{plus}\ (\text{pred } n)\ m) \\
   \text{in} \ \ldots
   $$

   - 可以在需要的地方使用 $\text{plus}$。

2. **使用 $\text{letrec}$ 定义 $\text{times}$：**

   $$
   \text{letrec } \text{times}: \text{Nat} \to \text{Nat} \to \text{Nat} = \\
   \quad \lambda n: \text{Nat}. \lambda m: \text{Nat}. \\
   \quad \text{if } \text{iszero } n\ \text{then } 0 \\
   \quad \text{else } \text{plus } m\ (\text{times}\ (\text{pred } n)\ m) \\
   \text{in} \ \ldots
   $$

3. **使用 $\text{letrec}$ 定义 $\text{factorial}$：**

   $$
   \text{letrec } \text{factorial}: \text{Nat} \to \text{Nat} = \\
   \quad \lambda n: \text{Nat}. \\
   \quad \text{if } \text{iszero } n\ \text{then } 1 \\
   \quad \text{else } \text{times } n\ (\text{factorial}\ (\text{pred } n)) \\
   \text{in} \ \ldots
   $$

   - 使用 $\text{letrec}$ 简化了定义，使其更易读。

---

**11.12 列表（Lists）**

列表是一种基本的数据结构，表示元素的序列。

**定义列表：**

- 对于任何类型 $T$，$\text{List}\ T$ 是包含类型为 $T$ 的元素的列表类型。

**图 11-13：列表**

**新的语法形式：**

- **项（$t$）：**

  $$
  t ::= \ldots\ |\ \text{nil}[T]\ |\ \text{cons}[T]\ t\ t\ |\ \text{isnil}[T]\ t\ |\ \text{head}[T]\ t\ |\ \text{tail}[T]\ t
  $$

  - $\text{nil}[T]$：类型为 $\text{List}\ T$ 的空列表。
  - $\text{cons}[T]\ t_1\ t_2$：通过将元素 $t_1$ 添加到列表 $t_2$ 的前面来构造列表。
  - $\text{isnil}[T]\ t$：检查列表 $t$ 是否为空。
  - $\text{head}[T]\ t$：获取列表 $t$ 的第一个元素。
  - $\text{tail}[T]\ t$：获取去掉第一个元素的列表 $t$。

- **值（$v$）：**

  $$
  v ::= \ldots\ |\ \text{nil}[T]\ |\ \text{cons}[T]\ v\ v
  $$

  - 值包括空列表和由值构造的列表。

- **类型（$T$）：**

  $$
  T ::= \ldots\ |\ \text{List}\ T
  $$

  - $\text{List}\ T$ 表示元素类型为 $T$ 的列表类型。

**新的求值规则（$t \to t'$）：**

1. **构造列表：**

   - **（E-Cons1）：**

     $$
     \frac{t_1 \to t_1'}{\text{cons}[T]\ t_1\ t_2 \to \text{cons}[T]\ t_1'\ t_2}
     $$

   - **（E-Cons2）：**

     $$
     \frac{t_2 \to t_2'}{\text{cons}[T]\ v_1\ t_2 \to \text{cons}[T]\ v_1\ t_2'}
     $$

2. **检查空列表：**

   - **（E-IsnilNil）：**

     $$
     \frac{}{\text{isnil}[S]\ (\text{nil}[T]) \to \text{true}}
     $$

   - **（E-IsnilCons）：**

     $$
     \frac{}{\text{isnil}[S]\ (\text{cons}[T]\ v_1\ v_2) \to \text{false}}
     $$

   - **（E-Isnil）：**

     $$
     \frac{t_1 \to t_1'}{\text{isnil}[T]\ t_1 \to \text{isnil}[T]\ t_1'}
     $$

3. **访问列表元素：**

   - **（E-HeadCons）：**

     $$
     \frac{}{\text{head}[S]\ (\text{cons}[T]\ v_1\ v_2) \to v_1}
     $$

   - **（E-Head）：**

     $$
     \frac{t_1 \to t_1'}{\text{head}[T]\ t_1 \to \text{head}[T]\ t_1'}
     $$

   - **（E-TailCons）：**

     $$
     \frac{}{\text{tail}[S]\ (\text{cons}[T]\ v_1\ v_2) \to v_2}
     $$

   - **（E-Tail）：**

     $$
     \frac{t_1 \to t_1'}{\text{tail}[T]\ t_1 \to \text{tail}[T]\ t_1'}
     $$

**新的类型规则（$\Gamma \vdash t : T$）：**

1. **（T-Nil）：**

   $$
   \frac{}{\Gamma \vdash \text{nil}[T1] : \text{List}\ T1}
   $$

2. **（T-Cons）：**

   $$
   \frac{\Gamma \vdash t_1 : T1 \quad \Gamma \vdash t_2 : \text{List}\ T1}{\Gamma \vdash \text{cons}[T1]\ t_1\ t_2 : \text{List}\ T1}
   $$

3. **（T-Isnil）：**

   $$
   \frac{\Gamma \vdash t_1 : \text{List}\ T11}{\Gamma \vdash \text{isnil}[T11]\ t_1 : \text{Bool}}
   $$

4. **（T-Head）：**

   $$
   \frac{\Gamma \vdash t_1 : \text{List}\ T11}{\Gamma \vdash \text{head}[T11]\ t_1 : T11}
   $$

5. **（T-Tail）：**

   $$
   \frac{\Gamma \vdash t_1 : \text{List}\ T11}{\Gamma \vdash \text{tail}[T11]\ t_1 : \text{List}\ T11}
   $$

---

**练习 11.12.1：** 验证对于带有布尔类型和列表的简单类型 $\lambda$ 演算，进展（Progress）和保持（Preservation）定理成立。

**解答：**

- **进展定理**：每个良类型的项要么是一个值，要么可以根据求值规则进行一步求值。

  - 对于列表，我们需要证明像 $\text{cons}$、$\text{isnil}$、$\text{head}$ 和 $\text{tail}$ 这样的操作满足进展性质。
  - 由于求值规则涵盖了列表的所有可能形式，且类型规则确保项是良构的，因此进展定理成立。

- **保持定理**：如果一个良类型的项 $t$ 类型为 $T$，且 $t \to t'$，那么 $t'$ 也具有类型 $T$。

  - 我们验证每个求值规则都保持类型。
  - 例如，在（E-Cons1）中，如果 $\text{cons}[T]\ t_1\ t_2$ 类型为 $\text{List}\ T$，且 $t_1 \to t_1'$，那么 $t_1'$ 类型为 $T$，因此 $\text{cons}[T]\ t_1'\ t_2$ 仍然类型为 $\text{List}\ T$。

---

**练习 11.12.2：** 这里的列表表示包含了许多不必要的类型注解，因为类型规则可以很容易地从上下文中推导出这些注解。是否可以删除所有的类型注解？

**解答：**

- 并非所有类型注解都可以删除，但许多都可以被推断。
- 例如，在 $\text{cons}\ t_1\ t_2$ 中，如果我们知道 $t_2$ 的类型是 $\text{List}\ T1$，那么 $t_1$ 必须类型为 $T1$，因此 $\text{cons}\ t_1\ t_2$ 类型为 $\text{List}\ T1$。
- 然而，在像 $\text{nil}[T]$ 这样的情况下，我们需要指定类型 $T$，因为单独的 $\text{nil}$ 不提供足够的信息。
- 类似地，在函数中，如果元素的类型无法从上下文中清楚地得知，则需要类型注解。

---

**结论**

变体和列表是类型系统中强大的构造，允许对具有不同结构的数据进行灵活而安全的操作。通过有效地使用标签和类型，我们可以利用类型系统来防止错误，并编写更健壮的程序。

**进一步阅读：**

- 关于不动点算子和递归的更多信息，参见 Klop（1980）和 Winskel（1993）。
- 类型算子和高级类型系统特性将在第 29 章讨论。

### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------
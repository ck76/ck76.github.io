[toc]



### 第14章 异常（Exceptions）

在第13章中，我们看到了如何使用可变引用扩展纯简单类型 $\lambda$ 演算的简单操作语义，并考虑了这种扩展对类型规则和类型安全性证明的影响。在本章中，我们将处理对我们原始计算模型的另一种扩展：**引发和处理异常**（raising and handling exceptions）。

现实世界的编程充满了这样一些情况：函数需要向其调用者发出信号，表示由于某种原因它无法完成任务——可能是因为某个计算将涉及除以零或算术溢出（arithmetic overflow），一个查找键在字典中丢失，数组索引越界，文件无法找到或打开，发生了某些灾难性事件，例如系统内存不足或用户终止了进程，等等。

其中一些异常情况可以通过让函数返回一个变体（variant）或选项（option）来表示，正如我们在第11.10节中看到的。但是在异常情况确实异常的情况下，我们可能不想强制我们的函数的每个调用者都处理它们可能发生的可能性。相反，我们可能更希望异常情况导致直接控制转移到程序中某个更高级别定义的异常处理程序——或者确实（如果异常情况足够罕见，或者调用者无论如何都无法从中恢复），直接终止程序。我们首先考虑后一种情况（第14.1节），即异常是整个程序的中止，然后添加一种机制来捕获并从异常中恢复（第14.2节），最后改进这两种机制，以允许在异常发生地和处理程序之间传递额外的程序员指定的数据（第14.3节）。

本章研究的系统是带有各种异常和异常处理原语（见图14-1和14-2）的简单类型 $\lambda$ 演算（图9-1）。

- **OCaml 实现**：第一个扩展的 OCaml 实现是 `fullerror`。带有携带值的异常的语言（图14-3）未实现。

---

### 14.1 引发异常（Raising Exceptions）

让我们从通过最简单的机制丰富简单类型 $\lambda$ 演算开始，用于信号异常：一个项 `error`，当被求值时，完全中止其出现的项的求值。**图14-1** 详细列出了所需的扩展。

#### 图14-1：错误（Errors）

**→ error** 扩展了 $\lambda \to$（图9-1）

- **新的语法形式**：

  $$
  \begin{align*}
  t ::= \quad & \ldots & \text{项（terms）} \\
  & \text{error} & \text{运行时错误（run-time error）}
  \end{align*}
  $$

- **新的求值规则** $t \to t'$：

  - **（E-AppErr1）**：

    $$
    \text{error}\ t_2 \to \text{error}
    $$

  - **（E-AppErr2）**：

    $$
    v_1\ \text{error} \to \text{error}
    $$

- **新的类型规则** $\Gamma \vdash t : T$：

  - **（T-Error）**：

    $$
    \Gamma \vdash \text{error} : T
    $$

---

#### 设计和解释

在为 `error` 编写规则时，主要的设计决策是如何在我们的操作语义中形式化“异常终止”。我们采用简单的权宜之计，让 `error` 本身成为程序中止的结果。规则 **E-AppErr1** 和 **E-AppErr2** 捕捉了这种行为。

- **（E-AppErr1）**：

  $$
  \text{error}\ t_2 \to \text{error}
  $$

  该规则表示，如果我们在尝试将应用（application）的左侧归约为值的过程中遇到项 `error`，我们应立即将 `error` 作为应用的结果。

- **（E-AppErr2）**：

  $$
  v_1\ \text{error} \to \text{error}
  $$

  该规则表示，如果我们在尝试将应用的参数（右侧）归约为值的过程中遇到 `error`，我们应放弃对该应用的工作，并立即返回 `error`。

注意，我们并未将 `error` 包含在值的语法中——它仅在项的语法中。这保证了 **E-AppAbs** 和 **E-AppErr2** 规则的左侧永远不会重叠——即，对于我们是否应该对项

$$
(\lambda x:\text{Nat}.\ 0)\ \text{error}
$$

执行应用（从而产生结果 `0`）或中止，没有歧义：只有后者是可能的。同样，我们在 **E-AppErr2** 中使用了元变量 $v_1$（而不是表示任意项的 $t_1$），这迫使求值器在中止之前等待应用的左侧被归约为值，即使右侧是 `error`。因此，像

$$
(\text{fix}\ (\lambda x:\text{Nat}.\ x))\ \text{error}
$$

这样的项将会发散（diverge）而不是中止。这些条件确保了求值关系仍然是确定性的。

**类型规则 T-Error** 也很有趣。由于我们可能希望在任何上下文中引发异常，`error` 形式被允许具有任何类型。

- **（T-Error）**：

  $$
  \Gamma \vdash \text{error} : T
  $$

例如，在

$$
(\lambda x:\text{Bool}.\ x)\ \text{error};
$$

中，它具有类型 `Bool`。在

$$
(\lambda x:\text{Bool}.\ x)\ (\text{error}\ \text{true});
$$

中，它具有类型 `\text{Bool} \to \text{Bool}`。

这种 `error` 类型的灵活性在实现类型检查算法时会引发一些困难，因为它打破了语言中每个可类型化的项都有唯一类型的性质（定理9.3.3）。这可以通过各种方式处理。在具有子类型的语言中，我们可以将 `error` 分配最小类型 `Bot`（参见第15.4节），必要时可以将其提升为任何其他类型。在具有参数化多态性的语言中（参见第23章），我们可以给 `error` 多态类型 $\forall X.\ X$，它可以实例化为任何其他类型。这两个技巧都允许将 `error` 的无限多种可能类型紧凑地表示为单个类型。

**练习 14.1.1** [«]：将 `error` 的预期类型在每个使用它的上下文中要求程序员进行注释，不会更简单吗？

**解答**：

- 是的，这可能会更简单。如果程序员在每次使用 `error` 时显式地注释其预期的类型，那么类型检查器就不需要推断 `error` 的类型，也避免了类型唯一性的问题。

---

类型保持性质对于带有异常的语言与往常一样：如果一个项具有类型 $T$，并且我们让它求值一步，结果仍然具有类型 $T$。然而，进展性质需要稍微调整一下。它的原始形式说，良类型的程序必须求值为一个值（或发散）。但现在我们引入了一个非值的正常形式（normal form），即 `error`，它当然可以是良类型程序的求值结果。我们需要重新陈述进展性质以允许这种情况。

**定理 14.1.2 [进展（Progress）]**：假设 $t$ 是一个闭合的、良类型的正常形式。那么要么 $t$ 是一个值，要么 $t = \text{error}$。

---

### 14.2 处理异常（Handling Exceptions）

对 `error` 的求值规则可以被认为是“展开调用栈”（unwinding the call stack），丢弃挂起的函数调用，直到 `error` 一直传播到顶层。在带有异常的语言的实际实现中，这正是发生的情况：调用栈由一组活动记录（activation records）组成，每个活动的函数调用一个；引发异常会导致活动记录从调用栈中弹出，直到它变为空。

在大多数带有异常的语言中，还可以在调用栈中安装异常处理程序。当引发异常时，活动记录从调用栈中弹出，直到遇到异常处理程序，然后求值继续在该处理程序处进行。换句话说，异常充当一种非本地的控制转移，其目标是最近安装的异常处理程序（即，调用栈中最近的一个）。

我们对异常处理程序的表述，概括在**图14-2** 中，与 ML 和 Java 都类似。表达式 `try t1 with t2` 的含义是“返回对 $t1$ 的求值结果，除非它中止，在这种情况下，改为求值处理程序 $t2$”。

#### 图14-2：错误处理（Error handling）

**→ error try** 扩展了 $\lambda \to$，添加了错误（14-1）

- **新的语法形式**：

  $$
  \begin{align*}
  t ::= \quad & \ldots & \text{项（terms）} \\
  & \text{try } t\ \text{with } t & \text{捕获错误（trap errors）}
  \end{align*}
  $$

- **新的求值规则** $t \to t'$：

  - **（E-TryV）**：

    $$
    \text{try } v_1\ \text{with } t_2 \to v_1
    $$

    当 $t_1$ 已经被归约为值 $v_1$ 时，我们可以丢弃 `try`，因为我们现在知道它不再需要。

  - **（E-TryError）**：

    $$
    \text{try }\ \text{error}\ \text{with } t_2 \to t_2
    $$

    这条规则表示，如果对 $t_1$ 的求值结果是 `error`，那么我们应该用 $t_2$ 替换整个 `try`，并从那里继续求值。

  - **（E-Try）**：

    $$
    \frac{t_1 \to t_1'}{\text{try } t_1\ \text{with } t_2 \to \text{try } t_1'\ \text{with } t_2}
    $$

    该规则表示，在 $t_1$ 被归约为值或 `error` 之前，我们应继续对其进行求值，并保持 $t_2$ 不变。

- **新的类型规则** $\Gamma \vdash t : T$：

  - **（T-Try）**：

    $$
    \frac{\Gamma \vdash t_1 : T \quad \Gamma \vdash t_2 : T}{\Gamma \vdash \text{try } t_1\ \text{with } t_2 : T}
    $$

---

#### 解释

**求值规则**

- **E-TryV**：当 `try` 的主体 $t_1$ 已经归约为值 $v_1$，我们可以丢弃 `try`，因为异常不会发生，结果就是 $v_1$。

- **E-TryError**：如果在求值 $t_1$ 时结果是 `error`，则将整个 `try` 替换为处理程序 $t_2$，继续从那里求值。

- **E-Try**：在 $t_1$ 还未归约为值或 `error` 之前，我们继续对 $t_1$ 进行求值。

**类型规则**

- **T-Try**：`try t_1 with t_2` 的结果可以是主体 $t_1$ 的结果，或者是处理程序 $t_2$ 的结果；我们需要要求它们具有相同的类型 $T$，这也是整个 `try` 表达式的类型。

类型安全性属性及其证明与前一节基本相同。

---

### 14.3 携带值的异常（Exceptions Carrying Values）

在第14.1节和第14.2节中引入的机制允许函数向其调用者发出信号，表示“发生了一些不寻常的事情”。通常，发送一些关于发生了什么不寻常事情的额外信息是有用的，因为处理程序需要采取的行动——要么恢复并重试，要么向用户呈现可理解的错误消息——可能取决于这些信息。

**图14-3** 显示了如何丰富我们的基本异常处理构造，使得每个异常都携带一个值。该值的类型记为 $\text{Texn}$。目前，我们对该类型的具体性质保持开放；下面我们将讨论几种替代方案。

#### 图14-3：携带值的异常（Exceptions carrying values）

**→ exceptions** 扩展了 $\lambda \to$（图9-1）

- **新的语法形式**：

  $$
  \begin{align*}
  t ::= \quad & \ldots & \text{项（terms）} \\
  & \text{raise } t & \text{引发异常（raise exception）} \\
  & \text{try } t\ \text{with } t & \text{处理异常（handle exceptions）}
  \end{align*}
  $$

- **新的求值规则** $t \to t'$：

  - **（E-AppRaise1）**：

    $$
    (\text{raise } v_{11})\ t_2 \to \text{raise } v_{11}
    $$

  - **（E-AppRaise2）**：

    $$
    v_1\ (\text{raise } v_{21}) \to \text{raise } v_{21}
    $$

  - **（E-Raise）**：

    $$
    \frac{t_1 \to t_1'}{\text{raise } t_1 \to \text{raise } t_1'}
    $$

  - **（E-RaiseRaise）**：

    $$
    \text{raise } (\text{raise } v_{11}) \to \text{raise } v_{11}
    $$

  - **（E-TryV）**：

    $$
    \text{try } v_1\ \text{with } t_2 \to v_1
    $$

  - **（E-TryRaise）**：

    $$
    \text{try } (\text{raise } v_{11})\ \text{with } t_2 \to t_2\ v_{11}
    $$

  - **（E-Try）**：

    $$
    \frac{t_1 \to t_1'}{\text{try } t_1\ \text{with } t_2 \to \text{try } t_1'\ \text{with } t_2}
    $$

- **新的类型规则** $\Gamma \vdash t : T$：

  - **（T-Exn）**：

    $$
    \frac{\Gamma \vdash t_1 : \text{Texn}}{\Gamma \vdash \text{raise } t_1 : T}
    $$

  - **（T-Try）**：

    $$
    \frac{\Gamma \vdash t_1 : T \quad \Gamma \vdash t_2 : \text{Texn} \to T}{\Gamma \vdash \text{try } t_1\ \text{with } t_2 : T}
    $$

---

#### 解释

**求值规则**

- **E-AppRaise1** 和 **E-AppRaise2**：这两条规则类似于图14-1中的 **E-AppErr1** 和 **E-AppErr2**，它们通过应用程序传播异常。

  - **E-AppRaise1**：

    $$
    (\text{raise } v_{11})\ t_2 \to \text{raise } v_{11}
    $$

    如果在函数位置（左侧）有一个 `raise` 表达式，则整个应用直接变为 `raise`。

  - **E-AppRaise2**：

    $$
    v_1\ (\text{raise } v_{21}) \to \text{raise } v_{21}
    $$

    如果在参数位置（右侧）有一个 `raise` 表达式，同样，整个应用直接变为 `raise`。

- **E-Raise**：如果 `raise` 的附加信息 $t_1$ 还需要求值，我们需要首先对 $t_1$ 求值。

  $$
  \frac{t_1 \to t_1'}{\text{raise } t_1 \to \text{raise } t_1'}
  $$

- **E-RaiseRaise**：处理在评估要在另一个异常中发送的附加信息时可能发生的异常。

  $$
  \text{raise } (\text{raise } v_{11}) \to \text{raise } v_{11}
  $$

- **E-TryV**：当 `try` 的主体 $t_1$ 已经归约为值 $v_1$，我们可以丢弃 `try`，结果就是 $v_1$。

  $$
  \text{try } v_1\ \text{with } t_2 \to v_1
  $$

- **E-TryRaise**：如果 `t_1` 求值为 `raise v_{11}`，则将异常的附加信息 $v_{11}$ 传递给处理程序 $t_2$。

  $$
  \text{try } (\text{raise } v_{11})\ \text{with } t_2 \to t_2\ v_{11}
  $$

- **E-Try**：在 $t_1$ 被归约为值或 `raise` 之前，我们继续对 $t_1$ 进行求值。

  $$
  \frac{t_1 \to t_1'}{\text{try } t_1\ \text{with } t_2 \to \text{try } t_1'\ \text{with } t_2}
  $$

**类型规则**

- **（T-Exn）**：

  $$
  \frac{\Gamma \vdash t_1 : \text{Texn}}{\Gamma \vdash \text{raise } t_1 : T}
  $$

  我们要求附加信息 $t_1$ 具有类型 $\text{Texn}$；整个 `raise` 表达式可以被赋予上下文所需的任何类型 $T$。

- **（T-Try）**：

  $$
  \frac{\Gamma \vdash t_1 : T \quad \Gamma \vdash t_2 : \text{Texn} \to T}{\Gamma \vdash \text{try } t_1\ \text{with } t_2 : T}
  $$

  我们检查处理程序 $t_2$ 是一个函数，给定类型为 $\text{Texn}$ 的附加信息，产生与 $t_1$ 相同类型 $T$ 的结果。

---

#### Texn 类型的替代方案

最后，让我们考虑 $\text{Texn}$ 类型的一些替代方案。

1. **将 $\text{Texn}$ 定义为 `Nat`**：

   - 这对应于 Unix 操作系统函数中使用的 `errno` 约定：每个系统调用返回一个数字“错误代码”，其中 0 表示成功，其他值报告各种异常情况。

2. **将 $\text{Texn}$ 定义为 `String`**：

   - 这避免了在表中查找错误号码，并允许异常引发点在需要时构建更具描述性的消息。额外灵活性的代价是错误处理程序现在可能需要解析这些字符串以找出发生了什么。

3. **将 $\text{Texn}$ 定义为变体类型（variant type）**：

   - 定义：

     $$
     \text{Texn} = \langle \text{divideByZero} : \text{Unit},\ \text{overflow} : \text{Unit},\ \text{fileNotFound} : \text{String},\ \text{fileNotReadable} : \text{String},\ \ldots \rangle
     $$

   - 这种方案允许处理程序使用简单的 `case` 表达式来区分异常的种类。此外，不同的异常可以携带不同类型的附加信息：像 `divideByZero` 这样的异常不需要额外的信息，`fileNotFound` 可以携带一个字符串，指示发生错误时正在打开的文件，等等。

   - **问题**：这种替代方案相当不灵活，要求我们预先确定任何程序可以引发的异常的完整集合（即变体类型 $\text{Texn}$ 的标签集合）。这为程序员声明特定于应用程序的异常留下了余地。

4. **将 $\text{Texn}$ 定义为可扩展的变体类型**：

   - 这种想法可以被改进，通过将 $\text{Texn}$ 定义为可扩展的变体类型，为用户定义的异常留出空间。ML 采用了这个想法，提供了一个称为 `exn` 的单个可扩展变体类型。

   - 在当前设置中，ML 中的声明 `exception l of T` 可以理解为：“确保 $l$ 与 $\text{Texn}$ 中已存在的任何标签不同，并且从现在开始让 $\text{Texn}$ 为 $\langle l_1 : T_1, \ldots, l_n : T_n, l : T \rangle$，其中 $l_1 : T_1$ 到 $l_n : T_n$ 是此声明之前的可能变体。”

   - **注意**：由于 `exception` 形式是一个绑定者，我们可以通过必要时对 $l$ 进行 $\alpha$-转换来确保它与 $\text{Texn}$ 中已使用的标签不同。

   - **引发异常的语法**：

     在 ML 中，引发异常的语法是 `raise l(t)`，其中 $l$ 是在当前作用域中定义的异常标签。这可以理解为标签操作符和我们的简单 `raise` 的组合：

     $$
     \text{raise } l(t) \quad \text{定义为} \quad \text{raise } (\langle l = t \rangle \text{ as } \text{Texn})
     $$

   - **异常处理的语法**：

     类似地，ML 中的 `try` 构造可以使用我们的简单 `try` 加上 `case` 来消糖（desugar）：

     $$
     \begin{align*}
     \text{try } t\ \text{with } l(x) \to h &\quad \text{定义为} \\
     \text{try } t\ \text{with } \lambda e:\text{Texn}.\ \text{case } e\ \text{of} \\
     &\quad \langle l = x \rangle \Rightarrow h \\
     &\quad | \_ \Rightarrow \text{raise } e
     \end{align*}
     $$

   - 该 `case` 检查已引发的异常是否带有标签 $l$。如果是，它将异常携带的值绑定到变量 $x$ 并求值处理程序 $h$。如果不是，它将通过 `else` 子句，重新引发异常。异常将继续传播（并可能被捕获和重新引发），直到它要么到达想要处理它的处理程序，要么到达顶层并中止整个程序。

5. **Java 的做法**：

   - Java 使用类而不是可扩展的变体来支持用户定义的异常。语言提供了一个内置类 `Throwable`；`Throwable` 或其任何子类的实例都可以在 `throw`（与我们的 `raise` 相同）或 `try...catch`（与我们的 `try...with` 相同）语句中使用。新的异常可以简单地通过定义 `Throwable` 的新子类来声明。

   - 实际上，这种异常处理机制与 ML 的机制之间存在密切的对应关系。大致来说，Java 中的异常对象在运行时由指示其类的标签（对应于 ML 中的可扩展变体标签）加上一组实例变量的记录（对应于由该标签标记的额外信息）来表示。

   - Java 异常在几个方面比 ML 更进一步。一方面是异常标签上有一个自然的偏序关系，由子类顺序生成。异常标签 $l$ 的处理程序实际上将捕获所有携带类 $l$ 或 $l$ 的任何子类的对象的异常。

   - 另一方面是 Java 区分了异常（`Exception` 的子类——`Throwable` 的子类），应用程序可能希望捕获并尝试恢复，以及错误（`Error` 的子类——也是 `Throwable` 的子类），指示严重的情况，通常应该终止执行。两者之间的关键区别在于类型检查规则，它要求方法显式地声明它们可能引发的异常（但不需要声明可能引发的错误）。

---

**练习 14.3.1** [«««]：上述替代方案4中对可扩展变体类型的解释相当非正式。展示如何使其精确。

**解答**：

- 我们需要正式地定义可扩展变体类型的语法和类型规则。

- 首先，我们引入一种机制，允许我们在类型系统中动态地扩展变体类型 $\text{Texn}$。

- 定义一个初始的异常类型 $\text{Texn}_0$，它可能是空的或包含一些基本的异常标签。

- 每当我们声明一个新的异常时，例如 `exception l of T`，我们将类型 $\text{Texn}$ 扩展为包含新的标签：

  $$
  \text{Texn}_{n+1} = \text{Texn}_n + \langle l : T \rangle
  $$

- 在类型系统中，我们需要确保在类型检查时知道当前的异常类型包含哪些标签。这可能需要类型环境中携带异常类型的信息。

- 我们需要定义引发异常和处理异常的类型规则，使其依赖于当前的异常类型。

- **引发异常的类型规则**：

  $$
  \frac{\Gamma \vdash t : T \quad l : T \in \text{Texn}}{\Gamma \vdash \text{raise } l(t) : S}
  $$

  - 其中 $l : T$ 是当前异常类型中的标签，$S$ 是任意类型。

- **处理异常的类型规则**：

  $$
  \frac{\Gamma \vdash t_1 : S \quad \Gamma \vdash t_2 : T \to S \quad l : T \in \text{Texn}}{\Gamma \vdash \text{try } t_1\ \text{with } l(x) \to t_2 : S}
  $$

  - 处理程序捕获标签为 $l$ 的异常，并将携带的值绑定到 $x$。

- 需要确保异常类型的扩展和作用域规则的正确性，以及类型安全性。

---

**练习 14.3.2** [««««]：我们在上面注意到，Java 异常（那些是 `Exception` 的子类）比 ML 中的异常（或我们在这里定义的异常）受到更严格的控制：一个方法可能引发的每个异常都必须在方法的类型中声明。扩展你对练习14.3.1的解答，使得函数的类型不仅指示其参数和结果类型，还指示它可能引发的异常集。证明你的系统是类型安全的。

**解答**：

- 我们需要为函数类型添加异常集的信息。

- **函数类型的扩展**：

  $$
  T = T_1 \xrightarrow{E} T_2
  $$

  - 其中 $E$ 是该函数可能引发的异常标签的集合。

- **类型规则的修改**：

  - **函数抽象（lambda）的类型规则**：

    $$
    \frac{\Gamma, x:T_1 \vdash t : T_2 \quad E = E_t}{\Gamma \vdash \lambda x:T_1.\ t : T_1 \xrightarrow{E} T_2}
    $$

    - 其中 $E_t$ 是在 $t$ 中可能引发的异常集。

  - **函数应用的类型规则**：

    $$
    \frac{\Gamma \vdash t_1 : T_{11} \xrightarrow{E_1} T_{12} \quad \Gamma \vdash t_2 : T_{11}}{\Gamma \vdash t_1\ t_2 : T_{12} \quad E = E_1 \cup E_{t_2}}
    $$

    - 其中 $E_{t_2}$ 是 $t_2$ 中可能引发的异常集。

- **类型安全性的证明**：

  - 我们需要证明在我们的类型系统中，程序不会发生未捕获的异常，即所有可能引发的异常都在类型中显式声明，并被正确地处理或传播。

  - 证明涉及到对求值的归纳，以及类型系统中异常集的信息正确传播。

---

**练习 14.3.3** [«««]：许多其他控制构造可以使用与本章中我们所见类似的技术来形式化。熟悉 Scheme 的“带当前连续体的调用”（call/cc）操作符的读者（参见 Clinger, Friedman, and Wand, 1985; Kelsey, Clinger, and Rees, 1998; Dybvig, 1996; Friedman, Wand, and Haynes, 2001）可能会尝试基于类型 $\text{Cont } T$ 的 $T$-连续体（即，期望类型为 $T$ 的参数的连续体）来制定类型规则。

**解答**：

- **call/cc** 是一种强大的控制操作符，允许程序捕获当前的计算上下文（连续体）并在以后恢复。

- 为了制定类型规则，我们可以引入一个新的类型构造 $\text{Cont } T$，表示期望类型为 $T$ 的参数的连续体。

- **call/cc 的类型规则**：

  $$
  \frac{\Gamma \vdash t : \text{Cont } T \to T}{\Gamma \vdash \text{call/cc } t : T}
  $$

- **连续体捕获的类型规则**：

  - 我们需要定义一个操作，使得在调用时，可以将当前的连续体作为参数传递给一个函数。

- **类型安全性的证明**：

  - 由于 call/cc 改变了程序的控制流，我们需要小心处理类型系统中的保证，以确保类型安全性。

- **进一步阅读**：

  - 读者可以参考相关文献，了解如何在类型系统中正确地处理 call/cc 和连续体的类型。

---

### 总结

通过本章的学习，我们了解了如何将异常机制添加到简单类型 $\lambda$ 演算中，以及如何设计求值规则和类型规则来处理异常的引发和捕获。我们讨论了异常的多种实现方式，包括携带值的异常、可扩展的异常类型，以及在编程语言中的具体实现（如 ML 和 Java）。同时，我们还探讨了异常对类型安全性的影响，以及如何在类型系统中准确地描述和处理异常。

### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------
[toc]



### 第14章 异常（Exceptions）

在第13章中，我们看到了如何使用🥑可变引用扩展纯简单类型 $\lambda$ 演算的简单操作语义，并考虑了这种扩展对类型规则和类型安全性证明的影响。在本章中，我们将处理对我们原始计算模型的另一种扩展：🥑**引发和处理异常**（raising and handling exceptions）。

现实世界的编程充满了这样一些情况：函数需要向其调用者发出信号，表示由于某种原因它无法完成任务——可能是因为某个计算将涉及除以零或算术溢出（arithmetic overflow），一个查找键在字典中丢失，数组索引越界，文件无法找到或打开，发生了某些灾难性事件，例如系统内存不足或用户终止了进程，等等。

其中一些异常情况可以通过让🥑🥑🥑🥑🥑🥑🥑🥑函数返回一个变体（variant）或选项（option）来表示，正如我们在第11.10节中看到的。但是在异常情况确实异常的情况下，我们可能不想强制我们的函数的每个调用者都处理它们可能发生的可能性。相反，我们可能更希望异常情况导致直接控制转移到程序中某个更高级别定义的异常处理程序——或者确实（如果异常情况足够罕见，或者调用者无论如何都无法从中恢复），直接终止程序。我们首先考虑后一种情况（第14.1节），即异常是整个程序的中止，然后添加一种机制来捕获并从异常中恢复（第14.2节），最后改进这两种机制，以允许在异常发生地和处理程序之间传递额外的程序员指定的数据（第14.3节）。

本章研究的系统是带有各种异常和异常处理原语（见图14-1和14-2）的简单类型 $\lambda$ 演算（图9-1）。

- **OCaml 实现**：第一个扩展的 OCaml 实现是 $fullerror$。带有携带值的异常的语言（图14-3）未实现。

### ------------------------------------------

在编程语言中，处理异常情况的方式有多种。在上述描述中，主要讨论了两种处理异常的方式：通过变体（variant）或选项（option）来显式处理异常，或者通过异常机制来隐式处理异常。让我们详细解释这两种方法，并扩展到更高级的异常处理方式。

### **1. 显式处理异常：使用变体（variant）或选项（option）**

在某些函数中，异常情况可以通过让函数返回一个特殊类型来表示，例如 **变体** 或 **选项** 类型，这样可以强制调用者显式处理可能出现的错误。

- **变体类型（variant type）**：允许函数返回不同类型的结果。例如，函数可以返回一个表示成功的值，或者返回一个表示错误的变体。
  
- **选项类型（option type）**：类似于变体类型，`Option` 类型通常表示值的存在与否。它通常有两个可能的值：
  - `Some(value)`：表示操作成功，返回了一个值。
  - `None`：表示操作失败，未返回值。
  

这种方式的🥑🥑🥑🥑🥑优点是**强制调用者处理错误**，确保在每个可能的异常情况下调用者都做出处理。

#### **例子：**

```rust
// 使用 Option 类型来显式处理异常情况
fn divide(x: i32, y: i32) -> Option<i32> {
    if y == 0 {
        None  // 返回 None 表示除以零的异常情况
    } else {
        Some(x / y)  // 返回 Some 结果表示成功
    }
}

fn main() {
    match divide(10, 0) {
        Some(result) => println!("结果是: {}", result),
        None => println!("不能除以零！"),  // 强制处理错误情况
    }
}
```

在这种显式错误处理方式下，程序的每个调用者都必须处理可能的错误。这种方式适用于常见或可恢复的错误情况，因为它提供了精确的控制，但🥑🥑🥑🥑缺点是可能导致代码冗长，特别是在错误频繁发生时。

### **2. 隐式处理异常：使用异常机制（Exception）**

在某些情况下，异常可能是比较罕见的，或者是无法从中恢复的异常。为每个调用者显式处理这些异常可能会让代码变得非常冗长。因此，异常机制允许程序在发生错误时自动“抛出”异常，并让程序的更高层捕获和处理这些异常。

#### **异常机制的特点：**
- **异常传播**：当发生异常时，程序的控制流会被打破，直接跳转到异常处理程序，而不是返回调用函数。
- **异常捕获（catching exceptions）**：更高层的代码可以选择捕获异常并处理，或者允许程序终止。

异常机制通常用于处理那些**异常且不可恢复的错误**。通过这种机制，程序可以快速跳转到处理程序，减少调用者的负担。

#### **例子：**

```python
def divide(x, y):
    if y == 0:
        raise ValueError("除以零错误")  # 抛出异常
    return x / y

try:
    result = divide(10, 0)
    print("结果是:", result)
except ValueError as e:
    print("捕获到错误:", e)  # 捕获并处理异常
```

在上述 Python 代码中，`raise` 语句会在异常情况发生时抛出一个异常。`try-except` 块可以捕获并处理这个异常。与显式返回 `None` 或 `Some` 的情况不同，🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑调用者不需要显式处理每个可能的异常，而是🥑🥑🥑只在需要时捕获异常。

### **3. 直接中止程序（Abort on Exception）**

在某些情况下，异常可能足够严重，或者无法恢复。这种情况下，我们可以选择让程序直接终止，而不进行任何处理。例如，分配内存失败或关键数据损坏可能无法从中恢复。

#### **例子：**

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *ptr = (int *)malloc(sizeof(int) * 100000000000);  // 试图分配巨大的内存
    if (ptr == NULL) {
        fprintf(stderr, "内存分配失败，程序终止。\n");
        exit(EXIT_FAILURE);  // 直接中止程序
    }
    return 0;
}
```

在 C 语言中，如果无法分配内存，程序会直接输出错误并中止。这是一种直接处理不可恢复错误的方式，避免了更多的处理步骤。

### **4. 捕获并恢复异常（Capturing and Recovering from Exceptions）**

尽管某些异常足够严重以至于无法恢复，仍有许多异常是可以恢复的。在这种情况下，程序可能希望捕获异常并从错误中恢复，而不是直接中止程序。这种机制允许程序在运行时从某些错误中跳过或重新尝试操作。

#### **捕获并恢复异常的机制：**
- **捕获异常**：程序捕获异常，并在出现错误时执行一些恢复操作（例如，重新尝试、跳过该部分代码，或使用默认值）。
- **继续执行**：程序在处理完异常后继续执行。

#### **例子：**

```java
try {
    int result = divide(10, 0);  // 可能抛出异常
} catch (ArithmeticException e) {
    System.out.println("不能除以零，使用默认值 1");
    result = 1;  // 使用默认值恢复
}
// 程序继续执行
System.out.println("结果是: " + result);
```

在 Java 中，通过 `catch` 块捕获异常并处理后，程序可以继续执行，而不必中止。这种方式特别适合那些可以从错误中恢复的情况。

### **5. 在异常发生地和处理程序之间传递数据**

当异常被抛出时，通常需要传递一些有用的信息给异常处理程序，以便后者能够理解和处理该异常。这种机制允许在**异常抛出点和捕获点之间传递数据**。

#### **传递额外数据的方式：**
- **异常消息**：抛出异常时，提供详细的异常信息或数据，例如错误代码、上下文信息等。
- **封装的异常对象**：某些编程语言允许定义带有额外信息的异常对象，这些对象可以携带更复杂的状态数据。

#### **例子：**

```python
class CustomError(Exception):
    def __init__(self, message, code):
        self.message = message
        self.code = code

def divide(x, y):
    if y == 0:
        raise CustomError("除以零错误", 400)  # 抛出带数据的异常
    return x / y

try:
    divide(10, 0)
except CustomError as e:
    print(f"错误: {e.message}, 错误码: {e.code}")  # 捕获并使用异常中的数据
```

在这个 Python 例子中，异常对象 `CustomError` 不仅携带了错误消息，还携带了一个错误代码。捕获异常时，处理程序可以使用这些附加的数据做出更精细的处理。

### **总结：**

- **变体/选项类型**：🥑🥑🥑🥑适合显式处理异常情况，强制调用者处理可能的错误，但代码可能变得冗长。
- **异常机制**：适合处理异常情况，自动跳转到异常处理程序，不需要每次都显式处理异常。
- **程序中止**：适合不可恢复的异常，直接终止程序执行。
- **捕获并恢复异常**：适合可以从错误中恢复的场景，允许程序继续执行。
- **传递数据的异常机制**：允许在异常抛出点和捕获点之间传递额外的上下文信息，帮助处理程序更好地理解异常。

每种方式都有各自的适用场景，编程时需要根据具体的异常情况选择合适的处理方式。

### ------------------------------------------

---

### 14.1 引发异常（Raising Exceptions）

让我们从通过最简单的机制丰富简单类型 $\lambda$ 演算开始，用于信号异常：一个项 $error$，当被求值时，完全中止其出现的项的求值。**图14-1** 详细列出了所需的扩展。

#### 图14-1：错误（Errors）

**→ error** 扩展了 $\lambda \to$（图9-1）

- **新的语法形式**：

  $$
  \begin{align*}
  t ::= \quad & \ldots & \text{项（terms）} \\
  & \text{error} & \text{运行时错误（run-time error）}
  \end{align*}
  $$

- **新的求值规则** $t \to t'$：

  - **（E-AppErr1）**：

    $$
    \text{error}\ t_2 \to \text{error}
    $$

  - **（E-AppErr2）**：

    $$
    v_1\ \text{error} \to \text{error}
    $$

- **新的类型规则** $\Gamma \vdash t : T$：

  - **（T-Error）**：

    $$
    \Gamma \vdash \text{error} : T
    $$

---

#### 设计和解释

在为 $error$ 编写规则时，主要的设计决策是如何在我们的操作语义中形式化“异常终止”。我们采用简单的权宜之计，让 $error$ 本身成为程序中止的结果。规则 **E-AppErr1** 和 **E-AppErr2** 捕捉了这种行为。

- **（E-AppErr1）**：

  $$
  \text{error}\ t_2 \to \text{error}
  $$

  该规则表示，如果我们在尝试将应用（application）的左侧归约为值的过程中遇到项 $error$，我们应立即将 $error$ 作为应用的结果。

- **（E-AppErr2）**：

  $$
  v_1\ \text{error} \to \text{error}
  $$

  该规则表示，如果我们在尝试将应用的参数（右侧）归约为值的过程中遇到 $error$，我们应放弃对该应用的工作，并立即返回 $error$。

🥑🥑注意，我们并未将 $error$ 包含在值的语法中——它仅在项的语法中。这保证了 **E-AppAbs** 和 **E-AppErr2** 规则的左侧永远不会重叠——即，对于我们是否应该对项

$$
(\lambda x:\text{Nat}.\ 0)\ \text{error}
$$

执行应用（从而产生结果 $0$）或中止，没有歧义：只有后者是可能的。同样，我们在 **E-AppErr2** 中使用了元变量 $v_1$（而不是表示任意项的 $t_1$），这迫使求值器在中止之前等待应用的左侧被归约为值，即使右侧是 $error$。因此，像

$$
(\text{fix}\ (\lambda x:\text{Nat}.\ x))\ \text{error}
$$

这样的项将会发散（diverge）而不是中止。这些条件确保了求值关系仍然是确定性的。

**类型规则 T-Error** 也很有趣。由于我们可能希望在任何上下文中引发异常，$error$ 形式被允许具有任何类型。

- **（T-Error）**：

  $$
  \Gamma \vdash \text{error} : T
  $$

例如，在

$$
(\lambda x:\text{Bool}.\ x)\ \text{error};
$$

中，它具有类型 $Bool$。在

$$
(\lambda x:\text{Bool}.\ x)\ (\text{error}\ \text{true});
$$

中，它具有类型 $\text{Bool} \to \text{Bool}$。

🥑🥑这种 $error$ 类型的灵活性在实现类型检查算法时会引发一些困难，因为它打破了语言中每个可类型化的项都有唯一类型的性质（定理9.3.3）。这可以通过各种方式处理。🥑🥑🥑在具有子类型的语言中，我们可以将 $error$ 分配最小类型 $Bot$（参见第15.4节），必要时可以将其提升为任何其他类型。🥑🥑🥑在具有参数化多态性的语言中（参见第23章），我们可以给 $error$ 多态类型 $\forall X.\ X$，🥑🥑它可以实例化为任何其他类型。这两个技巧都允许将 $error$ 的无限多种可能类型紧凑地表示为单个类型。

### --------------------------

### 类型规则 T-Error 详解

#### 灵活性和设计原理

**T-Error** 的规则允许 $error$ 形式具有任意类型 $T$，这反映了异常在编程语言中的广泛适用性。异常可以在任何地方被引发，并不依赖于上下文的具体类型。为了适应这一点，$error$ 被允许具有任意类型。

#### 规则定义

- **（T-Error）**：
  $$
  \Gamma \vdash \text{error} : T
  $$

该规则的核心思想是：无论上下文 $\Gamma$ 是什么，$error$ 都能被赋予任何类型 $T$。这意味着 $error$ 可以出现在任意类型的函数、表达式中，而不会导致类型检查失败。

#### 举例说明

- 在项 $(\lambda x:\text{Bool}.\ x)\ \text{error}$ 中，$error$ 的类型被推断为 $Bool$。虽然我们没有显式定义 $error$ 的类型，但由于这个项的上下文要求其类型为 $Bool$，因此根据 **T-Error** 规则，$error$ 被赋予类型 $Bool$。

- 在项 $(\lambda x:\text{Bool}.\ x)\ (\text{error}\ \text{true})$ 中，$error$ 的类型为 $Bool \to Bool$。这是因为应用的上下文要求 $error$ 作为一个函数的参数，而该函数期望一个 $Bool$ 类型的参数，所以 $error$ 被赋予了符合上下文的类型。

#### $error$ 类型灵活性带来的问题

这种允许 $error$ 具有任意类型的灵活性在设计类型检查算法时带来了复杂性。通常，在大多数类型系统中，一个良类型的项应该具有唯一的类型（即类型唯一性定理）。但由于 $error$ 可以在任何上下文中被赋予任意类型，这破坏了每个项具有唯一类型的性质。

这在实现类型推断或类型检查时可能会导致麻烦，因为 $error$ 的类型是不确定的。

#### 解决方案

为了应对这种复杂性，编程语言通常采用两种方式来处理 $error$ 的类型灵活性：

1. **子类型系统中的最小类型 $Bot$**

   在引入子类型系统的语言中，$error$ 可以被赋予一个最小类型，通常称为 $Bot$。$Bot$ 是所有类型的子类型，也就是说，$Bot$ 可以被提升为任何其他类型。

   例如：

   $$
   \Gamma \vdash \text{error} : \text{Bot}
   $$

   当程序需要时，可以将 $Bot$ 类型的 $error$ 提升为所需的类型。这样一来，$error$ 不需要明确指定每次的类型，只要被提升到正确的类型即可。

2. **多态类型 $\forall X.\ X$**

   在引入参数化多态性的语言中，$error$ 可以被赋予多态类型：

   $$
   \text{error} : \forall X.\ X
   $$

   这个多态类型意味着 $error$ 可以被实例化为任何具体类型。无论 $X$ 是 $Bool$、$Int$ 还是其他类型，$error$ 都能适应。在不同的上下文中，这个多态类型可以被具体化为不同的类型。

#### 结论

通过上述两种方法，$error$ 的无限多种可能类型可以通过 $Bot$ 或 $\forall X.\ X$ 来紧凑地表示，从而简化类型推断和类型检查算法的实现。$error$ 的灵活性在异常处理机制中至关重要，而编程语言在设计时通过引入最小类型或多态类型，保证了类型系统的健壮性和一致性。

### --------------------------

**练习 14.1.1** [«]：将 $error$ 的预期类型在每个使用它的上下文中要求程序员进行注释，不会更简单吗？

**解答**：

- 是的，这可能会更简单。如果程序员在每次使用 $error$ 时显式地注释其预期的类型，那么类型检查器就不需要推断 $error$ 的类型，也避免了类型唯一性的问题。

---

类型保持性质对于带有异常的语言与往常一样：如果一个项具有类型 $T$，并且我们让它求值一步，结果仍然具有类型 $T$。然而，进展性质需要稍微调整一下。它的原始形式说，良类型的程序必须求值为一个值（或发散）。但现在我们引入了一个非值的正常形式（normal form），即 $error$，它当然可以是良类型程序的求值结果。我们需要重新陈述进展性质以允许这种情况。

**定理 14.1.2 [进展（Progress）]**：假设 $t$ 是一个闭合的、良类型的正常形式。那么要么 $t$ 是一个值，要么 $t = \text{error}$。

### ---------------------------------

### 14.1 引发异常（Raising Exceptions）

本节介绍了如何通过引入 `error` 机制来扩展简单类型 $\lambda$ 演算，从而允许在运行时引发异常。当程序中遇到 `error` 时，求值将立即中止并返回错误结果。**图14-1** 详细列出了这种扩展的语法、求值规则以及类型规则。

#### **图14-1：错误（Errors）**

### 新的语法形式

为了在 $\lambda \to$ 演算中表示异常，新增了一种表示运行时错误的项：

$$
\begin{align*}
t ::= \quad & \ldots & \text{项（terms）} \\
& \text{error} & \text{运行时错误（run-time error）}
\end{align*}
$$

`error` 是一种特殊的项，当程序运行时遇到 `error`，求值会立即中止，返回 `error` 作为结果。

### 新的求值规则

扩展的求值规则定义了在不同场景下遇到 `error` 时，如何处理求值：

- **（E-AppErr1）**：

  $$
  \text{error}\ t_2 \to \text{error}
  $$

  - 解释：如果在应用的左侧遇到 `error`，整个应用的结果将是 `error`，而不需要进一步处理右侧项 $t_2$。

- **（E-AppErr2）**：

  $$
  v_1\ \text{error} \to \text{error}
  $$

  - 解释：如果应用的参数（右侧）是 `error`，则直接返回 `error`，不考虑左侧的值 $v_1$。

这些规则说明了 `error` 的传播方式。一旦在某个项中遇到 `error`，程序将立即中止，返回 `error` 作为求值结果。

#### 新的类型规则

引入 `error` 也需要对类型系统进行扩展。由于 `error` 可能出现在任何地方，且应该被允许在任何上下文中产生，因此我们赋予 `error` 一个通用的类型规则：

- **（T-Error）**：

  $$
  \Gamma \vdash \text{error} : T
  $$

  - 解释：`error` 可以被赋予任何类型 $T$，因为它可以在任何上下文中作为异常被引发。

### 设计和解释

#### 1. **求值中的异常处理**

在设计 `error` 机制时，一个关键点是如何在操作语义中处理异常。我们选择了简单的策略：一旦遇到 `error`，求值立即中止，返回 `error` 作为最终结果。

- **E-AppErr1**：左侧出现 `error` 时，整个应用的结果是 `error`，例如：

  $$
  \text{error}\ t_2 \to \text{error}
  $$

- **E-AppErr2**：右侧出现 `error` 时，整个应用的结果也是 `error`，例如：

  $$
  v_1\ \text{error} \to \text{error}
  $$

这种设计保证了程序遇到异常后立刻中止，不会继续处理其他部分。

#### 2. **值与非值的区别**

🥑🥑🥑🥑🥑🥑🥑🥑在求值规则的设计中，`error` 并没有被归为值，而是项的一部分。这确保了应用规则 **E-AppAbs** 和 **E-AppErr2** 之间没有歧义，例如：

$$
(\lambda x:\text{Nat}.\ 0)\ \text{error}
$$

在这种情况下，程序会中止而不会产生 $0$ 作为结果，因为求值首先遇到了 `error`。类似地，在 **E-AppErr2** 中，左侧的项会被完全求值后才中止。

### --------------------------

### 1. **求值中的异常处理**

在设计异常处理机制时，操作语义的关键点是如何处理异常。为了简化处理流程，`error` 被设计为一旦出现就立即中止整个求值过程，直接返回 `error` 作为结果。这种设计避免了复杂的错误传播或恢复机制，保证异常在求值过程中快速终止。

#### **求值规则**

- **E-AppErr1**：

  当应用中的左侧项是 `error` 时，整个应用会立即中止，并返回 `error`。例如：

  $$
  \text{error}\ t_2 \to \text{error}
  $$

  该规则确保程序在处理左侧项的过程中遇到 `error` 后，不再尝试对右侧项 $t_2$ 进行求值。

- **E-AppErr2**：

  当应用中的右侧项是 `error` 时，无论左侧项是什么，整个应用会立即中止，并返回 `error`。例如：

  $$
  v_1\ \text{error} \to \text{error}
  $$

  这表明即使左侧项 $v_1$ 已经成功求值为一个值，如果右侧出现 `error`，求值仍然会立即中止，返回 `error`。

#### **设计意义**

这种设计使得异常的传播方式非常直接：一旦程序中某个地方出现了 `error`，求值过程立即停止，不再处理其他部分。这避免了异常被忽略或处理不当的情况，从而提高了程序的鲁棒性。

---

### 2. **值与非值的区别**

在求值规则中，`error` 并没有被归类为值（value），而是视为一种特殊的项。为了明确区分值与非值，操作语义保证了在任何地方遇到 `error` 时，求值过程立即中止。

#### **关键规则设计**

- **E-AppAbs** 是应用规则的一个重要部分，处理函数应用时左侧项已经归约为值的情况。然而，`error` 并不属于值的集合，因此在应用规则中设计了 **E-AppErr1** 和 **E-AppErr2** 来捕获异常并中止求值过程。

例如，对于项：

$$
(\lambda x:\text{Nat}.\ 0)\ \text{error}
$$

程序遇到 `error` 时，求值不会继续执行函数应用得到 $0$，而是立即中止返回 `error`。

#### **值与求值的区别**

- **值（value）**：是求值过程的最终结果，例如函数或常量。
- **非值（non-value）**：例如 `error`，不会继续求值为某种值，而是作为求值过程的终止信号。

#### **设计的目的**

这种区别确保了求值规则的一致性，并避免了在不同规则之间产生歧义。例如，**E-AppErr2** 明确指出左侧项需要先被完全求值为值后，右侧出现 `error` 才会导致中止：

$$
v_1\ \text{error} \to \text{error}
$$

这使得程序在某些情况下不会在还未完全确定左侧值的情况下就提前中止，从而保持了求值的完整性和确定性。

### 总结

通过这些设计，`error` 的行为被明确为一种立即中止求值的机制，而不会影响正常值的求值过程。它保证了在任何情况下，遇到 `error` 时求值过程是确定且一致的。

### ---------------------------

#### 3. **`error` 的类型灵活性**

`error` 可以在任何类型上下文中使用，因此它被赋予了任何类型 $T$ 的规则。比如：

- 在项 $(\lambda x:\text{Bool}.\ x)\ \text{error}$ 中，`error` 的类型是 `Bool`。
- 在项 $(\lambda x:\text{Bool}.\ x)\ (\text{error}\ \text{true})$ 中，`error` 的类型是 `Bool \to Bool`。

#### 4. **`error` 与类型推断**

`error` 的这种灵活性在实现类型推断算法时引发了一些困难。因为 `error` 可以拥有任意类型，这违背了每个良类型项应具有唯一类型的性质。为了解决这个问题，有两种常见的策略：

1. **最小类型 `Bot`**：在具有子类型的语言中，可以将 `error` 的类型设为 `Bot`（最小类型），并在需要时将其提升为任意类型。
2. **多态类型**：在多态语言中，可以给 `error` 分配多态类型 $\forall X.\ X$，这样 `error` 可以实例化为任何具体类型。

这两种方法都允许 `error` 在类型系统中灵活地使用，并保持一致性。

#### 5. **类型保持与进展**

- **类型保持定理**：尽管引入了 `error`，类型保持定理仍然成立。即：如果一个项有类型 $T$，那么求值后它的类型仍然是 $T$。无论是值还是 `error`，它们都保持同样的类型。
  
- **进展定理**：引入 `error` 后，进展定理稍作调整。原本进展定理指出，良类型的程序要么求值为一个值，要么发散。而现在，`error` 是一种新的正常形式（normal form），我们需要允许良类型的程序求值为 `error`。

### 14.1.2 **进展定理**

**定理 14.1.2 [进展定理]**：假设 $t$ 是一个闭合的、良类型的正常形式。则要么 $t$ 是一个值，要么 $t = \text{error}$。

**证明思路**：

该定理表明，良类型的项不会卡住。一个良类型的项 $t$ 要么最终求值为值（比如 $\lambda$ 表达式），要么会遇到 `error` 而中止，不会卡在某个无法继续求值的状态。

### ----------------------------------

---

### 🥑14.2 处理异常（Handling Exceptions）

对 $error$ 的求值规则可以被认为是🥑“展开调用栈”（unwinding the call stack），🥑丢弃挂起的函数调用，🥑直到 $error$ 一直传播到顶层。在带有异常的语言的实际实现中，这正是发生的情况：调用栈由一组活动记录（activation records）组成，每个活动的函数调用一个；引发异常会导致活动记录从调用栈中弹出，直到它变为空。

在大多数带有异常的语言中，还可以在调用栈中安装异常处理程序。当引发异常时，活动记录从调用栈中弹出，直到遇到异常处理程序，然后求值继续在该处理程序处进行。换句话说，异常充当一种非本地的控制转移，其目标是最近安装的异常处理程序（即，调用栈中最近的一个）。

### ---------------------------

### 处理异常（Handling Exceptions）

在处理异常时，$error$ 的求值规则可以被视为**“展开调用栈”**（unwinding the call stack）。也就是说，当程序中遇到异常时，函数调用的执行会被中止，当前的求值路径（也就是当前的函数调用）会被丢弃，直到异常传播到程序的顶层。 

#### **展开调用栈的过程**

当程序运行时，每一个函数调用都会在调用栈中创建一个活动记录（activation record），也称为栈帧。每个栈帧包含了与该函数调用相关的局部变量、参数、返回地址等信息。异常的处理过程可以理解为逐步弹出这些活动记录，直到找到适合处理异常的位置。具体步骤为：

1. **遇到异常**：当程序遇到 $error$ 或其他异常时，正常的函数调用执行路径被中断。
2. **丢弃挂起的函数调用**：所有在异常发生时正在进行的函数调用都会被丢弃，活动记录逐步从调用栈中弹出。
3. **传播到顶层**：异常继续沿着调用栈向上传播，直到传播到程序的顶层。如果没有被捕获的处理程序，程序会中止。

在没有异常处理机制的情况下，$error$ 会一路传播到栈顶，程序直接结束运行。

#### **带有异常处理程序的情况**

在大多数带有异常的编程语言中，还可以在调用栈中安装异常处理程序。当引发异常时，程序会沿着调用栈向上遍历，直到找到一个适当的异常处理程序，然后将异常交由该处理程序处理。在找到处理程序之后，求值过程将继续在处理程序处恢复。这种异常处理机制允许程序在遇到异常时不必立即中止，而是有机会通过处理程序对异常进行适当的处理。

##### **处理流程**

1. **引发异常**：当遇到异常时，活动记录开始从栈顶依次弹出。
2. **寻找异常处理程序**：如果在调用栈中找到了异常处理程序，异常停止传播，并将控制权转移到该处理程序处。
3. **恢复求值**：异常处理程序可以决定如何处理异常，继续正常的程序流程或采取其他的应对措施。

#### **异常的非本地控制转移**

异常处理机制是一种非本地的控制转移（non-local control transfer）。通常情况下，函数的控制流是从调用点继续到函数的末尾。然而，引发异常时，控制流不会按通常的方式返回，而是直接跳到最近的异常处理程序。这是一种动态的控制流调整机制，允许程序跳过部分求值，直接进入错误处理逻辑。

##### **关键点**

- **调用栈的展开**：异常的传播会逐步弹出调用栈中的活动记录，直到遇到合适的异常处理程序。这个过程被称为“展开调用栈”。
- **异常处理程序的捕获**：异常一旦被捕获，控制权会转移到处理程序，程序可以继续执行。
- **非本地控制转移**：异常处理允许程序脱离正常的局部控制流，而转向一个较高的、动态确定的控制点。

#### **总结**

异常处理机制通过展开调用栈，使程序能够对运行时的错误进行非本地控制转移。这种机制允许程序在遇到错误时不必立即中止，而是有机会通过捕获异常继续执行特定的逻辑处理。异常处理程序在这种情况下扮演着至关重要的角色，它决定了异常在程序中的传播路径和处理方式。

### ----------------------------

我们对异常处理程序的表述，概括在**图14-2** 中，与 ML 和 Java 都类似。表达式 $try t1 with t2$ 的含义是“返回对 $t1$ 的求值结果，除非它中止，在这种情况下，改为求值处理程序 $t2$”。

#### 图14-2：错误处理（Error handling）

**→ error try** 扩展了 $\lambda \to$，添加了错误（14-1）

- **新的语法形式**：

  $$
  \begin{align*}
  t ::= \quad & \ldots & \text{项（terms）} \\
  & \text{try } t\ \text{with } t & \text{捕获错误（trap errors）}
  \end{align*}
  $$

- **新的求值规则** $t \to t'$：

  - **（E-TryV）**：

    $$
    \text{try } v_1\ \text{with } t_2 \to v_1
    $$

    当 $t_1$ 已经被归约为值 $v_1$ 时，我们可以丢弃 $try$，因为我们现在知道它不再需要。

  - **（E-TryError）**：

    $$
    \text{try }\ \text{error}\ \text{with } t_2 \to t_2
    $$

    这条规则表示，如果对 $t_1$ 的求值结果是 $error$，那么我们应该用 $t_2$ 替换整个 $try$，并从那里继续求值。

  - **（E-Try）**：

    $$
    \frac{t_1 \to t_1'}{\text{try } t_1\ \text{with } t_2 \to \text{try } t_1'\ \text{with } t_2}
    $$

    该规则表示，在 $t_1$ 被归约为值或 $error$ 之前，我们应继续对其进行求值，并保持 $t_2$ 不变。

- **新的类型规则** $\Gamma \vdash t : T$：

  - **（T-Try）**：

    $$
    \frac{\Gamma \vdash t_1 : T \quad \Gamma \vdash t_2 : T}{\Gamma \vdash \text{try } t_1\ \text{with } t_2 : T}
    $$

---

#### 解释

**求值规则**

- **E-TryV**：当 $try$ 的主体 $t_1$ 已经归约为值 $v_1$，我们可以丢弃 $try$，因为异常不会发生，结果就是 $v_1$。

- **E-TryError**：如果在求值 $t_1$ 时结果是 $error$，则将整个 $try$ 替换为处理程序 $t_2$，继续从那里求值。

- **E-Try**：在 $t_1$ 还未归约为值或 $error$ 之前，我们继续对 $t_1$ 进行求值。

**类型规则**

- **T-Try**：$try t_1 with t_2$ 的结果可以是主体 $t_1$ 的结果，或者是处理程序 $t_2$ 的结果；我们需要要求它们具有相同的类型 $T$，这也是整个 $try$ 表达式的类型。

类型安全性属性及其证明与前一节基本相同。

### -----------------------------------

### 带值的异常（Exceptions Carrying Values）

带值的异常扩展了基础的异常处理机制，使得异常不仅仅是一个简单的信号，还能够携带额外的信息。这些信息能够帮助异常处理程序了解异常的具体原因，从而采取适当的应对措施，如重试操作、记录错误日志，或者向用户提供有用的错误反馈。

#### **异常机制的基本原理**

在前面的章节中，我们看到异常处理机制能够帮助函数向其调用者发出信号，表示“发生了一些不寻常的事情”。然而，单单通过一个异常信号往往不足以提供足够的上下文。例如，在发生除零错误或文件未找到的情况下，仅仅知道发生了错误是不够的；我们希望了解具体的错误信息，例如哪个数被除以零，或者哪个文件未找到。

因此，**带值的异常**允许程序在引发异常时附带详细的信息。这种设计极大地提升了异常处理的灵活性和实用性，因为异常处理程序可以根据异常携带的值来决定如何应对。

#### **带值异常的优点**

1. 🥑**提供上下文信息**：异常可以携带发生错误时的上下文数据，比如文件名、行号、错误类型等。这些信息可以帮助程序员在处理异常时更好地了解问题所在。
   
2. 🥑**精确处理**：异常处理程序可以根据携带的值来区分不同类型的错误，进而采取不同的处理策略。例如，某些错误可能需要重试操作，而另一些错误可能需要立即终止程序。

3. 🥑**提升用户体验**：带值异常允许程序向用户提供更有用的错误消息。例如，当用户尝试打开不存在的文件时，异常可以携带该文件的路径，帮助用户了解具体的错误原因。

#### **带值异常的实现方式**

##### **1. 异常携带简单值**

在许多编程语言中，异常可以附带简单的标量值，如整数、字符串或布尔值。这些值可以帮助处理程序区分不同类型的错误。

**例子：Python 中带值异常**

```python
try:
    raise ValueError("Invalid input: must be an integer.")
except ValueError as e:
    print(e)
```

在这个例子中，异常 `ValueError` 附带了一个字符串值 "Invalid input: must be an integer."，这个值可以帮助异常处理程序输出更加详细的错误消息。

##### **2. 异常携带复杂结构**

在更复杂的场景中，异常可能需要携带结构化的数据，例如对象或记录。这样可以让处理程序获取更加全面的信息，如多个相关的错误字段或嵌套的错误上下文。

**例子：Java 中带值异常**

```java
class FileNotFoundException extends Exception {
    private String fileName;
    
    public FileNotFoundException(String fileName) {
        super("File not found: " + fileName);
        this.fileName = fileName;
    }

    public String getFileName() {
        return fileName;
    }
}
```

在这个例子中，`FileNotFoundException` 类不仅传递了错误消息，还附带了错误的文件名。这使得捕获异常的处理程序能够使用 `getFileName()` 方法获取具体的文件路径，从而提供更有针对性的处理。

##### **3. 🥑参数化异常（多态性）**

在某些语言中，异常还可以通过多态性携带不同类型的数据。通过使用泛型或类型参数化，异常处理程序可以针对不同类型的异常值进行处理。

**例子：Haskell 中的参数化异常**

```haskell
data MyError = FileNotFound String | DivideByZero
    deriving Show

handleError :: MyError -> String
handleError (FileNotFound fileName) = "File not found: " ++ fileName
handleError DivideByZero = "Attempted to divide by zero."
```

在这个例子中，`MyError` 数据类型可以携带不同的错误信息。`FileNotFound` 构造函数携带一个文件名，而 `DivideByZero` 则不需要任何额外的信息。处理函数 `handleError` 可以根据异常的构造形式来处理不同类型的错误。

#### **带值异常的设计取舍**

##### **优点**：

- **灵活性**：带值的异常提供了更大的灵活性，允许携带额外的信息，帮助异常处理程序做出更合适的决策。
  
- **可维护性**：提供上下文信息可以减少调试时的难度，程序员能够通过异常携带的值直接定位问题。

##### **缺点**：

- **复杂性增加**：带值异常会增加系统的复杂性，尤其是在携带复杂结构的情况下。设计良好的异常处理逻辑需要明确区分不同类型的异常及其关联的上下文数据。

- **潜在的性能开销**：携带大量数据的异常可能增加异常抛出和捕获的性能开销，尤其是在资源受限的系统中。

#### **总结**

带值异常通过允许附带详细的错误信息，极大增强了异常处理机制的灵活性和实用性。无论是简单的标量值，还是复杂的结构化数据，带值异常都可以帮助程序更精确地处理错误，提高程序的健壮性和用户体验。

### ------------------------------------

---

### 14.3 携带值的异常（Exceptions Carrying Values）

在第14.1节和第14.2节中引入的机制允许函数向其调用者发出信号，表示“发生了一些不寻常的事情”。通常，发送一些关于发生了什么不寻常事情的额外信息是有用的，因为处理程序需要采取的行动——要么恢复并重试，要么向用户呈现可理解的错误消息——可能取决于这些信息。

**图14-3** 显示了如何丰富我们的基本异常处理构造，使得每个异常都携带一个值。该值的类型记为 $\text{Texn}$。目前，我们对该类型的具体性质保持开放；下面我们将讨论几种替代方案。

#### 图14-3：携带值的异常（Exceptions carrying values）

**→ exceptions** 扩展了 $\lambda \to$（图9-1）

- **新的语法形式**：

  $$
  \begin{align*}
  t ::= \quad & \ldots & \text{项（terms）} \\
  & \text{raise } t & \text{引发异常（raise exception）} \\
  & \text{try } t\ \text{with } t & \text{处理异常（handle exceptions）}
  \end{align*}
  $$

- **新的求值规则** $t \to t'$：

  - **（E-AppRaise1）**：

    $$
    (\text{raise } v_{11})\ t_2 \to \text{raise } v_{11}
    $$

  - **（E-AppRaise2）**：

    $$
    v_1\ (\text{raise } v_{21}) \to \text{raise } v_{21}
    $$

  - **（E-Raise）**：

    $$
    \frac{t_1 \to t_1'}{\text{raise } t_1 \to \text{raise } t_1'}
    $$

  - **（E-RaiseRaise）**：

    $$
    \text{raise } (\text{raise } v_{11}) \to \text{raise } v_{11}
    $$

  - **（E-TryV）**：

    $$
    \text{try } v_1\ \text{with } t_2 \to v_1
    $$

  - **（E-TryRaise）**：

    $$
    \text{try } (\text{raise } v_{11})\ \text{with } t_2 \to t_2\ v_{11}
    $$

  - **（E-Try）**：

    $$
    \frac{t_1 \to t_1'}{\text{try } t_1\ \text{with } t_2 \to \text{try } t_1'\ \text{with } t_2}
    $$

- **新的类型规则** $\Gamma \vdash t : T$：

  - **（T-Exn）**：

    $$
    \frac{\Gamma \vdash t_1 : \text{Texn}}{\Gamma \vdash \text{raise } t_1 : T}
    $$

  - **（T-Try）**：

    $$
    \frac{\Gamma \vdash t_1 : T \quad \Gamma \vdash t_2 : \text{Texn} \to T}{\Gamma \vdash \text{try } t_1\ \text{with } t_2 : T}
    $$

---

#### 解释

**求值规则**

- **E-AppRaise1** 和 **E-AppRaise2**：这两条规则类似于图14-1中的 **E-AppErr1** 和 **E-AppErr2**，它们通过应用程序传播异常。

  - **E-AppRaise1**：

    $$
    (\text{raise } v_{11})\ t_2 \to \text{raise } v_{11}
    $$

    🥑如果在函数位置（左侧）有一个 $raise$ 表达式，则整个应用直接变为 $raise$。

  - **E-AppRaise2**：

    $$
    v_1\ (\text{raise } v_{21}) \to \text{raise } v_{21}
    $$

    🥑如果在参数位置（右侧）有一个 $raise$ 表达式，同样，整个应用直接变为 $raise$。

- **E-Raise**：如果 $raise$ 的附加信息 $t_1$ 还需要求值，我们需要首先对 $t_1$ 求值。

  $$
  \frac{t_1 \to t_1'}{\text{raise } t_1 \to \text{raise } t_1'}
  $$

- **E-RaiseRaise**：处理在评估要在另一个异常中发送的附加信息时可能发生的异常。

  $$
  \text{raise } (\text{raise } v_{11}) \to \text{raise } v_{11}
  $$

- **E-TryV**：当 $try$ 的主体 $t_1$ 已经归约为值 $v_1$，我们可以丢弃 $try$，结果就是 $v_1$。
  $$
  \text{try } v_1\ \text{with } t_2 \to v_1
  $$
  
- **E-TryRaise**：如果 $t_1$ 求值为 $raise v_{11}$，则将异常的🥑附加信息 $v_{11}$ 🥑传递给处理程序 $t_2$。
  $$
  \text{try } (\text{raise } v_{11})\ \text{with } t_2 \to t_2\ v_{11}
  $$
  
- **E-Try**：在 $t_1$ 被归约为值或 $raise$ 之前，我们继续对 $t_1$ 进行求值。

  $$
  \frac{t_1 \to t_1'}{\text{try } t_1\ \text{with } t_2 \to \text{try } t_1'\ \text{with } t_2}
  $$

**类型规则**

- **（T-Exn）**：

  $$
  \frac{\Gamma \vdash t_1 : \text{Texn}}{\Gamma \vdash \text{raise } t_1 : T}
  $$

  我们要求附加信息 $t_1$ 🥑具有类型 $\text{Texn}$；整个 $raise$ 表达式可以被赋予上下文所需的任何类型 $T$。

- **（T-Try）**：

  $$
  \frac{\Gamma \vdash t_1 : T \quad \Gamma \vdash t_2 : \text{Texn} \to T}{\Gamma \vdash \text{try } t_1\ \text{with } t_2 : T}
  $$

  我们检查处理程序 $t_2$ 是一个函数，给定类型为 $\text{Texn}$ 的附加信息，产生与 $t_1$ 相同类型 $T$ 的结果。

### ----------------------------

### 求值规则（Evaluation Rules）

#### 1. **E-AppRaise1** 和 **E-AppRaise2**
这两条规则处理异常在函数应用中的传播，类似于图14-1中的 **E-AppErr1** 和 **E-AppErr2**，它们定义了当函数或参数中包含 `raise` 表达式时，如何传播异常。

- **E-AppRaise1**：当函数位置（左侧）是一个 `raise` 表达式时，整个应用直接成为该 `raise` 表达式，不需要对参数进行求值。换句话说，如果在函数位置出现了异常，参数求值会被跳过，整个应用中止，并直接返回异常。

  $$
  (\text{raise } v_{11})\ t_2 \to \text{raise } v_{11}
  $$

  **解释**：如果一个函数的位置已经是 `raise v_{11}`，那么函数的参数 $t_2$ 不会继续求值，应用的结果直接就是 `raise v_{11}`。

  **例子**：

  ```racket
  (raise 5) 10 ; 结果为 (raise 5)，而不是进行 10 的求值
  ```

- **E-AppRaise2**：当参数位置（右侧）是一个 `raise` 表达式时，整个应用直接成为该 `raise` 表达式。这表明，即使函数本身已经求值为一个值，如果参数是 `raise`，函数调用也会中止并传播异常。

  $$
  v_1\ (\text{raise } v_{21}) \to \text{raise } v_{21}
  $$

  **解释**：如果在参数位置有 `raise v_{21}`，那么即便左边 $v_1$ 是一个值，整个应用的结果仍然是 `raise v_{21}`。

  **例子**：

  ```racket
  (lambda (x) (+ x 1)) (raise 7) ; 结果为 (raise 7)，而不是对 lambda 求值
  ```

#### 2. **E-Raise** 和 **E-RaiseRaise**
这两条规则处理 `raise` 表达式本身的求值，特别是当 `raise` 携带的附加信息还需要求值时。

- **E-Raise**：如果 `raise` 的附加信息 $t_1$ 还未求值，我们需要先对 $t_1$ 进行求值。

  $$
  \frac{t_1 \to t_1'}{\text{raise } t_1 \to \text{raise } t_1'}
  $$

  **解释**：如果 `raise` 表达式的附加信息 $t_1$ 不是一个已经求值的值（即非终止状态），那么我们需要继续对 $t_1$ 进行求值。

  **例子**：

  ```racket
  (raise (+ 2 3)) ; 需要先对 (+ 2 3) 求值为 5，再返回 (raise 5)
  ```

- **E-RaiseRaise**：如果 `raise` 表达式的附加信息本身又是一个 `raise` 表达式，我们直接传播最内层的异常值。

  $$
  \text{raise } (\text{raise } v_{11}) \to \text{raise } v_{11}
  $$

  **解释**：如果 `raise` 表达式的附加信息本身是另一个 `raise`，那么只传播内层的异常值，而不嵌套异常。

  **例子**：

  ```racket
  (raise (raise 10)) ; 结果为 (raise 10)
  ```

#### 3. **E-TryV 和 E-TryRaise**
这两条规则处理异常捕获机制，通过 `try` 语句处理异常。

- **E-TryV**：当 `try` 的主体 $t_1$ 已经归约为一个值 $v_1$ 时，`try` 表达式不再需要捕获异常，结果就是 $v_1$。

  $$
  \text{try } v_1\ \text{with } t_2 \to v_1
  $$

  **解释**：如果 `try` 表达式中的主体 $t_1$ 已经求值为一个正常值，那么 `try` 的结果就是这个值，异常处理程序 $t_2$ 不会被调用。

  **例子**：

  ```racket
  (try (+ 2 3) with (lambda (e) (* e 2))) ; 结果为 5，不触发异常处理
  ```

- **E-TryRaise**：如果 `t_1` 求值为 `raise v_{11}`，则将异常信息 $v_{11}$ 传递给处理程序 $t_2$，并执行处理程序。

  $$
  \text{try } (\text{raise } v_{11})\ \text{with } t_2 \to t_2\ v_{11}
  $$

  **解释**：如果 `t_1` 求值过程中抛出了异常（即 `raise v_{11}`），`try` 捕获到异常后，处理程序 $t_2$ 会用异常值 $v_{11}$ 作为输入继续执行。

  **例子**：

  ```racket
  (try (raise 5) with (lambda (e) (* e 2))) ; 结果为 10，处理程序捕获异常并进行处理
  ```

#### 4. **E-Try**
在 `t_1` 被归约为值或 `raise` 之前，我们继续对 $t_1$ 进行求值，直到确定是否需要触发异常处理程序。

$$
  \frac{t_1 \to t_1'}{\text{try } t_1\ \text{with } t_2 \to \text{try } t_1'\ \text{with } t_2}
$$

  **解释**：在 `try` 表达式中，我们会持续对主体 $t_1$ 进行求值，直到它归约为值或 `raise`，这时再决定是否需要进入异常处理程序。

---

### 类型规则（Typing Rules）

#### 1. **T-Exn**
定义异常的类型规则，规定 `raise` 表达式可以在任何上下文中赋予任何类型。

$$
  \frac{\Gamma \vdash t_1 : \text{Texn}}{\Gamma \vdash \text{raise } t_1 : T}
$$

  **解释**：这里 $t_1$ 表示异常附带的信息，其类型必须是 `Texn`（异常类型），但是整个 `raise` 表达式可以被赋予上下文需要的任何类型 $T$。

  **例子**：

  ```racket
  (raise "error") ; 异常附带字符串信息，但表达式可以被赋予任何类型
  ```

#### 2. **T-Try**
定义 `try` 表达式的类型规则。`try` 的主体和处理程序必须返回相同类型。

$$
  \frac{\Gamma \vdash t_1 : T \quad \Gamma \vdash t_2 : \text{Texn} \to T}{\Gamma \vdash \text{try } t_1\ \text{with } t_2 : T}
$$

  **解释**：`t_1` 是正常情况下的表达式，其类型为 $T$。`t_2` 是处理异常的表达式，它是一个接受异常信息（类型为 `Texn`）的函数，返回值的类型也必须是 $T$。因此，无论是异常发生还是不发生，整个 `try` 表达式的结果类型都保持一致。

  **例子**：

  ```racket
  (try (raise 5) with (lambda (e) e)) ; 异常处理程序返回相同类型
  ```

---

### 总结

- **求值规则**：处理 `raise` 的求值规则通过传播异常信息来决定是否中止求值，或者进入异常处理程序。
- **类型规则**：`raise` 可以赋予任何上下文要求的类型，而 `try` 结构必须确保主体和处理程序的返回类型一致。

### ------------------------------

---

#### Texn 类型的替代方案

最后，让我们考虑 $\text{Texn}$ 类型的一些替代方案。

1. 🥑**将 $\text{Texn}$ 定义为 $Nat$**：

   - 这对应于 Unix 操作系统函数中使用的 $errno$ 约定：每个系统调用返回一个数字“错误代码”，其中 0 表示成功，其他值报告各种异常情况。

2. 🥑**将 $\text{Texn}$ 定义为 $String$**：

   - 这避免了在表中查找错误号码，并允许异常引发点在需要时构建更具描述性的消息。额外灵活性的代价是错误处理程序现在可能需要解析这些字符串以找出发生了什么。

3. 🥑**将 $\text{Texn}$ 定义为变体类型（variant type）**：

   - 定义：

     $$
     \text{Texn} = \langle \text{divideByZero} : \text{Unit},\ 
     \text{overflow} : \text{Unit},\ \text{fileNotFound} : \text{String},\ \text{fileNotReadable} : \text{String},\ \ldots \rangle
     $$

   - 这种方案允许处理程序使用简单的 $case$ 表达式来区分异常的种类。此外，不同的异常可以携带不同类型的附加信息：像 $divideByZero$ 这样的异常不需要额外的信息，$fileNotFound$ 可以携带一个字符串，指示发生错误时正在打开的文件，等等。

   - **问题**：这种替代方案相当不灵活，🥑要求我们预先确定任何程序可以引发的异常的完整集合（即变体类型 $\text{Texn}$ 的标签集合）。这为程序员声明特定于应用程序的异常留下了余地。

4. 🥑**将 $\text{Texn}$ 定义为可扩展的变体类型**：

   - 这种想法可以被改进，通过将 $\text{Texn}$ 定义为可扩展的变体类型，为用户定义的异常留出空间。ML 采用了这个想法，提供了一个称为 🥑$exn$ 的单个可扩展变体类型。

   - 在当前设置中，ML 中的声明 $exception l of T$ 可以理解为：“确保 $l$ 与 $\text{Texn}$ 中已存在的任何标签不同，并且从现在开始让 $\text{Texn}$ 为 $\langle l_1 : T_1, \ldots, l_n : T_n, l : T \rangle$，其中 $l_1 : T_1$ 到 $l_n : T_n$ 是此声明之前的可能变体。”

   - **注意**：由于 $exception$ 形式是一个绑定者，我们可以通过必要时对 $l$ 进行 $\alpha$-转换来确保它与 $\text{Texn}$ 中已使用的标签不同。

   - **引发异常的语法**：

     在 ML 中，引发异常的语法是 $raise l(t)$，其中 $l$ 是在当前作用域中定义的异常标签。这可以理解为标签操作符和我们的简单 $raise$ 的组合：

     $$
     \text{raise } l(t) \quad \text{定义为} \quad \text{raise } (\langle l = t \rangle \text{ as } \text{Texn})
     $$

   - **异常处理的语法**：

     类似地，ML 中的 $try$ 构造可以使用我们的简单 $try$ 加上 $case$ 来消糖（desugar）：

     $$
     \begin{align*}
     \text{try } t\ \text{with } l(x) \to h &\quad \text{定义为} \\
     \text{try } t\ \text{with } \lambda e:\text{Texn}.\ \text{case } e\ \text{of} \\
     &\quad \langle l = x \rangle \Rightarrow h \\
     &\quad | \_ \Rightarrow \text{raise } e
     \end{align*}
     $$

   - 该 $case$ 检查已引发的异常是否带有标签 $l$。如果是，它将异常携带的值绑定到变量 $x$ 并求值处理程序 $h$。如果不是，它将通过 $else$ 子句，重新引发异常。异常将继续传播（并可能被捕获和重新引发），直到它要么到达想要处理它的处理程序，要么到达顶层并中止整个程序。

5. **Java 的做法**：

   - Java 🥑使用类而不是可扩展的变体来支持用户定义的异常。语言提供了一个内置类 $Throwable$；$Throwable$ 或其任何子类的实例都可以在 $throw$（与我们的 $raise$ 相同）或 $try...catch$（与我们的 $try...with$ 相同）语句中使用。新的异常可以简单地通过定义 $Throwable$ 的新子类来声明。

   - 实际上，🥑这种异常处理机制与 ML 的机制之间存在密切的对应关系。大致来说，Java 中的异常对象在运行时由指示其类的标签（对应于 ML 中的可扩展变体标签）加上一组实例变量的记录（对应于由该标签标记的额外信息）来表示。

   - Java 异常在几个方面比 ML 更进一步。一方面是异常标签上有一个自然的偏序关系，由子类顺序生成。异常标签 $l$ 的处理程序实际上将捕获所有携带类 $l$ 或 $l$ 的任何子类的对象的异常。

   - 另一方面是 Java 区分了🥑异常（$Exception$ 的子类——$Throwable$ 的子类），应用程序可能希望捕获并尝试恢复，以及错误🥑（$Error$ 的子类——也是 $Throwable$ 的子类），指示严重的情况，通常应该终止执行。两者之间的关键区别在于类型检查规则，它要求方法显式地声明它们可能引发的异常（但不需要声明可能引发的错误）。



### Texn 类型的替代方案与对比

以下表格详细对比了几种处理异常的不同方式，涵盖了 Texn 类型的定义、它们的优缺点、以及在主流编程语言中的实现方式。

| 替代方案                                   | 定义方式                                                     | 优点                                                         | 缺点                                                   | 实现示例                                                     |
| ------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------ | ------------------------------------------------------------ |
| **1. Texn 定义为 Nat**                     | 使用自然数（整数）作为错误代码（类似于 Unix 的 `errno` 系统） | 简单易实现，开销小；错误码有规范                             | 错误信息不可读；需要查找错误码表                       | **C** 中的 `errno` 系统调用返回 `0` 表示成功，其他值表示不同错误：```c errno = 0; if (open("file.txt", O_RDONLY) == -1) { printf("Error code: %d\n", errno); }``` |
| **2. Texn 定义为 String**                  | 将错误信息以字符串形式传递                                   | 错误信息可读，便于用户理解和调试；灵活性高                   | 性能开销高；错误处理程序可能需要解析字符串，复杂度增加 | **Python** 中的异常机制：```python try: raise ValueError("Invalid input") except ValueError as e: print(e) # 输出 "Invalid input"``` |
| **3. Texn 定义为变体类型（variant type）** | 定义为具有不同标签的变体，每种异常携带不同的信息             | 异常类型明确，处理异常时易于区分类型；不同异常可携带不同类型的附加信息 | 需要预定义所有可能的异常；灵活性差，不适合扩展         | **OCaml** 中使用变体类型处理异常：```ocaml type texn = | DivideByZero | FileNotFound of string;; try ... with | DivideByZero -> ... | FileNotFound(f) -> ...``` |
| **4. Texn 定义为可扩展的变体类型**         | 使用可扩展变体类型，允许用户定义新的异常类型                 | 用户可以定义自己的异常，灵活性高；异常可以动态扩展，适应不同场景 | 实现稍复杂，需要处理异常标签冲突                       | **OCaml 或 ML**：```ocaml exception FileNotFound of string;; raise (FileNotFound "config.txt");;``` |
| **5. Java 的异常机制**                     | 使用类（$Throwable$）和子类来定义异常，并通过 `throw` 和 `catch` 捕获异常 | 强大且灵活，支持用户自定义异常；有内建的类层次结构，支持子类继承 | 比变体类型更复杂，性能稍差；需要显式声明异常           | **Java** 中的异常处理：```java try { throw new FileNotFoundException("File not found"); } catch (FileNotFoundException e) { System.out.println(e.getMessage()); }``` |

### 关键对比

- **灵活性**：`String` 和可扩展变体类型具有最高的灵活性。用户可以在运行时动态生成或扩展异常信息。而像 `Nat` 和普通的变体类型相对固定，难以扩展。
- **性能**：`Nat` 的性能最好，因为它只需要处理数字，没有复杂的字符串解析或类继承问题。而 `String` 的开销最大，尤其是在传递长字符串或进行复杂解析时。
- **类型安全性**：`变体类型` 和 `可扩展变体类型` 能提供最强的类型安全性，因为它们能精确描述每种异常的信息类型。`String` 和 `Nat` 由于不包含额外的类型信息，因此缺乏这种安全性。
- **易于实现**：`Nat` 和 `String` 是最简单的实现方式，但它们在灵活性和可读性上有较大限制。`变体类型` 和 `Java 的类层次结构` 则复杂度较高，但适合构建大型应用。

### 语言实现

- **C 的 errno** 使用 `Nat` 类型简单标记错误，但缺乏灵活性。
- **Python** 和 **Java** 的异常机制使用 `String` 或自定义类，让异常处理更加直观和灵活。
- **ML 和 OCaml** 的变体类型提供了异常类型的明确定义，并且可扩展变体类型允许动态扩展和自定义异常。

### 总结

不同的异常处理方式各有优缺点，实际选择取决于编程语言的特性以及具体的应用需求。例如，系统编程中可能更青睐于 `Nat` 型错误码，而高层应用开发可能会使用 `String` 或类层次结构来传递更为丰富的错误信息。

### ----------------------------------------

### OCaml 系列（ML 系）的异常处理设计

#### 1. **异常的基本设计**

在 OCaml 和 ML 系列的语言中，异常通过一种轻量级的、灵活的机制实现，允许程序员在程序执行过程中引发和处理异常。异常的定义和使用类似于普通的函数和数据类型，因此具有较高的灵活性。

- **异常定义**：
  OCaml 中的异常定义通过 `exception` 关键字，可以携带额外的数据，例如：

  ```ocaml
  exception DivideByZero;;
  exception FileNotFound of string;;
  ```

  - `DivideByZero` 是一个不携带信息的异常。
  - `FileNotFound` 携带了一个字符串作为额外的错误信息。

- **引发异常**：
  异常通过 `raise` 语句引发。例如：

  ```ocaml
  let divide x y =
    if y = 0 then raise DivideByZero
    else x / y;;
  ```

  如果在 `y = 0` 时调用 `divide` 函数，就会引发 `DivideByZero` 异常。

- **处理异常**：
  异常通过 `try...with` 结构捕获处理：

  ```ocaml
  let safe_divide x y =
    try divide x y with
    | DivideByZero -> "Cannot divide by zero";;
  ```

  这段代码尝试捕获 `DivideByZero` 异常，并返回相应的错误消息。

#### 2. **灵活性与类型系统的结合**

OCaml 的异常处理机制非常灵活，允许用户定义自定义异常并传递任意类型的信息。异常本质上是一种 **可扩展的变体类型**。在 OCaml 中，异常是具有类型的，但不像函数参数和返回值那样强制进行类型检查。这意味着引发的异常可以携带任意类型的信息。

- 由于异常是一种 **变体类型**，不同的异常可以携带不同类型的附加信息。例如：

  ```ocaml
  exception FileNotFound of string;;
  exception Overflow of int;;
  ```

  - `FileNotFound` 携带字符串信息。
  - `Overflow` 携带整数信息。

- 异常处理程序使用 **模式匹配** 来区分和捕获不同的异常类型。

#### 3. **可扩展变体类型**

OCaml 的异常处理机制之所以灵活，是因为它支持 **可扩展的变体类型**。这意味着你可以在程序运行时动态地增加新的异常类型，不需要事先定义所有可能的异常。这种扩展性通过 `exception` 语法提供，允许定义新的异常类型并随时使用。

- **示例**：

  ```ocaml
  exception InvalidArgument of string;;
  
  let parse_int s =
    try int_of_string s with
    | Invalid_argument _ -> raise (InvalidArgument "Invalid integer");;
  ```

  这里我们捕获了内置的 `Invalid_argument` 异常，并重新引发自定义的 `InvalidArgument` 异常，携带具体的错误信息。

#### 4. **性能考虑**

OCaml 的异常机制相对轻量，适合用于处理少量的异常。与其他语言相比，OCaml 的异常在性能上有很好的表现，因为它不强制进行复杂的类型检查，也不引入复杂的控制流结构。

### Java 系列的异常处理设计

#### 1. **异常的基本设计**

Java 的异常处理设计与 OCaml 系列有很大不同，采用了基于 **类继承** 的结构。Java 中的异常是 `Throwable` 类的实例。异常分为两大类：

- **已检查异常（Checked Exceptions）**：必须在代码中显式声明和处理的异常，继承自 `Exception`。
- **未检查异常（Unchecked Exceptions）**：在运行时可能发生，但不要求显式处理，继承自 `RuntimeException`。

#### 2. **异常定义**

在 Java 中，定义异常通常通过继承 `Exception` 或 `RuntimeException` 类来实现。程序员可以通过定义自定义异常类，传递更丰富的信息。

```java
class FileNotFoundException extends Exception {
    public FileNotFoundException(String message) {
        super(message);
    }
}
```

这里，我们定义了一个自定义的 `FileNotFoundException`，继承自 `Exception`，并允许通过构造函数传递错误信息。

#### 3. **引发异常**

Java 使用 `throw` 语句引发异常：

```java
public void readFile(String filename) throws FileNotFoundException {
    if (filename == null) {
        throw new FileNotFoundException("File not found: " + filename);
    }
    // 读取文件逻辑
}
```

这里我们在 `readFile` 函数中通过 `throw` 引发了自定义异常。

#### 4. **处理异常**

Java 中使用 `try...catch...finally` 结构来捕获和处理异常：

```java
try {
    readFile("config.txt");
} catch (FileNotFoundException e) {
    System.out.println(e.getMessage());
}
```

- **`finally` 块**：无论是否发生异常，`finally` 块中的代码都会被执行，用于释放资源。

```java
try {
    // 打开文件
} finally {
    // 关闭文件
}
```

#### 5. **已检查与未检查异常的区别**

Java 将异常分为已检查和未检查的关键区别在于：已检查异常在编译时强制处理，而未检查异常可以在运行时处理。

- **已检查异常**：需要在方法签名中声明，例如 `throws FileNotFoundException`。这些异常通常表示应用程序可以预料的错误。

- **未检查异常**：继承自 `RuntimeException`，常用于编程错误（如空指针异常）。开发者可以选择不处理这些异常。

#### 6. **性能与类型检查**

与 OCaml 不同，Java 强制进行严格的类型检查，所有已检查异常都必须被显式处理或声明。虽然这提高了程序的可靠性，但也增加了开发者的负担，尤其是在处理较多异常的代码中。此外，Java 的异常捕获机制比 OCaml 要复杂一些，特别是在处理嵌套的异常块时，可能带来性能开销。

#### 7. **面向对象的异常处理机制**

Java 的异常机制与其面向对象设计紧密结合，允许开发者使用类继承来构建异常层次结构。例如，可以定义多个自定义异常类，分别继承自不同的父类，这样的层次结构为异常处理提供了很大的灵活性。

```java
class DataFormatException extends Exception {}
class CSVFormatException extends DataFormatException {}
class JSONFormatException extends DataFormatException {}
```

- 使用多态特性，开发者可以捕获 `DataFormatException` 并处理所有数据格式相关的异常，或者捕获具体的 `CSVFormatException` 或 `JSONFormatException` 进行特定处理。

#### 8. **优点与缺点**

| **特性**     | **Java 系列**                                                | **ML/OCaml 系列**                                |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------ |
| **灵活性**   | 使用类层次结构，可定义复杂的异常类型，但需声明已检查异常     | 使用可扩展的变体类型，灵活性高，动态添加异常     |
| **性能**     | 编译时强制处理已检查异常，运行时处理未检查异常；性能较 OCaml 稍差 | 异常处理较轻量，灵活性高，适合高效运行时异常处理 |
| **类型系统** | 强制类型检查，已检查异常需显式声明                           | 异常是一种可扩展的变体类型，灵活且类型检查宽松   |
| **适用场景** | 适合大型、面向对象的应用程序，特别是需要严格异常处理的场景   | 适合函数式编程场景，允许灵活定义和处理异常       |

### 总结

- **OCaml** 的异常机制使用可扩展变体类型，允许在程序运行时动态添加新的异常类型，并通过模式匹配捕获和处理异常。这种设计使得异常处理灵活、轻量，适用于函数式编程。
  
- **Java** 的异常处理通过类继承和强制类型检查，提供了面向对象的异常层次结构。Java 的已检查异常设计保证了程序的类型安全性和健壮性，但在开发过程中可能会增加代码复杂度和性能开销。

两种机制各有优缺点，OCaml 系列更加灵活和高效，适合追求简洁和高效的场景，而 Java 系列则提供了更强的类型安全性和面向对象的支持，适合构建大型、复杂的系统。



### ----------------------------------------

---

**练习 14.3.1** [«««]：上述替代方案4中对可扩展变体类型的解释相当🥑非正式。展示如何使其精确。

**解答**：

- 我们需要正式地定义可扩展变体类型的语法和类型规则。

- 首先，我们引入一种机制，允许我们在类型系统中动态地扩展变体类型 $\text{Texn}$。

- 定义一个初始的异常类型 $\text{Texn}_0$，它可能是空的或包含一些基本的异常标签。

- 每当我们声明一个新的异常时，例如 $exception l of T$，我们将类型 $\text{Texn}$ 扩展为包含新的标签：

  $$
  \text{Texn}_{n+1} = \text{Texn}_n + \langle l : T \rangle
  $$

- 在类型系统中，我们需要确保在类型检查时知道当前的异常类型包含哪些标签。这可能需要类型环境中携带异常类型的信息。

- 我们需要定义引发异常和处理异常的类型规则，使其依赖于当前的异常类型。

- **引发异常的类型规则**：

  $$
  \frac{\Gamma \vdash t : T \quad l : T \in \text{Texn}}{\Gamma \vdash \text{raise } l(t) : S}
  $$

  - 其中 $l : T$ 是当前异常类型中的标签，$S$ 是任意类型。

- **处理异常的类型规则**：

  $$
  \frac{\Gamma \vdash t_1 : S \quad \Gamma \vdash t_2 : T \to S \quad l : T \in \text{Texn}}{\Gamma \vdash \text{try } t_1\ \text{with } l(x) \to t_2 : S}
  $$

  - 处理程序捕获标签为 $l$ 的异常，并将携带的值绑定到 $x$。

- 需要确保异常类型的扩展和作用域规则的正确性，以及类型安全性。

### -------------------------------------

### 详解：可扩展变体类型的形式化定义

为了精确地定义可扩展变体类型，我们需要正式地定义其语法和类型规则，并展示如何在类型系统中动态地扩展这些变体类型。以下是步骤详解：

#### 1. **初始的异常类型定义**

首先，我们定义一个基本的异常类型 $\text{Texn}_0$，它可能是空的，也可能包含一组初始的异常标签。我们将逐步扩展这个类型，以支持用户定义新的异常标签。

- **基础异常类型**：

  $$ \text{Texn}_0 = \emptyset $$

  或者，🥑🥑$\text{Texn}_0$ 也可以包含一些内置的异常标签：

  $$ \text{Texn}_0 = \langle \text{DivideByZero} : \text{Unit}, \ \text{NullPointer} : \text{Unit} \rangle $$

#### 2. **扩展变体类型**

每当声明一个新的异常标签时，我们通过在类型系统中 🥑🥑**动态地** 扩展变体类型来支持新的标签。假设当前的异常类型为 $\text{Texn}_n$，那么扩展后的异常类型 $\text{Texn}_{n+1}$ 是通过添加新的标签 $l$ 和对应的类型 $T$ 得到的：

$$ \text{Texn}_{n+1} = \text{Texn}_n + \langle l : T \rangle $$

- **例如**，如果我们声明 `exception FileNotFound of string`，那么异常类型将扩展为：

  $$ \text{Texn}_{n+1} = \text{Texn}_n + \langle \text{🥑FileNotFound} : \text{String} \rangle $$

在类型环境中，需要携带当前的异常类型 $\text{Texn}_n$ 的信息，以确保在类型检查过程中知道哪些异常标签是可用的。

#### 3. **引发异常的类型规则**

引发异常的类型规则需要确保当前环境中定义的异常标签可以被使用，并且引发的异常携带的信息类型与声明的异常标签类型一致。

- **引发异常的类型规则**：
$$
  \frac{\Gamma \vdash t : T \quad l : T \in \text{Texn}}{\Gamma \vdash \text{raise } l(t) : S} 
  $$
  
- 其中 $l : T$ 是当前异常类型 $\text{Texn}_n$ 中的标签。
  - $S$ 可以是任意类型，因为异常中止后不会返回具体的值。
  
- **例如**，如果当前类型环境包含 `FileNotFound : String`，我们可以引发异常：
  
  ```ocaml
    raise (FileNotFound "config.txt")
    ```
  
  在类型检查中，`FileNotFound : String` 将匹配异常标签，确保类型安全。

#### 4. **处理异常的类型规则**

处理异常的类型规则确保在捕获特定异常时，捕获的值类型与异常定义中携带的类型一致。处理程序可以使用该值，并且处理后的结果类型应与原始表达式类型一致。

- **处理异常的类型规则**：

  $$
  \frac{\Gamma \vdash t_1 : S \quad \Gamma \vdash t_2 : T \to S \quad l : T \in \text{Texn}}{\Gamma \vdash \text{try } t_1\ \text{with } l(x) \to t_2 : S}
  $$

  - 其中 $t_1$ 是可能引发异常的表达式，类型为 $S$。
  - $t_2$ 是处理程序，接受类型为 $T$ 的值，并返回类型为 $S$ 的结果。
  - $l : T$ 是异常类型中匹配的标签。

  - **例如**，捕获 `FileNotFound` 异常并处理：

    ```ocaml
    try read_file "config.txt" with
    | FileNotFound file_name -> Printf.printf "File not found: %s" file_name
    ```

    在此处，异常处理程序将 `FileNotFound` 标签携带的 `file_name` 字符串绑定，并进行相应处理。

#### 5. **作用域和扩展规则**

在动态扩展变体类型时，确保扩展后的异常类型仅在当前作用域内有效。新的异常标签只能在引发和捕获时使用。由于异常处理使用了模式匹配的方式，因此确保所有可能的异常情况都能被正确处理。

- 每次声明一个新的异常，都会扩展当前的异常类型并记录到类型环境中。
  
  - **示例**：

    ```ocaml
    exception MyError of int;;
    let risky_function x = 
      try if x = 0 then raise (MyError 42) 
      else x 
      with MyError n -> Printf.printf "Caught MyError: %d" n
    ;;
    ```

#### 6. **确保类型安全性**

类型安全性是通过以下方式确保的：
1. **引发异常的类型**：引发的异常类型必须在当前异常类型环境中声明，且🥑携带的数据类型必须与声明类型一致。
2. **处理异常的类型**：处理程序捕获的异常类型必须与引发的异常类型匹配，🥑同时处理后的结果类型必须与原始表达式类型一致。
3. **扩展的合理性**：每次声明新的异常时，类型系统能够动态扩展异常类型，🥑并确保在使用异常标签时遵循扩展后的类型规则。

#### 7. **总结：可扩展变体类型的正式化**

- **变体类型扩展**：通过添加新的异常标签和对应的类型来扩展异常类型。
- **引发异常的类型规则**：确保引发的异常符合当前类型环境中的标签和类型。
- **处理异常的类型规则**：处理程序通过模式匹配捕获异常，确保异常处理逻辑安全且类型一致。

可扩展变体类型通过允许动态添加新标签和类型，提高了异常处理的灵活性。ML 系列语言通过这种机制实现了高效的异常处理，并为用户定义自定义异常提供了强大的支持。

### ---------------------------------------

---

**练习 14.3.2** [««««]：我们在上面注意到，Java 异常（那些是 $Exception$ 的子类）比 ML 中的异常（或我们在这里定义的异常）受到更严格的控制：一个方法可能引发的每个异常都必须在方法的类型中声明。扩展你对练习14.3.1的解答，使得函数的类型不仅指示其参数和结果类型，还指示它可能引发的异常集。证明你的系统是类型安全的。

**解答**：

- 我们需要为函数类型添加异常集的信息。

- **函数类型的扩展**：

  $$
  T = T_1 \xrightarrow{E} T_2
  $$

  - 其中 $E$ 是该函数可能引发的异常🥑标签的集合。

- **类型规则的修改**：

  - **函数抽象（lambda）的类型规则**：

    $$
    \frac{\Gamma, x:T_1 \vdash t : T_2 \quad E = E_t}{\Gamma \vdash \lambda x:T_1.\ t : T_1 \xrightarrow{E} T_2}
    $$

    - 其中 $E_t$ 是在 $t$ 中可能引发的异常集。

  - **函数应用的类型规则**：

    $$
    \frac{\Gamma \vdash t_1 : T_{11} \xrightarrow{E_1} T_{12} \quad \Gamma \vdash t_2 : T_{11}}{\Gamma \vdash t_1\ t_2 : T_{12} \quad E = E_1 \cup E_{t_2}}
    $$

    - 其中 $E_{t_2}$ 是 $t_2$ 中可能引发的异常集。

- **类型安全性的证明**：

  - 🥑我们需要证明在我们的类型系统中，程序不会发生未捕获的异常，🥑即所有可能引发的异常都在类型中显式声明，并被正确地处理或传播。

  - 证明涉及到对求值的归纳，以及类型系统中异常集的信息正确传播。

### --------------------------------

### Java 异常控制扩展系统的详解

在这一部分，我们将扩展函数的类型系统，使得它们不仅包含参数和返回值的类型信息，还能够指示函数可能引发的异常集。我们将设计新的类型规则来支持这一扩展，并证明该系统的类型安全性。

#### 1. **函数类型的扩展**

在标准的类型系统中，函数的类型是从参数类型映射到结果类型的简单映射：

$$
T = T_1 \to T_2
$$

为了支持对异常的控制扩展，我们为🥑函数类型添加🥑异常集的信息。我们可以表示一个可能引发异常的函数类型如下：

$$
T = T_1 \xrightarrow{E} T_2
$$

- $T_1$ 是函数的参数类型。
- $T_2$ 是函数的返回类型。
- $E$ 是该函数可能引发的异常集，🥑$E$ 中的元素是异常标签。

#### 2. **类型规则的修改**

##### 2.1. **函数抽象（lambda）的类型规则**

在我们现有的 $\lambda$ 演算的基础上，函数类型现在不仅表示参数和返回类型，还必须记录函数体中可能引发的异常集。

**函数抽象的类型规则**：

$$
\frac{\Gamma, x:T_1 \vdash t : T_2 \quad E = E_t}{\Gamma \vdash \lambda x:T_1.\ t : T_1 \xrightarrow{E} T_2}
$$

- $\Gamma$ 是类型环境，表示已知的变量及其类型。
- $x:T_1$ 表示参数 $x$ 的类型是 $T_1$。
- $t : T_2$ 表示函数体 $t$ 的类型是 $T_2$。
- 🥑$E = E_t$ 是函数体 $t$ 中可能引发的异常集。
- 结果是一个🥑从 $T_1$ 到 $T_2$ 的函数类型，并且该函数可能引发的异常集是 $E$。

##### 2.2. **函数应用的类型规则**

函数应用时，除了检查参数和返回值类型的一致性外，我们还需要合并函数本身及其参数中可能引发的异常集。

**函数应用的类型规则**：

$$
\frac{\Gamma \vdash t_1 : T_{11} \xrightarrow{E_1} T_{12} \quad \Gamma \vdash t_2 : T_{11}}{\Gamma \vdash t_1\ t_2 : T_{12} \quad E = E_1 \cup E_{t_2}}
$$

- $t_1$ 是一个函数，其类型为 $T_{11} \xrightarrow{E_1} T_{12}$，即它接受一个参数类型为 $T_{11}$，返回类型为 $T_{12}$，并可能引发异常集 $E_1$。
- $t_2$ 是参数，其类型为 $T_{11}$，可能引发的异常集为 $E_{t_2}$。
- 函数应用的结果类型为 $T_{12}$，并且它可能引发的异常集为 $E_1 \cup E_{t_2}$，即函数本身和参数中所有可能的异常。

#### 3. **异常处理的类型规则**

当一个函数在执行过程中引发异常时，类型系统确保这些异常要么被捕获并处理，要么被显式声明为可能引发的异常。

##### 3.1. **异常处理的类型规则**

在 `try...catch` 结构中，如果一个函数引发了异常，它可以通过🥑🥑🥑匹配相应的异常标签并执行处理程序来捕获和处理该异常。

**异常处理的类型规则**：

$$
\frac{\Gamma \vdash t_1 : S \quad \Gamma \vdash t_2 : \text{Texn} \to S \quad l : T \in \text{Texn}}{\Gamma \vdash \text{try } t_1\ \text{with } l(x) \to t_2 : S}
$$

- $t_1$ 是可能引发异常的表达式，其类型为 $S$。
- $t_2$ 是异常处理程序，接受类型为 $T$ 的异常，并返回类型为 $S$ 的结果。
- $l : T$ 是异常类型系统中的标签，表示可能引发的异常类型。

#### 4. **类型安全性的证明**

##### 4.1. **目标**

我们需要证明的是，在引入了异常类型集扩展后，系统仍然是类型安全的。这意味着任何可能引发的异常都应在类型中显式声明，并且异常处理程序能够正确捕获和处理这些异常。

##### 4.2. **证明思路**

- 我们通过对求值和类型检查进行归纳证明。
- 在类型规则中，每次引发异常时，类型系统会确保该异常存在于异常集 $E$ 中。如果没有合适的处理程序，则异常会继续传播，直到遇到处理程序或程序终止。
- 在异常处理规则中，处理程序的类型必须匹配异常的标签及其携带的数据类型，确保异常能够正确处理。
- **关键点**：我们确保每次函数调用和异常传播中，可能引发的异常集都被精确地追踪并传递给下一级求值规则。

##### 4.3. **类型安全性定理**

**定理**（类型安全性）：如果 $\Gamma \vdash t : T \xrightarrow{E} S$，并且 $t$ 在求值过程中引发异常，那么该异常必须存在于 $E$ 中，并且处理程序能够正确处理该异常。

#### 5. **扩展练习：Java 异常机制中的类型安全**

Java 中的异常处理机制与我们扩展的类型系统有很多相似之处。Java 强制要求每个方法必须声明它可能抛出的异常（通过 `throws` 关键字），这与我们为函数类型添加异常集的做法非常类似。

- **Java 中的函数类型扩展**：

  - **声明异常**：

    ```java
    public void foo() throws IOException {
      // 函数体
    }
    ```

    在 Java 中，函数 `foo` 必须声明它可能抛出的异常 `IOException`，这与我们系统中的异常集声明一致。

- **Java 中的异常处理**：

  - **处理异常**：

    ```java
    try {
      foo();
    } catch (IOException e) {
      e.printStackTrace();
    }
    ```

    Java 的异常处理机制要求处理程序匹配引发的异常，并在处理程序中处理或传播异常。

#### 6. **总结**

我们扩展了函数类型系统，使其能够捕获和处理可能引发的异常集。这种设计增强了类型安全性，确保所有可能引发的异常在系统中显式声明，并得到适当的处理。这种机制与 Java 的异常处理模型非常相似，但通过在类型系统中引入异常集信息，使得异常处理更加灵活和精确。

### ---------------------------------

---

**练习 14.3.3** [«««]：许多其他控制构造可以使用与本章中我们所见类似的技术来形式化。熟悉 🥑Scheme 的“带🥑当前连续体的调用”（call/cc）操作符的读者（参见 Clinger, Friedman, and Wand, 1985; Kelsey, Clinger, and Rees, 1998; Dybvig, 1996; Friedman, Wand, and Haynes, 2001）可能会尝试基于🥑类型 $\text{Cont } T$ 的 $T$-连续体（即，期望类型为 $T$ 的参数的连续体）来制定类型规则。

**解答**：

- **call/cc** 是一种强大的控制操作符，允许程序捕获当前的计算上下文（连续体）并在以后恢复。

- 为了制定类型规则，我们可以引入一个新的🥑类型构造 $\text{Cont } T$，表示🥑期望类型为 $T$ 的参数的连续体。

- **call/cc 的类型规则**：

  $$
  \frac{\Gamma \vdash t : \text{Cont } T \to T}{\Gamma \vdash \text{call/cc } t : T}
  $$

- **连续体捕获的类型规则**：

  - 我们需要定义一个操作，使得在调用时，可以将当前的连续体作为参数传递给一个函数。

- **类型安全性的证明**：

  - 由于 call/cc 改变了程序的控制流，我们需要小心处理类型系统中的保证，以确保类型安全性。

- **进一步阅读**：

  - 读者可以参考相关文献，了解如何在类型系统中正确地处理 call/cc 和连续体的类型。

---

### 总结

通过本章的学习，我们了解了如何将异常机制添加到简单类型 $\lambda$ 演算中，以及如何设计求值规则和类型规则来处理异常的引发和捕获。我们讨论了异常的多种实现方式，包括携带值的异常、可扩展的异常类型，以及在编程语言中的具体实现（如 ML 和 Java）。同时，我们还探讨了异常对类型安全性的影响，以及如何在类型系统中准确地描述和处理异常。

### ---------------------------

### 详解：基于 `call/cc` 的类型系统

#### 1. **什么是 `call/cc`？**

`call/cc`（`call with current continuation`，带当前连续体的调用）是 Scheme 中一种强大的控制构造，它允许程序捕获当前的计算上下文（即，程序的后续执行状态）并将其作为函数传递。通过这种方式，程序可以在将来的某个时间点恢复该上下文，就像倒带程序的执行。

- **连续体（continuation）**：是程序从某个特定点开始到最终结束的计算步骤。`call/cc` 操作符通过捕获这一连续体并允许我们在将来任意位置恢复这一状态，从而实现非本地的控制转移。

#### 2. **定义连续体类型：$\text{Cont } T$**

为了在类型系统中引入 `call/cc`，我们首先需要定义与连续体相关的类型规则。我们可以定义一个新的类型构造 **$\text{Cont } T$**，表示**期望返回类型为 $T$ 的连续体**。

- $\text{Cont } T$ 类型的含义是：这是一个期望类型为 $T$ 的函数，它捕获当前的程序状态（上下文）并在以后可以恢复该状态。
- **直观理解**：$\text{Cont } T$ 是一个将当前上下文作为参数的高阶函数，可以理解为一个“程序状态快照”。

#### 3. **`call/cc` 的类型规则**

当我们引入 `call/cc` 作为一种操作符时，类型系统需要捕捉其行为。通过 `call/cc`，我们能够捕获当前的连续体并将其作为参数传递给一个函数，因此其类型规则应该如下：

$$
\frac{\Gamma \vdash t : \text{Cont } T \to T}{\Gamma \vdash \text{call/cc } t : T}
$$

- **解释**：
  - $t : \text{Cont } T \to T$：$t$ 是一个函数，接受一个类型为 $\text{Cont } T$ 的连续体，并返回类型 $T$ 的值。
  - $\text{call/cc } t : T$：应用 `call/cc` 后的结果是一个类型为 $T$ 的值。

在这个类型规则中，`call/cc` 操作符接收一个函数 $t$，该函数期望接收一个连续体作为参数，并在之后返回类型 $T$ 的值。

#### 4. **连续体捕获的类型规则**

`call/cc` 之所以特别，是因为它捕获当前的计算状态作为一个“值”传递给某个函数。因此，连续体本质上是一种特定类型的函数，它的类型可以通过 $\text{Cont } T$ 来表达：

- **捕获当前的连续体**：捕获的连续体的类型是 $T \to \text{Void}$，这意味着这个函数接收一个类型为 $T$ 的值，并且一旦调用它，它会替代当前的执行路径。

- 🥑🥑🥑当调用连续体时，当前的程序状态会被替换为捕获时的状态。这种捕获和恢复机制类似于一种非本地的跳转。

#### 5. **类型安全性的证明**

在设计这种操作时，关键在于证明 **类型安全性**：即 `call/cc` 的🥑引入不会破坏程序的类型一致性。

##### **证明思路**：

1. **捕获连续体的安全性**：
   - 当我们捕获连续体时，我们需要确保该连续体的类型与函数的🥑期望类型一致。`call/cc` 操作符会确保捕获的连续体类型匹配，并将其作为函数的输入传递。

2. **应用连续体的安全性**：
   - 当捕获的连续体被调用时，它应该恢复到之前的程序状态，并返回类型 $T$ 的值。为了保证类型安全性，类型系统需要确保所有对连续体的调用都符合其返回类型 $T$。

3. **非本地控制转移的安全性**：
   - 在 `call/cc` 操作下，程序的控制流可以🥑非本地地跳转。因此，类型系统必须确保这种跳转不会引入类型不一致性。通过捕获连续体并严格限制其调用，我们能够确保类型安全性。

#### 6. **进一步阅读与参考**

对于感兴趣的读者，以下是一些参考文献，这些文献详细讨论了 Scheme 中的 `call/cc` 操作符及其类型系统中的处理：

- **Clinger, Friedman, and Wand (1985)**：讨论了 Scheme 中的连续体和 `call/cc` 操作符。
- **Kelsey, Clinger, and Rees (1998)**：Scheme 语言的标准文档，详细描述了 `call/cc` 的语义。
- **Friedman, Wand, and Haynes (2001)**：关于控制流和连续体的进一步研究。

通过这些参考文献，读者可以更深入地理解如何在类型系统中形式化处理 `call/cc` 操作符。

### ----------------------------

### 详解：本地跳转与非本地跳转

#### 1. **本地跳转（Local Jumps）**

本地跳转指的是**在同一个作用域或控制结构中跳转到某个已知的目标位置**。这种跳转通常是程序执行过程中对控制流的局部调整，它不会离开当前的作用域或栈帧。常见的本地跳转有以下几种：

- **`break`**、**`continue`**：在循环控制结构中跳转到某个位置。
  - `break`：退出当前循环。
  - `continue`：跳到下一次循环迭代的开始。
- **`goto`**（少见）：有些语言（如 C）允许直接跳转到代码中的特定标签（尽管这种做法不鼓励）。
  
##### **示例：本地跳转**

```c
for (int i = 0; i < 10; i++) {
    if (i == 5) break;  // 跳出循环
}
```

- 这种 `break` 跳转仅发生在当前的循环结构内，不会超出其作用域。

#### 2. **非本地跳转（Non-local Jumps）**

**非本地跳转**指的是**控制流在程序中的某个位置跳转到另一个远离当前位置的目标**，这个目标可能在更高层的调用栈上或完全不同的作用域内。非本地跳转往往会导致函数执行中断，甚至离开当前调用栈，跳到上层的上下文。

非本地跳转的典型用途包括：

- **异常处理**：当程序运行时遇到错误，通过抛出异常跳出当前的函数调用栈并寻找相应的异常处理程序。例如，Java 中的 `throw` 和 `try-catch` 机制。
- **`setjmp`/`longjmp`**：C 语言中提供的一种非本地跳转机制，可以直接在栈帧之间跳转。`setjmp` 保存当前的程序状态，`longjmp` 恢复到之前的 `setjmp` 所保存的状态。
- **`call/cc`**：Scheme 中的 `call/cc` 允许捕获当前的程序状态（称为连续体），并在未来的某个时刻恢复该状态，这也是一种非本地跳转。

##### **示例：非本地跳转**

```java
try {
    // 可能抛出异常的代码
    throw new Exception("An error occurred");
} catch (Exception e) {
    // 处理异常
    System.out.println(e.getMessage());
}
```

- 这里的 `throw` 将当前的控制流从异常抛出点非本地跳转到 `catch` 块。这种跳转不仅离开了当前的作用域，还可能跨越多个栈帧。

#### 3. **本地跳转 vs 非本地跳转**

| **特性**         | **本地跳转**                                     | **非本地跳转**                                               |
| ---------------- | ------------------------------------------------ | ------------------------------------------------------------ |
| **跳转范围**     | 发生在同一个函数或作用域内，局部跳转。           | 可以跨越多个栈帧，跳出当前函数或作用域。                     |
| **跳转类型**     | `break`, `continue`, `goto` 等。                 | 异常处理（`throw`），`setjmp`/`longjmp`，`call/cc` 等。      |
| **栈影响**       | 控制流在当前作用域内移动，不涉及栈的深层次改变。 | 栈帧可能会被跳过，甚至弹出，涉及程序的非本地控制流变化。     |
| **常见用途**     | 循环控制、局部异常处理。                         | 错误处理、非本地异常处理、控制流的捕获和恢复（如 `call/cc`）。 |
| **典型语言示例** | C 中的 `break`，`continue`。                     | Java 的异常处理，Scheme 的 `call/cc`。                       |

#### 4. **非本地跳转的详细机制**

##### **异常处理**

非本地跳转的常见用途之一是异常处理。在大多数编程语言中，异常处理机制会抛出错误（如 Java 的 `throw`），并跳过当前的代码块，寻找合适的异常处理程序。

##### **Scheme 中的 `call/cc`**

`call/cc` 是 Scheme 中的一种复杂控制流构造，它允许程序捕获当前的执行上下文（称为“连续体”）并在将来恢复该上下文。

- 这种机制的实现涉及到栈帧的捕获和跳转，即当调用连续体时，程序的控制流会返回到捕获该连续体时的状态。

```scheme
(define (example)
  (call/cc (lambda (k)
    (k 42) ; 这里进行非本地跳转，返回42
    (display "This will not be printed"))))
```

- 在这个例子中，`k` 是捕获的当前连续体。当 `k` 被调用时，控制流会跳回到 `call/cc` 捕获连续体的地方，并返回结果 `42`，跳过了后面的代码。

#### 5. **总结**

- **本地跳转**：局部的控制流变化，通常用于简单的流程控制，不会影响整个程序的执行路径。
- **非本地跳转**：涉及更复杂的控制流变化，如异常处理、栈帧的回溯与跳转，通常用于处理错误或控制流捕获的高级操作。

### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------
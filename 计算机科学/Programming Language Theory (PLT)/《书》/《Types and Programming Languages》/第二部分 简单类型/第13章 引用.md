[toc]



**第13章 引用（References）**

到目前为止，我们已经讨论了各种纯语言特性，包括函数抽象（functional abstraction）、基本类型（basic types）如数字和布尔值，以及结构类型（structured types）如记录（records）和🥑变体（variants）。这些特性构成了大多数编程语言的骨干，包括纯函数式语言如 Haskell、“主要是函数式”的语言如 ML、命令式语言如 C，以及面向对象语言如 Java。

大多数实用的编程语言还包括各种🥑**非纯的特性**（impure features），这些特性无法用我们目前使用的简单语义框架来描述。特别地，除了产生结果外，这些语言中的🥑项的求值可能会对可变变量进行赋值（mutable variables，如引用单元 reference cells、数组 arrays、可变记录字段 mutable record fields 等），对文件、显示器或网络连接进行输入输出（I/O），通过异常（exceptions）、跳转（jumps）或连续体（continuations）进行非本地控制转移，进行进程间的同步和通信，等等。在编程语言的文献中，这些计算的“副作用”更一般地称为🥑🥑🥑🥑🥑🥑**计算效应**（computational effects）。

在本章中，我们将看到一种计算效应——🥑🥑🥑🥑**可变引用**（mutable references）——如何添加到我们已经研究的演算中。主要的扩展将是显式地处理存储器（store，也称为堆 heap）。这个扩展的定义是直接的；最有趣的部分是我们需要对类型保持定理（type preservation theorem，13.5.3）进行🥑细化。我们将在第14章讨论另一种效应——🥑🥑异常（exceptions）和🥑🥑🥑非本地控制转移。

---

### 13.1 引言（Introduction）

几乎每种编程语言都提供了一种赋值操作（assignment operation），用于改变先前分配的存储空间的内容。

**注**：本章研究的系统是带有 Unit 和引用（References，见图13-1）的简单类型 $\lambda$ 演算（simply typed lambda-calculus）。关联的 OCaml 实现是 $fullref$。

**绑定（Binding）**和**赋值（Assignment）**的机制在一些语言中（特别是 ML 及其相关语言）是分开的。我们可以有一个变量 $x$，其值是数字 $5$；或者一个变量 $y$，其值是指向一个当前内容为 $5$ 的可变单元（mutable cell）的**引用（reference）**（或指针 pointer）。这个区别对于程序员是可见的。我们可以将 $x$ 加到另一个数字上，但不能对它赋值。我们可以直接使用 $y$ 给它指向的单元赋予一个新值（通过写作 $y := 84$），但不能直接将其作为 $plus$ 的参数。相反，我们必须显式地对其解引用（dereference），写作 $!y$ 来获得其当前内容。在大多数其他语言中，特别是在所有 C 家族的成员（包括 Java）中，每个变量名都引用一个可变单元，对变量进行解引用以获取其当前内容的操作是**隐式的**。

**重要提示**：严格来说，在 C 或 Java 中，类型为 $T$ 的大多数变量实际上应该被视为指向包含类型为 $\text{Option}(T)$ 的值的单元的指针，反映了变量的内容可以是一个正常值或特殊值 $null$。

**对于形式化的研究**，将这些机制分开是有用的；我们的发展将紧密遵循 ML 的模型。将这里学到的经验应用到类似 C 的语言上，只需简单地合并一些区别，并将某些操作（如解引用）从显式变为隐式即可。

#### 基础

引用的基本操作是**分配（allocation）**、**解引用（dereferencing）**和**赋值（assignment）**。要分配一个引用，我们使用 $ref$ 操作符，提供新单元的初始值。

```haskell
r = ref 5;
⊢ r : Ref Nat
```

类型检查器的响应表明，$r$ 的值是一个引用，指向一个总是包含数字的单元。要读取该单元的当前值，我们使用解引用操作符 $!$。

```haskell
!r;
⊢ 5 : Nat
```

要改变存储在该单元中的值，我们使用赋值操作。

```haskell
r := 7;
⊢ unit : Unit
```

**注意**：赋值的结果是平凡的 $unit$ 值（参见第11.2节）。如果我们再次解引用 $r$，我们会看到更新后的值。

```haskell
!r;
⊢ 7 : Nat
```

#### 副作用和序列化（Side Effects and Sequencing）

赋值表达式的结果是平凡的值 $unit$，这与第11.3节定义的序列化符号非常契合，允许我们写作：

```haskell
(r := succ(!r); !r);
⊢ 8 : Nat
```

而不是等价但更繁琐的：

```haskell
(λ_:Unit. !r) (r := succ(!r));
⊢ 9 : Nat
```

来按顺序求值两个表达式并返回第二个表达式的值。将第一个表达式的类型限制为 $Unit$ 有助于类型检查器捕获一些愚蠢的错误，因为它允许我们仅在确实保证值是平凡的情况下丢弃第一个值。

注意，如果第二个表达式也是一个赋值，那么整个序列的类型将是 $Unit$，因此我们可以合法地将其放在另一个 $;$ 的左侧，构建更长的赋值序列：

```haskell
(r := succ(!r); r := succ(!r); r := succ(!r); r := succ(!r); !r);
⊢ 13 : Nat
```

#### 引用和别名（References and Aliasing）

牢记绑定到 $r$ 的🥑**引用**与该引用指向的存储器中的**单元**之间的区别是很重要的。

```haskell
[图示：r 指向一个值为 13 的存储单元]
```

如果我们复制 $r$，例如将其值绑定到另一个变量 $s$：

```haskell
s = r;
⊢ s : Ref Nat
```

那么被复制的只是引用（图中的箭头），而不是单元：

```haskell
[图示：r 和 s 都指向值为 13 的同一存储单元]
```

我们可以通过对 $s$ 进行赋值来验证这一点：

```haskell
s := 82;
⊢ unit : Unit
```

并通过 $r$ 读取它：

```haskell
!r;
⊢ 82 : Nat
```

引用 $r$ 和 $s$ 被称为指向同一单元的**别名（aliases）**。

**练习 13.1.1** [«]：画出类似的图示，展示计算表达式 $a = {ref 0, ref 0}$ 和 $b = (λx:Ref Nat. {x,x}) (ref 0)$ 的效果。

**解答**：

1. 对于 $a = {ref 0, ref 0}$：

   - $ref 0$ 被计算两次，产生两个不同的引用，分别指向两个不同的存储单元，初始值都是 $0$。

   ```haskell
   [图示]
   a = { l1, l2 }
   l1 指向 0
   l2 指向 0
   ```

2. 对于 $b = (λx:Ref Nat. {x,x}) (ref 0)$：

   - $ref 0$ 只被计算一次，产生一个引用 $l$，传递给函数，函数返回 ${x, x}$，即 ${l, l}$，两个字段都引用同一个存储单元。

   ```haskell
   [图示]
   l 指向 0
   b = { l, l }
   ```

---

#### 共享状态（Shared State）

🥑🥑🥑🥑🥑🥑**别名**的可能性会使得带有引用的程序在推理时相当棘手。例如，表达式 $(r := 1; r := !s)$，它先将 $1$ 赋值给 $r$，然后立即用 $s$ 的当前值覆盖它，与单个赋值 $r := !s$ 有完全相同的效果，除非我们在一个上下文中写它，其中 $r$ 和 $s$ 是同一个单元的别名。

当然，**别名**也是引用有用的一个重要部分。特别地，它允许我们在程序的不同部分之间建立“隐式的通信通道”——**共享状态**。例如，假设我们定义一个引用单元和两个操作其内容的函数：

```haskell
c = ref 0;
⊢ c : Ref Nat

incc = λx:Unit. (c := succ(!c); !c);
⊢ incc : Unit → Nat

decc = λx:Unit. (c := pred(!c); !c);
⊢ decc : Unit → Nat
```

调用 $incc$：

```haskell
incc unit;
⊢ 1 : Nat
```

会导致对 $c$ 的更改，这可以通过调用 $decc$ 来观察：

```haskell
decc unit;
⊢ 0 : Nat
```

如果我们将 $incc$ 和 $decc$ 一起打包到一个记录中：

```haskell
o = { i = incc, d = decc };
⊢ o : { i: Unit → Nat, d: Unit → Nat }
```

那么我们可以将整个结构作为一个单元传递，并使用其组件对共享的状态 $c$ 执行递增和递减操作。实际上，我们已经构造了一种简单的对象（object）。这个思想将在第18章中详细展开。

#### 对复合类型的引用（References to Compound Types）

引用单元不仅可以包含一个数字：上述的基本操作允许我们创建对任何类型值的引用，包括函数。例如，我们可以使用对函数的引用来给出一个（不是很高效的）数字数组（arrays of numbers）的实现，如下所示。将 $NatArray$ 定义为类型 $Ref (Nat → Nat)$。

```haskell
NatArray = Ref (Nat → Nat);
```

要构建一个新的数组，我们分配一个引用单元，并填充一个函数，当给定一个索引时，总是返回 $0$。

```haskell
newarray = λ_:Unit. ref (λn:Nat. 0);
⊢ newarray : Unit → NatArray
```

要查找数组的一个元素，我们简单地将函数应用于所需的索引。

```haskell
lookup = λa:NatArray. λn:Nat. (!a) n;
⊢ lookup : NatArray → Nat → Nat
```

编码的有趣部分是更新函数。它接受一个数组、一个索引和要存储在该索引的新值，通过创建（并存储在引用中）一个新函数来完成工作：当它被要求提供这个索引的值时，返回提供给 $update$ 的新值；对于所有其他索引，将查找传递给之前存储在引用中的函数。

```haskell
update = λa:NatArray. λm:Nat. λv:Nat.
          let oldf = !a in
          a := (λn:Nat. if equal m n then v else oldf n);
⊢ update : NatArray → Nat → Nat → Unit
```

**练习 13.1.2** [««]：如果我们将 $update$ 定义得更紧凑，如下所示：

```haskell
update = λa:NatArray. λm:Nat. λv:Nat.
          a := (λn:Nat. if equal m n then v else (!a) n);
```

它的行为会一样吗？

**解答**：

- 是的，行为是一样的。区别在于原始版本保存了旧函数 $oldf$，而新的版本直接在函数体中使用 $!a$ 来引用旧函数。由于在赋值前 $!a$ 总是引用旧函数，因此两者等价。

---

引用包含其他引用的值也非常有用，允许我们定义数据结构，如可变列表（mutable lists）和树（trees）。（这些结构通常还涉及递归类型，我们将在第20章中引入。）

#### 垃圾回收（Garbage Collection）

在继续形式化引用之前，我们最后需要提到一个问题：存储的释放（storage deallocation）。我们没有提供任何用于在不再需要时释放引用单元的原语。相反，像许多现代语言（包括 ML 和 Java）一样，我们依赖于运行时系统执行**垃圾回收（garbage collection）**，收集并重用程序不再能够访问的单元。这不仅仅是语言设计中的一个品味问题：在存在显式释放操作的情况下，很难实现类型安全。这背后的原因是熟悉的**悬挂引用问题（dangling reference problem）**：我们分配一个包含数字的单元，将对它的引用保存到某个数据结构中，使用它一段时间，然后释放它并分配一个包含布尔值的新单元，可能重用了相同的存储空间。现在，我们可能对同一个存储单元有两个名称——一个类型为 $Ref Nat$，另一个类型为 $Ref Bool$。

**练习 13.1.3** [««]：展示这如何导致类型安全性的违反。

**解答**：

- 如果我们有一个类型为 $Ref Nat$ 的引用 $r$，指向一个存储单元 $l$。我们释放了 $l$，并将其重新分配给一个类型为 $Ref Bool$ 的引用 $b$。

- 现在，$r$ 和 $b$ 都指向同一个位置 $l$，但类型检查器认为 $r$ 是 $Ref Nat$，$b$ 是 $Ref Bool$。

- 我们可以通过 $!r$ 读取一个布尔值（但类型系统认为是 $Nat$），或者对 $r$ 进行赋值 $r := 5$，覆盖了布尔值。

- 这会导致类型系统的破坏，因为我们可以在预期是数字的地方得到布尔值，反之亦然。

---

### 13.2 类型（Typing）

$ref$、$:=$ 和 $!$ 的类型规则直接来自它们的行为。

- **（T-Ref）**：

  $$
  \frac{\Gamma \vdash t_1 : T_1}{\Gamma \vdash \text{ref } t_1 : \text{Ref } T_1}
  $$

- **（T-Deref）**：

  $$
  \frac{\Gamma \vdash t_1 : \text{Ref } T_1}{\Gamma \vdash !t_1 : T_1}
  $$

- **（T-Assign）**：

  $$
  \frac{\Gamma \vdash t_1 : \text{Ref } T_1 \quad \Gamma \vdash t_2 : T_1}{\Gamma \vdash t_1 := t_2 : \text{Unit}}
  $$

---

### ------------------

**Unit 类型**是编程语言中一个非常简单而且基础的类型，它表示一种特殊的值，通常用于表示“**没有有意义的值**”或“**没有返回值**”。在许多编程语言中，`Unit` 类型的唯一值是 `()`，或者有时称为 `unit`。

### 1. **Unit 类型的定义**

- **Unit 类型**是一个只有一个可能值的类型，这个值通常表示为 `()`，其含义类似于“空”或“无操作”。
- **Unit 类型的唯一值**：通常只有一个值 `()`，这个值也叫作“**unit**”。
  
### 2. **Unit 类型的作用**

#### **2.1 表示没有有意义的返回值**

在许多编程语言中，`Unit` 类型用于表示函数或者表达式不返回任何有用的值。例如，在函数式编程中，如果一个函数不返回任何有用的结果（比如副作用函数），我们就可以使用 `Unit` 类型作为返回类型。

**例子：**

```haskell
printMessage :: String -> IO ()
printMessage message = putStrLn message
```

在这个 Haskell 函数中，`printMessage` 打印一个消息，但它没有返回有意义的值，所以它的返回类型是 `IO ()`，表示这个函数的返回值是 `Unit` 类型。

在命令式语言中，如 **Java**，类似的概念是 `void`：

```java
void printMessage(String message) {
    System.out.println(message);
}
```

虽然 Java 的 `void` 也表示函数没有返回值，但它与 `Unit` 类型不同，`void` 不是一个真正的类型，而 `Unit` 是一个可以赋值的类型。

#### **2.2 占位符**

有时 `Unit` 类型可以被用作某些需要返回值或参数的占位符。因为 `Unit` 类型只有一个可能的值，所以它不会引入不确定性。

例如，在某些语言中，我们可能需要定义一个泛型函数，该函数可以处理各种类型，但对某些情况下的返回值没有意义时，就可以使用 `Unit` 类型。

#### **2.3 表示计算的结束**

`Unit` 类型还可以用来表示某个过程或计算已经结束，特别是在某些函数式语言中，它被用作与命令式语言中的 `return void` 类似的结构，用来表示程序控制流的终结。

### 3. **Unit 类型 vs Void 类型**

#### **Unit 类型**：
- **有值**：Unit 类型有一个唯一的值 `()`。
- **类型**：`Unit` 是一个真实存在的类型，可以在表达式中使用。
- **用途**：主要用于函数没有有意义的返回值，或者作为占位符使用。

#### **Void 类型**：
- **没有值**：`void` 不是一个类型，它只是表示函数不返回任何值。
- **不是类型**：在许多命令式语言中（如 C 和 Java），`void` 并不是一个类型，它仅用于表示函数没有返回值。

### 4. **Unit 类型在不同语言中的实现**

#### **Haskell**：

在 Haskell 中，`Unit` 类型的唯一值是 `()`。它经常用于 `IO` 操作中，表示某个操作的结果不需要有意义的返回值。

```haskell
main :: IO ()
main = do
  putStrLn "Hello, world!"
```

在这个例子中，`main` 函数的返回类型是 `IO ()`，表示它是一个 I/O 操作，没有有意义的返回值。

#### **Scala**：

在 Scala 中，`Unit` 类型也有一个值 `()`，它与 Haskell 的 `Unit` 非常相似，表示没有有意义的返回值。

```scala
def printMessage(message: String): Unit = {
  println(message)
}
```

这个 Scala 函数 `printMessage` 返回 `Unit`，表示没有有意义的返回值。

#### **Rust**：

Rust 中的 `()` 也表示 `Unit` 类型，通常用于表示函数不返回值。

```rust
fn print_message(message: &str) -> () {
    println!("{}", message);
}
```

Rust 中 `print_message` 函数的返回类型是 `()`，表示函数不返回有意义的值。

#### **Racket（Scheme）**：

在 Racket 或 Scheme 中，没有类似 Haskell 或 Scala 的明确 `Unit` 类型，但可以使用 `#<void>` 来表示没有返回值的情况。这通常用在没有返回值的地方，类似于 `Unit` 的作用。

### 5. **Racket 实现示例：使用 Unit 类型**

在实现解释器时，可以通过 Racket 实现 `Unit` 类型，用于处理没有返回值的表达式或函数：

```racket
#lang racket

;; 定义一个简单的Unit类型表示
(define unit '())

;; 一个副作用函数，返回Unit类型
(define (print-message msg)
  (displayln msg)
  unit)

;; 调用副作用函数
(print-message "Hello, World!")  ;; 输出：Hello, World!
                                 ;; 返回：unit
```

在这个例子中，`print-message` 函数打印一条消息，并返回 `unit`，表示没有有意义的返回值。

---

### 6. **总结**

- **Unit 类型** 是一种只有一个值的类型，通常用来表示函数没有有意义的返回值，或者作为占位符。
- **Unit 类型与 void 的区别** 在于，`Unit` 是一种实际存在的类型，具有值 `()`，而 `void` 只是用于指示函数没有返回值，并不是一种类型。
- **应用场景** 包括副作用函数、占位符、以及表示没有有意义的返回值或表示计算的结束。

通过理解 `Unit` 类型，可以更好地掌握函数式编程中的类型系统，特别是在设计没有返回值或副作用函数时的语义表达。

### ------------------

### 13.3 求值（Evaluation）

当我们考虑如何形式化引用的操作行为时，一个更微妙的方面出现了。可以问：“类型为 $Ref T$ 的值应该是什么？”我们需要考虑的关键观察是，求值一个 $ref$ 操作应该做一些事情——即分配一些存储空间——并且操作的结果应该是对该存储的引用。

🥑🥑🥑🥑那么，**什么是一个引用（reference）**？

大多数编程语言实现中的运行时存储（run-time store）本质上只是一个巨大的字节数组。运行时系统跟踪这个数组的哪些部分当前正在使用；当我们需要分配一个新的引用单元时，我们从存储的空闲区域分配一个足够大的段（例如，整数单元需要 4 字节，存储 $Float$ 的单元需要 8 字节等），将其标记为已使用，并返回新分配的区域的起始索引（通常是一个 32 位或 64 位整数）。这些索引就是引用。

**对于当前的目的**，没有必要如此具体。我们可以将存储看作是一个值的数组，而不是字节的数组，抽象掉不同值的运行时表示的不同大小。此外，我们可以抽象掉引用（即该数组的索引）是数字这一事实。我们将引用视为某个**未解释的集合** $L$ 中的存储位置（store locations）的元素，并将存储看作是从位置 $l$ 到值的一个**部分函数**（partial function）。我们使用元变量 $\mu$ 来表示存储。

因此，🥑🥑🥑🥑🥑**引用**是一个**位置（location）**——存储的一个抽象索引。为了强调这种抽象性质，我们从现在开始使用**位置**（location）一词，而不是引用或指针。

**注意**：以这种方式抽象地处理位置，将阻止我们模拟在 C 等低级语言中发现的指针运算。这种限制是有意的。虽然指针运算有时非常有用（特别是在实现运行时系统的低级组件，如垃圾收集器时），但它不能被大多数类型系统跟踪：知道存储中位置 $n$ 包含一个 $Float$，并不能告诉我们关于位置 $n + 4$ 的类型的任何有用信息。在 C 中，指针运算是类型安全性违反的臭名昭著的来源。

---

接下来，我们需要扩展我们的操作语义来考虑存储。由于表达式的求值通常取决于它在其中求值的存储的内容，因此求值规则应该不仅以项作为参数，还要以存储作为参数。此外，由于一个项的求值可能对存储产生副作用，这可能影响将来其他项的求值，求值规则需要返回一个新的存储。

因此，单步求值关系的形状从 $t \to t'$ 变为 $t\ |\ \mu \to t'\ |\ \mu'$，其中 $\mu$ 和 $\mu'$ 是存储的起始和结束状态。实际上，我们丰富了抽象机的概念，因此机器状态不仅是一个程序计数器（由项表示），而且是程序计数器加上存储的当前内容。

### -------------------------------

这段话讨论了**引用（reference）**在编程语言中操作的形式化过程，特别是在涉及到内存管理和存储时引用的求值行为。

### 1. **引用的基本问题**

首先，段落提出了一个问题：“类型为 $Ref\ T$ 的值到底是什么？” 这涉及到引用类型 $Ref\ T$ 的定义。引用类型可以被视为某种指向内存的指针，指向某个存储单元，在编程语言中用于操作内存中的数据。当我们执行引用操作（如 `ref`）时，实际上是分配存储空间并返回对该空间的引用（指针或位置）。

### 2. **引用和存储的运行时视角**

为了说明这一点，段落描述了大多数编程语言的运行时系统将**内存**视为一个巨大的**字节数组**。每次需要分配存储时，运行时系统会从空闲区域分配足够的空间（比如整数占用 4 字节，浮点数占用 8 字节），并将该区域的起始位置返回给调用者作为引用。引用可以被认为是内存数组的索引，通常是32位或64位的整数。

**关键点**：在大多数语言中，引用本质上是某个内存地址的索引值，指向该地址所在的存储单元。这些地址或索引允许程序通过引用来操作内存中的数据。

### 3. **更抽象的视角**

尽管内存的物理表示是字节数组，并且引用通常是数值索引，段落提醒我们：**不需要对运行时的具体细节进行深入考虑**。我们可以用更抽象的方式思考引用和存储，而不关心实际的字节大小或者地址索引。为了实现这种抽象，可以将存储视为值的数组，而不是字节的数组。同时，引用不再需要被视为数字地址，而是一个抽象的集合 $L$ 中的元素。

#### **抽象模型**：
- 🥑🥑🥑🥑🥑**引用**可以被视为一个**位置（location）**，即存储的索引。
- **存储**可以被建模为一个从**位置** $l$ 到**值**的**部分函数**（partial function），🥑🥑用 $\mu$ 表示。
  - 这意味着每个位置 $l$（即引用）可以映射到存储中的某个值。

这种抽象使得我们不必关心内存地址或具体的字节分配，只需要知道某个存储位置 $l$ 对应于某个值。这种抽象模型在类型系统和形式化语义中非常重要。

### 4. **位置 vs 引用 vs 指针**

在这种抽象中，**引用**可以被视为存储中的某个**位置（location）**。因此，段落建议我们以后使用“位置”一词而不是“引用”或“指针”。这种术语上的变化是为了强调这种更高层次的抽象。

### 5. **避免指针运算**

通过这种抽象处理位置的方式，我们🥑🥑失去了对**指针运算（pointer arithmetic）**的支持。指针运算在诸如 C 语言等低级语言中非常常见，它允许程序员直接操作内存地址（例如，计算 $n+4$）。然而，🥑🥑指针运算会引入许多类型安全性的问题。

- **安全性问题**：在 C 语言中，知道某个存储位置 $n$ 存放一个 `Float`，并不能告诉我们位置 $n+4$ 存放的数据是什么类型。指针运算很容易造成类型安全性的破坏，使得程序出现不可预料的错误。
  

因此，形式化语义通常会避免使用指针运算，并通过抽象掉这些低级操作，确保类型安全性。

### 6. **存储和求值的扩展**

接下来，段落讨论如何将这种抽象概念引入到**操作语义**中。操作语义是关于如何对表达式进行求值的形式化描述。由于表达式的求值可能会对存储产生影响（例如，分配、修改或读取存储中的值），所以求值规则不仅要处理表达式，还要处理存储。

#### **求值关系扩展**：
- 传统的求值关系表示为 $t \to t'$，表示表达式 $t$ 归约为表达式 $t'$。
- 现在，由于存储的存在，求值关系扩展为 $t\ |\ \mu \to t'\ |\ \mu'$，表示表达式 $t$ 在存储 $\mu$ 中求值，结果是新表达式 $t'$ 和新的存储 $\mu'$。

这个新的求值关系考虑了存储的变化。**存储的状态**可能在表达式的求值过程中被改变（例如，分配了新的存储位置或修改了存储中的值），因此我们需要追踪存储的变化。

#### **机器状态的扩展**：
求值的过程中，机器状态（即程序的当前执行状态）不仅包括当前正在执行的表达式，还包括当前的存储内容。因此，机器的状态不再仅仅是程序计数器（项 $t$），而是**程序计数器**加上当前的**存储状态**。

### 7. **总结**

- **引用（Reference）** 是指向存储位置的抽象标识，在运行时它通常表示内存地址。
- **存储（Store）** 可以被抽象为从位置（Location）到值的部分函数（Partial Function）。
- 我们通过抽象的方式处理引用和存储，不关心具体的内存地址和字节表示，而是使用抽象的存储位置和值的映射。
- 通过扩展操作语义，将存储状态作为求值的一个组成部分，求值关系不仅追踪表达式的变化，也追踪存储的变化。
- 这种抽象帮助我们避免了低级语言中指针运算带来的安全性问题。

通过这种形式化抽象，我们可以更容易地处理复杂的存储模型，并且确保类型安全性。

### -------------------------------

要完成这一变化，我们首先需要将所有现有的求值规则加上存储：

- **（E-AppAbs）**：

  $$
  (\lambda x:T_{11}.\ t_{12})\ v_2\ |\ \mu \to [x \mapsto v_2]t_{12}\ |\ \mu
  $$

  - 这个规则返回未改变的存储 $\mu$：函数应用本身没有副作用。

- **（E-App1）**：

  $$
  \frac{t_1\ |\ \mu \to t_1'\ |\ \mu'}{t_1\ t_2\ |\ \mu \to t_1'\ t_2\ |\ \mu'}
  $$

- **（E-App2）**：

  $$
  \frac{t_2\ |\ \mu \to t_2'\ |\ \mu'}{v_1\ t_2\ |\ \mu \to v_1\ t_2'\ |\ \mu'}
  $$

  - 这两个规则简单地将副作用从前提传播到结论。

---

🥑🥑接下来，我们需要对项的语法进行一个小的扩展。求值 $ref$ 表达式的结果将是一个新的位置，因此我们需要将位置包含在可以作为求值结果的事物（即值）的集合中。

- **值（values）**：

  $$
  v ::= \text{值：} \quad \lambda x:T.\ t \quad \text{抽象值（abstraction value）} \\
  \quad\quad\quad\quad\quad \text{unit} \quad \text{单位值（unit value）} \\
  \quad\quad\quad\quad\quad 🥑l \quad \text{存储位置（store location）}
  $$

由于所有的值也是项，这意味着项的集合应该包括位置。

- **项（terms）**：

  $$
  t ::= \text{项：} \quad x \quad \text{变量（variable）} \\
  \quad\quad\quad\quad\quad \lambda x:T.\ t \quad \text{抽象（abstraction）} \\
  \quad\quad\quad\quad\quad t\ t \quad \text{应用（application）} \\
  \quad\quad\quad\quad\quad \text{unit} \quad \text{常量 unit} \\
  \quad\quad\quad\quad\quad \text{ref } t \quad \text{引用创建（reference creation）} \\
  \quad\quad\quad\quad\quad !t \quad \text{解引用（dereference）} \\
  \quad\quad\quad\quad\quad t := t \quad \text{赋值（assignment）} \\
  \quad\quad\quad\quad\quad l \quad \text{存储位置（store location）}
  $$

当然，对项语法的这种扩展并不意味着我们打算让程序员编写涉及显式、具体位置的项：这样的项将仅作为求值的中间结果出现。实际上，本章中的项语言应该被视为形式化一个中间语言，其中的一些特性并未直接提供给程序员。

---

基于这种扩展的语法，我们可以为操纵位置和存储的新构造陈述求值规则。首先，要求值一个解引用表达式 $!t1$，我们必须首先将 $t1$ 归约为一个值：

- **（E-Deref）**：

  $$
  \frac{t_1\ |\ \mu \to t_1'\ |\ \mu'}{!t_1\ |\ \mu \to !t_1'\ |\ \mu'}
  $$

一旦 $t1$ 完成归约，我们应该有一个形式为 $!l$ 的表达式，其中 $l$ 是某个位置。尝试解引用任何其他类型的值（如函数或 $unit$）的项是错误的。在这种情况下，求值规则将卡住（stuck）。第13.5节中的类型安全性保证了良类型的项永远不会以这种方式出错。

- **（E-DerefLoc）**：

  $$
  \frac{\mu(l) = v}{!l\ |\ \mu \to v\ |\ \mu}
  $$

接下来，要求值一个赋值表达式 $t1 := t2$，我们必须首先将 $t1$ 归约为一个值（即位置）：

- **（E-Assign1）**：

  $$
  \frac{t_1\ |\ \mu \to t_1'\ |\ \mu'}{t_1 := t_2\ |\ \mu \to t_1' := t_2\ |\ \mu'}
  $$

然后将 $t2$ 归约为一个值（任何类型的值）：

- **（E-Assign2）**：

  $$
  \frac{t_2\ |\ \mu \to t_2'\ |\ \mu'}{v_1 := t_2\ |\ \mu \to v_1 := t_2'\ |\ \mu'}
  $$

一旦我们完成了对 $t1$ 和 $t2$ 的归约，我们有一个形式为 $l := v2$ 的表达式，我们通过更新存储使位置 $l$ 包含 $v2$ 来执行它：

- **（E-Assign）**：

  $$
  \frac{}{l := v_2\ |\ \mu \to \text{unit}\ |\ [l \mapsto v_2]\mu}
  $$

- 这里，$[l \mapsto v_2]\mu$ 表示“将 $l$ 映射到 $v2$，并将所有其他位置映射到与 $\mu$ 相同的存储”。

- 结果项是 $unit$；有趣的结果是更新后的存储。

最后，要求值一个形式为 $ref t1$ 的表达式，我们首先将 $t1$ 归约为一个值：

- **（E-Ref）**：

  $$
  \frac{t_1\ |\ \mu \to t_1'\ |\ \mu'}{\text{ref } t_1\ |\ \mu \to \text{ref } t_1'\ |\ \mu'}
  $$

然后，为了求值 $ref$ 本身，我们选择一个新的位置 $l$（即，不在 $\mu$ 的定义域中），并产生一个扩展了 $\mu$ 的新存储，其中添加了新的绑定 $l \mapsto v_1$。

- **（E-RefV）**：

  $$
  \frac{l \notin \text{dom}(\mu)}{\text{ref } v_1\ |\ \mu \to l\ |\ (\mu, l \mapsto v_1)}
  $$

- 这个求值步骤的结果项是新分配的位置的名称 $l$。

---

注意，这些求值规则不执行任何形式的垃圾回收：我们只是允许存储随着求值的进行而无限制地增长。这不会影响求值的正确性（毕竟，“垃圾”的定义正是程序不再能够访问的存储部分，因此不能在求值中发挥任何作用），但这意味着我们的求值器的一个简单实现有时会耗尽内存，而更复杂的求值器可以通过重用内容已成为垃圾的位置继续运行。

**练习 13.3.1** [«««]：我们如何改进求值规则以模拟垃圾回收？然后需要证明什么定理，以论证这种改进是正确的？

**解答**：

- **改进求值规则**：在每一步求值后，我们可以在更新存储时，移除那些不再可达的存储位置（即，程序中没有任何部分可以再访问这些位置）。

- 这意味着在规则中，我们需要定义一个函数 $GC$，它接受当前项和存储，返回经过垃圾回收的存储。

- **需要证明的定理**：需要证明改进的求值关系与原始求值关系是**等价的**，即对于任意项和初始存储，求值序列在改进的规则下产生的最终结果（项和存储）与在原始规则下产生的结果相同，除了存储中包含的不可达位置被移除之外。

---

**总结**：

通过本章的学习，我们了解了如何将可变引用添加到简单类型的 $\lambda$ 演算中，以及它对类型系统和操作语义的影响。我们引入了存储的概念，并讨论了引用、别名和共享状态等关键问题。此外，我们还探讨了垃圾回收的重要性，以及为什么在存在显式释放操作的情况下很难实现类型安全。

### ---------------------------

这个部分涉及到引用（references）在编程语言中的形式化表示以及与存储（store）的关系。为了帮助你更好地理解这段抽象内容，我将逐步解释每个概念、公式和规则，并提供详细的背景信息。

### 1. **引用是什么？**

在编程语言中，**引用（reference）** 是对内存中某个存储位置的标识或指针。它允许程序通过访问内存中的特定位置来读取或修改数据。

在这里，我们重点讨论的是如何在形式化语义中表示和处理引用。引用与内存（存储）相关联，每个引用代表一个具体的内存位置。一般而言，内存可以被视为一个数组，数组的每个位置存储不同类型的数据。

例如，在运行时，存储系统跟踪哪些内存部分当前在使用，当分配新的引用时，内存管理器会为该引用分配适当大小的内存块，然后返回这个块的起始地址。

### 2. **存储的抽象表示**

为了更抽象和一般化的处理，我们不必将存储看作字节的数组，而可以看作一个**值的数组**。这使得我们可以避免处理具体的内存布局（如整数需要 4 字节，浮点数需要 8 字节等），而只关注存储中包含哪些值。

#### **存储的抽象表示：**

- 我们用 $\mu$ 来表示**存储**，即内存中当前位置和存储值的映射。
- 形式上，存储 $\mu$ 是一个**部分函数**（partial function），即从存储位置 $l$ 到存储值的映射关系。

例如，存储可以表示为 $\mu = \{ l_1 \mapsto v_1, l_2 \mapsto v_2, \dots \}$，其中 $l_1, l_2$ 是存储位置，$v_1, v_2$ 是存储的值。

### 3. **引用和位置的抽象**

在大多数编程语言中，引用通常表示为整数（如指针地址）。但是在形式化语义中，我们可以将引用抽象为一个**未解释的集合** $L$，其元素就是存储的位置（location）。我们不关心这些位置是如何实现的，只需要知道它们是不同的，并且可以指向存储中的值。

因此，**引用就是存储的一个抽象索引**，在形式化语义中称为**位置（location）**。这是一个重要的抽象，使我们能够处理引用而不依赖具体的内存实现。

### 4. **存储和求值**

由于表达式的求值往往会影响存储（例如，分配内存、更新存储中的值），我们需要扩展求值的表示方法，不仅要追踪表达式的变化，还要追踪存储的变化。

我们用 $\mu$ 表示求值前的存储状态，用 $\mu'$ 表示求值后的存储状态。因此，单步求值的关系从 $t \to t'$（表示表达式 $t$ 归约为 $t'$）扩展为：

$$
t\ |\ \mu \to t'\ |\ \mu'
$$

这意味着表达式 $t$ 在存储 $\mu$ 中进行求值，得到了新的表达式 $t'$，并且存储变为 $\mu'$。

### 5. **具体的求值规则**

让我们来看一些具体的求值规则，特别是如何在有存储的情况下处理表达式的求值。

#### **函数应用的求值**

- **$E\text{-AppAbs}$**：当应用一个抽象函数时，求值没有影响存储。

  $$
  (\lambda x:T_{11}.\ t_{12})\ v_2\ |\ \mu \to [x \mapsto v_2]t_{12}\ |\ \mu
  $$

  - 这里，$\mu$ 表示存储状态，求值过程并没有修改存储。函数应用时，参数 $v_2$ 被替换进函数体中，但存储保持不变。

- **$E\text{-App1}$ 和 $E\text{-App2}$**：这些规则处理函数应用时的递归求值。

  $$
  \frac{t_1\ |\ \mu \to t_1'\ |\ \mu'}{t_1\ t_2\ |\ \mu \to t_1'\ t_2\ |\ \mu'}
  $$

  这个规则表示，如果 $t_1$ 在存储 $\mu$ 中归约为 $t_1'$，并且存储变为 $\mu'$，那么整个应用表达式 $t_1\ t_2$ 也在存储 $\mu'$ 中继续求值。规则 $E\text{-App2}$ 同理。

#### **解引用和赋值的求值**

接下来，我们扩展表达式的语法以支持**解引用**和**赋值**等操作。

- **$E\text{-Deref}$**：在求值一个解引用操作 $!t_1$ 时，我们首先对 $t_1$ 进行求值：

  $$
  \frac{t_1\ |\ \mu \to t_1'\ |\ \mu'}{!t_1\ |\ \mu \to !t_1'\ |\ \mu'}
  $$

  这意味着我们首先将 $t_1$ 归约为一个值，直到得到一个形式为 $!l$ 的表达式，其中 $l$ 是存储的位置。

- **$E\text{-DerefLoc}$**：当我们最终获得一个位置 $l$，并且 $l$ 存储了一个值 $v$，则解引用 $!l$ 返回存储中的值 $v$：

  $$
  \frac{\mu(l) = v}{!l\ |\ \mu \to v\ |\ \mu}
  $$

  这里表示的是通过存储 $\mu$ 中的 $l$ 位置找到对应的值 $v$。

#### **赋值操作的求值**

- **$E\text{-Assign1}$ 和 $E\text{-Assign2}$**：这些规则处理赋值操作 $t_1 := t_2$。首先，我们将 $t_1$ 和 $t_2$ 归约为具体的值。

  $$
  \frac{t_1\ |\ \mu \to t_1'\ |\ \mu'}{t_1 := t_2\ |\ \mu \to t_1' := t_2\ |\ \mu'}
  $$

- **$E\text{-Assign}$**：当我们得到一个位置 $l$ 和一个值 $v_2$ 时，赋值操作 $l := v_2$ 会将存储更新为 $l$ 映射到 $v_2$：

  $$
  \frac{}{l := v_2\ |\ \mu \to \text{unit}\ |\ [l \mapsto v_2]\mu}
  $$

  赋值后，结果是 `unit`（表示操作成功），而存储变为 $\mu$，其中 $l$ 对应的新值是 $v_2$。

#### **引用创建的求值**

- **$E\text{-Ref}$**：在求值 `ref t1` 时，我们首先将 $t1$ 归约为一个值：

  $$
  \frac{t_1\ |\ \mu \to t_1'\ |\ \mu'}{\text{ref } t_1\ |\ \mu \to \text{ref } t_1'\ |\ \mu'}
  $$

- **$E\text{-RefV}$**：一旦 $t_1$ 归约为值 $v_1$，我们为它分配一个新的存储位置 $l$，并返回这个位置：

  $$
  \frac{l \notin \text{dom}(\mu)}{\text{ref } v_1\ |\ \mu \to l\ |\ (\mu, l \mapsto v_1)}
  $$

  这里，$l$ 是一个新的存储位置，$\mu$ 是存储，新的存储状态是 $\mu$ 扩展了位置 $l$ 的绑定。

### 6. **垃圾回收的讨论**

**问题**：如何改进求值规则以模拟垃圾回收？

- 在实际实现中，我们可以在每次存储更新后，检查哪些存储位置不再可达（即没有任何表达式或引用指向这些位置）。我们可以通过移除这些不可达位置来模拟垃圾回收。

- **需要证明的定理**：我们需要证明修改后的求值规则与原始规则是等价的，也就是说，经过垃圾回收的存储状态与原始存储状态是等价的，除了不可达位置被移除之外。

---

### 总结

在这部分中，我们通过引入**存储**和**引用**，扩展了求值的形式化表示。引用在这里被抽象为存储中的**位置**，并且我们

扩展了求值规则以处理引用、解引用和赋值操作。通过这些规则，我们可以在形式化语义中描述有状态的程序如何操作存储。

同时，垃圾回收是优化存储管理的重要技术，形式化语义中可以通过引入垃圾回收规则来模拟这一过程，并保持语义的正确性。

### ---------------------------

### 13.4 存储类型（Store Typings）

在我们已经扩展了语法和求值规则以适应引用之后，我们的最后一个任务是🥑🥑🥑为新构造编写类型规则——当然，还要检查它们是可靠的。自然，关键问题是：🥑🥑🥑“一个位置（location）的类型是什么？”

当我们求值一个包含具体位置的项时，结果的类型取决于我们开始时存储的内容。例如，如果我们在存储 $\mu = (l_1 \mapsto \text{unit},\ l_2 \mapsto \text{unit})$ 中求值项 $!l_2$，结果是 $\text{unit}$；如果我们在存储 $\mu = (l_1 \mapsto \text{unit},\ l_2 \mapsto \lambda x:\text{Unit}.\ x)$ 中求值相同的项，结果是 $\lambda x:\text{Unit}.\ x$。相对于前一个存储，位置 $l_2$ 的类型是 $\text{Unit}$，而相对于后一个存储，它的类型是 $\text{Unit} \to \text{Unit}$。这个观察立即引出了一个关于位置的类型规则的初步尝试：

$$
\frac{\Gamma \vdash \mu(l) : T_1}{\Gamma \vdash l : \text{Ref } T_1}
$$

也就是说，要找到位置 $l$ 的类型，我们在存储中查找 $l$ 的当前内容🥑🥑🥑🥑🥑 $\mu(l)$ 并计算其类型 $T_1$。然后，位置的类型就是 $\text{Ref } T_1$。

以这种方式开始，我们需要更进一步以达到一致的状态。实际上，通过使一个项的类型依赖于存储，我们已经将类型关系从一个三元关系（上下文、项和类型之间）更改为一个四元关系（上下文、存储、项和类型之间）。直观上，存储是我们计算项的类型时的上下文的一部分，因此我们将这个四元关系写成将存储放在推导符左侧的形式：$\Gamma\ |\ \mu \vdash t : T$。我们的引用类型规则现在形式为：

$$
\frac{\Gamma\ |\ \mu \vdash \mu(l) : T_1}{\Gamma\ |\ \mu \vdash l : \text{Ref } T_1}
$$

系统中其余的类型规则以类似的方式扩展，添加了存储。但其他规则不需要对它们的存储做任何有趣的事情——只需将它们从前提传递到结论即可。

然而，这个规则有两个问题。首先，类型检查相当低效，因为计算位置 $l$ 的类型涉及计算 $l$ 的当前内容 $v$ 的类型。如果 $l$ 在项 $t$ 中多次出现，那么在为 $t$ 构建类型推导的过程中，我们将多次重新计算 $v$ 的类型。更糟糕的是，如果 $v$ 本身包含位置，那么我们每次出现它们时都必须重新计算它们的类型。例如，如果存储包含：

$$
\begin{align*}
l_1 &\mapsto \lambda x:\text{Nat}.\ 999, \\
l_2 &\mapsto \lambda x:\text{Nat}.\ (!l_1)\ x, \\
l_3 &\mapsto \lambda x:\text{Nat}.\ (!l_2)\ x, \\
l_4 &\mapsto \lambda x:\text{Nat}.\ (!l_3)\ x, \\
l_5 &\mapsto \lambda x:\text{Nat}.\ (!l_4)\ x,
\end{align*}
$$

那么计算 $l_5$ 的类型涉及计算 $l_4$、$l_3$、$l_2$ 和 $l_1$ 的类型。

第二，所提出的位置的类型规则可能根本不允许我们推导任何东西，如果存储包含一个循环。例如，对于存储：

$$
\begin{align*}
l_1 &\mapsto \lambda x:\text{Nat}.\ (!l_2)\ x, \\
l_2 &\mapsto \lambda x:\text{Nat}.\ (!l_1)\ x,
\end{align*}
$$

没有针对位置 $l_2$ 的有限类型推导，因为计算 $l_2$ 的类型需要找到 $l_1$ 的类型，而这又涉及 $l_2$，如此循环。循环引用结构在实践中确实会出现（例如，它们可用于构建双向链表），🥑🥑我们希望我们的类型系统能够处理它们。

**练习 13.4.1** [«]：你能找到一个项，其求值会创建这个特定的循环存储吗？

**解答**：

- 我们可以定义：

  ```haskell
  l1 = ref (\lambda x:\text{Nat}.\ (!l2)\ x);
  l2 = ref (\lambda x:\text{Nat}.\ (!l1)\ x);
  ```

- 通过执行上述赋值，我们在存储中创建了一个循环引用结构。

---

🥑🥑🥑这两个问题都源于我们提出的位置类型规则要求我们每次在项中提及它时都重新计算位置的类型。但是，直观上，这不应该是必要的。毕竟，当一个位置首次被创建时，我们知道我们存储到其中的初始值的类型。此外，尽管我们可能稍后将其他值存储到该位置，但这些其他值将始终具有与初始值相同的类型。换句话说，对于存储中的每个位置，我们总是考虑一个固定的类型，该类型在位置分配时确定。这些预期的类型可以收集为一个**存储类型**（store typing）——一个将位置映射到类型的有限函数。我们使用元变量 $\Sigma$ 来表示这样的函数。

假设我们有一个🥑存储类型 $\Sigma$，描述了某个项 $t$ 将在其中求值的存储 $\mu$。那么我们可以🥑使用 $\Sigma$ 来计算 $t$ 的结果的类型，而无需直接查看 $\mu$。例如，如果 $\Sigma = (l_1 \mapsto \text{Unit},\ l_2 \mapsto \text{Unit} \to \text{Unit})$，那么我们可以立即推断 $!l_2$ 的类型是 $\text{Unit} \to \text{Unit}$。更一般地，🥑🥑🥑我们可以将位置的类型规则重新表述为基于存储类型，如下所示：

$$
\frac{\Sigma(l) = T_1}{\Gamma\ |\ \Sigma \vdash l : \text{Ref } T_1} \tag{T-Loc}
$$

类型检查再次是一个四元关系，但它是基于存储类型而不是具体的存储来参数化的。其余的类型规则以类似的方式添加了存储类型。

当然，只有当在求值期间使用的具体存储实际符合我们在类型检查时假设的存储类型时，这些类型规则才能准确预测求值结果。这种条件与我们迄今为止看到的所有演算中的自由变量情况完全类似：替换引理（9.3.8）向我们保证，如果 $\Gamma \vdash t : T$，那么我们可以用类型在 $\Gamma$ 中列出的值替换 $t$ 中的自由变量，从而获得类型为 $T$ 的闭项；根据类型保持定理（9.3.9），如果它产生任何结果，将求值为类型为 $T$ 的最终结果。我们将在第13.5节看到如何形式化与存储和存储类型类似的直觉。

最后，注意对于类型检查程序员实际编写的项，我们不需要做任何棘手的事情来猜测我们应该使用什么存储类型。正如我们上面提到的，具体的位置常量只会出现在求值的中间结果的项中；它们不在程序员编写的语言中。因此，我们可以简单地相对于**空存储类型**（empty store typing）来类型检查程序员的项。随着求值的进行，新的位置被创建，我们总是能够通过查看放置在新分配单元中的初始值的类型来扩展存储类型；这种直觉在下面类型保持定理（13.5.3）的陈述中形式化。

现在，我们已经处理了位置，其他新语法形式的类型规则相当直接。当我们创建对类型为 $T_1$ 的值的引用时，引用本身的类型是 $\text{Ref } T_1$。

$$
\frac{\Gamma\ |\ \Sigma \vdash t_1 : T_1}{\Gamma\ |\ \Sigma \vdash \text{ref } t_1 : \text{Ref } T_1} \tag{T-Ref}
$$

🥑🥑🥑🥑注意我们在这里不需要扩展存储类型，因为新位置的名称直到运行时才会确定，而 $\Sigma$ 只记录已经分配的存储单元及其类型之间的关联。

相反，如果 $t_1$ 求值为类型为 $\text{Ref } T_{11}$ 的位置，那么解引用 $t_1$ 保证会产生一个类型为 $T_{11}$ 的值。

$$
\frac{\Gamma\ |\ \Sigma \vdash t_1 : \text{Ref } T_{11}}{\Gamma\ |\ \Sigma \vdash !t_1 : T_{11}} \tag{T-Deref}
$$

最后，如果 $t_1$ 表示类型为 $\text{Ref } T_{11}$ 的单元，那么只要 $t_2$ 的类型也是 $T_{11}$，我们就可以将 $t_2$ 存储到该单元中：

$$
\frac{\Gamma\ |\ \Sigma \vdash t_1 : \text{Ref } T_{11} \quad \Gamma\ |\ \Sigma \vdash t_2 : T_{11}}{\Gamma\ |\ \Sigma \vdash t_1 := t_2 : \text{Unit}} \tag{T-Assign}
$$

**图13-1** 总结了带有引用的简单类型 $\lambda$ 演算的类型规则（以及为了方便参考的语法和求值规则）。

---

### ------------------------------

这段内容的主题是**存储类型（Store Typing）**，探讨如何为存储中的位置（locations）分配类型，以及如何在扩展的类型系统中处理引用、解引用、赋值等操作。我们将从几个方面详细解释这段内容，帮助你理解存储类型及其在形式化语义中的应用。

### 1. **存储和位置的类型**

首先，段落中提出了一个关键问题：“一个位置（location）的类型是什么？”

为了回答这个问题，考虑以下场景：

- 假设我们有一个存储 $\mu$，其中位置 $l_1$ 和 $l_2$ 分别存储值 `unit` 和 `lambda` 函数。如果我们解引用位置 $l_2$（即执行操作 $!l_2$），其结果的类型依赖于位置 $l_2$ 中存储的内容。例如：
  - 在存储 $\mu = (l_1 \mapsto \text{unit},\ l_2 \mapsto \text{unit})$ 中，$!l_2$ 的结果是 `unit`。
  - 在存储 $\mu = (l_1 \mapsto \text{unit},\ l_2 \mapsto \lambda x:\text{Unit}.\ x)$ 中，$!l_2$ 的结果是 `lambda` 函数。

因此，位置的类型与存储中的当前内容直接相关。我们需要通过查找存储 $\mu(l)$ 来获取存储位置 $l$ 中的当前值，并根据这个值推导其类型。形式化表示如下：

$$
\frac{\Gamma \vdash \mu(l) : T_1}{\Gamma \vdash l : \text{Ref } T_1}
$$

这意味着，位置 $l$ 的类型是 `Ref T_1`，其中 $T_1$ 是存储位置 $l$ 当前存储的值的类型。

### 2. **类型检查扩展到存储**

在传统的类型系统中，类型关系是一个三元关系，涉及上下文 $\Gamma$、项 $t$ 和项的类型 $T$。现在，由于我们引入了存储（store），我们需要将类型检查扩展为一个🥑🥑🥑🥑**四元关系**，即**上下文**、**存储**、**项** 和 **类型** 之间的关系：

$$
\Gamma\ |\ \mu \vdash t : T
$$

这种表示方式表明，表达式 $t$ 的类型不仅取决于上下文 $\Gamma$，还取决于当前存储 $\mu$ 的状态。因此，存储成为类型推导的关键因素。

### 3. **存储类型的性能问题**

这种方法虽然能描述位置的类型，但它存在🥑两个问题：

1. 🥑**低效的类型检查**：每次我们需要检查位置 $l$ 的类型时，都需要重新计算存储 $\mu(l)$ 中的值的类型。如果某个位置多次出现在项 $t$ 中，那么我们将多次计算该位置存储的值的类型。这显然是低效的。
   
   🥑更糟糕的是，如果位置 $l$ 中的值本身包含其他位置的引用（例如存储中包含链式引用），那么每次出现这些位置时，我们都需要递归计算它们的类型。这会导致性能问题，尤其是在复杂的存储结构中。

2. 🥑**循环引用的问题**：如果存储中包含循环引用，例如位置 $l_1$ 引用 $l_2$，而 $l_2$ 又引用 $l_1$，这种循环依赖会导致我们无法为这些位置推导出一个有限的类型推导。这是由于在计算 $l_2$ 的类型时，需要依赖 $l_1$ 的类型，反过来计算 $l_1$ 的类型时，又需要依赖 $l_2$，从而导致无限循环。

   这类问题在实践中确实存在，例如用于实现双向链表或其他互相引用的数据结构。

### 4. **存储类型（Store Typing）的引入**

为了解决上述问题，我们引入了🥑**存储类型**（Store Typing）的概念。存储类型是一个🥑将**位置**映射到**类型**的有限函数，表示在某个位置上存储的值的🥑类型是固定的。我们用 $\Sigma$ 表示存储类型：

- $\Sigma$ 的形式为 $\Sigma = \{ l_1 \mapsto T_1, l_2 \mapsto T_2, \dots \}$，其中 $l_i$ 是存储位置，$T_i$ 是该位置存储的值的类型。

引入存储类型后，我们可以避免在每次提及位置时重新计算它的类型，因为位置的类型在存储中首次创建时就已经确定并记录在存储类型 $\Sigma$ 中。例如：

- 如果 $\Sigma = (l_1 \mapsto \text{Unit},\ l_2 \mapsto \text{Unit} \to \text{Unit})$，那么我们可以直接推导 $!l_2$ 的类型为 `Unit -> Unit`，而不需要查找存储 $\mu$。

### 5. **存储类型规则**

基于存储类型的引入，我们重新定义位置的类型规则：

$$
\frac{\Sigma(l) = T_1}{\Gamma\ |\ \Sigma \vdash l : \text{Ref } T_1} \tag{T-Loc}
$$

该规则表示，如果位置 $l$ 在存储类型 $\Sigma$ 中的类型为 $T_1$，那么位置 $l$ 的类型就是 `Ref T_1`。

与之前的存储 $\mu$ 不同，存储类型 $\Sigma$ 是静态的，它记录了所有位置的初始类型，而不涉及存储内容的具体值。这提高了类型检查的效率。

### 6. **存储类型一致性**

为了确保这种存储类型系统能够正确预测求值的结果，我们需要保证在运行时，存储 $\mu$ 符合我们在类型检查时假设的存储类型 $\Sigma$。这类似于处理自由变量的场景：我们可以使用 $\Gamma$ 中定义的值替换表达式中的自由变量，只要替换保持类型的一致性。

### 7. **引用和解引用的类型规则**

基于存储类型 $\Sigma$，我们可以为**引用**、**解引用**和**赋值**操作定义类型规则：

1. **引用创建规则**：

   $$\frac{\Gamma\ |\ \Sigma \vdash t_1 : T_1}{\Gamma\ |\ \Sigma \vdash \text{ref } t_1 : \text{Ref } T_1} \tag{T-Ref}$$

   该规则表示，如果 $t_1$ 的类型为 $T_1$，那么创建引用 `ref t_1` 的类型是 `Ref T_1`。

2. **解引用规则**：

   $$\frac{\Gamma\ |\ \Sigma \vdash t_1 : \text{Ref } T_{11}}{\Gamma\ |\ \Sigma \vdash !t_1 : T_{11}} \tag{T-Deref}$$

   该规则表示，如果 $t_1$ 是类型为 `Ref T_11` 的引用，那么解引用操作 $!t_1$ 的结果类型是 $T_{11}$。

3. **赋值规则**：

   $$\frac{\Gamma\ |\ \Sigma \vdash t_1 : \text{Ref } T_{11} \quad \Gamma\ |\ \Sigma \vdash t_2 : T_{11}}{\Gamma\ |\ \Sigma \vdash t_1 := t_2 : \text{Unit}} \tag{T-Assign}$$

   该规则表示，如果 $t_1$ 是一个类型为 `Ref T_11` 的引用，$t_2$ 是类型为 $T_{11}$ 的值，那么将 $t_2$ 赋值给 $t_1$ 的操作的类型是 `Unit`。

### 8. **总结**

- **存储类型**是将位置映射到类型的静态结构，避免了重复计算位置类型和循环依赖的问题。
- 存储类型使得我们可以在类型检查时推断位置的类型，而无需动态查找存储中的值。
- 通过引入存储类型，我们为引用、解引用、赋值等操作提供了更高效、更一致的类型检查规则。

这种设计使得类型系统在处理引用、位置等涉及存储的操作时既保持了效率，又能处理复杂的数据结构（如循环引用）带来的挑战。

### -----------------------------

### 图13-1：引用（References）

**→ Unit Ref** 扩展了 $\lambda \to$，添加了 Unit（9-1 和 11-2）

#### 语法

- **项（terms）**：

  $$
  \begin{align*}
  t ::= \quad & x & \text{变量（variable）} \\
  & \lambda x:T.\ t & \text{抽象（abstraction）} \\
  & t\ t & \text{应用（application）} \\
  & \text{unit} & \text{常量 unit} \\
  & \text{ref } t & \text{引用创建（reference creation）} \\
  & !t & \text{解引用（dereference）} \\
  & t := t & \text{赋值（assignment）} \\
  & l & \text{存储位置（store location）}
  \end{align*}
  $$

- **值（values）**：

  $$
  \begin{align*}
  v ::= \quad & \lambda x:T.\ t & \text{抽象值（abstraction value）} \\
  & \text{unit} & \text{常量 unit} \\
  & l & \text{存储位置（store location）}
  \end{align*}
  $$

- **类型（types）**：

  $$
  \begin{align*}
  T ::= \quad & T \to T & \text{函数类型（type of functions）} \\
  & \text{Unit} & \text{单位类型（unit type）} \\
  & \text{Ref } T & \text{引用单元类型（type of reference cells）}
  \end{align*}
  $$

- **上下文（contexts）**：

  $$
  \begin{align*}
  \Gamma ::= \quad & \emptyset & \text{空上下文（empty context）} \\
  & \Gamma,\ x:T & \text{项变量绑定（term variable binding）}
  \end{align*}
  $$

- **存储（stores）**：

  $$
  \begin{align*}
  \mu ::= \quad & \emptyset & \text{空存储（empty store）} \\
  & \mu,\ l = v & \text{位置绑定（location binding）}
  \end{align*}
  $$

- **存储类型（store typings）**：

  $$
  \begin{align*}
  \Sigma ::= \quad & \emptyset & \text{空存储类型（empty store typing）} \\
  & \Sigma,\ l:T & \text{位置类型（location typing）}
  \end{align*}
  $$

---

#### 求值

单步求值关系：$t\ |\ \mu \to t'\ |\ \mu'$

- **（E-App1）**：

  $$
  \frac{t_1\ |\ \mu \to t_1'\ |\ \mu'}{t_1\ t_2\ |\ \mu \to t_1'\ t_2\ |\ \mu'}
  $$

- **（E-App2）**：

  $$
  \frac{t_2\ |\ \mu \to t_2'\ |\ \mu'}{v_1\ t_2\ |\ \mu \to v_1\ t_2'\ |\ \mu'}
  $$

- **（E-AppAbs）**：

  $$
  (\lambda x:T_{11}.\ t_{12})\ v_2\ |\ \mu \to [x \mapsto v_2]t_{12}\ |\ \mu
  $$

- **（E-RefV）**：

  $$
  \frac{l \notin \text{dom}(\mu)}{\text{ref } v_1\ |\ \mu \to l\ |\ (\mu,\ l \mapsto v_1)}
  $$

- **（E-Ref）**：

  $$
  \frac{t_1\ |\ \mu \to t_1'\ |\ \mu'}{\text{ref } t_1\ |\ \mu \to \text{ref } t_1'\ |\ \mu'}
  $$

- **（E-DerefLoc）**：

  $$
  \frac{\mu(l) = v}{!l\ |\ \mu \to v\ |\ \mu}
  $$

- **（E-Deref）**：

  $$
  \frac{t_1\ |\ \mu \to t_1'\ |\ \mu'}{!t_1\ |\ \mu \to !t_1'\ |\ \mu'}
  $$

- **（E-Assign）**：

  $$
  \frac{}{l := v_2\ |\ \mu \to \text{unit}\ |\ [l \mapsto v_2]\mu}
  $$

- **（E-Assign1）**：

  $$
  \frac{t_1\ |\ \mu \to t_1'\ |\ \mu'}{t_1 := t_2\ |\ \mu \to t_1' := t_2\ |\ \mu'}
  $$

- **（E-Assign2）**：

  $$
  \frac{t_2\ |\ \mu \to t_2'\ |\ \mu'}{v_1 := t_2\ |\ \mu \to v_1 := t_2'\ |\ \mu'}
  $$

---

#### 类型规则

类型关系：$\Gamma\ |\ \Sigma \vdash t : T$

- **（T-Var）**：

  $$
  \frac{x:T \in \Gamma}{\Gamma\ |\ \Sigma \vdash x : T}
  $$

- **（T-Abs）**：

  $$
  \frac{\Gamma,\ x:T_1\ |\ \Sigma \vdash t_2 : T_2}{\Gamma\ |\ \Sigma \vdash \lambda x:T_1.\ t_2 : T_1 \to T_2}
  $$

- **（T-App）**：

  $$
  \frac{\Gamma\ |\ \Sigma \vdash t_1 : T_{11} \to T_{12} \quad \Gamma\ |\ \Sigma \vdash t_2 : T_{11}}{\Gamma\ |\ \Sigma \vdash t_1\ t_2 : T_{12}}
  $$

- **（T-Unit）**：

  $$
  \Gamma\ |\ \Sigma \vdash \text{unit} : \text{Unit}
  $$

- **（T-Loc）**：

  $$
  \frac{\Sigma(l) = T_1}{\Gamma\ |\ \Sigma \vdash l : \text{Ref } T_1}
  $$

- **（T-Ref）**：

  $$
  \frac{\Gamma\ |\ \Sigma \vdash t_1 : T_1}{\Gamma\ |\ \Sigma \vdash \text{ref } t_1 : \text{Ref } T_1}
  $$

- **（T-Deref）**：

  $$
  \frac{\Gamma\ |\ \Sigma \vdash t_1 : \text{Ref } T_{11}}{\Gamma\ |\ \Sigma \vdash !t_1 : T_{11}}
  $$

- **（T-Assign）**：

  $$
  \frac{\Gamma\ |\ \Sigma \vdash t_1 : \text{Ref } T_{11} \quad \Gamma\ |\ \Sigma \vdash t_2 : T_{11}}{\Gamma\ |\ \Sigma \vdash t_1 := t_2 : \text{Unit}}
  $$

---

### --------------------------------------

这段内容是对扩展后的 **$\lambda \to$ 演算**（简单类型 $\lambda$ 演算）进行**引用（Reference）**处理的形式化语法、求值规则、类型规则的总结。它引入了 **Unit** 类型以及引用相关的操作，比如**引用创建（reference creation）**、**解引用（dereference）**和**赋值（assignment）**，并为它们建立了相应的语法、求值规则和类型检查规则。下面我们逐条详解其中的公式和概念。

---

### 1. **语法（Syntax）**
语法部分描述了项（terms）、值（values）、类型（types）、上下文（contexts）、存储（stores）、存储类型（store typings）的结构。

#### **项（terms）**

$$
t ::= \quad x \quad \lambda x:T.\ t \quad t\ t \quad \text{unit} \quad \text{ref } t \quad !t \quad t := t \quad l
$$

- **$x$**：变量，用于表示项中的变量引用。
- **$\lambda x:T.\ t$**：抽象，用于定义带有类型 $T$ 的函数，其中 $t$ 是函数体。
- **$t\ t$**：应用，表示函数 $t_1$ 应用于 $t_2$ 的形式。
- **$\text{unit}$**：单位常量，表示没有有意义的返回值（类似于 `void` 或 `()` 的概念）。🥑
- **$\text{ref } t$**：引用创建，表示创建对项 $t$ 的引用。
- **$!t$**：解引用，表示获取引用 $t$ 对应的存储值。
- **$t := t$**：赋值，表示将 $t_2$ 赋值给引用 $t_1$。
- **$l$**：存储位置，用于表示内存中的一个具体位置。

这些项的引入使得 $\lambda \to$ 具有了引用相关的功能，可以🥑表示对存储的操作。

#### **值（values）**

$$
v ::= \quad \lambda x:T.\ t \quad \text{unit} \quad l
$$

- **$\lambda x:T.\ t$**：抽象值，表示一个定义了函数体 $t$ 的函数。
- 🥑**$\text{unit}$**：常量值，表示没有有意义的值，类似于 `()`。
- **$l$**：存储位置，表示引用的值是一个存储位置。

这些值扩展了系统，使得可以处理引用和位置。

#### **类型（types）**

$$
T ::= \quad T \to T \quad \text{Unit} \quad \text{Ref } T
$$

- **$T \to T$**：函数类型，表示从类型 $T_1$ 映射到类型 $T_2$ 的函数。
- 🥑**$\text{Unit}$**：单位类型，表示没有有意义的返回值。
- **$\text{Ref } T$**：引用类型，表示引用存储的单元，类型为 $T$。

这扩展了简单类型 $\lambda$ 演算的类型系统，引入了引用的概念。

#### **上下文（contexts）**

$$
\Gamma ::= \quad \emptyset \quad \Gamma,\ x:T
$$

- **$\Gamma$**：上下文，用来记录变量和它们的类型绑定。
- **$\Gamma,\ x:T$**：表示将变量 $x$ 和类型 $T$ 的绑定加入上下文。

上下文是类型检查过程中的重要部分，用来追踪项中的自由变量及其类型。

#### **存储（stores）**

$$
\mu ::= \quad \emptyset \quad \mu,\ l = v
$$

- **$\mu$**：存储，表示对内存中存储位置和存储值的映射。
- **$\mu,\ l = v$**：表示将位置 $l$ 与值 $v$ 绑定。

存储描述了对存储位置的管理，是操作引用的基础。

#### **存储类型（store typings）**

$$
\Sigma ::= \quad \emptyset \quad \Sigma,\ l:T
$$

- 🥑🥑🥑🥑🥑🥑**$\Sigma$**：存储类型，表示对存储位置与其类型的映射。
- 🥑🥑🥑🥑🥑🥑**$\Sigma,\ l:T$**：表示将位置 $l$ 与类型 $T$ 绑定。

存储类型为存储中的位置赋予了类型，确保每个存储位置的类型是固定的。

---

### 2. **求值规则（Evaluation Rules）**

求值关系表示为：$t\ |\ \mu \to t'\ |\ \mu'$，表示项 $t$ 在存储 $\mu$ 中求值，结果是项 $t'$ 和更新后的存储 $\mu'$。

#### **（E-App1）**

$$
\frac{t_1\ |\ \mu \to t_1'\ |\ \mu'}{t_1\ t_2\ |\ \mu \to t_1'\ t_2\ |\ \mu'}
$$

- 当应用项 $t_1\ t_2$ 进行求值时，首先对 $t_1$ 求值，产生 $t_1'$，并且存储从 $\mu$ 更新到 $\mu'$。
- 之后，更新后的应用表达式变为 $t_1'\ t_2$。

#### **（E-App2）**

$$
\frac{t_2\ |\ \mu \to t_2'\ |\ \mu'}{v_1\ t_2\ |\ \mu \to v_1\ t_2'\ |\ \mu'}
$$

- 如果 $t_1$ 是一个值 $v_1$，我们则对 $t_2$ 求值，产生 $t_2'$ 和更新的存储 $\mu'$。

#### **（E-AppAbs）**

$$
(\lambda x:T_{11}.\ t_{12})\ v_2\ |\ \mu \to [x \mapsto v_2]t_{12}\ |\ \mu
$$

- 当应用一个抽象函数时，函数体 $t_{12}$ 通过将 $x$ 绑定到 $v_2$ 进行替换，结果是替换后的项 $[x \mapsto v_2]t_{12}$。
- 存储 $\mu$ 保持不变。

#### **（E-RefV）**

$$
\frac{l \notin \text{dom}(\mu)}{\text{ref } v_1\ |\ \mu \to l\ |\ (\mu,\ l \mapsto v_1)}
$$

- 如果位置 $l$ 不在存储 $\mu$ 中，创建引用 `ref v_1`，并为该引用分配一个新的位置 $l$，将 $v_1$ 存储在 $l$ 中。

#### **（E-Ref）**

$$
\frac{t_1\ |\ \mu \to t_1'\ |\ \mu'}{\text{ref } t_1\ |\ \mu \to \text{ref } t_1'\ |\ \mu'}
$$

- 如果引用的右侧不是值，则对其进行求值，产生 $t_1'$ 和更新的存储 $\mu'$。

#### **（E-DerefLoc）**

$$
\frac{\mu(l) = v}{!l\ |\ \mu \to v\ |\ \mu}
$$

- 对存储位置 $l$ 解引用，得到位置 $l$ 对应的值 $v$。

#### **（E-Deref）**

$$
\frac{t_1\ |\ \mu \to t_1'\ |\ \mu'}{!t_1\ |\ \mu \to !t_1'\ |\ \mu'}
$$

- 如果解引用的项不是位置，先对该项求值。

#### **（E-Assign）**

$$
\frac{}{l := v_2\ |\ \mu \to \text{unit}\ |\ [l \mapsto v_2]\mu}
$$

- 将值 $v_2$ 赋给位置 $l$，并返回 `unit`，存储更新为 $[l \mapsto v_2]\mu$。

---

### 3. **类型规则（Typing Rules）**

类型规则描述了如何为表达式赋予类型。

#### **（T-Var）**

$$
\frac{x:T \in \Gamma}{\Gamma\ |\ \Sigma \vdash x : T}
$$

- 如果变量 $x$ 在上下文 $\Gamma$ 中具有类型 $T$，则 $x$ 的类型为 $T$。

#### **（T-Abs）**

$$
\frac{\Gamma,\ x:T_1\ |\ \Sigma \vdash t_2 : T_2}{\Gamma\ |\ \Sigma \vdash \lambda x:T_1.\ t_2 : T_1 \to T_2}
$$

- 如果在上下文 $\Gamma,\ x:T_1$ 中，$t_2$ 的类型是 $T_2$，那么抽象函数 $\lambda x:T_1.\ t_2$ 的类型是 $T_1 \to T_2$

。

#### **（T-App）**

$$
\frac{\Gamma\ |\ \Sigma \vdash t_1 : T_{11} \to T_{12} \quad \Gamma\ |\ \Sigma \vdash t_2 : T_{11}}{\Gamma\ |\ \Sigma \vdash t_1\ t_2 : T_{12}}
$$

- 如果 $t_1$ 的类型是 $T_{11} \to T_{12}$，$t_2$ 的类型是 $T_{11}$，那么应用 $t_1\ t_2$ 的类型是 $T_{12}$。

#### **（T-Unit）**

$$
\Gamma\ |\ \Sigma \vdash \text{unit} : \text{Unit}
$$

- 单位常量 `unit` 的类型是 `Unit`。

#### **（T-Loc）**

$$
\frac{\Sigma(l) = T_1}{\Gamma\ |\ \Sigma \vdash l : \text{Ref } T_1}
$$

- 如果位置 $l$ 在存储类型 $\Sigma$ 中的类型是 $T_1$，那么 $l$ 的类型是 `Ref T_1`。

#### **（T-Ref）**

$$
\frac{\Gamma\ |\ \Sigma \vdash t_1 : T_1}{\Gamma\ |\ \Sigma \vdash \text{ref } t_1 : \text{Ref } T_1}
$$

- 如果 $t_1$ 的类型是 $T_1$，那么 `ref t_1` 的类型是 `Ref T_1`。

#### **（T-Deref）**

$$
\frac{\Gamma\ |\ \Sigma \vdash t_1 : \text{Ref } T_{11}}{\Gamma\ |\ \Sigma \vdash !t_1 : T_{11}}
$$

- 如果 $t_1$ 是 `Ref T_{11}`，那么解引用 $!t_1$ 的类型是 $T_{11}$。

#### **（T-Assign）**

$$
\frac{\Gamma\ |\ \Sigma \vdash t_1 : \text{Ref } T_{11} \quad \Gamma\ |\ \Sigma \vdash t_2 : T_{11}}{\Gamma\ |\ \Sigma \vdash t_1 := t_2 : \text{Unit}}
$$

- 如果 $t_1$ 是类型 `Ref T_{11}` 的引用，$t_2$ 是类型 $T_{11}$ 的值，那么赋值操作 $t_1 := t_2$ 的类型是 `Unit`。

---

这些公式为扩展后的 $\lambda \to$ 系统引入了引用操作及其求值和类型规则，允许程序操作存储，并确保引用操作类型安全。

### --------------------------------------

非常抱歉之前的回答不够详细。下面我会逐步对你提供的内容进行更加详细的解说，不省略任何细节，同时解释公式中的每个符号和概念。

### 图13-1：引用（References）

本章节扩展了 $\lambda \to$ 演算，为其添加了对引用（reference）和单位类型（Unit）的支持。引用允许我们操作存储中的值，类似于C语言中的指针，但不允许像C那样进行不安全的指针操作。下面是它的语法、求值规则和类型检查规则的详细解释。

---

### 1. **语法（Syntax）**

在这个扩展中，我们引入了引用操作，并且扩展了原本的 $\lambda \to$ 语言的项、值、类型和上下文等部分。以下是扩展后的语法定义。

#### **项（terms）**

$$
t ::= \quad x \quad \lambda x:T.\ t \quad t\ t \quad \text{unit} \quad \text{ref } t \quad !t \quad t := t \quad l
$$

- **$x$**：变量（variable），可以在项 $t$ 中自由出现。
- **$\lambda x:T.\ t$**：抽象（abstraction），定义了一个类型为 $T$ 的匿名函数，其中 $x$ 是函数的参数，$t$ 是函数的主体。$T$ 是 $x$ 的类型。
- **$t\ t$**：应用（application），表示函数应用，即将项 $t_1$ 应用于项 $t_2$。
- **$\text{unit}$**：单位常量，表示没有有意义的返回值。类似于一些编程语言中的 `()` 或 `void`。
- **$\text{ref } t$**：引用创建（reference creation），用于创建对项 $t$ 的引用，即将 $t$ 存储在某个存储位置。
- **$!t$**：解引用（dereference），获取项 $t$ 所指向的存储位置中的值。
- **$t := t$**：赋值（assignment），表示将项 $t_2$ 赋给引用 $t_1$，即修改存储中 $t_1$ 所指向位置的值。
- **$l$**：存储位置（store location），表示存储中的一个具体位置。

通过这些扩展，$\lambda \to$ 演算不仅可以表达函数和变量，还可以处理引用、存储位置和赋值等操作。

#### **值（values）**

$$
v ::= \quad \lambda x:T.\ t \quad \text{unit} \quad l
$$

- **$\lambda x:T.\ t$**：抽象值，表示一个函数，它接受类型为 $T$ 的参数 $x$，并返回函数体 $t$。这种表示方式允许函数作为值。
- **$\text{unit}$**：单位值，表示没有有意义的返回值。类似于 C 语言中的 `void`，或者其他语言中的 `()`。
- **$l$**：存储位置值，表示一个存储位置。引用的值就是一个存储位置。

#### **类型（types）**

$$
T ::= \quad T \to T \quad \text{Unit} \quad \text{Ref } T
$$

- **$T \to T$**：函数类型，表示从类型 $T_1$ 映射到类型 $T_2$ 的函数。即如果函数的参数是 $T_1$，则返回值是 $T_2$。
- **$\text{Unit}$**：单位类型，表示没有有意义的返回值，这与 `unit` 值对应。
- **$\text{Ref } T$**：引用类型，表示存储中对类型为 $T$ 的值的引用。即，一个 `Ref T` 类型的项是指向一个存储位置的引用，而这个位置存储了类型为 $T$ 的值。

#### **上下文（contexts）**

$$
\Gamma ::= \quad \emptyset \quad \Gamma,\ x:T
$$

- **$\emptyset$**：空上下文，表示没有任何绑定的上下文。
- **$\Gamma,\ x:T$**：上下文 $\Gamma$ 与变量 $x$ 的类型绑定，表示在上下文中 $x$ 的类型为 $T$。

上下文用于跟踪自由变量的类型信息，这是类型检查时的重要组成部分。

#### **存储（stores）**

$$
\mu ::= \quad \emptyset \quad \mu,\ l = v
$$

- **$\emptyset$**：空存储，表示没有任何位置和值绑定的存储。
- **$\mu,\ l = v$**：存储 $\mu$ 增加一个绑定，将存储位置 $l$ 与值 $v$ 关联。

存储 $\mu$ 跟踪每个存储位置 $l$ 的当前值 $v$，它用于处理引用的操作。

#### **存储类型（store typings）**

$$
\Sigma ::= \quad \emptyset \quad \Sigma,\ l:T
$$

- **$\emptyset$**：空存储类型，表示没有存储位置与类型的绑定。
- **$\Sigma,\ l:T$**：存储类型 $\Sigma$ 中增加位置 $l$ 与类型 $T$ 的绑定，表示存储位置 $l$ 存储的是类型为 $T$ 的值。

存储类型 $\Sigma$ 确保存储中的每个位置都存储特定类型的值，从而使得操作是类型安全的。

---

### 🥑🥑🥑🥑🥑🥑🥑2. **求值规则（Evaluation Rules）**

在引用操作中，项的求值可能会影响存储的状态。因此，我们需要扩展 $\lambda \to$ 的求值关系。新的求值关系形如 $t\ |\ \mu \to t'\ |\ \mu'$，表示项 $t$ 在存储 $\mu$ 中归约为项 $t'$，同时存储更新为 $\mu'$。

#### **（E-App1）**：函数应用左侧求值

$$
\frac{t_1\ |\ \mu \to t_1'\ |\ \mu'}{t_1\ t_2\ |\ \mu \to t_1'\ t_2\ |\ \mu'}
$$

- **解释**：如果项 $t_1$ 在存储 $\mu$ 中求值为 $t_1'$ 并更新存储为 $\mu'$，则整个应用 $t_1\ t_2$ 求值为 $t_1'\ t_2$，存储更新为 $\mu'$。
- **符号解释**：
  - $t_1$ 和 $t_2$：分别是函数和参数。
  - $\mu$：表示当前的存储状态。
  - $t_1'$：表示 $t_1$ 求值后的结果。
  - $\mu'$：表示求值 $t_1$ 之后更新后的存储。

#### **（E-App2）**：函数应用右侧求值

$$
\frac{t_2\ |\ \mu \to t_2'\ |\ \mu'}{v_1\ t_2\ |\ \mu \to v_1\ t_2'\ |\ \mu'}
$$

- **解释**：如果函数 $v_1$ 的参数 $t_2$ 在存储 $\mu$ 中求值为 $t_2'$，并且存储更新为 $\mu'$，则整个应用 $v_1\ t_2$ 求值为 $v_1\ t_2'$，存储更新为 $\mu'$。
- **符号解释**：
  - $v_1$：表示一个函数值。
  - $t_2$：函数的参数。
  - $\mu$ 和 $\mu'$：表示求值前后的存储状态。

#### **（E-AppAbs）**：函数应用求值

$$
(\lambda x:T_{11}.\ t_{12})\ v_2\ |\ \mu \to [x \mapsto v_2]t_{12}\ |\ \mu
$$

- **解释**：当我们应用一个抽象函数时，函数的参数 $x$ 被替换为具体的值 $v_2$，并将函数体 $t_{12}$ 中的 $x$ 替换为 $v_2$ 继续求值。存储 $\mu$ 保持不变。
- **符号解释**：
  - $\lambda x:T_{11}.\ t_{12}$：表示一个抽象函数，它的参数是 $x$，类型为 $T_{11}$，函数体是 $t_{12}$。
  - $v_2$：表示具体传递给函数的值。
  - $[x \mapsto v_2]t_{12}$：表示将 $x$ 替换为 $v_2$ 后的项。

#### **（E-RefV）**：引用创建

$$
\frac{l \notin \text{dom}(\mu)}{\text{ref } v_1\ |\ \mu \to l\ |\ (\mu,\ l \mapsto v_1)}
$$



- **解释**：如果位置 $l$ 不在当前存储 $\mu$ 的定义域中，则创建引用 `ref v_1`，并为其分配一个新的存储位置 $l$，将 $v_1$ 存储在该位置中。存储 $\mu$ 更新为包含 $l \mapsto v_1$ 的映射。
- **符号解释**：
  - $v_1$：是被引用的值。
  - $l$：是新分配的存储位置。
  - $\mu$ 和 $(\mu,\ l \mapsto v_1)$：表示存储在引用创建前后的状态。

#### **（E-Ref）**：引用的右侧项求值

$$
\frac{t_1\ |\ \mu \to t_1'\ |\ \mu'}{\text{ref } t_1\ |\ \mu \to \text{ref } t_1'\ |\ \mu'}
$$

- **解释**：如果引用的右侧项 $t_1$ 不是值，则首先对其进行求值。即 `ref t_1` 中的 $t_1$ 需要先求值为 $t_1'$。
- **符号解释**：
  - $t_1$：是被引用的项。
  - $t_1'$：是 $t_1$ 的求值结果。

#### **（E-DerefLoc）**：解引用位置

$$
\frac{\mu(l) = v}{!l\ |\ \mu \to v\ |\ \mu}
$$

- **解释**：如果 $l$ 是一个存储位置，且存储 $\mu$ 中 $l$ 的值为 $v$，则解引用操作 $!l$ 直接返回存储中的值 $v$，存储 $\mu$ 不变。
- **符号解释**：
  - $l$：存储位置。
  - $\mu(l)$：表示存储 $\mu$ 中 $l$ 对应的值。
  - $v$：存储位置 $l$ 的值。

#### **（E-Deref）**：解引用项求值

$$
\frac{t_1\ |\ \mu \to t_1'\ |\ \mu'}{!t_1\ |\ \mu \to !t_1'\ |\ \mu'}
$$

- **解释**：如果解引用操作的项 $t_1$ 不是存储位置，则对 $t_1$ 进行求值，得到 $t_1'$，并继续对 $!t_1'$ 进行解引用。
- **符号解释**：
  - $t_1$ 和 $t_1'$：表示解引用的项及其求值结果。

#### **（E-Assign）**：赋值操作

$$
\frac{}{l := v_2\ |\ \mu \to \text{unit}\ |\ [l \mapsto v_2]\mu}
$$

- **解释**：如果存储位置 $l$ 是有效位置，则将值 $v_2$ 存储在位置 $l$ 中，存储更新为 $[l \mapsto v_2]\mu$，并返回 `unit` 表示赋值操作完成。
- **符号解释**：
  - $l$：存储位置。
  - $v_2$：要存储的值。
  - $\mu$ 和 $[l \mapsto v_2]\mu$：表示存储在赋值前后的状态。
  - `unit`：表示赋值操作的返回值，通常无意义。

#### **（E-Assign1）**：赋值左侧求值

$$
\frac{t_1\ |\ \mu \to t_1'\ |\ \mu'}{t_1 := t_2\ |\ \mu \to t_1' := t_2\ |\ \mu'}
$$

- **解释**：如果赋值操作的左侧 $t_1$ 不是存储位置，则对其进行求值，得到 $t_1'$，并将赋值操作更新为 $t_1' := t_2$。
- **符号解释**：
  - $t_1$ 和 $t_1'$：表示赋值左侧的项及其求值结果。

#### **（E-Assign2）**：赋值右侧求值

$$
\frac{t_2\ |\ \mu \to t_2'\ |\ \mu'}{v_1 := t_2\ |\ \mu \to v_1 := t_2'\ |\ \mu'}
$$

- **解释**：如果赋值操作的右侧 $t_2$ 不是值，则对 $t_2$ 进行求值，得到 $t_2'$，并将赋值操作更新为 $v_1 := t_2'$。
- **符号解释**：
  - $t_2$ 和 $t_2'$：表示赋值右侧的项及其求值结果。
  - $v_1$：表示赋值左侧的引用。

---

### 3. **类型规则（Typing Rules）**

类型检查关系为 $\Gamma\ |\ \Sigma \vdash t : T$，表示在上下文 $\Gamma$ 和存储类型 $\Sigma$ 下，项 $t$ 的类型为 $T$。我们需要确保所有项的类型都符合其上下文与存储中的预期类型。

#### **（T-Var）**：变量类型规则

$$
\frac{x:T \in \Gamma}{\Gamma\ |\ \Sigma \vdash x : T}
$$

- **解释**：如果变量 $x$ 的类型 $T$ 存在于上下文 $\Gamma$ 中，则 $x$ 的类型为 $T$。
- **符号解释**：
  - $x:T$：表示 $x$ 绑定的类型。
  - $\Gamma$：表示上下文，记录变量的类型信息。

#### **（T-Abs）**：抽象函数的类型规则

$$
\frac{\Gamma,\ x:T_1\ |\ \Sigma \vdash t_2 : T_2}{\Gamma\ |\ \Sigma \vdash \lambda x:T_1.\ t_2 : T_1 \to T_2}
$$

- **解释**：如果在上下文 $\Gamma$ 和存储类型 $\Sigma$ 下，项 $t_2$ 的类型为 $T_2$，则抽象函数 $\lambda x:T_1.\ t_2$ 的类型为 $T_1 \to T_2$，即从 $T_1$ 到 $T_2$ 的函数。
- **符号解释**：
  - $T_1 \to T_2$：表示函数类型，从 $T_1$ 到 $T_2$ 的映射。

#### **（T-App）**：应用的类型规则

$$
\frac{\Gamma\ |\ \Sigma \vdash t_1 : T_{11} \to T_{12} \quad \Gamma\ |\ \Sigma \vdash t_2 : T_{11}}{\Gamma\ |\ \Sigma \vdash t_1\ t_2 : T_{12}}
$$

- **解释**：如果项 $t_1$ 的类型是从 $T_{11}$ 到 $T_{12}$ 的函数类型，并且项 $t_2$ 的类型是 $T_{11}$，那么函数应用 $t_1\ t_2$ 的类型是 $T_{12}$。
- **符号解释**：
  - $T_{11} \to T_{12}$：函数类型，从 $T_{11}$ 到 $T_{12}$。

#### **（T-Unit）**：单位类型规则

$$
\Gamma\ |\ \Sigma \vdash \text{unit} : \text{Unit}
$$

- **解释**：常量 `unit` 的类型是 `Unit`。
- **符号解释**：
  - `Unit`：单位类型，表示没有有意义的返回值。

#### **（T-Loc）**：存储位置的类型规则

$$
\frac{\Sigma(l) = T_1}{\Gamma\ |\ \Sigma \vdash l : \text{Ref } T_1}
$$

- **解释**：如果存储类型 $\Sigma$ 中位置 $l$ 的类型是 $T_1$，则位置 $l$ 的类型为 `Ref T_1`，即引用类型。
- **符号解释**：
  - $\Sigma(l) = T_1$：表示存储类型 $\Sigma$ 中位置 $l$ 存储的是类型 $T_1$ 的值。
  - `Ref T_1`：表示存储位置的引用类型。

#### **（T-Ref）**：引用的类型规则

$$
\frac{\Gamma\ |\ \Sigma \vdash t_1 : T_1}{\Gamma\ |\ \Sigma \vdash \text{ref } t_1 : \text{Ref } T_1}
$$

- **解释**：如果项 $t_1$ 的类型是 $T_1$，则 `ref t_1` 的类型是 `Ref T_1`，表示一个存储了 $T_1$ 类型值的引用。
- **符号解释**：

  - `Ref T_1`：表示存储类型为 $T_1$ 的引用。

#### **（T-Deref）**：解引用的类型规则

$$
\frac{\Gamma\ |\ \Sigma \vdash t_1 : \text{Ref } T_{11}}{\Gamma\ |\ \Sigma \vdash !t_1 : T_{11}}
$$

- **解释**：如果 $t_1$ 的类型是 `Ref T_{11}`，那么解引用 $!t_1$ 的类型是 $T_{11}$，即引用的内容的类型。
- **符号解释**：
  - `Ref T_{11}`：表示引用类型。
  - $T_{11}$：引用存储的值的类型。

#### **（T-Assign）**：赋值的类型规则

$$
\frac{\Gamma\ |\ \Sigma \vdash t_1 : \text{Ref } T_{11} \quad \Gamma\ |\ \Sigma \vdash t_2 : T_{11}}{\Gamma\ |\ \Sigma \vdash t_1 := t_2 : \text{Unit}}
$$

- **解释**：如果 $t_1$ 是 `Ref T_{11}` 类型的引用，并且 $t_2$ 是类型为 $T_{11}$ 的值，那么赋值操作 $t_1 := t_2$ 的类型是 `Unit`。
- **符号解释**：
  - `Ref T_{11}`：表示引用类型。
  - `Unit`：赋值操作返回 `unit`，表示没有有意义的返回值。

---

### 总结

这套规则为 $\lambda \to$ 演算添加了对引用的支持，包括引用的创建、解引用和赋值操作，并通过存储 $\mu$ 和存储类型 $\Sigma$ 确保这些操作的类型安全。

### ---------------------------------------

### 13.5 安全性（Safety）

本章的最后一个任务是检查类型安全的标准性质对于带有引用的演算仍然成立。**进展定理（Progress Theorem）**（“良类型的项不会卡住”）可以像以前一样陈述和证明（参见 13.5.7）；我们只需要在证明中添加一些直接的情况，处理新构造。类型保持定理则有点更有趣，因此我们先看看它。

由于我们扩展了求值关系（包含初始和最终的存储）和类型关系（包含存储类型），我们需要更改类型保持定理的陈述以包含这些参数。但是，我们显然不能只添加存储和存储类型而不说明它们是如何关联的。

如果

$$
\Gamma\ |\ \Sigma \vdash t : T \\
t\ |\ \mu \to t'\ |\ \mu'
$$

那么

$$
\Gamma\ |\ \Sigma \vdash t' : T \quad \text{（错误！）}
$$

如果我们根据关于存储中值的类型的一组假设来类型检查，然后在违反这些假设的存储中进行求值，结果将是灾难性的。以下要求表达了我们需要的约束。

**定义 13.5.1**：如果 $\text{dom}(\mu) = \text{dom}(\Sigma)$，并且对于每个 $l \in \text{dom}(\mu)$，都有 $\Gamma\ |\ \Sigma \vdash \mu(l) : \Sigma(l)$，则称存储 $\mu$ **相对于**上下文 $\Gamma$ 和存储类型 $\Sigma$ **良类型的**（well typed），记作 $\Gamma\ |\ \Sigma \vdash \mu$。

直观上，如果存储中的每个值都具有存储类型预测的类型，则存储 $\mu$ 与存储类型 $\Sigma$ **一致**。

**练习 13.5.2** [««]：你能找到一个上下文 $\Gamma$、一个存储 $\mu$ 和两个不同的存储类型 $\Sigma_1$ 和 $\Sigma_2$，使得 $\Gamma\ |\ \Sigma_1 \vdash \mu$ 和 $\Gamma\ |\ \Sigma_2 \vdash \mu$ 都成立吗？

**解答**：

- 设 $\Gamma = \emptyset$，$\mu = (l \mapsto \text{unit})$。

- 定义两个存储类型：

  - $\Sigma_1 = (l \mapsto \text{Unit})$

  - $\Sigma_2 = (l \mapsto T)$，其中 $T$ 是 $\text{Unit}$ 的任意子类型（如果有子类型关系的话）。

- 在这两种情况下，只要 $\Gamma\ |\ \Sigma_i \vdash \mu(l) : \Sigma_i(l)$，那么 $\Gamma\ |\ \Sigma_i \vdash \mu$。

- 因此，对于不同的存储类型，$\mu$ 都可以是良类型的。

---

现在，我们可以陈述更接近所需的类型保持性质：

如果

$$
\Gamma\ |\ \Sigma \vdash t : T \\
t\ |\ \mu \to t'\ |\ \mu' \\
\Gamma\ |\ \Sigma \vdash \mu
$$

那么

$$
\Gamma\ |\ \Sigma \vdash t' : T \quad \text{（不够正确。）}
$$

这个陈述对于所有求值规则都是好的，除了分配规则（E-RefV）。问题在于该规则产生的存储比初始存储有更大的定义域，这使得上述陈述的结论失效：如果 $\mu'$ 包含一个新位置 $l$ 的绑定，那么 $l$ 不能在 $\Sigma$ 的定义域中，且 $t'$（肯定提到了 $l$）在 $\Sigma$ 下无法类型化。

显然，由于存储在求值过程中可以增加大小，我们需要允许存储类型也增长。这引出了类型保持性质的最终（正确）陈述：

**定理 13.5.3 [类型保持（Preservation）]**：如果

$$
\Gamma\ |\ \Sigma \vdash t : T \\
\Gamma\ |\ \Sigma \vdash \mu \\
t\ |\ \mu \to t'\ |\ \mu'
$$

那么，存在某个 $\Sigma' \supseteq \Sigma$，使得

$$
\Gamma\ |\ \Sigma' \vdash t' : T \\
\Gamma\ |\ \Sigma' \vdash \mu'
$$

请注意，类型保持定理仅断言存在某个存储类型 $\Sigma' \supseteq \Sigma$（即，在所有旧位置的值上与 $\Sigma$ 一致），使得新项 $t'$ 在 $\Sigma'$ 下是良类型的；它并没有确切告诉我们 $\Sigma'$ 是什么。直观上，很明显 $\Sigma'$ 要么是 $\Sigma$，要么是 $\Sigma$ 加上一个新的绑定 $(l \mapsto T_1)$，其中 $l$ 是新分配的位置，$T_1$ 是在扩展存储 $(\mu,\ l \mapsto v_1)$ 中绑定到 $l$ 的初始值的类型，但明确地陈述这一点会使定理的陈述复杂化，而不会使其更有用：上述较弱的版本已经处于正确的形式（因为它的结论暗含了它的假设），可以重复地“转动曲柄”，并得出每个求值步骤序列都保持良类型性。将此与进展性质结合，我们获得了通常的保证，即“良类型的程序永远不会出错”。

为了证明类型保持，我们需要一些技术性的引理。第一个是标准替换引理（9.3.8）的简单扩展。

**引理 13.5.4 [替换（Substitution）]**：如果 $\Gamma,\ x:S\ |\ \Sigma \vdash t : T$ 且 $\Gamma\ |\ \Sigma \vdash s : S$，那么 $\Gamma\ |\ \Sigma \vdash [x \mapsto s]t : T$。

**证明**：与引理 9.3.8 类似。

---

接下来，陈述将存储中某个单元的内容替换为适当类型的新值不会改变存储的整体类型。

**引理 13.5.5**：如果

$$
\Gamma\ |\ \Sigma \vdash \mu \\
\Sigma(l) = T \\
\Gamma\ |\ \Sigma \vdash v : T
$$

那么

$$
\Gamma\ |\ \Sigma \vdash [l \mapsto v]\mu
$$

**证明**：直接来自 $\Gamma\ |\ \Sigma \vdash \mu$ 的定义。

---

最后，我们需要存储的弱化引理，说明如果存储扩展了一个新位置，扩展后的存储仍然允许我们为与原来相同的项赋予类型。

**引理 13.5.6**：如果 $\Gamma\ |\ \Sigma \vdash t : T$ 且 $\Sigma' \supseteq \Sigma$，那么 $\Gamma\ |\ \Sigma' \vdash t : T$。

**证明**：容易的归纳。

---

现在我们可以证明主要的类型保持定理。

**证明（定理 13.5.3）**：对求值推导进行直接的归纳，使用上述引理和类型规则的反演性质（9.3.1 的直接扩展）。

---

**进展定理**（9.3.5）的陈述也必须扩展，以考虑存储和存储类型：

**定理 13.5.7 [进展（Progress）]**：假设 $t$ 是一个闭合的、良类型的项（即，对于某些 $T$ 和 $\Sigma$，有 $\emptyset\ |\ \Sigma \vdash t : T$）。那么，要么 $t$ 是一个值，要么对于任何满足 $\emptyset\ |\ \Sigma \vdash \mu$ 的存储 $\mu$，存在某个项 $t'$ 和存储 $\mu'$，使得 $t\ |\ \mu \to t'\ |\ \mu'$。

**证明**：对类型推导进行直接的归纳，遵循 9.3.5 的模式。（**规范形式引理**（Canonical Forms Lemma，9.3.4）需要两个额外的情况，说明类型为 $\text{Ref } T$ 的所有值都是位置，类型为 $\text{Unit}$ 的值是 $\text{unit}$。）

---

**练习 13.5.8** [推荐，«««]：在本章的演算中，求值关系对于良类型的项是归一化的吗？如果是，证明它。如果不是，请在当前演算中编写一个良类型的阶乘函数（扩展了数字和布尔值）。

**解答**：

- 答：不是归一化的。

- 虽然简单类型 $\lambda$ 演算（没有引用）是归一化的，但添加引用后，我们可以编写非终止的程序。

- 例如，我们可以利用引用和递归来编写一个非终止的阶乘函数。

- 由于演算中没有显式的递归机制，我们可以通过引用来模拟递归。

- 定义一个引用 $f$，并赋值一个函数，该函数在调用时再次调用 $f$，从而创建一个递归调用。

---

### ---------------------------------

在这段内容中，重点讨论了在加入了引用的情况下，类型安全性（safety）的保持问题。这里我们详解关键内容、公式以及其中的概念，确保清晰理解：

### 13.5 **安全性（Safety）**

#### 引言

🥑类型安全性是编程语言理论中的核心概念，它确保类型系统可以防止程序在运行时出现不期望的错误。具体来说，类型安全性包括两大性质：

1. **进展定理（Progress Theorem）**：任何良类型的项（well-typed term）要么是一个值（value），要么可以进行进一步的求值，而不会卡住（stuck）。
2. **类型保持定理（Preservation Theorem）**：如果一个良类型的项经过求值，求值后的结果仍然是良类型的。

#### 1. **类型保持定理的陈述和问题**

由于求值和类型检查的扩展引入了存储和存储类型，类型保持定理需要修正，以反映存储的变化。

🥑首先，原始的类型保持定理可以被理解为：如果项 $t$ 在类型检查时是良类型的，且 $t$ 可以求值为 $t'$，那么 $t'$ 也是良类型的。然而，在处理引用时，简单地说“$t$ 在求值后的类型保持不变”是不够的。因为在求值过程中，存储可能会发生变化，比如分配新的存储位置。在这种情况下，原有的🥑存储类型 $\Sigma$ 可能不足以描述新的存储状态。

#### **错误的类型保持陈述：**

$$
\Gamma\ |\ \Sigma \vdash t : T \quad t\ |\ \mu \to t'\ |\ \mu' \quad \Rightarrow \quad \Gamma\ |\ \Sigma \vdash t' : T
$$

这个陈述🥑并不总是成立。原因在于，存储 🥑$\mu'$ 可能包含新的位置，而 $\Sigma$ 并没有扩展以包含新位置的类型信息。因此，类型保持定理需要允许存储类型 $\Sigma$ 在求值过程中扩展。

#### 2. **存储的良类型性**

为了确保存储在求值过程中也是类型安全的，我们引入了存储的良类型性定义。

**定义 13.5.1：存储 $\mu$ 的良类型性**

如果存储 $\mu$ 和存储类型 $\Sigma$ 满足以下条件：

- **存储 $\mu$ 和存储类型 $\Sigma$ 的定义域相同**，即 $\text{dom}(\mu) = \text{dom}(\Sigma)$。
- 对于每个存储位置 $l$，存储中该位置的值 $\mu(l)$ 的类型与存储类型 $\Sigma(l)$ 中给出的类型一致，即 $\Gamma\ |\ \Sigma \vdash \mu(l) : \Sigma(l)$。

那么我们称 $\mu$ 是 **相对于** 上下文 $\Gamma$ 和存储类型 $\Sigma$ 的 **良类型存储**，记作：

$$
\Gamma\ |\ \Sigma \vdash \mu
$$

这意味着，存储 $\mu$ 中的每个值都与存储类型 $\Sigma$ 一致。

#### 3. **类型保持定理的最终陈述**

**定理 13.5.3 [类型保持定理]**：如果

- $\Gamma\ |\ \Sigma \vdash t : T$
- $\Gamma\ |\ \Sigma \vdash \mu$
- $t\ |\ \mu \to t'\ |\ \mu'$

那么，存在某个扩展的存储类型 $\Sigma' \supseteq \Sigma$，使得：

$$
\Gamma\ |\ \Sigma' \vdash t' : T \quad \text{且} \quad \Gamma\ |\ \Sigma' \vdash \mu'
$$

解释：

- $t$ 是良类型的，类型为 $T$，存储 $\mu$ 也符合存储类型 $\Sigma$。
- 如果 $t$ 在存储 $\mu$ 中求值为 $t'$ 并更新了存储 $\mu'$，那么我们可以找到一个新的存储类型 $\Sigma'$，该存储类型扩展了 $\Sigma$，包含了新的存储位置的类型信息。
- 在这个扩展的存储类型 $\Sigma'$ 下，项 $t'$ 仍然是类型 $T$，并且更新后的存储 $\mu'$ 也是良类型的。

这个定理表明，求值过程可能会扩展存储，但类型系统能够自动跟踪这些变化，确保类型安全性不被破坏。

#### 4. **引理 13.5.4：替换引理**

**替换引理（Substitution Lemma）**：如果

$$
\Gamma,\ x:S\ |\ \Sigma \vdash t : T \quad \Gamma\ |\ \Sigma \vdash s : S
$$

那么：

$$
\Gamma\ |\ \Sigma \vdash [x \mapsto s]t : T
$$

这个引理是替换引理的扩展形式，证明了我们可以在良类型的上下文中用项 $s$ 替换项 $t$ 中的变量 $x$，并且替换后的项仍然保持类型 $T$。

#### 5. **进展定理（Progress Theorem）**

**定理 13.5.7 [进展定理]**：假设 $t$ 是一个闭合的、良类型的项（即，对于某些 $T$ 和 $\Sigma$，有 $\emptyset\ |\ \Sigma \vdash t : T$）。那么：

- 要么 $t$ 是一个值，
- 要么对于任何满足 $\emptyset\ |\ \Sigma \vdash \mu$ 的存储 $\mu$，存在某个项 $t'$ 和存储 $\mu'$，使得 $t\ |\ \mu \to t'\ |\ \mu'$。

这意味着，良类型的项要么是一个值，要么可以继续进行求值，而不会卡住。

### 总结

通过这些定理和引理，确保了扩展了引用和存储的演算仍然保持类型安全性。特别是，通过允许存储类型随着存储的扩展而更新，解决了求值过程中出现的新存储位置无法被原有存储类型描述的问题。

这套理论框架为处理引用提供了强大的类型安全保证，确保良类型的程序在求值过程中不会出现类型错误。

### ---------------------------------

### 13.6 注释（Notes）

本章的内容改编自 Harper（1994，1996）的处理方式。Wright 和 Felleisen（1994）也以类似的风格给出了描述。

将引用（或其他计算效应）与 ML 风格的多态类型推断相结合会引发一些相当微妙的问题（参见第22.7节），在研究文献中受到大量关注。参见 Tofte（1990）、Hoang 等（1993）、Jouvelot 和 Gifford（1991）、Talpin 和 Jouvelot（1992）、Leroy 和 Weis（1991）、Wright（1992）、Harper（1994，1996）及其中引用的文献。

对可能的别名进行静态预测是编译器实现（称为**别名分析**，alias analysis）和编程语言理论中的一个长期问题。Reynolds（1978，1989）的有影响力的早期尝试创造了术语**干扰的句法控制**（syntactic control of interference）。这些思想最近出现了新的活跃研究——参见 O'Hearn 等（1995）和 Smith 等（2000）。关于别名的更一般的推理技术，见 Reynolds（1981）和 Ishtiaq 与 O'Hearn（2001）及其中引用的其他文献。

关于垃圾回收的全面讨论可以在 Jones 和 Lins（1996）中找到。更语义化的处理见 Morrisett 等（1995）。

### ----------------------------

### 13.6 **注释（Notes）**

这一部分主要介绍了本章内容的来源、与引用相关的研究工作、以及与引用结合多态类型推断带来的问题。此外，别名分析和垃圾回收等相关主题也在此作了介绍。

#### 1. **内容来源**

本章内容改编自 Harper 的研究工作，主要参考文献包括：

- **Harper (1994, 1996)**：Harper 的处理方法对于引用与类型系统的结合进行了深入的讨论，并为类型安全提供了形式化基础。

- **Wright 和 Felleisen (1994)**：这篇文章也采用了类似风格来描述引用与类型安全性。Wright 和 Felleisen 对于类型推断与引用的处理提出了重要的理论贡献。

#### 2. **引用与多态类型推断的问题**

**🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑引用（references）** 和 **多态类型推断（polymorphic type inference）** 的结合会带来一些微妙的问题，尤其是在 ML 风格的语言中。这是因为引用引入了状态的变化，而多态类型系统允许类型参数的泛化，导致了在推断和检查类型时存在复杂的相互作用。

##### **为什么引用与多态类型推断的问题会变得复杂？**

当一个多态函数涉及引用时，它的行为可能与纯粹的函数不同。🥑🥑🥑🥑🥑引用的状态性意味着每次访问引用的值时，它的类型可能发生变化。因此，在多态推断中如何确保这些引用的一致性和安全性是非常具有挑战性的。

例如，当我们考虑以下 ML 风格的代码：

```ml
let r = ref [] in
r := [1]; !r
```

在多态类型系统中，如果不加限制，`ref []` 可能会被推断为 `ref α list`（泛型引用类型），但随后的 `r := [1]` 会将 `r` 的类型具体化为 `ref int list`，这可能导致类型不一致。

##### **研究文献中的相关工作**

研究者们为解决这种复杂性提出了不同的方案：

- **Tofte (1990)** 提出了🥑以区域为基础的内存管理系统来处理引用的多态性。
- **Hoang 等 (1993)**、**Jouvelot 和 Gifford (1991)** 以及 **Talpin 和 Jouvelot (1992)** 也研究了不同的静态分析方法，帮助编译器正确推断带引用的多态函数类型。
- **Leroy 和 Weis (1991)** 和 **Wright (1992)** 的研究进一步探讨了在多态类型系统中如何安全地处理引用。
- **Harper (1994, 1996)** 的研究为多态类型推断与引用的结合提供了形式化的解释和证明，奠定了后续研究的基础。

这些研究共同探讨了如何在不引入运行时错误的前提下，安全地结合引用与多态类型推断。引用的问题和复杂性不仅在理论上，而且在实际编程语言设计中都是一个关键问题。

#### 3. **别名分析（Alias Analysis）**

**别名分析** 是编译器优化和编程语言理论中的重要问题。它试图在静态分析过程中确定哪些变量或内存位置可能引用同一个存储位置，从而帮助编译器在优化时避免错误。

##### **Reynolds 的“干扰的句法控制”**

Reynolds 的工作对于早期的别名分析和干扰控制做出了重要贡献，尤其是他的“干扰的句法控制”理论（syntactic control of interference）提出了一种基于句法的方法来控制内存中别名可能产生的干扰。

- **Reynolds (1978, 1989)** 提出的方法影响了后来的很多别名分析技术。这种方法通过限制别名和干扰的方式确保引用操作的安全性。
  
##### **别名分析的现代发展**

- **O'Hearn 等 (1995)** 和 **Smith 等 (2000)**：他们的研究重新激发了别名分析的活跃研究，提出了现代别名分析中使用的多种推理技术。
- **Ishtiaq 和 O'Hearn (2001)**：进一步探讨了更复杂的别名分析技术及其在编译器中的应用。

##### **别名分析的重要性**

别名分析对于编译器的优化至关重要。例如，当一个变量有多个别名时，修改其中一个别名的值可能会影响其他别名的值，因此编译器在优化时必须仔细处理这些别名关系。别名分析能够帮助编译器确定哪些变量不会受到其他变量修改的影响，从而安全地进行代码优化。

#### 4. **垃圾回收**

**垃圾回收（Garbage Collection, GC）** 是管理动态内存分配的一种机制。它自动回收不再使用的内存，避免内存泄漏。

- **Jones 和 Lins (1996)** 的工作为垃圾回收提供了全面的讨论，涉及多种垃圾回收算法和技术。
  
##### **更语义化的处理**

Morrisett 等 (1995) 提出了一种基于语义的垃圾回收方法，即从程序的语义特性出发，确保只回收那些绝对不再使用的内存。这种方法更加精确，但也更复杂。

##### **垃圾回收与引用的结合**

引用的存在使得垃圾回收的设计变得更加复杂，尤其是在别名存在的情况下，垃圾回收器需要确保某些内存位置不会因为误判而被回收。为此，现代编程语言设计往往结合了精确的别名分析与高效的垃圾回收机制，以确保内存管理的安全性和高效性。

### 总结

本章总结了引用的类型系统及其类型安全性问题，并提到了引用在多态类型推断中的复杂性。研究者们针对引用与多态性的结合提出了多种解决方案。别名分析和垃圾回收也是与引用密切相关的重要主题，分别在编译器优化和内存管理中扮演重要角色。

通过这些研究和技术，编程语言能够更好地处理复杂的引用和状态性操作，同时保持类型安全性

### ----------------------------

在编程语言的理论和实践中，**Unit 类型**频繁出现的原因主要是由于它在**类型系统**和**语义设计**中的特殊作用。`Unit` 是一个非常简单的类型，其唯一值通常是 `()`。这个类型频繁出现的原因可以从几个角度进行分析，包括它在**表示没有有意义的返回值**、**副作用函数**、**控制结构**、以及**程序流程控制**中的重要性。

### 1. **表示没有有意义的返回值**

`Unit` 类型最常用的场景之一是在函数没有返回有意义的值时。某些函数的主要目的是执行副作用（如打印、修改全局变量、更新存储等），而不返回一个有用的结果。这类函数的返回类型通常是 `Unit`，表明🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑🥑它们的执行不是为了产生值，而是为了产生某种**副作用**。

例如，在命令式语言中，`Unit` 类型类似于 **void** 类型，表示函数完成任务后没有返回值。

#### **示例：Scala**

```scala
def printMessage(msg: String): Unit = {
  println(msg)
}
```

这里的 `printMessage` 函数返回 `Unit`，表明该函数不返回有用的值，但会执行打印操作。

#### **示例：Haskell**

```haskell
main :: IO ()
main = do
  putStrLn "Hello, World!"
```

在 Haskell 中，`IO ()` 表示一个执行 I/O 操作的函数，它的返回值类型是 `()`，也就是 `Unit` 类型。该函数的主要目的是产生副作用，而非返回值。

### 2. **副作用函数**

`Unit` 类型在表示**副作用函数**中非常有用，特别是在**纯函数式编程**中。由于函数式编程语言中的函数应该是**纯函数**（即没有副作用，只根据输入产生输出），所以副作用函数（如 I/O 操作、写入存储等）通常用 `Unit` 来表示它们没有返回有意义的结果，而只是执行了某种动作。

### 3. **控制结构的占位符**

在许多编程语言中，`Unit` 类型充当**占位符**，特别是在**控制结构**中。例如，`if-else`、`while` 等控制结构可能不返回有用的值，但依然需要一个返回类型。在这种情况下，`Unit` 类型可以作为默认的返回类型。

#### **示例：Scala 中的 `if-else` 表达式**

```scala
val result: Unit = if (x > 0) println("Positive") else println("Negative")
```

在这个例子中，`if-else` 表达式本身没有返回一个有意义的值，因此 `result` 的类型是 `Unit`。

### 4. **表达计算的结束**

在形式化语义中，`Unit` 类型通常被用作计算结束的标志。例如，当表达式执行完成，但不需要返回有意义的结果时，计算的结束会返回 `Unit` 类型，这表示操作已经完成。

#### **示例：赋值操作**

在大多数语言中，赋值操作通常不返回有意义的结果，只是更新存储中的值。形式化语义中，赋值操作的结果通常是 `Unit` 类型。

```scala
var x = 0
val result: Unit = x = 10
```

在这个例子中，赋值操作 `x = 10` 不返回一个值，因此 `result` 的类型是 `Unit`。

### 5. **类型系统的一致性**

`Unit` 类型在**类型系统设计**中起到使类型系统一致的作用。由于 `Unit` 是一个非常简单且易于推导的类型，它在某些没有其他合理返回值的情况下充当🥑🥑🥑🥑“默认类型”，确保所有表达式都有类型，这对语言的类型检查器和类型推导系统来说非常重要。

- 例如，在编译器的设计中，某些语言要求每个函数都要有返回类型，即使函数不返回任何有意义的值。这时，`Unit` 类型就可以被用作默认的返回类型。

### 6. **程序流程控制**

在某些程序流程控制中，`Unit` 类型也会作为一种返回类型的占位符。特别是当我们关注副作用和控制流的运转，而不关注具体的返回值时，`Unit` 类型提供了一个明确的占位符，以保持程序逻辑和类型系统的一致性。

#### **示例：递归函数的基例**

递归函数的基例有时返回 `Unit` 类型，表示递归结束时不返回有意义的值，🥑🥑🥑🥑🥑只是终止递归。

```scala
def countdown(n: Int): Unit = {
  if (n > 0) {
    println(n)
    countdown(n - 1)
  } else {
    println("Done")
  }
}
```

在这个例子中，`countdown` 函数递归打印数字，最后的 `else` 分支返回 `Unit` 类型，表示递归结束。

### 7. **计算无返回值的表达式**

在某些场景下，我们会遇到不返回值的表达式或函数。比如在表达式计算的过程中，某些表达式并不关心返回值，`Unit` 类型用来表示这些情况。例如，在命令式编程中，许多表达式并不需要返回值（如打印、赋值等操作）。

---

### 总结

**Unit 类型频繁出现的原因**可以归结为它在编程语言设计中的特殊作用，特别是在表示没有有意义的返回值、处理副作用、占位符和保持类型系统一致性等场景下。它是一个简洁而有力的概念，能够在不需要有意义值的场合提供一个明确的占位符，确保程序的正确性和类型系统的一致性。

以下是关于 **Unit 类型** 多角度全面的对比表格，涵盖了 **Unit 类型** 的作用、用途、实现及其在不同编程语言中的表现。

| **方面**                 | **描述**                                                     | **举例**                                                     | **应用场景**                                                 | **Unit 与其他类型的对比**                                |
| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------------------------- |
| **类型定义**             | Unit 类型是一个只有一个值的类型，通常表示为 `()`，用来表示“没有有意义的返回值”或“占位符”。 | Haskell 中的 `()`；Scala 中的 `()`                           | 用于表示函数或表达式没有返回有意义的值，或操作的结果是无效的 | 与 `void` 不同，`Unit` 是真正的类型，有一个具体的值。    |
| **唯一值**               | `Unit` 类型只有一个值，通常写作 `()` 或类似符号，这个值也称为 `unit`。 | `()` 或 `unit`                                               | 用来表达“空”值或无实际意义的返回值。                         | `void` 没有值，而 `Unit` 有唯一的值。                    |
| **表示没有返回值**       | Unit 类型常用来表示函数没有有意义的返回值，函数执行后仅产生副作用。 | Haskell: `IO ()`；Scala: `Unit` 函数                         | 副作用函数，如打印、修改全局变量等。                         | `void` 类型在命令式语言中用于类似目的，但不是类型。      |
| **副作用函数**           | Unit 类型表明函数的目的是执行副作用，而非返回值。            | Scala 中的 `println()` 返回 `Unit`；Haskell 中 `putStrLn` 返回 `()` | 副作用函数在命令式编程和函数式编程中的使用。                 | 函数式编程中常见于 I/O 操作，命令式语言中用 `void`。     |
| **占位符**               | Unit 类型可以作为占位符，在控制结构或表达式中使用，表示没有返回值。 | Scala 中 `if-else` 表达式的返回类型可以是 `Unit`。           | 适用于控制结构或表达式计算时不关心返回值。                   | 与返回值类型有关的语言中，`Unit` 用于维持一致性。        |
| **控制结构**             | 在某些控制结构中，`Unit` 类型用作结果占位符，保持程序逻辑一致性。 | Scala 中的 `if-else`；Haskell 中的条件表达式                 | 用于分支控制、递归等需要占位符的情景。                       | 使得表达式可以有一致的类型。                             |
| **递归基例**             | 递归函数的基例通常返回 `Unit`，表示递归终止。                | Scala 中递归函数 `countdown` 基例返回 `Unit`。               | 递归基例常用 `Unit` 来表示递归结束。                         | 与其他返回有意义值的递归函数对比，`Unit` 表示结束。      |
| **计算结束的标识**       | `Unit` 类型可以用来表示计算的结束，尤其是在没有返回值的表达式或语句中。 | 赋值操作在某些语言中返回 `Unit`，表示计算完成。              | 赋值语句、状态变更语句返回 `Unit` 以保持类型系统的完整性。   | 在命令式语言中，赋值不需要有返回值。                     |
| **类型系统中的作用**     | `Unit` 类型有助于保持类型系统的一致性，尤其是当函数必须有返回类型时，但实际没有有意义的返回值。 | 编译器要求每个函数必须有返回类型时，`Unit` 是默认的返回类型。 | 在类型系统要求每个函数都有返回类型的编程语言中，`Unit` 是默认的占位符类型。 | 在不返回有意义值的函数中保持类型一致性。                 |
| **与 `void` 的对比**     | `Unit` 是一个真正的类型，有一个值 `()`；`void` 不是类型，仅表示函数没有返回值。 | Java 中 `void` 函数与 Haskell 中 `Unit` 函数的对比。         | 适用于函数没有返回值但需要维持类型系统一致性的场景。         | `Unit` 是类型，`void` 不是类型，只是语法约定。           |
| **函数的返回类型**       | `Unit` 类型表示那些没有返回有意义值的函数，例如打印函数、I/O 操作函数等。 | Haskell 中的 `IO ()`；Scala 中的 `Unit`。                    | 当一个函数只执行操作，而不返回有意义的结果时，`Unit` 被用作返回类型。 | 在函数没有有意义返回值的情况下保持函数类型的一致性。     |
| **类型推导中的作用**     | 在类型推导中，`Unit` 类型确保即使没有有意义的返回值，表达式依然有类型。 | Haskell 类型推导中，即使函数没有返回值，也会推导出类型为 `IO ()`。 | 类型推导系统中，`Unit` 用于占位，避免没有返回类型的情况出现。 | `Unit` 确保表达式始终有类型，避免编译错误。              |
| **I/O 操作中的使用**     | 在 I/O 操作中，`Unit` 类型常被用作函数的返回类型，表示操作本身没有返回值，但会产生副作用。 | Haskell 中的 `print` 操作返回 `()`；Scala 中 `println` 返回 `Unit`。 | I/O 操作和副作用函数中常用 `Unit` 来表示操作的完成。         | 在需要副作用且无返回值的 I/O 操作中，`Unit` 是默认选择。 |
| **形式化语义中的作用**   | `Unit` 类型在形式化语义中用于表示没有有意义的返回值的计算，并作为操作语义的占位符。 | 赋值操作返回 `Unit`，表示操作已完成且无返回值。              | 形式化语义中，用于定义求值结果没有返回值的操作。             | 确保形式化语义中的计算有统一的返回类型。                 |
| **命令式编程中的替代品** | 在命令式编程中，`void` 用于代替 `Unit`，表示函数或过程没有返回值，但 `void` 不是类型，而是一个语法规则。 | C、Java 中的 `void` 函数；C# 中的 `void`。                   | `void` 表示命令式语言中没有返回值的函数或过程，但无法用于表达式计算。 | `void` 不是类型，只能用于函数签名。                      |
| **控制流中的角色**       | 在控制流结构中（如 `if-else` 或 `while`），当没有有意义的返回值时，`Unit` 类型作为占位符来保证类型系统的完整性。 | Scala 中的 `if-else` 或 `while` 结构可能返回 `Unit`。        | 控制流语句中的分支结构可能没有返回有意义的值时，`Unit` 用于保持类型一致性。 | 保证控制流语句始终有返回值，避免类型不一致。             |
| **解释器中的实现**       | 在解释器或编译器设计中，`Unit` 类型用来表示没有返回值的操作的求值结果，并确保计算流的统一。 | 在 Racket 或 Haskell 解释器设计中，`Unit` 类型常用于表示计算结束的操作结果。 | 解释器设计中，`Unit` 用于表示某些操作没有返回值，并用于保持求值流的统一性。 | 确保求值器能够正确处理没有返回值的操作。                 |

---

### 总结：
这个表格从多个角度分析了 **Unit 类型** 的作用和用途，并将其与其他相关类型（如 `void`）进行对比。通过这个全面的分析，你可以理解 **Unit 类型** 在编程语言中的多重作用：它不仅仅是为了处理没有返回值的场景，还在副作用函数、控制结构、类型推导和解释器设计中起到关键作用。

如果你需要对某个特定点进行更深入的解释或进一步的代码示例，欢迎随时提出！

### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------
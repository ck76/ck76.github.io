[toc]



**第13章 引用（References）**

到目前为止，我们已经讨论了各种纯语言特性，包括函数抽象（functional abstraction）、基本类型（basic types）如数字和布尔值，以及结构类型（structured types）如记录（records）和变体（variants）。这些特性构成了大多数编程语言的骨干，包括纯函数式语言如 Haskell、“主要是函数式”的语言如 ML、命令式语言如 C，以及面向对象语言如 Java。

大多数实用的编程语言还包括各种**非纯的特性**（impure features），这些特性无法用我们目前使用的简单语义框架来描述。特别地，除了产生结果外，这些语言中的项的求值可能会对可变变量进行赋值（mutable variables，如引用单元 reference cells、数组 arrays、可变记录字段 mutable record fields 等），对文件、显示器或网络连接进行输入输出（I/O），通过异常（exceptions）、跳转（jumps）或连续体（continuations）进行非本地控制转移，进行进程间的同步和通信，等等。在编程语言的文献中，这些计算的“副作用”更一般地称为**计算效应**（computational effects）。

在本章中，我们将看到一种计算效应——**可变引用**（mutable references）——如何添加到我们已经研究的演算中。主要的扩展将是显式地处理存储器（store，也称为堆 heap）。这个扩展的定义是直接的；最有趣的部分是我们需要对类型保持定理（type preservation theorem，13.5.3）进行细化。我们将在第14章讨论另一种效应——异常（exceptions）和非本地控制转移。

---

### 13.1 引言（Introduction）

几乎每种编程语言都提供了一种赋值操作（assignment operation），用于改变先前分配的存储空间的内容。

**注**：本章研究的系统是带有 Unit 和引用（References，见图13-1）的简单类型 $\lambda$ 演算（simply typed lambda-calculus）。关联的 OCaml 实现是 $fullref$。

**绑定（Binding）**和**赋值（Assignment）**的机制在一些语言中（特别是 ML 及其相关语言）是分开的。我们可以有一个变量 $x$，其值是数字 $5$；或者一个变量 $y$，其值是指向一个当前内容为 $5$ 的可变单元（mutable cell）的**引用（reference）**（或指针 pointer）。这个区别对于程序员是可见的。我们可以将 $x$ 加到另一个数字上，但不能对它赋值。我们可以直接使用 $y$ 给它指向的单元赋予一个新值（通过写作 $y := 84$），但不能直接将其作为 $plus$ 的参数。相反，我们必须显式地对其解引用（dereference），写作 $!y$ 来获得其当前内容。在大多数其他语言中，特别是在所有 C 家族的成员（包括 Java）中，每个变量名都引用一个可变单元，对变量进行解引用以获取其当前内容的操作是**隐式的**。

**重要提示**：严格来说，在 C 或 Java 中，类型为 $T$ 的大多数变量实际上应该被视为指向包含类型为 $\text{Option}(T)$ 的值的单元的指针，反映了变量的内容可以是一个正常值或特殊值 $null$。

**对于形式化的研究**，将这些机制分开是有用的；我们的发展将紧密遵循 ML 的模型。将这里学到的经验应用到类似 C 的语言上，只需简单地合并一些区别，并将某些操作（如解引用）从显式变为隐式即可。

#### 基础

引用的基本操作是**分配（allocation）**、**解引用（dereferencing）**和**赋值（assignment）**。要分配一个引用，我们使用 $ref$ 操作符，提供新单元的初始值。

```haskell
r = ref 5;
⊢ r : Ref Nat
```

类型检查器的响应表明，$r$ 的值是一个引用，指向一个总是包含数字的单元。要读取该单元的当前值，我们使用解引用操作符 $!$。

```haskell
!r;
⊢ 5 : Nat
```

要改变存储在该单元中的值，我们使用赋值操作。

```haskell
r := 7;
⊢ unit : Unit
```

**注意**：赋值的结果是平凡的 $unit$ 值（参见第11.2节）。如果我们再次解引用 $r$，我们会看到更新后的值。

```haskell
!r;
⊢ 7 : Nat
```

#### 副作用和序列化（Side Effects and Sequencing）

赋值表达式的结果是平凡的值 $unit$，这与第11.3节定义的序列化符号非常契合，允许我们写作：

```haskell
(r := succ(!r); !r);
⊢ 8 : Nat
```

而不是等价但更繁琐的：

```haskell
(λ_:Unit. !r) (r := succ(!r));
⊢ 9 : Nat
```

来按顺序求值两个表达式并返回第二个表达式的值。将第一个表达式的类型限制为 $Unit$ 有助于类型检查器捕获一些愚蠢的错误，因为它允许我们仅在确实保证值是平凡的情况下丢弃第一个值。

注意，如果第二个表达式也是一个赋值，那么整个序列的类型将是 $Unit$，因此我们可以合法地将其放在另一个 $;$ 的左侧，构建更长的赋值序列：

```haskell
(r := succ(!r); r := succ(!r); r := succ(!r); r := succ(!r); !r);
⊢ 13 : Nat
```

#### 引用和别名（References and Aliasing）

牢记绑定到 $r$ 的**引用**与该引用指向的存储器中的**单元**之间的区别是很重要的。

```haskell
[图示：r 指向一个值为 13 的存储单元]
```

如果我们复制 $r$，例如将其值绑定到另一个变量 $s$：

```haskell
s = r;
⊢ s : Ref Nat
```

那么被复制的只是引用（图中的箭头），而不是单元：

```haskell
[图示：r 和 s 都指向值为 13 的同一存储单元]
```

我们可以通过对 $s$ 进行赋值来验证这一点：

```haskell
s := 82;
⊢ unit : Unit
```

并通过 $r$ 读取它：

```haskell
!r;
⊢ 82 : Nat
```

引用 $r$ 和 $s$ 被称为指向同一单元的**别名（aliases）**。

**练习 13.1.1** [«]：画出类似的图示，展示计算表达式 $a = {ref 0, ref 0}$ 和 $b = (λx:Ref Nat. {x,x}) (ref 0)$ 的效果。

**解答**：

1. 对于 $a = {ref 0, ref 0}$：

   - $ref 0$ 被计算两次，产生两个不同的引用，分别指向两个不同的存储单元，初始值都是 $0$。

   ```haskell
   [图示]
   a = { l1, l2 }
   l1 指向 0
   l2 指向 0
   ```

2. 对于 $b = (λx:Ref Nat. {x,x}) (ref 0)$：

   - $ref 0$ 只被计算一次，产生一个引用 $l$，传递给函数，函数返回 ${x, x}$，即 ${l, l}$，两个字段都引用同一个存储单元。

   ```haskell
   [图示]
   l 指向 0
   b = { l, l }
   ```

---

#### 共享状态（Shared State）

**别名**的可能性会使得带有引用的程序在推理时相当棘手。例如，表达式 $(r := 1; r := !s)$，它先将 $1$ 赋值给 $r$，然后立即用 $s$ 的当前值覆盖它，与单个赋值 $r := !s$ 有完全相同的效果，除非我们在一个上下文中写它，其中 $r$ 和 $s$ 是同一个单元的别名。

当然，**别名**也是引用有用的一个重要部分。特别地，它允许我们在程序的不同部分之间建立“隐式的通信通道”——**共享状态**。例如，假设我们定义一个引用单元和两个操作其内容的函数：

```haskell
c = ref 0;
⊢ c : Ref Nat

incc = λx:Unit. (c := succ(!c); !c);
⊢ incc : Unit → Nat

decc = λx:Unit. (c := pred(!c); !c);
⊢ decc : Unit → Nat
```

调用 $incc$：

```haskell
incc unit;
⊢ 1 : Nat
```

会导致对 $c$ 的更改，这可以通过调用 $decc$ 来观察：

```haskell
decc unit;
⊢ 0 : Nat
```

如果我们将 $incc$ 和 $decc$ 一起打包到一个记录中：

```haskell
o = { i = incc, d = decc };
⊢ o : { i: Unit → Nat, d: Unit → Nat }
```

那么我们可以将整个结构作为一个单元传递，并使用其组件对共享的状态 $c$ 执行递增和递减操作。实际上，我们已经构造了一种简单的对象（object）。这个思想将在第18章中详细展开。

#### 对复合类型的引用（References to Compound Types）

引用单元不仅可以包含一个数字：上述的基本操作允许我们创建对任何类型值的引用，包括函数。例如，我们可以使用对函数的引用来给出一个（不是很高效的）数字数组（arrays of numbers）的实现，如下所示。将 $NatArray$ 定义为类型 $Ref (Nat → Nat)$。

```haskell
NatArray = Ref (Nat → Nat);
```

要构建一个新的数组，我们分配一个引用单元，并填充一个函数，当给定一个索引时，总是返回 $0$。

```haskell
newarray = λ_:Unit. ref (λn:Nat. 0);
⊢ newarray : Unit → NatArray
```

要查找数组的一个元素，我们简单地将函数应用于所需的索引。

```haskell
lookup = λa:NatArray. λn:Nat. (!a) n;
⊢ lookup : NatArray → Nat → Nat
```

编码的有趣部分是更新函数。它接受一个数组、一个索引和要存储在该索引的新值，通过创建（并存储在引用中）一个新函数来完成工作：当它被要求提供这个索引的值时，返回提供给 $update$ 的新值；对于所有其他索引，将查找传递给之前存储在引用中的函数。

```haskell
update = λa:NatArray. λm:Nat. λv:Nat.
          let oldf = !a in
          a := (λn:Nat. if equal m n then v else oldf n);
⊢ update : NatArray → Nat → Nat → Unit
```

**练习 13.1.2** [««]：如果我们将 $update$ 定义得更紧凑，如下所示：

```haskell
update = λa:NatArray. λm:Nat. λv:Nat.
          a := (λn:Nat. if equal m n then v else (!a) n);
```

它的行为会一样吗？

**解答**：

- 是的，行为是一样的。区别在于原始版本保存了旧函数 $oldf$，而新的版本直接在函数体中使用 $!a$ 来引用旧函数。由于在赋值前 $!a$ 总是引用旧函数，因此两者等价。

---

引用包含其他引用的值也非常有用，允许我们定义数据结构，如可变列表（mutable lists）和树（trees）。（这些结构通常还涉及递归类型，我们将在第20章中引入。）

#### 垃圾回收（Garbage Collection）

在继续形式化引用之前，我们最后需要提到一个问题：存储的释放（storage deallocation）。我们没有提供任何用于在不再需要时释放引用单元的原语。相反，像许多现代语言（包括 ML 和 Java）一样，我们依赖于运行时系统执行**垃圾回收（garbage collection）**，收集并重用程序不再能够访问的单元。这不仅仅是语言设计中的一个品味问题：在存在显式释放操作的情况下，很难实现类型安全。这背后的原因是熟悉的**悬挂引用问题（dangling reference problem）**：我们分配一个包含数字的单元，将对它的引用保存到某个数据结构中，使用它一段时间，然后释放它并分配一个包含布尔值的新单元，可能重用了相同的存储空间。现在，我们可能对同一个存储单元有两个名称——一个类型为 $Ref Nat$，另一个类型为 $Ref Bool$。

**练习 13.1.3** [««]：展示这如何导致类型安全性的违反。

**解答**：

- 如果我们有一个类型为 $Ref Nat$ 的引用 $r$，指向一个存储单元 $l$。我们释放了 $l$，并将其重新分配给一个类型为 $Ref Bool$ 的引用 $b$。

- 现在，$r$ 和 $b$ 都指向同一个位置 $l$，但类型检查器认为 $r$ 是 $Ref Nat$，$b$ 是 $Ref Bool$。

- 我们可以通过 $!r$ 读取一个布尔值（但类型系统认为是 $Nat$），或者对 $r$ 进行赋值 $r := 5$，覆盖了布尔值。

- 这会导致类型系统的破坏，因为我们可以在预期是数字的地方得到布尔值，反之亦然。

---

### 13.2 类型（Typing）

$ref$、$:=$ 和 $!$ 的类型规则直接来自它们的行为。

- **（T-Ref）**：

  $$
  \frac{\Gamma \vdash t_1 : T_1}{\Gamma \vdash \text{ref } t_1 : \text{Ref } T_1}
  $$

- **（T-Deref）**：

  $$
  \frac{\Gamma \vdash t_1 : \text{Ref } T_1}{\Gamma \vdash !t_1 : T_1}
  $$

- **（T-Assign）**：

  $$
  \frac{\Gamma \vdash t_1 : \text{Ref } T_1 \quad \Gamma \vdash t_2 : T_1}{\Gamma \vdash t_1 := t_2 : \text{Unit}}
  $$

---

### 13.3 求值（Evaluation）

当我们考虑如何形式化引用的操作行为时，一个更微妙的方面出现了。可以问：“类型为 $Ref T$ 的值应该是什么？”我们需要考虑的关键观察是，求值一个 $ref$ 操作应该做一些事情——即分配一些存储空间——并且操作的结果应该是对该存储的引用。

那么，**什么是一个引用（reference）**？

大多数编程语言实现中的运行时存储（run-time store）本质上只是一个巨大的字节数组。运行时系统跟踪这个数组的哪些部分当前正在使用；当我们需要分配一个新的引用单元时，我们从存储的空闲区域分配一个足够大的段（例如，整数单元需要 4 字节，存储 $Float$ 的单元需要 8 字节等），将其标记为已使用，并返回新分配的区域的起始索引（通常是一个 32 位或 64 位整数）。这些索引就是引用。

**对于当前的目的**，没有必要如此具体。我们可以将存储看作是一个值的数组，而不是字节的数组，抽象掉不同值的运行时表示的不同大小。此外，我们可以抽象掉引用（即该数组的索引）是数字这一事实。我们将引用视为某个**未解释的集合** $L$ 中的存储位置（store locations）的元素，并将存储看作是从位置 $l$ 到值的一个**部分函数**（partial function）。我们使用元变量 $\mu$ 来表示存储。

因此，**引用**是一个**位置（location）**——存储的一个抽象索引。为了强调这种抽象性质，我们从现在开始使用**位置**（location）一词，而不是引用或指针。

**注意**：以这种方式抽象地处理位置，将阻止我们模拟在 C 等低级语言中发现的指针运算。这种限制是有意的。虽然指针运算有时非常有用（特别是在实现运行时系统的低级组件，如垃圾收集器时），但它不能被大多数类型系统跟踪：知道存储中位置 $n$ 包含一个 $Float$，并不能告诉我们关于位置 $n + 4$ 的类型的任何有用信息。在 C 中，指针运算是类型安全性违反的臭名昭著的来源。

---

接下来，我们需要扩展我们的操作语义来考虑存储。由于表达式的求值通常取决于它在其中求值的存储的内容，因此求值规则应该不仅以项作为参数，还要以存储作为参数。此外，由于一个项的求值可能对存储产生副作用，这可能影响将来其他项的求值，求值规则需要返回一个新的存储。

因此，单步求值关系的形状从 $t \to t'$ 变为 $t\ |\ \mu \to t'\ |\ \mu'$，其中 $\mu$ 和 $\mu'$ 是存储的起始和结束状态。实际上，我们丰富了抽象机的概念，因此机器状态不仅是一个程序计数器（由项表示），而且是程序计数器加上存储的当前内容。

要完成这一变化，我们首先需要将所有现有的求值规则加上存储：

- **（E-AppAbs）**：

  $$
  (\lambda x:T_{11}.\ t_{12})\ v_2\ |\ \mu \to [x \mapsto v_2]t_{12}\ |\ \mu
  $$

  - 这个规则返回未改变的存储 $\mu$：函数应用本身没有副作用。

- **（E-App1）**：

  $$
  \frac{t_1\ |\ \mu \to t_1'\ |\ \mu'}{t_1\ t_2\ |\ \mu \to t_1'\ t_2\ |\ \mu'}
  $$

- **（E-App2）**：

  $$
  \frac{t_2\ |\ \mu \to t_2'\ |\ \mu'}{v_1\ t_2\ |\ \mu \to v_1\ t_2'\ |\ \mu'}
  $$

  - 这两个规则简单地将副作用从前提传播到结论。

---

接下来，我们需要对项的语法进行一个小的扩展。求值 $ref$ 表达式的结果将是一个新的位置，因此我们需要将位置包含在可以作为求值结果的事物（即值）的集合中。

- **值（values）**：

  $$
  v ::= \text{值：} \quad \lambda x:T.\ t \quad \text{抽象值（abstraction value）} \\
  \quad\quad\quad\quad\quad \text{unit} \quad \text{单位值（unit value）} \\
  \quad\quad\quad\quad\quad l \quad \text{存储位置（store location）}
  $$

由于所有的值也是项，这意味着项的集合应该包括位置。

- **项（terms）**：

  $$
  t ::= \text{项：} \quad x \quad \text{变量（variable）} \\
  \quad\quad\quad\quad\quad \lambda x:T.\ t \quad \text{抽象（abstraction）} \\
  \quad\quad\quad\quad\quad t\ t \quad \text{应用（application）} \\
  \quad\quad\quad\quad\quad \text{unit} \quad \text{常量 unit} \\
  \quad\quad\quad\quad\quad \text{ref } t \quad \text{引用创建（reference creation）} \\
  \quad\quad\quad\quad\quad !t \quad \text{解引用（dereference）} \\
  \quad\quad\quad\quad\quad t := t \quad \text{赋值（assignment）} \\
  \quad\quad\quad\quad\quad l \quad \text{存储位置（store location）}
  $$

当然，对项语法的这种扩展并不意味着我们打算让程序员编写涉及显式、具体位置的项：这样的项将仅作为求值的中间结果出现。实际上，本章中的项语言应该被视为形式化一个中间语言，其中的一些特性并未直接提供给程序员。

---

基于这种扩展的语法，我们可以为操纵位置和存储的新构造陈述求值规则。首先，要求值一个解引用表达式 $!t1$，我们必须首先将 $t1$ 归约为一个值：

- **（E-Deref）**：

  $$
  \frac{t_1\ |\ \mu \to t_1'\ |\ \mu'}{!t_1\ |\ \mu \to !t_1'\ |\ \mu'}
  $$

一旦 $t1$ 完成归约，我们应该有一个形式为 $!l$ 的表达式，其中 $l$ 是某个位置。尝试解引用任何其他类型的值（如函数或 $unit$）的项是错误的。在这种情况下，求值规则将卡住（stuck）。第13.5节中的类型安全性保证了良类型的项永远不会以这种方式出错。

- **（E-DerefLoc）**：

  $$
  \frac{\mu(l) = v}{!l\ |\ \mu \to v\ |\ \mu}
  $$

接下来，要求值一个赋值表达式 $t1 := t2$，我们必须首先将 $t1$ 归约为一个值（即位置）：

- **（E-Assign1）**：

  $$
  \frac{t_1\ |\ \mu \to t_1'\ |\ \mu'}{t_1 := t_2\ |\ \mu \to t_1' := t_2\ |\ \mu'}
  $$

然后将 $t2$ 归约为一个值（任何类型的值）：

- **（E-Assign2）**：

  $$
  \frac{t_2\ |\ \mu \to t_2'\ |\ \mu'}{v_1 := t_2\ |\ \mu \to v_1 := t_2'\ |\ \mu'}
  $$

一旦我们完成了对 $t1$ 和 $t2$ 的归约，我们有一个形式为 $l := v2$ 的表达式，我们通过更新存储使位置 $l$ 包含 $v2$ 来执行它：

- **（E-Assign）**：

  $$
  \frac{}{l := v_2\ |\ \mu \to \text{unit}\ |\ [l \mapsto v_2]\mu}
  $$

- 这里，$[l \mapsto v_2]\mu$ 表示“将 $l$ 映射到 $v2$，并将所有其他位置映射到与 $\mu$ 相同的存储”。

- 结果项是 $unit$；有趣的结果是更新后的存储。

最后，要求值一个形式为 $ref t1$ 的表达式，我们首先将 $t1$ 归约为一个值：

- **（E-Ref）**：

  $$
  \frac{t_1\ |\ \mu \to t_1'\ |\ \mu'}{\text{ref } t_1\ |\ \mu \to \text{ref } t_1'\ |\ \mu'}
  $$

然后，为了求值 $ref$ 本身，我们选择一个新的位置 $l$（即，不在 $\mu$ 的定义域中），并产生一个扩展了 $\mu$ 的新存储，其中添加了新的绑定 $l \mapsto v_1$。

- **（E-RefV）**：

  $$
  \frac{l \notin \text{dom}(\mu)}{\text{ref } v_1\ |\ \mu \to l\ |\ (\mu, l \mapsto v_1)}
  $$

- 这个求值步骤的结果项是新分配的位置的名称 $l$。

---

注意，这些求值规则不执行任何形式的垃圾回收：我们只是允许存储随着求值的进行而无限制地增长。这不会影响求值的正确性（毕竟，“垃圾”的定义正是程序不再能够访问的存储部分，因此不能在求值中发挥任何作用），但这意味着我们的求值器的一个简单实现有时会耗尽内存，而更复杂的求值器可以通过重用内容已成为垃圾的位置继续运行。

**练习 13.3.1** [«««]：我们如何改进求值规则以模拟垃圾回收？然后需要证明什么定理，以论证这种改进是正确的？

**解答**：

- **改进求值规则**：在每一步求值后，我们可以在更新存储时，移除那些不再可达的存储位置（即，程序中没有任何部分可以再访问这些位置）。

- 这意味着在规则中，我们需要定义一个函数 $GC$，它接受当前项和存储，返回经过垃圾回收的存储。

- **需要证明的定理**：需要证明改进的求值关系与原始求值关系是**等价的**，即对于任意项和初始存储，求值序列在改进的规则下产生的最终结果（项和存储）与在原始规则下产生的结果相同，除了存储中包含的不可达位置被移除之外。

---

**总结**：

通过本章的学习，我们了解了如何将可变引用添加到简单类型的 $\lambda$ 演算中，以及它对类型系统和操作语义的影响。我们引入了存储的概念，并讨论了引用、别名和共享状态等关键问题。此外，我们还探讨了垃圾回收的重要性，以及为什么在存在显式释放操作的情况下很难实现类型安全。

### ---------------------------

### 13.4 存储类型（Store Typings）

在我们已经扩展了语法和求值规则以适应引用之后，我们的最后一个任务是为新构造编写类型规则——当然，还要检查它们是可靠的。自然，关键问题是：“一个位置（location）的类型是什么？”

当我们求值一个包含具体位置的项时，结果的类型取决于我们开始时存储的内容。例如，如果我们在存储 $\mu = (l_1 \mapsto \text{unit},\ l_2 \mapsto \text{unit})$ 中求值项 $!l_2$，结果是 $\text{unit}$；如果我们在存储 $\mu = (l_1 \mapsto \text{unit},\ l_2 \mapsto \lambda x:\text{Unit}.\ x)$ 中求值相同的项，结果是 $\lambda x:\text{Unit}.\ x$。相对于前一个存储，位置 $l_2$ 的类型是 $\text{Unit}$，而相对于后一个存储，它的类型是 $\text{Unit} \to \text{Unit}$。这个观察立即引出了一个关于位置的类型规则的初步尝试：

$$
\frac{\Gamma \vdash \mu(l) : T_1}{\Gamma \vdash l : \text{Ref } T_1}
$$

也就是说，要找到位置 $l$ 的类型，我们在存储中查找 $l$ 的当前内容 $\mu(l)$ 并计算其类型 $T_1$。然后，位置的类型就是 $\text{Ref } T_1$。

以这种方式开始，我们需要更进一步以达到一致的状态。实际上，通过使一个项的类型依赖于存储，我们已经将类型关系从一个三元关系（上下文、项和类型之间）更改为一个四元关系（上下文、存储、项和类型之间）。直观上，存储是我们计算项的类型时的上下文的一部分，因此我们将这个四元关系写成将存储放在推导符左侧的形式：$\Gamma\ |\ \mu \vdash t : T$。我们的引用类型规则现在形式为：

$$
\frac{\Gamma\ |\ \mu \vdash \mu(l) : T_1}{\Gamma\ |\ \mu \vdash l : \text{Ref } T_1}
$$

系统中其余的类型规则以类似的方式扩展，添加了存储。但其他规则不需要对它们的存储做任何有趣的事情——只需将它们从前提传递到结论即可。

然而，这个规则有两个问题。首先，类型检查相当低效，因为计算位置 $l$ 的类型涉及计算 $l$ 的当前内容 $v$ 的类型。如果 $l$ 在项 $t$ 中多次出现，那么在为 $t$ 构建类型推导的过程中，我们将多次重新计算 $v$ 的类型。更糟糕的是，如果 $v$ 本身包含位置，那么我们每次出现它们时都必须重新计算它们的类型。例如，如果存储包含：

$$
\begin{align*}
l_1 &\mapsto \lambda x:\text{Nat}.\ 999, \\
l_2 &\mapsto \lambda x:\text{Nat}.\ (!l_1)\ x, \\
l_3 &\mapsto \lambda x:\text{Nat}.\ (!l_2)\ x, \\
l_4 &\mapsto \lambda x:\text{Nat}.\ (!l_3)\ x, \\
l_5 &\mapsto \lambda x:\text{Nat}.\ (!l_4)\ x,
\end{align*}
$$

那么计算 $l_5$ 的类型涉及计算 $l_4$、$l_3$、$l_2$ 和 $l_1$ 的类型。

第二，所提出的位置的类型规则可能根本不允许我们推导任何东西，如果存储包含一个循环。例如，对于存储：

$$
\begin{align*}
l_1 &\mapsto \lambda x:\text{Nat}.\ (!l_2)\ x, \\
l_2 &\mapsto \lambda x:\text{Nat}.\ (!l_1)\ x,
\end{align*}
$$

没有针对位置 $l_2$ 的有限类型推导，因为计算 $l_2$ 的类型需要找到 $l_1$ 的类型，而这又涉及 $l_2$，如此循环。循环引用结构在实践中确实会出现（例如，它们可用于构建双向链表），我们希望我们的类型系统能够处理它们。

**练习 13.4.1** [«]：你能找到一个项，其求值会创建这个特定的循环存储吗？

**解答**：

- 我们可以定义：

  ```haskell
  l1 = ref (\lambda x:\text{Nat}.\ (!l2)\ x);
  l2 = ref (\lambda x:\text{Nat}.\ (!l1)\ x);
  ```

- 通过执行上述赋值，我们在存储中创建了一个循环引用结构。

---

这两个问题都源于我们提出的位置类型规则要求我们每次在项中提及它时都重新计算位置的类型。但是，直观上，这不应该是必要的。毕竟，当一个位置首次被创建时，我们知道我们存储到其中的初始值的类型。此外，尽管我们可能稍后将其他值存储到该位置，但这些其他值将始终具有与初始值相同的类型。换句话说，对于存储中的每个位置，我们总是考虑一个固定的类型，该类型在位置分配时确定。这些预期的类型可以收集为一个**存储类型**（store typing）——一个将位置映射到类型的有限函数。我们使用元变量 $\Sigma$ 来表示这样的函数。

假设我们有一个存储类型 $\Sigma$，描述了某个项 $t$ 将在其中求值的存储 $\mu$。那么我们可以使用 $\Sigma$ 来计算 $t$ 的结果的类型，而无需直接查看 $\mu$。例如，如果 $\Sigma = (l_1 \mapsto \text{Unit},\ l_2 \mapsto \text{Unit} \to \text{Unit})$，那么我们可以立即推断 $!l_2$ 的类型是 $\text{Unit} \to \text{Unit}$。更一般地，我们可以将位置的类型规则重新表述为基于存储类型，如下所示：

$$
\frac{\Sigma(l) = T_1}{\Gamma\ |\ \Sigma \vdash l : \text{Ref } T_1} \tag{T-Loc}
$$

类型检查再次是一个四元关系，但它是基于存储类型而不是具体的存储来参数化的。其余的类型规则以类似的方式添加了存储类型。

当然，只有当在求值期间使用的具体存储实际符合我们在类型检查时假设的存储类型时，这些类型规则才能准确预测求值结果。这种条件与我们迄今为止看到的所有演算中的自由变量情况完全类似：替换引理（9.3.8）向我们保证，如果 $\Gamma \vdash t : T$，那么我们可以用类型在 $\Gamma$ 中列出的值替换 $t$ 中的自由变量，从而获得类型为 $T$ 的闭项；根据类型保持定理（9.3.9），如果它产生任何结果，将求值为类型为 $T$ 的最终结果。我们将在第13.5节看到如何形式化与存储和存储类型类似的直觉。

最后，注意对于类型检查程序员实际编写的项，我们不需要做任何棘手的事情来猜测我们应该使用什么存储类型。正如我们上面提到的，具体的位置常量只会出现在求值的中间结果的项中；它们不在程序员编写的语言中。因此，我们可以简单地相对于**空存储类型**（empty store typing）来类型检查程序员的项。随着求值的进行，新的位置被创建，我们总是能够通过查看放置在新分配单元中的初始值的类型来扩展存储类型；这种直觉在下面类型保持定理（13.5.3）的陈述中形式化。

现在，我们已经处理了位置，其他新语法形式的类型规则相当直接。当我们创建对类型为 $T_1$ 的值的引用时，引用本身的类型是 $\text{Ref } T_1$。

$$
\frac{\Gamma\ |\ \Sigma \vdash t_1 : T_1}{\Gamma\ |\ \Sigma \vdash \text{ref } t_1 : \text{Ref } T_1} \tag{T-Ref}
$$

注意我们在这里不需要扩展存储类型，因为新位置的名称直到运行时才会确定，而 $\Sigma$ 只记录已经分配的存储单元及其类型之间的关联。

相反，如果 $t_1$ 求值为类型为 $\text{Ref } T_{11}$ 的位置，那么解引用 $t_1$ 保证会产生一个类型为 $T_{11}$ 的值。

$$
\frac{\Gamma\ |\ \Sigma \vdash t_1 : \text{Ref } T_{11}}{\Gamma\ |\ \Sigma \vdash !t_1 : T_{11}} \tag{T-Deref}
$$

最后，如果 $t_1$ 表示类型为 $\text{Ref } T_{11}$ 的单元，那么只要 $t_2$ 的类型也是 $T_{11}$，我们就可以将 $t_2$ 存储到该单元中：

$$
\frac{\Gamma\ |\ \Sigma \vdash t_1 : \text{Ref } T_{11} \quad \Gamma\ |\ \Sigma \vdash t_2 : T_{11}}{\Gamma\ |\ \Sigma \vdash t_1 := t_2 : \text{Unit}} \tag{T-Assign}
$$

**图13-1** 总结了带有引用的简单类型 $\lambda$ 演算的类型规则（以及为了方便参考的语法和求值规则）。

---

### 图13-1：引用（References）

**→ Unit Ref** 扩展了 $\lambda \to$，添加了 Unit（9-1 和 11-2）

#### 语法

- **项（terms）**：

  $$
  \begin{align*}
  t ::= \quad & x & \text{变量（variable）} \\
  & \lambda x:T.\ t & \text{抽象（abstraction）} \\
  & t\ t & \text{应用（application）} \\
  & \text{unit} & \text{常量 unit} \\
  & \text{ref } t & \text{引用创建（reference creation）} \\
  & !t & \text{解引用（dereference）} \\
  & t := t & \text{赋值（assignment）} \\
  & l & \text{存储位置（store location）}
  \end{align*}
  $$

- **值（values）**：

  $$
  \begin{align*}
  v ::= \quad & \lambda x:T.\ t & \text{抽象值（abstraction value）} \\
  & \text{unit} & \text{常量 unit} \\
  & l & \text{存储位置（store location）}
  \end{align*}
  $$

- **类型（types）**：

  $$
  \begin{align*}
  T ::= \quad & T \to T & \text{函数类型（type of functions）} \\
  & \text{Unit} & \text{单位类型（unit type）} \\
  & \text{Ref } T & \text{引用单元类型（type of reference cells）}
  \end{align*}
  $$

- **上下文（contexts）**：

  $$
  \begin{align*}
  \Gamma ::= \quad & \emptyset & \text{空上下文（empty context）} \\
  & \Gamma,\ x:T & \text{项变量绑定（term variable binding）}
  \end{align*}
  $$

- **存储（stores）**：

  $$
  \begin{align*}
  \mu ::= \quad & \emptyset & \text{空存储（empty store）} \\
  & \mu,\ l = v & \text{位置绑定（location binding）}
  \end{align*}
  $$

- **存储类型（store typings）**：

  $$
  \begin{align*}
  \Sigma ::= \quad & \emptyset & \text{空存储类型（empty store typing）} \\
  & \Sigma,\ l:T & \text{位置类型（location typing）}
  \end{align*}
  $$

---

#### 求值

单步求值关系：$t\ |\ \mu \to t'\ |\ \mu'$

- **（E-App1）**：

  $$
  \frac{t_1\ |\ \mu \to t_1'\ |\ \mu'}{t_1\ t_2\ |\ \mu \to t_1'\ t_2\ |\ \mu'}
  $$

- **（E-App2）**：

  $$
  \frac{t_2\ |\ \mu \to t_2'\ |\ \mu'}{v_1\ t_2\ |\ \mu \to v_1\ t_2'\ |\ \mu'}
  $$

- **（E-AppAbs）**：

  $$
  (\lambda x:T_{11}.\ t_{12})\ v_2\ |\ \mu \to [x \mapsto v_2]t_{12}\ |\ \mu
  $$

- **（E-RefV）**：

  $$
  \frac{l \notin \text{dom}(\mu)}{\text{ref } v_1\ |\ \mu \to l\ |\ (\mu,\ l \mapsto v_1)}
  $$

- **（E-Ref）**：

  $$
  \frac{t_1\ |\ \mu \to t_1'\ |\ \mu'}{\text{ref } t_1\ |\ \mu \to \text{ref } t_1'\ |\ \mu'}
  $$

- **（E-DerefLoc）**：

  $$
  \frac{\mu(l) = v}{!l\ |\ \mu \to v\ |\ \mu}
  $$

- **（E-Deref）**：

  $$
  \frac{t_1\ |\ \mu \to t_1'\ |\ \mu'}{!t_1\ |\ \mu \to !t_1'\ |\ \mu'}
  $$

- **（E-Assign）**：

  $$
  \frac{}{l := v_2\ |\ \mu \to \text{unit}\ |\ [l \mapsto v_2]\mu}
  $$

- **（E-Assign1）**：

  $$
  \frac{t_1\ |\ \mu \to t_1'\ |\ \mu'}{t_1 := t_2\ |\ \mu \to t_1' := t_2\ |\ \mu'}
  $$

- **（E-Assign2）**：

  $$
  \frac{t_2\ |\ \mu \to t_2'\ |\ \mu'}{v_1 := t_2\ |\ \mu \to v_1 := t_2'\ |\ \mu'}
  $$

---

#### 类型规则

类型关系：$\Gamma\ |\ \Sigma \vdash t : T$

- **（T-Var）**：

  $$
  \frac{x:T \in \Gamma}{\Gamma\ |\ \Sigma \vdash x : T}
  $$

- **（T-Abs）**：

  $$
  \frac{\Gamma,\ x:T_1\ |\ \Sigma \vdash t_2 : T_2}{\Gamma\ |\ \Sigma \vdash \lambda x:T_1.\ t_2 : T_1 \to T_2}
  $$

- **（T-App）**：

  $$
  \frac{\Gamma\ |\ \Sigma \vdash t_1 : T_{11} \to T_{12} \quad \Gamma\ |\ \Sigma \vdash t_2 : T_{11}}{\Gamma\ |\ \Sigma \vdash t_1\ t_2 : T_{12}}
  $$

- **（T-Unit）**：

  $$
  \Gamma\ |\ \Sigma \vdash \text{unit} : \text{Unit}
  $$

- **（T-Loc）**：

  $$
  \frac{\Sigma(l) = T_1}{\Gamma\ |\ \Sigma \vdash l : \text{Ref } T_1}
  $$

- **（T-Ref）**：

  $$
  \frac{\Gamma\ |\ \Sigma \vdash t_1 : T_1}{\Gamma\ |\ \Sigma \vdash \text{ref } t_1 : \text{Ref } T_1}
  $$

- **（T-Deref）**：

  $$
  \frac{\Gamma\ |\ \Sigma \vdash t_1 : \text{Ref } T_{11}}{\Gamma\ |\ \Sigma \vdash !t_1 : T_{11}}
  $$

- **（T-Assign）**：

  $$
  \frac{\Gamma\ |\ \Sigma \vdash t_1 : \text{Ref } T_{11} \quad \Gamma\ |\ \Sigma \vdash t_2 : T_{11}}{\Gamma\ |\ \Sigma \vdash t_1 := t_2 : \text{Unit}}
  $$

---

### 13.5 安全性（Safety）

本章的最后一个任务是检查类型安全的标准性质对于带有引用的演算仍然成立。**进展定理（Progress Theorem）**（“良类型的项不会卡住”）可以像以前一样陈述和证明（参见 13.5.7）；我们只需要在证明中添加一些直接的情况，处理新构造。类型保持定理则有点更有趣，因此我们先看看它。

由于我们扩展了求值关系（包含初始和最终的存储）和类型关系（包含存储类型），我们需要更改类型保持定理的陈述以包含这些参数。但是，我们显然不能只添加存储和存储类型而不说明它们是如何关联的。

如果

$$
\Gamma\ |\ \Sigma \vdash t : T \\
t\ |\ \mu \to t'\ |\ \mu'
$$

那么

$$
\Gamma\ |\ \Sigma \vdash t' : T \quad \text{（错误！）}
$$

如果我们根据关于存储中值的类型的一组假设来类型检查，然后在违反这些假设的存储中进行求值，结果将是灾难性的。以下要求表达了我们需要的约束。

**定义 13.5.1**：如果 $\text{dom}(\mu) = \text{dom}(\Sigma)$，并且对于每个 $l \in \text{dom}(\mu)$，都有 $\Gamma\ |\ \Sigma \vdash \mu(l) : \Sigma(l)$，则称存储 $\mu$ **相对于**上下文 $\Gamma$ 和存储类型 $\Sigma$ **良类型的**（well typed），记作 $\Gamma\ |\ \Sigma \vdash \mu$。

直观上，如果存储中的每个值都具有存储类型预测的类型，则存储 $\mu$ 与存储类型 $\Sigma$ **一致**。

**练习 13.5.2** [««]：你能找到一个上下文 $\Gamma$、一个存储 $\mu$ 和两个不同的存储类型 $\Sigma_1$ 和 $\Sigma_2$，使得 $\Gamma\ |\ \Sigma_1 \vdash \mu$ 和 $\Gamma\ |\ \Sigma_2 \vdash \mu$ 都成立吗？

**解答**：

- 设 $\Gamma = \emptyset$，$\mu = (l \mapsto \text{unit})$。

- 定义两个存储类型：

  - $\Sigma_1 = (l \mapsto \text{Unit})$

  - $\Sigma_2 = (l \mapsto T)$，其中 $T$ 是 $\text{Unit}$ 的任意子类型（如果有子类型关系的话）。

- 在这两种情况下，只要 $\Gamma\ |\ \Sigma_i \vdash \mu(l) : \Sigma_i(l)$，那么 $\Gamma\ |\ \Sigma_i \vdash \mu$。

- 因此，对于不同的存储类型，$\mu$ 都可以是良类型的。

---

现在，我们可以陈述更接近所需的类型保持性质：

如果

$$
\Gamma\ |\ \Sigma \vdash t : T \\
t\ |\ \mu \to t'\ |\ \mu' \\
\Gamma\ |\ \Sigma \vdash \mu
$$

那么

$$
\Gamma\ |\ \Sigma \vdash t' : T \quad \text{（不够正确。）}
$$

这个陈述对于所有求值规则都是好的，除了分配规则（E-RefV）。问题在于该规则产生的存储比初始存储有更大的定义域，这使得上述陈述的结论失效：如果 $\mu'$ 包含一个新位置 $l$ 的绑定，那么 $l$ 不能在 $\Sigma$ 的定义域中，且 $t'$（肯定提到了 $l$）在 $\Sigma$ 下无法类型化。

显然，由于存储在求值过程中可以增加大小，我们需要允许存储类型也增长。这引出了类型保持性质的最终（正确）陈述：

**定理 13.5.3 [类型保持（Preservation）]**：如果

$$
\Gamma\ |\ \Sigma \vdash t : T \\
\Gamma\ |\ \Sigma \vdash \mu \\
t\ |\ \mu \to t'\ |\ \mu'
$$

那么，存在某个 $\Sigma' \supseteq \Sigma$，使得

$$
\Gamma\ |\ \Sigma' \vdash t' : T \\
\Gamma\ |\ \Sigma' \vdash \mu'
$$

请注意，类型保持定理仅断言存在某个存储类型 $\Sigma' \supseteq \Sigma$（即，在所有旧位置的值上与 $\Sigma$ 一致），使得新项 $t'$ 在 $\Sigma'$ 下是良类型的；它并没有确切告诉我们 $\Sigma'$ 是什么。直观上，很明显 $\Sigma'$ 要么是 $\Sigma$，要么是 $\Sigma$ 加上一个新的绑定 $(l \mapsto T_1)$，其中 $l$ 是新分配的位置，$T_1$ 是在扩展存储 $(\mu,\ l \mapsto v_1)$ 中绑定到 $l$ 的初始值的类型，但明确地陈述这一点会使定理的陈述复杂化，而不会使其更有用：上述较弱的版本已经处于正确的形式（因为它的结论暗含了它的假设），可以重复地“转动曲柄”，并得出每个求值步骤序列都保持良类型性。将此与进展性质结合，我们获得了通常的保证，即“良类型的程序永远不会出错”。

为了证明类型保持，我们需要一些技术性的引理。第一个是标准替换引理（9.3.8）的简单扩展。

**引理 13.5.4 [替换（Substitution）]**：如果 $\Gamma,\ x:S\ |\ \Sigma \vdash t : T$ 且 $\Gamma\ |\ \Sigma \vdash s : S$，那么 $\Gamma\ |\ \Sigma \vdash [x \mapsto s]t : T$。

**证明**：与引理 9.3.8 类似。

---

接下来，陈述将存储中某个单元的内容替换为适当类型的新值不会改变存储的整体类型。

**引理 13.5.5**：如果

$$
\Gamma\ |\ \Sigma \vdash \mu \\
\Sigma(l) = T \\
\Gamma\ |\ \Sigma \vdash v : T
$$

那么

$$
\Gamma\ |\ \Sigma \vdash [l \mapsto v]\mu
$$

**证明**：直接来自 $\Gamma\ |\ \Sigma \vdash \mu$ 的定义。

---

最后，我们需要存储的弱化引理，说明如果存储扩展了一个新位置，扩展后的存储仍然允许我们为与原来相同的项赋予类型。

**引理 13.5.6**：如果 $\Gamma\ |\ \Sigma \vdash t : T$ 且 $\Sigma' \supseteq \Sigma$，那么 $\Gamma\ |\ \Sigma' \vdash t : T$。

**证明**：容易的归纳。

---

现在我们可以证明主要的类型保持定理。

**证明（定理 13.5.3）**：对求值推导进行直接的归纳，使用上述引理和类型规则的反演性质（9.3.1 的直接扩展）。

---

**进展定理**（9.3.5）的陈述也必须扩展，以考虑存储和存储类型：

**定理 13.5.7 [进展（Progress）]**：假设 $t$ 是一个闭合的、良类型的项（即，对于某些 $T$ 和 $\Sigma$，有 $\emptyset\ |\ \Sigma \vdash t : T$）。那么，要么 $t$ 是一个值，要么对于任何满足 $\emptyset\ |\ \Sigma \vdash \mu$ 的存储 $\mu$，存在某个项 $t'$ 和存储 $\mu'$，使得 $t\ |\ \mu \to t'\ |\ \mu'$。

**证明**：对类型推导进行直接的归纳，遵循 9.3.5 的模式。（**规范形式引理**（Canonical Forms Lemma，9.3.4）需要两个额外的情况，说明类型为 $\text{Ref } T$ 的所有值都是位置，类型为 $\text{Unit}$ 的值是 $\text{unit}$。）

---

**练习 13.5.8** [推荐，«««]：在本章的演算中，求值关系对于良类型的项是归一化的吗？如果是，证明它。如果不是，请在当前演算中编写一个良类型的阶乘函数（扩展了数字和布尔值）。

**解答**：

- 答：不是归一化的。

- 虽然简单类型 $\lambda$ 演算（没有引用）是归一化的，但添加引用后，我们可以编写非终止的程序。

- 例如，我们可以利用引用和递归来编写一个非终止的阶乘函数。

- 由于演算中没有显式的递归机制，我们可以通过引用来模拟递归。

- 定义一个引用 $f$，并赋值一个函数，该函数在调用时再次调用 $f$，从而创建一个递归调用。

---

### 13.6 注释（Notes）

本章的内容改编自 Harper（1994，1996）的处理方式。Wright 和 Felleisen（1994）也以类似的风格给出了描述。

将引用（或其他计算效应）与 ML 风格的多态类型推断相结合会引发一些相当微妙的问题（参见第22.7节），在研究文献中受到大量关注。参见 Tofte（1990）、Hoang 等（1993）、Jouvelot 和 Gifford（1991）、Talpin 和 Jouvelot（1992）、Leroy 和 Weis（1991）、Wright（1992）、Harper（1994，1996）及其中引用的文献。

对可能的别名进行静态预测是编译器实现（称为**别名分析**，alias analysis）和编程语言理论中的一个长期问题。Reynolds（1978，1989）的有影响力的早期尝试创造了术语**干扰的句法控制**（syntactic control of interference）。这些思想最近出现了新的活跃研究——参见 O'Hearn 等（1995）和 Smith 等（2000）。关于别名的更一般的推理技术，见 Reynolds（1981）和 Ishtiaq 与 O'Hearn（2001）及其中引用的其他文献。

关于垃圾回收的全面讨论可以在 Jones 和 Lins（1996）中找到。更语义化的处理见 Morrisett 等（1995）。

### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------
[toc]



好的，我们从第8章 **Typed Arithmetic Expressions (类型化的算术表达式)** 开始逐步详解。本章回顾了第三章中的布尔和算术表达式语言，并在其基础上引入了静态类型系统，以便介绍贯穿全书的重要概念。尽管类型系统本身相对简单，但它为我们学习后续复杂的类型理论提供了一个有用的基础。

### **8.1 Types (类型)**

#### **解释：**
在这一部分中，我们讨论的主要是语言的类型。类型系统的核心任务是为表达式分配适当的类型，并确保每个表达式的类型与其操作一致。这里引入的类型可以是简单的布尔类型和算术类型。我们可以定义以下两种类型：
- 布尔类型：表示逻辑真值 $true$ 和 $false$。
- 算术类型：表示整数或自然数。

这些类型的定义方式可能类似于：
- $\text{Bool}$ 表示布尔类型。
- $\text{Nat}$ 表示自然数类型。

#### **公式定义：**
$$
T ::= \text{Bool} \, | \, \text{Nat}
$$

- $T$ 表示类型的集合。我们引入两种类型：布尔类型 $\text{Bool}$ 和自然数类型 $\text{Nat}$。
- 这是一个简单的类型系统，目的是为表达式赋予一个静态类型，使得表达式的类型在计算前可以被确定。

### **8.2 The Typing Relation (类型关系)**

#### **解释：**
类型关系是类型系统的核心，它描述了表达式如何与类型关联。我们可以通过 **Typing Judgments (类型判断)** 来为表达式赋予类型。类型判断的格式通常是：
$$
\Gamma \vdash e : T
$$
其中：
- $\Gamma$ 是上下文（Context），描述了变量的类型信息。
- $e$ 是表达式。
- $T$ 是表达式的类型。
- $\vdash$ 代表“类型推导”关系，表示在上下文 $\Gamma$ 中，表达式 $e$ 的类型是 $T$。

对于我们这里的布尔和自然数表达式，我们可以定义一些基本的类型推导规则。例如：
1. **布尔常量**的类型规则：
   $$
   \frac{}{\vdash true : \text{Bool}} \quad \frac{}{\vdash false : \text{Bool}}
   $$
   解释：在空上下文中，$true$ 和 $false$ 的类型都是 $\text{Bool}$。

2. **自然数**的类型规则：
   $$
   \frac{}{\vdash 0 : \text{Nat}} \quad \frac{\vdash n : \text{Nat}}{\vdash \text{succ}(n) : \text{Nat}}
   $$
   解释：自然数 $0$ 的类型是 $\text{Nat}$，如果 $n$ 是自然数，那么 $succ(n)$ 也是自然数。

这些类型规则通过推导树的形式表达出来，清晰地描述了表达式的类型推导过程。

#### **推导树实例：**

我们来看一个自然数 $1$ 的推导过程，它可以被表示为：
$$
\frac{\frac{}{\vdash 0 : \text{Nat}}}{\vdash succ(0) : \text{Nat}}
$$

- 首先，$0$ 被推导为自然数。
- 接着，使用类型规则 $succ$，我们推导出 $succ(0)$ 也是自然数。

### **8.3 Safety = Progress + Preservation (安全性 = 前进性 + 保持性)**

#### **解释：**
在类型系统中，安全性通常意味着程序的执行不会发生类型错误。为了证明语言的类型系统是安全的，我们需要两个核心性质：
1. **Progress (前进性)**: 如果表达式 $e$ 是一种类型 $T$ 的表达式，那么要么 $e$ 是一个值（它已经计算完成），要么它能够进一步计算。这意味着程序不会卡住。
2. **Preservation (保持性)**: 如果表达式 $e$ 能够从一个表达式演变为另一个表达式 $e'$（即 $e \to e'$），并且 $e$ 的类型是 $T$，那么 $e'$ 的类型也必须是 $T$。这意味着计算不会改变表达式的类型。

为了证明一个语言的类型系统是安全的，我们需要分别证明这两个性质，并将它们组合起来，证明类型系统的安全性。

#### **公式表示：**

- **前进性**的定义：
   $$
   \text{If } \Gamma \vdash e : T \text{ and } e \text{ is not a value, then } e \to e'.
   $$
   解释：如果表达式 $e$ 有一个类型 $T$，且 $e$ 不是一个值，那么 $e$ 一定可以进行进一步的计算。

- **保持性**的定义：
   $$
   \text{If } \Gamma \vdash e : T \text{ and } e \to e', \text{ then } \Gamma \vdash e' : T.
   $$
   解释：如果表达式 $e$ 的类型是 $T$，并且 $e$ 能够演变为 $e'$，那么 $e'$ 的类型也必须是 $T$。

### **总结：**
第8章通过引入类型系统，为我们展示了如何为算术和布尔表达式赋予类型。通过类型关系和推导规则，我们可以静态地推断出表达式的类型，并证明表达式的计算过程是安全的。本章提出了一个重要的安全性定理，即“安全性 = 前进性 + 保持性”，为后续的类型理论学习奠定了基础。

接下来如果有具体内容或者习题，欢迎提供给我，我会继续详细讲解。

### ---------------------------

### **8.1 Types (类型)** 详解

#### **布尔和算术表达式的语法回顾：**

首先，回顾在第三章中介绍的算术表达式的语法：

$$
t ::= \text{terms:}
$$

- $\text{true}$：常量 $true$（布尔类型的常量，表示“真”）
- $\text{false}$：常量 $false$（布尔类型的常量，表示“假”）
- $\text{if } t_1 \, \text{then } t_2 \, \text{else } t_3$：条件表达式，根据 $t_1$ 的布尔值选择执行 $t_2$ 或 $t_3$
- $0$：常量 $0$（自然数类型的常量，表示数字 0）
- $\text{succ } t$：后继函数，表示自然数的后继（即 $t+1$）
- $\text{pred } t$：前驱函数，表示自然数的前驱（即 $t-1$）
- $\text{iszero } t$：零测试函数，检查一个数是否为 $0$

#### **值的定义：**

我们将术语（terms）的求值结果称为**值**(value)。定义如下：
$$
v ::= \text{values:}
$$

- $\text{true}$：布尔值 $true$
- $\text{false}$：布尔值 $false$
- $nv$：数字值（numeric value）

**数字值**的定义进一步为：
$$
nv ::= \text{numeric values:}
$$

- $0$：自然数 $0$
- $\text{succ } nv$：自然数的后继

这些值的定义为我们提供了构造布尔值和自然数值的基础。表达式通过求值可以得到这些基本值。

#### **问题引出：**

在第三章，我们看到对术语的求值要么产生一个值，要么在求值过程中卡住。例如，如果我们对 $\text{pred false}$ 进行求值，由于 $false$ 不是自然数，无法应用前驱操作符，所以这种情况下求值会“卡住”（没有相应的求值规则）。

**卡住的术语**往往表示程序中出现了无意义或错误的部分。我们希望在不实际求值的情况下，能够静态地判断一个术语是否会卡住，确保其求值不会遇到类型错误。

#### **类型引入：**

为此，我们需要区分术语的不同类型，从而保证只有自然数才能作为 $\text{pred}$、$\text{succ}$ 和 $\text{iszero}$ 的参数，而只有布尔值才能作为条件语句的条件。我们引入两种类型：
- **Nat**：自然数类型，表示自然数的值，如 $0$ 和其后继。
- **Bool**：布尔类型，表示布尔值 $true$ 和 $false$。

类型系统的任务就是为术语分配这些类型，并静态地保证术语的类型是合法的。我们将使用元变量 $S$、$T$ 和 $U$ 等来表示类型。

#### **类型判断：**

当我们说“一个术语 $t$ 的类型是 $T$”，这意味着 $t$ 可以“显然”地被求值为一个特定形式的值。这里的“显然”是指我们可以通过**静态分析**来确定，而不需要真正对术语进行求值。

例如：
- 术语 $if \ true \ then \ false \ else \ true$ 的类型是 $\text{Bool}$，因为无论条件为真或假，该表达式都会返回布尔值。
- 术语 $\text{pred (succ (pred (succ 0)))}$ 的类型是 $\text{Nat}$，因为它最终可以求值为一个自然数。

然而，我们的类型分析是保守的，基于静态信息的推理手段可能无法给出所有术语的类型。例如，像 $if \ (iszero \ 0) \ then \ 0 \ else \ false$ 或 $if \ true \ then \ 0 \ else \ false$ 这样的表达式在求值过程中虽然不会卡住，但类型系统无法为它们分配类型，因为这些表达式混用了布尔和自然数类型，违反了类型规则。

#### **总结：**

- **类型系统**可以通过静态分析帮助我们在不进行求值的情况下预测术语是否能正确求值。
- **布尔类型**和**自然数类型**是这个类型系统的基本组成部分，它们分别用于区分布尔值和自然数值。
- **类型判断**能够为术语分配类型，确保术语在计算时不会发生类型错误。
  

这种静态类型系统为我们提供了一个保守的推理机制，在后续章节中将进一步扩展以涵盖更复杂的类型系统。

如果有进一步的问题或者习题，欢迎继续提供给我，我会详细讲解。

### ----------------------------

好的，我将对**8.2 Typing Relation (类型关系)**进行详细的分步解释，确保不省略任何重要内容。

### **8.2 The Typing Relation (类型关系)**

#### **定义和规则：**

类型关系是将类型分配给表达式的基础，我们通过推导规则（inference rules）为表达式分配类型。类型关系通常写为 $t : T$，表示术语 $t$ 的类型为 $T$。这些规则详见**图8-1**和**图8-2**。类似于第三章中的方法，这里我们将布尔类型和自然数类型的规则分成两个图表，这是为了在后续章节中能够更容易地单独引用它们。

**布尔类型规则**和**自然数类型规则**分别描述了如何为布尔常量和算术表达式分配类型。类型系统的关键是确保表达式在语法上是正确的，并且避免不符合类型规则的操作。

##### **T-True** 和 **T-False** 规则：
- **规则T-True**：布尔常量 $true$ 的类型是 $Bool$。
  $$
  \frac{}{\vdash true : Bool} \ \ \text{(T-True)}
  $$

- **规则T-False**：布尔常量 $false$ 的类型是 $Bool$。
  $$
  \frac{}{\vdash false : Bool} \ \ \text{(T-False)}
  $$

这两个规则为布尔常量分配类型 $\text{Bool}$。通过这些规则，我们可以确保每当看到 $true$ 或 $false$ 时，系统可以推断它们的类型是 $Bool$。

##### **T-If** 条件表达式规则：
**条件表达式** $if \ t_1 \ then \ t_2 \ else \ t_3$ 的类型取决于三个子表达式的类型：
- $t_1$ 必须是一个布尔值。
- $t_2$ 和 $t_3$ 的类型必须相同，表示“then”与“else”分支的类型一致。

规则形式如下：
$$
\frac{\vdash t_1 : Bool \quad \vdash t_2 : T \quad \vdash t_3 : T}{\vdash if \ t_1 \ then \ t_2 \ else \ t_3 : T} \ \ \text{(T-If)}
$$

这个规则确保条件表达式的两个分支具有相同的类型 $T$，并且条件部分是一个布尔值。

#### **自然数类型规则：**

接着我们来看自然数类型的规则，这些规则总结在**图8-2**中。

##### **T-Zero** 零常量规则：
- **规则T-Zero**：常量 $0$ 的类型是 $Nat$。
  $$
  \frac{}{\vdash 0 : Nat} \ \ \text{(T-Zero)}
  $$

这个规则为常量 $0$ 赋予自然数类型 $Nat$。常量 $0$ 是自然数的基本元素，其后继由后续规则定义。

##### **T-Succ** 后继规则：
- **规则T-Succ**：表达式 $succ \ t_1$ 的类型是 $Nat$，前提是 $t_1$ 也是自然数。
  $$
  \frac{\vdash t_1 : Nat}{\vdash succ \ t_1 : Nat} \ \ \text{(T-Succ)}
  $$

这个规则确保如果 $t_1$ 是一个自然数，那么它的后继 $succ(t_1)$ 也是一个自然数。

##### **T-Pred** 前驱规则：
- **规则T-Pred**：表达式 $pred \ t_1$ 的类型是 $Nat$，前提是 $t_1$ 是自然数。
  $$
  \frac{\vdash t_1 : Nat}{\vdash pred \ t_1 : Nat} \ \ \text{(T-Pred)}
  $$

这个规则确保对自然数的前驱操作返回一个自然数。

##### **T-IsZero** 零测试规则：
- **规则T-IsZero**：表达式 $iszero \ t_1$ 的类型是 $Bool$，前提是 $t_1$ 是自然数。
  $$
  \frac{\vdash t_1 : Nat}{\vdash iszero \ t_1 : Bool} \ \ \text{(T-IsZero)}
  $$

这个规则确保零测试只能应用于自然数，并且其返回类型是布尔值 $Bool$。

#### **类型关系的形式定义：**

**8.2.1 定义：**
类型关系是术语和类型之间的二元关系，满足上述所有规则。我们称术语 $t$ 为**可类型化的**（typable），当存在一个类型 $T$ 使得 $t : T$。

#### **类型关系的倒转引理 (Inversion Lemma)：**

**8.2.2 倒转引理**：
倒转引理（也称为生成引理）可以帮助我们从类型规则中倒推特定表达式的类型，这对于类型推断至关重要。它展示了如何从给定的有效类型推断出子表达式的类型。

##### **倒转引理的内容：**
1. 如果 $true : R$，那么 $R = Bool$。
   $$
   \frac{}{\vdash true : Bool}
   $$

2. 如果 $false : R$，那么 $R = Bool$。
   $$
   \frac{}{\vdash false : Bool}
   $$

3. 如果 $if \ t_1 \ then \ t_2 \ else \ t_3 : R$，那么 $t_1 : Bool$，且 $t_2 : R$，$t_3 : R$。
   $$
   \frac{\vdash t_1 : Bool \quad \vdash t_2 : R \quad \vdash t_3 : R}{\vdash if \ t_1 \ then \ t_2 \ else \ t_3 : R}
   $$

4. 如果 $0 : R$，那么 $R = Nat$。
   $$
   \frac{}{\vdash 0 : Nat}
   $$

5. 如果 $succ \ t_1 : R$，那么 $R = Nat$ 且 $t_1 : Nat$。
   $$
   \frac{\vdash t_1 : Nat}{\vdash succ \ t_1 : Nat}
   $$

6. 如果 $pred \ t_1 : R$，那么 $R = Nat$ 且 $t_1 : Nat$。
   $$
   \frac{\vdash t_1 : Nat}{\vdash pred \ t_1 : Nat}
   $$

7. 如果 $iszero \ t_1 : R$，那么 $R = Bool$ 且 $t_1 : Nat$。
   $$
   \frac{\vdash t_1 : Nat}{\vdash iszero \ t_1 : Bool}
   $$

**倒转引理证明：**
每一个引理的证明都是直接从定义中得出的。对于给定的类型声明，这些引理说明了如何从其推导出子表达式的类型。

#### **倒转引理的应用：**

倒转引理可以直接用于递归地推断术语的类型。这为我们提供了一种**递归算法**，用于计算术语的类型。这在后续第9章中将详细讨论。

### **总结：**
**8.2** 节介绍了布尔值和自然数的类型关系及其推导规则。通过这些规则，我们可以确保术语在静态类型检查阶段符合类型系统的要求，避免类型错误。倒转引理为我们提供了一种强大的工具，用于推导复杂表达式的类型，并为类型推断算法奠定了基础。

如果您有更多的具体问题或者需要讲解的习题，欢迎继续提供，我将按您的要求逐步详解。

### ---------------------------

这段内容详细介绍了布尔类型 (Bool) 和自然数类型 (Nat) 的推导规则及其扩展，并通过图8-1和图8-2展示了这些规则的具体形式。接下来我将逐条详细解释。

### **图 8-1: 布尔类型的推导规则 (Figure 8-1: Typing rules for booleans, B)**

#### **新语法形式：**

在这里，类型的语法表示为：
$$
T ::= \text{types:} \quad \text{Bool} \quad \text{type of booleans}
$$

- **Bool**: 表示布尔类型的值，包含 $true$ 和 $false$，以及条件表达式 $if \ t_1 \ then \ t_2 \ else \ t_3$。它们都属于布尔类型。

#### **布尔类型的新推导规则：**

推导规则的基本形式是 $t : T$，表示术语 $t$ 具有类型 $T$。下面是布尔类型的推导规则：

1. **T-True**: 布尔常量 $true$ 的类型是 $Bool$。
   $$
   \frac{}{\vdash true : Bool} \ \ \text{(T-True)}
   $$
   - 这个规则表示：没有任何前提条件，$true$ 直接被赋予 $Bool$ 类型。

2. **T-False**: 布尔常量 $false$ 的类型是 $Bool$。
   $$
   \frac{}{\vdash false : Bool} \ \ \text{(T-False)}
   $$
   - 同样地，$false$ 没有前提条件，直接被赋予 $Bool$ 类型。

3. **T-If**: 条件表达式 $if \ t_1 \ then \ t_2 \ else \ t_3$ 的类型取决于 $t_1$、$t_2$ 和 $t_3$ 的类型。
   $$
   \frac{\vdash t_1 : Bool \quad \vdash t_2 : T \quad \vdash t_3 : T}{\vdash if \ t_1 \ then \ t_2 \ else \ t_3 : T} \ \ \text{(T-If)}
   $$

   - **条件** $t_1$ 必须是布尔类型 $Bool$。
   - **分支** $t_2$ 和 $t_3$ 必须具有相同的类型 $T$，无论 $T$ 是 $Bool$ 还是 $Nat$，甚至可能是其他复杂类型。
   - 这个规则确保了条件表达式的类型推导正确。如果 $t_1$ 是布尔类型，并且两个分支具有相同的类型 $T$，则整个条件表达式的类型为 $T$。

---

### **图 8-2: 自然数类型的推导规则 (Figure 8-2: Typing rules for numbers, NB)**

#### **新语法形式：**

接下来是自然数类型的语法：
$$
T ::= \ldots \ \text{types:} \quad \text{Nat} \quad \text{type of natural numbers}
$$

- **Nat**: 表示自然数类型，包含自然数 $0$ 和使用 $succ$（后继）、$pred$（前驱）、$iszero$（零测试）的表达式。

#### **自然数类型的新推导规则：**

自然数类型的推导规则定义了 $Nat$ 类型表达式的推导方法：

1. **T-Zero**: 自然数常量 $0$ 的类型是 $Nat$。
   $$
   \frac{}{\vdash 0 : Nat} \ \ \text{(T-Zero)}
   $$
   - 没有前提条件，常量 $0$ 直接具有类型 $Nat$。

2. **T-Succ**: 表达式 $succ \ t_1$ 的类型是 $Nat$，前提是 $t_1$ 也是 $Nat$ 类型。
   $$
   \frac{\vdash t_1 : Nat}{\vdash succ \ t_1 : Nat} \ \ \text{(T-Succ)}
   $$
   - 这里，$succ$ 是自然数后继函数。推导规则表示：如果 $t_1$ 的类型是 $Nat$，那么它的后继 $succ(t_1)$ 的类型也是 $Nat$。

3. **T-Pred**: 表达式 $pred \ t_1$ 的类型是 $Nat$，前提是 $t_1$ 是 $Nat$ 类型。
   $$
   \frac{\vdash t_1 : Nat}{\vdash pred \ t_1 : Nat} \ \ \text{(T-Pred)}
   $$
   - 这个规则规定了前驱操作的类型推导：如果 $t_1$ 是自然数，则它的前驱 $pred(t_1)$ 也是自然数。

4. **T-IsZero**: 表达式 $iszero \ t_1$ 的类型是 $Bool$，前提是 $t_1$ 是 $Nat$ 类型。
   $$
   \frac{\vdash t_1 : Nat}{\vdash iszero \ t_1 : Bool} \ \ \text{(T-IsZero)}
   $$
   - $iszero$ 是一个零测试操作，判断自然数 $t_1$ 是否为零。这个规则表示：如果 $t_1$ 是自然数类型，则 $iszero(t_1)$ 的类型是布尔值 $Bool$。

---

### **总结：**

#### **图 8-1 布尔类型的推导规则：**
- **T-True** 和 **T-False** 分别将布尔常量 $true$ 和 $false$ 赋予 $Bool$ 类型。
- **T-If** 确保条件表达式 $if \ t_1 \ then \ t_2 \ else \ t_3$ 的条件 $t_1$ 是布尔值，两个分支 $t_2$ 和 $t_3$ 具有相同的类型 $T$。

#### **图 8-2 自然数类型的推导规则：**
- **T-Zero** 为自然数常量 $0$ 分配类型 $Nat$。
- **T-Succ** 和 **T-Pred** 分别为自然数的后继和前驱操作赋予类型推导规则，确保这些操作只应用于自然数。
- **T-IsZero** 将 $iszero$ 操作应用于自然数，并返回布尔值类型。

这两个图总结了布尔值和自然数表达式的基本类型推导规则，确保在静态类型检查阶段可以正确分配类型并避免类型错误。通过这些规则，我们可以推导出复杂表达式的类型，确保它们的计算符合类型系统的要求。

如果有更多具体内容需要解析或深入的讨论，欢迎继续提供！

### ----------------------------

### 8.2.3 习题解析 [« 3]: **证明每个良类型的术语的子术语也是良类型的**

#### **问题描述：**
要求证明一个**良类型的术语**(well-typed term)的每一个**子术语**(subterm)也是良类型的。这涉及到构建一个类型推导的证明树，通过类型推导规则逐步得出结论，最终证明每一个子术语的类型与其母术语的类型保持一致。

#### **背景知识：**
在§3.5 中，我们引入了**求值推导**(evaluation derivation)的概念。类似地，**类型推导**(typing derivation)也是一个基于类型规则的推导树，每个 `(t, T)` 在类型关系中的配对都是通过一个类型推导证明得出的结论。

##### **类型推导证明树：**
- 一个类型推导证明是一个包含类型规则实例的推导树，根节点表示术语的最终类型，分支表示术语的子表达式及其类型推导。
- 每对 `(t, T)` 在类型推导关系中，由一个类型推导证明树支撑，证明 $t : T$ 的正确性。

#### **推导树实例：**

给定表达式 $if \ iszero \ 0 \ then \ 0 \ else \ pred \ 0 : Nat$ 的类型推导树如下：

1. **T-Zero**: 
   - 常量 $0$ 的类型是 $Nat$。
   
   $$
   \frac{}{\vdash 0 : Nat} \ \ \text{(T-Zero)}
   $$
   
2. **T-IsZero**: 
   - $iszero \ 0$ 是一个零测试操作，类型是 $Bool$。此处使用了 T-IsZero 规则。
   
   $$
   \frac{\vdash 0 : Nat}{\vdash iszero \ 0 : Bool} \ \ \text{(T-IsZero)}
   $$
   
3. **T-Pred**:
   - 前驱操作 $pred \ 0$ 只对自然数操作，结果类型是 $Nat$。
   
   $$
   \frac{\vdash 0 : Nat}{\vdash pred \ 0 : Nat} \ \ \text{(T-Pred)}
   $$
   
4. **T-If**:
   - 条件表达式 $if \ iszero \ 0 \ then \ 0 \ else \ pred \ 0$ 的条件部分是布尔类型，两个分支的类型都是 $Nat$。因此整个表达式的类型是 $Nat$。
   
   $$
   \frac{\vdash iszero \ 0 : Bool \quad \vdash 0 : Nat \quad \vdash pred \ 0 : Nat}{\vdash if \ iszero \ 0 \ then \ 0 \ else \ pred \ 0 : Nat} \ \ \text{(T-If)}
   $$

推导树总结了这个复杂表达式的每个子术语的类型。通过逐步应用类型规则，我们可以看出每个子术语都被赋予了正确的类型。

#### **证明思路：**

我们要证明的是：**每个良类型术语的子术语也是良类型的**。这个证明依赖于类型推导树的结构。推导树中的每个节点都表示一个术语的类型推导，而该术语的子术语则对应推导树中的子节点。因此，如果一个术语是良类型的，那么根据类型推导树的递归性质，它的每个子术语也必须是良类型的。

##### **证明步骤：**
1. **定义良类型的术语**：假设术语 $t$ 的类型为 $T$，表示为 $t : T$。这意味着存在一个类型推导树从根节点开始推导出 $t : T$。

2. **子术语的类型推导**：根据推导树的结构，每个术语的子术语对应推导树的子节点。如果一个术语 $t$ 是良类型的，那么它的子术语 $t'$ 也会出现在推导树中，并且根据类型推导规则，子术语 $t'$ 的类型也是通过相应的规则推导得出的。

3. **递归性质**：推导树是递归定义的，每个节点表示的类型推导依赖于其子节点的类型推导。因此，根节点（表示整个术语）的良类型性依赖于其所有子节点（即子术语）的良类型性。

##### **推导示例：**

以表达式 $if \ iszero \ 0 \ then \ 0 \ else \ pred \ 0$ 为例：
- **根节点**：整个表达式的类型是 $Nat$，由 $T-If$ 规则推导。
- **子术语 $iszero \ 0$**：该子术语的类型是 $Bool$，由 $T-IsZero$ 规则推导。
- **子术语 $0$**：作为条件和分支的一部分，其类型是 $Nat$，由 $T-Zero$ 规则推导。
- **子术语 $pred \ 0$**：其类型是 $Nat$，由 $T-Pred$ 规则推导。

因此，整个推导树的结构保证了每个子术语的类型都能通过递归地应用类型推导规则来验证。

#### **总结：**
- **推导树的结构**确保了一个良类型的术语的每个子术语也是良类型的。我们通过递归地应用类型推导规则，验证了术语的每个子部分的类型。
- 这个性质非常重要，因为它为我们提供了一种静态地检查程序是否符合类型规则的方法，从而避免运行时的类型错误。

---

如果有进一步的问题或需要更详细的讲解，欢迎继续提供！

### ---------------------------

### 8.2.4 定理：**类型唯一性 (Uniqueness of Types)**

#### **定理陈述：**
每个术语 $t$ 最多只能有一个类型。如果 $t$ 是可类型化的，那么它的类型是唯一的。此外，这个类型推导只有唯一的推导树能证明其成立，并且该推导树是基于**图8-1** 和 **图8-2**中的类型推导规则构建的。

#### **证明方法：**
定理的证明采用的是基于术语 $t$ 的**结构归纳法**(structural induction)。每种类型规则通过归纳假设和**倒转引理**(inversion lemma)逐步验证，确保类型唯一性。

#### **结构归纳法简介：**

1. **基础步骤**（Base Case）：
   - 在简单的类型系统中，每个常量（如 $true$、$false$、$0$）都有唯一的类型。例如，$true$ 和 $false$ 总是有类型 $Bool$，而 $0$ 总是有类型 $Nat$。
   - 根据 **图8-1** 和 **图8-2** 中的类型推导规则，常量的类型是直接指定的，并且没有歧义。

2. **归纳步骤**（Inductive Case）：
   - 假设对于较小的子术语，类型唯一性成立，即子术语 $t_1, t_2, \dots$ 都有唯一的类型。
   - 对于更复杂的术语（如 $succ \ t_1$, $if \ t_1 \ then \ t_2 \ else \ t_3$, 等），我们根据推导规则来推断整体的类型。此时，我们应用倒转引理，结合归纳假设，确保这些术语的类型是唯一的。

   **倒转引理**告诉我们，对于每种特定的类型推导规则（例如，$succ$、$pred$、$if$ 等），只可能有一种方式证明术语具有某个类型。这意味着复杂术语的类型完全取决于其子术语的类型，而子术语的类型通过归纳假设已经是唯一的。

#### **证明细节：**

为了更加具体，我们来看几个类型规则：

1. **T-True 和 T-False**：
   - 对于 $true$ 和 $false$，我们只有一种类型规则，即 **T-True** 和 **T-False**：
     $$
     \frac{}{\vdash true : Bool} \quad \frac{}{\vdash false : Bool}
     $$
     这两条规则表明：$true$ 和 $false$ 只能被分配 $Bool$ 类型，不能有其他类型。

2. **T-Zero 和 T-Succ**：
   - 对于常量 $0$ 和后继表达式 $succ \ t_1$，我们有如下规则：
     $$
     \frac{}{\vdash 0 : Nat} \quad \frac{\vdash t_1 : Nat}{\vdash succ \ t_1 : Nat}
     $$
     - $0$ 只能具有 $Nat$ 类型。
     - 对于 $succ \ t_1$，其类型取决于 $t_1$ 的类型。根据归纳假设，$t_1$ 的类型是唯一的，因此 $succ \ t_1$ 的类型也只能是 $Nat$。

3. **T-If**：
   - 对于条件表达式 $if \ t_1 \ then \ t_2 \ else \ t_3$，我们有：
     $$
     \frac{\vdash t_1 : Bool \quad \vdash t_2 : T \quad \vdash t_3 : T}{\vdash if \ t_1 \ then \ t_2 \ else \ t_3 : T}
     $$
     - 该规则要求 $t_1$ 必须是布尔类型，且 $t_2$ 和 $t_3$ 的类型相同。因此，整个表达式的类型也是唯一的，归纳假设确保了 $t_2$ 和 $t_3$ 的类型一致且唯一。

#### **结论：**
通过结构归纳法，我们可以证明对于每个术语 $t$，它的类型是唯一的。归纳步骤表明，无论是简单的常量还是复杂的组合表达式，其类型推导总是唯一的。这也意味着，对于每个术语的类型推导过程，我们可以构建唯一的一棵推导树来证明其类型正确性。

---

### **进一步说明：类型唯一性的扩展**

在我们当前讨论的简单类型系统中，每个术语都有唯一的类型，且该类型推导的证明树是唯一的。但在后续章节（如第15章中介绍的**子类型系统**），这一性质将会被放宽：

- **多重类型**：在具有子类型的系统中，一个术语可能有多个类型。例如，$Nat$ 类型的术语在子类型系统中也可能被赋予其超类型 $Any$。
- **多种推导树**：在这种复杂的类型系统中，可能会有多种推导树能够证明某个术语具有某个类型。

因此，类型唯一性定理适用于当前简单的类型系统，在更复杂的类型系统中将需要进一步扩展。

---

### 8.3 安全性定理：**安全性 = 前进性 + 保持性 (Safety = Progress + Preservation)**

下一节讨论的安全性定理将建立在类型唯一性和推导树的基础上，通过前进性和保持性来确保类型系统的安全性。进而，我们可以确保程序在执行时不会遇到类型错误。

---

如果您有更多问题或需要进一步的解释，欢迎继续提供！

### ----------------------------

### 8.3 安全性定理：**安全性 = 前进性 + 保持性 (Safety = Progress + Preservation)**

#### **安全性 (Safety)**

**安全性**是任何类型系统中最基本的性质之一。在这里，安全性也被称为**健全性**(soundness)，其含义是：**良类型的术语不会出错**。具体而言，一个术语出错意味着它进入了一种“卡住状态”(stuck state)，在这个状态中，它既不是最终的值，评估规则也无法告诉我们下一步该做什么。我们的目标是证明：**良类型的术语不会卡住**。

要证明这一点，我们通过两个步骤来进行：
1. **前进性定理 (Progress Theorem)**：一个良类型的术语要么是值，要么能够根据评估规则前进一步。
2. **保持性定理 (Preservation Theorem)**：如果一个良类型的术语能够前进一步，那么前进后的术语也是良类型的。

#### **前进性 (Progress)**

前进性定理说明：**良类型的术语永远不会卡住**。也就是说，术语要么是值（即评估已经完成），要么能够根据评估规则进一步演化。

##### **前进性定理的形式表述：**
$$
\text{如果 } t \text{ 是良类型的术语 } t : T, \text{ 要么 } t \text{ 是一个值，要么存在一个 } t' \text{ 使得 } t \to t'.
$$

这意味着，一个良类型的术语不会进入无法评估的状态（即卡住状态）。这种状态通常是由不正确的类型导致的，例如应用前驱操作符于布尔值（如 $pred \ true$），这种操作在良类型的系统中是不允许的，因此保证术语不会卡住。

#### **保持性 (Preservation)**

保持性定理说明：**如果一个良类型的术语在评估过程中发生了一步转换，那么转换后的术语仍然是良类型的**。这意味着，**类型在评估过程中是被保持的**。

##### **保持性定理的形式表述：**
$$
\text{如果 } t : T \text{ 且 } t \to t', \text{ 那么 } t' : T.
$$

在评估过程中，术语从 $t$ 转换为 $t'$，保持性定理确保 $t'$ 仍然具有相同的类型 $T$。因此，我们可以安全地继续进行评估，不必担心术语会因类型不一致而出现问题。

#### **安全性 = 前进性 + 保持性**

将**前进性**和**保持性**结合起来，我们可以得出类型系统的**安全性**：

- **前进性**确保一个良类型的术语总是能够前进一步，或者是一个值。
- **保持性**确保术语的类型在评估过程中保持一致，不会由于评估过程中的类型错误而出错。

因此，**安全性**的核心定义为：**良类型的术语在评估过程中不会进入卡住状态**。

#### **证明思路：**

##### **前进性定理的证明：**

我们可以通过归纳法来证明前进性定理。具体地，假设我们已经知道较小的术语满足前进性，那么对于更复杂的术语（例如 $if \ t_1 \ then \ t_2 \ else \ t_3$），我们通过考察 $t_1$ 的类型来判断整个表达式是否能够前进一步：

- 如果 $t_1$ 是 $true$ 或 $false$，那么可以直接评估出 $t_2$ 或 $t_3$。
- 如果 $t_1$ 不是一个布尔值，那么根据类型推导规则，$t_1$ 必须能够进一步评估。

##### **保持性定理的证明：**

保持性定理同样可以通过归纳法证明。假设我们已经证明较小的术语评估后保持类型不变，接着我们考察更复杂的术语评估后是否依然符合类型规则：

- 如果 $t_1 \to t_1'$，那么评估后 $if \ t_1' \ then \ t_2 \ else \ t_3$ 仍然是良类型的，因为 $t_1'$ 的类型没有改变。

#### **扩展说明：**

在更复杂的类型系统中（如第15章中讨论的**子类型系统**），保持性定理的形式会有所变化。例如，在某些类型系统中，术语的类型在评估过程中可能会发生变化（例如从更广泛的类型变为更具体的类型）。在这种情况下，我们说**类型变得更具信息性**。

例如，在包含子类型的系统中，一个术语可能会从较大的类型（如 $Any$）评估为更小的类型（如 $Nat$）。虽然类型发生了变化，但它依然是良类型的术语，只是类型的表达变得更加精确了。

#### **结论：**

**安全性定理**通过结合**前进性**和**保持性**，为我们提供了类型系统健全性的证明：**良类型的术语永远不会出错**。这一重要性质确保了我们在静态类型检查时可以提前发现并修复潜在的类型错误，从而在运行时避免不必要的错误。

---

如果有更多问题或想深入探讨其他内容，欢迎继续提问！

### ---------------------------

### 8.3.1 引理：**标准形式 (Canonical Forms)**

#### **引理陈述：**
1. 如果 $v$ 是一个类型为 $Bool$ 的值，那么 $v$ 要么是 $true$，要么是 $false$。
2. 如果 $v$ 是一个类型为 $Nat$ 的值，那么 $v$ 是符合 **图 3-2** 语法的数字值。

#### **证明：**
- **(1) 布尔值的标准形式：**
   - 根据 **图 3-1** 和 **图 3-2** 的语法，值的可能形式有四种：$true$、$false$、$0$ 和 $succ \ nv$（其中 $nv$ 是一个数字值）。
   - 对于类型为 $Bool$ 的值，只有两种可能的形式：$true$ 和 $false$。因为在倒转引理（inversion lemma）的第4条和第5条中明确指出，$0$ 和 $succ \ nv$ 只能有类型 $Nat$，而不是 $Bool$。
   - 因此，$v$ 是 $true$ 或 $false$。
  
- **(2) 自然数的标准形式：**
   - 同样地，根据语法规则，类型为 $Nat$ 的值只能是 $0$ 或 $succ \ nv$（后继一个数字值）。这一点直接得出。

---

### 8.3.2 定理：**前进性定理 (Progress Theorem)**

#### **定理陈述：**
假设术语 $t$ 是良类型的（即 $t : T$）。那么要么 $t$ 是一个值，要么存在一个 $t_0$ 使得 $t \to t_0$。

#### **证明：**
我们将通过**归纳法**，基于术语 $t : T$ 的推导树来证明前进性定理。

##### **基础情况：**
对于 $T-True$、$T-False$ 和 $T-Zero$ 的情况，这些术语本身就是值，因此前进性成立。因为对于这些术语，它们本身不需要进一步评估。

##### **复杂情况：**

1. **情况 T-If**: 
   - 术语 $t = if \ t_1 \ then \ t_2 \ else \ t_3$ 且 $t_1 : Bool$，$t_2 : T$，$t_3 : T$。
   - 根据归纳假设，要么 $t_1$ 是一个值，要么 $t_1 \to t_1'$。
   - 如果 $t_1$ 是一个值，根据**标准形式引理 (Canonical Forms Lemma)**，$t_1$ 必然是 $true$ 或 $false$：
     - 如果 $t_1 = true$，则根据规则 $E-IfTrue$，术语评估为 $t_2$。
     - 如果 $t_1 = false$，则根据规则 $E-IfFalse$，术语评估为 $t_3$。
   - 如果 $t_1 \to t_1'$，那么根据 $T-If$ 规则，$t \to if \ t_1' \ then \ t_2 \ else \ t_3$。

2. **情况 T-Succ**: 
   - 术语 $t = succ \ t_1$ 且 $t_1 : Nat$。
   - 根据归纳假设，要么 $t_1$ 是一个值，要么 $t_1 \to t_1'$。
   - 如果 $t_1$ 是一个值，根据标准形式引理，$t_1$ 必然是一个数字值，因此 $succ \ t_1$ 也是一个值。
   - 如果 $t_1 \to t_1'$，那么根据规则 $E-Succ$，$succ \ t_1 \to succ \ t_1'$。

3. **情况 T-Pred**: 
   - 术语 $t = pred \ t_1$ 且 $t_1 : Nat$。
   - 根据归纳假设，要么 $t_1$ 是一个值，要么 $t_1 \to t_1'$。
   - 如果 $t_1$ 是一个值，根据标准形式引理，$t_1$ 必然是数字值，因此 $t_1$ 要么是 $0$，要么是 $succ \ nv_1$：
     - 如果 $t_1 = 0$，则根据规则 $E-PredZero$，$pred \ 0$ 评估为 $0$。
     - 如果 $t_1 = succ \ nv_1$，则根据规则 $E-PredSucc$，$pred \ (succ \ nv_1)$ 评估为 $nv_1$。
   - 如果 $t_1 \to t_1'$，那么根据规则 $E-Pred$，$pred \ t_1 \to pred \ t_1'$。

4. **情况 T-IsZero**: 
   - 术语 $t = iszero \ t_1$ 且 $t_1 : Nat$。
   - 根据归纳假设，要么 $t_1$ 是一个值，要么 $t_1 \to t_1'$。
   - 如果 $t_1$ 是一个值，根据标准形式引理，$t_1$ 必然是数字值：
     - 如果 $t_1 = 0$，则根据规则 $E-IsZeroZero$，$iszero \ 0$ 评估为 $true$。
     - 如果 $t_1 = succ \ nv_1$，则根据规则 $E-IsZeroSucc$，$iszero \ (succ \ nv_1)$ 评估为 $false$。
   - 如果 $t_1 \to t_1'$，那么根据规则 $E-IsZero$，$iszero \ t_1 \to iszero \ t_1'$。

#### **总结：**
通过归纳法证明，我们验证了每种情况下良类型的术语 $t$ 要么是值，要么可以根据评估规则进一步评估。这就证明了**前进性定理**的正确性。

---

### **评估保持性：**

前进性定理为我们提供了术语在评估过程中不会卡住的保证，而**保持性定理**则进一步确保评估过程中术语的类型保持不变。这是类型系统健全性的重要组成部分。

---

如果需要对这部分内容进行更深入的讨论，或有更多问题，请继续提问！

### ----------------------------

### 8.3.3 定理：**保持性 (Preservation)**

#### **定理陈述：**
如果 $t : T$ 且 $t \to t'$，那么 $t' : T$。

#### **证明方法：**
为了证明保持性定理，我们使用**归纳法**（induction）基于术语 $t : T$ 的推导树。每一步推导都假设对所有子推导的保持性成立，即：如果 $s : S$ 且 $s \to s'$，那么 $s' : S$，其中 $s : S$ 是当前推导的子推导。同时，我们通过**案例分析**（case analysis）来验证每种情况。

接下来我们通过具体的情况一步步验证保持性定理。这里只展示了一部分案例，其他类似。

---

### **具体案例分析：**

#### **案例 1: T-True**

- 假设 $t = true$，且 $T = Bool$。
- 如果推导的最后一个规则是 $T-True$，根据规则的形式，$t$ 必然是常量 $true$，且 $T$ 必然是 $Bool$。
- 但是，$t$ 是一个值，因此不可能存在 $t \to t'$ 的情况，也就是说，$t$ 不会进一步演化。
- 因此，定理在此情况中**平凡地**成立，因为 $t$ 是一个值，不需要进一步验证。

##### **解释：**
由于 $true$ 是一个值，它本身就是终结状态，不会继续演化，因此我们不需要处理任何进一步的转换。这个情况下，保持性定理自动成立。

---

#### **案例 2: T-If**

- 假设 $t = if \ t_1 \ then \ t_2 \ else \ t_3$，且 $t_1 : Bool$，$t_2 : T$，$t_3 : T$。
- 如果推导的最后一个规则是 $T-If$，根据这个规则的形式，$t$ 必然是一个形如 $if \ t_1 \ then \ t_2 \ else \ t_3$ 的条件表达式，其中 $t_1$ 是布尔类型，而 $t_2$ 和 $t_3$ 都是类型为 $T$ 的子表达式。
- 我们现在需要查看关于 $if$ 语句的求值规则 **图3-1**，发现有三种规则可以推导 $t \to t'$：
  - **E-IfTrue**: 当 $t_1 = true$ 时，$t'$ 是 $t_2$。
  - **E-IfFalse**: 当 $t_1 = false$ 时，$t'$ 是 $t_3$。
  - **E-If**: 当 $t_1 \to t_1'$ 时，$t'$ 是 $if \ t_1' \ then \ t_2 \ else \ t_3$。

##### **子案例分析：**

###### **子案例 1: E-IfTrue**

- 假设 $t_1 = true$，因此根据规则 **E-IfTrue**，我们有 $t \to t_2$。
- 根据 $T-If$ 的前提，已知 $t_2 : T$，这正是我们需要的，即 $t' = t_2 : T$。

###### **子案例 2: E-If**

- 假设 $t_1 \to t_1'$，因此根据规则 **E-If**，我们有 $t \to if \ t_1' \ then \ t_2 \ else \ t_3$。
- 根据 $T-If$ 的前提，$t_1 : Bool$，且我们可以应用归纳假设，得到 $t_1' : Bool$。
- 结合 $t_2 : T$ 和 $t_3 : T$，我们可以应用 $T-If$ 规则，推导出 $if \ t_1' \ then \ t_2 \ else \ t_3 : T$，即 $t' : T$。

##### **总结：**
在 $T-If$ 规则的推导下，不论 $t_1$ 是 $true$、$false$ 还是能够进一步演化为 $t_1'$，我们总能证明 $t'$ 的类型保持为 $T$，因此保持性定理成立。

---

#### **案例 3: T-Zero**

- 假设 $t = 0$，且 $T = Nat$。
- 如果推导的最后一个规则是 $T-Zero$，那么 $t$ 必然是常量 $0$ 且类型为 $Nat$。
- 同样的，$0$ 是一个值，不可能存在 $t \to t'$ 的情况。
- 因此定理在此情况中也**平凡地**成立，因为 $t$ 是一个值，不会进一步演化。

##### **解释：**
类似于 $true$ 的情况，$0$ 也是一个终结状态的值，因此保持性定理自动成立。

---

#### **案例 4: T-Succ**

- 假设 $t = succ \ t_1$，且 $t_1 : Nat$，$T = Nat$。
- 我们检查 **图3-2** 中的求值规则，发现只有一个规则 **E-Succ** 可以用于推导 $t \to t'$。
  - **E-Succ**：$t_1 \to t_1'$，则 $succ \ t_1 \to succ \ t_1'$。
  
##### **证明：**

- 根据推导规则 $T-Succ$，我们知道 $t_1 : Nat$。
- 根据归纳假设，$t_1 \to t_1'$ 后，$t_1' : Nat$。
- 于是，应用 $T-Succ$ 规则，我们可以推导出 $succ \ t_1' : Nat$，即 $t' : Nat$。

##### **总结：**
在 $T-Succ$ 规则的推导下，我们能够通过归纳假设证明 $t_1'$ 仍然是自然数类型，因此 $succ \ t_1'$ 也具有类型 $Nat$，保持性定理成立。

---

### **总结：保持性定理的证明**

我们通过归纳法和案例分析验证了**保持性定理**，即：如果 $t : T$ 且 $t \to t'$，那么 $t' : T$。

- 在每一个规则的推导中，我们都根据归纳假设证明了术语在评估后其类型保持不变。
- 无论是简单的值（如 $true$、$false$、$0$）还是更复杂的表达式（如 $if$、$succ$、$pred$），它们的类型在评估过程中始终保持一致。
- 保持性定理是类型系统健全性的重要组成部分，确保了程序在执行过程中不会因类型错误而中断。

---

如果您有进一步的问题或需要更详细的讨论，欢迎继续提供内容！

### ---------------------------

### 8.3.4 习题 [«« 3]：**将保持性定理的证明结构调整为基于求值推导的归纳，而不是类型推导**

#### **问题描述：**
此题要求将保持性定理的证明从基于**类型推导**的归纳法，重新调整为基于**求值推导**的归纳法。通常，我们基于类型推导来证明保持性定理，但题目要求我们改为根据术语的求值推导进行归纳。

#### **解释：**
**保持性定理**的本质是，假设 $t : T$，并且 $t \to t'$，我们想证明 $t' : T$。原来的证明方法是通过类型推导树来证明，即对每一个类型推导规则进行归纳。而现在要求我们对**求值推导**进行归纳，即对术语从 $t \to t'$ 的推导进行分析。

##### **结构调整建议：**

1. **基于求值推导的归纳：**
   - 对求值规则进行归纳分析，例如：$E-IfTrue$、$E-Succ$ 等。我们可以逐步处理每个求值规则，确保每一步求值都能保持类型不变。

2. **具体步骤：**
   - 对于每一个求值规则，考虑术语 $t$ 的初始类型，然后通过归纳假设来推导出 $t'$ 的类型。例如：
     - 如果 $t = if \ t_1 \ then \ t_2 \ else \ t_3$ 并且 $t_1 \to t_1'$，那么根据求值规则，整个表达式 $t$ 也会变化，我们需要检查变化后的术语 $t'$ 的类型是否仍然是 $T$。

3. **重构证明：**
   - 证明应该重新构建为逐步分析求值推导的过程，而不是类型推导过程。每一步的求值操作对应于求值规则，并且我们要确保术语的类型在求值之后保持不变。

---

### 8.3.5 习题 [«]：**评估规则 E-PredZero 的直观问题**

#### **问题描述：**
**E-PredZero** 规则有些反直觉：我们可能会认为 $pred \ 0$ 不应该被定义为 $0$，而是应当未定义。问题是：如果我们想改变这种行为，是否可以简单地通过从单步求值规则中删除这个规则来实现？

#### **分析：**

**E-PredZero** 规则如下：
$$
\frac{}{\text{pred } 0 \to 0} \ \ \text{(E-PredZero)}
$$

这个规则表明，$pred \ 0$ 被定义为 $0$。这是在类型系统中为了简化处理而定义的一种规则。直觉上，我们可能会认为 $pred \ 0$ 应该是未定义的，因为前驱函数在自然数 $0$ 上没有“前一个数”的合理解释。

##### **如果移除 E-PredZero：**
- **后果**：
  - 如果我们从求值规则中删除 **E-PredZero**，那么在评估 $pred \ 0$ 时将无法找到匹配的求值规则，导致 $pred \ 0$ 处于**卡住状态**（stuck state）。
  - 这种行为与我们在本章中定义的“良类型术语不会卡住”的原则相冲突，因为良类型的术语 $pred \ 0$ 将会卡住，违反了**安全性定理**。

##### **解决方案：**
- 如果我们想让 $pred \ 0$ 未定义，我们不仅需要删除求值规则，还需要修改类型系统，以确保 $pred$ 函数在 $0$ 上是非法操作。
- 这意味着我们需要调整类型系统，让 $pred$ 只能接受非零自然数作为参数。这可能涉及引入更复杂的类型检查机制，而不仅仅是删除求值规则。

---

### 8.3.6 习题 [««, 推荐]：**探讨相反性质——主体扩展 (Subject Expansion)**

#### **问题描述：**
在前面的习题中我们已经看到了**主体缩减性质**（subject reduction），现在我们要探讨相反的性质，即**主体扩展性质**。题目要求我们回答：是否总是存在以下情况，即如果 $t \to t'$ 并且 $t' : T$，那么 $t : T$？如果成立，请证明。如果不成立，请给出反例。

#### **分析：**

**主体扩展性质 (Subject Expansion)** 是指：如果一个术语 $t'$ 经过评估得到了 $t$，并且 $t' : T$，那么 $t : T$ 是否也成立？换句话说，我们能否通过逆向推导证明原术语 $t$ 的类型？

##### **反例：**
主体扩展并不总是成立。我们可以通过以下反例来证明：

- 假设有一个自然数表达式 $t = succ \ true$，即尝试对布尔值 $true$ 使用后继操作符。
- 如果我们对其进行求值，$t$ 将卡住，因为 $succ$ 只能作用于自然数，$true$ 并不是自然数。
- 然而，假设我们应用某种求值策略，导致我们误将 $t$ 转换为某个良类型的术语 $t'$，例如 $succ \ 0$，此时 $t' : Nat$。
- 然而，$t = succ \ true$ 并不是一个良类型的术语，因此不能逆向推导出 $t : Nat$。

##### **总结：**
主体扩展性质并不总是成立。反例表明，在某些情况下，评估后的术语 $t'$ 可能是良类型的，但原始术语 $t$ 并不一定是良类型的。由于类型系统中的不一致性或求值规则的复杂性，术语的类型可能会在评估过程中改变，特别是在不正确的类型操作时。

---

如果有进一步的问题或需要更多的解释，欢迎继续提供！

### ----------------------------

### 8.3.7 习题 [推荐, ««]：**假设我们的求值关系是以大步风格定义的，如何形式化类型安全的直观性质？**

#### **问题描述：**
题目要求我们假设求值关系是以**大步风格 (big-step style)**定义的，参考**习题3.5.17**。在这种情况下，如何形式化地表达**类型安全性**的直观性质？

#### **背景知识：**
- **大步风格求值 (big-step evaluation)** 又称**自然语义 (natural semantics)**，其核心思想是直接描述一个术语 $t$ 如何一步到达一个最终值（即从起始状态到最终状态），而不像小步风格那样逐步描述术语的演化过程。大步风格的规则通常形式为：
  $$
  \frac{\text{多个前提}}{t \to v}
  $$
  - 意味着术语 $t$ 在求值之后最终得到值 $v$。

- **类型安全性**的直观性质通常表达为：良类型的术语在求值过程中不会产生类型错误。这可以通过两条性质来表达：
  1. **前进性 (Progress)**：良类型的术语要么是一个值，要么可以进一步求值。
  2. **保持性 (Preservation)**：如果一个良类型的术语进行了一步求值，那么结果仍然是良类型的。

#### **在大步求值下的类型安全性形式化：**

在大步风格求值中，类型安全性依然可以通过**前进性**和**保持性**来形式化表达，但由于大步风格直接从术语求值到最终值，因此这两个性质需要略作调整：

1. **前进性 (Progress) 在大步求值中的形式化：**
   - **前进性**表明一个良类型的术语 $t$ 要么是一个值，要么在大步求值的过程中能够最终得到一个值：
   $$
   \text{如果 } t : T，\text{则存在 } v \text{ 使得 } t \to v，\text{且 } v : T。
   $$
   - 也就是说，良类型的术语总是能够求值到一个值，并且这个值的类型与原术语一致。

2. **保持性 (Preservation) 在大步求值中的形式化：**
   - **保持性**表明，如果术语 $t$ 的类型为 $T$，那么在大步求值后，结果 $v$ 的类型也是 $T$：
   $$
   \text{如果 } t : T \text{ 且 } t \to v，\text{那么 } v : T。
   $$
   - 这与小步风格的保持性类似，只不过在大步风格下，术语直接从 $t$ 求值到最终值 $v$，我们依然要求结果的类型与初始术语的类型一致。

#### **总结：**
- 在大步风格求值下，类型安全性可以通过调整后的**前进性**和**保持性**性质来表达：
  - **前进性**保证良类型的术语最终能求值为一个值。
  - **保持性**保证求值后的结果类型与原始术语的类型保持一致。

---

### 8.3.8 习题 [推荐, ««]：**假设求值规则扩展了对荒谬术语的求值规则，如何形式化类型安全性？**

#### **问题描述：**
假设我们的求值关系增加了将不合逻辑的术语（nonsensical terms）简化到明确的错误状态的规则（参考习题3.5.16），我们应该如何形式化类型安全性？

#### **背景知识：**
在**习题3.5.16**中，求值关系被扩展为包含将不合逻辑的术语（如在布尔值上应用算术操作）简化为一个显式的“错误”状态 $wrong$ 的规则。也就是说，某些类型错误的术语可以直接求值为 $wrong$，这与通常的卡住状态不同。

#### **类型安全性形式化：**

当我们引入了“错误状态” $wrong$ 时，类型安全性的形式化需要做一些修改。我们需要确保**良类型的术语不会简化为 $wrong$**，即使不合逻辑的术语会被简化为 $wrong$，良类型的术语依然保持安全性。

1. **前进性 (Progress)**：
   - **前进性**依然表示良类型的术语要么是一个值，要么可以继续求值，但这里我们需要明确良类型的术语不能被简化为 $wrong$：
   $$
   \text{如果 } t : T，\text{则 } t \to v \text{ 且 } v \neq wrong。
   $$
   - 也就是说，良类型的术语最终要么是一个值，要么是可以继续求值的术语，但不会简化为错误状态。

2. **保持性 (Preservation)**：
   - **保持性**依然表示如果术语 $t$ 的类型为 $T$，那么它经过一步求值后，结果 $t'$ 的类型依然是 $T$。同时，我们要求这个结果不能是 $wrong$：
   $$
   \text{如果 } t : T \text{ 且 } t \to t'，\text{则 } t' : T \text{ 且 } t' \neq wrong。
   $$
   - 这保证了在求值过程中，良类型的术语不会导致错误状态。

#### **总结：**
在求值关系被扩展到处理荒谬术语的情况下，类型安全性依然可以通过前进性和保持性来形式化。关键区别在于，我们需要明确**良类型的术语永远不会被简化为 $wrong$**，即良类型的术语在求值过程中不会进入错误状态。

---

### 额外讨论：

#### **类型安全性在不同语言中的表现：**
如引言中的引用所述，不同语言对于类型安全性的形式化可能有所不同。例如，在某些形式化的 Java 操作语义中，类型保持性定理可能不会像这里描述的那样严格成立，但这不一定是语言本身的缺陷，而可能是形式化表示的一种特性。

在某些情况下，使用大步求值（big-step）或小步求值（small-step）会对类型保持性产生不同的影响。例如，大步求值中的类型安全性可以通过保证良类型的术语最终可以求值到一个良类型的值来维持，而小步求值则强调每一步求值过程中的类型保持性。

---

如果有进一步的问题或需要更详细的解释，欢迎继续提供内容！

### ---------------------------

### 引述解析：从无类型系统到类型化宇宙的演变

#### **背景：**
Luca Cardelli 和 Peter Wegner 在1985年探讨了从**无类型**（untyped）到**类型化系统**（typed systems）的过渡。这段引述指出，许多不同领域多次经历了这一演变，背后的原因基本相同：**类型系统的引入**带来了编程语言的安全性和可靠性，能够防止常见的运行时错误。

#### **解释：**

1. **无类型系统 (untyped systems) 到 类型化系统 (typed systems)**：
   - 早期编程语言，如 Lisp 等，是无类型的。所有值都可以通过通用的表示进行存储，类型错误只有在运行时才能检测到。而类型化系统则通过引入类型检查，允许在编译时就发现潜在的错误，从而提高了程序的健全性和可靠性。
   - 卡德里（Cardelli）和魏格纳（Wegner）的观点是，这种从无类型到类型化系统的演进不仅发生在编程语言中，而且在计算机科学的许多不同领域都体现出类似的趋势，目的是为了减少错误并增强系统的可维护性。

2. **相同的原因：类型带来的安全性**：
   - 引入类型化系统的核心动机是为了实现**类型安全性**。类型安全性确保程序不会执行非法操作，如对一个布尔值执行算术操作。这种安全性让程序员能够更好地推理程序行为，减少意外错误的发生。
   - 在编译期通过类型系统捕获错误，从而避免运行时错误，也大大提高了程序的健壮性。

---

### 脚注 4：有些语言的这些性质不成立，但仍然可以被视为类型安全

#### **背景：**
尽管类型系统提供了前进性和保持性等核心性质，有些语言可能并不满足这些特性，但仍然可以被认为是**类型安全的**。

#### **Java 作为例子：**

1. **Java 的操作语义**：
   - 如果我们将 Java 的操作语义形式化，并采用**小步求值风格**（small-step style），类型保持性定理（type preservation）可能不完全成立。具体而言，类型系统可能允许某些不保持类型的中间状态，但这些状态并不代表类型系统的失败。
   
2. **为什么仍然被认为是类型安全的？**：
   - 尽管在某些情况下，类型保持性定理会在小步求值的形式化中失败，但这并不意味着 Java 语言本身不安全。实际上，这种问题只是**形式化过程中的现象**，并非语言本身的缺陷。事实上，当我们采用**大步求值风格**（big-step style）重新表示语义时，这种问题可能完全消失。

3. **形式化与语言特性之间的关系**：
   - 脚注提到的例子表明，形式化过程中的某些细节可能导致我们暂时看不到某些性质（如保持性），但这并不代表语言本身存在问题。语言的安全性在某些情况下仍然得以保障，因为求值过程中某些语义可能在不同的形式化方式下呈现不同的性质。

#### **总结：**
- 有些编程语言（例如 Java）虽然在小步求值的形式化中不完全符合类型保持性定理，但我们仍然可以认为它们是类型安全的。这种差异往往是由于**形式化表达**的细节，而不是语言本身的缺陷。当采用不同的形式化方法（如大步求值）时，这些问题可能消失。

---

#### **补充说明：**
大步求值和小步求值是两种不同的操作语义形式化方式：
- **小步求值 (Small-Step Evaluation)**：逐步展示术语如何从一个状态演化到下一个状态，强调中间步骤的变化。
- **大步求值 (Big-Step Evaluation)**：直接展示术语如何一步到达其最终值，忽略了中间的演化步骤。

在某些情况下，语言的语义在小步求值和大步求值之间表现不同，类型安全性定理可能在某种表达下失败，但在另一种表达下成立。这种现象是形式化过程中的一种常见现象，并不能完全反映语言的类型安全性。

---

如果您有其他问题或需要进一步的解释，欢迎继续提问！



### ----------------------------
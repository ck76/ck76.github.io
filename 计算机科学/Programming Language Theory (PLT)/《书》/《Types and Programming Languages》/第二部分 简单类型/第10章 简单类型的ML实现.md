[toc]



### 第10章 **简单类型系统的 ML 实现** (An ML Implementation of Simple Types)

---

本章介绍了如何使用 ML（Meta Language）语言实现简单类型 λ 演算（Simply Typed Lambda-Calculus）。这个实现遵循了第7章中无类型 λ 演算实现的思路，主要增加了一个用于在给定上下文中计算给定项的类型的函数 `typeof`。在介绍 `typeof` 之前，我们需要一些用于操作上下文的底层机制。

---

#### 10.1 **上下文** (Contexts)

**回顾：**

- 在第7章（第85页），上下文（context）被定义为变量名和绑定对的列表：

  ```ocaml
  type context = (string * binding) list
  ```

- 在第7章中，我们仅在解析（parsing）和打印（printing）期间使用上下文来在有名和无名形式的项之间转换。

- 为此，我们只需要知道变量的名称；绑定类型（binding）被定义为一个不携带任何信息的简单数据类型：

  ```ocaml
  type binding = NameBind
  ```

**扩展：**

- 为了实现类型检查器，我们需要使用上下文来携带关于变量的类型假设。

- 我们通过向 `binding` 类型添加一个新的构造器 `VarBind` 来支持这一点：

  ```ocaml
  type binding =
    NameBind
  | VarBind of ty
  ```

  - `VarBind` 构造器携带对应变量的类型假设。

  - 我们保留了原来的 `NameBind` 构造器，以便解析和打印函数的方便，因为它们不关心类型假设。

**函数 `addbinding`：**

- `typeof` 函数使用 `addbinding` 函数，将一个新的变量绑定 `(x, bind)` 扩展到上下文 `ctx` 中。

- 由于上下文被表示为列表，`addbinding` 本质上就是列表的 `cons` 操作：

  ```ocaml
  let addbinding ctx x bind = (x, bind) :: ctx
  ```

**函数 `getTypeFromContext`：**

- 用于从上下文 `ctx` 中提取与特定变量 `i` 相关联的类型假设（`fi` 是位置信息，用于在变量超出范围时打印错误消息）：

  ```ocaml
  let getTypeFromContext fi ctx i =
    match getbinding fi ctx i with
      VarBind(tyT) -> tyT
    | _ -> error fi
              ("getTypeFromContext: Wrong kind of binding for variable "
              ^ (index2name fi ctx i))
  ```

  - `match` 语句提供了一些内部一致性检查：在正常情况下，`getTypeFromContext` 应始终被调用在上下文中第 `i` 个绑定实际上是一个 `VarBind`。

  - 如果 `getTypeFromContext` 被错误地调用到错误类型的变量，会使用低级别的 `error` 函数打印消息，并传递位置信息 `fi`，以报告错误发生的位置。

**函数 `error`：**

- 定义如下：

  ```ocaml
  val error : info -> string -> 'a
  ```

  - `error` 函数的返回类型是多态类型 `'a`，可以被实例化为任何 ML 类型（因为它永远不会实际返回：它打印消息并终止程序）。

  - 在这里，我们需要假设 `error` 的返回类型是 `ty`，因为 `match` 的另一个分支返回的是 `ty`。

**索引查找：**

- 我们通过索引查找类型假设，因为项在内部以无名形式表示，变量表示为数值索引。

- `getbinding` 函数简单地在给定的上下文中查找第 `i` 个绑定：

  ```ocaml
  val getbinding : info -> context -> int -> binding
  ```

- 其定义可以在书的网络资源中的 `simplebool` 实现中找到。

---

#### 10.2 **项和类型** (Terms and Types)

**类型的表示：**

- 类型的语法直接从 **图8-1** 和 **图9-1** 中的抽象语法转换为 ML 数据类型：

  ```ocaml
  type ty =
    TyBool
  | TyArr of ty * ty
  ```

  - `TyBool` 表示布尔类型 `Bool`。

  - `TyArr` 表示函数类型 `T1 -> T2`，其中 `TyArr(ty1, ty2)` 对应于 `ty1 -> ty2`。

**项的表示：**

- 项的表示与我们在无类型 λ 演算中使用的表示相同（第84页），只是对 `TmAbs` 分支添加了类型注释。

  ```ocaml
  type term =
    TmTrue of info
  | TmFalse of info
  | TmIf of info * term * term * term
  | TmVar of info * int * int
  | TmAbs of info * string * ty * term
  | TmApp of info * term * term
  ```

  - `TmTrue` 和 `TmFalse` 表示布尔常量。

  - `TmIf` 表示条件表达式。

  - `TmVar` 表示变量，使用无名形式，由变量的索引和上下文长度表示。

  - `TmAbs` 表示 λ 抽象，包含信息 `info`、参数名 `string`、参数类型 `ty` 和函数体 `term`。

  - `TmApp` 表示函数应用。

---

#### 10.3 **类型检查** (Typechecking)

**函数 `typeof`：**

- `typeof` 函数可以被视为 λ 演算类型规则（**图8-1** 和 **图9-1**）的直接翻译，或者更准确地说，是类型关系的反演引理（引理9.3.1）的转录。

- 第二种观点更准确，因为反演引理告诉我们，对于每种语法形式，项是类型良好的必要条件。

- 类型规则告诉我们在某些条件下某种形式的项是类型良好的，但通过查看单个类型规则，我们永远无法得出某个项不是类型良好的结论，因为总有可能使用另一个规则对该项进行类型检查。

**`typeof` 函数的实现：**

```ocaml
let rec typeof ctx t =
  match t with
    TmTrue(fi) ->
      TyBool
  | TmFalse(fi) ->
      TyBool
  | TmIf(fi, t1, t2, t3) ->
      if (=) (typeof ctx t1) TyBool then
        let tyT2 = typeof ctx t2 in
        if (=) tyT2 (typeof ctx t3) then tyT2
        else error fi "arms of conditional have different types"
      else error fi "guard of conditional not a boolean"
  | TmVar(fi, i, _) ->
      getTypeFromContext fi ctx i
  | TmAbs(fi, x, tyT1, t2) ->
      let ctx' = addbinding ctx x (VarBind(tyT1)) in
      let tyT2 = typeof ctx' t2 in
      TyArr(tyT1, tyT2)
  | TmApp(fi, t1, t2) ->
      let tyT1 = typeof ctx t1 in
      let tyT2 = typeof ctx t2 in
      (match tyT1 with
        TyArr(tyT11, tyT12) ->
          if (=) tyT2 tyT11 then tyT12
          else error fi "parameter type mismatch"
      | _ -> error fi "arrow type expected")
```

**详细解释：**

1. **布尔常量：**

   - `TmTrue(fi)` 和 `TmFalse(fi)`：

     - 直接返回类型 `TyBool`。

     ```ocaml
     TmTrue(fi) -> TyBool
     | TmFalse(fi) -> TyBool
     ```

2. **条件表达式：**

   - `TmIf(fi, t1, t2, t3)`：

     - 首先检查条件 `t1` 的类型是否为 `TyBool`。

     ```ocaml
     if (=) (typeof ctx t1) TyBool then
     ```

     - 如果是，则计算 `t2` 和 `t3` 的类型，确保它们相等。

     ```ocaml
     let tyT2 = typeof ctx t2 in
     if (=) tyT2 (typeof ctx t3) then tyT2
     else error fi "arms of conditional have different types"
     ```

     - 如果 `t2` 和 `t3` 的类型相同，返回该类型；否则，抛出错误。

     - 如果条件 `t1` 的类型不是 `TyBool`，则抛出错误。

     ```ocaml
     else error fi "guard of conditional not a boolean"
     ```

3. **变量：**

   - `TmVar(fi, i, _)`：

     - 使用 `getTypeFromContext` 函数从上下文中获取变量的类型。

     ```ocaml
     TmVar(fi, i, _) -> getTypeFromContext fi ctx i
     ```

4. **λ 抽象：**

   - `TmAbs(fi, x, tyT1, t2)`：

     - 将参数 `x` 的类型假设 `VarBind(tyT1)` 添加到上下文中，得到新的上下文 `ctx'`。

     ```ocaml
     let ctx' = addbinding ctx x (VarBind(tyT1)) in
     ```

     - 递归调用 `typeof` 计算函数体 `t2` 的类型 `tyT2`。

     ```ocaml
     let tyT2 = typeof ctx' t2 in
     ```

     - 返回函数类型 `TyArr(tyT1, tyT2)`。

     ```ocaml
     TyArr(tyT1, tyT2)
     ```

5. **函数应用：**

   - `TmApp(fi, t1, t2)`：

     - 递归计算 `t1` 和 `t2` 的类型 `tyT1` 和 `tyT2`。

     ```ocaml
     let tyT1 = typeof ctx t1 in
     let tyT2 = typeof ctx t2 in
     ```

     - 检查 `tyT1` 是否为函数类型 `TyArr(tyT11, tyT12)`。

     ```ocaml
     match tyT1 with
       TyArr(tyT11, tyT12) ->
     ```

     - 如果是，检查 `tyT2` 是否与参数类型 `tyT11` 相同。

     ```ocaml
     if (=) tyT2 tyT11 then tyT12
     else error fi "parameter type mismatch"
     ```

     - 如果类型匹配，返回结果类型 `tyT12`；否则，抛出参数类型不匹配的错误。

     - 如果 `tyT1` 不是函数类型，抛出需要函数类型的错误。

     ```ocaml
     | _ -> error fi "arrow type expected"
     ```

**OCaml 语言细节：**

- **比较运算符 `=`：**

  - 在 OCaml 中，`=` 是用于比较值是否相等的运算符。

  - 在上述代码中，`=` 被写在括号中 `(<operator>)`，以将其作为前缀函数使用，而不是中缀操作符。

  - 这样做的原因是为了方便后续版本的 `typeof` 函数的修改，在这些版本中，比较类型的操作需要比简单的相等更复杂。

- **结构相等性：**

  - OCaml 中的 `=` 运算符对复合值执行结构相等性比较，而不是指针相等性。

  - 例如：

    ```ocaml
    let t = TmApp(t1, t2) in
    let t' = TmApp(t1, t2) in
    (=) t t'
    ```

    - 即使 `t` 和 `t'` 是在不同时间分配的两个 `TmApp` 实例，它们的比较结果仍然是 `true`，因为它们的结构相同。

---

**总结：**

- 本章展示了如何使用 ML 实现简单类型 λ 演算，主要关注点是如何在 ML 中表示类型、项以及实现类型检查器。

- 通过对 `typeof` 函数的详细解释，我们了解了如何将类型规则和反演引理转化为实际的代码，实现对 λ 演算项的类型推导。

- 还讨论了在编程实践中需要注意的一些 OCaml 语言细节，如运算符的使用和比较方式。

---

**后续：**

- 在后续章节中，我们将探讨更复杂的类型系统和 λ 演算的扩展，包括多态类型、类型推断等。

- 本章的代码可以在书的网络资源中的 `simplebool` 实现中找到，读者可以参考并尝试运行和修改，以加深理解。

---

**如果您对上述内容有任何疑问，或者希望进一步讨论，请随时提出！**

### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------
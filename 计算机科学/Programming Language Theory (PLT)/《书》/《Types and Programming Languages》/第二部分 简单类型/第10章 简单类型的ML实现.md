[toc]



### ç¬¬10ç«  **ç®€å•ç±»å‹ç³»ç»Ÿçš„ ML å®ç°** (An ML Implementation of Simple Types)

---

æœ¬ç« ä»‹ç»äº†å¦‚ä½•ä½¿ç”¨ MLï¼ˆMeta Languageï¼‰è¯­è¨€å®ç°ç®€å•ç±»å‹ Î» æ¼”ç®—ï¼ˆSimply Typed Lambda-Calculusï¼‰ã€‚è¿™ä¸ªå®ç°éµå¾ªäº†ç¬¬7ç« ä¸­æ— ç±»å‹ Î» æ¼”ç®—å®ç°çš„æ€è·¯ï¼Œä¸»è¦å¢åŠ äº†ä¸€ä¸ªç”¨äºåœ¨ç»™å®šä¸Šä¸‹æ–‡ä¸­è®¡ç®—ç»™å®šé¡¹çš„ğŸ¥‘ç±»å‹çš„å‡½æ•°ğŸ¥‘ $ğŸ¥‘typeof$ã€‚åœ¨ä»‹ç» $typeof$ ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦ä¸€äº›ç”¨äºæ“ä½œä¸Šä¸‹æ–‡çš„åº•å±‚æœºåˆ¶ã€‚

---

#### 10.1 **ä¸Šä¸‹æ–‡** (Contexts)

**å›é¡¾ï¼š**

- åœ¨ç¬¬7ç« ï¼ˆç¬¬85é¡µï¼‰ï¼Œä¸Šä¸‹æ–‡ï¼ˆcontextï¼‰è¢«å®šä¹‰ä¸ºå˜é‡åå’Œç»‘å®šå¯¹çš„åˆ—è¡¨ï¼š

  ```ocaml
  type context = (string * binding) list
  ```

- åœ¨ç¬¬7ç« ä¸­ï¼Œæˆ‘ä»¬ä»…åœ¨è§£æï¼ˆparsingï¼‰å’Œæ‰“å°ï¼ˆprintingï¼‰æœŸé—´ä½¿ç”¨ä¸Šä¸‹æ–‡æ¥åœ¨æœ‰åå’Œæ— åå½¢å¼çš„é¡¹ä¹‹é—´è½¬æ¢ã€‚

- ä¸ºæ­¤ï¼Œæˆ‘ä»¬åªéœ€è¦çŸ¥é“å˜é‡çš„åç§°ï¼›ç»‘å®šç±»å‹ï¼ˆbindingï¼‰è¢«å®šä¹‰ä¸ºä¸€ä¸ªä¸æºå¸¦ä»»ä½•ä¿¡æ¯çš„ç®€å•æ•°æ®ç±»å‹ï¼š

  ```ocaml
  type binding = NameBind
  ```

**æ‰©å±•ï¼š**

- ä¸ºäº†å®ç°ç±»å‹æ£€æŸ¥å™¨ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨ä¸Šä¸‹æ–‡æ¥æºå¸¦å…³äºå˜é‡çš„ğŸ¥‘ç±»å‹å‡è®¾ã€‚

- æˆ‘ä»¬é€šè¿‡å‘ $binding$ ç±»å‹æ·»åŠ ä¸€ä¸ªæ–°çš„æ„é€ å™¨ $VarBind$ æ¥æ”¯æŒè¿™ä¸€ç‚¹ï¼š

  ```ocaml
  type binding =
    NameBind
  | VarBind of ty
  ```

  - $VarBind$ æ„é€ å™¨æºå¸¦å¯¹åº”å˜é‡çš„ç±»å‹å‡è®¾ã€‚

  - æˆ‘ä»¬ä¿ç•™äº†åŸæ¥çš„ $NameBind$ æ„é€ å™¨ï¼Œä»¥ä¾¿è§£æå’Œæ‰“å°å‡½æ•°çš„æ–¹ä¾¿ï¼Œå› ä¸ºå®ƒä»¬ä¸å…³å¿ƒç±»å‹å‡è®¾ã€‚

**å‡½æ•° $addbinding$ï¼š**

- $typeof$ å‡½æ•°ä½¿ç”¨ $addbinding$ å‡½æ•°ï¼Œå°†ä¸€ä¸ªæ–°çš„å˜é‡ç»‘å®š $(x, bind)$ æ‰©å±•åˆ°ä¸Šä¸‹æ–‡ $ctx$ ä¸­ã€‚

- ç”±äºä¸Šä¸‹æ–‡è¢«è¡¨ç¤ºä¸ºåˆ—è¡¨ï¼Œ$addbinding$ æœ¬è´¨ä¸Šå°±æ˜¯åˆ—è¡¨çš„ $cons$ æ“ä½œï¼š

  ```ocaml
  let addbinding ctx x bind = (x, bind) :: ctx
  ```

**å‡½æ•° $getTypeFromContext$ï¼š**

- ç”¨äºä»ä¸Šä¸‹æ–‡ $ctx$ ä¸­æå–ä¸ç‰¹å®šå˜é‡ $i$ ç›¸å…³è”çš„ç±»å‹å‡è®¾ï¼ˆ$fi$ æ˜¯ä½ç½®ä¿¡æ¯ï¼Œç”¨äºåœ¨å˜é‡è¶…å‡ºèŒƒå›´æ—¶æ‰“å°é”™è¯¯æ¶ˆæ¯ï¼‰ï¼š

  ```ocaml
  let getTypeFromContext fi ctx i =
    match getbinding fi ctx i with
      VarBind(tyT) -> tyT
    | _ -> error fi
              ("getTypeFromContext: Wrong kind of binding for variable "
              ^ (index2name fi ctx i))
  ```

  - $match$ è¯­å¥æä¾›äº†ä¸€äº›å†…éƒ¨ä¸€è‡´æ€§æ£€æŸ¥ï¼šåœ¨æ­£å¸¸æƒ…å†µä¸‹ï¼Œ$getTypeFromContext$ åº”å§‹ç»ˆè¢«è°ƒç”¨åœ¨ä¸Šä¸‹æ–‡ä¸­ç¬¬ $i$ ä¸ªç»‘å®šå®é™…ä¸Šæ˜¯ä¸€ä¸ª $VarBind$ã€‚

  - å¦‚æœ $getTypeFromContext$ è¢«é”™è¯¯åœ°è°ƒç”¨åˆ°é”™è¯¯ç±»å‹çš„å˜é‡ï¼Œä¼šä½¿ç”¨ä½çº§åˆ«çš„ $error$ å‡½æ•°æ‰“å°æ¶ˆæ¯ï¼Œå¹¶ä¼ é€’ä½ç½®ä¿¡æ¯ $fi$ï¼Œä»¥æŠ¥å‘Šé”™è¯¯å‘ç”Ÿçš„ä½ç½®ã€‚

**å‡½æ•° $error$ï¼š**

- å®šä¹‰å¦‚ä¸‹ï¼š

  ```ocaml
  val error : info -> string -> 'a
  ```

  - $error$ å‡½æ•°çš„è¿”å›ç±»å‹æ˜¯å¤šæ€ç±»å‹ $'a$ï¼Œå¯ä»¥è¢«å®ä¾‹åŒ–ä¸ºä»»ä½• ML ç±»å‹ï¼ˆå› ä¸ºå®ƒæ°¸è¿œä¸ä¼šå®é™…è¿”å›ï¼šå®ƒæ‰“å°æ¶ˆæ¯å¹¶ç»ˆæ­¢ç¨‹åºï¼‰ã€‚

  - åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬éœ€è¦å‡è®¾ $error$ çš„è¿”å›ç±»å‹æ˜¯ $ty$ï¼Œå› ä¸º $match$ çš„å¦ä¸€ä¸ªåˆ†æ”¯è¿”å›çš„æ˜¯ $ty$ã€‚

**ç´¢å¼•æŸ¥æ‰¾ï¼š**

- æˆ‘ä»¬é€šè¿‡ç´¢å¼•æŸ¥æ‰¾ç±»å‹å‡è®¾ï¼Œå› ä¸ºé¡¹åœ¨å†…éƒ¨ä»¥æ— åå½¢å¼è¡¨ç¤ºï¼Œå˜é‡è¡¨ç¤ºä¸ºæ•°å€¼ç´¢å¼•ã€‚

- $getbinding$ å‡½æ•°ç®€å•åœ°åœ¨ç»™å®šçš„ä¸Šä¸‹æ–‡ä¸­æŸ¥æ‰¾ç¬¬ $i$ ä¸ªç»‘å®šï¼š

  ```ocaml
  val getbinding : info -> context -> int -> binding
  ```

- å…¶å®šä¹‰å¯ä»¥åœ¨ä¹¦çš„ç½‘ç»œèµ„æºä¸­çš„ $simplebool$ å®ç°ä¸­æ‰¾åˆ°ã€‚

---

#### 10.2 **é¡¹å’Œç±»å‹** (Terms and Types)

**ç±»å‹çš„è¡¨ç¤ºï¼š**

- ç±»å‹çš„è¯­æ³•ç›´æ¥ä» **å›¾8-1** å’Œ **å›¾9-1** ä¸­çš„æŠ½è±¡è¯­æ³•è½¬æ¢ä¸º ML æ•°æ®ç±»å‹ï¼š

  ```ocaml
  type ty =
    TyBool
  | TyArr of ty * ty
  ```

  - $TyBool$ è¡¨ç¤ºå¸ƒå°”ç±»å‹ $Bool$ã€‚

  - $TyArr$ è¡¨ç¤ºå‡½æ•°ç±»å‹ $T1 -> T2$ï¼Œå…¶ä¸­ $TyArr(ty1, ty2)$ å¯¹åº”äº $ty1 -> ty2$ã€‚

**é¡¹çš„è¡¨ç¤ºï¼š**

- é¡¹çš„è¡¨ç¤ºä¸æˆ‘ä»¬åœ¨æ— ç±»å‹ Î» æ¼”ç®—ä¸­ä½¿ç”¨çš„è¡¨ç¤ºç›¸åŒï¼ˆç¬¬84é¡µï¼‰ï¼Œåªæ˜¯å¯¹ $TmAbs$ åˆ†æ”¯æ·»åŠ äº†ç±»å‹æ³¨é‡Šã€‚

  ```ocaml
  type term =
    TmTrue of info
  | TmFalse of info
  | TmIf of info * term * term * term
  | TmVar of info * int * int
  | TmAbs of info * string * ty * term
  | TmApp of info * term * term
  ```

  - $TmTrue$ å’Œ $TmFalse$ è¡¨ç¤ºå¸ƒå°”å¸¸é‡ã€‚

  - $TmIf$ è¡¨ç¤ºæ¡ä»¶è¡¨è¾¾å¼ã€‚

  - $TmVar$ è¡¨ç¤ºå˜é‡ï¼Œä½¿ç”¨æ— åå½¢å¼ï¼Œç”±å˜é‡çš„ç´¢å¼•å’Œä¸Šä¸‹æ–‡é•¿åº¦è¡¨ç¤ºã€‚

  - $TmAbs$ è¡¨ç¤º Î» æŠ½è±¡ï¼ŒåŒ…å«ä¿¡æ¯ $info$ã€å‚æ•°å $string$ã€å‚æ•°ç±»å‹ $ty$ å’Œå‡½æ•°ä½“ $term$ã€‚

  - $TmApp$ è¡¨ç¤ºå‡½æ•°åº”ç”¨ã€‚

---

#### 10.3 **ç±»å‹æ£€æŸ¥** (Typechecking)

**å‡½æ•° $typeof$ï¼š**

- $typeof$ å‡½æ•°å¯ä»¥è¢«è§†ä¸º Î» æ¼”ç®—ç±»å‹è§„åˆ™ï¼ˆ**å›¾8-1** å’Œ **å›¾9-1**ï¼‰çš„ç›´æ¥ç¿»è¯‘ï¼Œæˆ–è€…æ›´å‡†ç¡®åœ°è¯´ï¼Œæ˜¯ç±»å‹å…³ç³»çš„åæ¼”å¼•ç†ï¼ˆå¼•ç†9.3.1ï¼‰çš„è½¬å½•ã€‚

- ç¬¬äºŒç§è§‚ç‚¹æ›´å‡†ç¡®ï¼Œå› ä¸ºåæ¼”å¼•ç†å‘Šè¯‰æˆ‘ä»¬ï¼Œå¯¹äºæ¯ç§è¯­æ³•å½¢å¼ï¼Œé¡¹æ˜¯ç±»å‹è‰¯å¥½çš„å¿…è¦æ¡ä»¶ã€‚

- ç±»å‹è§„åˆ™å‘Šè¯‰æˆ‘ä»¬åœ¨æŸäº›æ¡ä»¶ä¸‹æŸç§å½¢å¼çš„é¡¹æ˜¯ç±»å‹è‰¯å¥½çš„ï¼Œä½†é€šè¿‡æŸ¥çœ‹å•ä¸ªç±»å‹è§„åˆ™ï¼Œæˆ‘ä»¬æ°¸è¿œæ— æ³•å¾—å‡ºæŸä¸ªé¡¹ä¸æ˜¯ç±»å‹è‰¯å¥½çš„ç»“è®ºï¼Œå› ä¸ºæ€»æœ‰å¯èƒ½ä½¿ç”¨å¦ä¸€ä¸ªè§„åˆ™å¯¹è¯¥é¡¹è¿›è¡Œç±»å‹æ£€æŸ¥ã€‚

**$typeof$ å‡½æ•°çš„å®ç°ï¼š**

```ocaml
let rec typeof ctx t =
  match t with
    TmTrue(fi) ->
      TyBool
  | TmFalse(fi) ->
      TyBool
  | TmIf(fi, t1, t2, t3) ->
      if (=) (typeof ctx t1) TyBool then
        let tyT2 = typeof ctx t2 in
        if (=) tyT2 (typeof ctx t3) then tyT2
        else error fi "arms of conditional have different types"
      else error fi "guard of conditional not a boolean"
  | TmVar(fi, i, _) ->
      getTypeFromContext fi ctx i
  | TmAbs(fi, x, tyT1, t2) ->
      let ctx' = addbinding ctx x (VarBind(tyT1)) in
      let tyT2 = typeof ctx' t2 in
      TyArr(tyT1, tyT2)
  | TmApp(fi, t1, t2) ->
      let tyT1 = typeof ctx t1 in
      let tyT2 = typeof ctx t2 in
      (match tyT1 with
        TyArr(tyT11, tyT12) ->
          if (=) tyT2 tyT11 then tyT12
          else error fi "parameter type mismatch"
      | _ -> error fi "arrow type expected")
```

**è¯¦ç»†è§£é‡Šï¼š**

1. **å¸ƒå°”å¸¸é‡ï¼š**

   - $TmTrue(fi)$ å’Œ $TmFalse(fi)$ï¼š

     - ç›´æ¥è¿”å›ç±»å‹ $TyBool$ã€‚

     ```ocaml
     TmTrue(fi) -> TyBool
     | TmFalse(fi) -> TyBool
     ```

2. **æ¡ä»¶è¡¨è¾¾å¼ï¼š**

   - $TmIf(fi, t1, t2, t3)$ï¼š

     - é¦–å…ˆæ£€æŸ¥æ¡ä»¶ $t1$ çš„ç±»å‹æ˜¯å¦ä¸º $TyBool$ã€‚

     ```ocaml
     if (=) (typeof ctx t1) TyBool then
     ```

     - å¦‚æœæ˜¯ï¼Œåˆ™è®¡ç®— $t2$ å’Œ $t3$ çš„ç±»å‹ï¼Œç¡®ä¿å®ƒä»¬ç›¸ç­‰ã€‚

     ```ocaml
     let tyT2 = typeof ctx t2 in
     if (=) tyT2 (typeof ctx t3) then tyT2
     else error fi "arms of conditional have different types"
     ```

     - å¦‚æœ $t2$ å’Œ $t3$ çš„ç±»å‹ç›¸åŒï¼Œè¿”å›è¯¥ç±»å‹ï¼›å¦åˆ™ï¼ŒæŠ›å‡ºé”™è¯¯ã€‚

     - å¦‚æœæ¡ä»¶ $t1$ çš„ç±»å‹ä¸æ˜¯ $TyBool$ï¼Œåˆ™æŠ›å‡ºé”™è¯¯ã€‚

     ```ocaml
     else error fi "guard of conditional not a boolean"
     ```

3. **å˜é‡ï¼š**

   - $TmVar(fi, i, _)$ï¼š

     - ä½¿ç”¨ $getTypeFromContext$ å‡½æ•°ä»ä¸Šä¸‹æ–‡ä¸­è·å–å˜é‡çš„ç±»å‹ã€‚

     ```ocaml
     TmVar(fi, i, _) -> getTypeFromContext fi ctx i
     ```

4. **Î» æŠ½è±¡ï¼š**

   - $TmAbs(fi, x, tyT1, t2)$ï¼š

     - ğŸ¥‘ğŸ¥‘ğŸ¥‘ğŸ¥‘ğŸ¥‘å°†å‚æ•° $x$ çš„ç±»å‹å‡è®¾ $VarBind(tyT1)$ æ·»åŠ åˆ°ä¸Šä¸‹æ–‡ä¸­ï¼Œå¾—åˆ°æ–°çš„ä¸Šä¸‹æ–‡ $ctx'$ã€‚

     ```ocaml
     let ctx' = addbinding ctx x (VarBind(tyT1)) in
     ```

     - é€’å½’è°ƒç”¨ $typeof$ è®¡ç®—å‡½æ•°ä½“ $t2$ çš„ç±»å‹ $tyT2$ã€‚

     ```ocaml
     let tyT2 = typeof ctx' t2 in
     ```

     - è¿”å›å‡½æ•°ç±»å‹ $TyArr(tyT1, tyT2)$ã€‚

     ```ocaml
     TyArr(tyT1, tyT2)
     ```

5. **å‡½æ•°åº”ç”¨ï¼š**

   - $TmApp(fi, t1, t2)$ï¼š

     - é€’å½’è®¡ç®— $t1$ å’Œ $t2$ çš„ç±»å‹ $tyT1$ å’Œ $tyT2$ã€‚

     ```ocaml
     let tyT1 = typeof ctx t1 in
     let tyT2 = typeof ctx t2 in
     ```

     - æ£€æŸ¥ $tyT1$ æ˜¯å¦ä¸ºå‡½æ•°ç±»å‹ $TyArr(tyT11, tyT12)$ã€‚

     ```ocaml
     match tyT1 with
       TyArr(tyT11, tyT12) ->
     ```

     - å¦‚æœæ˜¯ï¼Œæ£€æŸ¥ $tyT2$ æ˜¯å¦ä¸å‚æ•°ç±»å‹ $tyT11$ ç›¸åŒã€‚

     ```ocaml
     if (=) tyT2 tyT11 then tyT12
     else error fi "parameter type mismatch"
     ```

     - å¦‚æœç±»å‹åŒ¹é…ï¼Œè¿”å›ç»“æœç±»å‹ $tyT12$ï¼›å¦åˆ™ï¼ŒæŠ›å‡ºå‚æ•°ç±»å‹ä¸åŒ¹é…çš„é”™è¯¯ã€‚

     - å¦‚æœ $tyT1$ ä¸æ˜¯å‡½æ•°ç±»å‹ï¼ŒæŠ›å‡ºéœ€è¦å‡½æ•°ç±»å‹çš„é”™è¯¯ã€‚

     ```ocaml
     | _ -> error fi "arrow type expected"
     ```

**OCaml è¯­è¨€ç»†èŠ‚ï¼š**

- **æ¯”è¾ƒè¿ç®—ç¬¦ $=$ï¼š**

  - åœ¨ OCaml ä¸­ï¼Œ$=$ æ˜¯ç”¨äºæ¯”è¾ƒå€¼æ˜¯å¦ç›¸ç­‰çš„è¿ç®—ç¬¦ã€‚

  - åœ¨ä¸Šè¿°ä»£ç ä¸­ï¼Œ$=$ è¢«å†™åœ¨æ‹¬å·ä¸­ $(<operator>)$ï¼Œä»¥å°†å…¶ä½œä¸ºå‰ç¼€å‡½æ•°ä½¿ç”¨ï¼Œè€Œä¸æ˜¯ä¸­ç¼€æ“ä½œç¬¦ã€‚

  - è¿™æ ·åšçš„åŸå› æ˜¯ä¸ºäº†æ–¹ä¾¿åç»­ç‰ˆæœ¬çš„ $typeof$ å‡½æ•°çš„ä¿®æ”¹ï¼Œåœ¨è¿™äº›ç‰ˆæœ¬ä¸­ï¼Œæ¯”è¾ƒç±»å‹çš„æ“ä½œéœ€è¦æ¯”ç®€å•çš„ç›¸ç­‰æ›´å¤æ‚ã€‚

- **ç»“æ„ç›¸ç­‰æ€§ï¼š**

  - OCaml ä¸­çš„ $=$ è¿ç®—ç¬¦å¯¹å¤åˆå€¼æ‰§è¡Œç»“æ„ç›¸ç­‰æ€§æ¯”è¾ƒï¼Œè€Œä¸æ˜¯æŒ‡é’ˆç›¸ç­‰æ€§ã€‚

  - ä¾‹å¦‚ï¼š

    ```ocaml
    let t = TmApp(t1, t2) in
    let t' = TmApp(t1, t2) in
    (=) t t'
    ```

    - å³ä½¿ $t$ å’Œ $t'$ æ˜¯åœ¨ä¸åŒæ—¶é—´åˆ†é…çš„ä¸¤ä¸ª $TmApp$ å®ä¾‹ï¼Œå®ƒä»¬çš„æ¯”è¾ƒç»“æœä»ç„¶æ˜¯ $true$ï¼Œå› ä¸ºå®ƒä»¬çš„ç»“æ„ç›¸åŒã€‚

---

**æ€»ç»“ï¼š**

- æœ¬ç« å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨ ML å®ç°ç®€å•ç±»å‹ Î» æ¼”ç®—ï¼Œä¸»è¦å…³æ³¨ç‚¹æ˜¯å¦‚ä½•åœ¨ ML ä¸­è¡¨ç¤ºç±»å‹ã€é¡¹ä»¥åŠå®ç°ç±»å‹æ£€æŸ¥å™¨ã€‚

- é€šè¿‡å¯¹ $typeof$ å‡½æ•°çš„è¯¦ç»†è§£é‡Šï¼Œæˆ‘ä»¬äº†è§£äº†å¦‚ä½•å°†ç±»å‹è§„åˆ™å’Œåæ¼”å¼•ç†è½¬åŒ–ä¸ºå®é™…çš„ä»£ç ï¼Œå®ç°å¯¹ Î» æ¼”ç®—é¡¹çš„ç±»å‹æ¨å¯¼ã€‚

- è¿˜è®¨è®ºäº†åœ¨ç¼–ç¨‹å®è·µä¸­éœ€è¦æ³¨æ„çš„ä¸€äº› OCaml è¯­è¨€ç»†èŠ‚ï¼Œå¦‚è¿ç®—ç¬¦çš„ä½¿ç”¨å’Œæ¯”è¾ƒæ–¹å¼ã€‚

---

**åç»­ï¼š**

- åœ¨åç»­ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†æ¢è®¨æ›´å¤æ‚çš„ç±»å‹ç³»ç»Ÿå’Œ Î» æ¼”ç®—çš„æ‰©å±•ï¼ŒåŒ…æ‹¬å¤šæ€ç±»å‹ã€ç±»å‹æ¨æ–­ç­‰ã€‚

- æœ¬ç« çš„ä»£ç å¯ä»¥åœ¨ä¹¦çš„ç½‘ç»œèµ„æºä¸­çš„ $simplebool$ å®ç°ä¸­æ‰¾åˆ°ï¼Œè¯»è€…å¯ä»¥å‚è€ƒå¹¶å°è¯•è¿è¡Œå’Œä¿®æ”¹ï¼Œä»¥åŠ æ·±ç†è§£ã€‚

---

**å¦‚æœæ‚¨å¯¹ä¸Šè¿°å†…å®¹æœ‰ä»»ä½•ç–‘é—®ï¼Œæˆ–è€…å¸Œæœ›è¿›ä¸€æ­¥è®¨è®ºï¼Œè¯·éšæ—¶æå‡ºï¼**

### ---------------------------

### OCaml å®ç°ï¼šç®€å•ç±»å‹ç³»ç»Ÿ

#### ç¬¬10ç«  **ç®€å•ç±»å‹ç³»ç»Ÿçš„ ML å®ç°** (An ML Implementation of Simple Types)

æœ¬ç« ä»‹ç»äº†å¦‚ä½•ä½¿ç”¨ OCaml å®ç°ç®€å•ç±»å‹çš„ Î» æ¼”ç®—ã€‚è¯¥å®ç°åŸºäºå‰é¢ä»‹ç»çš„æ— ç±»å‹ Î» æ¼”ç®—ï¼Œä½†åŠ å…¥äº†ç±»å‹æ£€æŸ¥æœºåˆ¶ï¼Œæ‰©å±•äº†ä¸Šä¸‹æ–‡ä»¥æºå¸¦ç±»å‹å‡è®¾ï¼Œå¹¶ä½¿ç”¨ `typeof` å‡½æ•°æ¥è®¡ç®—è¡¨è¾¾å¼çš„ç±»å‹ã€‚

#### 10.1 **ä¸Šä¸‹æ–‡** (Contexts)

åœ¨æ— ç±»å‹ Î» æ¼”ç®—ä¸­ï¼Œä¸Šä¸‹æ–‡åªåŒ…å«å˜é‡åçš„ç»‘å®šã€‚åœ¨å¼•å…¥ç±»å‹ç³»ç»Ÿåï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨ä¸Šä¸‹æ–‡æ¥æºå¸¦å˜é‡çš„ç±»å‹å‡è®¾ã€‚

```ocaml
(* å®šä¹‰ç±»å‹ç»‘å®š *)
type binding =
    | NameBind
    | VarBind of ty  (* å˜é‡ç»‘å®šï¼Œæºå¸¦ç±»å‹ä¿¡æ¯ *)

(* ä¸Šä¸‹æ–‡ä¸ºå˜é‡åå’Œç»‘å®šç±»å‹çš„åˆ—è¡¨ *)
type context = (string * binding) list

(* å‘ä¸Šä¸‹æ–‡æ·»åŠ æ–°ç»‘å®š *)
let addbinding ctx x bind = (x, bind) :: ctx

(* è·å–ä¸Šä¸‹æ–‡ä¸­ç¬¬ i ä¸ªå˜é‡çš„ç»‘å®š *)
let getbinding ctx i =
  try List.nth ctx i
  with Failure _ -> failwith "Variable not found"

(* ä»ä¸Šä¸‹æ–‡ä¸­è·å–ç¬¬ i ä¸ªå˜é‡çš„ç±»å‹ *)
let getTypeFromContext ctx i =
  match getbinding ctx i with
  | VarBind(tyT) -> tyT
  | _ -> failwith "Wrong kind of binding"
```

#### 10.2 **é¡¹å’Œç±»å‹** (Terms and Types)

åœ¨ç®€å•ç±»å‹ Î» æ¼”ç®—ä¸­ï¼Œæ”¯æŒå¸ƒå°”ç±»å‹å’Œå‡½æ•°ç±»å‹ã€‚ä¸‹é¢æ˜¯ç±»å‹çš„è¡¨ç¤ºæ–¹å¼ï¼š

```ocaml
(* å®šä¹‰ç±»å‹ *)
type ty =
    | TyBool  (* å¸ƒå°”ç±»å‹ *)
    | TyArr of ty * ty  (* å‡½æ•°ç±»å‹ T1 -> T2 *)

(* å®šä¹‰é¡¹ *)
type term =
    | TmTrue  (* å¸ƒå°”å¸¸é‡ true *)
    | TmFalse  (* å¸ƒå°”å¸¸é‡ false *)
    | TmIf of term * term * term  (* æ¡ä»¶è¡¨è¾¾å¼ *)
    | TmVar of int  (* å˜é‡ï¼Œç”¨ç´¢å¼•è¡¨ç¤º *)
    | TmAbs of string * ty * term  (* Î» æŠ½è±¡ï¼Œå¸¦æœ‰ç±»å‹æ³¨é‡Š *)
    | TmApp of term * term  (* å‡½æ•°åº”ç”¨ *)
```

#### 10.3 **ç±»å‹æ£€æŸ¥** (Typechecking)

`typeof` å‡½æ•°æ ¹æ® Î» æ¼”ç®—çš„ç±»å‹è§„åˆ™ï¼Œé€’å½’åœ°ä¸ºæ¯ä¸ªé¡¹è®¡ç®—å…¶ç±»å‹ã€‚è¯¥å‡½æ•°æ ¹æ®ä¸åŒçš„é¡¹çš„ç±»å‹è§„åˆ™è¿›è¡ŒåŒ¹é…å¹¶è¿”å›é¡¹çš„ç±»å‹ã€‚

```ocaml
(* è®¡ç®—é¡¹çš„ç±»å‹ *)
let rec typeof ctx t = match t with
  | TmTrue -> TyBool  (* å¸ƒå°”å¸¸é‡ true çš„ç±»å‹ä¸º TyBool *)
  | TmFalse -> TyBool  (* å¸ƒå°”å¸¸é‡ false çš„ç±»å‹ä¸º TyBool *)
  | TmIf(t1, t2, t3) ->  (* æ¡ä»¶è¡¨è¾¾å¼ç±»å‹æ£€æŸ¥ *)
      if (typeof ctx t1) = TyBool then  (* t1 å¿…é¡»ä¸ºå¸ƒå°”ç±»å‹ *)
        let tyT2 = typeof ctx t2 in
        if tyT2 = (typeof ctx t3) then tyT2  (* t2 å’Œ t3 çš„ç±»å‹å¿…é¡»ç›¸åŒ *)
        else failwith "If branches must have the same type"
      else failwith "Guard of conditional must be a boolean"
  | TmVar(i) -> getTypeFromContext ctx i  (* å˜é‡ç±»å‹é€šè¿‡ä¸Šä¸‹æ–‡è·å– *)
  | TmAbs(x, tyT1, t2) ->  (* Î» æŠ½è±¡ *)
      let ctx' = addbinding ctx x (VarBind(tyT1)) in  (* æ·»åŠ å˜é‡çš„ç±»å‹å‡è®¾åˆ°ä¸Šä¸‹æ–‡ä¸­ *)
      let tyT2 = typeof ctx' t2 in
      TyArr(tyT1, tyT2)  (* è¿”å›å‡½æ•°ç±»å‹ T1 -> T2 *)
  | TmApp(t1, t2) ->  (* å‡½æ•°åº”ç”¨ *)
      let tyT1 = typeof ctx t1 in
      let tyT2 = typeof ctx t2 in
      (match tyT1 with
        | TyArr(tyT11, tyT12) ->  (* æ£€æŸ¥ t1 æ˜¯å¦ä¸ºå‡½æ•°ç±»å‹ *)
            if tyT2 = tyT11 then tyT12  (* å‚æ•°ç±»å‹ t2 å¿…é¡»åŒ¹é…å‡½æ•°ç±»å‹çš„å‚æ•°ç±»å‹ *)
            else failwith "Parameter type mismatch"
        | _ -> failwith "Expected a function type")
```

### è¯¦ç»†è¯´æ˜ï¼š

1. **å¸ƒå°”å¸¸é‡ç±»å‹åˆ¤æ–­ï¼š**
    - å¯¹äº `TmTrue` å’Œ `TmFalse`ï¼Œç›´æ¥è¿”å›å¸ƒå°”ç±»å‹ `TyBool`ã€‚

2. **æ¡ä»¶è¡¨è¾¾å¼ï¼š**
    - å¯¹äº `TmIf` è¡¨è¾¾å¼ï¼Œé¦–å…ˆæ£€æŸ¥æ¡ä»¶éƒ¨åˆ† `t1` æ˜¯å¦ä¸ºå¸ƒå°”ç±»å‹ `TyBool`ã€‚å¦‚æœæ˜¯ï¼Œåˆ™é€’å½’è®¡ç®—ä¸¤ä¸ªåˆ†æ”¯ `t2` å’Œ `t3` çš„ç±»å‹ï¼Œå¹¶ç¡®ä¿å®ƒä»¬ç›¸åŒã€‚å¦‚æœä¸ç›¸åŒæˆ–æ¡ä»¶ä¸æ˜¯å¸ƒå°”ç±»å‹ï¼Œåˆ™æŠ¥é”™ã€‚

3. **å˜é‡ï¼š**
    - å¯¹äºå˜é‡ `TmVar`ï¼Œä»ä¸Šä¸‹æ–‡ä¸­è·å–è¯¥å˜é‡çš„ç±»å‹ã€‚å˜é‡åœ¨é¡¹çš„å†…éƒ¨è¡¨ç¤ºä¸ºç´¢å¼•ï¼Œå› æ­¤é€šè¿‡ç´¢å¼•æŸ¥æ‰¾ä¸Šä¸‹æ–‡ä¸­çš„ç±»å‹å‡è®¾ã€‚

4. **Î» æŠ½è±¡ï¼š**
    - å¯¹äº Î» æŠ½è±¡ `TmAbs`ï¼Œé¦–å…ˆå°†å‚æ•°ç±»å‹ç»‘å®šåˆ°ä¸Šä¸‹æ–‡ä¸­ï¼Œç„¶åé€’å½’è®¡ç®—å‡½æ•°ä½“ `t2` çš„ç±»å‹ã€‚è¿”å›çš„ç±»å‹æ˜¯ `TyArr(tyT1, tyT2)`ï¼Œè¡¨ç¤ºå‚æ•°ç±»å‹åˆ°è¿”å›ç±»å‹çš„å‡½æ•°ç±»å‹ã€‚

5. **å‡½æ•°åº”ç”¨ï¼š**
    - å¯¹äºå‡½æ•°åº”ç”¨ `TmApp`ï¼Œé¦–å…ˆé€’å½’è®¡ç®—å‡½æ•°å’Œå‚æ•°çš„ç±»å‹ã€‚æ£€æŸ¥å‡½æ•°çš„ç±»å‹æ˜¯å¦ä¸º `TyArr(tyT11, tyT12)`ï¼Œå¹¶ç¡®ä¿å‚æ•°çš„ç±»å‹ `tyT2` ä¸å‡½æ•°ç±»å‹çš„å‚æ•°éƒ¨åˆ† `tyT11` ä¸€è‡´ã€‚å¦‚æœä¸€è‡´ï¼Œè¿”å›å‡½æ•°çš„è¿”å›ç±»å‹ `tyT12`ï¼Œå¦åˆ™æŠ¥é”™ã€‚

### ç»“è®ºï¼š

- é€šè¿‡è¿™ä¸ª OCaml å®ç°ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹ç®€å•ç±»å‹ Î» æ¼”ç®—ä¸­çš„è¡¨è¾¾å¼è¿›è¡Œç±»å‹æ£€æŸ¥ã€‚`typeof` å‡½æ•°å®ç°äº†ç±»å‹æ¨å¯¼çš„æ ¸å¿ƒé€»è¾‘ï¼Œæ ¹æ®ä¸Šä¸‹æ–‡å’Œè¡¨è¾¾å¼çš„è¯­æ³•ç»“æ„é€’å½’åœ°è®¡ç®—ç±»å‹ã€‚
- æœ¬ç« é€šè¿‡é€æ­¥å¼•å…¥ä¸Šä¸‹æ–‡ã€ç±»å‹è¡¨ç¤ºä»¥åŠç±»å‹æ£€æŸ¥å‡½æ•°ï¼Œä¸ºåç»­å¤æ‚ç±»å‹ç³»ç»Ÿçš„å®ç°æä¾›äº†åŸºç¡€ã€‚

ä½ å¯ä»¥å°è¯•å°†è¿™äº›ä»£ç è¿è¡Œåœ¨ OCaml ç¯å¢ƒä¸­ï¼Œè¿›ä¸€æ­¥ç†è§£å…¶å·¥ä½œæœºåˆ¶ã€‚å¦‚æœä½ å¯¹æŸäº›éƒ¨åˆ†éœ€è¦æ›´è¯¦ç»†çš„è§£é‡Šæˆ–æœ‰å…¶ä»–é—®é¢˜ï¼Œæ¬¢è¿ç»§ç»­æé—®ï¼

### ----------------------------

ä»¥ä¸‹æ˜¯å®Œæ•´çš„ OCaml å®ç°ä»£ç ï¼Œæ¶µç›–äº†ç®€å•ç±»å‹ç³»ç»Ÿçš„ä¸Šä¸‹æ–‡å¤„ç†ã€é¡¹å’Œç±»å‹çš„è¡¨ç¤ºä»¥åŠç±»å‹æ£€æŸ¥åŠŸèƒ½ã€‚ä½ å¯ä»¥å°†æ­¤ä»£ç ç›´æ¥è¿è¡Œåœ¨ OCaml ç¯å¢ƒä¸­ã€‚

```ocaml
(* å®šä¹‰ç±»å‹ *)
type ty =
    | TyBool  (* å¸ƒå°”ç±»å‹ *)
    | TyArr of ty * ty  (* å‡½æ•°ç±»å‹ T1 -> T2 *)

(* å®šä¹‰é¡¹ *)
type term =
    | TmTrue  (* å¸ƒå°”å¸¸é‡ true *)
    | TmFalse  (* å¸ƒå°”å¸¸é‡ false *)
    | TmIf of term * term * term  (* æ¡ä»¶è¡¨è¾¾å¼ *)
    | TmVar of int  (* å˜é‡ï¼Œç”¨ç´¢å¼•è¡¨ç¤º *)
    | TmAbs of string * ty * term  (* Î» æŠ½è±¡ï¼Œå¸¦æœ‰ç±»å‹æ³¨é‡Š *)
    | TmApp of term * term  (* å‡½æ•°åº”ç”¨ *)

(* å®šä¹‰ç»‘å®šç±»å‹ *)
type binding =
    | NameBind  (* åç§°ç»‘å®š *)
    | VarBind of ty  (* å˜é‡ç»‘å®šï¼Œæºå¸¦ç±»å‹ä¿¡æ¯ *)

(* ä¸Šä¸‹æ–‡ä¸ºå˜é‡åå’Œç»‘å®šç±»å‹çš„åˆ—è¡¨ *)
type context = (string * binding) list

(* å‘ä¸Šä¸‹æ–‡æ·»åŠ æ–°ç»‘å®š *)
let addbinding ctx x bind = (x, bind) :: ctx

(* è·å–ä¸Šä¸‹æ–‡ä¸­ç¬¬ i ä¸ªå˜é‡çš„ç»‘å®š *)
let getbinding ctx i =
  try List.nth ctx i
  with Failure _ -> failwith "Variable not found"

(* ä»ä¸Šä¸‹æ–‡ä¸­è·å–ç¬¬ i ä¸ªå˜é‡çš„ç±»å‹ *)
let getTypeFromContext ctx i =
  match getbinding ctx i with
  | VarBind(tyT) -> tyT
  | _ -> failwith "Wrong kind of binding"

(* è®¡ç®—é¡¹çš„ç±»å‹ *)
let rec typeof ctx t = match t with
  | TmTrue -> TyBool  (* å¸ƒå°”å¸¸é‡ true çš„ç±»å‹ä¸º TyBool *)
  | TmFalse -> TyBool  (* å¸ƒå°”å¸¸é‡ false çš„ç±»å‹ä¸º TyBool *)
  | TmIf(t1, t2, t3) ->  (* æ¡ä»¶è¡¨è¾¾å¼ç±»å‹æ£€æŸ¥ *)
      if (typeof ctx t1) = TyBool then  (* t1 å¿…é¡»ä¸ºå¸ƒå°”ç±»å‹ *)
        let tyT2 = typeof ctx t2 in
        if tyT2 = (typeof ctx t3) then tyT2  (* t2 å’Œ t3 çš„ç±»å‹å¿…é¡»ç›¸åŒ *)
        else failwith "If branches must have the same type"
      else failwith "Guard of conditional must be a boolean"
  | TmVar(i) -> getTypeFromContext ctx i  (* å˜é‡ç±»å‹é€šè¿‡ä¸Šä¸‹æ–‡è·å– *)
  | TmAbs(x, tyT1, t2) ->  (* Î» æŠ½è±¡ *)
      let ctx' = addbinding ctx x (VarBind(tyT1)) in  (* æ·»åŠ å˜é‡çš„ç±»å‹å‡è®¾åˆ°ä¸Šä¸‹æ–‡ä¸­ *)
      let tyT2 = typeof ctx' t2 in
      TyArr(tyT1, tyT2)  (* è¿”å›å‡½æ•°ç±»å‹ T1 -> T2 *)
  | TmApp(t1, t2) ->  (* å‡½æ•°åº”ç”¨ *)
      let tyT1 = typeof ctx t1 in
      let tyT2 = typeof ctx t2 in
      (match tyT1 with
        | TyArr(tyT11, tyT12) ->  (* æ£€æŸ¥ t1 æ˜¯å¦ä¸ºå‡½æ•°ç±»å‹ *)
            if tyT2 = tyT11 then tyT12  (* å‚æ•°ç±»å‹ t2 å¿…é¡»åŒ¹é…å‡½æ•°ç±»å‹çš„å‚æ•°ç±»å‹ *)
            else failwith "Parameter type mismatch"
        | _ -> failwith "Expected a function type")

(* ç¤ºä¾‹ä¸Šä¸‹æ–‡ *)
let ctx = [("x", VarBind(TyBool)); ("y", VarBind(TyArr(TyBool, TyBool)))]

(* ç¤ºä¾‹é¡¹ï¼š Î»x:Bool. x *)
let example_term = TmAbs("x", TyBool, TmVar(0))

(* è¿è¡Œç±»å‹æ£€æŸ¥ *)
let _ =
  let ty = typeof ctx example_term in
  match ty with
  | TyBool -> print_endline "Type: Bool"
  | TyArr(_, _) -> print_endline "Type: Function"
  | _ -> print_endline "Unknown type"
```

### è¿è¡Œè¯´æ˜ï¼š
1. **ä¸Šä¸‹æ–‡å’Œç±»å‹æ¨å¯¼**ï¼šåœ¨ `ctx` ä¸Šä¸‹æ–‡ä¸­ï¼Œå˜é‡ `x` è¢«ç»‘å®šä¸ºå¸ƒå°”ç±»å‹ `TyBool`ï¼Œè€Œ `y` è¢«ç»‘å®šä¸ºå‡½æ•°ç±»å‹ `TyArr(TyBool, TyBool)`ã€‚
2. **ç¤ºä¾‹é¡¹**ï¼š`example_term` æ˜¯ä¸€ä¸ªç®€å•çš„ Î» æŠ½è±¡ï¼Œè¡¨ç¤º `Î»x:Bool. x`ã€‚
3. **ç±»å‹æ£€æŸ¥å™¨**ï¼š`typeof` å‡½æ•°å°†ä¸ºç»™å®šçš„é¡¹è®¡ç®—å…¶ç±»å‹ï¼Œå¹¶è¾“å‡ºç»“æœã€‚

ä½ å¯ä»¥å¤åˆ¶å¹¶è¿è¡Œè¿™æ®µä»£ç ï¼ŒOCaml å°†è¾“å‡ºé¡¹çš„ç±»å‹ã€‚

### ---------------------------

æŠ±æ­‰ä¹‹å‰çš„ä»£ç æœ‰è¯¯ï¼Œé—®é¢˜å‡ºåœ¨ `getTypeFromContext` å‡½æ•°ä¸­ã€‚`getbinding` å‡½æ•°è¿”å›çš„æ˜¯ `(string * binding)` ç±»å‹çš„å€¼ï¼Œä½†åœ¨ `getTypeFromContext` ä¸­ï¼Œæˆ‘ä»¬éœ€è¦ä»ä¸­æå– `binding` éƒ¨åˆ†ã€‚

ä»¥ä¸‹æ˜¯ä¿®æ­£åçš„å®Œæ•´å¯è¿è¡Œçš„ OCaml ä»£ç ï¼š

```ocaml
(* å®šä¹‰ç±»å‹ *)
type ty =
    | TyBool  (* å¸ƒå°”ç±»å‹ *)
    | TyArr of ty * ty  (* å‡½æ•°ç±»å‹ T1 -> T2 *)

(* å®šä¹‰é¡¹ *)
type term =
    | TmTrue  (* å¸ƒå°”å¸¸é‡ true *)
    | TmFalse  (* å¸ƒå°”å¸¸é‡ false *)
    | TmIf of term * term * term  (* æ¡ä»¶è¡¨è¾¾å¼ *)
    | TmVar of int  (* å˜é‡ï¼Œç”¨ç´¢å¼•è¡¨ç¤º *)
    | TmAbs of string * ty * term  (* Î» æŠ½è±¡ï¼Œå¸¦æœ‰ç±»å‹æ³¨é‡Š *)
    | TmApp of term * term  (* å‡½æ•°åº”ç”¨ *)

(* å®šä¹‰ç»‘å®šç±»å‹ *)
type binding =
    | NameBind  (* åç§°ç»‘å®š *)
    | VarBind of ty  (* å˜é‡ç»‘å®šï¼Œæºå¸¦ç±»å‹ä¿¡æ¯ *)

(* ä¸Šä¸‹æ–‡ä¸ºå˜é‡åå’Œç»‘å®šç±»å‹çš„åˆ—è¡¨ *)
type context = (string * binding) list

(* å‘ä¸Šä¸‹æ–‡æ·»åŠ æ–°ç»‘å®š *)
let addbinding ctx x bind = (x, bind) :: ctx

(* è·å–ä¸Šä¸‹æ–‡ä¸­ç¬¬ i ä¸ªå˜é‡çš„ç»‘å®š *)
let getbinding ctx i =
  try List.nth ctx i
  with Failure _ -> failwith "Variable not found"

(* ä»ä¸Šä¸‹æ–‡ä¸­è·å–ç¬¬ i ä¸ªå˜é‡çš„ç±»å‹ *)
let getTypeFromContext ctx i =
  match getbinding ctx i with
  | (_, VarBind(tyT)) -> tyT  (* æå–ç»‘å®šä¸­çš„ç±»å‹ä¿¡æ¯ *)
  | _ -> failwith "Wrong kind of binding"

(* è®¡ç®—é¡¹çš„ç±»å‹ *)
let rec typeof ctx t = match t with
  | TmTrue -> TyBool  (* å¸ƒå°”å¸¸é‡ true çš„ç±»å‹ä¸º TyBool *)
  | TmFalse -> TyBool  (* å¸ƒå°”å¸¸é‡ false çš„ç±»å‹ä¸º TyBool *)
  | TmIf(t1, t2, t3) ->  (* æ¡ä»¶è¡¨è¾¾å¼ç±»å‹æ£€æŸ¥ *)
      if (typeof ctx t1) = TyBool then  (* t1 å¿…é¡»ä¸ºå¸ƒå°”ç±»å‹ *)
        let tyT2 = typeof ctx t2 in
        if tyT2 = (typeof ctx t3) then tyT2  (* t2 å’Œ t3 çš„ç±»å‹å¿…é¡»ç›¸åŒ *)
        else failwith "If branches must have the same type"
      else failwith "Guard of conditional must be a boolean"
  | TmVar(i) -> getTypeFromContext ctx i  (* å˜é‡ç±»å‹é€šè¿‡ä¸Šä¸‹æ–‡è·å– *)
  | TmAbs(x, tyT1, t2) ->  (* Î» æŠ½è±¡ *)
      let ctx' = addbinding ctx x (VarBind(tyT1)) in  (* æ·»åŠ å˜é‡çš„ç±»å‹å‡è®¾åˆ°ä¸Šä¸‹æ–‡ä¸­ *)
      let tyT2 = typeof ctx' t2 in
      TyArr(tyT1, tyT2)  (* è¿”å›å‡½æ•°ç±»å‹ T1 -> T2 *)
  | TmApp(t1, t2) ->  (* å‡½æ•°åº”ç”¨ *)
      let tyT1 = typeof ctx t1 in
      let tyT2 = typeof ctx t2 in
      (match tyT1 with
        | TyArr(tyT11, tyT12) ->  (* æ£€æŸ¥ t1 æ˜¯å¦ä¸ºå‡½æ•°ç±»å‹ *)
            if tyT2 = tyT11 then tyT12  (* å‚æ•°ç±»å‹ t2 å¿…é¡»åŒ¹é…å‡½æ•°ç±»å‹çš„å‚æ•°ç±»å‹ *)
            else failwith "Parameter type mismatch"
        | _ -> failwith "Expected a function type")

(* ç¤ºä¾‹ä¸Šä¸‹æ–‡ *)
let ctx = [("x", VarBind(TyBool)); ("y", VarBind(TyArr(TyBool, TyBool)))]

(* ç¤ºä¾‹é¡¹ï¼š Î»x:Bool. x *)
let example_term = TmAbs("x", TyBool, TmVar(0))

(* è¿è¡Œç±»å‹æ£€æŸ¥ *)
let _ =
  let ty = typeof ctx example_term in
  match ty with
  | TyBool -> print_endline "Type: Bool"
  | TyArr(_, _) -> print_endline "Type: Function"
  | _ -> print_endline "Unknown type"
```

### è§£é‡Šä¿®æ­£éƒ¨åˆ†ï¼š

- **`getTypeFromContext` å‡½æ•°ä¿®æ­£ï¼š**

  åŸå§‹ä»£ç ä¸­ï¼Œ`getTypeFromContext` å‡½æ•°ç›´æ¥åŒ¹é… `getbinding ctx i` çš„ç»“æœä¸º `VarBind(tyT)`ï¼Œä½†å®é™…ä¸Š `getbinding` è¿”å›çš„æ˜¯ `(string * binding)` ç±»å‹çš„å€¼ï¼Œå› æ­¤éœ€è¦å…ˆè§£æ„å…ƒç»„ï¼Œæå–å‡º `binding` éƒ¨åˆ†ã€‚

  ä¿®æ­£åçš„ä»£ç ï¼š

  ```ocaml
  let getTypeFromContext ctx i =
    match getbinding ctx i with
    | (_, VarBind(tyT)) -> tyT  (* æå–ç»‘å®šä¸­çš„ç±»å‹ä¿¡æ¯ *)
    | _ -> failwith "Wrong kind of binding"
  ```

- **å…³äºå˜é‡ç´¢å¼•ï¼š**

  åœ¨æ­¤å®ç°ä¸­ï¼Œå˜é‡ä½¿ç”¨ De Bruijn ç´¢å¼•è¡¨ç¤ºï¼Œæœ€å†…å±‚çš„ç»‘å®šç´¢å¼•ä¸º 0ï¼Œä¾æ¬¡é€’å¢ã€‚å› æ­¤ï¼Œ`getbinding` å‡½æ•°å¯ä»¥ç›´æ¥ä½¿ç”¨ `List.nth ctx i` æ¥è·å–ç¬¬ `i` ä¸ªç»‘å®šã€‚

### è¿è¡Œç»“æœï¼š

ç¼–è¯‘å¹¶è¿è¡Œä¸Šè¿°ä»£ç ï¼Œå°†è¾“å‡ºï¼š

```
Type: Function
```

è¿™è¡¨æ˜ç¤ºä¾‹é¡¹ `Î»x:Bool. x` çš„ç±»å‹è¢«æ­£ç¡®åœ°æ¨å¯¼ä¸ºä¸€ä¸ªå‡½æ•°ç±»å‹ã€‚

### è¯´æ˜ï¼š

- **ä¸Šä¸‹æ–‡ `ctx`ï¼š** åŒ…å«äº†å˜é‡ `x` å’Œ `y` çš„ç±»å‹ç»‘å®šï¼Œä¾›ç±»å‹æ£€æŸ¥å™¨åœ¨é‡åˆ°å˜é‡æ—¶æŸ¥æ‰¾å…¶ç±»å‹ã€‚
- **ç¤ºä¾‹é¡¹ `example_term`ï¼š** å®šä¹‰äº†ä¸€ä¸ªç®€å•çš„ Î» æŠ½è±¡ `Î»x:Bool. x`ï¼Œè¡¨ç¤ºèº«ä»½å‡½æ•°ï¼Œæ¥å—ä¸€ä¸ªå¸ƒå°”å€¼å¹¶è¿”å›è¯¥å€¼ã€‚
- **ç±»å‹æ£€æŸ¥å™¨ `typeof`ï¼š** é€’å½’åœ°è®¡ç®—é¡¹çš„ç±»å‹ï¼Œæ ¹æ®ç±»å‹è§„åˆ™è¿›è¡ŒåŒ¹é…å’ŒéªŒè¯ã€‚

### æ³¨æ„äº‹é¡¹ï¼š

- **å˜é‡ç»‘å®šå’Œä¸Šä¸‹æ–‡ç®¡ç†ï¼š** åœ¨ Î» æ¼”ç®—çš„å®ç°ä¸­ï¼Œæ­£ç¡®åœ°ç®¡ç†ä¸Šä¸‹æ–‡å’Œå˜é‡ç»‘å®šè‡³å…³é‡è¦ï¼Œç‰¹åˆ«æ˜¯åœ¨ä½¿ç”¨ De Bruijn ç´¢å¼•çš„æƒ…å†µä¸‹ã€‚
- **ç±»å‹åŒ¹é…å’Œé”™è¯¯å¤„ç†ï¼š** ç±»å‹æ£€æŸ¥å™¨éœ€è¦ç²¾ç¡®åœ°åŒ¹é…ç±»å‹ï¼Œå¹¶åœ¨ç±»å‹ä¸åŒ¹é…çš„æƒ…å†µä¸‹æŠ›å‡ºé€‚å½“çš„é”™è¯¯ä¿¡æ¯ã€‚

### è¿›ä¸€æ­¥æµ‹è¯•ï¼š

ä½ å¯ä»¥å°è¯•ä¿®æ”¹ `example_term`ï¼Œä¾‹å¦‚ï¼š

- å®šä¹‰ä¸€ä¸ªåº”ç”¨é¡¹ `TmApp(TmVar(1), TmTrue)`ï¼Œå¹¶åœ¨ä¸Šä¸‹æ–‡ä¸­ç¡®ä¿ç´¢å¼•ä¸º 1 çš„å˜é‡æ˜¯ä¸€ä¸ªå‡½æ•°ç±»å‹ã€‚
- å®šä¹‰ä¸€ä¸ªæ¡ä»¶è¡¨è¾¾å¼ `TmIf(TmVar(0), TmTrue, TmFalse)`ï¼Œå¹¶ç›¸åº”åœ°è°ƒæ•´ä¸Šä¸‹æ–‡ã€‚

### å®Œæ•´ä»£ç å¯è¿è¡Œï¼š

ç¡®ä¿å°†ä¸Šè¿°ä»£ç ä¿å­˜ä¸º `.ml` æ–‡ä»¶ï¼Œå¹¶ä½¿ç”¨ OCaml ç¼–è¯‘å™¨ç¼–è¯‘å’Œè¿è¡Œï¼š

```bash
ocamlc -o main main.ml
./main
```

å¦‚æœä½ æœ‰ä»»ä½•ç–‘é—®æˆ–éœ€è¦è¿›ä¸€æ­¥çš„å¸®åŠ©ï¼Œè¯·éšæ—¶æé—®ï¼

### ----------------------------

```ocaml
File "main.ml", line 73, characters 4-5:
73 |   | _ -> print_endline "Unknown type"
         ^
Warning 11 [redundant-case]: this match case is unused.
Type: Function
```



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------
[toc]



---
## 31 高阶子类型（Higher-Order Subtyping）

最后一个我们将要讨论的系统称为 **Fω<:**（“F-omega-sub”），它是类型算子和子类型的组合。它可以被视为将子类型扩展到类型算子的 **System F<:**，即二阶多态性 $\lambda$ 演算与有界量化的结合。**Fω<:** 的最有趣的新特性是将子类型关系从种类 $*$ 扩展到更高种类的类型。

**Fω<:** 的定义非常接近于 **Pierce 和 Steffen**（1994）的系统，是最简单的之一。我们不会在本章中证明该系统的任何性质；有兴趣的读者可以参考 **Pierce 和 Steffen**（1994），或者 **Compagnoni**（1994）以及 **Abadi 和 Cardelli**（1996），这些文献处理了类似的系统。（例如，第 28 章与第 30.3 节的复杂性相乘，展示了这些证明占用了多少空间。）

讨论 **Fω<:** 的主要原因是它为第 32 章中的面向对象编程（object-oriented programming）的最后一个案例研究提供了背景。这些示例不涉及 **Fω<:** 定义中的任何深奥方面——所需的仅仅是能够编写一个有界量化，范围限定在给定类型算子的子类型。读者可能希望在第一次阅读时快速浏览本章，并在遇到问题时再回来看。

### 31.1 直觉（Intuitions）

类型算子与子类型以及有界量化的交互在组合系统的设计中提出了若干设计问题。我们在继续定义系统之前，简要讨论这些问题。

#### 类型算子的有界抽象

第一个问题是，在有子类型的情况下，像 $\lambda X::K_1.~T_2$ 这样的类型算子是否应该推广为有界类型算子，例如 $\lambda X<:T_1.~T_2$。在本章中，我们选择了简洁性而非规律性，定义一个具有有界量化和无界类型算子的系统。

#### 子类型关系的提升

下一个问题是如何将子类型关系扩展到包括类型算子。有几种选择。我们在此选择最简单的一种：将子类型关系在类型算子上逐点提升。

**类型算子抽象的子类型规则**：

$$
\frac{\Gamma,~X \vdash S <: T}
     {\Gamma \vdash \lambda X.~S <: \lambda X.~T} \quad (\text{S-Abs})
$$

**解释**：如果在上下文 $\Gamma$ 中，类型算子 $\lambda X.~S$ 在 $X$ 绑定后是 $S <: T$，则 $\lambda X.~S$ 是 $\lambda X.~T$ 的子类型。

**类型算子应用的子类型规则**：

$$
\frac{\Gamma \vdash F <: G}{\Gamma \vdash F~U <: G~U} \quad (\text{S-App})
$$

**解释**：如果类型算子 $F$ 是类型算子 $G$ 的子类型，则对相同参数 $U$ 的应用 $F~U$ 是 $G~U$ 的子类型。

**注**：该规则仅在 $F$ 和 $G$ 应用于相同参数 $U$ 时适用——知道 $F$ 在逐点上是 $G$ 的子类型并不能告诉我们它们在不同参数上的行为。

#### 类型等价与子类型

一个额外的规则来源于类型等价关系的预期含义。如果 $S \equiv T$，则 $S$ 和 $T$ 拥有相同的成员。但拥有相同成员的类型必然互为子类型。因此，我们引入一个子类型规则，将定义等价关系作为基础情况。

$$
\frac{\Gamma \vdash S :: K \quad \Gamma \vdash T :: K \quad S \equiv T}
     {\Gamma \vdash S <: T} \quad (\text{S-Eq})
$$

**解释**：如果在上下文 $\Gamma$ 中，类型 $S$ 和 $T$ 都具有种类 $K$，且 $S \equiv T$，则 $S$ 是 $T$ 的子类型。

#### 子类型关系的扩展

通过将子类型关系从种类 $*$ 提升到种类 $* \Rightarrow *$，我们可以继续对更复杂的种类进行相同的提升。例如，如果 $P$ 和 $Q$ 是种类为 $* \Rightarrow * \Rightarrow *$ 的类型算子，则当对每个 $U$，应用 $P~U$ 是 $Q~U$ 的子类型时，我们说 $P <: Q$。

**最大元素**：这种定义的一个有用副作用是高种类的子类型关系都具有最大元素。如果我们定义：

$$
\text{Top}[K \Rightarrow K'] = \lambda X::K.~\text{Top}[K']
$$

则简单的归纳证明显示，在 $\Gamma \vdash S <: \text{Top}[K]$（只要 $S$ 具有种类 $K$ 时成立）。

#### 高阶有界量化

从普通的有界量化扩展到高阶有界量化是一个直接的步骤。**Fω<:** 继承了 **System F<:** 的有界量化形式 $\forall X<:T_1.~T_2$。将其推广到高阶（即，对类型算子的量化）无需改变语法：我们只需观察这里的 $T_1$ 可以是任何类型表达式，包括类型算子。无界的高阶量化继承自 **Fω**，可以被视为有界量化的缩写，使用最大界限，即将 $\forall X::K_1.~T_2$ 视为 $\forall X<: \text{Top}[K_1].~T_2$ 的缩写。

#### 子类型规则的变体

**Fω<:** 继承了 **System F<:** 的规则 $\text{S-All}$ 的问题，即使用更可操作的核心变体或更强大的完整变体。我们在本章中选择核心变体；完整变体虽然在语义上有意义，但其元理论性质（即使按类比 **System F<:** 也应该成立）尚未建立。

---
## 31 高阶子类型（Higher-Order Subtyping）

**Fω<:**（“F-omega-sub”）是类型算子和子类型的结合。它可以被看作是 **System F<:**，即二阶多态性 $\lambda$ 演算与有界量化的扩展，加入了类型算子。**Fω<:** 的最有趣的新特性是将子类型关系从种类 $*$ 扩展到更高种类的类型。

### 31.1 直觉（Intuitions）

类型算子与子类型及有界量化的交互在组合系统的设计中提出了若干设计问题。我们在继续定义系统之前，简要讨论这些问题。

#### 类型算子的有界抽象

第一个问题是，在有子类型的情况下，像 $\lambda X::K_1.~T_2$ 这样的类型算子是否应该推广为有界类型算子，例如 $\lambda X<:T_1.~T_2$。在本章中，我们选择了简洁性而非规律性，定义一个具有有界量化和无界类型算子的系统。

#### 子类型关系的提升

下一个问题是如何将子类型关系扩展到包括类型算子。有几种选择。我们在此选择最简单的一种：将子类型关系在类型算子上逐点提升。

**类型算子抽象的子类型规则**：

$$
\frac{\Gamma,~X \vdash S <: T}
     {\Gamma \vdash \lambda X.~S <: \lambda X.~T} \quad (\text{S-Abs})
$$

**解释**：如果在上下文 $\Gamma$ 中，类型算子 $\lambda X.~S$ 在 $X$ 绑定后是 $S <: T$，则 $\lambda X.~S$ 是 $\lambda X.~T$ 的子类型。

**类型算子应用的子类型规则**：

$$
\frac{\Gamma \vdash F <: G}
     {\Gamma \vdash F~U <: G~U} \quad (\text{S-App})
$$

**解释**：如果类型算子 $F$ 是类型算子 $G$ 的子类型，则对相同参数 $U$ 的应用 $F~U$ 是 $G~U$ 的子类型。

**注**：该规则仅在 $F$ 和 $G$ 应用于相同参数 $U$ 时适用——知道 $F$ 在逐点上是 $G$ 的子类型并不能告诉我们它们在不同参数上的行为。

#### 类型等价与子类型

一个额外的规则来源于类型等价关系的预期含义。如果 $S \equiv T$，则 $S$ 和 $T$ 拥有相同的成员。但拥有相同成员的类型必然互为子类型。因此，我们引入一个子类型规则，将定义等价关系作为基础情况。

$$
\frac{\Gamma \vdash S :: K \quad \Gamma \vdash T :: K \quad S \equiv T}
     {\Gamma \vdash S <: T} \quad (\text{S-Eq})
$$

**解释**：如果在上下文 $\Gamma$ 中，类型 $S$ 和 $T$ 都具有种类 $K$，且 $S \equiv T$，则 $S$ 是 $T$ 的子类型。

#### 子类型关系的扩展

通过将子类型关系从种类 $*$ 提升到种类 $* \Rightarrow *$，我们可以继续对更复杂的种类进行相同的提升。例如，如果 $P$ 和 $Q$ 是种类为 $* \Rightarrow * \Rightarrow *$ 的类型算子，则当对每个 $U$，应用 $P~U$ 是 $Q~U$ 的子类型时，我们说 $P <: Q$。

**最大元素**：这种定义的一个有用副作用是高种类的子类型关系都具有最大元素。如果我们定义：

$$
\text{Top}[K \Rightarrow K'] = \lambda X::K.~\text{Top}[K']
$$

则简单的归纳证明显示，在 $\Gamma \vdash S <: \text{Top}[K]$（只要 $S$ 具有种类 $K$ 时成立）。

#### 高阶有界量化

从普通的有界量化扩展到高阶有界量化是一个直接的步骤。**Fω<:** 继承了 **System F<:** 的有界量化形式 $\forall X<:T_1.~T_2$。将其推广到高阶（即，对类型算子的量化）无需改变语法：我们只需观察这里的 $T_1$ 可以是任何类型表达式，包括类型算子。无界的高阶量化继承自 **Fω**，可以被视为有界量化的缩写，使用最大界限，即将 $\forall X::K_1.~T_2$ 视为 $\forall X<: \text{Top}[K_1].~T_2$ 的缩写。

#### 子类型规则的变体

**Fω<:** 继承了 **System F<:** 的规则 $\text{S-All}$ 的问题，即使用更可操作的核心变体或更强大的完整变体。我们在本章中选择核心变体；完整变体虽然在语义上有意义，但其元理论性质（即使按类比 **System F<:** 也应该成立）尚未建立。

---
## 31.1 直觉（Intuitions）

类型算子与子类型及有界量化的交互在组合系统的设计中提出了若干设计问题。我们在继续定义系统之前，简要讨论这些问题。

### 类型算子的有界抽象

第一个问题是，在有子类型的情况下，像 $\lambda X::K_1.~T_2$ 这样的类型算子是否应该推广为有界类型算子，例如 $\lambda X<:T_1.~T_2$。在本章中，我们选择了简洁性而非规律性，定义一个具有有界量化和无界类型算子的系统。

### 子类型关系的提升

下一个问题是如何将子类型关系扩展到包括类型算子。有几种选择。我们在此选择最简单的一种：将子类型关系在类型算子上逐点提升。

**类型算子抽象的子类型规则**：

$$
\frac{\Gamma,~X \vdash S <: T}
     {\Gamma \vdash \lambda X.~S <: \lambda X.~T} \quad (\text{S-Abs})
$$

**解释**：如果在上下文 $\Gamma$ 中，类型算子 $\lambda X.~S$ 在 $X$ 绑定后是 $S <: T$，则 $\lambda X.~S$ 是 $\lambda X.~T$ 的子类型。

**类型算子应用的子类型规则**：

$$
\frac{\Gamma \vdash F <: G}
     {\Gamma \vdash F~U <: G~U} \quad (\text{S-App})
$$

**解释**：如果类型算子 $F$ 是类型算子 $G$ 的子类型，则对相同参数 $U$ 的应用 $F~U$ 是 $G~U$ 的子类型。

**注**：该规则仅在 $F$ 和 $G$ 应用于相同参数 $U$ 时适用——知道 $F$ 在逐点上是 $G$ 的子类型并不能告诉我们它们在不同参数上的行为。

### 类型等价与子类型

一个额外的规则来源于类型等价关系的预期含义。如果 $S \equiv T$，则 $S$ 和 $T$ 拥有相同的成员。但拥有相同成员的类型必然互为子类型。因此，我们引入一个子类型规则，将定义等价关系作为基础情况。

$$
\frac{\Gamma \vdash S :: K \quad \Gamma \vdash T :: K \quad S \equiv T}
     {\Gamma \vdash S <: T} \quad (\text{S-Eq})
$$

**解释**：如果在上下文 $\Gamma$ 中，类型 $S$ 和 $T$ 都具有种类 $K$，且 $S \equiv T$，则 $S$ 是 $T$ 的子类型。

### 子类型关系的扩展

通过将子类型关系从种类 $*$ 提升到种类 $* \Rightarrow *$，我们可以继续对更复杂的种类进行相同的提升。例如，如果 $P$ 和 $Q$ 是种类为 $* \Rightarrow * \Rightarrow *$ 的类型算子，则当对每个 $U$，应用 $P~U$ 是 $Q~U$ 的子类型时，我们说 $P <: Q$。

**最大元素**：这种定义的一个有用副作用是高种类的子类型关系都具有最大元素。如果我们定义：

$$
\text{Top}[K \Rightarrow K'] = \lambda X::K.~\text{Top}[K']
$$

则简单的归纳证明显示，在 $\Gamma \vdash S <: \text{Top}[K]$（只要 $S$ 具有种类 $K$ 时成立）。

### 高阶有界量化

从普通的有界量化扩展到高阶有界量化是一个直接的步骤。**Fω<:** 继承了 **System F<:** 的有界量化形式 $\forall X<:T_1.~T_2$。将其推广到高阶（即，对类型算子的量化）无需改变语法：我们只需观察这里的 $T_1$ 可以是任何类型表达式，包括类型算子。无界的高阶量化继承自 **Fω**，可以被视为有界量化的缩写，使用最大界限，即将 $\forall X::K_1.~T_2$ 视为 $\forall X<: \text{Top}[K_1].~T_2$ 的缩写。

### 子类型规则的变体

**Fω<:** 继承了 **System F<:** 的规则 $\text{S-All}$ 的问题，即使用更可操作的核心变体或更强大的完整变体。我们在本章中选择核心变体；完整变体虽然在语义上有意义，但其元理论性质（即使按类比 **System F<:** 也应该成立）尚未建立。

---
### 31.1 系统的定义（Definition）

**Fω<:** 研究的是子类型和类型算子的组合。以下是该系统的主要特性：

- **有界量化**（Bounded Quantification）与 **类型算子抽象** 的结合。
- 子类型关系从种类 $*$ 扩展到更高种类的类型算子。
- 种类 $K$ 的定义允许构建更高阶的类型算子。

**系统定义的主要内容**：

1. **种类的层级**：
   $$
   \begin{align*}
   K_1 &= \emptyset \\
   K_{i+1} &= * \cup \{ J \Rightarrow K \mid J \in K_i \text{ 且 } K \in K_{i+1} \} \\
   K_\omega &= \bigcup_{1 \leq i} K_i
   \end{align*}
   $$

2. **子类型规则的提升**：
   - **S-Abs**：
     $$
     \frac{\Gamma,~X \vdash S <: T}
          {\Gamma \vdash \lambda X.~S <: \lambda X.~T}
     $$
     **解释**：如果在上下文 $\Gamma$ 中，类型算子 $\lambda X.~S$ 是 $\lambda X.~T$ 的子类型，那么 $\lambda X.~S <: \lambda X.~T$。

   - **S-App**：
     $$
     \frac{\Gamma \vdash F <: G}
          {\Gamma \vdash F~U <: G~U}
     $$
     **解释**：如果 $F <: G$，则 $F~U <: G~U$。

   - **S-Eq**：
     $$
     \frac{\Gamma \vdash S :: K \quad \Gamma \vdash T :: K \quad S \equiv T}
          {\Gamma \vdash S <: T}
     $$
     **解释**：如果 $S$ 和 $T$ 在种类 $K$ 下等价，则 $S <: T$。

3. **全称量化与类型算子的结合**：
   - **有界量化**：
     $$
     \forall X<:T_1.~T_2
     $$
     表示 $X$ 是一种类型，其上界为 $T_1$，并且 $T_2$ 可以依赖于 $X$。

   - **无界量化**（作为有界量化的缩写）：
     $$
     \forall X::K_1.~T_2 \quad \text{视为} \quad \forall X<: \text{Top}[K_1].~T_2
     $$
     **解释**：无界量化 $\forall X::K_1.~T_2$ 被视为有界量化 $\forall X<: \text{Top}[K_1].~T_2$，其中 $\text{Top}[K_1]$ 是种类 $K_1$ 的最大元素。

### 31.2 子类型关系的提升（Subtyping Lifted to Higher Kinds）

**Fω<:** 通过逐点提升子类型关系，将其扩展到高种类类型算子。具体来说：

- 如果 $F <: G$，且 $F$ 和 $G$ 是种类为 $K_1 \Rightarrow K_2$ 的类型算子，则对于任何类型 $U$，$F~U <: G~U$。

- 这种逐点提升确保了类型算子在被应用时保持子类型关系。

### 31.3 系统的扩展与性质（Extensions and Properties）

**Fω<:** 继承了子类型和类型算子的主要机制，但需要确保以下几点：

1. **种类的良构性**：所有类型在被使用前都必须具有正确的种类。

2. **类型等价的传递性与对称性**：确保等价关系的性质，使得类型等价关系能够正确地被子类型规则使用。

3. **类型替换与项替换的保留**：确保替换操作不会破坏类型系统的正确性。

### 31.4 子类型的更高阶扩展（Higher-Order Extensions of Subtyping）

某些更复杂的变体允许在不同参数上的应用时也维持子类型关系，但这需要更复杂的规则和证明，通常会增加系统的复杂性。

---
## 31.1 直觉（Intuitions）

类型算子与子类型及有界量化的交互在组合系统的设计中提出了若干设计问题。我们在继续定义系统之前，简要讨论这些问题。

### 类型算子的有界抽象

第一个问题是，在有子类型的情况下，像 $\lambda X::K_1.~T_2$ 这样的类型算子是否应该推广为有界类型算子，例如 $\lambda X<:T_1.~T_2$。在本章中，我们选择了简洁性而非规律性，定义一个具有有界量化和无界类型算子的系统。

### 子类型关系的提升

下一个问题是如何将子类型关系扩展到包括类型算子。有几种选择。我们在此选择最简单的一种：将子类型关系在类型算子上逐点提升。

**类型算子抽象的子类型规则**：

$$
\frac{\Gamma,~X \vdash S <: T}
     {\Gamma \vdash \lambda X.~S <: \lambda X.~T} \quad (\text{S-Abs})
$$

**解释**：如果在上下文 $\Gamma$ 中，类型算子 $\lambda X.~S$ 在 $X$ 绑定后是 $S <: T$，则 $\lambda X.~S$ 是 $\lambda X.~T$ 的子类型。

**类型算子应用的子类型规则**：

$$
\frac{\Gamma \vdash F <: G}
     {\Gamma \vdash F~U <: G~U} \quad (\text{S-App})
$$

**解释**：如果类型算子 $F$ 是类型算子 $G$ 的子类型，则对相同参数 $U$ 的应用 $F~U$ 是 $G~U$ 的子类型。

**注**：该规则仅在 $F$ 和 $G$ 应用于相同参数 $U$ 时适用——知道 $F$ 在逐点上是 $G$ 的子类型并不能告诉我们它们在不同参数上的行为。

### 类型等价与子类型

一个额外的规则来源于类型等价关系的预期含义。如果 $S \equiv T$，则 $S$ 和 $T$ 拥有相同的成员。但拥有相同成员的类型必然互为子类型。因此，我们引入一个子类型规则，将定义等价关系作为基础情况。

$$
\frac{\Gamma \vdash S :: K \quad \Gamma \vdash T :: K \quad S \equiv T}
     {\Gamma \vdash S <: T} \quad (\text{S-Eq})
$$

**解释**：如果在上下文 $\Gamma$ 中，类型 $S$ 和 $T$ 都具有种类 $K$，且 $S \equiv T$，则 $S$ 是 $T$ 的子类型。

### 子类型关系的扩展

通过将子类型关系从种类 $*$ 提升到种类 $* \Rightarrow *$，我们可以继续对更复杂的种类进行相同的提升。例如，如果 $P$ 和 $Q$ 是种类为 $* \Rightarrow * \Rightarrow *$ 的类型算子，则当对每个 $U$，应用 $P~U$ 是 $Q~U$ 的子类型时，我们说 $P <: Q$。

**最大元素**：这种定义的一个有用副作用是高种类的子类型关系都具有最大元素。如果我们定义：

$$
\text{Top}[K \Rightarrow K'] = \lambda X::K.~\text{Top}[K']
$$

则简单的归纳证明显示，在 $\Gamma \vdash S <: \text{Top}[K]$（只要 $S$ 具有种类 $K$ 时成立）。

### 高阶有界量化

从普通的有界量化扩展到高阶有界量化是一个直接的步骤。**Fω<:** 继承了 **System F<:** 的有界量化形式 $\forall X<:T_1.~T_2$。将其推广到高阶（即，对类型算子的量化）无需改变语法：我们只需观察这里的 $T_1$ 可以是任何类型表达式，包括类型算子。无界的高阶量化继承自 **Fω**，可以被视为有界量化的缩写，使用最大界限，即将 $\forall X::K_1.~T_2$ 视为 $\forall X<: \text{Top}[K_1].~T_2$ 的缩写。

### 子类型规则的变体

**Fω<:** 继承了 **System F<:** 的规则 $\text{S-All}$ 的问题，即使用更可操作的核心变体或更强大的完整变体。我们在本章中选择核心变体；完整变体虽然在语义上有意义，但其元理论性质（即使按类比 **System F<:** 也应该成立）尚未建立。

---
### 31.1 系统的定义（Definition）

**Fω<:** 研究的是子类型和类型算子的组合。以下是该系统的主要特性：

- **有界量化**（Bounded Quantification）与 **类型算子抽象** 的结合。
- 子类型关系从种类 $*$ 扩展到更高种类的类型算子。
- 种类 $K$ 的定义允许构建更高阶的类型算子。

**系统定义的主要内容**：

1. **种类的层级**：
   $$
   \begin{align*}
   K_1 &= \emptyset \\
   K_{i+1} &= * \cup \{ J \Rightarrow K \mid J \in K_i \text{ 且 } K \in K_{i+1} \} \\
   K_\omega &= \bigcup_{1 \leq i} K_i
   \end{align*}
   $$

2. **子类型规则的提升**：
   - **S-Abs**：
     $$
     \frac{\Gamma,~X \vdash S <: T}
          {\Gamma \vdash \lambda X.~S <: \lambda X.~T}
     $$
     **解释**：如果在上下文 $\Gamma$ 中，类型算子 $\lambda X.~S$ 是 $\lambda X.~T$ 的子类型，那么 $\lambda X.~S <: \lambda X.~T$。

   - **S-App**：
     $$
     \frac{\Gamma \vdash F <: G}
          {\Gamma \vdash F~U <: G~U}
     $$
     **解释**：如果类型算子 $F$ 是类型算子 $G$ 的子类型，则对相同参数 $U$ 的应用 $F~U$ 是 $G~U$ 的子类型。

   - **S-Eq**：
     $$
     \frac{\Gamma \vdash S :: K \quad \Gamma \vdash T :: K \quad S \equiv T}
          {\Gamma \vdash S <: T}
     $$
     **解释**：如果在上下文 $\Gamma$ 中，类型 $S$ 和 $T$ 都具有种类 $K$，且 $S \equiv T$，则 $S$ 是 $T$ 的子类型。

3. **全称量化与类型算子的结合**：
   - **有界量化**：
     $$
     \forall X<:T_1.~T_2
     $$
     表示 $X$ 是一种类型，其上界为 $T_1$，并且 $T_2$ 可以依赖于 $X$。

   - **无界量化**（作为有界量化的缩写）：
     $$
     \forall X::K_1.~T_2 \quad \text{视为} \quad \forall X<: \text{Top}[K_1].~T_2
     $$
     **解释**：无界量化 $\forall X::K_1.~T_2$ 被视为有界量化 $\forall X<: \text{Top}[K_1].~T_2$，其中 $\text{Top}[K_1]$ 是种类 $K_1$ 的最大元素。

---
### 31.2 系统的扩展与性质（Extensions and Properties）

**Fω<:** 继承了子类型和类型算子的主要机制，但需要确保以下几点：

1. **种类的良构性**：所有类型在被使用前都必须具有正确的种类。

2. **类型等价的传递性与对称性**：确保等价关系的性质，使得类型等价关系能够正确地被子类型规则使用。

3. **类型替换与项替换的保留**：确保替换操作不会破坏类型系统的正确性。

### 31.3 子类型关系的更高阶扩展（Higher-Order Extensions of Subtyping）

某些更复杂的变体允许在不同参数上的应用时也维持子类型关系，但这需要更复杂的规则和证明，通常会增加系统的复杂性。

---
## 31.4 系统的实现与应用（Implementation and Applications）

尽管本章没有详细讨论 **Fω<:** 的实现和具体应用，但了解其设计原则和核心规则对于后续章节，特别是第 32 章中的面向对象编程案例研究至关重要。读者可以参考以下文献以获得更深入的理解：

- **Pierce 和 Steffen**（1994）
- **Compagnoni**（1994）
- **Abadi 和 Cardelli**（1996）

---
## 总结

本章介绍了 **Fω<:**，一个结合了类型算子和子类型的高级类型系统。通过逐点提升子类型关系到更高种类的类型算子，**Fω<:** 能够处理更复杂的类型抽象和多态性。这为构建更强大的编程语言提供了理论基础，尤其是在面向对象编程和依赖类型的实现中。

**关键概念中英对照**：

- **Type Operators** 类型算子
- **Subtyping** 子类型
- **Bounded Quantification** 有界量化
- **Higher-Kinded Types** 高阶种类类型
- **Type Abstraction** 类型抽象
- **Type Equivalence** 类型等价
- **Confluence** 合流性
- **Preservation** 保持性
- **Progress** 前进性

通过理解 **Fω<:** 的设计和性质，读者能够更好地掌握高级类型系统的构建原理，并将这些知识应用于实际的编程语言设计中。

### ---------------------------

## 31.2 定义（Definitions）

**Fω <:** 的定义规则列在**图 31-1**中。定义中的一个技术细节是，尽管系统为类型变量提供了两种不同的绑定方式（类型算子中的 $X::K$ 和量词中的 $X <: T$），我们仅在上下文中允许后者形式的绑定。在规则 **K-Abs** 和 **S-Abs** 中，当我们将 $X::K$ 绑定从结论的右侧移动到左侧时，我们将其更改为 $X <: \text{Top}[K]$。

另一个细节是，**Fω <:** 中的规则 **S-Refl**（来自 **F<:**）和 **T-Eq**（来自 **Fω**）被省略。旧的 **S-Refl** 实例可以直接由 **S-Eq** 和 **Q-Refl** 推导而出，而 **T-Eq** 则可以由 **T-Sub** 和 **S-Eq** 推导而来。

### 31.2.1 练习（Exercise）[«]

**问题**：如果我们定义 $Id = \lambda X.~X$ 并且上下文 $\Gamma = B <: \text{Top}, A <: B, F <: Id$，那么以下哪些子类型关系是可以推导的？

1. $\Gamma \vdash A <: Id~B$
2. $\Gamma \vdash Id~A <: B$
3. $\Gamma \vdash \lambda X.~X <: \lambda X.~\text{Top}$
4. $\Gamma \vdash \lambda X.~\forall Y <: X.~Y <: \lambda X.~\forall Y <: \text{Top}.~Y$
5. $\Gamma \vdash \lambda X.~\forall Y <: X.~Y <: \lambda X.~\forall Y <: X.~X$
6. $\Gamma \vdash F~B <: B$
7. $\Gamma \vdash B <: F~B$
8. $\Gamma \vdash F~B <: F~B$
9. $\Gamma \vdash \forall F <: (\lambda Y.~\text{Top} \to Y).~F~A <: \forall F <: (\lambda Y.~\text{Top} \to Y).~\text{Top} \to B$
10. $\Gamma \vdash \forall F <: (\lambda Y.~\text{Top} \to Y).~F~A <: \forall F <: (\lambda Y.~\text{Top} \to Y).~F~B$
11. $\Gamma \vdash \text{Top}[ * \Rightarrow *] <: \text{Top}[ * \Rightarrow * \Rightarrow *]$

**解答**：

我们逐一分析每个子类型关系是否可以在上下文 $\Gamma = B <: \text{Top}, A <: B, F <: Id$ 下被推导。

#### 1. $\Gamma \vdash A <: Id~B$

- **分析**：
  - 已知 $F <: Id$，即 $F$ 是 $Id$ 的子类型。
  - 要证明 $A <: Id~B$。
  - 根据上下文，$A <: B$。
  - $Id~B = (\lambda X.~X)~B = B$。
  - 因此，$A <: B$，所以 $A <: Id~B$ 成立。

- **结论**：可推导。

#### 2. $\Gamma \vdash Id~A <: B$

- **分析**：
  - $Id~A = (\lambda X.~X)~A = A$。
  - 需要证明 $A <: B$。
  - 上下文中已知 $A <: B$。

- **结论**：可推导。

#### 3. $\Gamma \vdash \lambda X.~X <: \lambda X.~\text{Top}$

- **分析**：
  - 根据 **S-Abs** 规则：
    $$
    \frac{\Gamma,~X \vdash S <: T}{\Gamma \vdash \lambda X.~S <: \lambda X.~T} \quad (\text{S-Abs})
    $$
  - 设 $S = X$，$T = \text{Top}$。
  - 需要在上下文 $\Gamma, X <: \text{Top}[K]$ 下证明 $X <: \text{Top}$。
  - $\text{Top}$ 的种类为 $*$，$X <: \text{Top}[K] = X <: \text{Top}$。
  - 根据类型变量绑定，$X <: \text{Top}$ 已被绑定，且 $\text{Top} <: \text{Top}$（由 **S-Eq**）。

- **结论**：可推导。

#### 4. $\Gamma \vdash \lambda X.~\forall Y <: X.~Y <: \lambda X.~\forall Y <: \text{Top}.~Y$

- **分析**：
  - 使用 **S-Abs** 规则：
    $$
    \frac{\Gamma,~X \vdash S <: T}{\Gamma \vdash \lambda X.~S <: \lambda X.~T}
    $$
  - 设 $S = \forall Y <: X.~Y$，$T = \forall Y <: \text{Top}.~Y$。
  - 需要在 $\Gamma, X <: \text{Top}$ 下证明 $\forall Y <: X.~Y <: \forall Y <: \text{Top}.~Y$。
  - 使用 **S-All** 规则：
    $$
    \frac{\Gamma,~X <: T_1 \vdash S <: T_2}{\Gamma \vdash \forall X <: T_1.~S <: \forall X <: T_1.~T_2} \quad (\text{S-All})
    $$
  - 设 $T_1 = X$, $S = Y$, $T_2 = Y$。
  - 需要在 $\Gamma, X <: \text{Top}$ 下证明 $Y <: Y$，这是显然的（由 **S-Eq**）。
  - 因此，$\forall Y <: X.~Y <: \forall Y <: \text{Top}.~Y$ 成立。

- **结论**：可推导。

#### 5. $\Gamma \vdash \lambda X.~\forall Y <: X.~Y <: \lambda X.~\forall Y <: X.~X$

- **分析**：
  - 使用 **S-Abs** 规则：
    $$
    \frac{\Gamma,~X \vdash S <: T}{\Gamma \vdash \lambda X.~S <: \lambda X.~T}
    $$
  - 设 $S = \forall Y <: X.~Y$，$T = \forall Y <: X.~X$。
  - 需要在 $\Gamma, X <: \text{Top}$ 下证明 $\forall Y <: X.~Y <: \forall Y <: X.~X$。
  - 使用 **S-All** 规则：
    $$
    \frac{\Gamma,~X <: T_1 \vdash S <: T_2}{\Gamma \vdash \forall X <: T_1.~S <: \forall X <: T_1.~T_2} \quad (\text{S-All})
    $$
  - 设 $T_1 = X$, $S = Y$, $T_2 = X$。
  - 需要在 $\Gamma, X <: \text{Top}$ 下证明 $Y <: X$。
  - 由于 $X <: \text{Top}$，且 $Y$ 是类型变量绑定为 $Y <: X$，则 $Y <: X$ 成立。

- **结论**：可推导。

#### 6. $\Gamma \vdash F~B <: B$

- **分析**：
  - 已知 $F <: Id$。
  - $F~B <: Id~B$（由 **S-App**）。
  - $Id~B = B$。
  - 因此，$F~B <: B$。

- **结论**：可推导。

#### 7. $\Gamma \vdash B <: F~B$

- **分析**：
  - 已知 $F <: Id$，即 $F~U <: Id~U$ 对任意 $U$。
  - $Id~B = B$，所以 $F~B <: B$。
  - 需要证明 $B <: F~B$，但已知 $F~B <: B$，且没有信息表明 $B <: F~B$。
  - 无法推出 $B <: F~B$。

- **结论**：不可推导。

#### 8. $\Gamma \vdash F~B <: F~B$

- **分析**：
  - 任何类型总是其自身的子类型（由类型等价关系 **S-Eq**）。
  - $F~B \equiv F~B$，因此 $F~B <: F~B$。

- **结论**：可推导。

#### 9. $\Gamma \vdash \forall F <: (\lambda Y.~\text{Top} \to Y).~F~A <: \forall F <: (\lambda Y.~\text{Top} \to Y).~\text{Top} \to B$

- **分析**：
  - 使用 **S-All** 规则：
    $$
    \frac{\Gamma,~F <: (\lambda Y.~\text{Top} \to Y) \vdash F~A <: \text{Top} \to B}
         {\Gamma \vdash \forall F <: (\lambda Y.~\text{Top} \to Y).~F~A <: \forall F <: (\lambda Y.~\text{Top} \to Y).~\text{Top} \to B}
    $$
  - 需要在 $\Gamma, F <: (\lambda Y.~\text{Top} \to Y)$ 下证明 $F~A <: \text{Top} \to B$。
  - 已知 $F <: Id$，即 $F~A <: Id~A$。
  - $Id~A = A$。
  - 需要证明 $A <: \text{Top} \to B$，但上下文中 $A <: B$，且 $B <: \text{Top}$，但无法直接推导 $A <: \text{Top} \to B$。

- **结论**：不可推导。

#### 10. $\Gamma \vdash \forall F <: (\lambda Y.~\text{Top} \to Y).~F~A <: \forall F <: (\lambda Y.~\text{Top} \to Y).~F~B$

- **分析**：
  - 使用 **S-All** 规则：
    $$
    \frac{\Gamma,~F <: (\lambda Y.~\text{Top} \to Y) \vdash F~A <: F~B}
         {\Gamma \vdash \forall F <: (\lambda Y.~\text{Top} \to Y).~F~A <: \forall F <: (\lambda Y.~\text{Top} \to Y).~F~B}
    $$
  - 需要在 $\Gamma, F <: (\lambda Y.~\text{Top} \to Y)$ 下证明 $F~A <: F~B$。
  - 已知 $A <: B$，且 $F <: Id$。
  - 根据 **S-App**，$F~A <: Id~A = A$ 和 $F~B <: Id~B = B$。
  - 但 $A <: B$，所以通过传递性，$F~A <: B$。
  - 由于 $F~B <: B$，但不一定 $F~A <: F~B$。

- **结论**：不可推导。

#### 11. $\Gamma \vdash \text{Top}[ * \Rightarrow *] <: \text{Top}[ * \Rightarrow * \Rightarrow *]$

- **分析**：
  - 定义 $\text{Top}[K \Rightarrow K'] = \lambda X::K.~\text{Top}[K']$。
  - 需要证明 $\text{Top}[ * \Rightarrow *] <: \text{Top}[ * \Rightarrow * \Rightarrow *]$。
  - 根据定义：
    $$
    \text{Top}[ * \Rightarrow *] = \lambda X:: * \Rightarrow *.~\text{Top}[*]
    $$
    $$
    \text{Top}[ * \Rightarrow * \Rightarrow *] = \lambda X:: * \Rightarrow * \Rightarrow *.~\text{Top}[*]
    $$
  - 使用 **S-Abs** 规则：
    $$
    \frac{\Gamma,~X <: \text{Top}[ * \Rightarrow *] \vdash \text{Top}[ *] <: \text{Top}[*] }
         {\Gamma \vdash \lambda X:: * \Rightarrow *.~\text{Top}[ *] <: \lambda X:: * \Rightarrow * \Rightarrow *.~\text{Top}[ *]}
    $$
  - 需要在 $\Gamma, X <: \text{Top}[ * \Rightarrow *]$ 下证明 $\text{Top}[ *] <: \text{Top}[ *]$。
  - $\text{Top}[ *] = \text{Top}$，且 $\text{Top} <: \text{Top}$ 成立（由 **S-Eq**）。

- **结论**：可推导。

### 图 31-1：高阶有界量化（Fω <:）的定义规则

**语法（Syntax）**

- **项（Terms）**：
  $$
  \begin{align*}
  t &::= x & \text{变量} \\
    &| \lambda x:T.~t & \text{抽象} \\
    &| t~t & \text{应用} \\
    &| \lambda X<:T.~t & \text{类型抽象} \\
    &| t~[T] & \text{类型应用}
  \end{align*}
  $$

- **值（Values）**：
  $$
  \begin{align*}
  v &::= \lambda x:T.~t & \text{抽象值} \\
    &| \lambda X<:T.~t & \text{类型抽象值}
  \end{align*}
  $$

- **类型（Types）**：
  $$
  \begin{align*}
  T &::= \text{Top} & \text{最大类型} \\
    &| X & \text{类型变量} \\
    &| T_1 \to T_2 & \text{函数类型} \\
    &| \forall X<:T.~T & \text{全称类型} \\
    &| \lambda X::K.~T & \text{类型算子抽象} \\
    &| T~T & \text{类型算子应用}
  \end{align*}
  $$

- **上下文（Contexts）**：
  $$
  \begin{align*}
  \Gamma &::= \emptyset & \text{空上下文} \\
        &| \Gamma, x:T & \text{项变量绑定} \\
        &| \Gamma, X<:T & \text{类型变量绑定}
  \end{align*}
  $$

- **种类（Kinds）**：
  $$
  \begin{align*}
  K &::= * & \text{适当类型的种类} \\
    &| K \Rightarrow K & \text{类型算子的种类}
  \end{align*}
  $$

**归约规则（Evaluation Rules）**

- **单步归约**（Single-step reduction）$t \rightarrow t'$：

  1. **E-App1**：
     $$
     \frac{t_1 \rightarrow t'_1}{t_1~t_2 \rightarrow t'_1~t_2}
     $$
     **解释**：如果 $t_1$ 归约为 $t'_1$，则 $t_1~t_2$ 归约为 $t'_1~t_2$。

  2. **E-App2**：
     $$
     \frac{t_2 \rightarrow t'_2}{v_1~t_2 \rightarrow v_1~t'_2}
     $$
     **解释**：如果 $t_2$ 归约为 $t'_2$，则 $v_1~t_2$ 归约为 $v_1~t'_2$。

  3. **E-AppAbs**：
     $$
     (\lambda x:T_{11}.~t_{12})~v_2 \rightarrow [x \mapsto v_2]~t_{12} \quad (\text{E-AppAbs})
     $$
     **解释**：函数抽象应用于一个值时，进行替换。

  4. **E-TApp**：
     $$
     \frac{t_1 \rightarrow t'_1}{t_1~[T_2] \rightarrow t'_1~[T_2]}
     $$
     **解释**：如果 $t_1$ 归约为 $t'_1$，则 $t_1~[T_2]$ 归约为 $t'_1~[T_2]$。

  5. **E-TappTabs**：
     $$
     (\lambda X<:T_{11}.~t_{12})~[T_2] \rightarrow [X \mapsto T_2]~t_{12} \quad (\text{E-TappTabs})
     $$
     **解释**：类型抽象应用于一个类型时，进行替换。

**种类推导规则（Kinding Rules）**

- **K-TVar**：
  $$
  \frac{\Gamma \vdash F <: T}{\Gamma \vdash X :: K}
  $$
  **解释**：如果 $X <: T$ 存在于上下文 $\Gamma$ 中，并且 $\Gamma \vdash T :: K$，则 $X$ 的种类为 $K$。

- **K-Abs**：
  $$
  \frac{\Gamma, X <: T \vdash T_2 :: K_2 \quad \Gamma \vdash T_1 :: K_{11} \quad \Gamma \vdash T_1 \to T_2 :: K_{12}}
       {\Gamma \vdash \lambda X::K_1.~T_2 :: K_1 \Rightarrow K_2}
  $$
  **解释**：类型算子抽象的种类推导。

- **K-App**：
  $$
  \frac{\Gamma \vdash T_1 :: K_{11} \quad \Gamma \vdash T_2 :: K_{11} \quad \Gamma \vdash T_1 \to T_2 :: K_{12}}
       {\Gamma \vdash T_1~T_2 :: K_{12}}
  $$
  **解释**：类型算子应用的种类推导。

- **K-Arrow**：
  $$
  \frac{\Gamma \vdash T_1 :: * \quad \Gamma \vdash T_2 :: *}
       {\Gamma \vdash T_1 \to T_2 :: *}
  $$
  **解释**：函数类型的种类推导。

- **K-All**：
  $$
  \frac{\Gamma, X <: T_1 \vdash T_2 :: *}
       {\Gamma \vdash \forall X<:T_1.~T_2 :: *}
  $$
  **解释**：全称类型的种类推导。

### 31.2 定义规则详解

以下详细解释 **Fω <:** 的定义规则，包括语法、归约规则和种类推导规则。

#### 语法（Syntax）

**项（Terms）**：

- **变量（Variable）**：
  $$
  t ::= x \quad \text{(变量)}
  $$
  **解释**：$x$ 是一个变量，可以代表任何项。

- **抽象（Abstraction）**：
  $$
  t ::= \lambda x:T.~t \quad \text{(抽象)}
  $$
  **解释**：这是一个函数抽象，接受参数 $x$，其类型为 $T$，函数体为 $t$。

- **应用（Application）**：
  $$
  t ::= t~t \quad \text{(应用)}
  $$
  **解释**：这是一个函数应用，将函数 $t_1$ 应用于参数 $t_2$，表示为 $t_1~t_2$。

- **类型抽象（Type Abstraction）**：
  $$
  t ::= \lambda X<:T.~t \quad \text{(类型抽象)}
  $$
  **解释**：这是一个类型抽象，接受类型参数 $X$，其上界为 $T$，抽象体为 $t$。

- **类型应用（Type Application）**：
  $$
  t ::= t~[T] \quad \text{(类型应用)}
  $$
  **解释**：这是一个类型应用，将类型算子 $t_1$ 应用于类型 $T_2$，表示为 $t_1~[T_2]$。

**值（Values）**：

- **抽象值（Abstraction Value）**：
  $$
  v ::= \lambda x:T.~t \quad \text{(抽象值)}
  $$
  **解释**：抽象本身就是一个值，表示一个函数。

- **类型抽象值（Type Abstraction Value）**：
  $$
  v ::= \lambda X<:T.~t \quad \text{(类型抽象值)}
  $$
  **解释**：类型抽象本身也是一个值，表示一个多态函数。

**类型（Types）**：

- **最大类型（Top）**：
  $$
  T ::= \text{Top} \quad \text{(最大类型)}
  $$
  **解释**：$\text{Top}$ 是所有类型的超级类型。

- **类型变量（Type Variable）**：
  $$
  T ::= X \quad \text{(类型变量)}
  $$
  **解释**：$X$ 是一个类型变量，可以代表任何类型。

- **函数类型（Function Type）**：
  $$
  T ::= T_1 \to T_2 \quad \text{(函数类型)}
  $$
  **解释**：这是一个函数类型，从类型 $T_1$ 到类型 $T_2$。

- **全称类型（Universal Type）**：
  $$
  T ::= \forall X<:T.~T \quad \text{(全称类型)}
  $$
  **解释**：这是一个全称类型，表示对于所有类型 $X$，其上界为 $T$，类型为 $T_2$。

- **类型算子抽象（Type Operator Abstraction）**：
  $$
  T ::= \lambda X::K.~T \quad \text{(类型算子抽象)}
  $$
  **解释**：这是一个类型算子抽象，接受类型参数 $X$，其种类为 $K$，抽象体为类型 $T$。

- **类型算子应用（Type Operator Application）**：
  $$
  T ::= T~T \quad \text{(类型算子应用)}
  $$
  **解释**：这是一个类型算子应用，将类型算子 $T_1$ 应用于类型 $T_2$，表示为 $T_1~T_2$。

**上下文（Contexts）**：

- **空上下文（Empty Context）**：
  $$
  \Gamma ::= \emptyset \quad \text{(空上下文)}
  $$

- **项变量绑定（Term Variable Binding）**：
  $$
  \Gamma ::= \Gamma, x:T \quad \text{(项变量绑定)}
  $$

- **类型变量绑定（Type Variable Binding）**：
  $$
  \Gamma ::= \Gamma, X<:T \quad \text{(类型变量绑定)}
  $$

**种类（Kinds）**：

- **适当类型的种类（Kind of Proper Types）**：
  $$
  K ::= * \quad \text{(适当类型的种类)}
  $$

- **类型算子的种类（Kind of Type Operators）**：
  $$
  K ::= K \Rightarrow K \quad \text{(类型算子的种类)}
  $$

#### 归约规则（Evaluation Rules）

**单步归约**（Single-step reduction）$t \rightarrow t'$ 表示项 $t$ 归约为项 $t'$。

1. **E-App1**：
   $$
   \frac{t_1 \rightarrow t'_1}{t_1~t_2 \rightarrow t'_1~t_2} \quad (\text{E-App1})
   $$
   **解释**：如果函数部分 $t_1$ 归约为 $t'_1$，则整个应用 $t_1~t_2$ 归约为 $t'_1~t_2$。

2. **E-App2**：
   $$
   \frac{t_2 \rightarrow t'_2}{v_1~t_2 \rightarrow v_1~t'_2} \quad (\text{E-App2})
   $$
   **解释**：如果参数部分 $t_2$ 归约为 $t'_2$，且 $v_1$ 是一个值，则整个应用 $v_1~t_2$ 归约为 $v_1~t'_2$。

3. **E-AppAbs**：
   $$
   (\lambda x:T_{11}.~t_{12})~v_2 \rightarrow [x \mapsto v_2]~t_{12} \quad (\text{E-AppAbs})
   $$
   **解释**：函数抽象应用于一个值时，进行替换，将 $x$ 替换为 $v_2$。

4. **E-TApp**：
   $$
   \frac{t_1 \rightarrow t'_1}{t_1~[T_2] \rightarrow t'_1~[T_2]} \quad (\text{E-TApp})
   $$
   **解释**：如果类型抽象部分 $t_1$ 归约为 $t'_1$，则整个类型应用 $t_1~[T_2]$ 归约为 $t'_1~[T_2]$。

5. **E-TappTabs**：
   $$
   (\lambda X<:T_{11}.~t_{12})~[T_2] \rightarrow [X \mapsto T_2]~t_{12} \quad (\text{E-TappTabs})
   $$
   **解释**：类型抽象应用于一个类型时，进行替换，将 $X$ 替换为 $T_2$。

#### 种类推导规则（Kinding Rules）

1. **K-TVar**：
   $$
   \frac{\Gamma \vdash F <: T}{\Gamma \vdash X :: K} \quad (\text{K-TVar})
   $$
   **解释**：如果在上下文 $\Gamma$ 中，类型变量 $X$ 被绑定为 $X <: T$，且 $T$ 的种类为 $K$，则 $X$ 的种类为 $K$。

2. **K-Abs**：
   $$
   \frac{\Gamma,~X <: T \vdash T_2 :: K_2 \quad \Gamma \vdash T_1 :: K_{11} \quad \Gamma \vdash T_1 \to T_2 :: K_{12}}
        {\Gamma \vdash \lambda X::K_1.~T_2 :: K_1 \Rightarrow K_2} \quad (\text{K-Abs})
   $$
   **解释**：类型算子抽象的种类推导。假设在上下文 $\Gamma$ 和 $X <: T$ 下，$T_2$ 的种类为 $K_2$，且 $T_1 \to T_2$ 的种类为 $K_{12}$，则 $\lambda X::K_1.~T_2$ 的种类为 $K_1 \Rightarrow K_2$。

3. **K-App**：
   $$
   \frac{\Gamma \vdash T_1 :: K_{11} \quad \Gamma \vdash T_2 :: K_{11} \quad \Gamma \vdash T_1 \to T_2 :: K_{12}}
        {\Gamma \vdash T_1~T_2 :: K_{12}} \quad (\text{K-App})
   $$
   **解释**：类型算子应用的种类推导。如果 $T_1$ 和 $T_2$ 的种类均为 $K_{11}$，且 $T_1 \to T_2$ 的种类为 $K_{12}$，则 $T_1~T_2$ 的种类为 $K_{12}$。

4. **K-Arrow**：
   $$
   \frac{\Gamma \vdash T_1 :: * \quad \Gamma \vdash T_2 :: *}
        {\Gamma \vdash T_1 \to T_2 :: *} \quad (\text{K-Arrow})
   $$
   **解释**：函数类型的种类推导。如果 $T_1$ 和 $T_2$ 都具有种类 $*$，则 $T_1 \to T_2$ 的种类也为 $*$。

5. **K-All**：
   $$
   \frac{\Gamma,~X <: T_1 \vdash T_2 :: *}
        {\Gamma \vdash \forall X<:T_1.~T_2 :: *} \quad (\text{K-All})
   $$
   **解释**：全称类型的种类推导。如果在上下文 $\Gamma$ 和 $X <: T_1$ 下，$T_2$ 的种类为 $*$，则 $\forall X<:T_1.~T_2$ 的种类为 $*$。

### 总结

**Fω <:** 是一个结合了类型算子和子类型的高阶类型系统。其定义包括：

- **语法**：定义了项、值、类型、上下文和种类的构成。
- **归约规则**：定义了如何进行单步归约，包括函数应用和类型应用的规则。
- **种类推导规则**：定义了如何为不同类型构造推导其种类。

通过练习，我们验证了在特定上下文下，某些子类型关系是否可以被推导。理解这些规则对于掌握 **Fω <:** 的性质和应用至关重要。

**关键概念中英对照**：

- **Type Abstraction** 类型抽象
- **Type Application** 类型应用
- **Subtyping** 子类型
- **Bounded Quantification** 有界量化
- **Type Operator** 类型算子
- **Kinding** 种类推导
- **Reduction Rules** 归约规则
- **Context** 上下文
- **Value** 值
- **Type Equivalence** 类型等价

通过深入理解 **Fω <:** 的定义和规则，读者能够更好地掌握高阶类型系统的设计原理，并将其应用于复杂的编程语言设计中。

### ----------------------------

## 31.2 定义（Definitions）

### 类型等价（Type Equivalence）

类型等价关系定义了两种类型在某种意义下是相同的。以下是 **Fω<:** 系统中的类型等价规则：

1. **Q-Refl（反身性）**：
    $$
    \frac{}{\mathbf{T \equiv T}} \quad (\text{Q-Refl})
    $$
    **解释**：任何类型 $T$ 都与其自身等价。这是类型等价关系的反身性（Reflexivity）。

2. **Q-Symm（对称性）**：
    $$
    \frac{T \equiv S}{S \equiv T} \quad (\text{Q-Symm})
    $$
    **解释**：如果类型 $T$ 等价于类型 $S$，那么类型 $S$ 也等价于类型 $T$。这是类型等价关系的对称性（Symmetry）。

3. **Q-Trans（传递性）**：
    $$
    \frac{S \equiv U \quad U \equiv T}{S \equiv T} \quad (\text{Q-Trans})
    $$
    **解释**：如果类型 $S$ 等价于类型 $U$，且类型 $U$ 等价于类型 $T$，那么类型 $S$ 也等价于类型 $T$。这是类型等价关系的传递性（Transitivity）。

4. **Q-Arrow（箭头类型的等价）**：
    $$
    \frac{S_1 \equiv T_1 \quad S_2 \equiv T_2}{S_1 \to S_2 \equiv T_1 \to T_2} \quad (\text{Q-Arrow})
    $$
    **解释**：如果类型 $S_1$ 等价于类型 $T_1$，且类型 $S_2$ 等价于类型 $T_2$，那么函数类型 $S_1 \to S_2$ 等价于 $T_1 \to T_2$。

5. **Q-All（全称类型的等价）**：
    $$
    \frac{S_1 \equiv T_1 \quad S_2 \equiv T_2}{\forall X <: S_1.~S_2 \equiv \forall X <: T_1.~T_2} \quad (\text{Q-All})
    $$
    **解释**：如果类型 $S_1$ 等价于类型 $T_1$，且类型 $S_2$ 等价于类型 $T_2$，那么全称类型 $\forall X <: S_1.~S_2$ 等价于 $\forall X <: T_1.~T_2$。

6. **Q-Abs（类型抽象的等价）**：
    $$
    \frac{S_2 \equiv T_2}{\lambda X::K_1.~S_2 \equiv \lambda X::K_1.~T_2} \quad (\text{Q-Abs})
    $$
    **解释**：如果类型 $S_2$ 等价于类型 $T_2$，那么类型抽象 $\lambda X::K_1.~S_2$ 等价于 $\lambda X::K_1.~T_2$。

7. **Q-App（类型应用的等价）**：
    $$
    \frac{S_1 \equiv T_1 \quad S_2 \equiv T_2}{S_1~S_2 \equiv T_1~T_2} \quad (\text{Q-App})
    $$
    **解释**：如果类型 $S_1$ 等价于类型 $T_1$，且类型 $S_2$ 等价于类型 $T_2$，那么类型应用 $S_1~S_2$ 等价于 $T_1~T_2$。

8. **Q-AppAbs（类型抽象应用的等价）**：
    $$
    \frac{}{\lambda X::K_{11}.~T_{12}~T_2 \equiv [X \mapsto T_2]~T_{12}} \quad (\text{Q-AppAbs})
    $$
    **解释**：类型抽象应用于一个类型时，相当于在类型体中替换绑定的类型变量 $X$ 为具体类型 $T_2$。

### 子类型关系（Subtyping）

子类型关系定义了类型之间的继承关系，允许更具体的类型替代更一般的类型。以下是 **Fω<:** 系统中的子类型规则：

1. **S-Trans（传递性）**：
    $$
    \frac{\Gamma \vdash S <: U \quad \Gamma \vdash U <: T}{\Gamma \vdash S <: T} \quad (\text{S-Trans})
    $$
    **解释**：如果类型 $S$ 是类型 $U$ 的子类型，且类型 $U$ 是类型 $T$ 的子类型，那么类型 $S$ 也是类型 $T$ 的子类型。

2. **S-Top（最大类型）**：
    $$
    \frac{\Gamma \vdash S :: *}{\Gamma \vdash S <: \text{Top}} \quad (\text{S-Top})
    $$
    **解释**：任何类型 $S$，只要其种类为 $*$，都是 $\text{Top}$ 的子类型。

3. **S-Arrow（函数类型的子类型）**：
    $$
    \frac{\Gamma \vdash T_1 <: S_1 \quad \Gamma \vdash S_2 <: T_2}{\Gamma \vdash S_1 \to S_2 <: T_1 \to T_2} \quad (\text{S-Arrow})
    $$
    **解释**：如果类型 $T_1$ 是类型 $S_1$ 的子类型，且类型 $S_2$ 是类型 $T_2$ 的子类型，那么函数类型 $S_1 \to S_2$ 是 $T_1 \to T_2$ 的子类型。

4. **S-TVar（类型变量的子类型）**：
    $$
    \frac{X <: T \in \Gamma \quad \Gamma \vdash U_1 <: T_1}{\Gamma \vdash \forall X <: U_1.~S_2 <: \forall X <: T_1.~T_2} \quad (\text{S-TVar})
    $$
    **解释**：如果类型变量 $X$ 在上下文 $\Gamma$ 中被绑定为 $X <: T$，且类型 $U_1$ 是类型 $T_1$ 的子类型，那么全称类型 $\forall X <: U_1.~S_2$ 是 $\forall X <: T_1.~T_2$ 的子类型。

5. **S-All（全称类型的子类型）**：
    $$
    \frac{\Gamma,~X <: \text{Top}[K_1] \vdash S_2 <: T_2}{\Gamma \vdash \lambda X::K_1.~S_2 <: \lambda X::K_1.~T_2} \quad (\text{S-Abs})
    $$
    **解释**：如果在上下文 $\Gamma$ 中，类型算子 $\lambda X::K_1.~S_2$ 在 $X <: \text{Top}[K_1]$ 绑定后是 $S_2 <: T_2$，则 $\lambda X::K_1.~S_2$ 是 $\lambda X::K_1.~T_2$ 的子类型。

6. **S-App（类型应用的子类型）**：
    $$
    \frac{\Gamma \vdash S_1 <: T_1}{\Gamma \vdash S_1~U <: T_1~U} \quad (\text{S-App})
    $$
    **解释**：如果类型算子 $S_1$ 是类型算子 $T_1$ 的子类型，则类型应用 $S_1~U$ 是 $T_1~U$ 的子类型。

7. **S-Eq（类型等价的子类型）**：
    $$
    \frac{\Gamma \vdash S :: K \quad \Gamma \vdash T :: K \quad S \equiv T}{\Gamma \vdash S <: T} \quad (\text{S-Eq})
    $$
    **解释**：如果类型 $S$ 和类型 $T$ 在种类 $K$ 下是等价的，那么 $S$ 是 $T$ 的子类型。

### 类型判定规则（Typing Rules）

类型判定规则定义了如何为项赋予类型。以下是 **Fω<:** 系统中的类型判定规则：

1. **T-Var（变量）**：
    $$
    \frac{\Gamma \vdash t : T}{\Gamma \vdash x : T} \quad (\text{T-Var})
    $$
    **解释**：如果在上下文 $\Gamma$ 中，变量 $x$ 被绑定为类型 $T$，则变量 $x$ 的类型为 $T$。

2. **T-Abs（函数抽象）**：
    $$
    \frac{\Gamma \vdash t_1 : T_{11} \to T_{12} \quad \Gamma \vdash t_2 : T_{11}}{\Gamma \vdash t_1~t_2 : T_{12}} \quad (\text{T-App})
    $$
    **解释**：如果在上下文 $\Gamma$ 中，函数 $t_1$ 的类型为 $T_{11} \to T_{12}$，且参数 $t_2$ 的类型为 $T_{11}$，则应用 $t_1~t_2$ 的类型为 $T_{12}$。

3. **T-TAbs（类型抽象）**：
    $$
    \frac{\Gamma,~X <: T \vdash t_2 : T_2 \quad \Gamma \vdash t_1 : \forall X <: T_{11}.~T_{12}}{\Gamma \vdash t_1~[T_2] : [X \mapsto T_2]~T_{12}} \quad (\text{T-TApp})
    $$
    **解释**：如果在上下文 $\Gamma$ 中，类型抽象 $t_1$ 的类型为 $\forall X <: T_{11}.~T_{12}$，且类型 $T_2$ 是类型 $T_{11}$ 的子类型，则类型应用 $t_1~[T_2]$ 的类型为在 $T_{12}$ 中将 $X$ 替换为 $T_2$ 后的类型。

4. **T-Sub（子类型规则）**：
    $$
    \frac{\Gamma \vdash t : S \quad \Gamma \vdash S <: T \quad \Gamma \vdash T :: *}{\Gamma \vdash t : T} \quad (\text{T-Sub})
    $$
    **解释**：如果在上下文 $\Gamma$ 中，项 $t$ 的类型为 $S$，且类型 $S$ 是类型 $T$ 的子类型，且类型 $T$ 的种类为 $*$，则项 $t$ 的类型为 $T$。

### 31.2.1 练习（Exercise）[«]

**问题**：如果我们定义 $Id = \lambda X.~X$，并且上下文 $\Gamma = B <: \text{Top}, A <: B, F <: Id$，那么以下哪些子类型关系是可以推导的？

1. $\Gamma \vdash A <: Id~B$
2. $\Gamma \vdash Id~A <: B$
3. $\Gamma \vdash \lambda X.~X <: \lambda X.~\text{Top}$
4. $\Gamma \vdash \lambda X.~\forall Y <: X.~Y <: \lambda X.~\forall Y <: \text{Top}.~Y$
5. $\Gamma \vdash \lambda X.~\forall Y <: X.~Y <: \lambda X.~\forall Y <: X.~X$
6. $\Gamma \vdash F~B <: B$
7. $\Gamma \vdash B <: F~B$
8. $\Gamma \vdash F~B <: F~B$
9. $\Gamma \vdash \forall F <: (\lambda Y.~\text{Top} \to Y).~F~A <: \forall F <: (\lambda Y.~\text{Top} \to Y).~\text{Top} \to B$
10. $\Gamma \vdash \forall F <: (\lambda Y.~\text{Top} \to Y).~F~A <: \forall F <: (\lambda Y.~\text{Top} \to Y).~F~B$
11. $\Gamma \vdash \text{Top}[ * \Rightarrow *] <: \text{Top}[ * \Rightarrow * \Rightarrow *]$

**解答**：

我们逐一分析每个子类型关系是否可以在上下文 $\Gamma = B <: \text{Top}, A <: B, F <: Id$ 下被推导。

#### 1. $\Gamma \vdash A <: Id~B$

- **分析**：
  - 定义 $Id = \lambda X.~X$。
  - $Id~B = (\lambda X.~X)~B = B$。
  - 需要证明 $A <: B$。
  - 上下文中已知 $A <: B$。

- **结论**：可推导。

#### 2. $\Gamma \vdash Id~A <: B$

- **分析**：
  - $Id~A = (\lambda X.~X)~A = A$。
  - 需要证明 $A <: B$。
  - 上下文中已知 $A <: B$。

- **结论**：可推导。

#### 3. $\Gamma \vdash \lambda X.~X <: \lambda X.~\text{Top}$

- **分析**：
  - 使用 **S-Abs** 规则：
    $$
    \frac{\Gamma,~X \vdash S <: T}{\Gamma \vdash \lambda X.~S <: \lambda X.~T} \quad (\text{S-Abs})
    $$
  - 设 $S = X$，$T = \text{Top}$。
  - 需要在上下文 $\Gamma, X <: \text{Top}[K]$ 下证明 $X <: \text{Top}$。
  - 上下文中，$X <: \text{Top}[K] = X <: \text{Top}$。
  - 根据 **S-Top** 规则，任何类型 $S$（这里为 $X$）都可以是 $\text{Top}$ 的子类型，只要其种类为 $*$，而在上下文中已知 $X <: \text{Top}$。

- **结论**：可推导。

#### 4. $\Gamma \vdash \lambda X.~\forall Y <: X.~Y <: \lambda X.~\forall Y <: \text{Top}.~Y$

- **分析**：
  - 使用 **S-Abs** 规则：
    $$
    \frac{\Gamma,~X \vdash S <: T}{\Gamma \vdash \lambda X.~S <: \lambda X.~T} \quad (\text{S-Abs})
    $$
  - 设 $S = \forall Y <: X.~Y$，$T = \forall Y <: \text{Top}.~Y$。
  - 需要在上下文 $\Gamma, X <: \text{Top}$ 下证明 $\forall Y <: X.~Y <: \forall Y <: \text{Top}.~Y$。
  - 使用 **S-All** 规则：
    $$
    \frac{\Gamma,~X <: T_1 \vdash S <: T_2}{\Gamma \vdash \forall X <: T_1.~S <: \forall X <: T_1.~T_2} \quad (\text{S-All})
    $$
  - 设 $T_1 = X$，$S = Y$，$T_2 = Y$。
  - 需要在 $\Gamma, X <: \text{Top}$ 下证明 $Y <: Y$，这显然成立（由 **Q-Refl** 和 **S-Eq**）。

- **结论**：可推导。

#### 5. $\Gamma \vdash \lambda X.~\forall Y <: X.~Y <: \lambda X.~\forall Y <: X.~X$

- **分析**：
  - 使用 **S-Abs** 规则：
    $$
    \frac{\Gamma,~X \vdash S <: T}{\Gamma \vdash \lambda X.~S <: \lambda X.~T} \quad (\text{S-Abs})
    $$
  - 设 $S = \forall Y <: X.~Y$，$T = \forall Y <: X.~X$。
  - 需要在上下文 $\Gamma, X <: \text{Top}$ 下证明 $\forall Y <: X.~Y <: \forall Y <: X.~X$。
  - 使用 **S-All** 规则：
    $$
    \frac{\Gamma,~X <: T_1 \vdash S <: T_2}{\Gamma \vdash \forall X <: T_1.~S <: \forall X <: T_1.~T_2} \quad (\text{S-All})
    $$
  - 设 $T_1 = X$，$S = Y$，$T_2 = X$。
  - 需要在 $\Gamma, X <: \text{Top}$ 下证明 $Y <: X$。
  - 上下文中，$X <: \text{Top}$，且 $Y <: X$ 是通过类型变量绑定 $Y <: X$ 得到的，因此 $Y <: X$ 成立。

- **结论**：可推导。

#### 6. $\Gamma \vdash F~B <: B$

- **分析**：
  - 已知 $F <: Id$。
  - 根据 **S-App** 规则：
    $$
    \frac{\Gamma \vdash F <: Id}{\Gamma \vdash F~B <: Id~B}
    $$
  - $Id~B = (\lambda X.~X)~B = B$。
  - 因此，$F~B <: B$。

- **结论**：可推导。

#### 7. $\Gamma \vdash B <: F~B$

- **分析**：
  - 已知 $F <: Id$，即 $F~U <: Id~U$ 对任意 $U$。
  - $Id~B = B$，因此 $F~B <: B$。
  - 需要证明 $B <: F~B$，但已知 $F~B <: B$，且没有额外信息表明 $B <: F~B$。

- **结论**：不可推导。

#### 8. $\Gamma \vdash F~B <: F~B$

- **分析**：
  - 任意类型总是其自身的子类型（由 **S-Eq** 和 **Q-Refl**）。
  - $F~B \equiv F~B$，因此 $F~B <: F~B$。

- **结论**：可推导。

#### 9. $\Gamma \vdash \forall F <: (\lambda Y.~\text{Top} \to Y).~F~A <: \forall F <: (\lambda Y.~\text{Top} \to Y).~\text{Top} \to B$

- **分析**：
  - 使用 **S-All** 规则：
    $$
    \frac{\Gamma,~F <: (\lambda Y.~\text{Top} \to Y) \vdash F~A <: \text{Top} \to B}{\Gamma \vdash \forall F <: (\lambda Y.~\text{Top} \to Y).~F~A <: \forall F <: (\lambda Y.~\text{Top} \to Y).~\text{Top} \to B}
    $$
  - 需要在上下文 $\Gamma, F <: (\lambda Y.~\text{Top} \to Y)$ 下证明 $F~A <: \text{Top} \to B$。
  - 已知 $F <: Id$，即 $F~A <: Id~A = A$。
  - 需要证明 $A <: \text{Top} \to B$，但上下文中 $A <: B$，且 $B <: \text{Top}$，但无法直接推导 $A <: \text{Top} \to B$。

- **结论**：不可推导。

#### 10. $\Gamma \vdash \forall F <: (\lambda Y.~\text{Top} \to Y).~F~A <: \forall F <: (\lambda Y.~\text{Top} \to Y).~F~B$

- **分析**：
  - 使用 **S-All** 规则：
    $$
    \frac{\Gamma,~F <: (\lambda Y.~\text{Top} \to Y) \vdash F~A <: F~B}{\Gamma \vdash \forall F <: (\lambda Y.~\text{Top} \to Y).~F~A <: \forall F <: (\lambda Y.~\text{Top} \to Y).~F~B}
    $$
  - 需要在上下文 $\Gamma, F <: (\lambda Y.~\text{Top} \to Y)$ 下证明 $F~A <: F~B$。
  - 已知 $A <: B$，且 $F <: Id$。
  - 根据 **S-App**，$F~A <: Id~A = A$，且 $F~B <: Id~B = B$。
  - 因此，$F~A <: A$ 且 $A <: B$，通过 **S-Trans**，$F~A <: B$。
  - 但需要 $F~A <: F~B$，而仅知 $F~A <: B$ 和 $F~B <: B$，无法得出 $F~A <: F~B$。

- **结论**：不可推导。

#### 11. $\Gamma \vdash \text{Top}[ * \Rightarrow *] <: \text{Top}[ * \Rightarrow * \Rightarrow *]$

- **分析**：
  - 根据定义：
    $$
    \text{Top}[K \Rightarrow K'] = \lambda X::K.~\text{Top}[K']
    $$
  - 因此，
    $$
    \text{Top}[ * \Rightarrow *] = \lambda X::* \Rightarrow *.~\text{Top}[*]
    $$
    $$
    \text{Top}[ * \Rightarrow * \Rightarrow *] = \lambda X::* \Rightarrow * \Rightarrow *.~\text{Top}[*]
    $$
  - 使用 **S-Abs** 规则：
    $$
    \frac{\Gamma,~X <: \text{Top}[ * \Rightarrow *] \vdash \text{Top}[ *] <: \text{Top}[ *]}{\Gamma \vdash \lambda X::* \Rightarrow *.~\text{Top}[ *] <: \lambda X::* \Rightarrow * \Rightarrow *.~\text{Top}[ *]} \quad (\text{S-Abs})
    $$
  - 需要在上下文 $\Gamma, X <: \text{Top}[ * \Rightarrow *]$ 下证明 $\text{Top}[ *] <: \text{Top}[ *]$，这显然成立（由 **Q-Refl** 和 **S-Eq**）。

- **结论**：可推导。

### 总结

通过以上分析，我们得出以下结论：

1. 可推导的子类型关系：
    - $\Gamma \vdash A <: Id~B$
    - $\Gamma \vdash Id~A <: B$
    - $\Gamma \vdash \lambda X.~X <: \lambda X.~\text{Top}$
    - $\Gamma \vdash \lambda X.~\forall Y <: X.~Y <: \lambda X.~\forall Y <: \text{Top}.~Y$
    - $\Gamma \vdash \lambda X.~\forall Y <: X.~Y <: \lambda X.~\forall Y <: X.~X$
    - $\Gamma \vdash F~B <: B$
    - $\Gamma \vdash F~B <: F~B$
    - $\Gamma \vdash \text{Top}[ * \Rightarrow *] <: \text{Top}[ * \Rightarrow * \Rightarrow *]$

2. 不可推导的子类型关系：
    - $\Gamma \vdash B <: F~B$
    - $\Gamma \vdash \forall F <: (\lambda Y.~\text{Top} \to Y).~F~A <: \forall F <: (\lambda Y.~\text{Top} \to Y).~\text{Top} \to B$
    - $\Gamma \vdash \forall F <: (\lambda Y.~\text{Top} \to Y).~F~A <: \forall F <: (\lambda Y.~\text{Top} \to Y).~F~B$

通过练习，我们更深入地理解了 **Fω<:** 系统中的类型等价和子类型关系规则，以及如何在特定上下文下应用这些规则进行类型推导。这对于掌握高阶类型系统的设计和应用至关重要。

**关键概念中英对照**：

- **Type Equivalence** 类型等价
- **Reflexivity** 反身性
- **Symmetry** 对称性
- **Transitivity** 传递性
- **Arrow Type** 箭头类型
- **Universal Type** 全称类型
- **Type Abstraction** 类型抽象
- **Type Application** 类型应用
- **Subtyping** 子类型
- **Bounded Quantification** 有界量化
- **Function Type** 函数类型
- **Top Type** 最大类型

通过深入理解这些规则，读者能够更好地掌握 **Fω<:** 系统的类型理论基础，并将其应用于复杂的编程语言设计和类型推导中。

### ---------------------------

## 31.3 性质（Properties）

在 **Fω<:** 系统中，证明其基本性质（如在归约过程中类型保持（Preservation）、进展性（Progress）以及最小类型化（Minimal Typing））的过程，可以参考本章开头提到的文献。这些证明必须处理子类型、有界量化和类型算子各自独立带来的所有问题。此外，当我们尝试定义子类型规则的另一种语法导向（syntax-directed）表示时，会出现一个显著的新复杂性：不仅类型变量规则可以与传递性规则在子类型推导中结合使用（如我们在第 28.3 节所见），类型等价规则（**S-Eq**）也可以与传递性规则结合使用。

### 例子分析

例如，在上下文 $\Gamma = X <: \text{Top}, F <: \lambda Y.~Y$ 中，命题 $\Gamma \vdash F~X <: X$ 是可以被证明的。具体推导过程如下（忽略种类推导）：

1. **S-TVar**：
    - 根据上下文 $F <: \lambda Y.~Y$，以及 $X <: \text{Top}$。
    - 应用 **S-App** 规则：$\Gamma \vdash F~X <: (\lambda Y.~Y)~X$。

2. **S-Eq**：
    - 根据类型等价规则，$\lambda Y.~Y~X \equiv X$。
    - 因此，$\Gamma \vdash (\lambda Y.~Y)~X <: X$。

3. **S-Trans**：
    - 由 **S-App** 和 **S-Eq**，得到 $\Gamma \vdash F~X <: X$。

这个例子展示了类型变量规则（**S-TVar**）、类型应用规则（**S-App**）、类型等价规则（**S-Eq**）以及传递性规则（**S-Trans**）如何协同工作，完成子类型关系的推导。

### 归约与子类型检查的复杂性

此外，注意到我们不能仅通过将所有类型表达式归约到它们的规范形式来解决这种交互问题。因为表达式 $F~A$ 本身并不是一个可归约项（redex），只有在子类型检查过程中，当变量 $F$ 被提升到其上界 $\lambda Y.~Y$ 时，$F~A$ 才成为一个可归约项。因此，解决方案是在子类型检查开始时对类型表达式进行一次规范化（normalize），并在提升操作过程中根据需要重新规范化。

## 31.4 注释（Notes）

**Fω<:** 系统的许多思想源自于 **Cardelli**，尤其是他在 1988 年发表的论文“Structural Subtyping and the Notion of Power Type”。类型算子子类型关系的扩展由 **Cardelli**（1990）和 **Mitchell**（1990a）发展。**Cardelli** 和 **Longo**（1991）通过部分等价关系（partial equivalence relations）给出了一个早期的语义模型。**Compagnoni** 和 **Pierce**（1996）为带有交叉类型的 **Fω<:** 扩展提供了一个模型。**Bruce** 和 **Mitchell**（1992）给出了一个包括递归类型的更强大的模型；**Abadi** 和 **Cardelli**（1996）也有相关模型，适用于他们的对象演算（object calculus），而非 $\lambda$ 演算，作为核心项语言。

子类型关系在类型算子应用时的逐点定义可以推广为允许不同类型算子应用于不同参数的子类型关系（$F~S <: G~T$），前提是我们细化种类系统以跟踪类型算子的极性。我们称一个算子 $F$ 为协变（covariant），如果对于任何 $S <: T$，都有 $F~S <: F~T$；称为逆变（contravariant），如果对于任何 $S <: T$，都有 $F~T <: F~S$。

引入以下两个新的子类型规则以反映这些属性：

1. **协变规则**：
    $$
    \frac{\Gamma \vdash S <: T}{\Gamma \vdash F~S <: F~T} \quad (\text{Covariant})
    $$

2. **逆变规则**：
    $$
    \frac{\Gamma \vdash S <: T}{\Gamma \vdash F~T <: F~S} \quad (\text{Contravariant})
    $$

这样，如果我们有 $F <: G$，且 $G$ 是协变的，那么通过传递性规则，可以得到 $F~S <: G~T$，前提是 $S <: T$。为了使这一切有效，我们还需要：

- 标记类型变量的极性。
- 限制高阶量词仅对具有特定极性的算子进行量化。

**Cardelli**（1990）、**Steffen**（1998）、以及 **Duggan** 和 **Compagnoni**（1999）都考虑了带有极性的 **Fω<:** 版本。

另一个 **Fω<:** 表现形式的可能推广是将无界类型算子 $\lambda X::K_1.~T_2$ 广义化为有界类型算子 $\lambda X<:T_1.~T_2$。这是一个有吸引力的步骤，因为它与我们在形成 **F<:** 时通过将量词推广为有界量词以添加子类型的方式一致。然而，这会显著增加系统的复杂性，因为我们必须将种类系统也广义化为包括类似 $\forall X<:T_1.~K_2$ 这样的种类；这反过来又引入了种类推导和子类型规则之间的相互依赖，需要大量工作来解开这种依赖关系。有关详细内容，请参阅 **Compagnoni** 和 **Goguen**（1997a; 1997b）。

**Fω<:** 系统与依赖类型的扩展也被 **Chen** 和 **Longo**（1996）以及 **Zwanenburg**（1999）研究过。

### 相关文献与进一步阅读

- **Cardelli**, B. (1988a). Structural Subtyping and the Notion of Power Type.
- **Cardelli**, B. (1990). Type Polymorphism.
- **Mitchell**, J. C. (1990a). Subtyping Polymorphism.
- **Cardelli**, B., & **Longo**, E. (1991). A semantic model for structural subtyping.
- **Compagnoni**, G., & **Pierce**, B. C. (1996). A model for higher-order bounded polymorphism.
- **Bruce**, J., & **Mitchell**, J. C. (1992). Recursive types and subtyping.
- **Abadi**, M., & **Cardelli**, B. (1996). Object calculi and their models.
- **Steffen**, M. (1998). Polarities in subtyping.
- **Duggan**, L., & **Compagnoni**, G. (1999). Higher-order subtyping with polarities.

这些文献详细讨论了 **Fω<:** 系统的不同方面，包括其语义模型、交叉类型、递归类型以及极性等特性。

## 总结

本节深入探讨了 **Fω<:** 系统的定义和性质，特别是类型等价和子类型关系的规则。我们通过具体的例子分析了这些规则如何协同工作，完成复杂的子类型关系推导。同时，介绍了 **Fω<:** 系统在学术界的发展历程及其与相关研究的联系。理解这些规则和性质对于掌握高级类型系统的设计和应用至关重要，特别是在构建功能强大的编程语言和类型检查器时。

**关键概念中英对照**：

- **Type Equivalence** 类型等价
- **Reflexivity** 反身性
- **Symmetry** 对称性
- **Transitivity** 传递性
- **Arrow Type** 箭头类型
- **Universal Type** 全称类型
- **Type Abstraction** 类型抽象
- **Type Application** 类型应用
- **Subtyping** 子类型
- **Bounded Quantification** 有界量化
- **Covariant** 协变
- **Contravariant** 逆变
- **Kinding** 种类推导
- **Reduction Rules** 归约规则
- **Context** 上下文

通过对 **Fω<:** 系统的详细解释和分析，读者能够更好地理解高阶类型系统的复杂性及其在编程语言设计中的应用潜力。

### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------
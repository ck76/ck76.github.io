[toc]



## 32 案例研究：纯函数对象（Purely Functional Objects）

我们的最后一个案例研究继续发展存在性对象模型（existential object model）。这个模型在第 24.2 节中简要介绍，展示了如何将存在性包（existential packages）视为简单对象，并比较了这种抽象风格与使用存在性实现更传统的抽象数据类型（abstract data types）的性质。在本章中，我们使用前几章开发的工具（类型算子和高阶子类型，以及本章新增的一个新特性——多态更新（polymorphic update），将在 §32.7 引入）来扩展这些简单的存在性对象，形成一组提供全面面向对象编程（object-oriented programming）灵活性的习语，包括类和继承。

### 32.1 简单对象（Simple Objects）

首先，让我们回顾第 24.2 节中的纯函数计数器（Counter）对象类型：

```plaintext
Counter = {∃X, {state:X, methods:{get:X→Nat, inc:X→X}}};
```

**解释**：

- **存在性类型**（Existential Type）：`Counter` 是一个存在性类型，表示存在某种类型 `X`，使得包（package）包含一个 `state` 字段，其类型为 `X`，以及一个 `methods` 字段，其类型为一个记录（record），包含两个方法：
  - `get` 方法：类型为 `X→Nat`，即接受一个 `X` 类型的参数并返回一个自然数（`Nat`）。
  - `inc` 方法：类型为 `X→X`，即接受一个 `X` 类型的参数并返回一个新的 `X` 类型。

这些类型的元素是封装了隐藏状态类型 `X`、状态值和方法记录的包。

在本章的前几节中，我们将使用类型 `{x:Nat}` 作为所有对象的表示类型（representation type）。在 §32.8 中，我们将学习如何定义具有多个实例变量的对象，以及添加新实例变量的类。我们将始终使用缩写 `CounterR` 来表示内部状态类型。

```plaintext
CounterR = {x:Nat};
```

**解释**：

- `CounterR` 是一个记录类型，包含一个字段 `x`，其类型为自然数（`Nat`）。这是 `Counter` 对象的具体表示类型。

一个计数器对象是 `Counter` 类型的一个元素，根据存在性引入规则（`T-Pack`，见图 24-1）定义。以下是一个具体的计数器对象示例：

```plaintext
c = {*CounterR,
    {state = {x=5},
     methods = {get = λr:CounterR. r.x,
               inc = λr:CounterR. {x=succ(r.x)}}}} as Counter;
```

**解释**：

- **包（Package）**：`c` 是一个包，包含两个部分：
  - `state`：值为 `{x=5}`，类型为 `CounterR`。
  - `methods`：一个记录，包含两个方法：
    - `get` 方法：接受一个 `CounterR` 类型的参数 `r`，返回 `r.x`，即当前计数值。
    - `inc` 方法：接受一个 `CounterR` 类型的参数 `r`，返回一个新的记录 `{x=succ(r.x)}`，即计数值加一。

- **类型注解**：`as Counter` 表示 `c` 的类型为 `Counter`。

**方法调用**：

调用计数器对象的方法涉及解包、选择方法字段并将其应用于状态。例如，定义一个获取方法的函数 `sendget`：

```plaintext
sendget = λc:Counter.
    let {X, body} = c in
    body.methods.get(body.state);
```

**解释**：

- `sendget` 是一个函数，接受一个 `Counter` 类型的对象 `c`。
- 使用 `let` 表达式解包 `c`，提取隐藏类型 `X` 和主体 `body`。
- 调用 `body.methods.get` 方法，并将 `body.state` 作为参数传递，返回当前计数值。

类似地，定义一个递增方法的函数 `sendinc`：

```plaintext
sendinc = λc:Counter.
    let {X, body} = c in
    {*X,
    {state = body.methods.inc(body.state),
     methods = body.methods}} as Counter;
```

**解释**：

- `sendinc` 是一个函数，接受一个 `Counter` 类型的对象 `c`。
- 使用 `let` 表达式解包 `c`，提取隐藏类型 `X` 和主体 `body`。
- 调用 `body.methods.inc` 方法，并将 `body.state` 作为参数传递，得到新的状态。
- 构造一个新的包，保持相同的 `methods` 字段，更新 `state` 字段为新的状态 `{x=succ(r.x)}`。
- 使用 `as Counter` 进行类型注解，表示新包的类型为 `Counter`。

构建更复杂的操作，例如将计数器递增三次：

```plaintext
addthree = λc:Counter. sendinc (sendinc (sendinc c));
```

**解释**：

- `addthree` 是一个函数，接受一个 `Counter` 类型的对象 `c`，并连续调用 `sendinc` 方法三次，返回最终的计数器对象。

### 32.2 子类型（Subtyping）

存在性编码对象的一个令人愉快的特点是，我们期望的对象类型之间的子类型包含关系可以直接从存在性和记录的子类型规则中得出。为了验证这一点，让我们回顾第 26.3 节中的存在性类型的子类型规则：

```plaintext
Γ , X<:U ` S2 <: T2
Γ ` {∃X<:U,S2} <: {∃X<:U,T2}
(S-Some)
```

**解释**：

- **S-Some 规则**：如果在上下文 `Γ` 中，类型 `S2` 是类型 `T2` 的子类型（在类型变量 `X` 被绑定为 `X <: U` 的上下文下），那么存在性类型 `{∃X<:U, S2}` 是 `{∃X<:U, T2}` 的子类型。

基于此规则，如果我们定义一个具有比 `Counter` 更多方法的对象类型，例如：

```plaintext
ResetCounter = {∃X, {state:X, methods:{get:X→Nat, inc:X→X, reset:X→X}}};
```

**解释**：

- `ResetCounter` 是一个存在性类型，表示存在某种类型 `X`，包含 `state` 字段和 `methods` 字段，其中 `methods` 字段除了 `get` 和 `inc` 方法外，还新增了一个 `reset` 方法。

根据 **S-Some** 规则，`ResetCounter` 将是 `Counter` 的子类型，即：

```plaintext
ResetCounter <: Counter
```

**实例**：

定义一个重置计数器对象 `rc`：

```plaintext
rc = {*CounterR,
    {state = {x=0},
     methods = {get = λr:CounterR. r.x,
               inc = λr:CounterR. {x=succ(r.x)},
               reset = λr:CounterR. {x=0}}}} as ResetCounter;
```

**解释**：

- `rc` 是一个包，包含隐藏类型 `CounterR`，状态 `{x=0}`，以及 `get`、`inc` 和 `reset` 三个方法。
- `rc` 的类型为 `ResetCounter`。

由于 `ResetCounter <: Counter`，我们可以使用**子类型包含**（subsumption）将 `rc` 传递给接受 `Counter` 类型的函数，例如 `sendget`、`sendinc` 和 `addthree`：

```plaintext
rc3 = addthree rc;
```

**解释**：

- `addthree` 函数接受一个 `Counter` 类型的对象。
- 由于 `ResetCounter` 是 `Counter` 的子类型，`rc` 可以被传递给 `addthree`，返回的 `rc3` 类型为 `Counter`。

**注意**：

尽管 `rc3` 是一个 `Counter` 类型的对象，但它实际包含 `reset` 方法。然而，由于 `rc3` 的类型被限定为 `Counter`，我们失去了对 `reset` 方法的类型信息。

### 32.3 有界量化（Bounded Quantification）

子类型包含导致的信息丢失问题正是引入有界量化的动机所在（详见第 26 章）。有界量化本身并不足够——为了有效解决上述问题，还需要一些额外的机制。

**问题分析**：

观察一下，我们希望对 `sendinc` 函数进行有界量化的显然改进：

```plaintext
sendinc : ∀C<:Counter. C → C
```

**解释**：

- `sendinc` 函数被赋予一个多态类型，适用于所有 `C` 类型，只要 `C` 是 `Counter` 的子类型。
- 这样，`addthree` 可以被定义为：

```plaintext
addthree = λC<:Counter. λc:C.
    sendinc [C] (sendinc [C] (sendinc [C] c));
```

- 调用 `addthree` 时，可以具体化为 `ResetCounter` 类型：

```plaintext
rc3 = addthree [ResetCounter] rc;
```

**问题**：

然而，没有办法编写这样一个函数——或更确切地说，没有办法编写一个既符合预期行为又具有这种类型的函数。我们可以编写一个属于这个类型的恒等函数：

```plaintext
wrongsendinc = λC<:Counter. λc:C. c;
```

但如果尝试通过在前面添加有界类型抽象来精化 `sendinc` 的实际实现，将无法通过类型检查：

```plaintext
sendinc =
    λC<:Counter. λc:C.
        let {X, body} = c in
        {*X,
         {state = body.methods.inc(body.state),
          methods = body.methods}}
        as C;
```

**解释**：

- 最后一行 `as C` 告诉类型检查器“使用存在性类型 `C` 来表示被创建的包”。
- 但 `C` 并不是一个存在性类型，而是一个类型变量。这会导致类型检查错误，因为包 `{*X, {state = body.methods.inc(body.state), methods = body.methods}}` 并不具备 `C` 类型所需的所有字段（例如，如果 `C` 是 `{∃X, {state:X, methods:{get:X→Nat, inc:X→X, reset:X→X}}}`，那么它缺少 `reset` 方法）。

**根本问题**：

- 现有的子类型和存在性规则无法识别任何 `C <: Counter` 类型都是存在性类型。
- 即便 `C` 是 `Counter` 的子类型，包的实际结构可能不满足 `C` 的完整定义。

**解决方案**：

需要引入一些机制，使类型检查器能够正确处理多态更新，并确保在子类型上下文中保持类型信息。

**具体方法**：

1. **引入 Fω<: 系统**：使用高阶有界量化（higher-order bounded quantification）来更精细地控制子类型关系。
2. **多态更新（Polymorphic Update）**：引入一个新的原语，使得可以在类型安全的情况下更新记录中的字段。

通过结合这两种方法，我们可以解决信息丢失的问题，实现灵活且类型安全的纯函数对象。

### 32.4 高阶有界量化与多态更新

本节将讨论如何使用高阶有界量化和多态更新来扩展存在性对象模型，使其具备面向对象编程的灵活性，包括类和继承。

**高阶有界量化（Higher-Order Bounded Quantification）**：

- 允许类型参数本身是类型算子，进一步增强了类型系统的表达能力。
- 在子类型关系中，高阶有界量化允许更复杂的子类型推导，确保类型安全。

**多态更新（Polymorphic Update）**：

- 允许在保持类型信息的同时，更新记录中的字段。
- 通过引入新的类型更新机制，可以在多态上下文中安全地修改对象的状态。

### 32.5 类与继承（Classes and Inheritance）

在本节中，我们将展示如何使用前面介绍的工具（高阶子类型、类型算子和多态更新）来实现类和继承的概念。

**类（Classes）**：

- 类可以被视为带有多个实例变量和方法的类型算子。
- 继承通过子类型关系实现，允许子类继承和扩展父类的属性和方法。

**继承（Inheritance）**：

- 子类继承父类的所有实例变量和方法，并可以新增或覆盖某些方法。
- 通过子类型关系，子类对象可以被视为父类对象，支持多态性。

### 32.6 实例与应用（Instances and Applications）

在这一部分，我们将讨论如何实例化类，并如何在实际应用中使用这些实例对象。

**实例化类**：

- 创建类的实例对象时，具体化类型算子的参数，生成包含具体实例变量和方法的对象。
- 使用多态更新机制，可以在保持类型安全的前提下，修改实例变量的状态。

**方法调用**：

- 方法调用通过解包对象，选择方法字段，并将当前状态作为参数传递给方法。
- 通过类型算子和高阶子类型关系，确保方法调用的类型安全。

### 32.7 多态更新（Polymorphic Update）

本节将详细介绍多态更新机制，以及如何在 **Fω<:** 系统中实现这一功能。

**多态更新的定义**：

- 多态更新允许在多态上下文中，安全地更新记录中的字段，同时保持类型信息的正确性。
- 引入新的语法和规则，确保更新操作符合类型系统的子类型关系和有界量化规则。

**实现方法**：

1. **类型算子扩展**：在类型算子中加入更新操作的支持。
2. **子类型规则调整**：调整子类型规则，使其能够处理更新后的类型推导。
3. **类型检查机制**：在类型检查过程中，确保更新操作的类型安全性和正确性。

### 32.8 多实例变量与类的扩展（Multiple Instance Variables and Class Extensions）

在这一部分，我们将展示如何定义具有多个实例变量的对象，以及如何通过类扩展机制，向现有类中添加新的实例变量和方法。

**多实例变量对象**：

- 对象可以包含多个实例变量，每个变量都有自己的类型和作用域。
- 通过多态更新和高阶子类型关系，确保多实例变量对象的类型安全性。

**类扩展**：

- 允许在子类中添加新的实例变量和方法，扩展父类的功能。
- 通过子类型关系，子类对象可以被视为父类对象，同时保留新增的功能。

### 总结

本章通过案例研究展示了如何在 **Fω<:** 系统中实现纯函数对象，扩展存在性对象模型，加入类型算子和高阶子类型关系，最终实现面向对象编程的灵活性。通过引入多态更新和高阶有界量化，我们解决了存在性子类型关系带来的信息丢失问题，实现了类型安全且灵活的对象操作。

**关键概念中英对照**：

- **Existential Type** 存在性类型
- **Type Operator** 类型算子
- **Subtyping** 子类型
- **Bounded Quantification** 有界量化
- **Higher-Order Subtyping** 高阶子类型
- **Polymorphic Update** 多态更新
- **Classes** 类
- **Inheritance** 继承
- **Method Invocation** 方法调用
- **Type Equivalence** 类型等价
- **Package** 包

通过深入理解这些概念和机制，读者能够掌握如何在高级类型系统中实现功能强大的面向对象编程模型，并将其应用于实际的编程语言设计和开发中。

### ---------------------------

## 32.4 接口类型（Interface Types）

### 使用类型算子表达 Counter 和 Object

在 **Fω<:** 系统中，我们可以使用类型算子（type operators）将 `Counter` 表达为两个部分的组合：

```plaintext
Counter = Object CounterM;
```

其中，

```plaintext
CounterM = λR. {get: R → Nat, inc: R → R};
```

是一个种类为 $* \Rightarrow *$ 的类型算子，表示计数器对象的具体方法接口（method interface）。

```plaintext
Object = λM::*⇒*. {∃X, {state: X, methods: M X}};
```

是一个种类为 $( * \Rightarrow *) \Rightarrow *$ 的类型算子，捕捉所有对象类型的通用结构。通过这种重新构造，我们实现了将变化部分（方法接口）与固定骨架（存在性封装和状态与方法的配对）分离开来。这种分离的好处在于，允许我们在变化部分（方法接口）上进行子类型化，而不会影响固定部分（对象的封装结构）。

### 类型算子拆分的好处

这种重构的主要好处是将对象类型的变化部分（方法接口）与固定的对象结构（状态和方法的封装）分离开来。具体来说：

- **变化部分（Varying Part）**：方法接口 `CounterM`，允许子类型化。
- **固定骨架（Fixed Skeleton）**：存在性封装 `{∃X, {state: X, methods: M X}}`，不允许子类型化，以避免重包装时出现问题。

### 使用有界量化分离方法接口

为了实现这种拆分，我们需要在类型算子上进行有界量化（bounded quantification）。这允许我们从对象类型中提取方法接口，即使接口中提到了存在性绑定的状态类型 `X`，通过对方法接口本身进行抽象（abstraction）使其成为一个“参数化的参数”（parametric parameter）。这种参数化的参数的迭代特性反映在 `Object` 的种类以及应用 `Object CounterM` 的简化步骤中：

```plaintext
Object CounterM = {∃X, {state: X, methods: (CounterM X)}}
              = {∃X, {state: X, methods: {get: X → Nat, inc: X → X}}}
```

### 类型算子的子类型关系

如果我们以相同的方式拆分 `ResetCounter` 类型：

```plaintext
ResetCounterM = λR. {get: R → Nat, inc: R → R, reset: R → R};
ResetCounter = Object ResetCounterM;
```

则不仅有：

```plaintext
ResetCounter <: Counter
```

如前所述，还可以得到：

```plaintext
ResetCounterM <: CounterM
```

这是基于之前定义的类型算子子类型规则。这种拆分使得接口子类型化（interface subtyping）具有意义，并且独立于完整对象类型之间的子类型关系。

### 接口子类型化的相关工作

接口子类型化在概念上和技术上与 **Bruce** 等人（1997）提出的匹配（matching）概念密切相关，并由 **Abadi** 和 **Cardelli**（1995; 1996）进一步研究。

---

## 32.5 向对象发送消息（Sending Messages to Objects）

### 修复 sendinc 函数

在 §32.3 中，我们发现了 `sendinc` 函数类型不匹配的问题。现在，通过抽象化对 `CounterM` 子接口的子类型，而不是 `Counter` 子类型，我们可以修复这个问题。具体实现如下：

```plaintext
sendinc =
λM<:CounterM. λc:Object M.
    let {X, b} = c in
    {*X,
    {state = b.methods.inc(b.state),
     methods = b.methods}}
    as Object M;
```

**类型注解**：

```plaintext
sendinc : ∀M<:CounterM. Object M → Object M
```

**解释**：

- `sendinc` 是一个多态函数，接受一个子接口 `M`，类型为 `CounterM` 的对象 `c`，并返回一个具有相同接口 `M` 的新对象。
- 使用有界量化 `∀M<:CounterM`，确保 `M` 是 `CounterM` 的子类型。
- 通过 `let` 表达式解包对象 `c`，提取隐藏类型 `X` 和主体 `b`。
- 创建一个新的包 `{*X, {state = b.methods.inc(b.state), methods = b.methods}}`，其中状态被更新为 `b.methods.inc(b.state)`，方法保持不变。
- 使用 `as Object M` 进行类型注解，表示新包的类型为 `Object M`。

### 类型注解的直观理解

`sendinc` 的类型可以直观地理解为：“给我一个细化了 `CounterM` 接口的对象，然后我会返回一个具有相同接口的对象。”

### 32.5.1 练习（Exercise [«]）

**问题**：为什么这个 `sendinc` 是类型正确的，而之前的版本不是？

**解答**：

之前的 `sendinc` 函数尝试将类型变量 `C` 直接用于封装类型，但 `C` 不是一个存在性类型，导致类型检查失败。具体原因如下：

1. **原始版本的问题**：

    ```plaintext
    sendinc =
    λC<:Counter. λc:C.
        let {X, body} = c in
        {*X,
         {state = body.methods.inc(body.state),
          methods = body.methods}}
        as C;
    ```

    - 最后一行 `as C` 尝试将包 `{*X, {state = body.methods.inc(body.state), methods = body.methods}}` 注解为类型 `C`。
    - 但是 `C` 是一个类型变量，并不是一个存在性类型 `{∃X, {state: X, methods: M X}}`。
    - 如果 `C` 是一个具有更多方法的子类型，例如 `ResetCounter`，上述注解会缺少额外的方法（如 `reset`），导致类型不匹配。

2. **修正后的版本的优势**：

    ```plaintext
    sendinc =
    λM<:CounterM. λc:Object M.
        let {X, b} = c in
        {*X,
        {state = b.methods.inc(b.state),
         methods = b.methods}}
        as Object M;
    ```

    - 通过使用类型算子 `M<:CounterM`，确保 `M` 只是方法接口，不涉及存在性封装。
    - `Object M` 保证了封装结构的一致性，避免了直接使用类型变量带来的问题。
    - 这样，`sendinc` 返回的对象类型与输入对象类型一致，确保类型安全。

---

### 调用计数器和重置计数器对象的方法

为了调用 `Counter` 和 `ResetCounter` 对象的方法，我们需要实例化多态方法调用函数，并使用适当的接口签名 `CounterM` 或 `ResetCounterM`。假设 `sendget` 和 `sendreset` 已经类似地定义，具体调用如下：

```plaintext
sendget [CounterM] (sendinc [CounterM] c);
```

**解释**：

- 调用 `sendinc` 函数，传入接口 `CounterM` 和对象 `c`。
- 然后调用 `sendget` 函数，传入接口 `CounterM` 和更新后的对象。
- 返回值类型为 `Nat`。

```plaintext
sendget [ResetCounterM] (sendreset [ResetCounterM] (sendinc [ResetCounterM] rc));
```

**解释**：

- 类似地，调用 `sendinc` 和 `sendreset` 函数，传入接口 `ResetCounterM` 和对象 `rc`。
- 返回值类型为 `Nat`。

---

### 32.5.2 练习（Exercise [Recommended, ««]）

**问题**：定义 `sendget` 和 `sendreset`。

**解答**：

根据 `sendinc` 的定义模式，我们可以定义 `sendget` 和 `sendreset` 函数如下：

#### 定义 `sendget`

```plaintext
sendget =
λM<:CounterM. λc:Object M.
    let {X, b} = c in
    b.methods.get(b.state);
```

**类型注解**：

```plaintext
sendget : ∀M<:CounterM. Object M → Nat
```

**解释**：

- `sendget` 是一个多态函数，接受一个子接口 `M` 和一个类型为 `Object M` 的对象 `c`。
- 通过 `let` 表达式解包对象 `c`，提取隐藏类型 `X` 和主体 `b`。
- 调用 `b.methods.get` 方法，并将 `b.state` 作为参数传递，返回当前计数值。

#### 定义 `sendreset`

```plaintext
sendreset =
λM<:CounterM. λc:Object M.
    let {X, b} = c in
    {*X,
    {state = b.methods.reset(b.state),
     methods = b.methods}}
    as Object M;
```

**类型注解**：

```plaintext
sendreset : ∀M<:CounterM. Object M → Object M
```

**解释**：

- `sendreset` 是一个多态函数，接受一个子接口 `M` 和一个类型为 `Object M` 的对象 `c`。
- 通过 `let` 表达式解包对象 `c`，提取隐藏类型 `X` 和主体 `b`。
- 调用 `b.methods.reset` 方法，并将 `b.state` 作为参数传递，得到新的状态 `{x=0}`。
- 构造一个新的包，保持相同的 `methods` 字段，更新 `state` 字段为新的状态 `{x=0}`。
- 使用 `as Object M` 进行类型注解，表示新包的类型为 `Object M`。

---

## 32.6 简单类（Simple Classes）

### 类的定义

现在让我们考虑类（classes），与第 18 章一样，首先从没有自引用（self）的简单类开始。

在第 18.6 节中，我们定义了一个简单的类（用于命令式对象编码，其中对象是方法的记录），将类定义为从状态到对象的函数。这是一种制造具有相同方法但每个对象具有新分配的实例变量的多对象的方法。在本章中，对象不仅仅是方法的记录：它还包括一个表示类型和状态。然而，由于这是一个纯函数模型，每个方法都将状态作为参数传递（如果需要，返回一个具有更新状态的对象），因此我们不需要在对象创建时将状态传递给类。事实上，这里类的定义——假设我们仍然假设所有对象使用相同的表示类型——可以被视为一个简单的方法记录。

### 类的示例定义

定义一个简单的计数器类 `counterClass`：

```plaintext
counterClass =
{get = λr:CounterR. r.x,
 inc = λr:CounterR. {x=succ(r.x)}}
as {get: CounterR → Nat, inc: CounterR → CounterR};
```

**类型注解**：

```plaintext
counterClass : {get: CounterR → Nat, inc: CounterR → CounterR}
```

或者，使用 `CounterM` 类型算子更简洁地表示：

```plaintext
counterClass =
{get = λr:CounterR. r.x,
 inc = λr:CounterR. {x=succ(r.x)}}
as CounterM CounterR;
```

**类型注解**：

```plaintext
counterClass : CounterM CounterR
```

**解释**：

- `counterClass` 是一个记录，包含两个方法：
  - `get` 方法：接受一个 `CounterR` 类型的参数 `r`，返回 `r.x`。
  - `inc` 方法：接受一个 `CounterR` 类型的参数 `r`，返回一个新的记录 `{x=succ(r.x)}`，即计数值加一。
- 使用 `as` 进行类型注解，确保 `counterClass` 的类型符合方法接口 `CounterM` 和表示类型 `CounterR`。

### 创建类的实例对象

通过提供初始状态值，并将其与方法（即类）打包到一个对象中，我们可以构建类的实例对象。例如，创建一个计数器对象 `c`：

```plaintext
c = {*CounterR,
    {state = {x=0},
     methods = counterClass}}
as Counter;
```

**类型注解**：

```plaintext
c : Counter
```

**解释**：

- 创建一个包 `{*CounterR, {state = {x=0}, methods = counterClass}}`。
- `state` 字段初始化为 `{x=0}`，类型为 `CounterR`。
- `methods` 字段为 `counterClass`，包含 `get` 和 `inc` 方法。
- 使用 `as Counter` 进行类型注解，表示 `c` 的类型为 `Counter`。

### 子类的定义

定义一个子类 `ResetCounter`，通过复制现有类的某些方法，并添加新的方法：

```plaintext
resetCounterClass =
let super = counterClass in
{get = super.get,
 inc = super.inc,
 reset = λr:CounterR. {x=0}}
as ResetCounterM CounterR;
```

**类型注解**：

```plaintext
resetCounterClass : ResetCounterM CounterR
```

**解释**：

- 使用 `let` 表达式将 `counterClass` 赋值给 `super`。
- 创建一个新的记录，复制 `super` 的 `get` 和 `inc` 方法，并新增 `reset` 方法。
- `reset` 方法接受一个 `CounterR` 类型的参数 `r`，返回一个新的记录 `{x=0}`，即将计数器重置为 0。
- 使用 `as ResetCounterM CounterR` 进行类型注解，表示 `resetCounterClass` 的类型为 `ResetCounterM CounterR`。

### 类和继承的概念

通过上述方式定义类和子类，我们能够：

- **创建类的实例**：通过提供初始状态并打包方法，创建对象实例。
- **定义子类**：通过复制父类的方法并添加新方法，扩展类的功能。
- **实现继承**：子类对象不仅具有父类的方法，还具有新增的方法，支持多态性和代码重用。

### 类的扩展需求

为了处理更复杂的示例，如添加新的实例变量和处理 `self`，我们需要：

1. **添加新的实例变量**：定义具有多个实例变量的对象。
2. **处理 `self`**：在方法中引用自身，以支持更复杂的对象行为。

这些将在后续章节中详细介绍。

---

## 总结

本节通过案例研究展示了如何在 **Fω<:** 系统中实现纯函数对象，扩展存在性对象模型，并引入类型算子和高阶子类型关系。通过定义接口类型、发送消息、以及简单类的创建与继承，我们实现了面向对象编程的基本概念，同时保持了类型系统的严谨性和灵活性。

### 关键概念中英对照

- **Type Operator** 类型算子
- **Existential Type** 存在性类型
- **Subtyping** 子类型
- **Bounded Quantification** 有界量化
- **Higher-Order Subtyping** 高阶子类型
- **Polymorphic Update** 多态更新
- **Classes** 类
- **Inheritance** 继承
- **Method Invocation** 方法调用
- **Interface Subtyping** 接口子类型化
- **Package** 包

通过深入理解这些概念和机制，读者能够掌握如何在高级类型系统中实现功能强大的面向对象编程模型，并将其应用于实际的编程语言设计和开发中。

### ----------------------------

## 32.7 多态更新（Polymorphic Update）

### 引言

为了向类中添加实例变量（instance variables），我们需要引入一个新机制——**记录字段的原地多态更新原语**（a primitive for in-place polymorphic update of record fields）以及对记录类型的相关细化（an associated refinement to record types）。这些特性的需求来源于以下事实：允许类之间实例变量的变化意味着需要使超类（superclasses）在其子类（subclasses）的实例变量上具有多态性。让我们详细探讨这一过程。

### 实例变量的添加与技术难题

假设我们想定义 `resetCounterClass` 的一个子类，添加一个备份方法（backup method），用于保存当前计数器的值，并修改 `reset` 方法的行为，使其恢复到这个保存的值而不是一个固定的初始值。为了保存这个值，我们需要将状态类型从 `{x:Nat}` 扩展到 `{x:Nat, old:Nat}`。这种表示的差异立即带来了一个技术难题：在定义 `backupCounterClass` 时，重新使用 `resetCounterClass` 的 `inc` 方法依赖于该方法在两个类中表现一致。然而，如果实例变量的集合不同，`inc` 方法的行为就不完全相同：

- `ResetCounter` 的 `inc` 方法期望状态类型为 `{x:Nat}`，并返回相同类型的新状态。
- `BackupCounter` 的 `inc` 方法期望和返回的状态类型为 `{x:Nat, old:Nat}`。

### 统一方法接口

为了解决这个问题，我们观察到 `inc` 方法实际上不需要知道状态类型是 `{x:Nat}` 还是 `{x:Nat, old:Nat}`，它只需要知道状态中包含一个实例变量 `x`。换句话说，我们可以通过给这两个方法赋予相同的类型 $\forall S <: \{x:Nat\}. S \to S$ 来统一它们。这意味着：

- **方法接口统一**：`inc` 方法的类型为 $\forall S <: \{x:Nat\}. S \to S$，表示对于任何包含 `x:Nat` 的状态类型 `S`，`inc` 方法接受并返回该类型的状态。

然而，在当前的 **Fω<:** 系统中，类型 $\forall S <: \{x:Nat\}. S \to S$ 在纯 **F<:** 中仅由恒等函数（identity function）所拥有。这表明，我们需要一种机制，允许更精确的有界量化，以实现多态更新。

### 引入多态更新原语

为了解决上述问题，我们引入一个新的原语——**记录字段的多态更新**（polymorphic update of record fields）。具体来说：

- **记录更新原语**（Record Update Primitive）：如果 `r` 是一个具有字段 `x` 的记录，且 `t` 是类型为 `T` 的项，则我们用 `r ← x = t` 表示“一个与 `r` 相同但 `x` 字段值为 `t` 的记录”。注意，这是一个纯函数式的更新操作——它不会改变 `r`，而是生成一个新的记录。

使用这个更新原语，我们可以编写一个符合预期行为的 `inc` 方法：

```plaintext
f = λX<:{a:Nat}. λr:X. r ← a = succ(r.a);
```

**解释**：

- `f` 是一个多态函数，接受一个类型参数 `X`，其上界为 `{a:Nat}`。
- 函数体接受一个记录 `r`，其类型为 `X`，并返回一个新的记录，`a` 字段的值增加一。

### 更新原语的类型规则与安全性

然而，直接为更新操作定义如下类型规则是不安全的：

$$
\frac{\Gamma \vdash r : R \quad \Gamma \vdash R <: \{l_j : T_j\} \quad \Gamma \vdash t : T_j}{\Gamma \vdash r \leftarrow l_j = t : R}
$$

**解释**：

- 如果在上下文 $\Gamma$ 中，记录 `r` 的类型为 `R`，且 `R` 是包含字段 `l_j : T_j` 的记录类型的子类型，并且 `t` 的类型为 `T_j`，则 `r ← l_j = t` 的类型为 `R`。

**问题示例**：

考虑以下记录：

```plaintext
s = {x = {a = 5, b = 6}, y = true};
```

- 类型为 `{x: {a:Nat, b:Nat}, y:Bool}`。
- 根据深度子类型化（depth subtyping），我们有 `{x: {a:Nat, b:Nat}, y:Bool} <: {x: {a:Nat}}`。

使用上述更新规则，我们可以推导出：

```plaintext
s ← x = {a = 8} : {x: {a:Nat, b:Nat}, y:Bool}
```

**错误解释**：

- 实际上，`s ← x = {a = 8}` 应该生成 `{x = {a = 8}, y = true}`，但根据类型规则，它被认为是 `{x: {a:Nat, b:Nat}, y:Bool}`，这是错误的，因为缺少 `b` 字段。

### 解决方案：标记可更新字段

这个问题的根源在于允许深度子类型化（depth subtyping）在可能被更新的字段上。为了解决这个问题，我们引入了一种简单的方法——**标记可更新字段**（marking updatable fields）。具体做法如下：

- **记录类型标注**（Record Type Annotation）：记录类型中的每个字段都被标注了一个方差标签，指示是否允许该字段的子类型化。
  - 使用 `#` 标记字段，以禁止该字段的子类型化。
  - 未标记的字段则允许子类型化。

- **深度子类型化规则的修正**（Refining the Depth Subtyping Rule）：在进行深度子类型化时，只允许未标记字段进行子类型化。

- **字段方差规则**（Field Variance Rules）：允许字段标记从 `#` 改为未标记，以“忘记”字段是可更新的。

- **更新操作的类型规则**（Typing Rules for Update Operation）：更新操作要求被更新的字段必须被标记 `#`。

- **更新操作的归约规则**（Reduction Rules for Update Operation）：实现记录更新的具体操作。

#### 32.7.1 事实（Fact）

**事实**：如果 $\Gamma \vdash R <: \{#l: T_1\}$，那么 $R = \{\ldots #l: R_1 \ldots\}$ 且 $\Gamma \vdash R_1 <: T_1$ 且 $\Gamma \vdash T_1 <: R_1$。

**解释**：

- 这意味着，如果记录类型 `R` 是 `{#l: T_1}` 的子类型，那么 `R` 必须包含一个标记 `#` 的字段 `l`，其类型 `R_1` 必须与 `T_1` 互为子类型。

### 32.7.2 练习（Exercise [Recommended, «««]）

**问题**：这个演算是否满足最小类型化性质（minimal typing property）？如果满足，请证明；如果不满足，请找到修复方法。

**解答**：

#### 最小类型化性质（Minimal Typing Property）

**定义**：

最小类型化性质（minimal typing property）要求，对于每一个项 `t`，存在一个最小类型 `T`，使得 $\Gamma \vdash t : T$，并且对于任意类型 `T'`，如果 $\Gamma \vdash t : T'$，则 $T \leq T'$。

**问题分析**：

在引入多态更新后，类型系统需要确保每次记录更新操作都不会违反类型安全性。具体来说，记录更新操作只能在标记为不可子类型化的字段上进行，以防止类型信息丢失。

然而，由于引入了标记和对更新操作的严格限制，类型系统在某些情况下可能无法找到一个最小类型。例如，考虑以下情形：

```plaintext
f = λX<:{#a:Nat}. λr:X. r ← a = succ(r.a);
```

**类型注解**：

```plaintext
f : ∀X<:{#a:Nat}. X → X
```

此函数试图对记录的 `a` 字段进行更新，并返回一个具有相同接口的记录。由于字段 `a` 被标记为 `#`，类型系统确保只有标记字段可以被更新，但这限制了类型推导的灵活性，可能导致无法为某些项找到最小类型。

#### 结论

**最小类型化性质不满足**。具体原因在于记录更新操作的类型规则过于严格，限制了类型系统的灵活性，导致在某些情况下无法为项找到最小类型。

#### 修复方法

为了解决最小类型化性质不满足的问题，我们需要调整类型规则，确保类型系统能够在记录更新操作中正确地推导出最小类型。具体方法如下：

1. **增强类型推导规则**：

   修改记录更新操作的类型规则，使其能够识别和处理标记字段，确保只有标记为 `#` 的字段可以被更新，同时保持类型推导的最小性。

2. **引入更精细的标记机制**：

   通过更细粒度的标记机制，区分不同字段的可更新性，避免过度限制类型推导。

3. **扩展有界量化**：

   引入更强大的有界量化机制，允许类型系统在多态更新操作中更灵活地推导类型，确保最小类型化性质的满足。

4. **类型推导算法调整**：

   调整类型推导算法，使其能够在标记字段和更新操作之间建立更准确的关系，确保类型推导的正确性和最小性。

通过以上方法，可以修复最小类型化性质不满足的问题，确保类型系统在处理多态更新操作时既保持类型安全性，又满足最小类型化性质。

---

## 总结

本节介绍了**多态更新**（Polymorphic Update）的概念及其在 **Fω<:** 系统中的实现。通过引入记录字段的多态更新原语和标记机制，我们解决了在添加实例变量时由于子类型关系导致的信息丢失问题。同时，通过练习，我们探讨了系统是否满足最小类型化性质，并提出了相应的修复方法。

### 关键概念中英对照

- **Polymorphic Update** 多态更新
- **Record Update Primitive** 记录更新原语
- **Bounded Quantification** 有界量化
- **Type Operator** 类型算子
- **Subtyping** 子类型
- **Minimal Typing Property** 最小类型化性质
- **Updatable Records** 可更新记录
- **Variance Tag** 方差标签
- **Depth Subtyping** 深度子类型化
- **Marking Updatable Fields** 标记可更新字段

通过深入理解这些概念和机制，读者能够掌握如何在高级类型系统中实现类型安全且灵活的对象操作，进一步拓展对**编程语言设计原理**（Programming Language Design Principles）的全面理解。

### ---------------------------

下面将对公式部分进行详细解释，每个规则和公式都包括了**上下文中的含义**、**推导步骤**以及**符号的详细解析**。

### 新语法形式 (New Syntactic Forms)

#### 记录 (Records)

- **语法形式**: 
  $$
  \{ \iota_i l_i = t_i \mid i \in 1..n \} \quad \text{record}
  $$

  这是记录的语法形式，表示一组字段 $l_i$ 及其对应的值 $t_i$，其中 $i$ 表示从 $1$ 到 $n$ 的字段索引。每个字段可以有一个标记 $\iota_i$，该标记可以是 `#`，表示该字段是**可更新的字段**（invariant，updatable field），未标记的字段表示是**固定的**（covariant，fixed field），即不可更新。

- **字段更新 (Field Update)**:
  $$
  t \leftarrow l = t
  $$

  这是字段更新的语法，表示更新记录 $t$ 中的字段 $l$，并将其值替换为新值 $t$。这种更新是函数式的，不改变原记录，而是生成一个新的记录。

### 新的求值规则 (New Evaluation Rules)

#### 记录字段更新 (Record Field Update)

- **规则**: 
  $$
  \frac{}{{\iota_j l_j = v_j \mid j \in 1..n} \leftarrow l_i = v 
  \longrightarrow \{ \iota_j l_j = v_j \mid j \in 1..i-1, \iota_i l_i = v, \iota_k l_k = v_k \mid k \in i+1..n \}}
  $$
  **解释**:

  - 左侧的记录 $\{ \iota_j l_j = v_j \mid j \in 1..n \}$ 表示具有字段 $l_1$ 到 $l_n$ 的记录。
  - 我们更新字段 $l_i$ 的值为 $v$，并生成一个新记录，保留其他字段（$l_j$ 和 $l_k$ 分别表示在 $i$ 之前和之后的字段）。
  - 更新后生成的新记录中，$l_i$ 的值已被更新为 $v$，其他字段保持不变。
  - 该规则只适用于标记为 `#` 的可更新字段。

  **公式中的符号**:
  
  - $\iota_j$：字段的方差标记，可以是 `#`（可更新）或省略的表示不可更新。
  - $v_j$：记录字段的值，$v_i$ 表示第 $i$ 个字段的值。
  
#### 记录字段投影 (Record Field Projection)

- **规则**:
  $$
  \frac{}{\{ \iota_i l_i = v_i \mid i \in 1..n \}. l_j \longrightarrow v_j}
  $$
  **解释**:

  - 这是记录字段投影的规则，表示从记录中获取字段 $l_j$ 的值 $v_j$。
  - 对于记录 $\{ \iota_i l_i = v_i \mid i \in 1..n \}$，选择字段 $l_j$，返回该字段的值 $v_j$。

#### 记录求值 (Record Evaluation)

- **规则**:
  $$
  \frac{t_j \longrightarrow t'_j}{\{ \iota_i l_i = v_i \mid i \in 1..j-1, \iota_j l_j = t_j, \iota_k l_k = t_k \mid k \in j+1..n \} \longrightarrow \{ \iota_i l_i = v_i \mid i \in 1..j-1, \iota_j l_j = t'_j, \iota_k l_k = t_k \mid k \in j+1..n \}}
  $$
  **解释**:

  - 该规则表示记录中的逐步求值。假设字段 $l_j$ 当前的值是 $t_j$，并且 $t_j$ 可以进一步求值为 $t'_j$。
  - 结果是一个新的记录，$l_j$ 的值被更新为 $t'_j$，而其他字段保持不变。

### 新的子类型化规则 (New Subtyping Rules)

#### 记录宽度子类型化 (Record Width Subtyping)

- **规则**:
  $$
  \frac{}{\Gamma \vdash \{ \iota_i l_i : T_i \mid i \in 1..n+k \} <: \{ \iota_i l_i : T_i \mid i \in 1..n \}}
  $$
  **解释**:

  - 这是记录的**宽度子类型化**规则，表示一个包含更多字段的记录类型（$n+k$ 个字段）可以是字段较少的记录类型（$n$ 个字段）的子类型。记录类型中的字段和顺序必须保持一致。
  - 该规则允许我们从具有较多字段的记录类型推导出较少字段的子类型。

#### 记录深度子类型化 (Record Depth Subtyping)

- **规则**:
  $$
  \frac{\text{for each } i \ \Gamma \vdash S_i <: T_i \quad \text{if } \iota_i = \#, \text{then } \Gamma \vdash T_i <: S_i}{\Gamma \vdash \{ \iota_i l_i : S_i \mid i \in 1..n \} <: \{ \iota_i l_i : T_i \mid i \in 1..n \}}
  $$
  **解释**:

  - 这是记录的**深度子类型化**规则，表示如果每个字段 $S_i$ 都是 $T_i$ 的子类型，则整个记录类型 $\{ \iota_i l_i : S_i \}$ 是 $\{ \iota_i l_i : T_i \}$ 的子类型。
  - 如果某个字段标记为 `#`（可更新），则需要确保 `T_i` 和 `S_i` 之间的子类型关系是双向的，即 $T_i$ 也必须是 $S_i$ 的子类型。

#### 记录方差子类型化 (Record Variance Subtyping)

- **规则**:
  $$
  \frac{}{\Gamma \vdash \{ \ldots # l_i : S_i \ldots \} <: \{ \ldots l_i : S_i \ldots \}}
  $$
  **解释**:

  - 该规则表示方差标记的子类型化关系。一个标记为 `#` 的可更新字段可以被“忘记”其可更新性，即可以将它视为不可更新字段的子类型。这称为**方差子类型化**。

### 新的类型规则 (New Typing Rules)

#### 记录类型化 (Typing for Records)

- **规则**:
  $$
  \frac{\text{for each } i \quad \Gamma \vdash t_i : T_i}{\Gamma \vdash \{ \iota_i l_i = t_i \mid i \in 1..n \} : \{ \iota_i l_i : T_i \mid i \in 1..n \}}
  $$
  **解释**:

  - 该规则用于推导记录的类型。如果每个字段 $l_i$ 对应的值 $t_i$ 的类型是 $T_i$，那么整个记录的类型为 $\{ \iota_i l_i : T_i \}$。

#### 记录投影类型化 (Typing for Record Projection)

- **规则**:
  $$
  \frac{\Gamma \vdash t_1 : \{ \iota_i l_i : T_i \mid i \in 1..n \}}{\Gamma \vdash t_1 . l_j : T_j}
  $$
  **解释**:

  - 该规则用于推导记录字段的类型。如果 $t_1$ 的类型为 $\{ \iota_i l_i : T_i \}$，那么记录的字段 $l_j$ 的类型为 $T_j$。

#### 记录更新类型化 (Typing for Record Update)

- **规则**:
  $$
  \frac{\Gamma \vdash r : R \quad \Gamma \vdash R <: \{ # l_j : T_j \} \quad \Gamma \vdash t : T_j}{\Gamma \vdash r \leftarrow l_j = t : R}
  $$
  **解释**:

  - 这是记录更新的类型规则。如果记录 $r$ 的类型为 $R$，且 $R$ 是包含标记 `#` 的字段 $l_j$ 类型 $\{# l_j : T_j\}$ 的子类型，并且 $t$ 的类型为 $T_j$，那么更新操作的结果类型仍然是 $R$。
  - 更新操作只能在标记为 `#` 的字段上进行。

---

## 总结

通过这些公式和规则，我们可以清晰地理解**

### ----------------------------

### 1. 语法定义 (Syntax Definitions)

#### 新的语法形式 (New Syntactic Forms)

- **术语 (Terms)**:
  
  $$
  t ::= \ldots \mid \{ \iota_i \, l_i = t_i \}_{i \in 1..n} \quad \text{记录 (record)}
  $$
  
  $$
  t \leftarrow l = t \quad \text{字段更新 (field update)}
  $$

  - **解释**:
    - $t$ 表示术语 (term)。
    - $\{ \iota_i \, l_i = t_i \}_{i \in 1..n}$ 表示一个记录类型 (record type)，包含 $n$ 个字段。
    - $t \leftarrow l = t$ 表示对记录的字段 $l$ 进行更新，将其值设为 $t$。

- **类型 (Types)**:
  
  $$
  T ::= \ldots \mid \{ \iota_i \, l_i : T_i \}_{i \in 1..n} \quad \text{记录类型 (type of records)}
  $$
  
  - **解释**:
    - $T$ 表示类型 (type)。
    - $\{ \iota_i \, l_i : T_i \}_{i \in 1..n}$ 表示一个记录类型，包含 $n$ 个字段，每个字段都有名称 $l_i$ 和类型 $T_i$。

- **不变符号 (Invariant Symbol)**:
  
  $$
  \iota ::= \# \quad \text{不变 (invariant) 字段}
  $$
  
  - **解释**:
    - $\iota$ 表示不变符号，用于标记字段的变异性。
    - $\#$ 表示该字段是可更新的 (updatable)。

### 2. 评估规则 (Evaluation Rules)

#### 更新操作的评估规则 (Evaluation Rules for Updates)

- **更新操作规则 (E-UpdateV)**:
  
  $$
  \frac{}
  {\{ \iota_j \, l_j = v_j \}_{j \in 1..n} \leftarrow l_i = v \rightarrow \{ \iota_j \, l_j = v_j \}_{j \in 1..i-1}, \iota_i \, l_i = v, \iota_k \, l_k = v_k \}_{k \in i+1..n}}
  $$

  - **解释**:
    - 该规则描述了对记录的字段 $l_i$ 进行更新的过程。
    - 左边的记录 $\{ \iota_j \, l_j = v_j \}_{j \in 1..n}$ 中的字段 $l_i$ 被更新为新的值 $v$。
    - 更新后的记录将字段 $l_i$ 的值设为 $v$，其他字段保持不变。

#### 记录投影的评估规则 (E-ProjRcd)

- **记录投影规则 (E-ProjRcd)**:
  
  $$
  \frac{}
  {\{ \iota_i \, l_i = v_i \}_{i \in 1..n} . l_j \rightarrow v_j}
  $$

  - **解释**:
    - 该规则描述了从记录中提取字段 $l_j$ 的值。
    - 记录 $\{ \iota_i \, l_i = v_i \}_{i \in 1..n}$ 中的字段 $l_j$ 的值 $v_j$ 被投影出来。

#### 记录构造的评估规则 (E-Rcd)

- **记录构造规则 (E-Rcd)**:
  
  $$
  \frac{
    t_j \rightarrow t_j' \quad \text{for some } j
  }
  {\{ \iota_i \, l_i = t_i \}_{i \in 1..n} \rightarrow \{ \iota_i \, l_i = t_i' \}_{i \in 1..n}}
  $$

  - **解释**:
    - 该规则描述了记录中某个字段的值从 $t_j$ 变化为 $t_j'$ 的过程。
    - 如果存在某个字段 $l_j$，其值 $t_j$ 评估为 $t_j'$，则整个记录的该字段值也相应更新。

### 3. 子类型规则 (Subtyping Rules)

#### 记录类型的宽度子类型规则 (S-RcdWidth)

- **宽度子类型规则 (S-RcdWidth)**:
  
  $$
  \frac{}
  {\Gamma \vdash \{ \iota_i \, l_i : T_i \}_{i \in 1..n+k} <: \{ \iota_i \, l_i : T_i \}_{i \in 1..n}}
  $$

  - **解释**:
    - 如果一个记录类型包含更多的字段（$n+k$ 个）而目标类型只需要前 $n$ 个字段，则前者是后者的子类型。
    - 这称为“宽度子类型” (width subtyping)，允许记录类型拥有更多的字段。

#### 记录类型的深度子类型规则 (S-RcdDepth)

- **深度子类型规则 (S-RcdDepth)**:
  
  $$
  \frac{\Gamma \vdash S_i <: T_i \quad \text{对于每个 } i}
  {\Gamma \vdash \{ \iota_i \, l_i : S_i \}_{i \in 1..n} <: \{ \iota_i \, l_i : T_i \}_{i \in 1..n}}
  $$

  - **解释**:
    - 如果每个字段的类型 $S_i$ 是目标类型 $T_i$ 的子类型，则整个记录类型是目标记录类型的子类型。
    - 这称为“深度子类型” (depth subtyping)，关注字段类型的兼容性。

#### 记录类型的协变性子类型规则 (S-RcdVariance)

- **协变性子类型规则 (S-RcdVariance)**:
  
  $$
  \frac{}
  {\Gamma \vdash \{ \ldots \# l_i : S_i \ldots \} <: \{ \ldots l_i : S_i \ldots \}}
  $$

  - **解释**:
    - 如果一个记录类型中的某些字段被标记为不变（$\#$），则这些字段在子类型中必须保持协变。
    - 这确保了字段的类型在子类型中是兼容的，不会引入类型不一致的问题。

### 4. 类型规则 (Typing Rules)

#### 记录类型的类型规则 (T-Rcd)

- **记录类型规则 (T-Rcd)**:
  
  $$
  \frac{
    \Gamma \vdash t_i : T_i \quad \text{对于每个 } i
  }
  {\Gamma \vdash \{ \iota_i \, l_i = t_i \}_{i \in 1..n} : \{ \iota_i \, l_i : T_i \}_{i \in 1..n}}
  $$

  - **解释**:
    - 如果每个字段的术语 $t_i$ 的类型是 $T_i$，则整个记录 $\{ \iota_i \, l_i = t_i \}_{i \in 1..n}$ 的类型是 $\{ \iota_i \, l_i : T_i \}_{i \in 1..n}$。
    - 这确保了记录的每个字段都有正确的类型。

#### 记录字段投影的类型规则 (T-Proj)

- **记录字段投影规则 (T-Proj)**:
  
  $$
  \frac{
    \Gamma \vdash t_1 : \{ \iota_i \, l_i : T_i \}_{i \in 1..n} \\
    \Gamma \vdash t_1 . l_j : T_j
  }
  {\Gamma \vdash t_1 . l_j : T_j}
  $$

  - **解释**:
    - 如果术语 $t_1$ 的类型是一个记录类型，并且字段 $l_j$ 的类型是 $T_j$，则 $t_1 . l_j$ 的类型也是 $T_j$。
    - 这允许从记录中提取特定字段的值，并确保类型的正确性。

#### 更新操作的类型规则 (T-Update)

- **更新操作规则 (T-Update)**:
  
  $$
  \frac{
    \Gamma \vdash r : R \\
    \Gamma \vdash R <: \{ \# l_j : T_j \} \\
    \Gamma \vdash t : T_j
  }
  {\Gamma \vdash r \leftarrow l_j = t : R}
  $$

  - **解释**:
    - 如果记录 $r$ 的类型 $R$ 是 $\{ \# l_j : T_j \}$ 的子类型，并且新值 $t$ 的类型也是 $T_j$，则更新操作 $r \leftarrow l_j = t$ 的类型仍然是 $R$。
    - 这保证了更新操作不会破坏记录的类型约束，特别是对于标记为不变的字段。

### 5. 多层推导树示例 (Multi-layer Derivation Tree Example)

假设我们有一个空树 (empty tree)，以下是一个多层推导树的示例：

- **空树 (Empty Tree)**:
  
  $$
  \frac{}{\text{empty tree}} \quad \frac{}{\text{empty tree}} 
  $$

- **第一层 (First Layer)**:
  
  $$
  \quad \frac{\frac{}{\text{empty tree}} \quad \frac{}{\text{empty tree}}}{\text{node(empty; empty) tree}} 
  $$

- **第二层 (Second Layer)**:
  
  $$
  \quad \frac{\frac{\frac{}{\text{empty tree}} \quad \frac{}{\text{empty tree}}}{\text{node(empty; empty) tree}} \quad \frac{}{\text{empty tree}}}{\text{node(node(empty; empty); empty) tree}}
  $$

  - **解释**:
    - 每一层推导树展示了如何从更底层的树结构构建更复杂的树。
    - 使用分隔符将每一层的子树分开，确保推导过程的清晰和结构化。

### 6. 公式的详细解析

所有涉及的公式都已在上述各部分详细列出，并按照用户的要求使用了正确的 Markdown 语法。每个公式前都有推导横线，确保格式的规范性。

### 7. 习题讲解与解答 (Exercise Solutions)

**注意**: 由于当前内容未涉及具体的习题，以下为示例说明。

- **习题示例 (Exercise Example)**:
  
  假设有以下记录类型和更新操作，证明更新后的类型仍然是子类型。

  **解答 (Solution)**:
  
  根据 **T-Update** 规则，若记录 $r$ 的类型 $R$ 是 $\{ \# l_j : T_j \}$ 的子类型，并且新值 $t$ 的类型是 $T_j$，则更新操作 $r \leftarrow l_j = t$ 的类型仍然是 $R$。因此，更新后的类型保持子类型关系。

### 8. 图示公式的详解 (Explanation of Formulas in Figures)

**Figure 32-1: Polymorphic Update**

- **公式 1: 新的语法形式 (New Syntactic Forms)**
  
  如前所述，定义了记录类型和更新操作的语法。

- **公式 2: 评估规则 (Evaluation Rules)**
  
  包括更新操作规则、记录投影规则和记录构造规则，详细解释了记录操作的评估过程。

- **公式 3: 子类型规则 (Subtyping Rules)**
  
  包含宽度子类型、深度子类型和协变性子类型规则，确保记录类型之间的兼容性。

- **公式 4: 类型规则 (Typing Rules)**
  
  包括记录类型的类型规则、记录字段投影的类型规则和更新操作的类型规则，确保类型系统的正确性。

每个公式都严格按照用户的要求进行了格式化和详细解释，确保内容的完整性和可理解性。

### ---------------------------

### 32.8 添加实例变量 (Adding Instance Variables)

在上一节的基础上，我们可以编写一个 `counterClass`，它在内部状态的类型上是多态的。

#### 定义 `CounterR` 类型

$$
CounterR = \{ \#x:Nat \}
$$

- **解释**:
  - **`CounterR`** 是一个记录类型，包含一个名为 `x` 的字段，其类型为自然数 (`Nat`)。
  - 字段前的 `#` 表示该字段是**不变的** (invariant)，即可以被更新。

#### 定义 `counterClass`

```plaintext
counterClass =
λR<:CounterR.
{ get = λs:R. s.x,
  inc = λs:R. s←x=succ(s.x)
} as CounterM R;
```

- **解释**:
  - **`counterClass`** 是一个类，接受一个类型参数 `R`，该类型 `R` 必须是 `CounterR` 的子类型 (`R <: CounterR`)。
  - 类包含两个方法：
    - **`get`**: 一个函数，接受状态 `s`，返回 `s.x` 的值。
    - **`inc`**: 一个函数，接受状态 `s`，将 `s.x` 的值增加 1（使用 `succ` 表示后继函数）。
  - 使用 `as CounterM R` 将其类型标注为 `CounterM R`。

#### 类型注解

$$
ñ \, counterClass : \forall R <: CounterR. \, CounterM \, R
$$

- **解释**:
  - `counterClass` 的类型是对于所有 `R` 类型，如果 `R` 是 `CounterR` 的子类型，那么 `counterClass` 的类型为 `CounterM R`。

#### 构建对象

```plaintext
c = {*CounterR,
  { state = {#x=0},
    methods = counterClass [CounterR]
  }
} as Object CounterM;
```

- **解释**:
  - 创建一个对象 `c`，其内部表示类型为 `CounterR`。
  - 对象包含两个部分：
    - **`state`**: 初始化为 `{#x=0}`，即 `x` 的初始值为 0。
    - **`methods`**: 使用 `counterClass` 进行实例化，传入 `CounterR` 作为类型参数。
  - 使用 `as Object CounterM` 将其类型注解为 `Object CounterM`。

#### 类型注解

$$
ñ \, c : Counter
$$

- **解释**:
  - 对象 `c` 的类型为 `Counter`，即 `Object CounterM`。

#### 解释

- 从新的 `counterClass` 构建的对象具有与之前相同的类型 `Counter = Object CounterM`。
- 实例变量的处理方式的变化完全在类的内部，不影响外部对象的类型。
- 上述的方法调用函数也可以用于从新类实例化的对象。

#### 定义 `resetCounterClass`

```plaintext
resetCounterClass =
λR<:CounterR.
  let super = counterClass [R] in
  { get = super.get,
    inc = super.inc,
    reset = λs:R. s←x=0
  } as ResetCounterM R;
```

- **解释**:
  - **`resetCounterClass`** 是一个类，继承自 `counterClass`。
  - 接受类型参数 `R`，要求 `R` 是 `CounterR` 的子类型。
  - 定义了三个方法：
    - **`get`** 和 **`inc`**: 继承自 `super`（即 `counterClass`）。
    - **`reset`**: 一个新方法，用于将 `x` 重置为 0。
  - 使用 `as ResetCounterM R` 将其类型注解为 `ResetCounterM R`。

#### 类型注解

$$
ñ \, resetCounterClass : \forall R <: CounterR. \, ResetCounterM \, R
$$

- **解释**:
  - `resetCounterClass` 的类型是对于所有 `R` 类型，如果 `R` 是 `CounterR` 的子类型，那么 `resetCounterClass` 的类型为 `ResetCounterM R`。

### 备份计数器类 (BackupCounterClass)

#### 定义 `BackupCounterM` 和 `BackupCounterR`

$$
BackupCounterM = λR. \{ get: R \rightarrow Nat, \, inc: R \rightarrow R, \, reset: R \rightarrow R, \, backup: R \rightarrow R \}
$$

$$
BackupCounterR = \{ \#x:Nat, \#old:Nat \}
$$

- **解释**:
  - **`BackupCounterM`** 定义了四个方法：`get`、`inc`、`reset` 和 `backup`。
  - **`BackupCounterR`** 是一个记录类型，包含两个不变字段：`x` 和 `old`，均为自然数 (`Nat`)。

#### 定义 `backupCounterClass`

```plaintext
backupCounterClass =
λR<:BackupCounterR.
  let super = resetCounterClass [R] in
  { get = super.get,
    inc = super.inc,
    reset = λs:R. s←x=s.old,
    backup = λs:R. s←old=s.x
  } as BackupCounterM R;
```

- **解释**:
  - **`backupCounterClass`** 是一个类，继承自 `resetCounterClass`。
  - 接受类型参数 `R`，要求 `R` 是 `BackupCounterR` 的子类型。
  - 定义了四个方法：
    - **`get`** 和 **`inc`**: 继承自 `super`（即 `resetCounterClass`）。
    - **`reset`**: 将 `x` 重置为 `old` 的值。
    - **`backup`**: 将 `old` 设置为当前 `x` 的值。
  - 使用 `as BackupCounterM R` 将其类型注解为 `BackupCounterM R`。

#### 类型注解

$$
ñ \, backupCounterClass : \forall R <: BackupCounterR. \, BackupCounterM \, R
$$

- **解释**:
  - `backupCounterClass` 的类型是对于所有 `R` 类型，如果 `R` 是 `BackupCounterR` 的子类型，那么 `backupCounterClass` 的类型为 `BackupCounterM R`。

### 32.9 带有 “Self” 的类 (Classes with “Self”)

在第18.9节中，我们看到如何通过一种机制扩展命令式类，使得类的方法可以相互递归引用。这种扩展在纯函数式环境中也是有意义的。

#### 抽象化 `counterClass`

```plaintext
counterClass =
λR<:CounterR.
  λself: Unit → CounterM R.
    λ_:Unit.
      { get = λs:R. s.x,
        inc = λs:R. s←x=succ(s.x)
      } as CounterM R;
```

- **解释**:
  - **`counterClass`** 现在接受三个参数：
    1. 类型参数 `R`，要求 `R` 是 `CounterR` 的子类型。
    2. `self`：一个函数，类型为 `Unit → CounterM R`，用于引用自身的方法集合。
    3. `_`：一个 `Unit` 类型的参数，用于延迟评估，配合 `fix` 操作创建对象的方法。
  - 类的方法定义与之前相同：`get` 和 `inc`。

#### 使用 `fix` 操作构建对象

```plaintext
c = {*CounterR,
  { state = {#x=0},
    methods = fix (counterClass [CounterR]) unit
  }
} as Object CounterM;
```

- **解释**:
  - 创建一个对象 `c`，其内部表示类型为 `CounterR`。
  - 对象包含两个部分：
    - **`state`**: 初始化为 `{#x=0}`。
    - **`methods`**: 使用 `fix` 操作构建方法集合，通过将 `counterClass` 应用于 `CounterR` 并传入 `unit`。
  - 使用 `as Object CounterM` 将其类型注解为 `Object CounterM`。

#### 类型注解

$$
ñ \, c : Counter
$$

- **解释**:
  - 对象 `c` 的类型为 `Counter`，即 `Object CounterM`。

### 定义带有 `set` 操作的子类 (SetCounterClass)

#### 定义 `SetCounterM`

$$
SetCounterM = λR. \{ get: R \rightarrow Nat, \, set: R \rightarrow Nat \rightarrow R, \, inc: R \rightarrow R \}
$$

- **解释**:
  - **`SetCounterM`** 定义了三个方法：`get`、`set` 和 `inc`。

#### 定义 `setCounterClass`

```plaintext
setCounterClass =
λR<:CounterR.
  λself: Unit → SetCounterM R.
    λ_:Unit.
      let super = counterClass [R] self unit in
      { get = super.get,
        set = λs:R. λn:Nat. s←x=n,
        inc = λs:R. (self unit).set s (succ ((self unit).get s))
      } as SetCounterM R;
```

- **解释**:
  - **`setCounterClass`** 是一个类，继承自 `counterClass`。
  - 接受三个参数：
    1. 类型参数 `R`，要求 `R` 是 `CounterR` 的子类型。
    2. `self`：一个函数，类型为 `Unit → SetCounterM R`，用于引用自身的方法集合。
    3. `_`：一个 `Unit` 类型的参数，用于延迟评估。
  - 定义了三个方法：
    - **`get`**: 继承自 `super`（即 `counterClass`）。
    - **`set`**: 一个新方法，接受状态 `s` 和自然数 `n`，将 `s.x` 设置为 `n`。
    - **`inc`**: 使用 `self` 调用 `set` 方法，将 `x` 增加 1。

#### 类型注解

- **解释**:
  - `setCounterClass` 的类型为 `SetCounterM R`，即 `{ get, set, inc }`。

### 定义带有访问计数的仪器化计数器类 (InstrCounterClass)

#### 定义 `InstrCounterM` 和 `InstrCounterR`

$$
InstrCounterM = λR. \{ get: R \rightarrow Nat, \, set: R \rightarrow Nat \rightarrow R, \, inc: R \rightarrow R, \, accesses: R \rightarrow Nat \}
$$

$$
InstrCounterR = \{ \#x:Nat, \#count:Nat \}
$$

- **解释**:
  - **`InstrCounterM`** 定义了四个方法：`get`、`set`、`inc` 和 `accesses`。
  - **`InstrCounterR`** 是一个记录类型，包含两个不变字段：`x` 和 `count`，均为自然数 (`Nat`)。

#### 定义 `instrCounterClass`

```plaintext
instrCounterClass =
λR<:InstrCounterR.
  λself: Unit → InstrCounterM R.
    λ_:Unit.
      let super = setCounterClass [R] self unit in
      { get = super.get,
        set = λs:R. λn:Nat.
          let r = super.set s n in
          r←count=succ(r.count),
        inc = super.inc,
        accesses = λs:R. s.count
      } as InstrCounterM R;
```

- **解释**:
  - **`instrCounterClass`** 是一个类，继承自 `setCounterClass`。
  - 接受三个参数：
    1. 类型参数 `R`，要求 `R` 是 `InstrCounterR` 的子类型。
    2. `self`：一个函数，类型为 `Unit → InstrCounterM R`，用于引用自身的方法集合。
    3. `_`：一个 `Unit` 类型的参数，用于延迟评估。
  - 定义了四个方法：
    - **`get`** 和 **`inc`**: 继承自 `super`（即 `setCounterClass`）。
    - **`set`**: 修改后的 `set` 方法，除了设置 `x` 的值，还会增加 `count` 的值。
    - **`accesses`**: 返回当前的访问计数 `count`。

#### 解释

- `inc` 方法通过调用 `self` 的 `set` 方法来实现，这样 `inc` 的调用也会被计数器的访问计数所记录。

### 构建仪器化计数器对象并发送消息

#### 定义对象 `ic`

```plaintext
ic = {*InstrCounterR,
  { state = {#x=0, #count=0},
    methods = fix (instrCounterClass [InstrCounterR]) unit
  }
} as Object InstrCounterM;
```

- **解释**:
  - 创建一个对象 `ic`，其内部表示类型为 `InstrCounterR`。
  - 对象包含两个部分：
    - **`state`**: 初始化为 `{#x=0, #count=0}`。
    - **`methods`**: 使用 `fix` 操作构建方法集合，通过将 `instrCounterClass` 应用于 `InstrCounterR` 并传入 `unit`。
  - 使用 `as Object InstrCounterM` 将其类型注解为 `Object InstrCounterM`。

#### 类型注解

$$
ñ \, ic : Object \, InstrCounterM
$$

- **解释**:
  - 对象 `ic` 的类型为 `Object InstrCounterM`。

#### 发送消息

```plaintext
sendaccesses [InstrCounterM] (sendinc [InstrCounterM] ic);
ñ \, 1 : Nat
```

- **解释**:
  - 首先对 `ic` 发送 `inc` 消息，增加 `x` 的值。
  - 然后对 `ic` 发送 `accesses` 消息，获取访问计数。
  - 最终结果为 `1`，表示 `inc` 方法被调用了一次。

### 32.9.1 习题 [推荐, «««]: 定义一个 `instrCounterClass` 的子类，添加 `backup` 和 `reset` 方法。

#### 习题要求

- 定义一个 `instrCounterClass` 的子类，增加两个新方法：`backup` 和 `reset`。

#### 解答

我们将基于现有的 `instrCounterClass`，创建一个新的子类 `extendedInstrCounterClass`，添加 `backup` 和 `reset` 方法。

#### 定义 `ExtendedInstrCounterM` 和 `ExtendedInstrCounterR`

$$
ExtendedInstrCounterM = λR. \{ get: R \rightarrow Nat, \, set: R \rightarrow Nat \rightarrow R, \, inc: R \rightarrow R, \, accesses: R \rightarrow Nat, \, backup: R \rightarrow R, \, reset: R \rightarrow R \}
$$

$$
ExtendedInstrCounterR = \{ \#x:Nat, \#count:Nat, \#old:Nat \}
$$

- **解释**:
  - **`ExtendedInstrCounterM`** 定义了六个方法：`get`、`set`、`inc`、`accesses`、`backup` 和 `reset`。
  - **`ExtendedInstrCounterR`** 是一个记录类型，包含三个不变字段：`x`、`count` 和 `old`，均为自然数 (`Nat`)。

#### 定义 `extendedInstrCounterClass`

```plaintext
extendedInstrCounterClass =
λR<:ExtendedInstrCounterR.
  λself: Unit → ExtendedInstrCounterM R.
    λ_:Unit.
      let super = instrCounterClass [R] self unit in
      { get = super.get,
        set = super.set,
        inc = super.inc,
        accesses = super.accesses,
        backup = λs:R. s←old=s.x,
        reset = λs:R. 
          let r1 = super.reset s in
          let r2 = r1←x=0 in
          r2
      } as ExtendedInstrCounterM R;
```

- **解释**:
  - **`extendedInstrCounterClass`** 是一个类，继承自 `instrCounterClass`。
  - 接受三个参数：
    1. 类型参数 `R`，要求 `R` 是 `ExtendedInstrCounterR` 的子类型。
    2. `self`：一个函数，类型为 `Unit → ExtendedInstrCounterM R`，用于引用自身的方法集合。
    3. `_`：一个 `Unit` 类型的参数，用于延迟评估。
  - 定义了六个方法：
    - **`get`**、**`set`**、**`inc`** 和 **`accesses`**: 继承自 `super`（即 `instrCounterClass`）。
    - **`backup`**: 将当前 `x` 的值备份到 `old` 字段。
    - **`reset`**: 首先调用 `super.reset` 将 `x` 重置为 `old`，然后将 `x` 设置为 0。

#### 解释

- **`backup` 方法**:
  - 备份当前的 `x` 值到 `old` 字段，以便后续恢复使用。
- **`reset` 方法**:
  - 通过调用 `super.reset` 方法将 `x` 重置为 `old` 的值，然后进一步将 `x` 设置为 0。

#### 使用 `fix` 操作构建扩展对象

```plaintext
extendedIc = {*ExtendedInstrCounterR,
  { state = {#x=0, #count=0, #old=0},
    methods = fix (extendedInstrCounterClass [ExtendedInstrCounterR]) unit
  }
} as Object ExtendedInstrCounterM;
```

- **解释**:
  - 创建一个对象 `extendedIc`，其内部表示类型为 `ExtendedInstrCounterR`。
  - 对象包含两个部分：
    - **`state`**: 初始化为 `{#x=0, #count=0, #old=0}`。
    - **`methods`**: 使用 `fix` 操作构建方法集合，通过将 `extendedInstrCounterClass` 应用于 `ExtendedInstrCounterR` 并传入 `unit`。
  - 使用 `as Object ExtendedInstrCounterM` 将其类型注解为 `Object ExtendedInstrCounterM`。

#### 类型注解

$$
ñ \, extendedIc : Object \, ExtendedInstrCounterM
$$

- **解释**:
  - 对象 `extendedIc` 的类型为 `Object ExtendedInstrCounterM`。

#### 发送消息示例

```plaintext
sendbackup [ExtendedInstrCounterM] extendedIc;
sendreset [ExtendedInstrCounterM] extendedIc;
ñ \, () : Unit
```

- **解释**:
  - 首先对 `extendedIc` 发送 `backup` 消息，备份当前 `x` 的值。
  - 然后对 `extendedIc` 发送 `reset` 消息，将 `x` 重置。
  - 最终结果为 `()`，表示操作完成。

### 总结

通过上述步骤，我们系统性地理解了如何在纯函数式编程中通过多态性和继承机制扩展类的功能，包括添加实例变量、定义子类以及实现方法的递归调用。每一步都详细解释了类型定义、方法实现以及对象构建的过程，确保了对编程语言设计原理和类型论的深入理解。

### 公式详细解析

在上述内容中，虽然主要使用了伪代码和类型注解，但以下是对涉及的关键公式和符号的详细解释：

#### 子类型约束

$$
R <: CounterR
$$

- **解释**:
  - `R` 是 `CounterR` 的**子类型**。
  - 这意味着 `R` 至少包含 `CounterR` 中定义的所有字段，并可能包含更多字段。

#### 多态类型

$$
\forall R <: CounterR. \, CounterM \, R
$$

- **解释**:
  - 这是一个**多态类型**，表示对于所有 `R` 类型，只要 `R` 是 `CounterR` 的子类型，`CounterM R` 都是有效的。
  - 使用 **全称量化** (universal quantification) 表示通用性。

#### 函数类型

$$
Unit \rightarrow CounterM \, R
$$

- **解释**:
  - 表示一个函数类型，接受一个 `Unit` 类型的参数，返回 `CounterM R` 类型的结果。
  - `Unit` 类型通常用于表示没有实际信息的参数，用于控制计算的顺序或延迟计算。

#### 记录类型

$$
\{ \#x:Nat, \#count:Nat \}
$$

- **解释**:
  - 这是一个**记录类型**，包含两个字段：`x` 和 `count`，均为自然数 (`Nat`)。
  - 字段前的 `#` 表示这些字段是**不变的** (invariant)，可以被更新。

### 代码段详细讲解

以下是对 `backupCounterClass` 的详细代码讲解：

```plaintext
backupCounterClass =
λR<:BackupCounterR.
  let super = resetCounterClass [R] in
  { get = super.get,
    inc = super.inc,
    reset = λs:R. s←x=s.old,
    backup = λs:R. s←old=s.x
  } as BackupCounterM R;
```

- **`λR<:BackupCounterR.`**:
  - 定义一个接受类型参数 `R` 的函数，`R` 必须是 `BackupCounterR` 的子类型。
  
- **`let super = resetCounterClass [R] in`**:
  - 创建一个变量 `super`，通过实例化 `resetCounterClass` 并传入类型参数 `R`，获得父类的方法集合。

- **`{ get = super.get, inc = super.inc, ... } as BackupCounterM R;`**:
  - 定义一个记录，包含以下方法：
    - **`get`**: 继承自 `super` 的 `get` 方法。
    - **`inc`**: 继承自 `super` 的 `inc` 方法。
    - **`reset`**: 新增的方法，将 `x` 重置为 `old` 的值。
    - **`backup`**: 新增的方法，将当前 `x` 的值备份到 `old` 字段。
  - 使用 `as BackupCounterM R` 将其类型标注为 `BackupCounterM R`。

### 多层推导树示例

以下是一个多层推导树的示例，用于展示如何构建复杂的树结构：

- **空树 (Empty Tree)**:

$$
\frac{}{\text{empty tree}} \quad \frac{}{\text{empty tree}}
$$

- **第一层 (First Layer)**:

$$
\quad \frac{\frac{}{\text{empty tree}} \quad \frac{}{\text{empty tree}}}{\text{node(empty; empty) tree}}
$$

- **第二层 (Second Layer)**:

$$
\quad \frac{\frac{\frac{}{\text{empty tree}} \quad \frac{}{\text{empty tree}}}{\text{node(empty; empty) tree}} \quad \frac{}{\text{empty tree}}}{\text{node(node(empty; empty); empty) tree}}
$$

- **解释**:
  - 每一层展示了如何从更底层的树结构构建更复杂的树。
  - 使用分隔符将每一层的子树分开，确保推导过程的清晰和结构化。

### 总结

通过对上述内容的详细解释和逐步讲解，我们不仅理解了如何在纯函数式编程中定义和扩展类，还深入了解了多态性、子类型约束和记录类型的应用。这些知识对于掌握编程语言设计原理和类型论具有重要意义。

### ----------------------------

### 32.10 注释 (Notes)

#### 纯函数式对象的最初解释

最早对**类型化 lambda 演算**中对象的“纯函数式”解释基于**递归定义的记录** (recursively-defined records)；这一模型由 **Cardelli** 于 **1984年** 提出，并由 **Kamin 和 Reddy**（Reddy, 1988; Kamin and Reddy, 1994）、**Cook 和 Palsberg**（1989）、以及 **Mitchell**（1990a）在多种变体中进行了研究。在其**未类型化**的形式中，这一模型被有效地用于**未类型化面向对象语言** (untyped object-oriented languages) 的**赋范语义** (denotational semantics)。在**类型化**的形式中，虽然该模型被用于编码个别的面向对象示例，但在**类型化面向对象语言** (typed object-oriented languages) 的**统一解释** (uniform interpretations) 上遇到了困难。

#### Cook 等人的贡献

在这一方向上，**Cook** 及其同事（Cook, Hill, and Canning, 1990; Canning, Cook, Hill, and Olthoff, 1989a; Canning, Cook, Hill, Olthoff, and Mitchell, 1989b）进行了最成功的尝试。他们的工作为在类型化 lambda 演算中解释对象提供了重要的基础，尽管仍面临一些挑战。

#### Pierce 和 Turner 的编码方法

**Pierce 和 Turner**（1994）引入了一种仅依赖于具有**存在类型** (existential types) 的类型系统的编码方法，而不使用**递归类型** (recursive types)。这一方法促使 **Hofmann 和 Pierce**（Hofmann and Pierce, 1995b）提出了**功能性演算中对象的第一个统一、类型驱动的解释** (the first uniform, type-driven interpretation of objects in a functional calculus)。在同一会议上，**Bruce**（1994）发表了一篇论文，讨论了一种**函数式面向对象语言** (functional object-oriented language) 的语义。这种语义最初被呈现为**Fω<:** 的赋范模型的直接映射，但最近被重新表述为依赖于**存在类型** 和 **递归类型** 的对象编码。

#### Abadi 和 Cardelli 的原始对象演算

与此同时，因在 lambda 演算中编码对象的困难，**Abadi 和 Cardelli**（1996）引入了一种**原始对象演算** (calculus of primitive objects)。然而，**Abadi、Cardelli 和 Viswanathan**（Abadi, Cardelli, and Viswanathan, 1996）后来发现，可以使用**有界存在类型** (bounded existentials) 和 **递归类型** 的组合，对该对象演算进行**忠实编码** (faithful encoding)。这些发展由 **Bruce 等人**（Bruce et al., 1999）和 **Abadi 和 Cardelli**（Abadi and Cardelli, 1996）进行了综述。

#### 多重继承的对象编码

本章中的**对象编码**已经扩展以包括**多重继承** (multiple inheritance)—具有多个超类的类—由 **Compagnoni 和 Pierce**（Compagnoni and Pierce, 1996）完成。其关键技术思想是扩展 **Fω<:**，引入**交叉类型** (intersection types)（详见 §15.7）。

#### 处理纯二阶有界量化的不足

针对我们在 §32.3 中观察到的**纯二阶有界量化** (pure second-order bounded quantification) 的不足，已经有许多提案。除了本章中讨论的**高阶有界量化** (higher-order bounded quantification) 和**多态记录更新原语** (polymorphic record update primitive) 外，还有以下几种方法：

- **多态记录更新** (Polymorphic Record Update):
  - **Cardelli 和 Mitchell**（1991; 1992）
  - **Fisher 和 Mitchell**（1996）
  - **Poll**（1996）

- **递归类型的结构展开** (Structural Unfolding for Recursive Types):
  - **Abadi 和 Cardelli**（1996）

- **正子类型** (Positive Subtyping):
  - **Hofmann 和 Pierce**（1995a）

- **存在类型的多态重新打包** (Polymorphic Repacking for Existential Types):
  - **Pierce**（1996）

- **类型析取器** (Type Destructors):
  - **Hofmann 和 Pierce**（1998）

#### 基于行变量多态性的不同方法

另一条基于**行变量多态性** (row-variable polymorphism) 的方法由 **Wand**（1987, 1988, 1989b）、**Rémy**（1990, 1989, 1992）、**Vouillon**（2000, 2001）等人发展，并成为 **OCaml**（Rémy and Vouillon, 1998）面向对象特性的基础。

#### 总结

这些发展展示了在类型化函数式编程中实现面向对象特性的多样化尝试和演进。尽管最初的模型在未类型化环境中表现良好，但在类型化系统中实现统一和灵活的对象模型仍然具有挑战性。通过引入存在类型、递归类型、交叉类型以及行变量多态性等高级类型系统特性，研究人员逐步克服了这些困难，实现了更加健壮和灵活的对象模型。这些工作不仅丰富了类型理论的发展，也为现代编程语言设计提供了坚实的理论基础。

### 相关术语中英双语对照

- **类型化 lambda 演算** (typed lambda calculus)
- **递归定义的记录** (recursively-defined records)
- **赋范语义** (denotational semantics)
- **类型化面向对象语言** (typed object-oriented languages)
- **存在类型** (existential types)
- **递归类型** (recursive types)
- **多重继承** (multiple inheritance)
- **交叉类型** (intersection types)
- **高阶有界量化** (higher-order bounded quantification)
- **多态记录更新原语** (polymorphic record update primitive)
- **正子类型** (positive subtyping)
- **行变量多态性** (row-variable polymorphism)

### 参考文献

- **Cardelli, L.** (1984). [Title of the work].
- **Kamin, G., & Reddy, S.** (1989a, 1989b, 1994).
- **Cook, R., Hill, S., & Canning, B.** (1990).
- **Cook, R., Palsberg, J.** (1989).
- **Mitchell, J. C.** (1990a).
- **Pierce, B. C., & Turner, M.** (1994).
- **Hofmann, H., & Pierce, B. C.** (1995a, 1995b, 1998).
- **Abadi, M., Cardelli, L., & Viswanathan, R.** (1996).
- **Compagnoni, R., & Pierce, B. C.** (1996).
- **Wand, M.** (1987, 1988, 1989b).
- **Rémy, J. C.** (1990, 1989, 1992).
- **Vouillon, S.** (2000, 2001).
- **Fisher, C., & Mitchell, J. C.** (1996).
- **Poll, D.** (1996).

这些参考文献展示了在类型化函数式编程中实现面向对象特性的研究进展和多样化方法，为进一步深入理解这一领域提供了丰富的资源。

### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------
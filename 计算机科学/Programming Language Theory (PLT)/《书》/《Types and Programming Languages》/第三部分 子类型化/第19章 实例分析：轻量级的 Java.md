[toc]



**19. 案例研究：轻量级 Java (Featherweight Java)**

在第 18 章中，我们看到如何使用具有子类型 (subtyping)、记录 (records) 和引用 (references) 的 $\lambda$-演算 (lambda-calculus) 来模拟面向对象编程的一些关键特性。该章的目标是通过将这些特性编码为更基本的元素，来加深我们对它们的理解。

在本章中，我们采取不同的方法，展示如何将前几章的思想直接应用于基于 Java 的核心面向对象语言的处理。这里假设读者已经熟悉 Java。

---

### **19.1 引言 (Introduction)**

**形式化建模 (Formal modeling)** 可以显著促进对复杂的现实世界制品（如编程语言）的设计。形式化模型可用于精确地描述设计的某些方面，陈述并证明其性质，以及引导人们关注可能被忽视的问题。

然而，在制定模型时，**完整性 (completeness)** 和**简洁性 (compactness)** 之间存在着张力：模型同时涉及的方面越多，它就越显得笨拙。通常，选择一个不那么完整但更简洁的模型是明智的，它可以以最小的投入提供最大的洞察力。这种策略可以在最近一系列关于 Java 形式属性的论文中看到，这些论文省略了诸如并发 (concurrency) 和反射 (reflection) 等高级特性，专注于可应用成熟理论的完整语言的某些片段。

**轻量级 Java (Featherweight Java, FJ)** 由 Igarashi、Pierce 和 Wadler（1999）提出，作为用于建模 Java 类型系统的最小核心演算的候选者。FJ 的设计几乎偏执地追求简洁性而非完整性，只包含五种术语形式：**对象创建 (object creation)**、**方法调用 (method invocation)**、**字段访问 (field access)**、**类型转换 (casting)** 和**变量 (variables)**。它的语法、类型规则和操作语义可以舒适地放在一页纸上。事实上，其设计目标是尽可能地省略特性——甚至是赋值 (assignment)——同时保留 Java 类型的核心特性。FJ 与 Java 的纯函数核心之间存在直接对应关系，因为每个 FJ 程序实际上都是一个可执行的 Java 程序。

FJ 只比 $\lambda$-演算或 Abadi 和 Cardelli 的对象演算 (object calculus)（1996）大一点，并且明显小于其他基于类的语言（如 Java）的形式模型，包括 Drossopoulou、Eisenbach 和 Khurshid（1999）、Syme（1997）、Nipkow 和 Oheimb（1998），以及 Flatt、Krishnamurthi 和 Felleisen（1998a，1998b）等的模型。由于更小，FJ 可以专注于少数几个关键问题。例如，我们将看到，在小步操作语义中捕获 Java 类型转换构造的行为比我们预期的要棘手。

FJ 的主要应用是建模 Java 的扩展。由于 FJ 本身非常简洁，它将注意力集中在扩展的基本方面。此外，由于纯 FJ 的类型安全性 (type safety) 证明非常简单，即使是对重要扩展的严格安全性证明也可能仍然是可管理的。最初的 FJ 论文通过用类似 GJ（Bracha、Odersky、Stoutamire 和 Wadler，1998）的泛型类和方法丰富 FJ，展示了其实用性。后续的论文（Igarashi、Pierce 和 Wadler，2001）形式化了原始类型 (raw types)，这是 GJ 引入的一个特性，以便于 Java 程序向 GJ 的演进。Igarashi 和 Pierce（2000）使用 FJ 作为研究 Java 内部类 (inner classes) 特性的基础。FJ 还被用于 Java 的类型保持编译 (type-preserving compilation)（League、Trifonov 和 Shao，2001）和语义基础（Studer，2001）的研究。

设计 FJ 的目标是使其类型安全性的证明尽可能简洁，同时仍能捕获完整 Java 的核心特性的安全性论证的本质。任何使安全性证明变得更长但没有实质性不同的语言特性都可能被省略。

与其同类研究一样，FJ 省略了高级特性，如并发 (concurrency) 和反射 (reflection)。其他在 FJ 中缺失的 Java 特性包括赋值 (assignment)、接口 (interfaces)、方法重载 (overloading)、对 $super$ 的消息 (messages to super)、空指针 (null pointers)、基本类型 (base types)（如 $int$、$bool$ 等）、抽象方法声明 (abstract method declarations)、内部类 (inner classes)、子类字段遮蔽超类字段 (shadowing of superclass fields by subclass fields)、访问控制 (access control)（如 $public$、$private$ 等）以及异常 (exceptions)。FJ 所建模的 Java 特性包括**相互递归的类定义 (mutually recursive class definitions)**、**对象创建 (object creation)**、**字段访问 (field access)**、**方法调用 (method invocation)**、**方法重写 (method override)**、通过 $this$ 的方法递归 (method recursion through this)、**子类型 (subtyping)** 和**类型转换 (casting)**。

**FJ 中的一个关键简化是省略了赋值。**

我们假设对象的字段在其构造函数 (constructor) 中被初始化，之后不再改变。这将 FJ 限制在 Java 的“函数式 (functional)”片段，其中许多常见的 Java 习惯用法（如枚举 (enumerations) 的使用）无法表示。然而，这个片段在计算上是完备的（可以很容易地将 $\lambda$-演算编码到其中），并且足够大，包含有用的程序——例如，Felleisen 和 Friedman 的 Java 教材（1998）中的许多程序都使用纯函数式风格。

---

### **19.2 概述 (Overview)**

在 FJ 中，程序由一组**类定义 (class definitions)** 加上一个要评估的**术语 (term)** 组成，后者对应于完整 Java 中 $main$ 方法的主体。以下是 FJ 中一些典型的类定义：

---

```java
class A extends Object { 
    A() { super(); } 
}

class B extends Object { 
    B() { super(); } 
}

class Pair extends Object {
    Object fst;
    Object snd;
    // 构造函数：
    Pair(Object fst, Object snd) {
        super(); this.fst = fst; this.snd = snd; 
    }
    // 方法定义：
    Pair setfst(Object newfst) {
        return new Pair(newfst, this.snd); 
    } 
}
```

---

**解释：**

- **类 $A$ 和 $B$**：都继承自 $Object$，并且都有一个默认的构造函数，调用了 $super()$。

- **类 $Pair$**：

  - **字段 (Fields)**：

    - $Object$ 类型的 $fst$：表示第一个元素。
    - $Object$ 类型的 $snd$：表示第二个元素。

  - **构造函数 (Constructor)**：

    - 接受两个参数 $Object \; fst$ 和 $Object \; snd$，与字段同名。
    - 调用 $super()$ 初始化超类的字段（在这里，$Object$ 没有字段，所以没有参数）。
    - 使用 $this.fst = fst;$ 和 $this.snd = snd;$ 初始化自己的字段。

  - **方法 $setfst$**：

    - 接受一个参数 $Object \; newfst$。
    - 返回一个新的 $Pair$ 对象，使用 $newfst$ 作为新的 $fst$，$this.snd$ 作为 $snd$。

**注意事项：**

- **语法一致性**：为了语法上的一致性，我们总是包含超类（即使它是 $Object$），总是写出构造函数（即使对于像 $A$ 和 $B$ 这样的简单类），并且在字段访问或方法调用中总是命名接收者（如 $this.snd$），即使接收者是 $this$。

- **构造函数的形式**：构造函数总是采用相同的风格：

  - 对于每个字段都有一个参数，名称与字段相同。
  - 调用 $super$ 构造函数来初始化超类的字段。
  - 然后使用对应的参数初始化剩余的字段。

- **$super$ 和 $=$ 的使用**：在 FJ 程序中，构造函数是唯一出现 $super$ 或 $=$ 的地方。

- **无副作用**：由于 FJ 不提供副作用操作，方法体总是由 $return$ 后跟一个术语组成，如 $setfst()$ 的主体。

**FJ 中的五种术语形式：**

1. **对象创建 (Object creation)**：如 $new \; A()$、$new \; B()$、$new \; Pair(\ldots, \ldots)$。
2. **方法调用 (Method invocation)**：如 $\ldots.setfst(\ldots)$。
3. **字段访问 (Field access)**：在 $setfst$ 方法的主体中，$this.snd$ 是一个字段访问。
4. **类型转换 (Casting)**：稍后讨论。
5. **变量 (Variables)**：如 $newfst$ 和 $this$。

**示例：**

在上述定义的上下文中，以下术语：

$$
\text{new Pair(new A(), new B()).setfst(new B())}
$$

求值为：

$$
\text{new Pair(new B(), new B())}
$$

**类型转换 (Casting)：**

剩下的术语形式是**类型转换**（参见第 15.5 节）。考虑以下术语：

$$
((\text{Pair}) \; \text{new Pair(new Pair(new A(), new B()), new A()).fst}).\text{snd}
$$

它求值为：

$$
\text{new B()}
$$

**解释：**

- **类型转换**：$(\text{Pair}) \; t$，其中 $t$ 是 $\text{new Pair}(\ldots).\text{fst}$，是一个类型转换。

- **为什么需要类型转换？**因为 $t$ 是对字段 $fst$ 的访问，$fst$ 被声明为包含一个 $Object$，而下一个字段访问（$\text{snd}$）只有在 $t$ 是 $Pair$ 时才有效。

- **运行时检查**：在运行时，求值规则检查存储在 $fst$ 字段中的 $Object$ 是否是一个 $Pair$（在本例中，检查通过）。

**省略副作用的好处：**

省略副作用有一个令人愉快的副作用：**求值可以完全在 FJ 的语法中形式化，而无需额外的机制来模拟堆 (heap)**（参见第 13 章）。FJ 有三个基本的计算规则：

1. **字段访问**。
2. **方法调用**。
3. **类型转换**。

回想一下，在 $\lambda$-演算中，应用的求值规则假定函数首先被简化为一个 $\lambda$ 抽象。同样，在 FJ 中，求值规则假定操作的对象首先被简化为一个 $new$ 术语。在 $\lambda$-演算中的口号是“万物皆函数 (everything is a function)”；在这里，是“万物皆对象 (everything is an object)”。

---

**示例：字段访问规则 (E-ProjNew) 的应用：**

$$
\text{new Pair(new A(), new B()).snd} \quad \rightarrow \quad \text{new B()}
$$

**解释：**

- 由于对象构造函数的规范化语法，我们知道构造函数对于每个字段都有一个参数，顺序与字段声明的顺序相同。

- 这里，字段是 $fst$ 和 $snd$，对字段 $snd$ 的访问选择第二个参数。

---

**示例：方法调用规则 (E-InvkNew) 的应用：**

$$
\text{new Pair(new A(), new B()).setfst(new B())} \quad \rightarrow
$$

将参数和接收者替换到方法体中：

$$
\begin{align*}
\text{newfst} &\leftarrow \text{new B()}, \\
\text{this} &\leftarrow \text{new Pair(new A(), new B())} \\
&\text{[方法} \; \text{setfst} \; \text{的主体]} \\
&= \text{new Pair(newfst, this.snd)} \\
&= \text{new Pair(new B(), new Pair(new A(), new B()).snd)}
\end{align*}
$$

**解释：**

- **接收者 (Receiver)**：方法调用的接收者是 $\text{new Pair(new A(), new B())}$。

- **查找方法**：在类 $Pair$ 中查找方法 $setfst$，发现其形式参数为 $newfst$，主体为 $\text{new Pair(newfst, this.snd)}$。

- **替换**：将形式参数替换为实际参数，将特殊变量 $this$ 替换为接收者对象。

- **类似于 $\lambda$-演算的 $\beta$-约简规则 (E-AppAbs)**：关键区别在于接收者的类决定在哪里查找方法主体（支持方法重写 (method override)），以及将接收者替换为 $this$（支持“通过 self 的开放递归”）。

- **没有副作用的影响**：在 FJ 中，如同在 $\lambda$-演算中，如果形式参数在主体中出现多次，可能会导致参数值的重复，但由于没有副作用，这种与标准 Java 语义的差异无法观察到。

---

**示例：类型转换规则 (E-CastNew) 的应用：**

$$
(\text{Pair}) \; \text{new Pair(new A(), new B())} \quad \rightarrow \quad \text{new Pair(new A(), new B())}
$$

**解释：**

- 一旦转换的主体被简化为一个对象，就很容易检查构造函数的类是否是转换目标的子类。

- 如果是（如本例所示），则化简移除类型转换。

- 如果不是，例如 $(\text{A}) \; \text{new B()}$，则没有规则适用，计算被卡住，表示运行时错误。

---

**可能卡住的三种情况：**

1. **尝试访问类未声明的字段**。
2. **尝试调用类未声明的方法（“消息不理解”）**。
3. **尝试转换为对象运行时类的超类以外的类型**。

我们将证明，对于良类型 (well-typed) 程序，前两种情况永远不会发生；对于不包含向下类型转换 (downcasts)（以及没有“愚蠢的类型转换 (stupid casts)”——下面将解释的技术细节）的良类型程序，第三种情况永远不会发生。

---

**求值策略：**

我们采用标准的**按值调用 (call-by-value)** 求值策略。以下是上面第二个示例术语的求值步骤，其中每一步中要简化的下一个子术语已下划线标记。

1. 初始术语：

   $$
   ((\text{Pair}) \; (\underline{\text{new Pair(new Pair(new A(), new B()), new A()).fst}}).\text{snd}
   $$

2. 对 $\text{fst}$ 字段访问求值：

   $$
   ((\text{Pair}) \; \underline{\text{new Pair(new A(), new B())}}).\text{snd}
   $$

3. 进行类型转换：

   $$
   \underline{\text{new Pair(new A(), new B())}}.\text{snd}
   $$

4. 访问 $\text{snd}$ 字段：

   $$
   \text{new B()}
   $$

---

### **19.3 名义和结构类型系统 (Nominal and Structural Type Systems)**

在继续 FJ 的形式化定义之前，我们应该停下来检查 FJ（和 Java）与本书主要关注的类型化 $\lambda$-演算之间的一个基本风格差异。这个差异涉及**类型名称 (type names)** 的地位。

**类型名称在类型系统中的作用：**

- **在之前的章节中**，我们经常为较长或复杂的复合类型定义简短的名称，以提高示例的可读性，例如：

  $$
  \text{NatPair} = \{ \text{fst}:\text{Nat}, \; \text{snd}:\text{Nat} \};
  $$

  这样的定义纯粹是**装饰性的**：名称 $\text{NatPair}$ 只是 $\{ \text{fst}:\text{Nat}, \; \text{snd}:\text{Nat} \}$ 的简单缩写，两者在任何上下文中都是可以互换的。我们对演算的形式化展示忽略了这些缩写。

- **相反，在 Java 中**，以及许多广泛使用的编程语言中，**类型定义起着更为重要的作用**。在 Java 程序中使用的每个复合类型都有一个名称，当我们声明局部变量、字段或方法参数的类型时，我们总是通过给出名称来完成。像 $\{ \text{fst}:\text{Nat}, \; \text{snd}:\text{Nat} \}$ 这样的“裸”类型根本不能出现在这些位置。

**类型名称在 Java 子类型关系中的作用：**

- 每当引入一个新名称（在类或接口定义中）时，程序员显式地声明新类型扩展 (extends) 的类和接口（或者在新类与已有接口的情况下，实现 (implements)）。编译器检查这些声明，以确保新类或接口提供的功能确实扩展了每个超类或超接口的功能——这个检查对应于类型化 $\lambda$-演算中的记录子类型 (record subtyping)。

- **子类型关系**现在定义在类型名称之间，作为声明的直接子类型关系的自反 (reflexive) 和传递 (transitive) 闭包。如果一个名称未被声明为另一个的子类型，那么它就不是。

**名义 (Nominal) 和结构 (Structural) 类型系统：**

- **名义类型系统 (Nominal type systems)**：如 Java 的类型系统，名称是重要的，子类型是显式声明的。

- **结构类型系统 (Structural type systems)**：如本书中的大多数类型系统，名称并不重要，子类型直接定义在类型的结构上。

**名义类型系统的优点和缺点：**

- **优点**：

  1. **类型名称在运行时也有用**：大多数名义语言为每个运行时对象附加一个包含其类型名称的头字 (header word)，具体表示为指向描述该类型并给出其直接超类型指针的运行时数据结构的指针。这些**类型标签 (type tags)** 对于各种用途都很方便，包括：

     - **运行时类型测试**：如 Java 的 $instanceOf$ 测试和向下类型转换 (downcasting) 操作。
     - **打印**：用于调试或日志记录。
     - **将数据结构编组 (marshaling)** 为用于文件存储或网络传输的二进制形式。
     - **反射机制 (reflective facilities)**：允许程序动态地检查给定对象的字段和方法。

     在结构系统中也可以支持运行时类型标签（参见 Glew，1999；League、Shao 和 Trifonov，1999；League、Trifonov 和 Shao，2001；以及其中引用的文献），但它们构成了一个额外的、独立的机制；在名义系统中，运行时标签与编译时类型一致。

  2. **递归类型的自然处理**：名义系统提供了对**递归类型 (recursive types)**（其定义中提到自身的类型）的自然直观的处理。（我们将在第 20 章详细讨论递归类型。）在严肃的编程中，这些类型无处不在，需要描述诸如列表 (lists) 和树 (trees) 等常见结构。名义类型系统以最直接的方式支持它们：在其自身的声明中引用 $List$ 与引用任何其他类型一样容易。甚至相互递归的类型 (mutually recursive types) 也是直接的。

     - **在结构类型系统中**，递归类型也可以处理。实际上，具有结构化类型的高级语言（如 ML）通常将递归类型与其他特性“捆绑”在一起，因此对程序员来说，它们与名义语言中的一样自然和易于使用。

     - **但在用于基础性目的（如类型安全性证明）的演算中**，严格处理递归类型所需的机制可能相当繁重，特别是如果允许相互递归类型的话。在名义系统中，递归类型基本上是免费提供的，这是一个明显的好处。

  3. **子类型检查的简单性**：在名义系统中，检查一个类型是否是另一个类型的子类型几乎是微不足道的。当然，编译器仍然需要验证声明的子类型关系是安全的，这本质上重复了结构子类型关系，但这项工作只需要对每个类型在其定义时完成一次，而不是在每次子类型检查期间。这使得在名义类型系统的类型检查器中实现良好的性能更容易。

- **缺点**：

  - **定义和证明可能更冗长**：在名义系统中，我们总是在某个全局的类型名称和关联定义的集合中工作。这倾向于使定义和证明更加冗长。

- **其他方面**：

  - **防止“虚假替换 (spurious subsumption)”**：经常有人提到显式子类型声明的另一个优点是它们可以防止“虚假替换”，即类型检查器未能拒绝在期望完全不同但结构上兼容的类型的位置使用某个类型的值。这一点比上述优点更具争议性，因为还有其他（可以说更好）的方式来防止虚假替换，例如使用单构造函数数据类型 (single-constructor datatypes)（见第 138 页）或抽象数据类型 (abstract data types)（见第 24 章）。

**为什么研究界倾向于结构类型系统：**

- **简洁和优雅**：至少在没有递归类型的情况下，结构系统在某种程度上更简洁和优雅。在结构环境中，类型表达式是一个封闭的实体：它携带了理解其含义所需的所有信息。

- **研究重点**：研究文献倾向于关注更高级的特性——特别是强大的类型抽象机制（参数多态性 (parametric polymorphism)、抽象数据类型、用户定义的类型算子、函子 (functors) 等）——以及体现这些特性的语言，如 ML 和 Haskell。不幸的是，这些特性在名义系统中并不太适合。

- **泛型类型的处理**：例如，像 $List(T)$ 这样的类型似乎是不可简化的复合类型——在程序的某个地方只有一个关于构造函数 $List$ 的定义，我们需要引用这个定义来查看 $List(T)$ 的行为，因此我们不能将 $List(T)$ 视为一个原子名称。

- **混合系统的复杂性**：一些名义语言已被扩展为具有这样的“泛型”特性（Myers、Bank 和 Liskov，1997；Agesen、Freund 和 Mitchell，1997；Bracha、Odersky、Stoutamire 和 Wadler，1998；Cartwright 和 Steele，1998；Stroustrup，1997），但这种扩展的结果不再是纯粹的名义系统，而是两种方法的复杂混合体。

- **因此，具有高级类型特性的语言的设计者倾向于采用结构化方法**。

---

**总结：**

- **名义类型系统**在主流编程语言中是常态，因为其类型标签的通用性和递归类型的简单处理。

- **结构类型系统**在研究界中更受关注，因为它们在没有递归类型的情况下更简洁优雅，并且更适合高级类型抽象特性。

- **两种系统的关系**仍然是正在进行的研究课题。

### ---------------------------

继续上一部分的讲解，我们将详细讨论 **19.4 定义 (Definitions)** 中剩余的内容，并解释相关的概念。

---

### **19.4.3 练习 [推荐，««« 3]**

**任务：**

- 在 FJ 中添加赋值操作，将新值分配给对象的字段。
- 使用第 13 章中对引用的处理作为模型。

**解答：**

为了在 FJ 中添加赋值操作，需要引入可变状态。以下是实现步骤：

1. **引入引用类型 (References)：**

   - 将对象的字段从不可变的值类型更改为可变的引用类型。
   - 定义引用类型，例如 $Ref C$，表示指向类型为 $C$ 的对象的引用。

2. **修改字段声明：**

   - 将字段类型从 $C f;$ 修改为 $Ref C f;$，表示字段是对对象的引用。

3. **添加赋值语法：**

   - 在术语的语法中添加赋值操作，例如 $t.f = t;$，表示将右侧的值赋给对象 $t$ 的字段 $f$。

4. **添加相应的求值规则：**

   - 定义赋值操作的求值规则，使其能够在运行时更新对象的字段值。

5. **更新类型规则：**

   - 为赋值操作添加类型规则，确保赋值的类型正确性。
   - 检查被赋值的字段和赋值的值是否具有兼容的类型。

**示例：**

```java
// 修改后的字段声明
class Pair extends Object {
    Ref Object fst;
    Ref Object snd;
    // 构造函数和方法保持不变
}

// 添加赋值操作的语法
t ::= ... | t.f = t

// 添加赋值操作的求值规则
(E-Assign)
(new C(v)).f_i = v' --> (new C(v[...v_i := v']))

// 添加赋值操作的类型规则
(T-Assign)
Γ ⊢ t0 : C0   fields(C0) = ... , (Ref C_i f_i), ...
Γ ⊢ t : C    C <: C_i
------------------------------
Γ ⊢ t0.f_i = t : C
```

**解释：**

- **求值规则 (E-Assign)：** 在对象 $new C(v)$ 上执行字段赋值操作，将字段 $f_i$ 的值更新为 $v'$。
- **类型规则 (T-Assign)：** 确保被赋值的字段 $f_i$ 是类型 $Ref C_i$，赋值的值 $t$ 的类型 $C$ 是 $C_i$ 的子类型。

---

### **19.4.4 练习 [««« 3]**

**任务：**

- 将 Java 的 $raise$ 和 $try$ 形式的类似物扩展到 FJ 中。
- 使用第 14 章中对异常的处理作为模型。

**解答：**

为了在 FJ 中添加异常处理机制，需要引入以下内容：

1. **引入异常的语法：**

   - 添加 $throw t;$ 表示抛出异常 $t$。
   - 添加 $try t_catch catch (C x) { t_catch }$ 表示尝试执行 $t_try$，如果发生类型为 $C$ 的异常，则执行 $t_catch$。

2. **修改术语的语法：**

   ```java
   t ::= ... | throw t | try t catch (C x) { t }
   ```

3. **添加异常的求值规则：**

   - 定义异常的传播规则，如果在 $t_try$ 中抛出异常，则捕获并处理。
   - 如果没有捕获到异常，则继续向外层传播。

4. **添加类型规则：**

   - 为 $throw$ 和 $try-catch$ 添加类型规则，确保异常的类型和捕获器的类型一致或兼容。

**示例：**

```java
// 添加异常的语法
t ::= ... | throw t | try t catch (C x) { t }

// 添加异常的求值规则
(E-Throw)
t --> t'
----------------
throw t --> throw t'

(E-TryCatch)
try throw v catch (C x) { t_catch } --> [x ↦ v] t_catch

(E-Try)
t_try --> t_try'
---------------------------------
try t_try catch (C x) { t_catch } --> try t_try' catch (C x) { t_catch }

// 添加异常的类型规则
(T-Throw)
Γ ⊢ t : C
----------------
Γ ⊢ throw t : C

(T-TryCatch)
Γ ⊢ t_try : C
Γ, x:C' ⊢ t_catch : C
C' <: C
------------------------------
Γ ⊢ try t_try catch (C' x) { t_catch } : C
```

**解释：**

- **求值规则：**
  - $(E-Throw)$：对 $throw t$ 中的 $t$ 进行求值。
  - $(E-TryCatch)$：如果 $try$ 块中抛出异常，并且异常类型匹配，则执行 $catch$ 块。
  - $(E-Try)$：对 $try$ 块中的 $t_try$ 进行求值。

- **类型规则：**
  - $(T-Throw)$：$throw t$ 的类型是异常对象的类型 $C$。
  - $(T-TryCatch)$：$try-catch$ 表达式的类型与 $try$ 块的类型一致，$catch$ 块中的异常类型 $C'$ 必须是 $C$ 的子类型。

---

### **19.4.5 练习 [«« 3]**

**任务：**

- FJ 和完整的 Java 一样，在类型关系中采用了算法式的呈现形式。没有使用子类型规则；相反，其他规则的前提中包含了子类型检查。
- 能否将系统重新表述为更声明式的风格，放弃大部分或全部这些前提，转而使用单一的子类型规则？

**解答：**

- **思路：**

  - 引入一个通用的**子类型规则 (Subsumption Rule)**，允许在任何上下文中进行类型提升。
  - 重写类型规则，去除显式的子类型检查，将子类型关系的处理交给子类型规则。

- **实现：**

  - **添加子类型规则：**

    ```java
    (T-Sub)
    Γ ⊢ t : C    C <: D
    -------------------------
    Γ ⊢ t : D
    ```

  - **修改其他类型规则：**

    - 移除规则中的子类型检查，例如在方法调用 $(T-Invk)$ 中，去除 $C <: D$ 的前提。

  - **结果：**

    - 类型系统变得更加声明式，类型提升由子类型规则统一处理。
    - 在类型推导过程中，可以随时应用 $(T-Sub)$ 规则进行类型转换。

---

### **19.4.6 练习 [«««]**

**任务：**

1. 展示如何以 Java 的风格将接口扩展到 FJ 中。
2. 展示在存在接口的情况下，子类型关系不一定在连接下封闭。
3. Java 的条件表达式的类型规则是什么？它是否合理？

**解答：**

1. **将接口扩展到 FJ：**

   - **添加接口的语法：**

     ```java
     I ::= interface declarations:
     interface I extends I { C m(C x); }
     ```

   - **修改类声明：**

     - 类可以实现多个接口：

       ```java
       class C extends D implements I { ... }
       ```

   - **修改子类型关系：**

     - 子类型关系包括类的继承和接口的实现。

2. **子类型关系不在连接下封闭：**

   - **示例：**

     - 假设有两个接口 $I1$ 和 $I2$，类 $C$ 实现了 $I1$，类 $D$ 实现了 $I2$。
     - $C$ 和 $D$ 之间没有子类型关系。
     - 在条件表达式中，如果 $t1$ 的类型是 $C$，$t2$ 的类型是 $D$，则无法确定条件表达式的类型。

3. **Java 的条件表达式的类型规则：**

   - **规则：**

     - 如果 $t1$ 的类型是 $C1$，$t2$ 的类型是 $C2$，那么条件表达式的类型是 $C$，其中 $C$ 是 $C1$ 和 $C2$ 的最近公共父类型 (least common supertype)。

   - **合理性：**

     - 在存在接口和多重继承的情况下，最近公共父类型可能不存在或不唯一，因此 Java 的条件表达式类型规则在某些情况下可能导致类型不精确。

---

### **19.4.7 练习 [«««]**

**任务：**

- FJ 包含了 Java 的 $this$ 关键字，但省略了 $super$。
- 展示如何添加 $super$。

**解答：**

- **思路：**

  - 将 $super$ 视为特殊的变量，允许在子类的方法中调用超类的方法。

- **实现步骤：**

  1. **在方法体中引入 $super$：**

     - 将 $super$ 作为隐式绑定的变量，类似于 $this$。

  2. **修改方法调用规则：**

     - 在方法调用中，如果接收者是 $super$，则在父类中查找方法，而不是当前类。

  3. **修改求值规则：**

     - 在方法调用的求值规则中，处理 $super$ 的情况，确保正确调用超类的方法。

---

### **19.5 性质 (Properties)**

**类型保持性定理：**

- **定理 19.5.1（类型保持）：**

  - 如果 $Γ ⊢ t : C$ 且 $t --> t'$，则存在 $C'$，使得 $Γ ⊢ t' : C'$ 且 $C' <: C$。

- **证明思路：**

  - 对于每个求值规则，检查在类型规则下类型是如何变化的。
  - 使用归纳法，证明在每一步求值后，术语的类型要么保持不变，要么变为原类型的子类型。

---

**进展性定理：**

- **定理 19.5.4（进展）：**

  - 如果 $t$ 是封闭的、良类型的正常形式，则要么 $t$ 是一个值，要么存在一个评价上下文 $E$，使得 $t = E[(C)(new D(v))]$，且 $D$ 不是 $C$ 的子类型。

- **解释：**

  - 良类型的程序要么可以继续求值，要么在尝试执行无效的向下类型转换时被卡住。

---

**19.5.5 练习 [««« 3]**

**任务：**

- 从一个 λ-演算类型检查器开始，构建一个轻量级 Java 的类型检查器和解释器。

**解答：**

- **步骤：**

  1. **定义抽象语法树 (AST)：**

     - 为 FJ 的语法定义数据结构，包括类声明、方法、构造函数、术语等。

  2. **实现类型检查器：**

     - 根据类型规则，实现类型检查函数，验证程序的类型正确性。

  3. **实现解释器：**

     - 根据求值规则，实现术语的求值函数，模拟程序的执行。

  4. **测试：**

     - 编写示例程序，测试类型检查器和解释器的功能。

---

**19.5.6 练习 [«««« 3]**

**任务：**

- 原始的 FJ 论文还以 GJ 的风格形式化了多态类型。
- 将练习 19.5.5 中的类型检查器和解释器扩展，包含这些特性。

**解答：**

- **要求预备知识：**

  - 在尝试此练习之前，需要阅读第 23、25、26 和 28 章，了解多态类型和泛型的概念。

- **实现步骤：**

  1. **扩展语法：**

     - 添加泛型类和方法的语法，支持类型参数。

  2. **修改类型规则：**

     - 引入类型变量，修改类型检查规则，处理多态类型。

  3. **修改求值规则：**

     - 在求值过程中，处理类型参数的替换和传递。

  4. **更新类型检查器和解释器：**

     - 根据新的规则，更新代码，实现对泛型的支持。

---

### **19.6 编码与原生对象 (Encodings vs. Primitive Objects)**

**总结：**

- 本章展示了处理简单面向对象语言的语义和类型的两种对比方法：

  1. **编码方法：**

     - 使用简单类型的 λ-演算结合记录、引用和子类型，来编码对象、类和继承。
     - 这种方法揭示了封装和重用的基本机制，有助于理解对象与其他语言特性的交互。

  2. **原生对象方法：**

     - 将对象和类作为原生机制，直接描述简单语言的操作语义和类型行为。
     - 这种方法更适合用于高级语言设计和文档编制。

- **两种方法的价值：**

  - **编码方法**有助于理解编译器如何将对象翻译成更低级的语言，以及对象与其他特性的交互。
  - **原生对象方法**允许直接讨论对象的操作语义和类型行为，更适合用于高层次的语言设计。

- **理想情况下，我们希望拥有两种视角：**

  - 一个高级语言，包括对象、类等原生特性，具有自己的类型规则和操作语义。
  - 一个从高级语言到更低级语言（仅包含记录和函数）的翻译，以及翻译的正确性证明，确保翻译保持了高级语言的求值和类型性质。

---

### **19.7 注记 (Notes)**

- 本章改编自 Igarashi、Pierce 和 Wadler（1999）的原始 FJ 文章。

- **主要区别：**

  - 本章使用了与本书其他部分一致的按值调用操作语义，而原始文章使用了非确定性的 β-约简关系。

- **关于 Java 子集的类型安全性证明：**

  - 许多论文证明了 Java 子集的类型安全性，采用了不同的方法和模型。
  - FJ 的目标是选择一个尽可能小的核心演算，仅捕获与特定任务相关的 Java 特性。

- **其他研究：**

  - 有关对象、类和继承的形式化，存在许多研究工作，包括基于类和基于对象的方法。
  - 这些研究有助于深入理解面向对象语言的基础和设计。

---

**结束语：**

通过本章的学习，我们深入了解了轻量级 Java (Featherweight Java) 的形式化定义，包括其语法、求值规则和类型系统。我们探讨了名义类型系统与结构类型系统的区别，以及在语言设计和类型安全性证明中的应用。这为我们理解面向对象语言的核心机制和形式化奠定了基础。

### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------
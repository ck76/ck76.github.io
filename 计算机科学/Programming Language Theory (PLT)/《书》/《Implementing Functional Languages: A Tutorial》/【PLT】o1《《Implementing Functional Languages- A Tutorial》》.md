
 #  
 Thought for 23 seconds
**概览**

您提供的内容是《Implementing Functional Languages: A Tutorial》一书的前言和目录。这本书由西蒙·佩顿·琼斯（Simon L Peyton Jones）和大卫·莱斯特（David R Lester）撰写，旨在通过实践的方法，深入探讨非严格（惰性）函数式语言的实现，特别是通过惰性图归约的方法。书中不仅提供了各种实现技术的抽象描述，还包含了完整的工作原型代码，帮助读者开发、修改和实验非严格函数式语言的编译器和解释器。

**详细解析**

**前言**

前言部分介绍了本书的目的、特色以及内容概览。作者强调，本书采用了一种实践性的方式来帮助读者理解非严格函数式语言的实现。与传统书籍仅提供抽象描述不同，本书提供了完整的工作原型代码，并通过一系列改进，引导读者逐步深入了解实现的细节。

**书的目标**

- **实践性**：通过提供完整的代码示例，帮助读者实际动手，实现非严格函数式语言。
- **深入理解**：通过开发和修改编译器，读者可以深入理解非严格函数式语言的实现机制。
- **经验积累**：帮助读者积累编写大型函数式程序的经验。
**内容结构**

本书主要围绕一个名为**Core语言**的小型函数式语言展开。Core语言被设计得尽可能简单，方便实现，但又足够表达力，可以有效地表示现代非严格函数式语言的特性。

**第一章：Core语言**

- **简介**：介绍Core语言的设计理念和基本特性。
- **语法**：详细描述Core语言的语法结构。
- **数据类型**：定义用于表示Core语言的各种数据类型。
- **标准前导（Prelude）**：提供一小段标准库代码，供Core语言程序使用。
- **美化打印器和解析器**：开发用于Core语言的代码格式化工具和语法解析器。
**附录B**提供了一些用于测试的Core语言示例程序。

**主要实现内容**

书中详细讨论了四种不同的Core语言实现方法，每一种方法都在不同的章节中进行了深入探讨。

1. **第二章：模板实例化（Template Instantiation）**
- **简介**：讨论最直接的实现方法，基于模板实例化的图归约。
- **实现细节**：通过状态转换系统，详细描述了模板实例化的执行过程。
2. **第三章：G-机器（G-Machine）**
- **简介**：介绍G-机器的基本概念和工作原理。
- **编译过程**：展示如何将Core程序编译成G-代码（G-code）指令序列。
- **执行模型**：详细描述G-机器的执行模型和指令集。
3. **第四章：三指令机器（TIM: Three Instruction Machine）**
- **简介**：介绍TIM的设计理念，其求值模型与G-机器有显著差异。
- **实现细节**：深入讨论TIM的求值模型和指令执行过程。
4. **第五章：并行G-机器（Parallel G-Machine）**
- **简介**：讨论并行执行的概念，介绍如何实现并行的G-机器。
- **实现挑战**：探讨在并行环境下实现非严格函数式语言的挑战和解决方案。
**第六章：Lambda提升（Lambda Lifting）**

- **背景**：由于Core语言不支持局部函数定义，需要通过Lambda提升将局部函数转换为全局函数。
- **实现过程**：详细描述了Lambda提升的实现步骤和技术细节。
- **完全惰性（Full Laziness）**：探讨了完全惰性的概念，并展示如何在单独的阶段实现它。
**附录A：实用工具模块**

- **堆类型**：定义了堆的数据结构，用于管理内存分配。
- **关联列表类型**：提供键值对的管理，实现符号表等功能。
- **其他实用函数**：包含了一些在全书中使用的辅助函数和类型。
**使用的原型语言**

作者选择使用函数式语言**Miranda**来编写书中的所有代码，实现了代码的可执行性。这样做的优点包括：

- **快速原型开发**：函数式语言适合快速原型开发，能专注于核心逻辑。
- **实践经验**：帮助读者积累使用函数式语言进行大型项目开发的经验。
- **代码清晰**：函数式语言的表达能力强，代码更简洁明了。
**未涵盖的内容**

- **前端编译器**：本书没有讨论如何将完整的函数式语言（如Miranda）程序翻译成Core语言。
- **类型检查**：没有涉及对程序进行类型检查的过程。
- **形式化证明**：作者没有提供Core程序与其实现之间等价性的形式证明。
**与《The Implementation of Functional Programming Languages》的关系**

- **区别**：Simon Peyton Jones之前的著作更偏重理论，而本书更注重实践，提供了可执行的代码和详细的实现过程。
- **目标**：本书旨在使学生仅通过本书就能学习和理解非严格函数式语言的实现，无需参考其他资料。
**全面详尽的总结**

《Implementing Functional Languages: A Tutorial》是一部深入探讨非严格函数式语言实现的实践指南。通过使用一个简化的Core语言，作者逐步引导读者了解从基础到高级的实现技术，包括：

- **模板实例化**：最直接的实现方式，利用模板实例化进行图归约。
- **G-机器**：将Core程序编译成G-code，介绍了指令序列的生成和执行。
- **三指令机器（TIM）**：提供了与G-机器不同的实现方法，探讨了不同的求值模型。
- **并行G-机器**：探讨了在并行计算环境下，实现非严格函数式语言的挑战和方法。
此外，第六章深入讨论了Lambda提升和完全惰性的问题，解决了Core语言缺乏局部函数定义的限制，并展示了如何在单独的编译阶段实现完全惰性，从而提高程序的效率。

作者使用Miranda语言来实现所有的示例代码，强调了函数式语言在快速原型开发中的优势。这种选择不仅使得代码更加简洁明了，也使读者能够专注于理解实现的核心逻辑，而不被语言的细节所干扰。

尽管本书主要关注编译器的后端实现，但通过详细的讲解、完整的代码示例和实践性的指导，读者可以深入理解非严格函数式语言的实现机制，积累宝贵的实践经验。

总的来说，这本书是希望深入学习函数式语言实现的读者的宝贵资源。它不仅提供了理论知识，还通过实践帮助读者建立对非严格函数式语言实现的全面理解，为未来的研究和开发打下坚实的基础。
 #  
 Thought for 8 seconds
**概览**

您提供的内容是《Implementing Functional Languages: A Tutorial》一书的前言和目录。这本书由西蒙·佩顿·琼斯（Simon L. Peyton Jones）和大卫·R. 莱斯特（David R. Lester）撰写，旨在通过实践的方法，引导读者深入理解非严格函数式语言的实现，特别是通过惰性图归约的方法。

书中不仅提供了各种实现技术的抽象描述，还包含了完整的工作原型代码，帮助读者开发、修改和实验非严格函数式语言的编译器和解释器。作者强调，这本书的独特之处在于它不仅仅是阅读材料，而且是可以执行的代码。通过让读者实际动手实现各个主要方法的工作原型，读者可以更深入地理解这些实现技术。

**详细解析**

### **前言**

**目的和特色**

前言部分介绍了本书的目标、特色和内容概览。作者明确表示，这本书的目的是提供一种实践性的途径，帮助读者理解非严格（惰性）函数式语言的实现，特别是通过惰性图归约的方法。

主要特色包括：

- **实践导向**：与仅提供抽象描述的传统书籍不同，本书提供了完整的工作原型代码。读者可以通过开发、修改和实验这些编译器和解释器，深入理解实现的细节。
- **可执行的代码**：书中的代码是可执行的，不仅仅是理论上的示例。这使得读者可以真正地“执行”这本书，而不仅仅是阅读它。
- **逐步改进**：作者通过一系列的改进，引导读者逐步深入了解实现的细节，从而加深对非严格函数式语言实现的理解。
**内容概览**

书中主要围绕一个名为**Core语言**的小型函数式语言展开。Core语言被设计得尽可能简单，方便实现，但又足够强大，可以有效地表示现代非严格函数式语言的特性。这样，读者可以专注于理解实现的核心概念，而不被复杂的语言特性分心。

**第一章：Core语言**

- **1.1 Core语言概览**：介绍Core语言的设计理念和基本特性，解释为什么选择这样一个简化的语言作为研究对象。
- **1.2 Core语言的语法**：详细描述Core语言的语法结构，包括变量、函数、表达式、数据类型等。
- **1.3 Core语言的数据类型**：定义用于表示Core语言的各种数据类型，这些数据类型将用于实现编译器和解释器。
- **1.4 小型标准前导（Prelude）**：提供一小段标准库代码，供Core语言程序使用。这部分代码包含了一些基本函数和定义，帮助读者更好地理解和使用Core语言。
- **1.5 Core语言的美化打印器**：开发用于Core语言的代码格式化工具，使得输出的代码更易读，便于调试和分析。
- **1.6 Core语言的解析器**：实现Core语言的语法解析器，能够将源代码转换为内部表示形式，为后续的编译和执行做准备。
**附录B：Core语言示例程序**

- 提供了一系列的Core语言程序，这些程序可以用作测试程序，帮助读者在实践中理解Core语言的特性和实现。
**主要实现内容**

书中详细讨论了四种不同的Core语言实现方法，每一种方法都在不同的章节中进行了深入探讨。每个实现都包括两个主要部分：编译器和机器解释器。编译器将Core语言程序转换为适合机器解释器执行的形式；机器解释器则模拟编译后程序的执行。

**第二章：模板实例化（Template Instantiation）**

- **2.1 模板实例化回顾**：讨论最直接的实现方法，基于模板实例化的图归约。介绍模板实例化的基本概念和工作原理。
- **2.2 状态转换系统**：引入状态转换系统的概念，作为描述解释器执行过程的工具。这有助于清晰地理解程序的执行流程。
- **2.3 标记1：最小化的模板实例化图归约器**：实现一个最基本的模板实例化图归约器，为后续的改进奠定基础。
- **2.4 标记2：处理let（rec）表达式**：扩展基本实现，添加对let和letrec表达式的支持。
- **2.5 标记3：添加更新机制**：介绍如何在实现中添加更新机制，以提高执行效率。
- **2.6 标记4：添加算术运算**：在实现中加入对算术运算的支持，丰富语言的表达能力。
- **2.7 标记5：结构化数据**：添加对数据结构的支持，例如列表和元组。
- **2.8 可替代的实现†**：讨论其他可能的实现方式，提供不同的视角。
- **2.9 垃圾回收†**：介绍垃圾回收的概念和在实现中的应用，帮助管理内存。
**第三章：G-机器（G-Machine）**

- **3.1 G-机器介绍**：介绍G-机器的基本概念、历史背景和工作原理。
- **3.2 构建模板的代码序列**：展示如何为构建模板生成代码序列，解释G-机器的指令集和操作方式。
- **3.3 标记1：最小化的G-机器**：实现一个最基本的G-机器，为后续的扩展和优化打下基础。
- **3.4 标记2：实现惰性求值**：使G-机器支持惰性求值，提高语言的表达能力和执行效率。
- **3.5 标记3：处理let（rec）表达式**：添加对let和letrec表达式的支持，使得G-机器能够处理更复杂的程序结构。
- **3.6 标记4：添加原始操作**：在实现中加入对原始操作（如基本算术运算）的支持。
- **3.7 标记5：改进算术处理**：优化对算术运算的处理，提高执行效率。
- **3.8 标记6：添加数据结构**：支持更复杂的数据结构，例如列表、元组和用户定义的类型。
- **3.9 标记7：进一步改进**：讨论其他可能的改进方向和优化策略。
- **3.10 结论**：总结G-机器的实现，讨论其优点和局限性。
**第四章：三指令机器（TIM：Three Instruction Machine）**

- **4.1 背景：TIM的工作原理**：介绍TIM的设计理念和求值模型，其与G-机器有显著的差异。
- **4.2 标记1：最小化的TIM**：实现一个最基本的TIM，展示其核心概念和执行流程。
- **4.3 标记2：添加算术运算**：扩展TIM，添加对算术运算的支持。
- **4.4 标记3：处理let（rec）表达式**：使TIM能够处理let和letrec表达式，增强其功能。
- **4.5 标记4：添加更新机制**：引入更新机制，提高TIM的执行效率。
- **4.6 标记5：结构化数据**：支持复杂的数据结构，丰富TIM的表达能力。
- **4.7 标记6：常量应用形式和代码存储†**：讨论常量应用形式（CAF）和代码存储的管理。
- **4.8 总结**：总结TIM的实现，讨论其与G-机器的异同、优点和不足。
**第五章：并行G-机器（Parallel G-Machine）**

- **5.1 引言**：讨论并行执行的概念，介绍在非严格函数式语言中实现并行性的挑战。
- **5.2 标记1：最小化的并行G-机器**：实现一个基本的并行G-机器，展示其核心概念。
- **5.3 标记2：求值后终止模型**：介绍一种求值后终止（evaluate-and-die）的模型，探讨线程管理和同步机制。
- **5.4 标记3：现实的并行G-机器**：扩展实现，使其更加接近现实中的并行执行环境。
- **5.5 标记4：改进阻塞处理**：优化对阻塞操作的处理，提高并行执行的效率。
- **5.6 结论**：总结并行G-机器的实现，讨论并行执行的优点、挑战和未来发展方向。
**第六章：Lambda提升（Lambda Lifting）**

- **6.1 引言**：解释为什么需要Lambda提升，由于Core语言不支持局部函数定义，需要通过Lambda提升将局部函数转换为全局函数。
- **6.2 改进expr数据类型**：修改表达式的数据类型，以支持Lambda提升过程中的变化。
- **6.3 标记1：简单的Lambda提升器**：实现一个基本的Lambda提升器，展示其核心原理和操作。
- **6.4 标记2：改进简单的Lambda提升器**：对基本实现进行优化，解决一些潜在的问题。
- **6.5 标记3：Johnsson风格的Lambda提升**：介绍一种更高级的Lambda提升方法，基于Johnsson的工作。
- **6.6 标记4：独立的完全惰性传递**：将完全惰性（Full Laziness）作为单独的编译阶段，实现更高效的代码。
- **6.7 标记5：完全惰性的改进**：对完全惰性的实现进行进一步优化。
- **6.8 标记6：依赖性分析†**：讨论如何进行依赖性分析，以支持更复杂的Lambda提升。
- **6.9 结论**：总结Lambda提升的实现，讨论其重要性和对编译器优化的影响。
**附录A：实用工具模块**

- **A.1 堆类型**：定义了堆的数据结构，用于管理内存分配，支持垃圾回收和内存优化。
- **A.2 关联列表类型**：提供键值对的管理，实现符号表、环境等功能。
- **A.3 生成唯一名称**：提供生成唯一变量名的函数，避免命名冲突。
- **A.4 集合**：定义集合类型和相关操作，用于处理变量集合、依赖关系等。
- **A.5 其他有用的函数定义**：包含了一些在全书中使用的辅助函数和类型。
**附录B：Core语言示例程序**

- **B.1 基本程序**：提供简单的示例程序，帮助读者理解Core语言的基本语法和特性。
- **B.2 let和letrec**：展示使用let和letrec表达式的示例，帮助理解变量绑定和递归定义。
- **B.3 算术运算**：提供包含算术运算的示例程序，展示如何在Core语言中进行数值计算。
- **B.4 数据结构**：展示使用列表、元组等数据结构的示例，帮助理解Core语言对数据结构的支持。
**使用的原型语言**

作者选择使用函数式语言**Miranda**来编写书中的所有代码，实现了代码的可执行性。这种选择的原因和优点包括：

- **快速原型开发**：函数式语言适合快速原型开发，能够专注于实现的核心逻辑，而不被底层细节所困扰。
- **实践经验**：通过使用Miranda，读者可以积累使用函数式语言进行大型项目开发的经验，了解函数式编程的优势和挑战。
- **代码清晰简洁**：函数式语言的高表达能力使得代码更加简洁明了，易于阅读和理解。
**代码表示方式**

- **代码格式**：Miranda代码使用打字机字体（typewriter font）显示，采用“反向注释约定”（inverse comment convention）。代码行以`>`开头，表示这是可执行的Miranda代码。例如：
```perl
> length [] = 0
> length (x:xs) = 1 + length xs
```
- **可执行的文档**：由于代码直接包含在文档中，并且使用了Miranda的注释约定，因此整个文档实际上是可执行的。这意味着读者可以直接运行文档中的代码，验证其功能。
**预定义的标准函数**

- Miranda提供了一系列预定义的标准函数，供用户直接使用。
- 在书中，作者使用了这些标准函数，并在需要时引用了Miranda的在线手册，以获取详细信息。
**未涵盖的内容**

- **前端编译器**：本书主要关注编译器的后端实现，没有讨论如何将完整的函数式语言（如Miranda）程序翻译成Core语言。
- **类型检查**：没有涉及对程序进行类型检查的过程。
- **形式化证明**：作者没有提供Core程序与其实现之间等价性的形式证明。虽然进行这样的证明是有意义的，但难度较大，目前只有少数工作（如[Lester 1988]）提供了完整的证明。
**与《The Implementation of Functional Programming Languages》的关系**

- **区别**：Simon Peyton Jones之前的著作《The Implementation of Functional Programming Languages》（1987年）涵盖了类似的内容，但风格上更偏重理论和抽象。
- **目标**：本书旨在使读者仅通过本书就能学习和理解非严格函数式语言的实现，无需参考其他资料。
- **范围差异**：本书的范围更为专注，主要对应于之前著作的第2和第3部分。之前著作的第1部分，讨论如何将高级函数式语言翻译成核心语言，则未在本书中涉及。
**全面详尽的总结**

《Implementing Functional Languages: A Tutorial》是一部深入探讨非严格函数式语言实现的实践指南。通过使用一个简化的**Core语言**，作者逐步引导读者了解从基础到高级的实现技术，包括模板实例化、G-机器、三指令机器（TIM）和并行G-机器等。

**核心内容**

1. **模板实例化（Template Instantiation）**：作为最直接的实现方式，模板实例化利用图归约技术，实现了对非严格函数式语言的求值。作者详细介绍了模板实例化的基本原理、状态转换系统以及如何处理let和letrec表达式、算术运算和数据结构等。
2. **G-机器（G-Machine）**：G-机器是一个用于执行非严格函数式语言的抽象机器。作者展示了如何将Core程序编译成G-代码（G-code），详细描述了G-机器的指令集、执行模型以及如何实现惰性求值、原始操作和数据结构等。
3. **三指令机器（TIM）**：TIM提供了与G-机器不同的实现方法，其求值模型基于不同的概念。作者深入讨论了TIM的设计理念、执行流程以及如何处理算术运算、let（rec）表达式、更新机制和数据结构等。
4. **并行G-机器（Parallel G-Machine）**：随着并行计算的兴起，作者探讨了在并行环境下实现非严格函数式语言的挑战。通过对并行G-机器的实现，作者讨论了线程管理、同步机制、阻塞处理等关键问题。
**Lambda提升和完全惰性**

由于Core语言不支持局部函数定义，作者在第六章深入讨论了**Lambda提升（Lambda Lifting）**和**完全惰性（Full Laziness）**的问题。

- **Lambda提升**：通过将局部函数转换为全局函数，Lambda提升解决了Core语言的限制。作者详细介绍了各种Lambda提升的技术，包括简单的Lambda提升器、Johnsson风格的Lambda提升和依赖性分析等。
- **完全惰性**：作者强调了完全惰性与Lambda提升的区别，并展示了如何在单独的编译阶段实现完全惰性，从而提高程序的效率。
**实用工具和示例程序**

- **实用工具模块**：附录A提供了一系列实用工具，包括堆类型、关联列表、唯一名称生成、集合操作和其他辅助函数。这些工具在全书的实现中广泛使用，帮助管理内存、变量和数据结构。
- **Core语言示例程序**：附录B包含了大量的Core语言示例程序，涵盖基本程序、let和letrec表达式、算术运算和数据结构等。这些示例有助于读者在实践中理解Core语言的特性和实现。
**使用Miranda语言**

作者使用**Miranda**语言来实现所有的示例代码，强调了函数式语言在快速原型开发中的优势。

- **可执行文档**：书中的代码直接包含在文档中，采用Miranda的注释约定，使得整个文档实际上是可执行的。
- **实践价值**：通过使用Miranda，读者可以积累编写大型函数式程序的经验，理解函数式编程的思想和方法。
**未涵盖的内容和局限性**

- 本书主要关注编译器的后端实现，没有涉及高级函数式语言到Core语言的翻译、类型检查和形式化证明等内容。
- 这使得读者需要具备一定的函数式编程基础，并可能需要参考其他资料来了解未涉及的部分。
**结论**

总的来说，《Implementing Functional Languages: A Tutorial》是希望深入学习函数式语言实现的读者的宝贵资源。它不仅提供了理论知识，还通过实践帮助读者建立对非严格函数式语言实现的全面理解，为未来的研究和开发打下坚实的基础。

通过详细的讲解、完整的代码示例和实践性的指导，读者可以：

- **深入理解非严格函数式语言的实现机制**：从模板实例化到G-机器、TIM和并行G-机器，读者可以全面了解不同的实现方法及其优缺点。
- **积累函数式编程的实践经验**：通过实际编写和运行Miranda代码，读者可以提高自己的函数式编程技能。
- **了解编译器优化技术**：通过Lambda提升和完全惰性的讨论，读者可以学习到编译器优化的关键技术和实现方法。
- **培养解决实际问题的能力**：通过逐步改进和优化实现，读者可以学习到如何在实际中应对挑战、解决问题。
本书的实践导向、详细的讲解和全面的内容，使其成为学习非严格函数式语言实现的理想教材。
 #  
 Thought for 43 seconds
**概览**

您提供的内容是《Implementing Functional Languages: A Tutorial》一书的第一章，标题为“核心语言”（The Core Language）。本章介绍了一种称为**Core语言**的小型函数式编程语言，该语言被设计为简单但具有足够的表达能力，以便在不损失表达性或效率的情况下，将更丰富的函数式语言（如Miranda）的程序翻译成Core语言。

本章的主要内容包括：

- 对Core语言的非正式介绍，解释其设计目的和基本特性。
- Core语言的正式定义，包括其语法和用于表示Core程序和表达式的数据类型。
- 开发用于Core语言的解析器和美化打印器，这些工具对于编译和执行Core程序至关重要。
通过本章，读者将了解Core语言的设计理念、关键特性，以及如何使用它作为实现函数式语言的基础。

**详细解析**

### **1. 引言：Core语言概述**

**1.1 核心语言的介绍**

Core语言是一种简化的函数式编程语言，设计用于演示各种函数式语言的实现技术。它的主要特点是：

- **简洁性**：Core语言被故意设计得非常简洁，以便于实现。
- **表达能力**：尽管简洁，Core语言足够表达性，能够表示用更复杂的函数式语言编写的程序。
- **接口作用**：它作为编译器的前端和后端之间的清晰接口。前端负责处理高级语言构造，并将其转换为Core语言；后端专注于以各种方式实现Core语言。
**为什么选择Core语言？**

- **简化实现**：通过使用简化的语言，开发者可以专注于理解和实现核心概念，而不被复杂的语言特性分散注意力。
- **保留表达性和效率**：Core语言设计得足够强大，能够表示更丰富的语言而不损失效率。
- **教育目的**：作为教学工具，Core语言有助于演示函数式语言的关键实现技术。
### **1.1.1 Core语言的基本结构**

**超级组合子（Supercombinators）**

- Core程序由一组**超级组合子定义**组成。
- **超级组合子**是顶层定义的函数，可以接受零个或多个参数。
- 存在一个特殊的超级组合子main，程序的执行从main开始。
**示例程序**

```arduino
main = double 21
double x = x + x
```

- **解释**：double是一个接受一个参数x的函数，返回x + x。main调用double 21，因此程序的结果是42。
**特点**

- **函数参数**：在Core语言中，函数的参数都是简单变量，不支持模式匹配。
- **无局部函数定义**：函数只能在顶层定义，即作为超级组合子。
### **1.1.1 本地定义**

**let表达式**

- Core语言提供了`let`构造用于本地定义。示例：
```java
quadruple x = let twice_x = x + x
              in twice_x + twice_x
```
**解释**：在let中，本地变量twice_x被定义为x + x。quadruple函数返回twice_x + twice_x，即x的四倍。
- **非递归**：`let`是非递归的，内部的定义不能引用自身。
**letrec表达式**

- 对于需要递归的本地定义，Core语言提供了`letrec`。示例：
```java
infinite n = letrec ns = cons n ns
             in ns
```
**解释**：ns被递归地定义为cons n ns，创建一个无限的n组成的列表。
**与Miranda的where子句的区别**

- **递归性质**：Miranda的where子句总是递归的，而Core语言区分了非递归的let和递归的letrec。
- **模式匹配**：where子句可以使用模式匹配和定义局部函数，但Core语言的let和letrec仅允许简单变量的绑定。
- **表达式与定义**：Core语言的let和letrec是表达式，可以出现在任何需要表达式的地方；而Miranda的where子句附加在定义上。
### **1.1.2 Lambda抽象**

**匿名函数**

- 虽然通常函数是在顶层作为超级组合子定义的，但Core语言也支持使用Lambda抽象来表示匿名函数。示例：
```c
double_list xs = map (\ x. 2 * x) xs
```
**解释**：\ x. 2 * x是一个Lambda抽象，表示一个匿名函数，将输入x乘以2。map函数将这个匿名函数应用于列表xs的每个元素。
**Lambda提升（Lambda Lifting）**

- 可以通过将Lambda抽象转换为顶层的超级组合子，消除程序中的Lambda抽象。
- 这个过程称为**Lambda提升**，将在第6章详细讨论。
- 在本书的大部分内容中，我们假设已经进行了Lambda提升，因此不使用显式的Lambda抽象。
### **1.1.3 结构化数据类型**

**代数数据类型**

- 现代函数式语言通常支持**代数数据类型**，允许定义复杂的数据结构。在Miranda中，示例：
```go
colour ::= Red | Green | Blue
complex ::= Rect num num | Polar num num
tree * ::= Leaf * | Branch (tree *) (tree *)
```
- **解释**：colour类型的值可以是Red、Green或Blue。complex类型的值可以是Rect（包含两个num）或Polar（包含两个num）。tree *是一个参数化类型，*是类型参数，表示树的叶子可以是任何类型。
**构造器和模式匹配**

- **构造器**用于创建数据类型的值，例如`Red`、`Rect 3 4`、`Branch (Leaf 1) (Leaf 2)`。
- **模式匹配**用于分解数据类型的值，例如：
```mathematica
isRed Red = True
isRed _ = False
```
- **特殊类型**：布尔类型和列表类型实际上也是代数数据类型的特例。
```go
bool ::= False | True
list * ::= Nil | Cons * (list *)
```
### **1.1.4 在Core语言中表示构造器**

**统一表示**

- 为了简化Core语言，我们不直接支持用户定义的构造器。
- 而是使用一个统一的构造器家族，形式为Pack{tag, arity}。**tag**：一个整数，唯一标识构造器。**arity**：构造器的参数数量。
**示例表示**

- 将之前的构造器表示为：
```makefile
Red = Pack{1,0}
Green = Pack{2,0}
Blue = Pack{3,0}
Rect = Pack{1,2}
Polar = Pack{2,2}
Leaf = Pack{1,1}
Branch = Pack{2,2}
```
- **使用示例**：代替`Branch (Leaf 3) (Leaf 4)`，我们写：
```scss
Pack{2,2} (Pack{1,1} 3) (Pack{1,1} 4)
```
**优点**

- **简化实现**：通过使用统一的构造器表示，避免了处理用户定义的数据类型的复杂性。
- **避免数据类型声明**：Core语言中没有数据类型声明，这使得语言更简洁。
### **1.1.5 case表达式**

**模式匹配的实现**

- 在Core语言中，模式匹配仅通过case表达式实现。
- case表达式用于检查一个表达式的构造器标签，并选择相应的分支。
**语法**

```php
case expression of
   vars1 -> expr1 ;
   vars2 -> expr2 ;
  ...
```

- **解释**：expression：要分析的表达式。<tag>：构造器的标签。vars：与构造器的参数对应的变量列表。expr：当匹配成功时要执行的表达式。
**示例**

```python
isRed c = case c of
            <1> -> True ;
            <2> -> False ;
            <3> -> False
```

- **解释**：检查c的构造器标签。如果标签是1（对应Red），返回True。否则，返回False。
**限制**

- **无复杂模式**：不允许嵌套模式、重叠模式或守卫。
- **简单性**：每个分支仅匹配构造器标签，并绑定必要的变量。
**操作解释**

- case表达式的执行类似于多路跳转：计算要分析的表达式，获取其构造器标签。根据标签选择相应的分支。
### **1.2 Core语言的语法**

**形式化语法**

- 本节提供了Core语言的形式化语法，定义了程序、超级组合子、表达式、定义和替代的结构。
- **关键组件**：**程序**：由一个或多个超级组合子定义组成。**超级组合子**：顶层定义的函数，可能有参数。**表达式**：可以是应用、二元操作、let/letrec表达式、case表达式、Lambda抽象或原子表达式。**原子表达式**：变量、数字、构造器或带括号的表达式。**定义**：在let和letrec中使用，由变量绑定组成。**替代**：在case表达式中使用，定义可能的匹配。
**操作符和优先级**

- **中缀操作符**：支持算术、比较和布尔操作符。
- **优先级和结合性**：**优先级**：决定在没有括号的情况下，表达式的计算顺序。较高的优先级表示更紧密的绑定。**结合性**：决定具有相同优先级的操作符如何组合（左结合、右结合、无结合性）。
**优先级表**

| 优先级 | 结合性 | 操作符 |
| ---- | ---- | ---- |
| 6 | 左 | 应用（Application） |
| 5 | 右 | * |
|  | 无 | / |
| 4 | 右 | + |
|  | 无 | - |
| 3 | 无 | ==, ~=, >, >=, <, <= |
| 2 | 右 | & |
| 1 | 右 | ` |

- **注意**：没有一元负号操作符，使用negate函数代替。例如，表达式x + (negate x)。
### **1.3 Core语言的数据类型**

**表示Core程序的数据类型**

为了实现Core语言，需要在实现语言（Miranda）中定义数据类型来表示Core程序和表达式。

**Expr数据类型**

- 定义：
```sql
data Expr a = EVar Name              -- 变量
            | ENum Int               -- 数字
            | EConstr Int Int        -- 构造器（标签，参数数量）
            | EAp (Expr a) (Expr a)  -- 应用
            | ELet IsRec [(a, Expr a)] (Expr a)  -- Let表达式
            | ECase (Expr a) [Alter a]           -- Case表达式
            | ELam [a] (Expr a)                  -- Lambda抽象
```
- **解释**：**EVar**：表示一个变量，包含变量名。**ENum**：表示一个整数常量。**EConstr**：表示一个构造器，包含标签和参数数量。**EAp**：表示函数应用，包含函数和参数两个表达式。**ELet**：表示let或letrec表达式。**IsRec**：一个布尔值，指示是否是递归的。**[(a, Expr a)]**：定义列表，包含变量和对应的表达式。**(Expr a)**：let表达式的主体。**ECase**：表示case表达式。**(Expr a)**：要分析的表达式。**[Alter a]**：替代列表，每个替代包含一个标签、变量列表和表达式。**ELam**：表示Lambda抽象，包含参数列表和主体表达式。
- **参数化**：Expr类型对a进行了参数化，这使得在绑定位置存储不同类型的值成为可能。通常，a是Name（变量名）。
**辅助数据类型**

- **Name**：类型同义词，表示变量名，定义为String。
- **IsRec**：类型同义词，表示布尔值，指示let是否是递归的。**recursive**：True，表示递归。**nonRecursive**：False，表示非递归。
- **Alter a**：表示case表达式的替代，定义为(Int, [a], Expr a)。
**实用函数**

- **bindersOf**：从定义列表中提取绑定的变量名列表。
- **rhssOf**：从定义列表中提取右侧的表达式列表。
- **isAtomicExpr**：检查表达式是否是原子的（即没有内部结构）。
**程序和超级组合子的定义**

- **Program a**：表示一个Core程序，是超级组合子定义的列表。
- **ScDefn a**：表示一个超级组合子的定义，包含名称、参数列表和主体表达式。
**示例表示**

给定Core程序：

```arduino
main = double 21
double x = x + x
```

其在定义的数据类型中的表示为：

```graphql
[ ("main", [],
    EAp (EVar "double") (ENum 21)),
  ("double", ["x"],
    EAp (EAp (EVar "+") (EVar "x")) (EVar "x")) ]
```

- **解释**：main是一个没有参数的超级组合子，应用double函数到21。double是一个接受参数x的超级组合子，返回x + x。
**全面详尽的总结**

本章介绍了Core语言，一种简化的函数式编程语言，设计用于演示非严格函数式语言的实现技术。Core语言的简洁性使得实现过程更加专注于核心概念，而不会被复杂的语言特性干扰。同时，它具有足够的表达能力，可以在不损失表达性或效率的情况下，表示用更复杂的函数式语言编写的程序。

**主要内容包括：**

- **Core语言的基本构造**：包括超级组合子定义、`let`和`letrec`表达式、Lambda抽象和`case`表达式。**超级组合子**：顶层定义的函数，程序从main超级组合子开始执行。**本地定义**：使用let（非递归）和letrec（递归）表达式进行本地变量的定义。**Lambda抽象**：支持匿名函数的定义，尽管在大部分实现中假设已经进行了Lambda提升。**case表达式**：用于模式匹配，通过构造器的标签进行匹配，简化了模式匹配的实现。
- **结构化数据类型的表示**：通过统一的`Pack{tag, arity}`构造器表示所有的数据类型构造器，避免了处理用户定义的数据类型的复杂性。
- **Core语言的语法**：提供了形式化的语法定义，明确了程序、表达式、定义和替代的结构，以及操作符的优先级和结合性。
- **用于表示Core程序的数据类型**：在实现语言（Miranda）中定义了数据类型来表示Core程序和表达式，这对于编写编译器和解释器至关重要。
- **示例程序和表示**：通过示例程序展示了如何使用Core语言的构造，以及如何在实现中表示这些程序。
**通过本章的学习，读者应该能够：**

- **理解Core语言的设计理念和关键特性**：认识到简化语言的重要性，以及如何在保持表达性的前提下，简化实现过程。
- **掌握Core语言的基本构造和语法**：熟悉超级组合子、let/letrec表达式、Lambda抽象和case表达式的用法和限制。
- **了解结构化数据类型的处理方法**：理解如何通过统一的构造器表示，简化数据类型的实现。
- **熟悉用于表示Core程序的数据类型**：掌握在实现中如何表示Core程序和表达式，为后续编译器和解释器的开发打下基础。
**总结**

本章为函数式语言的实现奠定了基础，通过介绍一个简化但功能强大的Core语言，读者可以专注于理解实现的核心概念。Core语言的设计体现了在简化与表达能力之间的平衡，为后续章节中探讨函数式语言的实现技术提供了必要的背景和工具。
 #  
 Thought for 14 seconds
**概览**

您提供的内容是《Implementing Functional Languages: A Tutorial》一书第一章的一部分，具体涵盖了第1.4节和第1.5节。这些章节讨论了在实现一个简化的函数式语言（称为Core语言）时，需要提供哪些基础工具以支持程序的编写和展示。

- **第1.4节：一个小型的标准前导（Prelude）**介绍了为Core语言提供一个小型标准库的必要性。定义了一组基本的函数（如I、K、S等），这些函数在编程中非常有用。解释了如何在Core语言中表示这些函数，以便在后续的实现中使用。
- **第1.5节：为Core语言编写一个美化打印器（Pretty-Printer）**讨论了需要一个美化打印器来以人类可读的方式显示Core程序。介绍了初始的实现方法，以及存在的性能问题。引入了抽象数据类型（Abstract Data Type，ADT）Iseq，用于高效地构建和显示字符串。详细解释了Iseq的设计、实现和如何使用它来改进打印器的性能和功能。强调了抽象数据类型和泛化（generalisation）在编程中的重要性。
**详细解析**

### **1.4 一个小型的标准前导（Prelude）**

**背景**

在函数式编程语言（如Miranda和Haskell）中，通常会提供一个**标准前导（Prelude）**，其中包含了一组预定义的函数和类型，供用户在编写程序时直接使用。这些函数通常是通用的、常用的，可以提高编程效率。

**为什么Core语言需要一个标准前导**

Core语言被设计得非常简洁，仅包含了最基本的构造，以便于实现各种函数式语言的核心功能。然而，这种简洁性也意味着它缺乏许多常用的函数。如果要编写实用的程序，或者要将更复杂的函数式语言（如Miranda）的程序翻译成Core语言，我们需要提供一些基本的函数供使用。

由于我们的实现将从最简单的解释器开始，逐步添加功能（如算术运算、数据结构等），因此我们需要一个小型的标准前导，只包含最基本的、在所有实现中都可用的函数。

**标准前导的定义**

以下是为Core语言定义的标准前导函数：

1. **I函数（恒等函数）**
- 定义：I x = x
- 解释：接受一个参数x，返回x本身。
2. **K函数**
- 定义：K x y = x
- 解释：接受两个参数x和y，总是返回第一个参数x。
3. **K1函数**
- 定义：K1 x y = y
- 解释：接受两个参数x和y，总是返回第二个参数y。
4. **S函数**
- 定义：S f g x = f x (g x)
- 解释：接受三个参数f、g和x，返回f x (g x)。
5. **compose函数（函数组合）**
- 定义：compose f g x = f (g x)
- 解释：接受三个参数f、g和x，返回f应用于g x的结果，相当于将f和g组合。
6. **twice函数**
- 定义：twice f = compose f f
- 解释：接受一个函数f，返回将f应用两次的组合函数。
**为什么选择这些函数**

- **I、K、S组合子**：这些函数是著名的SKI组合子系统的一部分，可以用来表示任何Lambda表达式。
- **compose和twice**：函数组合在函数式编程中非常常用，twice函数可以用于将一个函数应用两次，提供了更高阶的功能。
**在Core语言中的表示**

在Core语言中，我们需要将这些函数定义为超级组合子（supercombinators），并使用Core语言的语法来表示它们。以下是它们的定义：

```haskell
preludeDefs :: CoreProgram
preludeDefs =
  [ ("I", ["x"], EVar "x"),
    ("K", ["x","y"], EVar "x"),
    ("K1", ["x","y"], EVar "y"),
    ("S", ["f","g","x"], EAp (EAp (EVar "f") (EVar "x"))
                              (EAp (EVar "g") (EVar "x"))),
    ("compose", ["f","g","x"], EAp (EVar "f")
                                    (EAp (EVar "g") (EVar "x"))),
    ("twice", ["f"], EAp (EAp (EVar "compose") (EVar "f")) (EVar "f"))
  ]
```

- **解释**：("I", ["x"], EVar "x")：定义了I函数，参数为x，返回x。EVar表示变量，EAp表示函数应用。对于S函数，EAp用于表示函数的应用，需要嵌套使用以表示多个参数的应用。
**重要性**

- 提供了基本的函数，支持在Core语言中编写更复杂的程序。
- 这些函数在所有的实现中都可用，即使在最简单的仅支持函数应用的实现中。
### **1.5 为Core语言编写一个美化打印器（Pretty-Printer）**

**1.5.1 引言：为什么需要美化打印器**

当我们在实现一个编译器或解释器时，经常需要以人类可读的形式显示程序代码，方便调试和验证。在Miranda中，虽然有内置的显示函数，但直接使用它们显示Core程序的数据结构会导致输出难以阅读。例如，显示`preludeDefs`时，可能会得到复杂的嵌套结构，难以理解。

因此，我们需要编写一个专门的**美化打印器**，将Core程序的数据结构转换为格式良好的字符串，以便在屏幕上清晰地显示。

**目标**

- 编写一个函数pprint :: CoreProgram -> String，将Core程序转换为字符串。
- 生成的字符串应当格式良好，易于阅读，反映程序的结构。
**1.5.2 初始实现：直接使用字符串**

首先，我们尝试直接使用字符串来实现美化打印器。

**定义**

```haskell
pprExpr :: CoreExpr -> String
pprExpr (ENum n) = show n
pprExpr (EVar v) = v
pprExpr (EAp e1 e2) = pprExpr e1 ++ " " ++ pprAExpr e2

pprAExpr :: CoreExpr -> String
pprAExpr e = if isAtomicExpr e
             then pprExpr e
             else "(" ++ pprExpr e ++ ")"
```

- **解释**：pprExpr是一个递归函数，用于将Core表达式转换为字符串。ENum n和EVar v是基本情况，直接转换为字符串。EAp e1 e2表示函数应用，需要将e1和e2分别转换，然后拼接。pprAExpr用于在必要时添加括号，以确保表达式的正确性。
**性能问题**

然而，这种直接使用字符串拼接的方式存在性能问题：

- **列表拼接效率低下**：在函数式语言中，字符串是字符列表，使用++进行拼接时，如果不注意操作的顺序，可能会导致效率低下，特别是在嵌套的拼接中。
- **时间复杂度可能是二次的**：嵌套的++操作可能导致时间复杂度为O(n²)，对于大型程序，这将导致性能问题。
**示例**

考虑构造一个大型的函数应用，例如`f x x x ... x`（重复n次）。使用上述方法，生成字符串的时间可能与n的平方成正比。

**1.5.3 引入抽象数据类型（ADT）Iseq**

为了解决性能问题，我们引入一个抽象数据类型`Iseq`，用于高效地构建和处理字符串。

**Iseq的接口**

```haskell
iNil :: Iseq                 -- 空的Iseq
iStr :: String -> Iseq       -- 将字符串转换为Iseq
iAppend :: Iseq -> Iseq -> Iseq  -- 连接两个Iseq
iNewline :: Iseq             -- 表示换行符
iIndent :: Iseq -> Iseq      -- 缩进Iseq
iDisplay :: Iseq -> String   -- 将Iseq转换为字符串
```

- **解释**：Iseq是一个抽象数据类型，代表了可组合的、延迟计算的字符串序列。我们使用这些函数来构建字符串，而不立即执行拼接操作。
**使用Iseq重写打印器**

```haskell
pprExpr :: CoreExpr -> Iseq
pprExpr (EVar v) = iStr v
pprExpr (EAp e1 e2) = pprExpr e1 `iAppend` iStr " " `iAppend` pprAExpr e2
```

- **解释**：使用iAppend代替++，避免了直接拼接字符串，提升了性能。Iseq的实现将延迟实际的拼接操作，直到最终需要显示时才进行。
**Iseq的实现**

```haskell
data Iseq = INil
          | IStr String
          | IAppend Iseq Iseq
          | IIndent Iseq
          | INewline
```

- **解释**：Iseq的实现使用了一棵树的结构，延迟了字符串的拼接。通过这种方式，拼接操作的时间复杂度降低为线性的。
**flatten函数**

```haskell
flatten :: Int -> [(Iseq, Int)] -> String
flatten col [] = ""
flatten col ((INil, indent) : seqs) = flatten col seqs
flatten col ((IStr s, indent) : seqs) = s ++ flatten (col + length s) seqs
flatten col ((IAppend seq1 seq2, indent) : seqs) = flatten col ((seq1, indent) : (seq2, indent) : seqs)
flatten col ((INewline, indent) : seqs) = '\n' : replicate indent ' ' ++ flatten indent seqs
flatten col ((IIndent seq, indent) : seqs) = flatten col ((seq, col) : seqs)
```

- **解释**：flatten函数用于将Iseq转换为字符串。通过使用工作列表（work list），以线性时间展开Iseq，避免了嵌套拼接导致的性能问题。处理了缩进和换行，使得输出的字符串格式良好。
**1.5.4 改进打印器的布局和缩进**

通过引入`IIndent`和`INewline`，我们可以在打印器中实现自动的缩进和换行，使得输出的程序更易读。

**示例**

```haskell
pprExpr (ELet isrec defns expr) =
  iConcat [ iStr keyword, iNewline,
            iIndent (pprDefns defns), iNewline,
            iStr "in ", pprExpr expr ]
  where
    keyword = if isrec then "letrec" else "let"
```

- **解释**：使用iNewline表示换行，iIndent将后续的内容缩进。pprDefns和pprDefn分别用于打印定义列表和单个定义。
**1.5.5 处理操作符的优先级**

在Core语言的表示中，所有的函数应用都是前缀形式的，即使是二元操作符（如`+`、`-`等）。为了使打印出的程序更符合人类的阅读习惯，我们希望在打印时将这些操作符还原为中缀形式。

**实现方法**

- 在`pprExpr`中，添加匹配二元操作符的模式：
```haskell
pprExpr (EAp (EAp (EVar "+") e1) e2) =
  iConcat [ pprAExpr e1, iStr " + ", pprAExpr e2 ]
```
- 为了正确处理操作符的优先级和结合性，可以为`pprExpr`添加一个参数，表示当前的优先级，以决定是否需要添加括号。
**1.5.6 其他有用的Iseq函数**

为了方便打印器的编写，可以定义一些辅助函数：

- **iNum**：将数字转换为Iseq。
- **iFWNum**：将数字转换为固定宽度的Iseq，左侧填充空格。
- **iLayn**：为列表中的每一项编号并打印，每项后添加换行。
**1.5.7 总结**

**本节的主要内容**

- **引入Iseq抽象数据类型**：通过延迟拼接操作，提高了打印器的性能，避免了字符串拼接的性能问题。
- **实现了自动的缩进和布局**：使用IIndent和INewline，使得输出的程序格式良好，易于阅读。
- **讨论了抽象数据类型和泛化的重要性**：**抽象数据类型**：将接口与实现分离，允许我们改变实现而不影响使用它的代码。**泛化**：通过定义更通用的函数（如flatten），可以更方便地处理复杂的问题。
**全面详尽的总结**

在本节中，我们深入探讨了在实现Core语言时，如何提供必要的工具来支持程序的编写和展示。

**1.4 一个小型的标准前导**

- **目的**：为Core语言提供一组基本的函数，支持在编写程序时使用常用的功能。
- **内容**：定义了I、K、K1、S、compose和twice等函数。这些函数在函数式编程中具有重要作用，提供了基本的组合能力。
- **实现**：将这些函数表示为Core语言的超级组合子，使用Core语言的语法来定义。
- **意义**：为Core语言的程序提供了基本的构建块，支持更复杂的程序开发。这些函数可以在所有的实现中使用，确保了一致性。
**1.5 为Core语言编写一个美化打印器**

- **挑战**：需要一个能够以人类可读形式显示Core程序的工具，而直接使用字符串拼接存在性能问题。
- **解决方案**：引入了抽象数据类型Iseq，用于高效地构建和处理字符串序列。Iseq延迟了实际的字符串拼接操作，避免了嵌套的++导致的二次时间复杂度。
- **实现细节**：定义了iNil、iStr、iAppend、iNewline、iIndent和iDisplay等函数，组成了Iseq的接口。实现了flatten函数，将Iseq转换为字符串，处理了缩进和换行。修改了打印器的实现，使用Iseq来构建输出，提高了性能和可读性。
- **重要概念**：**抽象数据类型（ADT）**：通过将数据类型的实现隐藏在接口之后，可以在不影响使用者的情况下更改实现。**泛化（Generalisation）**：通过定义更一般的函数，可以更方便地处理复杂的问题，并提高代码的可重用性。
- **最终效果**：实现了一个高效的、美化的打印器，能够以良好的格式显示Core程序，方便调试和验证。
**总结**

通过本节的学习，我们不仅了解了如何为Core语言提供必要的标准函数，还学会了如何实现一个高效的美化打印器。这些工具对于后续的编译器和解释器的开发至关重要。

- **在编程实践中**，我们看到了性能优化的重要性，以及如何通过改变数据结构和算法来提高效率。
- **在软件设计中**，我们体会到了抽象数据类型和泛化的价值，理解了将接口与实现分离的好处。
- **在函数式编程中**，我们进一步认识了延迟计算（如在Iseq中延迟拼接）的优势，以及如何利用递归和高阶函数来构建灵活的程序。
这些概念和技巧对于理解和实现函数式语言都有重要的意义，为我们在后续章节中深入探讨Core语言的实现奠定了坚实的基础。

**结语**

通过深入解析第1.4节和第1.5节的内容，我们不仅了解了为Core语言提供标准前导和美化打印器的必要性和方法，还掌握了在函数式编程中常用的性能优化和软件设计技巧。这些知识将帮助我们更好地理解函数式语言的实现原理，为后续的学习和实践做好准备。
 #  
 Thought for 8 seconds
**概览**

您提供的内容是《Implementing Functional Languages: A Tutorial》一书的第一章的第1.6节，标题为“Core语言的解析器”（A parser for the Core language）。本节详细讨论了如何为之前介绍的简化函数式语言Core语言编写一个解析器，使其能够从源文件读取Core程序，并将其解析成内部数据结构，供编译器和解释器使用。

本节的主要内容包括：

- **解析器的设计与分解**：将解析过程分为读取文件、词法分析和语法分析三个阶段。
- **词法分析器的实现**：定义如何将输入的字符流转换为标记（tokens），并处理空白符、数字、变量等。
- **语法分析器的实现**：讨论了如何使用函数式编程的方法，通过组合小的解析器构建大的解析器，使用了一系列的解析器组合器（parser combinators）。
- **解析器工具的改进**：引入了泛型的解析器类型和组合器函数，如pLit、pVar、pAlt、pThen等，以便更灵活地构建解析器。
- **处理语法问题**：讨论了左递归和操作符优先级的问题，以及如何调整语法和解析器以正确处理这些情况。
- **总结**：强调了LL(1)语法的重要性，以及使用函数式编程方法编写解析器的优势。
**详细解析**

### **1.6 为Core语言编写一个解析器**

**背景**

在前面的章节中，我们介绍了Core语言的语法和数据结构，定义了如何表示Core程序和表达式。但是，要运行这些实现，我们需要能够读取Core程序的源代码，并将其转换为我们的内部表示（如`CoreProgram`类型）。为此，我们需要编写一个解析器（parser）。

解析器的作用是：

- **读取源文件**：从文件中读取Core程序的源代码。
- **词法分析**：将源代码的字符流转换为标记（tokens），如变量名、数字、操作符等。
- **语法分析**：根据Core语言的语法规则，将标记序列解析为内部的程序表示，如抽象语法树（AST）。
**解析器的总体设计**

为了实现解析器，我们将解析过程分为以下三个阶段：

1. **读取文件内容**：使用内置的读取函数，将源文件的内容读取为字符列表。
- 使用Miranda的内置函数read，类型为read :: String -> String。
2. **词法分析（Lexical Analysis）**：将字符列表转换为标记（tokens）列表。
- 定义函数clex :: String -> [Token]，将字符流解析为标记序列。
- 处理空白符、数字、变量名、操作符等。
3. **语法分析（Syntax Analysis）**：将标记序列解析为Core程序的数据结构。
- 定义函数syntax :: [Token] -> CoreProgram，将标记序列解析为CoreProgram类型的值。
最终，完整的解析器函数`parse`可以表示为上述三个函数的组合：

```haskell
parse :: String -> CoreProgram
parse = syntax . clex
```

- 这里使用了函数组合运算符.，表示parse函数等价于parse filename = syntax (clex (read filename))。
- 这种组合方式使得解析器的结构更加清晰，易于理解。
### **1.6.1 词法分析**

**Token类型的定义**

首先，我们需要定义标记（token）的类型。最简单的方式是将每个标记表示为非空的字符串：

```haskell
type Token = String  -- Token永远不为空
```

**词法分析器clex的实现**

词法分析器的主要作用是将字符流转换为标记序列，主要处理以下内容：

- **忽略空白符**：跳过空格、制表符、换行符等。
- **识别数字**：将连续的数字字符组合为一个数字标记。
- **识别变量名**：将以字母开头，后跟字母、数字或下划线的序列识别为变量名。
- **识别其他标记**：将其他字符（如操作符、括号等）作为单独的标记。
**具体实现**

1. **忽略空白符**
```haskell
clex (c:cs) | isWhiteSpace c = clex cs
```

- 使用isWhiteSpace函数检查字符c是否为空白符。
- 如果是，则递归调用clex，继续处理剩余的字符cs。
1. **识别数字**
```haskell
clex (c:cs) | isDigit c = num_token : clex rest_cs
  where
    num_token = c : takeWhile isDigit cs
    rest_cs = dropWhile isDigit cs
```

- 使用isDigit函数检查字符c是否为数字。
- 使用takeWhile和dropWhile函数获取连续的数字字符，形成一个数字标记。
- 将数字标记添加到结果列表中，继续处理剩余的字符。
1. **识别变量名**
```haskell
clex (c:cs) | isAlpha c = var_tok : clex rest_cs
  where
    var_tok = c : takeWhile isIdChar cs
    rest_cs = dropWhile isIdChar cs
```

- 使用isAlpha函数检查字符c是否为字母。
- 使用isIdChar函数检查字符是否为字母、数字或下划线。
- 将符合条件的字符组合成变量名标记。
1. **处理其他字符**
```haskell
clex (c:cs) = [c] : clex cs
```

- 对于不属于上述情况的字符（如操作符、括号等），将其作为单独的标记。
1. **处理输入结束**
```haskell
clex [] = []
```

- 当输入字符列表为空时，返回空的标记列表。
**辅助函数的定义**

```haskell
isIdChar, isWhiteSpace :: Char -> Bool
isIdChar c = isAlpha c || isDigit c || (c == '_')
isWhiteSpace c = c `elem` " \t\n"
```

- isIdChar用于检查字符是否是标识符的一部分（字母、数字或下划线）。
- isWhiteSpace用于检查字符是否为空白符。
**示例**

假设我们有以下输入字符串：

```arduino
"let x = 42 in x"
```

经过`clex`处理后，将得到以下标记序列：

```css
["let", "x", "=", "42", "in", "x"]
```

**练习**

- **练习1.9**：修改词法分析器，使其忽略注释。假设注释以||开始，直到行末。
- **练习1.10**：修改词法分析器，使其将两个字符的操作符（如==、<=等）识别为单个标记。
### **1.6.2 解析器的基本工具**

**解析器类型的定义**

在构建解析器时，我们采用函数式编程的常用方法，即通过组合小的解析器构建大的解析器。

**关键问题**：解析器的类型应如何定义？

- 解析器是一个函数，接受一个标记列表作为输入。
- 它需要返回解析的结果，以及剩余的未解析的标记列表，以便后续解析器继续处理。
- 由于解析可能失败（无法解析）或有多个可能的解析结果（在存在歧义的情况下），我们需要考虑这些情况。
**定义解析器类型**

我们定义解析器的类型为：

```haskell
type Parser a = [Token] -> [(a, [Token])]
```

- Parser a表示一个解析器，接受标记列表[Token]，返回一组解析结果，每个结果是一个解析值与剩余标记列表的对(a, [Token])。
- 解析器返回的结果是一个列表，表示可能的解析结果。列表为空表示解析失败。
**示例语法**

为了演示解析器的构建，我们使用一个简单的语法：

```markdown
greeting → hg person !
hg → hello
    | goodbye
```

- person可以是任何以字母开头的标记（变量）。
- 我们将构建解析器来解析这种问候语。
**基本解析器的定义**

1. **解析特定的标记**
```haskell
pLit :: String -> Parser String
pLit s (tok:toks) = if s == tok then [(s, toks)] else []
pLit s [] = []
```

- pLit用于匹配特定的标记 s。
- 如果输入的第一个标记tok等于s，则解析成功，返回s和剩余的标记列表toks。
- 否则，返回空列表，表示解析失败。
1. **解析变量**
```haskell
pVar :: Parser String
pVar [] = []
pVar (tok:toks) = if isAlpha (head tok) then [(tok, toks)] else []
```

- pVar用于解析变量，即以字母开头的标记。
- 检查标记tok的第一个字符是否为字母。
**解析器组合器**

为了组合解析器，我们定义了一些解析器组合器函数。

1. **pAlt（选择）**
```haskell
pAlt :: Parser a -> Parser a -> Parser a
pAlt p1 p2 toks = p1 toks ++ p2 toks
```

- pAlt接受两个解析器p1和p2，尝试用它们解析相同的输入 toks。
- 返回两者的解析结果的列表。
1. **pThen（顺序）**
```haskell
pThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
pThen combine p1 p2 toks =
  [ (combine v1 v2, toks2) | (v1, toks1) <- p1 toks, (v2, toks2) <- p2 toks1 ]
```

- pThen接受两个解析器p1和p2，以及一个组合函数combine。
- 首先用p1解析输入toks，得到解析结果v1和剩余标记toks1。
- 然后用p2解析toks1，得到解析结果v2和剩余标记toks2。
- 最终返回combine v1 v2和toks2。
**构建问候语解析器**

使用上述解析器和组合器，我们可以构建解析问候语的解析器：

```haskell
pHelloOrGoodbye :: Parser String
pHelloOrGoodbye = pLit "hello" `pAlt` pLit "goodbye"

pGreeting :: Parser (String, String)
pGreeting = pThen mk_pair pHelloOrGoodbye pVar
  where
    mk_pair hg name = (hg, name)
```

- pHelloOrGoodbye解析"hello"或"goodbye"。
- pGreeting解析一个问候语，由pHelloOrGoodbye和pVar组成，并将结果组合为元组。
**示例**

解析输入`["hello", "John", "!"]`：

```haskell
pGreeting ["hello", "John", "!"]
-- 结果：[ ( ("hello", "John"), ["!"] ) ]
```

### **1.6.3 改进解析器工具**

**引入更多的解析器组合器**

1. **pThen3和pThen4**
- 当需要依次解析三个或四个元素时，我们可以定义pThen3和pThen4。
```haskell
pThen3 :: (a -> b -> c -> d) -> Parser a -> Parser b -> Parser c -> Parser d
pThen3 combine p1 p2 p3 toks = [ (combine v1 v2 v3, toks3) |
                                 (v1, toks1) <- p1 toks,
                                 (v2, toks2) <- p2 toks1,
                                 (v3, toks3) <- p3 toks2 ]

-- pThen4类似，接受四个解析器和一个组合函数。
```

- 这样，我们可以更加方便地解析包含多个元素的结构。
1. **pZeroOrMore和pOneOrMore**
- 用于解析零个或多个、一个或多个重复的结构。
```haskell
pZeroOrMore :: Parser a -> Parser [a]
pZeroOrMore p = pOneOrMore p `pAlt` pEmpty []

pOneOrMore :: Parser a -> Parser [a]
pOneOrMore p = pThen (:) p (pZeroOrMore p)
```

- pZeroOrMore尝试解析零个或多个p，返回解析结果的列表。
- pOneOrMore尝试解析一个或多个p，至少要成功解析一次。
1. **pApply**
- 用于在解析成功后，对解析结果应用一个函数。
```haskell
pApply :: Parser a -> (a -> b) -> Parser b
pApply p f toks = [ (f v, toks1) | (v, toks1) <- p toks ]
```

- 这使得我们可以在不改变解析器的情况下，处理解析结果。
**处理关键字和变量**

- 为了避免将关键字（如let、in等）识别为变量，我们可以使用pSat函数。
```haskell
pSat :: (String -> Bool) -> Parser String
pSat pred (tok:toks) = if pred tok then [(tok, toks)] else []
pSat pred [] = []

keywords = ["let", "letrec", "case", "in", "of", "Pack"]

pVar = pSat (\tok -> isAlpha (head tok) && not (tok `elem` keywords))
```

- pSat接受一个谓词函数pred，用于判断标记是否符合条件。
- pVar使用pSat，确保变量名不在关键字列表中。
### **1.6.4 解析Core语言**

**解析器的整体结构**

- 我们需要定义一个函数syntax，它接受标记列表，返回CoreProgram。
- syntax可以使用我们之前定义的解析器来解析整个Core程序。
```haskell
syntax = take_first_parse . pProgram
  where
    take_first_parse ((prog, []):others) = prog
    take_first_parse (parse:others) = take_first_parse others
    take_first_parse [] = error "Syntax error"
```

- pProgram是用于解析程序的解析器。
- take_first_parse函数用于从解析结果中选择第一个完整解析（剩余标记列表为空的解析）。
**按照语法规则构建解析器**

根据Core语言的语法规则（参见第1.2节的语法定义），我们可以逐步构建解析器。

1. **解析程序和超级组合子**
```haskell
pProgram :: Parser CoreProgram
pProgram = pOneOrMoreWithSep pSc (pLit ";")

pSc :: Parser CoreScDefn
pSc = pThen4 mk_sc pVar (pZeroOrMore pVar) (pLit "=") pExpr
```

- pProgram解析一个或多个超级组合子定义，由;分隔。
- pSc解析一个超级组合子定义，形式为var var1 ... varn = expr。
1. **解析表达式**
- 由于表达式的结构复杂，涉及操作符优先级和左递归等问题，我们需要特别处理。
**处理左递归**

- 左递归的语法规则会导致解析器的无限递归，例如：
```bash
expr → expr aexpr
```

- 为了解决这个问题，我们可以将语法规则改写，消除左递归。
```haskell
expr → aexpr1 ... aexprn  (n ≥ 1)
```

- 在解析器中，我们使用pOneOrMore来解析一个或多个aexpr。
```haskell
pExpr = pOneOrMore pAexpr `pApply` mk_ap_chain
```

- mk_ap_chain函数用于将解析的aexpr列表构建为应用链，即嵌套的EAp结构。
**处理操作符优先级**

- 操作符的优先级和结合性需要在语法中明确表达。
- 我们可以将表达式的语法规则分为多个层次，每个层次对应不同的优先级。
```haskell
expr → expr1
expr1 → expr2 | expr1  -- 处理`|`操作符，右结合
expr2 → expr3 & expr2  -- 处理`&`操作符，右结合
expr3 → expr4 relop expr4  -- 处理关系操作符，无结合性
expr4 → expr5 + expr4  -- 处理`+`、`-`，右结合
expr5 → expr6 * expr5  -- 处理`*`、`/`，右结合
expr6 → aexpr1 ... aexprn  (n ≥ 1)
```

- 对于每个层次的表达式，我们需要处理操作符和结合性。
**在解析器中实现**

- 我们需要定义相应的解析器，如pExpr1、pExpr2等。
```haskell
pExpr1 = pThen assemble_op pExpr2 pExpr1c
pExpr1c = (pThen FoundOp (pLit "|") pExpr1) `pAlt` pEmpty NoOp
```

- assemble_op函数用于根据解析的操作符和操作数构建表达式。
### **1.6.7 总结**

在本节中，我们详细讨论了如何为Core语言编写一个解析器。通过使用函数式编程的技巧和解析器组合器，我们能够以模块化、可组合的方式构建解析器。

**主要内容包括：**

- **解析器的设计与实现**：将解析过程分为读取文件、词法分析和语法分析三个阶段，逐步构建解析器。
- **词法分析器的实现**：处理空白符、数字、变量名、操作符等，将字符流转换为标记序列。
- **解析器组合器的使用**：定义了pLit、pVar、pAlt、pThen、pZeroOrMore、pApply等解析器组合器，方便地组合小解析器构建大解析器。
- **处理语法问题**：通过消除左递归和明确操作符优先级，解决了语法分析中的关键问题。
- **解析器的测试与验证**：通过示例和练习，验证了解析器的正确性和健壮性。
**重要概念和技巧：**

- **抽象解析器类型**：定义了Parser a类型，统一了解析器的接口，方便组合和扩展。
- **泛化和高阶函数**：通过使用高阶函数和泛化的组合器，提高了解析器的灵活性和可重用性。
- **递归下降解析器**：采用递归的方法，根据语法规则构建解析器，适用于LL(1)语法。
- **模块化设计**：将解析器分解为小的、可组合的组件，便于维护和扩展。
**总结**

通过本节的学习，我们掌握了如何使用函数式编程的方法，构建一个功能完整、性能良好的解析器。这种方法具有以下优势：

- **清晰的结构**：解析器的结构直接反映了语法规则，易于理解和维护。
- **灵活的组合**：通过解析器组合器，可以方便地调整解析器的行为，添加新的规则或修改现有规则。
- **良好的性能**：通过消除左递归和明确操作符优先级，避免了解析器的性能问题。
在后续的章节中，我们将基于解析器的输出，继续实现Core语言的编译器和解释器，深入探索函数式语言的实现技术。

**全面详尽的总结**

本节详细探讨了为Core语言编写解析器的全过程，从读取源文件到词法分析，再到语法分析。通过引入抽象的解析器类型和一系列解析器组合器，我们成功地构建了一个模块化、可扩展的解析器。

**主要成果和收获：**

1. **解析器的分层设计**：通过将解析过程分为多个阶段，我们能够清晰地处理各个部分的逻辑，减少复杂性。
2. **词法分析器的实现**：我们学会了如何处理空白符、注释、数字、变量名和操作符等，构建了一个功能完备的词法分析器。
3. **解析器组合器的使用**：引入了`pLit`、`pVar`、`pAlt`、`pThen`、`pZeroOrMore`、`pApply`等解析器组合器，使得解析器的构建更加灵活和简洁。
4. **处理语法复杂性**：通过调整语法规则，消除了左递归的问题，并明确了操作符的优先级和结合性，确保了解析器的正确性和性能。
5. **函数式编程的优势**：充分利用了函数式编程的特性，如高阶函数、递归和延迟计算，使得解析器的实现更加自然和高效。
**对读者的启示和建议：**

- **理解抽象**：通过定义抽象的数据类型和接口，我们可以将复杂的问题分解为可管理的部分，提高代码的可读性和可维护性。
- **重用和组合**：鼓励读者在编程中寻找模式和共性，定义通用的组件，以便在不同的场景中重用和组合。
- **性能优化**：在设计和实现中，需要关注可能的性能问题，如左递归导致的无限递归，通过调整算法和数据结构来优化性能。
- **实践练习**：通过动手实践，完成文中提出的练习和示例，可以加深对解析器实现和函数式编程的理解。
**结语**

通过本节的学习，我们为Core语言的实现奠定了坚实的基础。解析器是编译器和解释器的关键组成部分，理解其原理和实现方法对于深入学习编程语言的实现至关重要。在后续的学习中，我们将继续基于解析器的成果，探索Core语言的其他实现技术，如编译、优化和执行模型。
 #  
 Thought for 7 seconds
**概览**

您提供的内容是《Implementing Functional Languages: A Tutorial》一书的第二章，标题为“模板实例化”（Template Instantiation）。本章介绍了函数式语言最简单的实现方式之一：基于模板实例化的图形归约（graph reduction）。

主要内容包括：

- **2.1 模板实例化回顾**：对模板实例化和图形归约的关键概念进行回顾，包括归约的步骤和示例。
- **2.2 状态转换系统**：介绍如何使用状态转换系统来描述机器的行为，为实现图形归约提供基础。
通过本章，您将了解函数式语言的基本执行模型，以及如何使用模板实例化来实现函数式语言的解释器或编译器。

**详细解析**

### **2.1 模板实例化回顾**

模板实例化（Template Instantiation）是一种实现非严格（惰性）函数式语言的方法，它使用图形归约（graph reduction）来计算表达式的值。在图形归约中，程序的表达式被表示为图形结构，计算通过对图形中的可归约表达式（redex）进行归约来完成。

#### **关键概念**

- **表达式表示为图形**：在函数式语言中，程序是通过计算表达式来执行的。为了实现这一点，表达式被表示为图形（树是图的一种特殊形式），其中节点代表函数、变量、常量等。
- **归约**：计算过程是通过一系列归约操作完成的。归约涉及到将一个可归约表达式（redex）替换为其简化形式。
- **可归约表达式（redex）**：这是可以进一步简化的表达式。例如，函数应用（如`f x`）在`f`和`x`都可用的情况下就是一个redex。
- **归约顺序**：由于在任何时候可能存在多个redex，选择下一个要归约的redex是关键的。幸运的是，在纯函数式语言中，无论选择哪个redex，最终的结果（即归约到的正常形式）都是相同的。然而，不同的归约顺序可能影响计算是否终止。
- **正常序归约（Normal Order Reduction）**：为了确保如果有可能终止，归约过程会终止，我们采用总是选择最外层的redex的策略，这被称为正常序归约。
#### **归约过程**

归约的过程可以描述为：

1. **找到下一个redex**：选择表达式中最外层的可归约部分。
2. **归约redex**：将redex替换为其简化形式。
3. **更新图形**：在图形中用归约的结果更新redex的位置。
4. **重复上述步骤**，直到表达式中不再有redex，表达式被归约到正常形式（normal form）。
### **2.1.1 示例**

考虑以下Core语言的程序：

```haskell
square x = x * x ;
main = square (square 3)
```

- **解释**：定义了一个函数square，计算一个数的平方。定义了main，计算square (square 3)，即(3 * 3) * (3 * 3)。
**图形表示和归约步骤**：

1. **初始图形**：
```css
main
```

- main是要计算的表达式。
2. **展开main**：
- main没有参数，是一个redex，可以替换为其定义的右侧。
```markdown
    @
   / \
square  @
        / \
    square  3
```

- @表示函数应用。
3. **归约最外层的square应用**：
- 将square函数应用于(square 3)，需要将square的定义替换进来。
```javascript
     @
    / \
   @   *
  / \ / \
square 3 square 3
```

- 将square x = x * x中的x替换为(square 3)。
4. **注意到共享**：
- square 3出现了两次，可以共享计算结果，避免重复计算。
5. **归约内层的square 3**：
- 继续归约内层的square应用。
```javascript
     @
    / \
   @   *
  / \ / \
 *  3  * 3
```

- 计算square 3得到3 * 3。
6. **计算乘法**：
- 计算3 * 3得到9。
```javascript
     @
    / \
   @   *
  / \ / \
  9   9
```
7. **计算最终结果**：
- 计算9 * 9得到81，这是最终结果。
#### **关键点**

- **惰性计算**：通过共享，可以避免重复计算相同的表达式（如`square 3`）。
- **图形归约**：归约过程中，图形结构不断被更新，节点被替换为其计算结果。
### **2.1.2 归约的三步**

归约过程可以概括为以下三个步骤：

1. **找到下一个redex**：找到表达式中最外层的可归约部分。
2. **归约redex**：对redex进行归约，得到简化的表达式。
3. **更新图形**：用归约的结果替换redex在图形中的位置，以便共享计算结果。
### **2.1.3 展开脊柱以找到下一个redex**

**脊柱（Spine）**：表达式中应用节点（application nodes）的左分支形成的链，称为脊柱。

**找到下一个redex的步骤**：

1. **展开脊柱**：
- 从表达式的根节点开始，沿着应用节点的左分支遍历，直到到达一个超级组合子（supercombinator）或内置的原语函数。
2. **确定应用节点的层次**：
- 检查超级组合子或原语函数需要的参数数量，回溯相应数量的应用节点，找到最外层的函数应用，即redex的根节点。
**示例**：

考虑表达式`(f E1 E2 E3)`，假设`f`需要两个参数。

- **脊柱展开**：
```lua
Stack
-----------          @
| ---|------->      / \
-------             @   E3
| ---|----->       / \
-------            @   E2
| ---|--->        / \
-------           f  E1
```
- **找到redex**：回溯两个应用节点，找到`(f E1 E2)`，这是下一个redex。
### **2.1.4 超级组合子redex**

**超级组合子（Supercombinator）**：

- 超级组合子是顶层定义的函数，没有自由变量。
**归约超级组合子redex**：

- **替换**：将redex替换为超级组合子体的一个实例，将实际参数的指针替换到形式参数的位置。
- **共享**：通过指针共享实际参数，避免复制。
**处理let和letrec表达式**：

- **let表达式**：描述了一个无环图，可以共享子表达式。
- **letrec表达式**：描述了一个有环图（循环），用于表示递归定义。
**示例**：

```haskell
f x = let y = x * x
      in y + y
```

- **图形表示**：
```markdown
    @
   / \
  f   3
```
- **归约f 3**：替换f的定义，构建y = 3 * 3，y + y。
### **2.1.5 更新**

**更新的必要性**：

- **避免重复计算**：当一个redex被多次引用时，必须在归约后更新图形，以便所有引用都能共享计算结果。
**间接节点（Indirection Node）**：

- 在某些情况下，直接替换可能导致重复计算。为了解决这个问题，引入了间接节点，表示一个指向其他节点的引用。
**示例**：

```haskell
id x = x
f p = (id p) * p
main = f (sqrt 4)
```

- **问题**：在计算`(id p)`时，如果直接替换，会导致`(sqrt 4)`被计算两次。
- **解决方案**：使用间接节点，将`(id p)`的结果更新为指向`p`，从而共享`(sqrt 4)`的计算结果。
### **2.1.6 常量应用形式（CAFs）†**

**常量应用形式（CAF）**：

- 没有参数的超级组合子称为CAF。
- **特点**：CAF本身是一个redex，需要在归约后更新，以共享计算结果。
**示例**：

```haskell
fac20 = factorial 20
```

- **处理**：fac20的定义需要被更新，以便后续引用共享factorial 20的计算结果。
### **2.2 状态转换系统**

为了实现图形归约，我们使用状态转换系统来描述机器的行为。

#### **什么是状态转换系统**

- **定义**：状态转换系统是一种用于描述顺序机器行为的形式化方法。
- **组成**：**状态**：机器在任意时刻的状态，由一组变量描述。**初始状态**：机器开始执行时的状态。**转换规则**：定义状态如何从一个状态转换到另一个状态。
- **执行过程**：**匹配规则**：在当前状态下，找到匹配的转换规则。**应用规则**：根据规则，产生新的状态。**重复**：直到没有规则可以应用，机器停止。
#### **示例：简单的乘法机**

定义一个简单的机器来计算两个数的乘积。

**状态定义**：

- **状态四元组**：(n, m, d, t)n：乘法的一个操作数。m：乘法的另一个操作数。d：计数器，用于控制循环。t：累加器，保存计算的结果。
- **初始状态**：`(n, m, 0, 0)`
**转换规则**：

1. **第一条规则**：当`d > 0`时，递减`d`，增加`t`。
```scss
n m d t
⇒ n m (d - 1) (t + 1)
```
2. **第二条规则**：当`d == 0`且`m > 0`时，重置`d`为`n`，递减`m`。
```scss
n m 0 t
⇒ n (m - 1) n t
```
**终止条件**：

- 当m == 0且d == 0时，机器停止，t即为n和m的乘积。
**执行示例**：

- 初始状态`(2, 3, 0, 0)`：应用第二条规则，得到(2, 2, 2, 0)。应用第一条规则两次，(2, 2, 1, 1)，(2, 2, 0, 2)。再次应用第二条规则，得到(2, 1, 2, 2)。重复上述步骤，最终得到(2, 0, 0, 6)。
#### **不变性和证明**

**不变性（Invariant）**：

- 在状态转换过程中，某些条件始终成立。
- **示例**：`t + (m * n) = N * M`，其中`N`和`M`是`n`和`m`的初始值。
**证明机器的正确性**：

1. **初始状态**：验证不变性在初始状态成立。
2. **规则应用**：证明如果不变性在当前状态成立，那么在应用规则后仍然成立。
3. **终止条件**：结合不变性和终止条件，得出`t = N * M`。
4. **终止性**：证明机器最终会停止。
#### **在Miranda中的实现**

**类型定义**：

```haskell
type MultState = (Int, Int, Int, Int)  -- (n, m, d, t)
```

**评估函数**：

```haskell
evalMult :: MultState -> [MultState]
evalMult state =
  if multFinal state
  then [state]
  else state : evalMult (stepMult state)
```

- **解释**：evalMult接受一个状态，返回从该状态开始的状态序列，直到机器停止。
**状态转换函数**：

```haskell
stepMult :: MultState -> MultState
stepMult (n, m, d, t) | d > 0 = (n, m, d - 1, t + 1)
stepMult (n, m, d, t) | d == 0 = (n, m - 1, n, t)
```

- **解释**：根据规则，计算下一个状态。
**终止条件函数**：

```haskell
multFinal :: MultState -> Bool
multFinal (n, m, d, t) = m == 0 && d == 0
```

- **解释**：当m == 0且d == 0时，机器停止。
**执行示例**：

- 运行evalMult (2, 3, 0, 0)，应得到状态序列，最后状态为(2, 0, 0, 6)。
**全面详尽的总结**

本章深入介绍了模板实例化（Template Instantiation）和图形归约（Graph Reduction）在实现函数式语言中的应用。通过对关键概念、示例和实现细节的详细讲解，读者可以理解函数式语言的基本执行模型，以及如何在实践中实现它。

**主要内容回顾：**

1. **模板实例化的关键概念**：
- **表达式表示为图形**：表达式通过图形结构表示，节点表示函数、变量和常量。
- **归约过程**：通过找到redex（可归约表达式），进行归约并更新图形，直到达到正常形式。
- **归约策略**：采用正常序归约，确保在可能的情况下，计算会终止。
2. **归约示例解析**：
- 通过对square (square 3)的计算，演示了图形归约的过程，包括共享子表达式和避免重复计算。
3. **归约的技术细节**：
- **脊柱展开**：如何找到下一个redex，以及如何处理函数应用的参数。
- **超级组合子redex**：如何替换和共享实际参数。
- **更新策略**：使用间接节点避免重复计算。
- **常量应用形式（CAF）**：处理没有参数的超级组合子，确保共享计算结果。
4. **状态转换系统的引入**：
- **定义和作用**：描述机器的行为，提供一种形式化的方法来实现图形归约。
- **示例**：通过实现一个简单的乘法机，展示了状态转换系统的使用方法。
- **证明正确性**：通过不变性和状态转换规则，证明机器的正确性和终止性。
5. **在函数式语言中的实现**：
- **类型定义**：使用类型定义来表示机器的状态。
- **递归函数**：使用递归函数来模拟机器的执行过程。
- **条件和规则**：根据状态转换规则，定义状态更新和终止条件。
**重要的概念和技能：**

- **图形归约的理解**：掌握了如何使用图形表示表达式，以及如何通过归约和更新来计算表达式的值。
- **惰性计算和共享**：认识到共享子表达式的重要性，避免了重复计算，提高了效率。
- **状态转换系统的应用**：学会了如何使用状态转换系统来描述和实现计算过程。
- **函数式编程的实践**：通过在Miranda中的实现，体会了函数式编程的思想和技巧，如递归、模式匹配和高阶函数。
**结语**

通过本章的学习，您对模板实例化和图形归约有了深入的理解。这些概念对于实现函数式语言的解释器或编译器至关重要。掌握了这些基础，您可以更好地理解函数式语言的执行模型，为后续的学习和实践奠定坚实的基础。
 #  
 Thought for 58 seconds
**概览**

您提供的内容是《Implementing Functional Languages: A Tutorial》一书的第二章，标题为“模板实例化”（Template Instantiation）。本章介绍了基于模板实例化的图归约（graph reduction），这是实现函数式语言最简单的方法之一。通过对模板实例化的回顾，以及状态转换系统的介绍，作者为实现一个基本的图归约器奠定了基础。

主要内容包括：

- **2.1 模板实例化回顾**：解释了函数式语言的执行方式，即通过对表达式的求值来执行程序，并介绍了图归约的基本概念和过程。
- **2.1.1 示例**：通过一个具体的Core语言程序，展示了图归约的具体步骤和细节。
- **2.1.2 三个步骤**：概述了图归约过程中重复的三个主要步骤。
- **2.1.3 展开脊柱以找到下一个redex**：解释了如何在表达式中找到下一个可归约的表达式（redex）。
- **2.1.4 超级组合子redex**：讨论了如何对超级组合子（supercombinator）进行归约。
- **2.1.5 更新**：强调了在归约过程中更新redex根节点的重要性，以及可能遇到的问题。
- **2.1.6 常量应用形式（CAFs）**：介绍了没有参数的超级组合子（常量应用形式）以及它们的处理方式。
- **2.2 状态转换系统**：介绍了用于描述图归约实现的状态转换系统，并通过一个简单的乘法机示例来说明其用法。
通过本章，您将深入理解模板实例化和图归约的原理，以及如何使用状态转换系统来描述和实现图归约器。

**详细解析**

### **2.1 模板实例化回顾**

#### **背景**

模板实例化是一种实现非严格（惰性）函数式语言的技术，它使用图归约来计算表达式的值。在这种模型中，程序被表示为一个图结构，通过对图中的可归约表达式（redex）进行替换和更新来执行计算。

#### **关键概念**

- **函数式程序的执行**：函数式程序是通过求值表达式来执行的。
- **表达式表示为图**：表达式被表示为一个图，其中节点代表函数、变量、常量等。这种图形表示允许共享子表达式，从而实现惰性计算。
- **归约**：计算通过一系列的归约步骤完成，每个步骤都将一个redex替换为其简化形式。
- **可归约表达式（redex）**：一个可以被进一步简化的表达式。例如，函数应用f x在f和x都可用的情况下就是一个redex。
- **正常形式**：当表达式中不再有redex时，求值完成，表达式被称为处于正常形式。
- **归约顺序**：在任何时刻，表达式中可能存在多个redex。幸运的是，在纯函数式语言中，无论选择哪个redex进行归约，最终的结果都是相同的（即正常形式）。但要注意，不同的归约序列可能导致计算无法终止。
- **正常序归约（Normal Order Reduction）**：为了确保在可能终止的情况下计算能够终止，我们总是选择最外层的redex进行归约，这被称为正常序归约。
#### **归约过程概述**

归约过程可以描述为：

1. **找到下一个redex**：在表达式中找到最外层的redex。
2. **归约redex**：将redex替换为其简化形式。
3. **更新redex的根节点**：在图中用归约的结果更新redex的根节点，以实现共享和惰性计算。
这个过程会重复进行，直到表达式中不再有redex，即达到正常形式。

### **2.1.1 示例**

**程序示例**

考虑以下Core语言程序：

```haskell
square x = x * x ;
main = square (square 3)
```

- **解释**：定义了一个函数square，计算一个数的平方。定义了main，计算square (square 3)，即计算3的四次方。
**图形表示和归约步骤**

1. **初始表达式**
```css
main
```

- main是程序的入口点，也是要计算的表达式。
2. **展开main**
- main是一个超级组合子，没有参数，因此它本身是一个redex，可以替换为其定义的右侧。
```markdown
    @
   / \
square  @
        / \
    square  3
```

- @表示函数应用。
3. **归约最外层的square应用**
- 我们需要归约square (square 3)，将square的定义替换进来。
- 归约过程涉及将实际参数替换到函数体中，同时使用指针共享实际参数。
```markdown
     @!
    /  \
square   @
         / \
     square  3
```

- 归约后的图形：
```python
     @!
    /  \
     @    @
    / \  / \
square 3  *  \
               / \
           square 3
```

- 注意到内层的square 3被共享，因此图形中存在了一个共享的子图，形成了一个图而非树。
4. **归约内层的square 3**
- 内层的square 3是下一个redex。
- 将square的定义应用于3，即计算3 * 3。
```javascript
     @
    / \
   @    *
  / \  / \
 *  3 *   \
          / \
          3
```
5. **计算乘法**
- 内层的乘法3 * 3是一个redex，需要计算。
- 计算得到9，并更新图形。
```javascript
     @
    / \
   @    *
  / \  / \
  9   9
```
6. **计算外层乘法**
- 外层的乘法9 * 9是最后的redex。
- 计算得到81，这就是最终的结果。
**关键点**

- **共享子表达式**：通过使用指针共享，避免了对square 3的重复计算。
- **图归约**：通过对图形的更新，实现了惰性计算和共享。
- **更新redex根节点**：在归约后，我们需要更新redex的根节点，以确保共享的引用都能获得更新的结果。
### **2.1.2 三个步骤**

图归约过程重复以下三个步骤，直到达到正常形式：

1. **找到下一个redex**：在表达式中找到最外层的可归约表达式。
2. **归约redex**：对redex进行归约，得到简化的表达式。
3. **更新redex的根节点**：用归约的结果更新redex的根节点。
### **2.1.3 展开脊柱以找到下一个redex**

#### **脊柱（Spine）**

- **定义**：从根节点开始，沿着应用节点的左分支，形成的链称为脊柱。
- **作用**：通过展开脊柱，可以找到表达式中最外层的函数应用。
#### **找到下一个redex的步骤**

1. **展开脊柱**：
- 从表达式的根节点开始，沿着左分支遍历，直到到达一个超级组合子或内置的原语函数。
- 在遍历过程中，使用堆栈记录节点的地址。
2. **确定函数应用的根节点**：
- 检查函数需要的参数数量，回溯相应数量的应用节点，找到完整的函数应用，即redex的根节点。
**示例**

考虑表达式`(f E1 E2 E3)`，假设`f`需要两个参数。

- **脊柱展开**：
```lua
Stack
-----------
| ---|-------> @
-------       / \
| ---|-----> @!  E3
-------      / \
| ---|---> @   E2
-------     / \
| ---|-> f  E1
-------

```
- **找到redex**：由于`f`需要两个参数，因此回溯两个应用节点，找到`(f E1 E2)`，这是下一个redex。
#### **弱头部正常形式（WHNF）**

- 如果函数需要的参数比提供的多，则无法进行归约，此时表达式被认为处于WHNF。
- 在这种情况下，解释器通常会停止进一步归约。
### **2.1.4 超级组合子redex**

#### **超级组合子**

- **定义**：没有自由变量的顶层函数定义称为超级组合子。
- **归约**：当超级组合子被应用时，可以进行归约。
#### **超级组合子归约**

- **过程**：**替换**：将redex替换为超级组合子体的一个实例。**参数绑定**：将实际参数的指针替换到函数体中对应的形式参数位置。**共享**：通过指针共享，实现参数的共享，避免复制。
- **示例**：
```haskell
f x = let y = x * x
      in y + y
```
**归约f 3**：
```python
@
```
/f 3
```markdown

- 替换`f`的定义，构建`let y = 3 * 3 in y + y`。
- `let`表达式描述了一个无环图，`y`被绑定为`3 * 3`，在`y + y`中共享。
```
### **2.1.5 更新**

#### **更新的重要性**

- **共享结果**：在归约后，需要更新redex的根节点，以确保所有共享引用都能获得更新的结果。
- **惰性计算的核心**：更新操作是惰性计算的核心，确保计算成本只会被承担一次。
#### **可能的问题**

- **重复计算**：如果不正确地更新redex，可能导致重复计算。
- **示例**：
```haskell
id x = x
f p = (id p) * p
main = f (sqrt 4)
```
如果在归约id p后，直接用(sqrt 4)替换id p，则sqrt 4会被计算两次。
#### **解决方案**

- **引入间接节点（Indirection Node）**：使用一个特殊的节点#，表示一个间接引用。在更新redex时，将其替换为一个间接节点，指向归约的结果。
- **示例**：
```python
@ reduces to @
/\         /\
@\        @\
/\ \      /\ \
*@\      *#\
/ \___@   \___@
id  / \   /   \
   sqrt 4 sqrt 4
```
使用间接节点#，确保sqrt 4只被计算一次。
### **2.1.6 常量应用形式（CAFs）†**

#### **定义**

- **常量应用形式（CAF）**：没有参数的超级组合子称为常量应用形式。
#### **处理方式**

- **问题**：CAF本身是一个redex，需要小心处理，避免重复计算。
- **解决方案**：将CAF表示为图中的一个节点，允许在归约后更新它。确保后续对CAF的引用都能共享计算结果。
- **示例**：
```haskell
fac20 = factorial 20
```
在首次计算fac20后，更新其节点，以便后续使用时直接获取结果。
### **2.2 状态转换系统**

#### **概述**

- **定义**：状态转换系统是一种用于描述顺序机器行为的形式化方法。
- **组成**：**状态**：机器在某一时刻的状态，由一组变量表示。**初始状态**：机器开始执行时的状态。**转换规则**：定义状态如何从一个状态转换到另一个状态。
- **执行过程**：**匹配规则**：根据当前状态，找到匹配的转换规则。**应用规则**：根据规则，产生新的状态。**重复**：直到没有规则可以应用，机器停止。
#### **特点**

- **抽象性**：足够抽象，不会陷入低级细节。
- **具体性**：足够具体，确保不会在规则中隐藏复杂性。
- **可实现性**：可以直接转换为可执行的程序。
#### **示例：乘法机**

**状态定义**

- **状态四元组**：`(n, m, d, t)`n：第一个乘数。m：第二个乘数。d：当前的计数器，用于控制循环。t：累计的乘积。
- **初始状态**：`(n, m, 0, 0)`
**转换规则**

1. **规则1**：当`d > 0`时，递减`d`，增加`t`。
```
n  m  d    t
⇒ n  m  d-1  t+1
```
2. **规则2**：当`d == 0`且`m > 0`时，重置`d`为`n`，递减`m`。
```
n  m   0    t
⇒ n  m-1 n    t
```
**终止条件**

- 当没有规则可以应用时，机器停止。
- 终止时，状态为(n, 0, 0, t)，其中t为n和m的乘积。
**执行示例**

- **初始状态**：`(2, 3, 0, 0)`
- **步骤**：规则2应用，得到(2, 2, 2, 0)规则1应用，(2, 2, 1, 1)规则1应用，(2, 2, 0, 2)规则2应用，(2, 1, 2, 2)重复上述步骤，最终得到(2, 0, 0, 6)
**不变量**

- **定义**：在状态转换过程中始终成立的条件。
- **不变量**：t + d * m = N * M，其中N和M是初始的n和m。
**证明**

1. **初始状态**：不变量成立，因为t = 0，d = 0，m = M，所以t + d * m = N * M。
2. **规则应用**：验证规则应用后，不变量仍然成立。
3. **终止状态**：m = 0，d = 0，所以t = N * M。
4. **终止性**：由于m和d都会递减，最终机器会停止。
#### **在Miranda中的实现**

**类型定义**

```haskell
type MultState = (Int, Int, Int, Int)  -- (n, m, d, t)
```

**评估函数**

```haskell
evalMult :: MultState -> [MultState]
evalMult state =
  if multFinal state
  then [state]
  else state : evalMult (stepMult state)
```

- **解释**：递归地生成状态序列，直到达到终止条件。
**状态转换函数**

```haskell
stepMult (n, m, d, t) | d > 0 = (n, m, d-1, t+1)
stepMult (n, m, d, t) | d == 0 = (n, m-1, n, t)
```

**终止条件函数**

```haskell
multFinal :: MultState -> Bool
multFinal (n, m, d, t) = m == 0 && d == 0
```

- **解释**：当m和d都为0时，机器停止。
**示例执行**

- 运行evalMult (2, 3, 0, 0)，应得到状态序列，最后状态为(2, 0, 0, 6)。
**全面详尽的总结**

本章深入探讨了模板实例化和图归约的原理，以及如何使用状态转换系统来描述和实现图归约器。

**主要内容总结**

1. **模板实例化和图归约**
- **核心思想**：通过将程序表示为图形结构，利用指针共享实现惰性计算。
- **归约过程**：重复找到redex、归约并更新，直到达到正常形式。
- **重要概念**：**Redex**：可归约的表达式。**脊柱展开**：通过展开表达式的脊柱找到下一个redex。**超级组合子**：没有自由变量的函数定义，其归约涉及参数替换和共享。
2. **更新机制**
- **必要性**：在归约后更新redex的根节点，确保共享的子表达式正确地引用更新后的结果。
- **间接节点**：为了解决更新时可能导致的重复计算问题，引入了间接节点。
3. **常量应用形式（CAFs）**
- **特点**：没有参数的超级组合子，需要特殊处理以避免重复计算。
- **处理方法**：将CAF表示为图中的节点，允许更新以共享计算结果。
4. **状态转换系统**
- **用途**：用于描述图归约器的实现。
- **组成**：状态、初始状态、转换规则和终止条件。
- **示例**：通过实现一个简单的乘法机，演示了状态转换系统的使用。
5. **Miranda实现**
- **类型定义**：使用类型别名定义状态。
- **递归函数**：evalMult和stepMult实现了状态的转换和序列生成。
- **终止条件**：multFinal函数确定何时停止。
**重要概念和技巧**

- **惰性计算**：通过共享和更新，避免了不必要的计算，提高了效率。
- **指针共享**：在图归约中，使用指针共享实际参数，避免了复制，支持惰性求值。
- **图形表示**：将表达式表示为图，有助于实现共享和惰性计算。
- **状态转换系统**：提供了一个形式化的方法来描述机器的行为，便于分析和实现。
**结语**

通过本章的学习，您对模板实例化和图归约有了深入的理解，掌握了如何利用状态转换系统来描述和实现函数式语言的执行模型。这些知识对于理解函数式语言的实现原理，以及编译器和解释器的设计至关重要。在后续的学习中，您可以进一步探索更复杂的实现技术，如引入垃圾回收、优化策略等。
 #  
 Thought for 57 seconds
**概览**

本段内容来自《Implementing Functional Languages: A Tutorial》一书的第二章，主要讨论了如何在基于模板实例化的图归约器中逐步添加新功能。具体来说，本段内容涵盖了以下几个主要部分：

- **2.4 Mark 2: let(rec)表达式**：扩展我们的图归约器以支持`let`和`letrec`表达式，讨论了在实例化过程中需要做出的修改。
- **2.5 Mark 3: 添加更新**：介绍了如何在归约过程中执行更新，以实现共享，避免重复计算。提出了使用间接节点（indirection nodes）的策略，并说明了实现细节。
- **2.5.1 减少间接节点的数量**：讨论了如何优化更新过程，减少间接节点的使用，提高效率。
- **2.6 Mark 4: 添加算术运算**：讲解了如何在图归约器中添加算术运算支持，包括设计状态转换规则，以及在实现过程中需要注意的地方。
通过这几个部分，作者逐步引导读者实现一个更完整、更高效的函数式语言解释器。

**详细解析**

### **2.4 Mark 2: let(rec)表达式**

#### **背景**

在之前的实现中，我们的图归约器还不支持`let`和`letrec`表达式。`let`和`letrec`是函数式语言中的重要特性，它们允许我们在表达式中定义局部绑定。

根据之前在**2.1.4节**的讨论，超级组合子的主体可能包含`let(rec)`表达式，这些表达式被视为图的文本描述。

#### **目标**

- **扩展instantiate函数**：我们需要修改`instantiate`函数，使其能够处理`ELet`构造器。
- **支持非递归的let表达式**：首先，我们要处理非递归的`let`表达式。
- **支持递归的letrec表达式**：然后，扩展处理递归的`letrec`表达式。
#### **实现非递归let表达式**

**Exercise 2.10**

**任务**：为非递归的`let`表达式添加`instantiate`的等式。

**步骤**：

1. **实例化右侧表达式**：对`defs`中的每个定义的右侧进行实例化。
- `defs`是一个列表，包含一系列的绑定，每个绑定是一个`(Name, CoreExpr)`对。
- 对于每个`(name, expr)`，需要对`expr`进行实例化。
2. **扩展环境**：将`defs`中的名字绑定到新创建的实例的地址上，扩展环境。
- 我们需要将每个名字name与其实例化结果的地址关联起来。
3. **实例化主体**：使用扩展后的环境，对`body`进行实例化。
**实现思路**：

- 在实例化`ELet`时，我们需要先处理`defs`中的定义，然后再处理`body`。
- 对于非递归`let`，在实例化`defs`中的表达式时，环境中不包含这些名字的绑定。
**代码示例**：

```haskell
instantiate (ELet nonRecursive defs body) heap env = instantiateLet heap env defs body
```

在`instantiateLet`函数中：

```haskell
instantiateLet heap env defs body = 
    let
        -- 实例化右侧表达式
        (heap', addrs) = mapAccumL instantiateDef heap defs
        -- 扩展环境
        env' = env ++ zip names addrs
        names = [name | (name, _) <- defs]
        -- 实例化主体
        (heap'', addr) = instantiate body heap' env'
    in
        (heap'', addr)
    where
        instantiateDef heap (name, expr) = instantiate expr heap env
```

**注意**：`mapAccumL`是一个类似于`map`的函数，但它会传递一个累加器（这里是`heap`）。

#### **实现递归letrec表达式**

**Exercise 2.11**

**任务**：将非递归`let`的`instantiate`等式复制一份，修改以处理递归的情况，或者修改定义以同时处理两种情况。

**提示**：

- 与`let`的区别在于，在实例化`defs`中的右侧表达式时，环境需要包含`defs`中的名字绑定。
- 这意味着在步骤1中，需要使用扩展后的环境。
**实现思路**：

- 对于letrec，我们需要先确定defs中每个绑定的地址，然后在环境中添加这些绑定，再实例化右侧表达式。
**代码示例**：

```haskell
instantiate (ELet recursive defs body) heap env = instantiateLetrec heap env defs body
```

在`instantiateLetrec`函数中：

```haskell
instantiateLetrec heap env defs body = 
    let
        -- 分配地址，但暂不实例化
        (heap', addrs) = mapAccumL allocateDummy heap defs
        -- 扩展环境
        env' = env ++ zip names addrs
        names = [name | (name, _) <- defs]
        -- 实例化右侧表达式，使用扩展后的环境
        heap'' = foldl instantiateDef heap' (zip addrs [expr | (_, expr) <- defs])
        -- 实例化主体
        (heap''', addr) = instantiate body heap'' env'
    in
        (heap''', addr)
    where
        allocateDummy heap _ = hAlloc heap (NInd (error "dummy address"))
        instantiateDef heap (addr, expr) = hUpdate heap addr node
            where
                (heap', nodeAddr) = instantiate expr heap env'
                node = NInd nodeAddr
```

**解释**：

- **分配占位符节点**：在`allocateDummy`中，我们为每个定义分配一个占位符节点，可以是`NInd`节点或其他占位符。
- **扩展环境**：在实例化右侧表达式时，环境中已经包含了所有定义的名字和对应的地址，这样可以处理递归引用。
- **实例化右侧表达式**：在`instantiateDef`中，我们使用扩展后的环境实例化右侧表达式，并更新之前的占位符节点。
**关于提示的解释**：

- 在非严格的函数式语言（如Miranda）中，我们可以先定义环境，再使用它，即使环境中的一些值还未计算。
- 在实际实现中，我们需要手动处理这种循环依赖。
#### **测试程序**

**提供的程序**：

```haskell
pair x y f = f x y ;

fst p = p K ;

snd p = p K1 ;

f x y = letrec
    a = pair x b ;
    b = pair y a
in
    fst (snd (snd (snd a))) ;

main = f 3 4
```

**预期结果**：`4`

**解释**：

- 这是一个使用递归定义的例子，`a`和`b`互相引用，形成了一个循环结构。
- 通过逐步展开，可以看到最终结果是`4`。
- 详细的工作原理将在**2.8.3节**解释。
#### **Exercise 2.12**

**任务**：考虑以下程序

```haskell
main = letrec f = f x in f
```

- **问题**：运行此程序会发生什么？
- **思考**：这个程序定义了一个递归函数`f`，它依赖于自身和一个未定义的变量`x`。
- **答案**：运行此程序会导致无限递归，最终导致堆栈溢出或非终止。在强类型的语言（如Miranda）中，这种情况可能会被类型检查器捕获，因为`x`未定义，或者类型不匹配。
### **2.5 Mark 3: 添加更新**

#### **背景**

- 在当前的归约机中，没有执行更新操作，这意味着共享的子表达式可能会被多次求值，导致效率低下。
- 为了避免重复计算，我们需要在归约后更新redex的根节点。
#### **目标**

- **使用间接节点（Indirection Nodes）**：更新redex的根节点，使其指向归约结果，从而实现共享。
- **修改状态转换规则**：调整归约规则以支持更新操作。
#### **修改归约规则**

**更新超级组合子redex的规则**

- 原始规则（2.2）：
```yaml
a0 : a1 : ... : an : s d h [a0 : NSupercomb [x1,..., xn] body] f
⇒ ar : s d h' f
```
- 修改后的规则（2.3）：
```yaml
a0 : a1 : ... : an : s d h [a0 : NSupercomb [x1,..., xn] body] f
⇒ ar : s d h' [an : NInd ar ] f
```
**解释**：

- 在归约超级组合子时，我们不仅要实例化其主体，还需要在堆中更新redex的根节点，使其成为一个间接节点，指向归约结果。
- 如果超级组合子是一个CAF（常量应用形式），则`n = 0`，需要更新的节点是超级组合子节点本身。
**添加处理间接节点的规则**

- 新的规则（2.4）：
```yaml
a : s d h [a : NInd a1] f
⇒ a1 : s d h f
```
- **解释**：当在展开脊柱时遇到间接节点，我们需要跳过它，直接指向它所引用的节点。
#### **实现步骤**

1. **修改Node数据类型**：添加`NInd`构造器。
```haskell
data Node = NAp Addr Addr -- Application
          | NSupercomb Name [Name] CoreExpr -- Supercombinator
          | NNum Int -- Number
          | NInd Addr -- Indirection
```
2. **更新showNode函数**：添加对`NInd`的处理，以便在调试时正确显示。
3. **修改scStep函数**：
- 使用`hUpdate`函数，在堆中更新redex的根节点，创建一个`NInd`节点，指向归约结果。
- **注意**：需要根据规则（2.3）进行修改。
4. **修改dispatch函数**：
- 添加对NInd节点的处理，根据规则（2.4）实现。
```haskell
dispatch (NInd addr) = indStep state addr
```

- 在indStep中，更新堆栈，替换间接节点的地址为其指向的地址。
#### **Exercise 2.13**

**任务**：按照上述步骤进行修改，以使用间接节点执行更新操作。

**测试程序**：

```haskell
id x = x ;

main = twice twice id 3
```

- **twice**函数在**1.4节**的`preludeDefs`中定义，作用是将一个函数应用两次。
- **思考**：手动归约此程序，观察在没有更新（Mark 1）和添加更新（Mark 3）的情况下，归约次数的差异。
- **进一步测试**：将`main`定义为`twice twice twice id 3`，观察归约次数的变化。
### **2.5.1 减少间接节点的数量**

#### **问题**

- 在某些情况下，我们将redex的根节点更新为指向由`instantiate`新创建的节点。
- 由于归约结果是新创建的节点，没有共享，可以直接在redex的根节点上构建结果，而无需创建间接节点。
#### **解决方案**

- **定义instantiateAndUpdate函数**：类似于`instantiate`，但接受一个额外的参数：要更新的节点地址。直接在指定的地址上构建实例化结果。
```haskell
instantiateAndUpdate :: CoreExpr -> Addr -> TiHeap -> ASSOC Name Addr -> TiHeap
```
- **实现示例**（对于应用表达式）：
```haskell
instantiateAndUpdate (EAp e1 e2) upd_addr heap env
    = hUpdate heap2 upd_addr (NAp a1 a2)
    where
        (heap1, a1) = instantiate e1 heap env
        (heap2, a2) = instantiate e2 heap1 env
```
#### **Exercise 2.14**

**任务**：完成`instantiateAndUpdate`的定义，需要注意以下几点：

- **对于变量**：当要实例化的表达式是一个简单变量时，仍然需要使用间接节点。**原因**：变量可能引用已有的节点，需要保持共享，不能直接在redex的根节点上构建。
- **处理let(rec)表达式的递归实例化**：在处理let(rec)时，需要小心递归实例化的顺序和环境的使用。
- **修改scStep函数**：使用`instantiateAndUpdate`替代`instantiate`。传递redex根节点的地址，作为要更新的地址。
- **移除scStep中的更新代码**：因为instantiateAndUpdate已经在实例化过程中完成了更新。
**测量效果**：

- 比较修改前后，归约次数和堆节点分配数量的变化。
- **预期结果**：减少间接节点的数量，提高效率。
### **2.6 Mark 4: 添加算术运算**

#### **背景**

- 我们希望在图归约器中添加算术运算支持，如加减乘除和取反。
- 这需要处理新的节点类型，以及在归约过程中处理严格的求值策略。
#### **目标**

- **添加算术原语（Primitive）节点**。
- **使用dump**：首次使用`dump`，用于保存求值过程中需要恢复的堆栈状态。
#### **状态转换规则**

**以取反（Negation）为例**

- **当参数已求值时**：规则（2.5）：
```yaml
a : a1 : [] d h
[ a : NPrim Neg
  a1 : NAp a b
  b : NNum n ]
f
⇒ a1 : [] d h [a1 : NNum (-n)] f
```
- **当参数未求值时**：需要求值参数，在新的堆栈上进行，以避免干扰当前的求值。**引入dump**：用于保存当前堆栈，以便在参数求值完成后恢复。规则（2.6）：
```yaml
a : a1 : [] d h
[ a : NPrim Neg
  a1 : NAp a b ]
f
⇒ b : [] (a : a1 : []) : d h f
```
- **参数求值完成后**：恢复之前的堆栈，继续处理取反操作。规则（2.7）：
```yaml
a : [] s : d h [a : NNum n] f
⇒ s d h f
```
**处理间接节点**

- 当参数求值后，可能是一个间接节点，需要处理。
- 添加规则（2.8）：
```yaml
a : s d h
[ a : NAp a1 a2
  a2 : NInd a3 ]
f
⇒ a : s d h [a : NAp a1 a3] f
```
- **修改规则（2.6）**：使得在参数求值完成后，从redex的根节点重新展开。规则（2.9）：
```yaml
a : a1 : [] d h
[ a : NPrim Neg
  a1 : NAp a b ]
f
⇒ b : [] (a1 : []) : d h f
```
#### **实现算术运算**

**修改TiDump类型**

- 定义`dump`为堆栈的堆栈：
```haskell
type TiDump = [TiStack]
initialTiDump = []
```
**修改Node数据类型**

- 添加`NPrim`构造器：
```haskell
data Node = NAp Addr Addr -- Application
          | NSupercomb Name [Name] CoreExpr -- Supercombinator
          | NNum Int -- Number
          | NInd Addr -- Indirection
          | NPrim Name Primitive -- Primitive
```
**定义Primitive类型**

- 定义算术原语的类型：
```haskell
data Primitive = Neg | Add | Sub | Mul | Div
```
**修改buildInitialHeap**

- 在初始堆中添加原语节点：
```haskell
buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
buildInitialHeap sc_defs
    = (heap2, sc_addrs ++ prim_addrs)
    where
        (heap1, sc_addrs) = mapAccuml allocateSc hInitial sc_defs
        (heap2, prim_addrs) = mapAccuml allocatePrim heap1 primitives
```
- 定义原语的映射：
```haskell
primitives :: ASSOC Name Primitive
primitives = [ ("negate", Neg),
               ("+", Add), ("-", Sub),
               ("*", Mul), ("/", Div) ]
```
**实现allocatePrim函数**

- 分配原语节点并返回地址：
```haskell
allocatePrim :: TiHeap -> (Name, Primitive) -> (TiHeap, (Name, Addr))
allocatePrim heap (name, prim)
    = (heap', (name, addr))
    where
        (heap', addr) = hAlloc heap (NPrim name prim)
```
**修改dispatch函数**

- 添加对`NPrim`节点的处理：
```haskell
dispatch (NPrim name prim) = primStep state prim
```
**实现primStep和primNeg**

- `primStep`根据原语调用相应的处理函数：
```haskell
primStep state Neg = primNeg state
```
- `primNeg`的实现需要：**获取参数**：使用`getArgs`从堆栈中提取参数的地址。**检查参数是否求值**：使用`isDataNode`检查参数节点是否已求值。**未求值时**：按照规则（2.9），设置新的状态，准备求值参数。将当前堆栈压入`dump`。创建新的堆栈，只包含取反操作的参数。**已求值时**：使用`hUpdate`更新redex的根节点，创建一个`NNum`节点，包含结果。修改堆栈，恢复之前的状态。
**修改numStep和apStep**

- **numStep**：实现规则（2.7），当堆栈只有一个NNum节点，且dump非空时，弹出dump的顶层堆栈，替换当前堆栈。
- **apStep**：实现规则（2.8），当应用节点的参数是NInd节点时，更新应用节点，使其参数指向NInd节点所指向的地址。
**修改tiFinal**

- 只有当堆栈中只有一个NNum节点，且dump为空时，才停止执行。
#### **Exercise 2.16**

**任务**：实现上述所有修改，添加取反操作，并测试以下程序：

1. `main = negate 3`
2. `main = twice negate 3`
3. `main = negate (I 3)`
- **目标**：验证取反操作的正确性，以及间接节点的处理是否正常。
#### **扩展到其他算术运算**

- 发现加减乘除等双目运算具有相似的模式。
- **使用高阶函数**：定义一个通用的`primArith`函数，接受具体的运算符作为参数。
- **实现示例**：
```haskell
primStep state Add = primArith state (+)
primStep state Sub = primArith state (-)
primStep state Mul = primArith state (*)
primStep state Div = primArith state div
```
- **定义primArith函数**：
```haskell
primArith :: TiState -> (Int -> Int -> Int) -> TiState
```
#### **Exercise 2.17**

**任务**：实现`primArith`函数，完成加减乘除的支持，并测试你的实现。

**全面详尽的总结**

本段内容深入探讨了如何在基于模板实例化的图归约器中逐步添加关键特性，以实现一个更完整的函数式语言解释器。

**主要内容回顾**：

1. **支持let和letrec表达式（Mark 2）**：
- **处理非递归let表达式**：通过在`instantiate`函数中添加对`ELet`构造器的处理，实现对非递归`let`的支持。
- **处理递归letrec表达式**：通过在实例化过程中预先分配地址，扩展环境，然后实例化右侧表达式，实现对`letrec`的支持。
- **关键挑战**：处理递归引用，需要在环境中包含所有定义的绑定。
2. **添加更新机制（Mark 3）**：
- **引入间接节点**：使用`NInd`节点，在归约后更新redex的根节点，指向归约结果，实现共享，避免重复计算。
- **修改归约规则**：调整状态转换规则，添加对间接节点的处理。
- **优化更新过程**：通过`instantiateAndUpdate`函数，减少间接节点的数量，提高效率。
3. **添加算术运算（Mark 4）**：
- **引入算术原语节点**：添加`NPrim`节点，表示算术运算符。
- **使用dump**：在需要求值参数时，保存当前堆栈，创建新的堆栈求值参数，完成后恢复。
- **实现通用的算术运算处理**：使用高阶函数，定义`primArith`，避免代码重复。
**重要的概念和技巧**：

- **非严格求值和环境处理**：在实例化递归定义时，需要理解非严格求值的特性，巧妙地处理环境中的递归绑定。
- **共享和更新机制**：通过更新redex的根节点，实现共享，避免重复计算，是惰性求值的核心。
- **高阶函数的应用**：在实现算术运算时，使用高阶函数提高代码的可复用性和简洁性。
- **状态转换系统的调整**：在添加新特性时，需要相应地调整状态转换规则，确保解释器的正确性。
**总结**

通过本段内容的学习，我们深入了解了在实现函数式语言解释器时，需要面对的各种挑战和解决方案。我们学会了如何在图归约器中支持`let(rec)`表达式、添加更新机制，以及实现算术运算。同时，我们也认识到在函数式编程中，如何利用非严格求值、高阶函数等特性，编写高效、优雅的代码。

这些知识为我们进一步探索函数式语言的实现技术奠定了坚实的基础。在后续的章节中，我们将继续完善和优化我们的解释器，实现更多的功能和改进。
 #  
 Thought for 10 seconds
**概览**

您提供的内容来自《Implementing Functional Languages: A Tutorial》一书的第二章，作者是 Simon Peyton Jones。本段内容主要涉及扩展模板实例化的图归约器，以支持结构化数据类型和条件表达式。这包括以下主要部分：

- **2.7 Mark 5: 结构化数据**：介绍了向图归约器中添加结构化数据类型的需求和挑战。
- **2.7.1 构建结构化数据**：讨论了如何在实现中表示和构建结构化数据。
- **2.7.2 条件表达式**：引入布尔类型，讨论了如何实现条件表达式以支持递归函数。
- **2.7.3 实现结构化数据**：详细列出了在实现中需要进行的更改，以支持结构化数据和条件表达式。
- **2.7.4 元组（Pairs）**：介绍了如何处理元组，特别是如何在没有通用`case`表达式的情况下拆解元组。
- **2.7.5 列表**：扩展了对列表的支持，包括如何构建和拆解列表，以及实现常见的列表操作。
- **2.7.6 打印列表**：讨论了如何修改机器的状态，以支持输出列表，以及添加新的原语以处理输出操作。
通过这些内容，您将了解如何在模板实例化的图归约器中添加对结构化数据的支持，以及在没有通用`case`表达式的情况下如何处理数据的拆解和条件判断。

**详细解析**

### **2.7 Mark 5: 结构化数据**

#### **引言**

在之前的实现中，我们的图归约器还不支持结构化数据类型，如布尔值、元组和列表。在函数式编程中，结构化数据类型非常重要，因为它们允许我们表示复杂的数据结构和实现递归函数。然而，在模板实例化机器中引入结构化数据和`case`表达式存在一定的挑战。

#### **困难之处**

**Exercise 2.18**

**问题**：为什么在模板实例化机器中引入`case`表达式很困难？

**提示**：考虑`instantiate`函数在处理`case`表达式时会做什么。

**解答**：

- 在模板实例化机器中，`instantiate`函数负责在堆中创建表达式的实例。当遇到`case`表达式时，需要根据被匹配的表达式的值来选择合适的分支进行实例化。
- 然而，在实例化阶段，我们无法知道被匹配的表达式的值，因为它可能尚未计算。由于模板实例化机器在实例化时并不执行计算，因此无法在实例化过程中决定应该实例化哪个分支。
- 这导致了一个问题，即`instantiate`无法正确地处理`case`表达式，因为它需要在实例化时就知道匹配的结果。
因此，在模板实例化机器中直接实现通用的`case`表达式是困难的。

### **2.7.1 构建结构化数据**

#### **构造器的表示**

为了在我们的机器中支持结构化数据，我们需要能够表示和构建结构化数据对象。我们使用`Pack{t, a}`构造器，其中`t`是构造器的标签（tag），`a`是构造器的元数（arity），即它需要的参数数量（参见**1.1.4节**）。

#### **实现方法**

- **扩展Primitive类型**：将`Pack{t, a}`构造器视为一种新的原语（primitive），我们可以通过向`Primitive`类型添加一个新的构造器`PrimConstr`来实现。
```haskell
data Primitive = ... | PrimConstr Int Int
```
- **修改instantiateConstr**：在`instantiate`函数中，当遇到`EConstr t a`时，我们将其实例化为一个`NPrim "Pack" (PrimConstr t a)`节点。
```haskell
instantiate (EConstr t a) heap env = hAlloc heap (NPrim "Pack" (PrimConstr t a))
```
#### **构建结构化数据对象**

- **在primStep中处理PrimConstr**：在执行过程中，当遇到`NPrim (PrimConstr t n)`节点时，我们需要在`primStep`函数中添加对`PrimConstr`的处理。
- **构建NData节点**：我们需要在`Node`类型中添加一个新的构造器`NData`，用于表示结构化数据对象。
```haskell
data Node = ... | NData Int [Addr]
```
其中，Int是数据对象的标签tag，[Addr]是其组件的地址列表。
- **规则（2.10）**：当我们有足够的参数时，我们可以将原来的应用链替换为一个`NData`节点。
```yaml
a : a1 : ... : an : [] d h
[ a : NPrim (PrimConstr t n)
  a1 : NAp a b1
  ...
  an : NAp an-1 bn ]
f
⇒ an : [] d h[an : NData t [b1,..., bn]] f
```
### **2.7.2 条件表达式**

#### **引入布尔类型**

为了支持递归函数和条件判断，我们需要布尔类型。在Miranda中，布尔类型可以定义为：

```haskell
boolean ::= False | True
```

- 我们为`False`和`True`分别分配标签1和2，元数都为0。
- 在Core语言中，我们可以定义：
```haskell
False = Pack{1,0}
True = Pack{2,0}
```
#### **实现条件原语**

由于无法直接实现通用的`case`表达式，我们引入一个条件原语`if`，其具有以下归约规则：

```java
if Pack{2,0} t e = t
if Pack{1,0} t e = e
```

- **操作过程**：`if`首先计算其第一个参数（条件表达式）。如果条件为`True`（标签为2），则返回第二个参数`t`。如果条件为`False`（标签为1），则返回第三个参数`e`。
#### **实现细节**

**Exercise 2.19**

**任务**：为条件原语`if`编写状态转换规则。需要三个规则：

1. **当条件已计算并为True时**：
- 将`if`表达式替换为其第二个参数。
- 需要在堆中使用间接节点进行更新。
2. **当条件已计算并为False时**：
- 将`if`表达式替换为其第三个参数。
- 同样需要使用间接节点。
3. **当条件未计算时**：
- 开始对条件进行计算。
- 将当前堆栈压入`dump`，并创建一个新堆栈，包含条件表达式的地址。
**缺少的规则**：当条件计算完成后，我们需要一种方式重新尝试`if`表达式。这意味着在从`dump`中恢复堆栈后，需要重新展开`if`表达式。

**实现提示**：

- 在`primStep`函数中，添加对`If`原语的处理。
- 在`isDataNode`函数中，识别`NData`节点。
- 在`step`函数的`dispatch`部分，添加对`NData`节点的处理，调用`dataStep`函数。
#### **定义其他布尔运算**

- 一旦有了`if`、`False`和`True`，我们可以在Core语言中定义其他布尔运算：
```haskell
and x y = if x y False
```
**Exercise 2.20**

**任务**：在Core语言中为`or`、`xor`和`not`编写定义，并将它们添加到`extraPreludeDefs`。

### **2.7.3 实现结构化数据**

#### **实现所需的更改**

为了支持结构化数据、条件表达式和比较操作，我们需要进行以下更改：

- **扩展Node类型**：添加`NData`构造器，并在`showNode`中处理它。
```haskell
data Node = ... | NData Int [Addr]
```
- **扩展Primitive类型**：添加`PrimConstr`、`If`以及比较运算符，如`Greater`、`GreaterEq`等。
- **更新primitives列表**：在`primitives`关联列表中，添加这些新原语的名称和对应的构造器。
- **实现instantiateConstr**：在`instantiate`函数中，当遇到`EConstr`时，实例化为`NPrim`节点。
- **更新isDataNode**：使其识别`NData`节点。
- **修改step函数**：在`dispatch`部分，添加对`NData`节点的处理，调用`dataStep`函数。
- **实现dataStep**：类似于`numStep`，处理`NData`节点。
- **扩展primStep**：添加对新原语的处理。
#### **泛化primArith函数**

由于比较运算符（如`>`、`>=`等）与算术运算符类似，但返回的是布尔值，我们需要对`primArith`函数进行泛化。

- **定义primDyadic函数**：
```haskell
primDyadic :: TiState -> (Node -> Node -> Node) -> TiState
```
- **primArith和primComp**：可以分别定义`primArith`和`primComp`，用于算术和比较操作，它们都基于`primDyadic`。
```haskell
primArith state op = primDyadic state (\(NNum n1) (NNum n2) -> NNum (n1 `op` n2))

primComp state op = primDyadic state (\(NNum n1) (NNum n2) ->
    if n1 `op` n2 then NData 2 [] else NData 1 [])
```
- **在primStep中处理比较运算符**：
```haskell
primStep state Greater = primComp state (>)
primStep state GreaterEq = primComp state (>=)
-- 其他比较运算符类似
```
**Exercise 2.21**

**任务**：进行上述所有更改。现在，您可以编写有意义的递归函数，例如阶乘函数。

**测试程序**：

```haskell
fac n = if (n == 0) 1 (n * fac (n-1)) ;
main = fac 3
```

### **2.7.4 元组（Pairs）**

#### **引入元组类型**

在Miranda中，可以定义元组类型：

```haskell
pair * ** ::= MkPair * **
```

- 我们将MkPair构造器表示为Pack{1,2}，其中标签为1，元数为2。
#### **拆解元组**

由于无法使用通用的`case`表达式，我们引入`casePair`原语，用于拆解元组。

- **转换示例**：
```haskell
f p = case p of
         <1> a b -> b*a*a end
```
转换为：
```haskell
f p = casePair p f'
f' a b = b*a*a
```
- **casePair的定义**：操作规则：
```css
casePair (Pack{1,2} a b) f = f a b
```
`casePair`首先计算其第一个参数，期望得到一个元组，然后将元组的组件作为参数传递给第二个函数参数`f`。
#### **实现方法**

- **扩展Primitive类型**：添加`PrimCasePair`构造器。
- **在primStep中处理PrimCasePair**：实现相应的状态转换规则。
**实现fst和snd**

- **Core语言定义**：
```haskell
fst p = casePair p K
snd p = casePair p K1
```
**Exercise 2.22**

**任务**：为`casePair`编写状态转换规则，并进行必要的实现更改。

**测试程序**：

```haskell
main = fst (snd (fst (MkPair (MkPair 1 (MkPair 2 3)) 4)))
```

### **2.7.5 列表**

#### **引入列表类型**

在Miranda中，列表类型可以定义为：

```haskell
list * ::= Nil | Cons * (list *)
```

- 我们为Nil和Cons分别分配标签1和2。
#### **拆解列表**

由于无法使用通用的`case`表达式，我们引入`caseList`原语。

- **caseList的定义**：操作规则：
```java
caseList Pack{1,0} cn cc = cn
caseList (Pack{2,2} x xs) cn cc = cc x xs
```
`caseList`有三个参数：**第一个参数**：要拆解的列表。**第二个参数cn**：当列表为空时返回的值。**第三个参数cc**：当列表非空时，对列表的头和尾进行处理的函数。
#### **实现示例**

- **定义length函数**：
```haskell
length xs = caseList xs 0 length'
length' x xs = 1 + length xs
```
**Exercise 2.23**

**任务**：

- 编写`Cons`、`Nil`、`head`和`tail`的Core语言定义。
- 为处理空列表时的错误，您需要引入一个新的原语`abort`，当取空列表的`head`或`tail`时调用。
- `abort`可以通过调用Miranda的`error`函数来实现。
#### **实现方法**

- **扩展Primitive类型**：添加`PrimCaseList`和`Abort`构造器。
- **在primStep中处理PrimCaseList**：实现相应的状态转换规则。
**Exercise 2.24**

**任务**：

- 为`caseList`和`abort`编写状态转换规则，实现它们，并将`Cons`、`Nil`、`head`和`tail`的定义添加到`preludeDefs`。
- 编写程序测试您的实现。
### **2.7.6 打印列表**

#### **问题描述**

- 目前，我们的机器默认认为程序的结果是一个数字。
- 如果我们希望程序的结果是一个数字列表，我们需要修改机器以支持输出列表。
#### **解决方案**

- **添加新的原语**：`Print`和`Stop`。
- **修改机器状态**：添加一个新的组件`output`，用于保存输出。
- **修改tiFinal函数**：当堆栈为空时停止执行，而不是报错。
#### **状态转换规则**

**Stop原语**

- **规则（2.11）**：
```less
o a : [] [] h[a : NPrim Stop] f
⇒ o [] [] h f
```
- **解释**：当堆栈包含`Stop`原语时，将堆栈清空。
**Print原语**

- **规则（2.12）**：当第一个参数已计算时。
```less
o a : a1 : a2 : [] [] h
[ a : NPrim Print  a1 : NAp a b1  a2 : NAp a1 b2  b1 : NNum n ]
f
⇒ o ++ [n] b2 : [] [] h f
```
- **解释**：将数字`n`添加到输出列表中，然后将第二个参数`b2`作为下一步的计算。
- **规则（2.13）**：当第一个参数未计算时。
```less
o a : a1 : a2 : [] [] h
[ a : NPrim Print  a1 : NAp a b1  a2 : NAp a1 b2 ]
f
⇒ o b1 : [] (a2 : []) : [] h f
```
- **解释**：开始计算第一个参数，将当前堆栈压入`dump`。
#### **实现方法**

- **修改机器状态类型**：添加`output`组件。
- **修改compile函数**：使初始堆栈包含`printList main`的地址。
- **定义printList函数**：
```haskell
printList xs = caseList xs stop printCons
printCons h t = print h (printList t)
```
- **在preludeDefs中添加定义**：将`"print"`绑定到`Print`原语，将`"stop"`绑定到`Stop`原语。
**Exercise 2.26**

**任务**：实现上述更改，并编写程序返回数字列表，测试您的实现。

**全面详尽的总结**

本段内容详细讨论了如何在模板实例化的图归约器中添加对结构化数据类型的支持，以及如何在没有通用`case`表达式的情况下处理数据的构建和拆解。主要涵盖了以下方面：

1. **引入结构化数据类型**
- **挑战**：模板实例化机器难以直接处理`case`表达式，因为在实例化阶段无法确定匹配结果。
- **解决方案**：通过引入特殊的原语（如`PrimConstr`、`If`、`PrimCasePair`、`PrimCaseList`）和构造器（如`NData`），实现对结构化数据的支持。
2. **实现条件表达式**
- **布尔类型的表示**：将`True`和`False`定义为`Pack{2,0}`和`Pack{1,0}`。
- **条件原语if**：通过状态转换规则，实现对条件的判断和选择，支持递归函数的终止条件。
- **扩展布尔运算**：在Core语言中定义`and`、`or`、`not`等布尔运算。
3. **处理元组和列表**
- **元组（Pairs）**：使用`casePair`原语拆解元组。实现`fst`和`snd`函数。
- **列表（Lists）**：使用`caseList`原语拆解列表。实现常见的列表操作，如`length`、`head`、`tail`。处理空列表时，引入`abort`原语。
4. **输出列表**
- **添加输出支持**：修改机器状态，添加`output`组件。
- **新的原语Print和Stop**：通过状态转换规则，实现输出操作。
- **修改程序入口**：在`compile`函数中，使初始堆栈包含`printList main`的地址，实现对列表结果的输出。
**重要的概念和技巧**：

- **利用特殊原语模拟case表达式**：通过定义特定的原语和构造器，绕过了模板实例化机器无法直接处理`case`表达式的限制。
- **状态转换规则的扩展**：针对新的原语和构造器，定义相应的状态转换规则，确保机器的正确执行。
- **高阶函数的应用**：在实现条件和数据拆解时，利用高阶函数（如将函数作为参数）实现灵活的操作。
- **输出机制的设计**：通过修改机器状态和添加新的原语，实现对输出的控制和数据的打印。
**总结**

通过本段内容的学习，您了解了在模板实例化的图归约器中如何逐步添加对结构化数据类型的支持，解决了在实例化阶段无法处理`case`表达式的挑战。同时，您学会了如何定义和实现条件原语、数据构造器和拆解原语，以及如何扩展机器的状态和功能以支持输出操作。这些知识对于理解函数式语言的实现原理，特别是在资源受限或特定约束下实现关键功能，具有重要的意义。

在后续的学习中，您可以继续探索如何在更通用的机器中实现`case`表达式，以及如何进一步优化和扩展图归约器的功能。
 #  
 Thought for 55 seconds
**概览**

本段内容来自 Simon Peyton Jones 的《Implementing Functional Languages: a tutorial》第二章，主要讨论了一些可供探索的替代实现方法。这些方法旨在优化和改进我们之前构建的基于模板实例化的图归约器，以提高其性能和效率。

主要内容包括：

- **2.8 替代实现**：探讨了几种可替代的方法，包括：**2.8.1 原语的替代表示**：将原语表示为从状态到状态的函数，而不是一个需要模式匹配的枚举类型。**2.8.2 dump的替代表示**：将`dump`实现为一个包含偏移量的数字栈，而不是栈的栈。**2.8.3 数据值的替代表示**：讨论了如何将布尔值、对和列表表示为函数，从而避免引入额外的节点类型和原语。
- **2.9 垃圾收集**：介绍了垃圾收集的必要性，以及如何在我们的机器中实现垃圾收集，包括：**2.9.1 标记-扫描（Mark-scan）收集**：详细解释了如何实现标记-扫描垃圾收集器。**2.9.2 消除间接节点**：讨论了如何在垃圾收集过程中消除间接节点，以优化内存使用。**2.9.3 指针反转（Pointer Reversal）**：介绍了一种无需额外堆栈空间的垃圾收集算法，适用于极端情况下的优化。**2.9.4 双空间垃圾收集（Two-space Garbage Collection）**：讲解了一种流行的垃圾收集方法，通过在两个堆之间复制活动数据，实现高效的垃圾收集。
通过这些内容，作者旨在引导读者探索更高级的实现技术，以改进函数式语言的解释器和编译器。

**详细解析**

### **2.8 替代实现**

这一节探讨了一些我们之前实现的替代方法，旨在优化和简化代码，同时提高效率。

#### **2.8.1 原语的替代表示**

**背景**

在之前的实现中，我们将`Primitive`定义为一个枚举类型，包含诸如`Add`、`Sub`等构造器。在执行时，我们需要对`Primitive`进行模式匹配，以确定要执行的操作。

**问题**

这种方法有几个缺点：

- **代码冗余**：每次添加新的原语，都需要修改`Primitive`类型和相应的处理代码。
- **效率问题**：模式匹配可能带来一些性能开销。
**替代方法**

- **将Primitive表示为函数**：我们可以将`Primitive`类型定义为一个从`TiState`到`TiState`的函数：
```haskell
Type Primitive = TiState -> TiState
```
- **消除模式匹配**：这样，我们不再需要在`primStep`中进行模式匹配，只需直接调用函数。
- **修改primStep和primitives**：
```haskell
primStep state prim = prim state

primitives = [ ("negate", primNeg),
               ("+", primArith (+)), ("-", primArith (-)),
               ("*", primArith (*)), ("/", primArith (/)) ]
```
**解释**

- **primStep函数**：接受当前状态和一个原语函数`prim`，直接调用`prim state`，返回新的状态。
- **primitives列表**：将原语的名称映射到相应的函数实现上，而不是构造器。
**现实中的对应**

在实际的实现中，我们可以将原语节点`NPrim`存储一个代码指针（类似于函数指针），在执行时直接跳转到相应的代码，而不是通过一个标记进行模式匹配。

**Exercise 2.27**

**任务**：实现并测试上述修改。

#### **2.8.2 dump的替代表示**

**背景**

在当前的实现中，`dump`被实现为一个栈的栈（`[TiStack]`），用于在需要求值参数时保存当前的堆栈。

**问题**

- **效率问题**：在每次需要求值参数时，都需要将当前堆栈压入`dump`，然后创建一个新堆栈。这可能导致性能开销。
- **内存占用**：`dump`可能占用较多的内存。
**替代方法**

- **使用偏移量表示dump**：将`dump`实现为一个数字栈，保存堆栈中各子堆栈的结束位置的偏移量。
- **修改TiDump类型**：
```haskell
type TiDump = Stack Num
```
**实现思路**

- **直接在旧堆栈之上构建新堆栈**：不再创建新的堆栈，而是在当前堆栈之上继续添加。
- **使用偏移量标记子堆栈的边界**：在`dump`中保存当前堆栈的大小，以便在需要恢复时知道要弹出多少元素。
**需要修改的部分**

- **开始求值参数时**：将当前堆栈的大小压入`dump`。
- **结束求值参数时**：从`dump`中弹出偏移量，根据偏移量恢复堆栈。
- **修改tiFinal的定义**：需要考虑`dump`的新的表示方式。
**Exercise 2.28**

**任务**：实现并测试上述修改，需要修改处理开始和结束求值参数的方程，以及`tiFinal`的定义。

#### **2.8.3 数据值的替代表示**

**背景**

在之前的实现中，我们通过`NData`节点和`NPrim`原语来表示布尔值、对和列表。这需要引入额外的节点类型和原语处理逻辑。

**替代方法**

- **将数据值表示为函数**：可以将布尔值、对和列表表示为函数，从而避免引入额外的节点类型和原语。
- **布尔值的表示**：
```haskell
True t f = t
False t f = f
```
- **布尔操作的定义**：
```haskell
if = I  -- 恒等函数

and b1 b2 t f = b1 (b2 t f) f

or b1 b2 t f = b1 t (b2 t f)

not b t f = b f t
```
- **对的表示**：
```haskell
pair a b f = f a b

casePair = I

fst p = p K

snd p = p K1
```
- **列表的表示**：
```haskell
cons a b cn cc = cc a b

nil cn cc = cn

caseList = I
```
**解释**

- **函数表示法**：通过将数据值表示为函数，我们可以在不引入额外节点类型的情况下处理数据结构。
- **消除原语和节点类型**：不再需要`if`原语、`NData`节点或`NPrim`节点，只需要处理算术比较原语。
**优势**

- **简化实现**：减少了需要处理的节点类型和原语。
- **利用函数的特性**：函数式语言本身支持高阶函数和柯里化，可以利用这些特性来表示数据结构。
**劣势**

- **可能的性能影响**：函数表示可能导致额外的函数调用，影响性能。
**Exercise 2.29**

**任务**：以这种方式实现布尔值、对和列表，并测量它们的性能。与之前的实现相比，探讨其优缺点。

### **2.9 垃圾收集**

随着程序的执行，堆中会分配越来越多的节点。如果不加以处理，最终会耗尽内存资源。在实际的实现中，垃圾收集是必不可少的。

#### **问题描述**

- **内存耗尽**：随着节点的分配，堆的大小不断增加，可能会耗尽内存。
- **需要垃圾收集**：为了释放不再需要的节点，必须实现垃圾收集机制。
#### **目标**

- **定义gc函数**：实现一个垃圾收集器`gc`，其类型为：
```haskell
gc :: TiState -> TiState
```
- **保持程序行为不变**：`gc`的输出状态应与输入状态在行为上完全一致，只是堆的大小可能变小了。
- **释放未使用的节点**：通过检测并释放不再需要的节点，节省内存空间。
- **在适当时机调用gc**：可以在`doAdmin`函数中检查堆的大小，当超过某个阈值时，调用垃圾收集器。
#### **2.9.1 标记-扫描（Mark-scan）收集**

**原理**

标记-扫描垃圾收集器分为三个阶段：

1. **标记根节点（Find Roots）**：找到所有的根节点，即机器状态中包含的所有堆地址。
2. **标记阶段（Mark Phase）**：从根节点开始，递归地标记所有可达的节点。
3. **扫描阶段（Scan Phase）**：遍历堆中的所有节点，释放未标记的节点，并取消标记已标记的节点。
**实现步骤**

1. **标记根节点**
- **查找机器状态中的地址**：在堆栈、`dump`和全局变量中查找所有的地址。
- **定义函数**：
```haskell
findStackRoots :: TiStack -> [Addr]
findDumpRoots :: TiDump -> [Addr]
findGlobalRoots :: TiGlobals -> [Addr]
```
2. **标记阶段**
- **定义markFrom函数**：
```haskell
markFrom :: TiHeap -> Addr -> TiHeap
```
- **标记过程**：如果节点已标记，直接返回，避免循环。使用`hUpdate`将节点替换为`NMarked n`，其中`n`是原节点。提取节点中的所有地址，对每个地址递归调用`markFrom`。
3. **扫描阶段**
- **定义scanHeap函数**：
```haskell
scanHeap :: TiHeap -> TiHeap
```
- **扫描过程**：遍历堆中的所有地址。如果节点未标记（不是`NMarked`），调用`hFree`释放节点。如果节点已标记，使用`hUpdate`将其替换为原节点（取消标记）。
**节点类型的修改**

- **添加NMarked构造器**：
```haskell
data Node = ... | NMarked Node
```
- **NMarked节点包含原节点**，标记阶段使用。
**Exercise 2.30**

**任务**：根据`findRoots`、`markFrom`和`scanHeap`定义`gc`函数，并在`doAdmin`中适当地调用它。

**Exercise 2.31**

**任务**：编写`findRoots`的定义。

**Exercise 2.32**

**任务**：编写`markFrom`和`scanHeap`的定义。

#### **2.9.2 消除间接节点**

**问题**

- **间接节点的存在**：在执行过程中，我们可能会引入许多`NInd`间接节点。
- **优化目标**：希望在垃圾收集过程中消除这些间接节点，以优化内存使用。
**解决方案**

- **修改markFrom函数**：使其在标记过程中跳过间接节点，并返回替换后的地址。
- **修改markFrom的类型**：
```haskell
markFrom :: TiHeap -> Addr -> (TiHeap, Addr)
```
- **在标记过程中**：当遇到`NInd`节点时，直接跳过，返回其指向的地址。对于其他节点，递归地标记，并更新节点中的地址。
**更新机器状态**

- **修改根节点标记函数**：
```haskell
markFromStack :: TiHeap -> TiStack -> (TiHeap, TiStack)
markFromDump :: TiHeap -> TiDump -> (TiHeap, TiDump)
markFromGlobals :: TiHeap -> TiGlobals -> (TiHeap, TiGlobals)
```
- **在标记过程中**：用返回的新地址替换原始地址。
**Exercise 2.33**

**任务**：实现修改后的`markFrom`，使其在标记过程中跳过间接节点，并更新节点中的地址。然后，实现其他标记函数，并将它们与新的`gc`函数结合。比较新旧垃圾收集器的堆大小。

#### **2.9.3 指针反转（Pointer Reversal）**

**问题**

- **递归深度**：在极端情况下（例如堆中所有节点形成一个长链表），`markFrom`可能会递归调用自身`N`次，导致堆栈溢出。
- **优化目标**：消除递归调用，避免在极端情况下的堆栈溢出。
**解决方案**

- **指针反转算法**：通过在标记过程中反转指针，利用节点本身保存状态，避免递归调用。
**实现细节**

- **扩展Node类型**：
```haskell
data Node = ... | NMarked MarkState Node

data MarkState = Done | Visits Int
```
**Done**：表示该节点的标记已完成。**Visits Int**：表示该节点已被访问的次数。
- **状态转换系统****状态**：`(f, b, h)`，其中`f`是前向指针，`b`是后向指针，`h`是堆。**初始状态**：`(a, hNull, hinit)`，`a`是要标记的节点地址。**终止条件**：当`f`指向已标记节点，且`b = hNull`时，标记完成。
- **标记规则****处理未标记的NAp节点**：
```css
f b h[f : NAp a1 a2] ⇒ a1 f h[f : NMarked (Visits 1) (NAp b a2)]
```
记录后向指针`b`到节点中。前向指针`f`更新为第一个子节点`a1`。**处理已标记节点**：如果`b = hNull`，标记完成。如果节点已访问一次，继续标记第二个子节点。
```css
f b h[f : NMarked Done n, b : NMarked (Visits 1) (NAp b' a2)] ⇒ a2 b h[b : NMarked (Visits 2) (NAp f b')]
```
如果节点已访问两次，标记完成，回溯。
```css
f b h[f : NMarked Done n, b : NMarked (Visits 2) (NAp a1 b')] ⇒ b b' h[b : NMarked Done (NAp a1 f)]
```
**处理NInd节点**：
```css
f b h[f : NInd a] ⇒ a b h
```
跳过间接节点。
**Exercise 2.34**

**任务**：为`NData`节点添加规则。

**Exercise 2.35**

**任务**：实现该算法。主要需要修改`Node`类型和`markFrom`函数。由于`NMarked`构造器的格式已更改，`scan`函数需要做一些小的修改。

#### **2.9.4 双空间垃圾收集（Two-space Garbage Collection）**

**背景**

- **基本思想**：将所有活动数据从一个堆复制到另一个堆，实现垃圾收集。
- **优点**：避免了标记阶段，复制过程中自然地消除了未使用的数据。
**实现步骤**

1. **转移节点（Evacuation）**
- **定义evacuateStack函数**：
```haskell
evacuateStack :: TiHeap -> TiHeap -> TiStack -> (TiHeap, TiStack)
```
- **过程**：从机器状态（堆栈、`dump`、全局变量）中获取所有的根节点。将这些节点从旧堆（`from-space`）复制到新堆（`to-space`）。在旧堆中的节点位置，写入一个转发指针（`NForward`），指向新堆中的节点。返回更新后的新堆和机器状态。
2. **扫描新堆（Scavenge）**
- **定义scavengeHeap函数**：
```haskell
scavengeHeap :: TiHeap -> TiHeap -> TiHeap
```
- **过程**：从新堆的起始位置开始，线性扫描所有节点。对每个节点，复制其引用的节点（如果尚未复制），并更新其引用地址。扫描直到扫描指针赶上分配指针（即新堆的末尾）。
**节点类型的修改**

- **添加NForward构造器**：
```haskell
data Node = ... | NForward Addr
```
用于在旧堆中存储转发指针，指向新堆中的节点。
**Exercise 2.36**

**任务**：实现这个垃圾收集器。

**全面详尽的总结**

本段内容深入探讨了几种替代的实现方法和垃圾收集技术，旨在优化和改进我们之前构建的基于模板实例化的图归约器。

**主要内容回顾：**

1. **替代实现方法**
- **原语的函数表示**：将原语表示为从状态到状态的函数，消除了对`Primitive`类型的模式匹配，提高了代码的简洁性和效率。
- **dump的偏移量表示**：将`dump`实现为数字栈，保存堆栈的偏移量，优化了内存使用和性能。
- **数据值的函数表示**：将布尔值、对和列表表示为函数，避免了引入额外的节点类型和原语处理逻辑，充分利用了函数式编程的特性。
2. **垃圾收集**
- **标记-扫描垃圾收集器**：通过标记所有可达节点并释放未标记的节点，实现了基本的垃圾收集功能。
- **消除间接节点的优化**：在垃圾收集过程中跳过间接节点，直接更新引用，优化了内存使用。
- **指针反转算法**：通过在标记过程中反转指针，消除了递归调用，避免了堆栈溢出，适用于极端情况下的优化。
- **双空间垃圾收集器**：通过将活动数据从一个堆复制到另一个堆，实现了高效的垃圾收集，避免了标记阶段。
**重要的概念和技巧：**

- **函数式编程的灵活性**：利用函数表示数据结构，充分发挥了函数式语言的高阶函数和柯里化特性。
- **垃圾收集的必要性**：理解垃圾收集在内存管理中的重要作用，以及不同垃圾收集算法的优缺点。
- **优化技术的应用**：通过替代实现和优化算法，提高了解释器的性能和效率。
- **数据结构的灵活表示**：在实现中，可以根据需要选择最合适的数据结构表示方法，权衡简洁性和性能。
**总结**

通过本段内容的学习，我们深入理解了在函数式语言的实现中，如何灵活地选择和优化各种实现方法，以及垃圾收集在内存管理中的关键作用。我们学会了利用函数式编程的特性，简化代码，提高效率。同时，我们还了解了不同的垃圾收集算法，掌握了在实际实现中优化内存管理的技巧。

这些知识为我们进一步探索函数式语言的实现和优化奠定了坚实的基础。在后续的学习中，我们可以继续研究更高级的实现技术，如编译器优化、并行化处理等，以构建更高效、更强大的函数式语言工具。
 #  
 Thought for 39 seconds
**概览**

本段内容来自 Simon Peyton Jones 的《Implementing Functional Languages: A Tutorial》一书的第三章，主要介绍了 G 机器（G-machine），这是第一个基于编译的函数式语言实现模型。G 机器由 Augustsson 和 Johnsson 在瑞典哥德堡的查尔姆斯理工大学开发。

本章的主要内容包括：

- **3.1 引言**：介绍了 G 机器的基本思想，以及它如何通过编译超级组合子（supercombinator）的主体为指令序列来提高执行效率。
- **3.1.1 一个示例**：通过一个具体的函数示例，展示了 G 机器编译器的工作原理，以及生成的指令如何执行。
- **3.1.2 进一步的优化**：讨论了编译还可以带来的其他优化，这些优化是模板实例化机器无法实现的。
- **3.2 构建模板的代码序列**：深入探讨了如何为表达式生成线性的指令序列，以及如何使用后缀表示法（postfix notation）来实现这一点。
- **3.2.1 算术表达式的后缀求值**：通过一个算术表达式的例子，展示了如何将表达式编译为后缀指令序列，并解释了其求值过程。
- **3.2.2 使用后缀代码构建图**：将上述思想应用到超级组合子的实例化上，讨论了如何使用后缀指令序列来构建表达式的实例。
- **3.2.3 实例化完成后的处理**：讨论了在实例化超级组合子主体后，需要对堆栈和求值过程进行的清理和安排。
通过这些内容，作者旨在阐明 G 机器的工作原理，以及它如何通过编译和优化来提高函数式语言的执行效率。

**详细解析**

### **3.1 引言**

#### **背景**

在之前的模板实例化机器中，主要操作是构造超级组合子主体的实例，这通过 `instantiate` 函数来实现。然而，这种方法效率较低，因为每次实例化都需要递归地遍历模板。

在执行 `instantiate` 时，实际上执行了两类指令：

1. **遍历模板的指令**：用于递归地遍历超级组合子的主体结构。
2. **实际构建实例的指令**：用于在堆中构建表达式的实例。
#### **G 机器的核心思想**

G 机器的核心思想是：

**在运行程序之前，将每个超级组合子的主体翻译为一系列指令，当执行这些指令时，将构造超级组合子主体的一个实例。**

这种方法的优点是：

- **提高执行速度**：因为所有的指令都专注于构建实例，而不需要在运行时遍历模板。
- **消除解释开销**：编译阶段已经完成了模板的遍历和分析，因此运行时不再需要执行这些操作。
- **抛弃原始的超级组合子**：因为我们只需要实例化超级组合子，所以在翻译完成后，可以舍弃原始的超级组合子，只保留编译后的代码。
#### **抽象机器的作用**

- **可移植性**：为了在不同的硬件平台上实现语言，实现一个抽象机器是有用的。
- **抽象机器的两个属性**：**易于翻译为具体的机器代码**：例如，可以轻松地翻译为 68000 汇编代码。**易于从源代码生成抽象机器代码**：编译器可以容易地将源代码转换为抽象机器的指令。
- **权衡**：如果抽象机器与真实机器相同，那么生成具体代码容易，但从源代码生成抽象机器代码会变得困难。因此，抽象机器是源语言和特定机器代码之间的桥梁。
### **3.1.1 一个示例**

#### **函数示例**

考虑以下函数：

```haskell
f g x = K (g x)
```

我们希望将这个函数编译为 G 机器的指令序列。

#### **编译结果**

编译后的 G 代码指令序列为：

```mathematica
Push 1
Push 1
Mkap
Pushglobal K
Mkap
Slide 3
Unwind
```

#### **指令含义**

- **Push n**：将堆栈中相对于栈顶第 n 个元素的地址压入堆栈。
- **Mkap**：从堆栈中弹出两个地址，构造一个应用节点（application node），将新节点的地址压入堆栈。
- **Pushglobal f**：将全局函数 `f` 的地址压入堆栈。
- **Slide n**：保留堆栈顶的元素，将其下方的 n 个元素从堆栈中移除。
- **Unwind**：展开堆栈顶的表达式，寻找下一个需要实例化的超级组合子。
#### **执行过程详解**

我们通过图解（Figure 3.1）来展示这些指令的执行过程。由于我们没有图，我们通过文字描述每个步骤。

1. **初始状态（图 (a)）**：
- 堆栈包含函数调用的应用节点，表示 `f g x`。
- 堆栈顶是超级组合子 `f` 的地址，其下方是应用节点的地址，包含参数 `g` 和 `x`。
2. **执行 Push 1（图 (b)）**：
- 忽略栈顶的超级组合子 `f`，堆栈中第一个元素编号为 0，第二个为 1。
- `Push 1` 将堆栈中第 1 个元素的地址（即 `x` 的地址）压入堆栈。
3. **再次执行 Push 1（图 (c)）**：
- 由于堆栈中又新增了一个元素，原来的第 1 个元素现在是第 2 个。
- 再次执行 `Push 1`，将堆栈中第 1 个元素的地址（即 `g` 的地址）压入堆栈。
4. **执行 Mkap（图 (d)）**：
- 从堆栈中弹出两个地址（`g` 和 `x` 的地址），在堆中创建一个应用节点 `g x`。
- 将新创建的应用节点的地址压入堆栈。
5. **执行 Pushglobal K（图 (e)）**：
- 将全局函数 K 的地址压入堆栈。
6. **再次执行 Mkap（图 (f)）**：
- 从堆栈中弹出两个地址（`K` 和 `g x` 的地址），在堆中创建一个应用节点 `K (g x)`。
- 将新创建的应用节点的地址压入堆栈。
7. **执行 Slide 3（图 (g)）**：
- 保留堆栈顶的元素（即新创建的 K (g x) 的地址），将其下方的 3 个元素（原来的 f、g、x 的地址）从堆栈中移除。
8. **执行 Unwind**：
- 开始对堆栈顶的表达式进行展开和求值。
#### **总结**

通过以上步骤，我们成功地实例化了函数 `f` 的主体，并清理了堆栈，为下一步的求值做好了准备。

### **3.1.2 进一步的优化**

#### **消除解释开销**

通过将超级组合子的主体编译为指令序列，我们消除了运行时遍历模板的解释开销，提高了执行速度。

#### **编译带来的其他优化**

编译还可以实现一些模板实例化机器无法实现的优化，例如：

- **避免重复计算**：在编译时，可以分析哪些变量已经求值，避免在运行时重复求值。
- **示例**：
```haskell
f x = x + x
```
在模板实例化机器中，`x` 会被求值两次。在编译实现中，可以在编译时确定 `x` 已经被求值，第二次使用时无需再次求值。
### **3.2 构建模板的代码序列**

#### **模板实例化机器的操作**

回顾模板实例化机器的操作：

- **终止条件**：当堆栈顶的唯一元素是一个整数的指针时，机器停止。
- **展开和实例化**：如果不是上述情况，我们展开应用节点，直到遇到超级组合子节点，然后实例化其主体，用实际参数替换形式参数。
#### **实例化超级组合子的过程**

在 Mark 1 模板机器中，`scStep` 和 `instantiate` 函数的作用可以描述为：

1. **构建局部环境**：创建一个从变量名到堆中地址的映射。
2. **实例化主体**：使用局部环境，在堆中创建超级组合子主体的实例。对于变量，不复制其值，而是使用对应的地址。
3. **清理堆栈**：从堆栈中移除应用节点和超级组合子节点的指针。
4. **更新堆栈**：将新创建的实例的地址压入堆栈。
#### **递归遍历模板的开销**

- **问题**：在实例化过程中，需要递归地遍历超级组合子的主体，构建表达式树。这是一个开销较大的操作。
- **目标**：希望能够为表达式生成一个线性的指令序列，以避免运行时的递归遍历。
### **3.2.1 算术表达式的后缀求值**

#### **引入**

为了实现上述目标，我们可以借鉴算术表达式的后缀求值方法。后缀表示法（也称为逆波兰表示法）是一种线性化表达式树的方法，使得表达式可以用一个平坦的指令序列来表示和求值。

#### **算术表达式的定义**

我们定义一个简单的算术表达式语言，包括数字、加法和乘法：

```haskell
data AExpr = Num Int
           | Plus AExpr AExpr
           | Mult AExpr AExpr
```

#### **解释函数**

定义一个解释函数 `aInterpret`，用于对算术表达式求值：

```haskell
aInterpret :: AExpr -> Int
aInterpret (Num n) = n
aInterpret (Plus e1 e2) = aInterpret e1 + aInterpret e2
aInterpret (Mult e1 e2) = aInterpret e1 * aInterpret e2
```

#### **编译为后缀指令序列**

我们可以将算术表达式编译为后缀指令序列：

- 定义指令类型：
```haskell
data AInstruction = INum Int
                  | IPlus
                  | IMult
```
- 编译函数 `aCompile`：
```haskell
aCompile :: AExpr -> [AInstruction]
aCompile (Num n) = [INum n]
aCompile (Plus e1 e2) = aCompile e1 ++ aCompile e2 ++ [IPlus]
aCompile (Mult e1 e2) = aCompile e1 ++ aCompile e2 ++ [IMult]
```
- 示例：表达式 `2 + 3 * 4` 编译为：
```haskell
[INum 2, INum 3, INum 4, IMult, IPlus]
```
#### **求值函数**

定义求值函数 `aEval`，用于执行指令序列：

```haskell
aEval :: ([AInstruction], [Int]) -> Int
aEval ([], [n]) = n
aEval (INum n : is, s) = aEval (is, n : s)
aEval (IPlus : is, n0 : n1 : s) = aEval (is, n1 + n0 : s)
aEval (IMult : is, n0 : n1 : s) = aEval (is, n1 * n0 : s)
```

#### **解释**

- **状态**：求值器的状态是一个指令序列和一个数字栈。
- **指令执行规则**：**INum n**：将数字 `n` 压入栈。**IPlus**：从栈中弹出两个数字，计算其和，结果压入栈。**IMult**：从栈中弹出两个数字，计算其积，结果压入栈。
- **结束条件**：当指令序列为空，且栈中只有一个数字时，求值完成，返回该数字。
#### **证明**

**练习 3.1**

证明对于所有的算术表达式 `e`，都有：

```haskell
aInterpret e = aEval (aCompile e, [])
```

**方法**：

- 使用结构归纳法（structural induction），对 e 的结构进行归纳，分别证明对于 Num、Plus、Mult 构造器，结论成立。
#### **扩展**

**练习 3.2**

- **任务**：扩展 `aInterpret`、`aCompile` 和 `aEval`，使其支持 `let` 表达式，并证明扩展后的函数仍满足：
```haskell
aInterpret e = aEval (aCompile e, [])
```
- **挑战**：进一步扩展到支持 `letrec` 等更复杂的表达式，并证明正确性。
### **3.2.2 使用后缀代码构建图**

#### **应用到超级组合子的实例化**

我们可以将上述后缀表示法的思想应用到超级组合子的实例化上：

- **堆栈中的值**：在这个情况下，堆栈上的“值”将是被实例化的表达式各部分的地址。
- **指令的作用**：与算术表达式的情况不同，这里的指令通常会在堆中分配节点，具有副作用。
#### **示例：Mkap 指令**

- **定义**：`Mkap` 指令从堆栈中弹出两个地址，创建一个应用节点（`NAp`），将新节点的地址压入堆栈。
- **作用**：构建表达式的应用结构，例如，将函数和参数组合在一起。
#### **使用现有的堆栈**

- **无需新建堆栈**：我们可以使用模板实例化机器已有的堆栈来存储地址。
- **注意事项**：**堆栈偏移的变化**：随着我们在堆栈上推入和弹出元素，变量名对应的堆栈位置会发生变化。**编译时跟踪**：在编译表达式时，需要跟踪堆栈的位置变化，以正确地生成访问变量的指令。
- **相对地址访问**：我们对堆栈中元素的访问是相对于堆栈顶的偏移量。当堆栈发生变化时，这些偏移量也需要相应调整。
### **3.2.3 实例化完成后的处理**

#### **堆栈的状态**

在完成对超级组合子主体的实例化后，堆栈的状态如下（假设有 `n` 个参数）：

- **堆栈顶**：新实例化的表达式（主体 `e`）在堆中的地址。
- **下方的 n+1 个元素**：包括了用于实例化的参数和原始的超级组合子节点的地址。
- **最底部的元素**：指向刚刚实例化的表达式的根节点（即原始的超级组合子应用节点）。
#### **堆栈清理**

- **使用 Slide 指令**：我们需要将堆栈顶的实例化结果保留，将其下方的 n 个参数地址从堆栈中移除。这可以通过执行 `Slide n+1` 实现。
- **继续展开求值**：清理完堆栈后，我们需要继续对新的表达式进行求值。这可以通过执行 `Unwind` 指令实现。
#### **完整的指令序列**

对于一个函数定义：

```haskell
f x1 x2 ... xn = e
```

对应的 G 机器指令序列为：

```php
<构造 e 实例的指令序列>
Slide n+1
Unwind
```

- **解释**：**构造实例的指令序列**：使用编译器将表达式 `e` 编译为一系列指令，用于在堆中构建 `e` 的实例。**Slide n+1**：清理堆栈，保留新实例化的表达式的地址。**Unwind**：展开新实例化的表达式，继续求值过程。
**全面详尽的总结**

本段内容深入介绍了 G 机器的基本原理和实现方法，以及如何通过编译超级组合子的主体为指令序列来提高函数式语言的执行效率。

**主要内容回顾：**

1. **G 机器的引入**
- **背景**：模板实例化机器在实例化超级组合子时效率较低，需要递归地遍历模板。
- **G 机器的核心思想**：在编译阶段，将超级组合子的主体翻译为指令序列，运行时直接执行这些指令构建实例，消除了运行时的模板遍历开销。
- **抽象机器的作用**：提供了一个可移植的中间层，方便从源代码生成指令序列，并且易于翻译为具体的机器代码。
2. **示例分析**
- **函数示例**：`f g x = K (g x)`。
- **指令序列**：通过具体的指令（如 `Push`、`Mkap`、`Slide`、`Unwind`）展示了 G 机器的执行过程。
- **执行过程**：详细解释了每个指令的作用，以及堆栈和堆的状态变化。
3. **编译带来的优化**
- **消除解释开销**：通过预先编译，避免了运行时的模板遍历。
- **其他优化**：编译器可以在编译时进行分析，避免运行时的重复计算和不必要的求值。
4. **构建模板的代码序列**
- **模板实例化的过程**：回顾了模板实例化机器如何实例化超级组合子。
- **问题**：实例化过程需要递归地遍历表达式树，效率低下。
- **解决方案**：希望生成线性的指令序列，以避免运行时的递归遍历。
5. **算术表达式的后缀求值**
- **后缀表示法**：通过将表达式编译为后缀指令序列，实现了表达式的线性化表示。
- **编译和求值函数**：展示了如何编写编译函数和求值函数，以及它们之间的关系。
- **证明**：通过练习，鼓励读者证明编译和求值的正确性。
6. **使用后缀代码构建图**
- **应用到超级组合子实例化**：将后缀表示法的思想应用到构建表达式实例上。
- **注意事项**：需要跟踪堆栈的变化，确保变量引用正确。
7. **实例化完成后的处理**
- **堆栈清理**：使用 `Slide` 指令清理堆栈，保留实例化结果。
- **继续求值**：使用 `Unwind` 指令展开新实例化的表达式，继续求值过程。
**重要的概念和技巧：**

- **编译与解释的区别**：通过编译，将运行时的解释和遍历开销转移到编译时，提高了运行效率。
- **抽象机器**：提供了一个中间层，既易于从源代码生成指令，又易于翻译为具体的机器代码。
- **后缀表示法**：将表达式树线性化，使得复杂的表达式可以用线性的指令序列表示和执行。
- **堆栈管理**：在编译时跟踪堆栈的变化，确保变量引用正确，避免运行时错误。
- **优化**：编译器可以在编译时进行分析和优化，避免重复计算，提高程序性能。
**总结**

通过本章的学习，您深入了解了 G 机器的基本原理和实现方法。G 机器通过将超级组合子的主体编译为指令序列，消除了模板实例化机器的运行时开销，提高了函数式语言的执行效率。您还学习了如何使用后缀表示法来线性化表达式，以及如何在编译时跟踪堆栈的变化，确保程序的正确性和高效性。

这些知识对于理解函数式语言的实现原理，以及编译器和解释器的设计至关重要。在后续的学习中，您可以进一步探索 G 机器的改进版本，以及其他基于编译的实现技术，如 C 机器、STG 机器等，深入理解函数式语言的高效实现方法。
 #  
 Thought for 48 seconds
**概览**

您提供的内容来自 Simon Peyton Jones 的《Implementing Functional Languages: a tutorial》第三章，主要介绍了一个最小的 G 机器实现（Mark 1）。G 机器是基于编译的函数式语言实现模型，通过将程序编译为一系列指令来执行，而不是像模板实例化机器那样在运行时构建表达式的实例。

本段内容包括：

- **3.3 Mark 1: 一个最小的 G 机器**：介绍了一个基本的 G 机器及其编译器的完整代码实现，但不包括更新（将在 3.4 节引入）或算术运算（将在 3.6 节引入）。
- **3.3.1 整体结构**：展示了 G 机器的顶层结构，与模板实例化器类似，使用 `run` 函数来运行整个系统。
- **3.3.2 数据类型定义**：详细说明了 G 机器的状态、堆、堆栈、指令集等数据类型，以及它们的定义和访问方法。
- **3.3.3 评估器（Evaluator）**：描述了 G 机器的评估器 `eval` 函数，如何执行指令，以及每个指令的具体实现，包括状态转换规则和对应的函数。
通过阅读这段内容，您将了解 G 机器的基本实现，包括其状态表示、指令集和指令执行方式，以及如何通过状态转换规则来描述程序的执行。

**详细解析**

### **3.3 Mark 1: 一个最小的 G 机器**

这一节介绍了一个基本的 G 机器实现及其编译器的完整代码。这个版本的 G 机器（Mark 1）不支持更新操作（将在 3.4 节引入）或算术运算（将在 3.6 节引入），因此是一个简化的版本，旨在帮助读者理解 G 机器的核心概念。

### **3.3.1 整体结构**

#### **顶层结构**

G 机器的顶层结构与模板实例化器非常相似，整个系统通过一个 `run` 函数来连接在一起。`runProg` 函数定义如下：

```haskell
runProg :: [Char] -> [Char]
runProg = showResults . eval . compile . parse
```

- **parse**：将输入的字符串解析为抽象语法树（AST）。
- **compile**：将 AST 编译为 G 机器的指令序列。
- **eval**：评估器，执行指令序列，产生一系列状态。
- **showResults**：格式化输出结果，显示程序的执行过程和最终结果。
#### **包含的模块**

为了能够访问解析器的数据结构和函数，包含了 `language.lhs` 模块：

```haskell
-- :a language.lhs -- parser data types
```

### **3.3.2 数据类型定义**

在函数式语言的实现中，图（graph）是图归约技术的核心。G 机器使用了堆（heap）数据类型，以及其他在附录 A 中提供的实用工具。

```haskell
-- :a util.lhs -- heap data type and other library functions
```

#### **G 机器的状态表示**

G 机器的状态（`GmState`）是一个五元组，包含了执行已编译程序所需的所有信息：

```haskell
type GmState
 = (GmCode,    -- 当前的指令序列
    GmStack,   -- 当前的堆栈
    GmHeap,    -- 节点的堆
    GmGlobals, -- 堆中全局变量的地址
    GmStats)   -- 统计信息
```

- **GmCode**：指令序列，即当前要执行的指令列表。
- **GmStack**：堆栈，存储堆中节点的地址。
- **GmHeap**：堆，存储节点（表达式）的图结构。
- **GmGlobals**：全局变量的关联列表，将全局名称映射到堆中的地址。
- **GmStats**：统计信息，例如执行的步骤数。
为了方便访问状态的各个组成部分，并且在将来添加新组件时能够重用代码，我们定义了一系列的状态访问函数。这些函数以 `get` 和 `put` 为前缀，分别用于获取和设置状态的组成部分。

#### **指令序列（GmCode）**

- **类型定义**：
```haskell
type GmCode = [Instruction]
```
指令序列是指令的列表。
- **访问函数**：
```haskell
getCode :: GmState -> GmCode
getCode (i, stack, heap, globals, stats) = i

putCode :: GmCode -> GmState -> GmState
putCode i' (i, stack, heap, globals, stats)
  = (i', stack, heap, globals, stats)
```
#### **指令集（Instruction）**

初始的 G 机器指令集包含以下六条指令：

```haskell
data Instruction
  = Unwind
  | Pushglobal Name
  | Pushint Int
  | Push Int
  | Mkap
  | Slide Int
```

- **Unwind**：展开堆栈，查找需要实例化的超级组合子。
- **Pushglobal Name**：将全局名称对应的地址压入堆栈。
- **Pushint Int**：将整数节点的地址压入堆栈。
- **Push Int**：将堆栈中相对于栈顶的第 n 个元素对应的地址压入堆栈。
- **Mkap**：创建一个应用节点，将函数和参数组合起来。
- **Slide Int**：清理堆栈，保留堆栈顶的元素，移除其下方的 n 个元素。
为了能够比较指令，我们实现了 `Eq` 类型类的实例：

```haskell
instance Eq Instruction where
  Unwind == Unwind = True
  Pushglobal a == Pushglobal b = a == b
  Pushint a == Pushint b = a == b
  Push a == Push b = a == b
  Mkap == Mkap = True
  Slide a == Slide b = a == b
  _ == _ = False
```

#### **堆栈（GmStack）**

- **类型定义**：
```haskell
type GmStack = [Addr]
```
堆栈是堆中地址的列表。
- **访问函数**：
```haskell
getStack :: GmState -> GmStack
getStack (i, stack, heap, globals, stats) = stack

putStack :: GmStack -> GmState -> GmState
putStack stack' (i, stack, heap, globals, stats)
  = (i, stack', heap, globals, stats)
```
#### **堆（GmHeap）**

- **类型定义**：
```haskell
type GmHeap = Heap Node
```
堆是存储节点的堆数据结构，`Heap` 类型在 `util.lhs` 中定义。
- **访问函数**：
```haskell
getHeap :: GmState -> GmHeap
getHeap (i, stack, heap, globals, stats) = heap

putHeap :: GmHeap -> GmState -> GmState
putHeap heap' (i, stack, heap, globals, stats)
  = (i, stack, heap', globals, stats)
```
- **节点类型（Node）**：在最小的 G 机器中，有三种类型的节点：
```haskell
data Node
  = NNum Int          -- 数字节点
  | NAp Addr Addr     -- 应用节点
  | NGlobal Int GmCode  -- 全局节点
```
**NNum Int**：表示整数值。**NAp Addr Addr**：应用节点，表示函数应用，第一个地址是函数，第二个地址是参数。**NGlobal Int GmCode**：全局节点，包含全局函数的元数（需要的参数数量）和对应的指令序列。注意，全局节点替代了模板实例化器中的 `NSupercomb` 节点，后者包含了模板，而全局节点包含了元数和代码。
#### **全局变量（GmGlobals）**

- **类型定义**：
```haskell
type GmGlobals = ASSOC Name Addr
```
全局变量是一个关联列表，将名称映射到堆中的地址。
- **访问函数**：
```haskell
getGlobals :: GmState -> GmGlobals
getGlobals (i, stack, heap, globals, stats) = globals
```
在 Mark 1 G 机器中，全局变量在程序执行过程中是常量，因此不需要 `putGlobals` 函数。
#### **统计信息（GmStats）**

- **抽象数据类型**：
```haskell
statInitial :: GmStats
statIncSteps :: GmStats -> GmStats
statGetSteps :: GmStats -> Int
```
- **实现**：
```haskell
type GmStats = Int

statInitial = 0
statIncSteps s = s + 1
statGetSteps s = s
```
统计信息用一个整数表示，记录了执行的步骤数。
- **访问函数**：
```haskell
getStats :: GmState -> GmStats
getStats (i, stack, heap, globals, stats) = stats

putStats stats' (i, stack, heap, globals, stats)
  = (i, stack, heap, globals, stats')
```
### **3.3.3 评估器（Evaluator）**

G 机器的评估器 `eval` 函数定义为生成一个状态列表。第一个状态是编译器构建的初始状态。如果有一个最终状态，那么评估结果将位于最后一个状态的堆栈顶。

#### **eval 函数**

```haskell
eval :: GmState -> [GmState]
eval state = state : restStates
  where
    restStates | gmFinal state = []
               | otherwise = eval nextState
    nextState = doAdmin (step state)
```

- **解释**：**state**：当前状态。**restStates**：剩余的状态列表，如果当前状态是最终状态，则为空列表；否则，递归地调用 eval，计算下一个状态。**nextState**：通过 step 函数计算下一个状态，并通过 doAdmin 更新统计信息。
#### **doAdmin 函数**

```haskell
doAdmin :: GmState -> GmState
doAdmin s = putStats (statIncSteps (getStats s)) s
```

- **作用**：使用 statIncSteps 函数增加步骤计数，将更新后的统计信息放入状态中。
#### **重要的函数**

评估器的关键部分是 `gmFinal` 和 `step` 函数。

##### **判断是否为最终状态：gmFinal**

```haskell
gmFinal :: GmState -> Bool
gmFinal s = case (getCode s) of
               [] -> True
               otherwise -> False
```

- **解释**：当指令序列为空时，评估器停止执行，当前状态为最终状态。
##### **执行一步：step**

```haskell
step :: GmState -> GmState
step state = dispatch i (putCode is state)
  where (i:is) = getCode state
```

- **解释**：**(i:is)**：将当前指令序列分解为当前指令 i 和剩余指令 is。**putCode is state**：更新状态的指令序列为 is，相当于在实际机器中推进程序计数器。**dispatch i**：根据当前指令 i，选择相应的状态转换函数。
##### **指令分派：dispatch**

```haskell
dispatch :: Instruction -> GmState -> GmState
dispatch (Pushglobal f) = pushglobal f
dispatch (Pushint n)    = pushint n
dispatch Mkap           = mkap
dispatch (Push n)       = push n
dispatch (Slide n)      = slide n
dispatch Unwind         = unwind
```

- **解释**：根据指令类型，调用对应的处理函数。
#### **指令的状态转换规则和实现**

接下来，我们详细解释每个指令的状态转换规则和对应的实现函数。

##### **Pushglobal 指令**

- **状态转换规则（3.5）**：
```less
Pushglobal f : i   s   h   m   [f : a]
=> i              a : s h   m
```
**解释**：在指令序列 i 前面有一个 Pushglobal f，它将全局名称 f 对应的地址 a 压入堆栈。
- **实现函数**：
```haskell
pushglobal :: Name -> GmState -> GmState
pushglobal f state
  = putStack (a : getStack state) state
    where a = aLookup (getGlobals state) f (error ("Undeclared global " ++ f))
```
**aLookup**：从全局变量列表中查找名称 f，如果找不到则抛出错误。**将地址 a 压入堆栈**。
##### **Pushint 指令**

- **状态转换规则（3.6）**：
```less
Pushint n : i   s   h   m
=> i           a : s h[a : NNum n] m
```
**解释**：将整数 n 放入堆中，地址为 a，然后将地址 a 压入堆栈。
- **实现函数**：
```haskell
pushint :: Int -> GmState -> GmState
pushint n state
  = putHeap heap' (putStack (a : getStack state) state)
    where (heap', a) = hAlloc (getHeap state) (NNum n)
```
**hAlloc**：在堆中分配一个新的节点 NNum n，返回新的堆和新节点的地址。
##### **Mkap 指令**

- **状态转换规则（3.7）**：
```ruby
Mkap : i   a1 : a2 : s h   m
=> i       a  : s h[a : NAp a1 a2] m
```
**解释**：从堆栈中弹出两个地址 a1 和 a2，在堆中创建一个应用节点 NAp a1 a2，地址为 a，然后将地址 a 压入堆栈。
- **实现函数**：
```haskell
mkap :: GmState -> GmState
mkap state
  = putHeap heap' (putStack (a : as') state)
    where (heap', a) = hAlloc (getHeap state) (NAp a1 a2)
          (a1 : a2 : as') = getStack state
```
**(a1 : a2 : as')**：从堆栈中获取两个地址 a1 和 a2，as' 是剩余的堆栈。
##### **Push 指令**

- **状态转换规则（3.8）**：
```less
Push n : i   a0 : ... : an+1 : s h [an+1 : NAp an a_n] m
=> i         a_n : a0 : ... : an+1 : s h m
```
**解释**：从堆栈中第 n+1 个元素（相对于堆栈顶）获取地址 an+1，通过查找对应的应用节点 NAp an a_n，获取参数 a_n，将其压入堆栈。
- **实现函数**：
```haskell
push :: Int -> GmState -> GmState
push n state
  = putStack (a : as) state
    where as = getStack state
          a = getArg (hLookup (getHeap state) (as !! (n + 1)))
```
**as !! (n + 1)**：获取堆栈中第 n+1 个元素的地址。**hLookup**：在堆中查找该地址对应的节点。**getArg**：获取应用节点的参数。
- **辅助函数**：
```haskell
getArg :: Node -> Addr
getArg (NAp a1 a2) = a2
```
##### **Slide 指令**

- **状态转换规则（3.9）**：
```less
Slide n : i   a0 : ... : an : s h m
=> i          a0 : s h m
```
**解释**：清理堆栈，保留堆栈顶的元素 a0，移除其下方的 n 个元素。
- **实现函数**：
```haskell
slide :: Int -> GmState -> GmState
slide n state
  = putStack (a : drop n as) state
    where (a : as) = getStack state
```
**drop n as**：从堆栈中移除前 n 个元素。
##### **Unwind 指令**

`Unwind` 指令是最复杂的指令，因为它替代了模板实例化器的外部循环。`Unwind` 指令通常是指令序列的最后一条。

- **实现函数**：
```haskell
unwind :: GmState -> GmState
unwind state
  = newState (hLookup heap a)
    where
      (a : as) = getStack state
      heap = getHeap state
```
**newState**：根据堆栈顶的节点类型，决定下一个状态。
- **状态转换规则****当堆栈顶为数字节点时（3.10）**：
```less
[Unwind] a : s h [a : NNum n] m
=> [] a : s h m
```
**解释**：当堆栈顶是数字节点时，评估器完成计算，将指令序列置为空。**实现**：
```haskell
newState (NNum n) = state
```
**state**：保持状态不变，因为 gmFinal 函数会检测到指令序列为空，停止评估。**当堆栈顶为应用节点时（3.11）**：
```less
[Unwind] a : s h [a : NAp a1 a2] m
=> [Unwind] a1 : a : s h m
```
**解释**：当堆栈顶是应用节点时，继续展开，取函数部分的地址 `a1`，将其压入堆栈。**实现**：
```haskell
newState (NAp a1 a2) = putCode [Unwind] (putStack (a1 : a : as) state)
```
**putCode [Unwind]**：将指令序列设置为 [Unwind]，继续展开。**putStack (a1 : a : as)**：将 a1（函数部分的地址）和原来的地址 a 压入堆栈。**当堆栈顶为全局节点时**：**情况一**：如果没有足够的参数来减少超级组合子的应用（即参数数量不足），则程序有错误（类型错误）。在 Mark 1 G 机器中，我们忽略这种情况。**情况二**：当有足够的参数时，可以通过跳转到超级组合子的代码来减少超级组合子的应用。这个过程在状态转换规则中表示为将超级组合子的代码移动到机器的代码组件中。**由于您的内容在这里结束，具体的状态转换规则和实现函数未给出**。
**全面详尽的总结**

本段内容详细介绍了一个最小的 G 机器（Mark 1）的实现，包括其状态表示、指令集、评估器以及各个指令的状态转换规则和实现函数。

**主要内容回顾：**

1. **G 机器的整体结构**：
- 使用 runProg 函数连接解析器、编译器、评估器和结果显示函数，形成完整的系统。
- 包含必要的模块和数据类型定义，例如解析器数据类型和堆数据类型。
2. **G 机器的状态表示**：
- GmState 是一个五元组，包含指令序列、堆栈、堆、全局变量和统计信息。
- 通过定义状态访问函数（get 和 put 函数），方便地访问和修改状态的各个组成部分。
3. **指令集和节点类型**：
- 指令集包含六条基本指令，每条指令都有明确的功能。
- 节点类型包括数字节点、应用节点和全局节点，分别表示整数值、函数应用和全局函数。
4. **评估器的实现**：
- eval 函数通过递归调用执行指令序列，生成状态列表。
- doAdmin 函数用于更新统计信息，记录执行的步骤数。
5. **指令的状态转换规则和实现**：
- 每条指令都有相应的状态转换规则，描述了指令的作用和状态的变化。
- 实现函数根据状态转换规则，更新状态的组成部分，例如堆栈和堆。
6. **Unwind 指令的处理**：
- Unwind 指令用于展开堆栈，查找需要实例化的超级组合子。
- 根据堆栈顶的节点类型（数字节点、应用节点或全局节点），采取不同的行动。
**重要的概念和技巧：**

- **状态表示和访问**：通过定义状态访问函数，便于在添加新组件时保持代码的可重用性和可维护性。
- **指令的实现**：每条指令都有清晰的状态转换规则和实现函数，体现了函数式编程中将数学描述转化为代码的过程。
- **堆栈管理**：在执行指令时，需要准确地操作堆栈，确保堆栈的正确性和数据的一致性。
- **延迟求值**：虽然 Mark 1 G 机器尚未实现更新和延迟求值，但为后续的改进奠定了基础。
**总结**

通过本段内容的学习，您了解了 G 机器的基本实现原理，包括其状态表示、指令集、评估器以及指令的执行方式。G 机器通过将程序编译为指令序列，避免了运行时的模板实例化，提高了执行效率。每条指令都有明确的状态转换规则和实现函数，体现了函数式编程中代码与数学模型的紧密结合。

这些知识为您进一步理解函数式语言的实现奠定了坚实的基础。在后续的学习中，您可以探索 G 机器的改进版本，了解如何实现更新操作、算术运算，以及如何支持延迟求值等高级特性。
 #  
 Thought for 59 seconds
**概览**

您提供的内容来自 Simon Peyton Jones 的《Implementing Functional Languages: a tutorial》第三章，主要介绍了 G 机器的编译器部分，特别是如何将超级组合子（supercombinator）定义编译为 G 机器代码。作者引入了三个编译方案：SC、R 和 C，分别用于编译超级组合子、表达式以及构造表达式的图。同时，内容还讨论了 G 机器在执行 `Unwind` 指令时的状态转换规则，以及编译器的实现细节。

本段内容包括：

- **SC、R 和 C 编译方案**：详细解释了如何使用这些编译方案将超级组合子定义编译为 G 机器代码。
- **状态转换规则（3.12）**：描述了当 G 机器在执行 `Unwind` 指令时，遇到全局节点的处理方式。
- **编译程序的实现**：展示了编译器如何将源程序编译为 G 机器的初始状态，包括堆、全局变量和指令序列的构建。
- **编译示例**：通过编译 K 组合子的例子，详细说明了编译过程和生成的指令序列。
- **打印结果**：解释了如何定义一个美化打印器（pretty-printer）来展示 G 机器的状态和执行过程。
- **改进 Mark 1 G 机器**：提出了一些练习，鼓励读者改进 G 机器的实现，例如优化 `Pushint` 指令的处理。
**详细解析**

### **SC、R 和 C 编译方案**

首先，作者引入了三个编译方案，用于将超级组合子定义和表达式编译为 G 机器代码。

#### **SC 编译方案**

- **目的**：将超级组合子定义编译为 G 机器代码。
- **表示**：
```lua
SC[[d]] 是超级组合子定义 d 的 G 机器代码。
```
- **定义**：
```lua
SC[[f x1 ... xn = e]] = R[[e]] [x1 → 0, ..., xn → n − 1] n
```
这里，`f x1 ... xn = e` 是超级组合子的定义。`R[[e]] [x1 → 0, ..., xn → n − 1] n` 表示使用编译方案 R，将表达式 `e` 编译为代码，环境为 `[x1 → 0, ..., xn → n − 1]`，并且超级组合子的元数（arity）为 `n`。
#### **R 编译方案**

- **目的**：生成代码来实例化表达式 `e`，并在堆栈上展开结果。
- **定义**：
```lua
R[[e]] ρ d = C[[e]] ρ ++ [Slide d + 1, Unwind]
```
`C[[e]] ρ`：使用编译方案 C，生成构建表达式 `e` 的图的代码。`[Slide d + 1, Unwind]`：在构建完表达式后，添加 `Slide` 和 `Unwind` 指令，用于清理堆栈和展开结果。`d`：超级组合子的元数。
#### **C 编译方案**

- **目的**：生成代码，在环境 `ρ` 下构建表达式 `e` 的图，并将指向该图的指针留在堆栈顶。
- **定义**：**变量**：
```lua
C[[x]] ρ = [Push (ρ x)]，其中 x 是局部变量
```
ρ x：在环境 ρ 中，变量 x 对应的堆栈位置。**全局函数**：
```lua
C[[f]] ρ = [Pushglobal f]，其中 f 是超级组合子
```
将全局名称 f 对应的地址压入堆栈。**整数**：
```lua
C[[i]] ρ = [Pushint i]
```
将整数 i 压入堆栈。**函数应用**：
```lua
C[[e0 e1]] ρ = C[[e1]] ρ ++ C[[e0]] ρ+1 ++ [Mkap]
```
首先编译参数 `e1`，然后编译函数 `e0`，环境偏移 `1`。使用 `Mkap` 指令，将函数和参数组合成应用节点。**环境偏移**：
```java
ρ+n x = (ρ x) + n
```
将环境中的每个变量的堆栈位置增加 n，用于调整堆栈偏移。
### **状态转换规则（3.12）**

在 G 机器执行 `Unwind` 指令时，如果堆栈顶是一个全局节点 `NGlobal`，且有足够的参数，则需要跳转到该全局节点的代码。

**规则（3.12）**：

```less
[Unwind] a0 : ... : an : s   h[a0 : NGlobal n c]   m
=⇒ c a0 : ... : an : s   h   m
```

- **解释**：`[Unwind]`：当前指令是 `Unwind`。`a0 : ... : an : s`：堆栈，`a0` 是全局节点地址，`a1` 到 `an` 是参数的地址。`h[a0 : NGlobal n c]`：堆中，`a0` 地址对应的节点是全局节点，元数为 `n`，代码为 `c`。如果堆栈中参数数量足够（`length as >= n`），则将全局节点的代码 `c` 放入指令序列，继续执行。
- **实现函数**：
```haskell
newState (NGlobal n c)
  | length as < n = error "Unwinding with too few arguments"
  | otherwise = putCode c state
```
如果参数数量不足，抛出错误。否则，将全局节点的代码 `c` 放入状态的代码部分。
### **编译程序**

现在，我们了解了指令的定义和状态转换规则，接下来讨论如何生成指令序列，即编译器的实现。

#### **编译器概述**

- **编译器函数**：将源程序编译为 G 机器的初始状态。
- **关键函数**：`compile`：将程序编译为初始状态。`compileSc`：编译超级组合子定义（对应编译方案 SC）。`compileR`：编译表达式并展开堆栈（对应编译方案 R）。`compileC`：编译构建表达式图的代码（对应编译方案 C）。
- **类型定义**：
```haskell
type GmCompiler = CoreExpr -> GmEnvironment -> GmCode
```
编译器函数类型，接受表达式和环境，返回指令序列。
#### **compile 函数**

```haskell
compile :: CoreProgram -> GmState
compile program
  = (initialCode, [], heap, globals, statInitial)
  where (heap, globals) = buildInitialHeap program
```

- **参数**：`program`，核心语言的程序。
- **返回值**：G 机器的初始状态，包括：`initialCode`：初始指令序列。`[]`：初始堆栈为空。`heap`：初始堆，包含了所有全局节点。`globals`：全局变量的映射。`statInitial`：初始统计信息。
- **buildInitialHeap**：构建初始堆和全局变量映射。
#### **buildInitialHeap 函数**

```haskell
buildInitialHeap :: CoreProgram -> (GmHeap, GmGlobals)
buildInitialHeap program
  = mapAccuml allocateSc hInitial compiled
  where compiled = map compileSc program
```

- **作用**：遍历程序中的每个超级组合子定义，编译并分配在堆中，生成全局变量映射。
- **步骤**：**编译超级组合子**：使用 `compileSc` 编译每个超级组合子，得到 `compiled` 列表，类型为 `[GmCompiledSC]`。**分配堆节点**：使用 `mapAccuml` 和 `allocateSc`，将编译后的超级组合子分配在堆中，生成堆和全局变量映射。
- **类型定义**：
```haskell
type GmCompiledSC = (Name, Int, GmCode)
```
每个编译后的超级组合子由名称、元数和指令序列组成。
#### **allocateSc 函数**

```haskell
allocateSc :: GmHeap -> GmCompiledSC -> (GmHeap, (Name, Addr))
allocateSc heap (name, nargs, instns)
  = (heap', (name, addr))
  where (heap', addr) = hAlloc heap (NGlobal nargs instns)
```

- **作用**：在堆中为编译后的超级组合子分配一个全局节点 `NGlobal`。
- **返回值**：更新后的堆和全局变量的名称与地址对。
#### **初始指令序列**

```haskell
initialCode :: GmCode
initialCode = [Pushglobal "main", Unwind]
```

- **解释**：**Pushglobal "main"**：将全局函数 `main` 的地址压入堆栈。**Unwind**：展开堆栈，开始执行程序。
#### **compileSc 函数**

```haskell
compileSc :: (Name, [Name], CoreExpr) -> GmCompiledSC
compileSc (name, env, body)
  = (name, length env, compileR body (zip2 env [0..]))
```

- **参数**：`name`：超级组合子的名称。`env`：参数列表，即形式参数。`body`：超级组合子的主体表达式。
- **返回值**：`(name, length env, code)`，即名称、元数和编译后的指令序列。
- **过程**：**构建环境**：`zip2 env [0..]`，将参数列表与其堆栈位置对应，生成环境 `ρ`。例如，["x", "y"] 对应 [(“x”, 0), (“y”, 1)]。**编译主体**：使用 `compileR`，编译主体表达式 `body`，环境为 `ρ`。
#### **compileR 函数**

```haskell
compileR :: GmCompiler
compileR e env = compileC e env ++ [Slide (length env + 1), Unwind]
```

- **作用**：**编译表达式**：使用 `compileC`，编译表达式 `e`，环境为 `env`。**添加指令**：在指令序列末尾添加 `Slide` 和 `Unwind` 指令。**Slide (length env + 1)**：清理堆栈，保留堆栈顶的结果，移除其下方的参数和超级组合子节点。**Unwind**：展开堆栈，继续执行。
#### **compileC 函数**

```haskell
compileC :: GmCompiler
compileC (EVar v) env
  | elem v (aDomain env) = [Push n]
  | otherwise = [Pushglobal v]
  where n = aLookup env v (error "Can't happen")

compileC (ENum n) env = [Pushint n]

compileC (EAp e1 e2) env = compileC e2 env ++
                           compileC e1 (argOffset 1 env) ++
                           [Mkap]
```

- **参数**：`e`：表达式，可以是变量、整数或应用。`env`：环境，变量到堆栈位置的映射。
- **处理**：**变量**：如果变量在环境中（局部变量），生成 `[Push n]`，将对应堆栈位置的元素压入堆栈。如果变量不在环境中（全局变量），生成 `[Pushglobal v]`，将全局变量的地址压入堆栈。**整数**：生成 [Pushint n]，将整数 n 压入堆栈。**应用**：首先编译参数 `e2`，环境为 `env`。然后编译函数 `e1`，环境为 `argOffset 1 env`，偏移量增加 1。添加 `[Mkap]`，将函数和参数组合成应用节点。
- **辅助函数**：**argOffset**：
```haskell
argOffset :: Int -> GmEnvironment -> GmEnvironment
argOffset n env = [(v, n + m) | (v, m) <- env]
```
将环境中的每个变量的堆栈位置增加 n，用于调整堆栈偏移。
### **编译示例：K 组合子**

我们通过编译 K 组合子来理解编译过程：

```haskell
compileSc ("K", ["x", "y"], EVar "x")
```

- **步骤 1**：使用 `compileSc` 编译超级组合子。
```haskell
("K", 2, compileR (EVar "x") [("x", 0), ("y", 1)])
```
名称：`"K"`。元数：`2`（参数列表的长度）。环境：`[("x", 0), ("y", 1)]`。
- **步骤 2**：使用 `compileR` 编译主体。
```haskell
("K", 2, compileC (EVar "x") [("x", 0), ("y", 1)] ++ [Slide 3, Unwind])
```
编译表达式 `EVar "x"`，环境为 `ρ`。添加 `[Slide 3, Unwind]`，其中 `length env + 1 = 2 + 1 = 3`。
- **步骤 3**：使用 `compileC` 编译 `EVar "x"`。查找变量 `x` 在环境中的位置，`n = 0`。生成 `[Push 0]`，将堆栈中第 `0` 个元素压入堆栈。
- **最终结果**：
```haskell
("K", 2, [Push 0, Slide 3, Unwind])
```
- **解释**：**Push 0**：将堆栈顶的元素（`x`）压入堆栈。**Slide 3**：清理堆栈，保留堆栈顶的结果，移除其下方的 `3` 个元素（`x`、`y`、`K`）。**Unwind**：展开堆栈，继续执行。
**练习 3.3**

- **任务**：为 S 组合子编写等效的转换序列。S 组合子定义为：
```haskell
S f g x = f x (g x)
```
- **提示**：使用与 K 组合子类似的步骤，编译 S 组合子，生成指令序列。运行编译器和机器，检查生成的代码是否正确。
### **原语（Primitives）**

在这个最小的 G 机器中，没有原语（如算术运算等），因此不需要实现任何原语。

```haskell
compiledPrimitives :: [GmCompiledSC]
compiledPrimitives = []
```

### **打印结果**

由于状态的某些组件是抽象数据类型，不能直接打印，需要定义一个美化打印器（pretty-printer）来展示机器产生的状态。

#### **showResults 函数**

```haskell
showResults :: [GmState] -> [Char]
showResults states
  = iDisplay (iConcat [
      iStr "Supercombinator definitions", iNewline,
      iInterleave iNewline (map (showSC s) (getGlobals s)),
      iNewline, iNewline, iStr "State transitions", iNewline, iNewline,
      iLayn (map showState states),
      iNewline, iNewline,
      showStats (last states)])
  where (s:ss) = states
```

- **功能**：输出以下内容：**超级组合子的代码序列**。**状态转换**：机器执行过程中每个状态的堆栈和指令序列。**最终统计信息**：例如执行的步骤数。
#### **showSC 函数**

```haskell
showSC :: GmState -> (Name, Addr) -> Iseq
showSC s (name, addr)
  = iConcat [ iStr "Code for ", iStr name, iNewline,
              showInstructions code, iNewline, iNewline]
  where (NGlobal arity code) = (hLookup (getHeap s) addr)
```

- **作用**：打印超级组合子的名称和对应的指令序列。
#### **showInstructions 函数**

```haskell
showInstructions :: GmCode -> Iseq
showInstructions is
  = iConcat [iStr " Code:{",
             iIndent (iInterleave iNewline (map showInstruction is)),
             iStr "}", iNewline]
```

- **作用**：格式化输出指令序列，每条指令占一行，缩进显示。
#### **showInstruction 函数**

```haskell
showInstruction :: Instruction -> Iseq
showInstruction Unwind = iStr "Unwind"
showInstruction (Pushglobal f) = (iStr "Pushglobal ") `iAppend` (iStr f)
showInstruction (Push n) = (iStr "Push ") `iAppend` (iNum n)
showInstruction (Pushint n) = (iStr "Pushint ") `iAppend` (iNum n)
showInstruction Mkap = iStr "Mkap"
showInstruction (Slide n) = (iStr "Slide ") `iAppend` (iNum n)
```

- **作用**：将指令转换为可读的字符串表示。
#### **showState 函数**

```haskell
showState :: GmState -> Iseq
showState s
  = iConcat [showStack s, iNewline,
             showInstructions (getCode s), iNewline]
```

- **作用**：打印机器状态的堆栈和当前指令序列。
#### **showStack 函数**

```haskell
showStack :: GmState -> Iseq
showStack s
  = iConcat [iStr " Stack:[",
             iIndent (iInterleave iNewline
                      (map (showStackItem s) (reverse (getStack s)))),
             iStr "]"]
```

- **作用**：打印堆栈，由于希望堆栈顶在底部显示，使用 reverse 函数反转堆栈。
#### **showStackItem 函数**

```haskell
showStackItem :: GmState -> Addr -> Iseq
showStackItem s a
  = iConcat [iStr (showaddr a), iStr ": ",
             showNode s a (hLookup (getHeap s) a)]
```

- **作用**：打印堆栈中的每个元素，显示地址和对应的节点信息。
#### **showNode 函数**

```haskell
showNode :: GmState -> Addr -> Node -> Iseq
showNode s a (NNum n) = iNum n
showNode s a (NGlobal n g) = iConcat [iStr "Global ", iStr v]
  where v = head [n | (n, b) <- getGlobals s, a == b]
showNode s a (NAp a1 a2) = iConcat [iStr "Ap ", iStr (showaddr a1),
                                    iStr " ", iStr (showaddr a2)]
```

- **作用**：根据节点类型，打印节点信息。**数字节点**：打印数字值。**全局节点**：打印全局变量名称。需要反转全局变量映射，以从地址获取名称。**应用节点**：打印函数和参数的地址。
#### **showStats 函数**

```haskell
showStats :: GmState -> Iseq
showStats s
  = iConcat [ iStr "Steps taken = ", iNum (statGetSteps (getStats s))]
```

- **作用**：打印统计信息，例如执行的步骤数。
### **改进 Mark 1 G 机器**

作者提出了一些练习，鼓励读者改进 G 机器的实现。

#### **练习 3.4**

- **任务**：运行程序 `main = S K K 3`。**问题**：它需要多少步？为什么与模板实例化机器的结果不同？比较机器的执行步骤数是否公平？
- **思考**：分析 G 机器和模板实例化机器的执行过程，理解步骤数的差异。考虑不同机器的实现细节和优化策略。
#### **练习 3.5**

- **任务**：尝试运行附录 B 中的其他程序。**注意**：由于这个简单的机器没有实现算术运算，可能需要避免包含算术操作的程序。
#### **练习 3.6**

- **任务**：优化 `Pushint` 指令的实现，类似于 `Pushglobal`。**问题**：每个不同的数字都在堆中创建一个唯一的节点。**方案**：**修改 Pushint 指令的状态转换规则**：如果全局变量映射中已经存在数字 `n`，则直接使用对应的地址。
```less
(3.13) Pushint n : i   s   h   m[n : a]
=⇒ i a : s h   m
```
如果不存在，则创建新的数字节点，并更新全局变量映射。
```less
(3.14) Pushint n : i   s   h   m
=⇒ i a : s h[a : NNum n] m[n : a]
```
**实现**：定义一个 `putGlobals` 函数，用于更新全局变量映射。修改 `pushint` 函数，首先检查全局变量映射，如果存在数字 `n`，则使用已有的地址，否则创建新节点并更新映射。
- **优势**：重用相同的数字节点，节省内存。避免重复创建相同的数字节点，提高效率。
**全面详尽的总结**

本段内容深入介绍了 G 机器的编译器部分，特别是如何使用编译方案 SC、R 和 C，将超级组合子定义和表达式编译为 G 机器的指令序列。

**主要内容回顾：**

1. **编译方案的定义**：
- **SC 编译方案**：用于编译超级组合子定义。
- **R 编译方案**：用于编译表达式并展开堆栈。
- **C 编译方案**：用于生成构建表达式图的代码。
- 这些编译方案提供了一个系统化的方法，将源代码翻译为 G 机器指令。
2. **状态转换规则（3.12）**：
- 描述了 G 机器在执行 Unwind 指令时的行为，特别是当堆栈顶为全局节点时，如何处理参数和跳转到对应的代码。
3. **编译器的实现**：
- 通过 `compile` 函数，将源程序编译为 G 机器的初始状态。
- 使用 `compileSc`、`compileR` 和 `compileC` 函数，按照编译方案将超级组合子和表达式编译为指令序列。
- 详细解释了环境的构建、堆的初始化和指令序列的生成。
4. **编译示例**：
- 通过编译 K 组合子的例子，展示了编译过程的具体步骤和生成的指令序列。
- 解释了如何处理变量、参数和堆栈偏移。
5. **打印结果**：
- 定义了美化打印器，能够格式化输出 G 机器的状态和执行过程。
- 详细介绍了各个打印函数的作用和实现。
6. **改进 G 机器的建议**：
- 提出了练习，鼓励读者优化 Pushint 指令的实现，重用数字节点，提高效率。
**重要的概念和技巧：**

- **编译方案的系统性**：通过定义清晰的编译方案（SC、R、C），将复杂的编译过程分解为可管理的部分，方便理解和实现。
- **环境和堆栈管理**：在编译过程中，正确处理变量的环境和堆栈偏移，确保生成的代码能够正确地访问和操作数据。
- **状态转换规则的应用**：明确定义机器的状态转换规则，有助于正确实现指令的执行和处理特殊情况。
- **代码重用和优化**：通过重用数字节点和全局节点，可以节省内存和提高效率，这是优化编译器和解释器的重要策略。
**总结**

通过本段内容的学习，您深入理解了 G 机器的编译器实现，包括如何将超级组合子定义和表达式编译为指令序列，以及如何处理环境、堆栈和状态转换。您还学会了使用编译方案来系统化地组织编译过程，以及如何定义和实现打印器来展示机器的状态。

这些知识为您进一步探索函数式语言的实现和优化奠定了坚实的基础。在后续的学习中，您可以继续研究 G 机器的改进版本，了解如何实现更新操作、支持延迟求值，以及添加算术运算等高级特性，构建更完善和高效的函数式语言解释器。
 #  
 Thought for 25 seconds
**概览**

您提供的内容来自 Simon Peyton Jones 的《Implementing Functional Languages: A Tutorial》第三章，特别是 3.4 节 "Mark 2: Making it lazy"。这一节讨论了如何对 Mark 1 G 机器进行修改，使其支持惰性求值（Lazy Evaluation），从而实现懒惰的函数式语言特性。

主要内容包括：

- **为什么需要惰性求值**：Mark 1 G 机器不是惰性的，因为它在展开（unwinding）之前没有更新原始表达式的根节点。
- **Mark 2 机器的改进**：通过在实例化超级组合子（supercombinator）主体后，用一个间接节点（indirection node）覆盖原始 redex（可还原表达式）的根节点。
- **指令集的修改**：引入了新的指令 `Update` 和 `Pop`，替换了之前的 `Slide` 指令，以实现更新和堆栈清理。
- **数据结构的修改**：增加了新的节点类型 `NInd`，用于表示间接节点。
- **评估器的修改**：定义了 `Update`、`Pop` 指令的语义，以及当堆栈顶是间接节点时，`Unwind` 指令的处理方式。
- **编译器的修改**：更新了编译方案 R，使其生成新的指令序列 `[Update n, Pop n, Unwind]`。
通过这些修改，G 机器能够记住先前计算的结果，避免重复计算，从而实现惰性求值。

**详细解析**

### **3.4 Mark 2: 使其惰性化**

#### **背景与动机**

- **Mark 1 G 机器的问题**：**非惰性**：Mark 1 机器不是惰性的，因为它在展开（unwind）之前没有更新原始表达式的根节点。**后果**：每次需要求值同一个表达式时，都会重新计算，而不会利用之前的计算结果。
- **惰性求值的必要性**：**避免重复计算**：通过记住之前的计算结果，可以提高效率，避免不必要的计算。**惰性求值**：在需要的时候才计算表达式的值，并在计算后缓存结果，以备后续使用。
#### **Mark 2 机器的改进**

- **核心思想**：**使用间接节点（indirection node）更新原始表达式的根节点**。**过程**：**实例化超级组合子的主体**：在堆中构建超级组合子主体的实例。**更新原始 redex 的根节点**：用一个指向新实例的间接节点覆盖原始表达式的根节点。**效果**：当再次需要计算该表达式时，可以直接使用之前计算的结果，避免重复计算。
#### **实现细节**

- **修改指令序列**：**Mark 1 机器的指令**：在每个超级组合子代码的末尾，使用 `[Slide (n + 1), Unwind]`。**Mark 2 机器的指令**：替换为 `[Update n, Pop n, Unwind]`。**Update n**：将堆栈中第 `n + 1` 个元素（相对于栈顶）对应的节点更新为一个间接节点，指向堆栈顶的元素。**Pop n**：从堆栈中弹出 `n` 个元素，清理不再需要的参数。
- **指令序列的示意**：**示例**：**原始指令**：`[Slide (n + 1), Unwind]`。**新指令**：`[Update n, Pop n, Unwind]`。
- **图示说明**：**Figure 3.4**：展示了 Mark 1 机器执行 `Slide n + 1` 指令时的堆栈和堆的变化。**Figure 3.5**：展示了 Mark 2 机器执行 `[Update n, Pop n]` 指令时的堆栈和堆的变化。**Update n**：更新原始 redex 的根节点为间接节点（使用 `#` 表示）。**Pop n**：移除堆栈中不再需要的参数。
### **3.4.1 数据结构**

为了支持新的指令和节点类型，需要对数据结构进行修改。

#### **指令集的修改**

- **新增指令**：**Update Int**：更新堆中的节点为间接节点。**Pop Int**：从堆栈中弹出指定数量的元素。
- **修改后的指令数据类型**：
```haskell
data Instruction
  = Unwind
  | Pushglobal Name
  | Pushint Int
  | Push Int
  | Mkap
  | Update Int
  | Pop Int
```
- **实现 Eq 类型类的实例**：
```haskell
instance Eq Instruction where
  Unwind == Unwind = True
  Pushglobal a == Pushglobal b = a == b
  Pushint a == Pushint b = a == b
  Push a == Push b = a == b
  Mkap == Mkap = True
  Update a == Update b = a == b
  _ == _ = False
```
- **练习 3.7**：**任务**：修改 `showInstruction` 函数，以显示新的指令。**提示**：需要为 `Update` 和 `Pop` 指令添加对应的显示规则。
#### **节点类型的修改**

- **新增节点类型**：**NInd Addr**：表示间接节点，存储一个地址。
- **修改后的节点数据类型**：
```haskell
data Node
  = NNum Int          -- 数字节点
  | NAp Addr Addr     -- 应用节点
  | NGlobal Int GmCode  -- 全局节点
  | NInd Addr         -- 间接节点
```
- **实现 Eq 类型类的实例**：
```haskell
instance Eq Node where
  NNum a == NNum b = a == b    -- 需要用于条件检查
  NAp a b == NAp c d = False   -- 不需要
  NGlobal a b == NGlobal c d = False  -- 不需要
  NInd a == NInd b = False     -- 不需要
```
**注意**：除了数字节点外，其他节点的相等性检查都返回 False，因为在当前实现中不需要比较这些节点的相等性。
- **更新显示函数 showNode**：**任务**：修改 `showNode` 函数，使其能够正确显示新的节点类型 `NInd`。**练习 3.8**：**提示**：为 NInd 节点添加显示规则，例如显示为 Indirection to <地址>。
### **3.4.2 评估器（Evaluator）**

需要为新的指令 `Update` 和 `Pop` 定义语义，以及当堆栈顶是间接节点时，`Unwind` 指令的处理方式。

#### **Update 指令的语义**

- **作用**：将堆栈中第 `n + 1` 个元素（相对于栈顶）的节点更新为一个间接节点，指向堆栈顶的元素。
- **状态转换规则（3.15）**：
```less
Update n : i   a : a0 : ... : an : s   h   m
=> i          a0 : ... : an : s   h[an : NInd a]   m
```
**解释**：**Update n**：当前指令是 `Update n`。**a : a0 : ... : an : s**：堆栈，`a` 是堆栈顶元素，`a0` 到 `an` 是之前的元素。**h[an : NInd a]**：将堆中地址为 `an` 的节点更新为 `NInd a`。**堆栈更新**：堆栈变为 `a0 : ... : an : s`，即移除了堆栈顶的 `a`。
#### **Pop 指令的语义**

- **作用**：从堆栈中弹出 `n` 个元素。
- **状态转换规则（3.16）**：
```less
Pop n : i   a1 : ... : an : s   h   m
=> i        s   h   m
```
**解释**：**Pop n**：当前指令是 `Pop n`。**a1 : ... : an : s**：堆栈，`a1` 到 `an` 是要弹出的元素。**堆栈更新**：堆栈变为 `s`，即移除了 `a1` 到 `an`。
#### **Unwind 指令的新规则**

- **当堆栈顶是间接节点时**：**作用**：将堆栈顶的地址替换为间接节点指向的地址，继续展开。
- **状态转换规则（3.17）**：
```less
[Unwind] a0 : s   h[a0 : NInd a]   m
=> [Unwind] a : s   h   m
```
**解释**：**堆栈顶**：`a0`，对应的节点是 `NInd a`。**操作**：将堆栈顶的地址替换为 `a`，即间接节点指向的地址。**指令序列**：保持为 `[Unwind]`，继续展开。
#### **实现**

- **修改 dispatch 函数**：**任务**：在 `dispatch` 函数中，添加对新指令 `Update` 和 `Pop` 的处理。**示例**：
```haskell
dispatch (Update n) = update n
dispatch (Pop n) = pop n
```
- **实现新指令的处理函数**：**update 函数**：根据状态转换规则（3.15）实现 `Update n` 指令的功能。**pop 函数**：根据状态转换规则（3.16）实现 `Pop n` 指令的功能。
- **修改 unwind 函数**：**任务**：在处理 `Unwind` 指令时，添加对间接节点的处理。**示例**：
```haskell
newState (NInd a) = putCode [Unwind] (putStack (a : as) state)
```
- **练习 3.9**：**任务**：修改 Mark 1 机器的 dispatch 函数，添加新指令的处理；实现新的状态转换规则。
### **3.4.3 编译器**

需要更新编译器，使其生成新的指令序列，以支持惰性求值。

#### **修改编译方案 R**

- **原始的 R 编译方案**：
```lua
R[[e]] ρ d = C[[e]] ρ ++ [Slide d + 1, Unwind]
```
- **新的 R 编译方案（图 3.6）**：
```lua
R[[e]] ρ d = C[[e]] ρ ++ [Update d, Pop d, Unwind]
```
**解释**：**C[[e]] ρ**：编译表达式 `e`，环境为 `ρ`。**[Update d, Pop d, Unwind]**：在编译的代码后添加新的指令序列。**Update d**：更新堆中的节点为间接节点。**Pop d**：弹出 `d` 个参数。**Unwind**：展开堆栈，继续求值。
- **需要修改的地方**：**compileR 函数**：根据新的 R 编译方案，修改生成的指令序列。
- **练习 3.10**：**任务**：修改 compileR 函数，实施新的 R 编译方案。
#### **编译器的其他部分**

- **其余的编译器代码不需要修改**，因为修改只涉及到 R 编译方案生成的指令序列。
### **练习 3.11**

**任务**：

- **运行惰性求值器**，执行以下程序：
```haskell
twice f x = f (f x)
id x = x
main = twice twice id 3
```
- **问题**：**需要多少步？****为什么与 Mark 1 机器的结果不同？****比较机器执行步骤数是否公平？**
**分析**：

- **Mark 2 机器的优势**：**惰性求值**：会记住之前计算的结果，避免重复计算。
- **执行过程**：**twice twice id 3** 展开后会涉及到多次调用 `id` 和 `twice`。**惰性求值**：在 Mark 2 机器中，相同的子表达式只会计算一次。
- **步骤数的差异**：**Mark 1 机器**：因为不是惰性的，可能会重复计算相同的表达式，步骤数会更多。**Mark 2 机器**：通过更新和间接节点，避免了重复计算，步骤数会减少。
- **公平性**：**比较执行步骤数是否公平**：需要考虑两台机器实现的特性不同。**评价标准**：应该根据机器的实际性能和特性进行比较，而不是仅仅依赖步骤数。
**全面详尽的总结**

本段内容详细介绍了如何对 Mark 1 G 机器进行修改，使其支持惰性求值，形成 Mark 2 G 机器。主要的修改包括：

1. **引入间接节点（Indirection Node）**：
- **目的**：在实例化超级组合子主体后，用间接节点覆盖原始表达式的根节点。
- **效果**：当再次需要计算该表达式时，可以直接使用之前计算的结果，避免重复计算，实现惰性求值。
2. **修改指令集**：
- **新增指令**：**Update Int**：更新堆中的节点为间接节点，指向计算结果。**Pop Int**：从堆栈中弹出指定数量的元素，清理不再需要的参数。
- **替换指令序列**：将 [Slide (n + 1), Unwind] 替换为 [Update n, Pop n, Unwind]。
3. **修改数据结构**：
- **新增节点类型**：**NInd Addr**：间接节点，存储一个地址，指向计算结果。
- **更新显示函数**：修改 showInstruction 和 showNode 函数，以支持新的指令和节点类型。
4. **修改评估器**：
- **定义新指令的语义**：**Update n**：根据状态转换规则（3.15）实现，更新堆中的节点为间接节点。**Pop n**：根据状态转换规则（3.16）实现，从堆栈中弹出指定数量的元素。
- **修改 Unwind 指令的处理**：当堆栈顶是间接节点时，根据状态转换规则（3.17）处理。
5. **修改编译器**：
- **更新 R 编译方案**：新的编译方案生成 [Update d, Pop d, Unwind] 指令序列，支持惰性求值。
- **修改 compileR 函数**：根据新的编译方案，生成更新后的指令序列。
6. **练习和实践**：
- **练习 3.7 和 3.8**：修改显示函数，支持新的指令和节点类型。
- **练习 3.9 和 3.10**：实现新的指令处理和编译方案。
- **练习 3.11**：通过运行示例程序，理解 Mark 2 机器的惰性求值特性，以及与 Mark 1 机器的差异。
**重要的概念和技巧**：

- **惰性求值的实现**：通过在计算后更新原始表达式的根节点为间接节点，记住计算结果，避免重复计算。
- **间接节点的作用**：作为指向计算结果的引用，使得相同的表达式只需计算一次。
- **指令集的扩展**：添加新的指令 `Update` 和 `Pop`，以支持更新和堆栈清理操作。
- **编译器的灵活性**：通过修改编译方案，生成新的指令序列，支持新的功能。
- **状态转换规则的应用**：清晰地定义了新指令的语义，确保评估器能够正确地执行。
**总结**

通过对 Mark 1 G 机器的改进，形成了支持惰性求值的 Mark 2 G 机器。惰性求值是函数式语言的重要特性，能够提高程序的效率，避免不必要的计算。实现惰性求值需要对指令集、数据结构、评估器和编译器进行修改，确保在计算后记住结果，并在需要时复用。

通过本段内容的学习，您了解了惰性求值的原理，以及如何在 G 机器中实现这一特性。这包括引入间接节点、修改指令集、更新评估器的处理逻辑，以及调整编译器生成的代码。您还通过练习和示例程序，加深了对这些概念的理解。

这些知识为您进一步探索函数式语言的实现奠定了坚实的基础。在后续的学习中，您可以继续研究 G 机器的其他改进，如支持算术运算、优化内存管理，以及更高级的特性，如垃圾回收和并行计算。
 #  
 Thought for 42 seconds
**概览**

您提供的内容来自 Simon Peyton Jones 的《Implementing Functional Languages: A Tutorial》第三章，特别是 3.5 节 **"Mark 3: let(rec) expressions"**。这一节讨论了如何扩展 G 机器，使其能够处理包含 `let` 和 `letrec` 表达式的程序。这涉及到对 G 机器的指令集、数据结构和编译器进行修改，以支持局部变量和递归定义。

主要内容包括：

- **引入对 let 和 letrec 表达式的支持**：通过修改编译器和机器，使其能够处理局部绑定的变量，包括非递归和递归的局部定义。
- **改进变量访问的效率**：通过调整堆栈布局，改善变量的访问方式，使得对局部变量的访问与对函数参数的访问方式相同，从而提高效率。
- **修改指令集和指令的实现**：为了适应新的堆栈布局，需要修改一些指令（如 Push 和 Unwind），并引入新的指令（如 Alloc 和 Slide）。
- **更新数据结构和评估器**：增加新的节点类型，调整评估器的行为，以支持新的指令和功能。
- **编译器的修改**：扩展编译器的功能，使其能够编译 let 和 letrec 表达式，生成相应的指令序列。
- **示例和练习**：通过编译固定点组合子（Y 组合子）的示例，展示编译过程，并提供练习以巩固理解。
**详细解析**

### **3.5 Mark 3: 支持 let(rec) 表达式**

在这一节中，我们将扩展 G 机器，使其能够处理包含 `let` 和 `letrec` 表达式的超级组合子定义。这需要对编译器、机器指令集、堆栈布局等进行修改。

#### **引入 ELet 构造器**

- **背景**：在核心表达式的数据类型 CoreExpr 中，引入了一个新的构造器 ELet，用于表示 let 和 letrec 表达式。
- **ELet 构造器**：**参数**：**Bool 类型的标志位**：指示定义是非递归的 let（False）还是递归的 letrec（True）。**定义列表**：一组变量与对应的表达式，即 [(Name, CoreExpr)]。**主体表达式**：在这些定义的作用域内要计算的表达式。
#### **重新审视堆栈布局**

在添加局部定义之前，我们需要重新考虑堆栈的布局，特别是如何更有效地访问变量。

##### **变量的高效访问**

- **目标**：提高变量访问的效率，使对局部绑定变量的访问方式与函数参数的访问方式相同。
- **现状（Mark 1 机器）**：当展开（unwind）到一个超级组合子节点 f，且 f 需要 n 个参数时，堆栈的状态如 **图 3.7** 左侧所示。堆栈中存储的是应用节点的地址，需要通过 getArg 函数多次解引用，才能访问实际的参数值。
- **改进（Mark 3 机器）**：修改堆栈布局，使堆栈顶部的 n 个元素直接指向表达式 e1 到 en，如 **图 3.7** 右侧所示。这样，我们可以更快地访问变量，因为只需要一次解引用即可获得参数值。**保留对原始表达式根节点的指针**：以便在需要更新时（例如惰性求值中的更新操作）仍然能够访问到原始表达式。
#### **指令的影响**

由于堆栈布局的改变，我们需要修改某些指令，以适应新的堆栈结构。

##### **修改 Push 指令**

- **原来的 Push 指令**：需要通过 getArg 函数，透过应用节点来获取参数。
- **修改后的 Push 指令**：不再需要使用 getArg，因为堆栈顶部的元素直接指向参数表达式。
- **新的状态转换规则（3.18）**：
```less
Push n : i   a0 : ... : an : s   h   m
=> i        an : a0 : ... : an : s   h   m
```
**解释**：**Push n**：当前指令，将堆栈中第 n 个元素压入堆栈顶部。**a0 : ... : an : s**：当前堆栈，其中 a0 是原始表达式的根节点地址，a1 到 an 是参数的地址。**结果**：将第 n 个元素 an 压入堆栈顶部，堆栈变为 an : a0 : ... : an : s。
##### **修改 Unwind 指令**

- **原因**：在新的堆栈布局中，当 `Unwind` 到一个超级组合子节点时，需要重新排列堆栈，使其适应新的访问方式。
- **新的状态转换规则（3.19）**：
```yaml
[Unwind] a0 : ... : an : s   h
[a0 : NGlobal n c
 a1 : NAp a0 a1'
 ...
 an : NAp an-1 an']
m
=> c a1' : ... : an' : an : s   h   m
```
**解释**：**堆栈**：a0 : ... : an : s，a0 是超级组合子的地址，a1 到 an 是应用节点的地址。**堆**：包含了应用节点的结构，用于解引用获取实际的参数地址 a1' 到 an'。**结果**：将超级组合子的代码 c 放入指令序列，将参数 a1' 到 an' 压入堆栈顶部。
- **注意**：这个 `Unwind` 的定义在 `n` 为零时也能正常工作。
##### **辅助函数 rearrange**

- **作用**：用于在 `Unwind` 指令中重新排列堆栈。
- **定义**：
```haskell
rearrange :: Int -> GmHeap -> GmStack -> GmStack
rearrange n heap as
  = take n as' ++ drop n as
  where as' = map (getArg . hLookup heap) (tail as)
```
**参数**：n：需要重新排列的参数数量。heap：当前的堆，用于查找节点。as：当前的堆栈。**结果**：返回重新排列后的堆栈。
##### **练习 3.12**

- **任务**：重写 dispatch 函数和新的状态转换规则，以适应新的指令集。需要使用 rearrange 函数来重新排列堆栈。
##### **练习 3.13**

- **任务**：使用附录 B 中的一些示例程序，测试新的编译器和抽象机器，确保实现仍然有效。
### **3.5.1 局部绑定变量**

现在，我们回到如何实现 `let` 和 `letrec` 表达式，首先考虑非递归的情况。

#### **非递归局部定义（let 表达式）**

- **思路**：在表达式 `let x1 = e1; ... ; xn = en in e` 中，一旦构建了表达式 `e1` 到 `en`，我们可以像处理超级组合子的参数一样处理变量 `x1` 到 `xn`。
- **变量访问**：通过堆栈偏移访问变量，使用环境 `ρ` 记录变量的位置。
- **堆栈操作过程**（见 **图 3.8**）：**初始状态**：堆栈中包含了超级组合子的参数。**执行构建局部定义的代码（Code）**：构建表达式 e1 到 en 的图，将它们的地址依次压入堆栈。堆栈顶部现在多了 n 个新的元素，分别是 e1 到 en 的地址。**构建主体表达式 e**：使用新的环境 ρ'，将变量 x1 到 xn 映射到堆栈中的位置。编译并执行表达式 e。**清理堆栈**：使用 Slide 指令，移除堆栈顶部的 n 个局部变量的地址。
- **环境更新**：因为堆栈上新增了 `n` 个变量，需要在环境中记录它们的位置，以便在编译 `e` 时正确地访问它们。
- **编译方案**：编译局部定义的代码（Code）：对每个表达式 ei，生成代码构建其图，并将地址压入堆栈。编译主体表达式 e，使用更新后的环境。添加 Slide n 指令，移除堆栈顶部的 n 个变量。
- **完整的编译方案参见 **图 3.10**。
#### **递归局部定义（letrec 表达式）**

- **挑战**：在递归定义中，每个表达式 `ei` 可能引用其他变量 `x1` 到 `xn`。
- **解决方案**：**在堆中创建空节点**：使用新的指令 Alloc n，在堆中创建 n 个空的节点（通常用 ? 表示），并将它们的地址压入堆栈。这些节点初始为间接节点，指向非法地址 hNull。**编译每个表达式 ei**：使用更新的环境 ρ'，其中变量 x1 到 xn 已经映射到堆栈中的位置。编译表达式 ei，生成代码来构建其图。在表达式的代码末尾，添加 Update n_i 指令，将对应的空节点更新为实际的图结构。**编译主体表达式 e**：使用环境 ρ'，编译主体表达式 e。**清理堆栈**：使用 Slide n 指令，移除堆栈顶部的 n 个变量。
- **过程示意**：见 **图 3.9**。
### **3.5.2 数据结构**

为了支持新的指令和功能，需要更新指令集和相关的数据结构。

#### **更新指令集**

- **新增指令**：**Alloc Int**：在堆中分配指定数量的空节点。**Slide Int**：从 Mark 1 机器引入，用于清理堆栈。
- **完整的指令数据类型**：
```haskell
data Instruction
  = Unwind
  | Pushglobal Name
  | Pushint Int
  | Push Int
  | Mkap
  | Update Int
  | Pop Int
  | Alloc Int
  | Slide Int
```
- **更新显示函数**：**练习 3.14**：修改 showInstruction 函数，以显示新的指令。
### **3.5.3 评估器（Evaluator）**

需要为新的指令 `Alloc` 定义状态转换规则，并更新 `dispatch` 函数。

#### **Alloc 指令的语义**

- **作用**：在堆中分配 `n` 个空节点（间接节点），并将它们的地址压入堆栈。
- **状态转换规则（3.20）**：
```less
Alloc n : i   s   h   m
=> i        a1 : ... : an : s   h'
m
```
**堆**：在堆中分配 n 个节点，地址为 a1 到 an，初始值为 NInd hNull。**堆栈**：将新分配的节点地址压入堆栈顶部。
- **实现**：
```haskell
alloc :: Int -> GmState -> GmState
alloc n state
  = putHeap heap' (putStack (as ++ getStack state) state)
    where (heap', as) = allocNodes n (getHeap state)
```
**辅助函数 allocNodes**：
```haskell
allocNodes :: Int -> GmHeap -> (GmHeap, [Addr])
allocNodes 0 heap = (heap, [])
allocNodes (n+1) heap = (heap2, a : as)
  where (heap1, as) = allocNodes n heap
        (heap2, a) = hAlloc heap1 (NInd hNull)
```
- **更新 dispatch 函数**：**练习 3.15**：在 dispatch 函数中，添加对 Alloc 指令的处理，使用 allocNodes 实现 alloc 函数。
### **3.5.4 编译器**

编译器需要更新 `compileC` 函数，以处理新的表达式类型 `ELet`，并实现 `compileLet` 和 `compileLetrec` 函数。

#### **更新 compileC 函数**

- **新的 compileC 定义**：
```haskell
compileC :: GmCompiler
compileC (EVar v) args
  | elem v (aDomain args) = [Push n]
  | otherwise = [Pushglobal v]
  where n = aLookup args v (error "")

compileC (ENum n) env = [Pushint n]

compileC (EAp e1 e2) env = compileC e2 env ++
                           compileC e1 (argOffset 1 env) ++
                           [Mkap]

compileC (ELet recursive defs e) args
  | recursive = compileLetrec compileC defs e args
  | otherwise = compileLet compileC defs e args
```
- **处理 ELet 构造器**：根据标志位 recursive，选择调用 compileLet 或 compileLetrec。
#### **实现 compileLet 函数**

- **作用**：根据编译方案（见 **图 3.10**），编译非递归的 `let` 表达式。
- **定义**：
```haskell
compileLet :: GmCompiler -> [(Name, CoreExpr)] -> GmCompiler
compileLet comp defs expr env
  = compileLet' defs env ++ comp expr env' ++ [Slide (length defs)]
  where env' = compileArgs defs env
```
- **辅助函数 compileLet'**：
```haskell
compileLet' :: [(Name, CoreExpr)] -> GmEnvironment -> GmCode
compileLet' [] env = []
compileLet' ((name, expr):defs) env
  = compileC expr env ++ compileLet' defs (argOffset 1 env)
```
- **辅助函数 compileArgs**：
```haskell
compileArgs :: [(Name, CoreExpr)] -> GmEnvironment -> GmEnvironment
compileArgs defs env
  = zip (map fst defs) [n-1, n-2 .. 0] ++ argOffset n env
  where n = length defs
```
**作用**：更新环境，将新的变量 x1 到 xn 映射到堆栈中的位置。
#### **实现 compileLetrec 函数**

- **练习 3.16**：实现 compileLetrec 函数，以支持递归的 letrec 表达式。
#### **编译示例：Y 组合子**

- **定义**：
```haskell
Y f = letrec x = f x in x
```
- **编译过程**：**调用 compileSc**：
```haskell
compileSc ("Y", ["f"], ELet True [("x", EAp (EVar "f") (EVar "x"))] (EVar "x"))
```
**参数**：名称："Y"参数列表：["f"]主体：ELet True [("x", EAp (EVar "f") (EVar "x"))] (EVar "x")**调用 compileR**：
```haskell
("Y", 1, compileR e [("f", 0)])
where e = ELet True [("x", EAp (EVar "f") (EVar "x"))] (EVar "x")
```
**调用 compileC**：
```haskell
("Y", 1, compileC e [("f", 0)] ++ [Update 1, Pop 1, Unwind])
```
**编译 letrec 表达式**：**环境 p**：`[("x", 0), ("f", 1)]`**生成代码**：
```haskell
("Y", 1, [Alloc 1] ++
          compileC (EAp (EVar "f") (EVar "x")) p ++ [Update 0] ++
          compileC (EVar "x") p ++ [Slide 1] ++
          [Update 1, Pop 1, Unwind])
```
**简化代码**：
```haskell
("Y", 1, [Alloc 1,
          Push 0, Push 2, Mkap, Update 0,
          Push 0, Slide 1,
          Update 1, Pop 1, Unwind])
```
- **执行过程**：**图 3.11** 展示了代码的执行过程，特别是如何通过 Update 0 实现“打结”（knot-tying），构建固定点组合子。
- **练习 3.18**：通过运行生成的代码，或者以其他方式，绘制剩余的状态转换图，仿照 **图 3.11**。
### **练习与思考**

- **练习 3.17**：考虑哪些测试程序可以用来验证新的编译器和指令集的正确性。
- **练习 3.19**：尝试为 Y 组合子给出一个更短的替代代码序列，仍然需要构建“打结”版本。
- **练习 3.20**：在没有 letrec 构造器的语言中，如何定义固定点组合子 Y？这个定义与示例中使用的定义有何不同？
**全面详尽的总结**

在这一节中，我们详细讨论了如何扩展 G 机器（Mark 3），使其能够处理包含 `let` 和 `letrec` 表达式的程序。这涉及到对机器的多个方面进行修改，包括堆栈布局、指令集、数据结构、评估器和编译器。

**主要内容回顾：**

1. **支持局部定义**：
- **引入 ELet 构造器**：用于表示 let 和 letrec 表达式。
- **处理非递归和递归定义**：通过不同的编译方案和指令，支持 let（非递归）和 letrec（递归）的局部定义。
2. **改进变量访问效率**：
- **调整堆栈布局**：将堆栈顶部的元素直接指向参数或局部变量的表达式，减少解引用次数。
- **修改指令**：更新 Push 和 Unwind 指令，以适应新的堆栈布局。
3. **更新指令集和数据结构**：
- **新增指令**：**Alloc**：在堆中分配空节点，支持 letrec 表达式。**Slide**：用于清理堆栈，移除局部变量的地址。
- **更新显示函数**：确保新的指令能够被正确地打印和调试。
4. **评估器的修改**：
- **实现新指令的语义**：定义 Alloc 指令的状态转换规则，并在评估器中实现。
- **更新 dispatch 函数**：添加对新指令的处理。
5. **编译器的扩展**：
- **更新 compileC 函数**：使其能够编译 ELet 表达式。
- **实现 compileLet 和 compileLetrec 函数**：根据编译方案，实现对非递归和递归局部定义的编译。
6. **示例分析**：
- **编译 Y 组合子**：通过详细的步骤，展示了如何编译包含 letrec 表达式的超级组合子。
- **执行过程**：解释了生成的代码如何执行，以及如何实现“打结”固定点组合子。
7. **练习与实践**：
- **练习**：提供了一系列练习，鼓励读者亲自实现、测试和思考，包括修改代码、运行示例、验证实现的正确性等。
**重要的概念和技巧：**

- **堆栈布局的优化**：通过调整堆栈结构，提高变量访问的效率，对于解释器和编译器的性能优化非常重要。
- **编译方案的灵活性**：使用编译方案，可以系统化地处理不同类型的表达式，便于扩展和维护。
- **环境的管理**：在编译过程中，正确地管理变量环境，确保变量的引用和堆栈位置的一致性。
- **递归定义的处理**：通过在堆中分配空节点和更新操作，支持递归的局部定义，体现了函数式语言的强大表达能力。
- **指令集的扩展**：根据需要引入新的指令，如 Alloc，使得机器能够支持更多的语言特性。
**总结**

通过本节的学习，您深入了解了如何扩展 G 机器以支持 `let` 和 `letrec` 表达式。这包括对堆栈布局的调整、指令集的修改、数据结构的更新，以及编译器的扩展。您还通过示例（如 Y 组合子的编译）和练习，加深了对这些概念的理解。

这些知识对于理解函数式语言的实现和编译器的设计非常重要。它展示了如何通过修改底层机器的行为和编译过程，来支持更复杂的语言特性。在后续的学习中，您可以进一步探索 G 机器的改进版本，了解如何实现其他高级特性，如算术运算、模式匹配、垃圾回收等。

通过亲自实践和思考，您将能够更深入地理解函数式语言的实现原理，并将这些概念应用到实际的编译器和解释器的开发中。
 #  
 Thought for 6 seconds
**概览**

您提供的内容来自 Simon Peyton Jones 的《Implementing Functional Languages: A Tutorial》第三章，特别是 **3.6 节 "Mark 4: Adding primitives"**。这一节介绍了如何在 G 机器中添加基本的算术和比较操作，使其能够处理更复杂的程序。作者详细讨论了添加原始操作（primitives）所需的修改，包括指令集、数据结构、评估器和编译器的更新。

主要内容包括：

- **引入新的指令**：添加算术指令（如 `Add`）、比较指令（如 `Eq`）、条件指令（如 `Cond`）和评估指令（`Eval`）。
- **处理惰性求值的挑战**：由于 G 机器支持惰性求值，需要确保在执行算术或比较操作前，操作数已经被求值。
- **引入 Eval 指令和 Dump**：`Eval` 指令用于确保堆栈顶的表达式被求值到弱头部范式（WHNF）。为此，引入了 Dump（堆栈），用于保存评估过程中的上下文。
- **更新数据结构**：修改 G 机器的状态表示，添加 Dump 组件，并更新相关的访问函数。
- **实现新指令的状态转换规则**：详细描述了新指令的语义和状态转换，包括 `Eval`、`Unwind`、算术指令、比较指令和 `Cond` 指令。
- **使用高阶函数简化实现**：通过定义通用的高阶函数（如 `primitive1`、`primitive2`），简化算术和比较指令的实现。
- **更新编译器**：修改编译器，使其能够生成新的指令序列，并添加编译后的原语函数。
- **练习和思考**：提供了一些练习，帮助读者加深理解，包括实现新指令的转换、解释设计决策和测试新功能。
**详细解析**

### **3.6 Mark 4：添加原语（Primitives）**

在前面的 G 机器版本中（Mark 1 到 Mark 3），我们已经能够执行基本的函数式程序，但缺少对实际算术运算和比较操作的支持。为了使 G 机器更实用，我们需要添加对这些基本原语操作的支持。

#### **引入算术指令**

首先，我们引入一个简单的加法指令 `Add`，用于将两个数字相加。

**Add 指令的状态转换规则（3.21）：**

```yaml
Add : i   a0 : a1 : s   h[a0 : NNum n0, a1 : NNum n1]   m
=> i    a : s   h[a : NNum (n0 + n1)]   m
```

- **解释：****指令**：`Add`。**堆栈**：`a0 : a1 : s`，堆栈顶是 `a0` 和 `a1`，它们是要相加的数字的地址。**堆**：`h` 包含 `a0` 和 `a1` 对应的节点，都是数字节点 `NNum n0` 和 `NNum n1`。**操作**：将 `n0` 和 `n1` 相加，结果 `n0 + n1` 存储在新的节点 `a` 中。**堆更新**：在堆中添加新的节点 `NNum (n0 + n1)`，地址为 `a`。**堆栈更新**：将结果地址 `a` 压入堆栈，堆栈变为 `a : s`。
#### **处理惰性求值的挑战**

在支持惰性求值的 G 机器中，操作数（如 `a0` 和 `a1`）可能尚未被求值（可能是未计算的表达式）。如果直接执行 `Add` 指令，而操作数不是数字节点，会导致错误。

**解决方案：**

- **引入 Eval 指令**：在执行算术或比较操作之前，确保操作数被求值到弱头部范式（WHNF）。
- **定义 Eval 指令的行为**：**目标**：当堆栈顶的节点不是 WHNF 时，执行求值，直到节点变为 WHNF。**问题**：为了实现这一点，我们需要一种机制来保存当前的执行上下文，以便在求值完成后能够恢复执行。
#### **引入 Dump**

为了解决上述问题，引入了一个新的组件 **Dump**，用于保存执行上下文。

- **Dump 的作用**：保存当前的指令序列和堆栈，以便在求值完成后恢复。
- **Dump 的结构**：Dump 是一个栈，每个元素是一个二元组 `(GmCode, GmStack)`，分别表示指令序列和堆栈。
#### **Eval 指令的定义**

**Eval 指令的状态转换规则（3.23）：**

```ruby
Eval : i   a : s   d   h   m
=> [Unwind]   [a]   (i, s) : d   h   m
```

- **解释：****指令**：`Eval`。**堆栈**：`a : s`，堆栈顶是地址 `a`。**Dump**：`d`。**操作**：将当前的指令序列 `i` 和堆栈 `s` 压入 Dump。设置新的指令序列为 `[Unwind]`，开始对 `a` 进行求值。将堆栈设置为 `[a]`，只包含地址 `a`。
- **当求值完成后**，`a` 将被求值到 WHNF，`Unwind` 指令将负责恢复执行上下文。
#### **Unwind 指令的修改**

**Unwind 指令在 WHNF 时的状态转换规则（3.22）：**

```less
[Unwind] a : s   (i', s') : d   h[a : NNum n]   m
=> i'   a : s'   d   h   m
```

- **解释：****堆栈顶**：`a`，对应的节点是数字节点 `NNum n`。**Dump**：`(i', s') : d`，从 Dump 中取出保存的执行上下文。**操作**：恢复指令序列 `i'` 和堆栈 `s'`。将结果地址 `a` 压入堆栈。
- **其他情况**：如果堆栈顶不是 WHNF，继续按照之前的 `Unwind` 规则进行处理。
#### **更新 G 机器的状态表示**

为了支持 Dump，需要修改 G 机器的状态表示 `GmState`，添加 Dump 组件。

**新的 G 机器状态类型：**

```haskell
type GmState = (GmCode, GmStack, GmDump, GmHeap, GmGlobals, GmStats)
```

- **组件说明：****GmCode**：当前的指令序列。**GmStack**：当前的堆栈。**GmDump**：新的 Dump 组件，用于保存执行上下文。**GmHeap**：堆，存储节点。**GmGlobals**：全局变量的映射。**GmStats**：统计信息。
#### **更新访问函数**

需要更新之前定义的状态访问函数，以支持新的状态表示。

**示例：**

```haskell
getDump :: GmState -> GmDump
getDump (i, stack, dump, heap, globals, stats) = dump

putDump :: GmDump -> GmState -> GmState
putDump dump' (i, stack, dump, heap, globals, stats)
  = (i, stack, dump', heap, globals, stats)
```

- **注意**：需要更新所有之前的访问函数，以适应新的状态类型。
**练习 3.21：**

- **任务**：对其他访问函数进行相应的修改，使其适应新的状态表示。
#### **添加新的指令**

为了支持新的功能，添加以下指令：

- **Eval**：用于求值堆栈顶的表达式到 WHNF。
- **算术指令**：**Add**：加法。**Sub**：减法。**Mul**：乘法。**Div**：除法。**Neg**：取负数。
- **比较指令**：**Eq**：等于。**Ne**：不等于。**Lt**：小于。**Le**：小于等于。**Gt**：大于。**Ge**：大于等于。
- **条件指令**：**Cond GmCode GmCode**：条件指令，根据条件执行不同的指令序列。
#### **更新指令数据类型**

```haskell
data Instruction
  = Unwind
  | Pushglobal Name
  | Pushint Int
  | Push Int
  | Mkap
  | Update Int
  | Pop Int
  | Slide Int
  | Alloc Int
  | Eval
  | Add | Sub | Mul | Div | Neg
  | Eq | Ne | Lt | Le | Gt | Ge
  | Cond GmCode GmCode
```

**练习 3.22：**

- **任务**：更新 showInstruction 函数，添加对新指令的显示支持。
### **打印状态**

为了更好地调试和观察机器的行为，需要修改打印函数，使其显示新的 Dump 组件。

**更新 showState 函数：**

```haskell
showState :: GmState -> Iseq
showState s
  = iConcat [showStack s, iNewline,
             showDump s, iNewline,
             showInstructions (getCode s), iNewline]
```

- **添加 showDump 调用**，以显示 Dump 的内容。
**定义 showDump 函数：**

```haskell
showDump :: GmState -> Iseq
showDump s
  = iConcat [iStr " Dump:[",
             iIndent (iInterleave iNewline
                      (map showDumpItem (reverse (getDump s)))),
             iStr "]"]
```

- **解释**：遍历 Dump，逐个显示其内容。
**定义 showDumpItem 函数：**

```haskell
showDumpItem :: GmDumpItem -> Iseq
showDumpItem (code, stack)
  = iConcat [iStr "<",
             shortShowInstructions 3 code, iStr ", ",
             shortShowStack stack, iStr ">"]
```

- **shortShowInstructions**：只显示指令序列的前 3 条指令，避免输出过多信息。
- **shortShowStack**：简要显示堆栈内容，显示地址列表。
**定义 shortShowInstructions 函数：**

```haskell
shortShowInstructions :: Int -> GmCode -> Iseq
shortShowInstructions number code
  = iConcat [iStr "{", iInterleave (iStr "; ") dotcodes, iStr "}"]
  where codes = map showInstruction (take number code)
        dotcodes | length code > number = codes ++ [iStr "..."]
                 | otherwise = codes
```

- **解释**：如果指令序列长度超过指定数量，添加省略号。
**定义 shortShowStack 函数：**

```haskell
shortShowStack :: GmStack -> Iseq
shortShowStack stack
  = iConcat [iStr "[",
             iInterleave (iStr ", ") (map (iStr . showaddr) stack),
             iStr "]"]
```

- **解释**：将堆栈中的地址转换为字符串，使用逗号分隔。
### **新指令的状态转换**

#### **Eval 和 Unwind 指令**

**Eval 指令的状态转换规则（3.23）：**

前面已经解释过，这里再强调一下：

```ruby
Eval : i   a : s   d   h   m
=> [Unwind]   [a]   (i, s) : d   h   m
```

- **操作**：将当前的指令序列 `i` 和堆栈 `s` 压入 Dump。设置新的指令序列为 `[Unwind]`，堆栈为 `[a]`。
**Unwind 指令在 WHNF 时的状态转换规则（3.22）：**

```less
[Unwind] a : s   (i', s') : d   h[a : NNum n]   m
=> i'   a : s'   d   h   m
```

- **操作**：恢复之前保存的指令序列 `i'` 和堆栈 `s'`。将结果地址 `a` 压入堆栈。
- **注意**：如果 Dump 为空，且堆栈顶是数字节点，表示程序已完成求值。
#### **算术指令**

**通用的状态转换规则（3.24）：**

对于任意二元算术操作 `op`：

```ruby
op : i   a0 : a1 : s   d   h[a0 : NNum n0, a1 : NNum n1]   m
=> i    a : s   d   h[a : NNum (n0 `op` n1)]   m
```

- **解释**：**堆栈**：`a0 : a1 : s`，`a0` 和 `a1` 是要操作的数字的地址。**操作**：从堆中取出 `n0` 和 `n1`，计算 `n0 op n1`。**堆更新**：在堆中添加新的数字节点，值为 `n0 op n1`，地址为 `a`。**堆栈更新**：将结果地址 `a` 压入堆栈，堆栈变为 `a : s`。
**Neg 指令的状态转换规则（3.25）：**

```ruby
Neg : i   a : s   d   h[a : NNum n]   m
=> i    a' : s   d   h[a' : NNum (-n)]   m
```

- **解释**：**堆栈**：`a : s`，`a` 是要取负的数字的地址。**操作**：从堆中取出 `n`，计算 `-n`。**堆更新**：在堆中添加新的数字节点，值为 `-n`，地址为 `a'`。**堆栈更新**：将结果地址 `a'` 压入堆栈。
#### **实现高阶函数**

为了简化实现，定义了通用的高阶函数，用于处理算术和比较指令。

**boxInteger 函数：**

```haskell
boxInteger :: Int -> GmState -> GmState
boxInteger n state
  = putStack (a : getStack state) (putHeap h' state)
  where (h', a) = hAlloc (getHeap state) (NNum n)
```

- **作用**：将整数 n 装箱（放入堆中），并将地址压入堆栈。
**unboxInteger 函数：**

```haskell
unboxInteger :: Addr -> GmState -> Int
unboxInteger a state
  = ub (hLookup (getHeap state) a)
  where ub (NNum i) = i
        ub n = error "Unboxing a non-integer"
```

- **作用**：从堆中取出地址 a 对应的整数值。
**primitive1 函数：**

```haskell
primitive1 :: (b -> GmState -> GmState) -- 装箱函数
           -> (Addr -> GmState -> a)    -- 解箱函数
           -> (a -> b)                  -- 一元操作
           -> (GmState -> GmState)      -- 状态转换函数
primitive1 box unbox op state
  = box (op (unbox a state)) (putStack as state)
  where (a : as) = getStack state
```

- **作用**：实现一元操作的通用模式。
**primitive2 函数：**

```haskell
primitive2 :: (b -> GmState -> GmState) -- 装箱函数
           -> (Addr -> GmState -> a)    -- 解箱函数
           -> (a -> a -> b)             -- 二元操作
           -> (GmState -> GmState)      -- 状态转换函数
primitive2 box unbox op state
  = box (op (unbox a0 state) (unbox a1 state)) (putStack as state)
  where (a0 : a1 : as) = getStack state
```

- **作用**：实现二元操作的通用模式。
**定义算术操作函数：**

```haskell
arithmetic1 :: (Int -> Int) -> (GmState -> GmState)
arithmetic1 = primitive1 boxInteger unboxInteger

arithmetic2 :: (Int -> Int -> Int) -> (GmState -> GmState)
arithmetic2 = primitive2 boxInteger unboxInteger
```

- **示例**：`Add` 指令的实现：`arithmetic2 (+)``Neg` 指令的实现：`arithmetic1 negate`
**练习 3.23：**

- **任务**：实现所有新指令的状态转换，修改 dispatch 函数，使用 primitive1 和 primitive2 实现操作。
**练习 3.24：**

- **问题**：为什么在完成 `Eval` 指令后，堆栈顶不会是间接节点（`NInd`）？
- **回答**：因为在 `Unwind` 指令中，当遇到间接节点时，会跟踪到其指向的节点，直到堆栈顶是 WHNF。因此，在完成 `Eval` 后，堆栈顶是 WHNF（如数字节点）。
#### **比较指令**

**通用的状态转换规则（3.26）：**

对于任意比较操作 `op`：

```ruby
op : i   a0 : a1 : s   d   h[a0 : NNum n0, a1 : NNum n1]   m
=> i    a : s   d   h[a : NNum (if n0 `op` n1 then 1 else 0)]   m
```

- **解释**：**操作**：将比较结果（True 或 False）转换为整数 1 或 0，存储在新的节点中。
**boxBoolean 函数：**

```haskell
boxBoolean :: Bool -> GmState -> GmState
boxBoolean b state
  = putStack (a : getStack state) (putHeap h' state)
  where (h', a) = hAlloc (getHeap state) (NNum b')
        b' = if b then 1 else 0
```

- **作用**：将布尔值转换为整数 1（True）或 0（False），并装箱。
**定义比较操作函数：**

```haskell
comparison :: (Int -> Int -> Bool) -> GmState -> GmState
comparison = primitive2 boxBoolean unboxInteger
```

- **示例**：`Eq` 指令的实现：`comparison (==)``Lt` 指令的实现：`comparison (<)`
#### **Cond 指令**

**状态转换规则（3.27 和 3.28）：**

- **当条件为真（NNum 1）时：**
```less
Cond i1 i2 : i   a : s   d   h[a : NNum 1]   m
=> i1 ++ i   s   d   h   m
```
- **当条件为假（NNum 0）时：**
```less
Cond i1 i2 : i   a : s   d   h[a : NNum 0]   m
=> i2 ++ i   s   d   h   m
```
- **解释**：根据堆栈顶的值，选择执行 i1 或 i2，然后继续执行 i。
**练习 3.25：**

- **任务**：实现比较指令和 Cond 指令的状态转换。
### **编译器的修改**

为了利用新的指令，我们需要修改编译器，使其能够生成使用新指令的代码。

#### **修改初始状态**

更新 `compile` 函数，修改初始状态和初始指令序列。

```haskell
compile :: CoreProgram -> GmState
compile program
  = (initialCode, [], [], heap, globals, statInitial)
  where (heap, globals) = buildInitialHeap program

initialCode :: GmCode
initialCode = [Pushglobal "main", Eval]
```

- **解释**：**初始指令序列**：添加了 Eval 指令，确保在开始执行时，求值 main 到 WHNF。
- **练习 3.26：****问题**：为什么修改了初始指令序列？如果保留旧的，会发生什么？**回答**：因为我们需要确保 `main` 被求值到 WHNF，以处理可能存在的未求值表达式。如果不添加 `Eval`，程序可能无法正确求值。
#### **添加编译后的原语**

为了支持算术和比较操作，我们在编译器中添加编译后的原语函数。

**compiledPrimitives 列表：**

```haskell
compiledPrimitives :: [GmCompiledSC]
compiledPrimitives
  = [("+", 2, [Push 1, Eval, Push 1, Eval, Add, Update 2, Pop 2, Unwind]),
     ("-", 2, [Push 1, Eval, Push 1, Eval, Sub, Update 2, Pop 2, Unwind]),
     ("*", 2, [Push 1, Eval, Push 1, Eval, Mul, Update 2, Pop 2, Unwind]),
     ("/", 2, [Push 1, Eval, Push 1, Eval, Div, Update 2, Pop 2, Unwind]),
     ("negate", 1, [Push 0, Eval, Neg, Update 1, Pop 1, Unwind]),
     ("==", 2, [Push 1, Eval, Push 1, Eval, Eq, Update 2, Pop 2, Unwind]),
     ("~=", 2, [Push 1, Eval, Push 1, Eval, Ne, Update 2, Pop 2, Unwind]),
     ("<", 2, [Push 1, Eval, Push 1, Eval, Lt, Update 2, Pop 2, Unwind]),
     ("<=", 2, [Push 1, Eval, Push 1, Eval, Le, Update 2, Pop 2, Unwind]),
     (">", 2, [Push 1, Eval, Push 1, Eval, Gt, Update 2, Pop 2, Unwind]),
     (">=", 2, [Push 1, Eval, Push 1, Eval, Ge, Update 2, Pop 2, Unwind]),
     ("if", 3, [Push 0, Eval, Cond [Push 1] [Push 2],
                Update 3, Pop 3, Unwind])]
```

- **解释**：每个条目是一个三元组 `(Name, Arity, Code)`。**算术操作**：如加法 `"+"`，需要两个参数。**代码序列**：`Push 1, Eval`：获取第一个参数并求值。`Push 1, Eval`：获取第二个参数并求值。`Add`：执行加法。`Update 2, Pop 2, Unwind`：更新堆栈，清理参数，继续执行。**比较操作**：类似于算术操作。**条件操作**：`"if"` 函数需要三个参数。**代码序列**：`Push 0, Eval`：求值条件表达式。`Cond [Push 1] [Push 2]`：根据条件执行 `Push 1`（真分支）或 `Push 2`（假分支）。`Update 3, Pop 3, Unwind`：更新堆栈，清理参数，继续执行。
**练习 3.27：**

- **问题**：从附录 B 中选择哪些测试程序来验证新的指令和编译器的工作？
- **回答**：可以选择包含算术和比较操作的程序，如计算斐波那契数列、阶乘、条件表达式等，测试加法、乘法、条件判断等功能。
**全面详尽的总结**

在这一节中，我们扩展了 G 机器（Mark 4），添加了对原语操作（primitives）的支持，使其能够执行实际的算术和比较运算。这使得 G 机器变得更加实用，能够处理更复杂的程序。

**主要内容回顾：**

1. **引入新的指令和组件：**
- **Eval 指令**：用于将表达式求值到弱头部范式（WHNF）。
- **Dump**：新增的堆栈组件，用于在 `Eval` 指令中保存执行上下文。
- **算术指令**：`Add`、`Sub`、`Mul`、`Div`、`Neg` 等，用于执行基本的算术运算。
- **比较指令**：`Eq`、`Ne`、`Lt`、`Le`、`Gt`、`Ge` 等，用于执行比较操作。
- **Cond 指令**：用于条件执行，根据条件选择不同的指令序列。
2. **处理惰性求值的挑战：**
- **需要确保操作数被求值**：在执行算术或比较操作之前，需要确保操作数已经被求值。
- **Eval 和 Unwind 指令的交互**：通过 `Eval` 指令和修改后的 `Unwind` 指令，实现了在惰性求值环境下的正确求值和结果传递。
3. **更新数据结构和打印函数：**
- **修改 G 机器的状态表示**：添加 Dump 组件，更新状态访问函数。
- **更新打印函数**：修改 `showState`、`showDump` 等函数，能够显示新的状态信息，便于调试。
4. **实现新指令的状态转换规则：**
- **定义了各个新指令的状态转换规则**，详细解释了它们的语义和操作步骤。
- **使用高阶函数**：通过定义通用的高阶函数 `primitive1`、`primitive2`，简化了算术和比较指令的实现，避免了重复代码。
5. **修改编译器：**
- **更新初始状态和指令序列**：确保在程序开始时，主函数被正确求值。
- **添加编译后的原语函数**：在编译器中添加 `compiledPrimitives`，为常用的算术和比较操作提供预定义的实现。
6. **练习与思考：**
- **练习 3.21 到 3.27**：通过这些练习，读者可以巩固对新内容的理解，亲自实现新指令的状态转换，思考设计决策，测试新功能。
**重要的概念和技巧：**

- **惰性求值与求值顺序的控制**：通过 `Eval` 和 `Unwind` 指令，控制了在惰性求值环境下的求值顺序，确保操作数在需要时被求值。
- **执行上下文的保存和恢复**：引入 Dump 组件，实现了在求值过程中保存和恢复执行上下文的机制。
- **高阶函数的应用**：利用高阶函数抽象出通用的模式，简化了指令的实现，提高了代码的可读性和可维护性。
- **指令集的扩展**：通过添加新的指令，使 G 机器能够支持更多的语言特性，执行更复杂的程序。
**总结**

通过本节的学习，您了解了如何在 G 机器中添加原语操作，使其能够执行基本的算术和比较运算。这涉及到对机器的多个方面进行修改，包括指令集、数据结构、评估器和编译器。您还学会了在惰性求值环境下处理求值顺序的技巧，以及如何使用高阶函数来简化实现。

这些知识对于理解函数式语言的实现和编译器的设计非常重要。它展示了如何通过修改底层机器的行为和编译过程，来支持更复杂的语言特性。在后续的学习中，您可以继续探索 G 机器的改进版本，了解如何实现其他高级特性，如模式匹配、垃圾回收、并行计算等。

通过亲自实践和思考，您将能够更深入地理解函数式语言的实现原理，并将这些概念应用到实际的编译器和解释器的开发中。
 #  
 Thought for 5 seconds
**概览**

您提供的内容来自 Simon Peyton Jones 的《Implementing Functional Languages: A Tutorial》第三章，特别是 **3.7 节 "Mark 5: 更好地处理算术"**。这一节讨论了如何改进 G 机器，以更有效地处理算术和比较操作。作者通过具体的示例，展示了当前实现的不足，并提出了改进方案，即引入严格上下文（Strict Context）和相应的编译方案（E 编译方案）。

主要内容包括：

- **当前问题的描述**：在现有的 G 机器实现中，算术操作是通过对预定义的函数（如 `+`、`*`）的调用来完成的，这导致了不必要的计算和性能问题。
- **示例分析**：通过具体的示例程序，展示了当前实现的效率低下和潜在的问题，如过早求值导致的错误。
- **引入严格上下文**：为了改进算术操作的处理，引入了严格上下文和惰性上下文的概念，分别对应于需要立即求值和可以延迟求值的情况。
- **新的编译方案**：定义了 E 编译方案，用于在严格上下文中编译表达式，以生成更高效的指令序列。
- **修改编译器和机器**：更新编译器，使其能够识别严格上下文，并生成适当的代码；同时，修改 G 机器的状态转换规则，以支持新的编译方案。
- **讨论与总结**：指出了改进的局限性，以及在实际编译器中如何更广泛地应用严格性分析。
**详细解析**

### **3.7 Mark 5: 更好地处理算术**

在这一节中，我们将改进 G 机器的实现，使其更高效地处理算术和比较操作。当前的实现存在一些问题，导致了效率低下，甚至可能引入错误。

#### **3.7.1 问题描述**

**现状**：

- 在当前的 G 机器实现中，每个算术操作都是通过调用预编译的原语函数（compiled primitives）来完成的。例如，加法操作 `+` 是通过调用全局函数 `"+"` 实现的。
- 这意味着，即使在简单的算术表达式中，也需要进行多次函数调用和堆操作，导致效率低下。
**示例 1：**

考虑以下简单的程序：

```haskell
main = 3 + 4 * 5
```

使用当前的编译器，会生成以下指令序列：

```haskell
[Pushint 5, Pushint 4, Pushglobal "*", Mkap, Mkap,
 Pushint 3, Pushglobal "+", Mkap, Mkap, Eval]
```

- **执行过程**：首先，推入数字 `5` 和 `4`，然后调用全局函数 `"*"`，构建应用节点。然后，推入数字 `3`，再调用全局函数 `"+"`，构建另一个应用节点。最后，执行 `Eval` 指令，开始求值。
- **问题**：执行上述代码需要 **33 步**，使用了 **11 个堆节点**。这是因为每个算术操作都被当作函数调用，需要创建应用节点，并展开求值。
**改进的想法**：

- 我们希望直接使用算术指令，如 `Add` 和 `Mul`，而不是调用全局函数。
- 这将大大减少指令数量和堆操作，提高执行效率。
**改进后的代码**：

```haskell
[Pushint 5, Pushint 4, Mul, Pushint 3, Add]
```

- **执行过程**：推入数字 `5` 和 `4`，直接执行乘法 `Mul`。推入数字 `3`，执行加法 `Add`。
- **优势**：执行上述代码只需要 **5 步**，使用了 **5 个堆节点**。
#### **3.7.1 问题**

然而，直接替换算术操作也可能引入新的问题，尤其是在惰性求值的环境下。

**示例 2：**

考虑以下程序：

```haskell
main = K 1 (1 / 0)
```

- **解释**：这里，`K` 是常用的组合子，定义为 `K x y = x`，即返回第一个参数。表达式 `1 / 0` 实际上是一个未定义的操作（除以零）。
**使用当前的编译器**，生成的代码为：

```haskell
[Pushint 0, Pushint 1, Pushglobal "/", Mkap, Mkap,
 Pushint 1, Pushglobal "K", Mkap, Mkap, Eval]
```

**如果直接替换算术操作**，可能会生成以下代码：

```haskell
[Pushint 0, Pushint 1, Div,
 Pushint 1, Pushglobal "K", Mkap, Mkap, Eval]
```

**问题**：

- 由于直接执行了除法操作 `Div`，在计算 `1 / 0` 时，会产生 **除以零错误**。
- 这与原始程序的预期不符，因为在惰性求值的环境下，如果第二个参数未被使用，`1 / 0` 应该不会被计算，从而不会产生错误。
- **过早求值**：直接替换算术指令导致了过早求值，违反了惰性求值的原则。
#### **3.7.2 解决方案**

为了解决上述问题，我们需要区分表达式所处的上下文，并根据上下文生成适当的代码。

##### **上下文的分类**

我们将上下文分为两类：

1. **严格上下文（Strict Context）**：
- 表达式的值 **需要** 被求值到弱头部范式（WHNF）。
- 在严格上下文中，表达式必须被求值，以得到最终的结果。
2. **惰性上下文（Lazy Context）**：
- 表达式的值 **可能** 不需要被求值。
- 在惰性上下文中，表达式的求值可以被推迟，直到需要其值时才进行求值。
##### **对应的编译方案**

- **E 编译方案**：用于在严格上下文中编译表达式。生成的代码会在适当的地方直接使用算术指令，避免不必要的函数调用。
- **C 编译方案**：用于在惰性上下文中编译表达式。与之前的编译方案相同，保留惰性求值的特性。
##### **严格上下文的识别**

- **原则**：尽可能识别出处于严格上下文的表达式，以便生成更高效的代码。
- **递归定义**：严格上下文可以递归地传播到子表达式中。**规则**：**超级组合子的主体**：总是在严格上下文中。**算术和比较操作的操作数**：如果操作本身处于严格上下文中，其操作数也处于严格上下文。**一元算术操作**：如 `negate e`，如果表达式 `negate e` 处于严格上下文中，则子表达式 `e` 也处于严格上下文。**条件表达式**：`if e0 e1 e2` 处于严格上下文中，则 `e0`、`e1`、`e2` 都处于严格上下文。**let 和 letrec 表达式**：如果整个表达式处于严格上下文中，其主体 `e` 也处于严格上下文。
##### **编译方案的更新**

- **R 编译方案**：用于编译超级组合子，调用 E 编译方案。定义为：
```haskell
R[[e]] ρ d = E[[e]] ρ ++ [Update d, Pop d, Unwind]
```
- **E 编译方案**：用于在严格上下文中编译表达式。**基本思想**：在严格上下文中，可以直接生成算术指令，而不是函数调用。**定义**（参见 **图 3.12**）：**整数**：
```haskell
E[[i]] ρ = [Pushint i]
```
**let 表达式**：
```haskell
E[[let x1 = e1; ...; xn = en in e]] ρ
  = C[[e1]] ρ+0 ++ ... ++
    C[[en]] ρ+(n−1) ++
    E[[e]] ρ' ++ [Slide n]
where ρ' = ρ+n[x1 → n−1, ..., xn → 0]
```
**letrec 表达式**：
```haskell
E[[letrec x1 = e1; ...; xn = en in e]] ρ
  = [Alloc n] ++
    C[[e1]] ρ' ++ [Update n−1] ++ ... ++
    C[[en]] ρ' ++ [Update 0] ++
    E[[e]] ρ' ++ [Slide n]
where ρ' = ρ+n[x1 → n−1, ..., xn → 0]
```
**算术和比较操作**：
```haskell
E[[e0 op e1]] ρ = E[[e1]] ρ ++ E[[e0]] ρ+1 ++ [Op]
```
其中 Op 是对应的算术或比较指令。**一元算术操作**：
```haskell
E[[negate e]] ρ = E[[e]] ρ ++ [Neg]
```
**条件表达式**：
```haskell
E[[if e0 e1 e2]] ρ = E[[e0]] ρ ++ [Cond (E[[e1]] ρ) (E[[e2]] ρ)]
```
**默认情况**：
```haskell
E[[e]] ρ = C[[e]] ρ ++ [Eval]
```
如果表达式不属于上述情况，则使用 C 编译方案编译，然后添加 Eval 指令，确保求值到 WHNF。
##### **示例分析**

**示例 1（改进后）：**

对于程序 `main = 3 + 4 * 5`，使用新的编译方案，生成的代码为：

```haskell
[Pushint 5, Pushint 4, Mul, Pushint 3, Add]
```

- **解释**：由于表达式 3 + (4 * 5) 处于严格上下文中，且 + 和 * 是算术操作，因此我们可以直接使用算术指令。
- **执行效率**：改进后的代码执行更快，使用更少的堆节点。
**示例 2（解决过早求值的问题）：**

对于程序 `main = K 1 (1 / 0)`，使用新的编译方案，生成的代码为：

```haskell
[Pushglobal "K", Pushint 1, C[[1 / 0]], Mkap, Mkap, Eval]
```

- **解释**：由于 `K` 是用户定义的超级组合子，其参数默认处于惰性上下文中。因此，`1 / 0` 不会被过早求值，除非在程序执行过程中需要其值。
- **避免了过早求值导致的错误**。
##### **修改 G 机器的状态转换**

为了支持新的编译方案，需要修改 G 机器的 `Unwind` 指令的状态转换规则。

**新的 Unwind 转换规则（3.29）：**

```haskell
[Unwind] a0 : ... : ak    (i', s') : d   h[a0 : NGlobal n c]   m
=> i'   ak : s'   d   h   m    当 k < n
```

- **解释**：当堆栈中的参数数量不足以展开超级组合子时，Unwind 会从 Dump 中恢复之前的执行上下文，并继续执行。
- **作用**：允许在 Eval 指令中，对任意对象求值到 WHNF，而不仅仅是数字。
**练习 3.29：**

- **任务**：实现新的 Unwind 转换规则，编写一个程序，证明在没有新的转换规则时会失败。
##### **更新编译器**

- **使用新的编译方案**：修改编译器中的 `compileR` 和 `compileE` 函数，以实现 R 编译方案和 E 编译方案。
- **辅助函数**：**builtInDyadic**：定义了一组内置的二元操作符及其对应的指令。
```haskell
builtInDyadic :: ASSOC Name Instruction
builtInDyadic
  = [("+", Add), ("-", Sub), ("*", Mul), ("div", Div),
     ("==", Eq), ("~=", Ne), (">=", Ge),
     (">", Gt), ("<=", Le), ("<", Lt)]
```
- **练习 3.28：****任务**：修改现有的编译器函数 compileR 和 compileE，使其实现新的 R 编译方案和 E 编译方案，使用 builtInDyadic。
#### **讨论**

- **严格性分析**：在编译时确定表达式的严格性，可以生成更高效的代码。但是，无法在编译时完全确定所有表达式的严格性，只能针对特定的情况。
- **继承属性的使用**：将严格上下文视为表达式的一个属性，子表达式继承父表达式的严格性。这是编译器理论中继承属性的一个例子，相关理论可以参考 [Aho 等人的书](https://en.wikipedia.org/wiki/Attribute_grammar)。
- **扩展性**：本书仅对有限的表达式（如算术表达式）进行了严格性分析。实际的编译器可能会进行更广泛的分析，以覆盖更一般的表达式。
- **研究前沿**：有关严格性分析的研究仍在继续，如 [Burn 1991] 的工作。
#### **练习**

**练习 3.28：**

- **任务**：修改编译器，实现新的编译方案。
- **提示**：在 `compileR` 中，调用 `compileE` 而不是 `compileC`。在 `compileE` 中，根据表达式类型，生成适当的指令序列。
**练习 3.29：**

- **任务**：实现新的 `Unwind` 转换规则，编写一个会在没有新规则时失败的程序。
- **提示**：可以编写一个需要对非数字的表达式求值到 WHNF 的程序，观察是否会失败。
**练习 3.30：**

- **任务**：比较本节开头的示例程序在 Mark 4 和 Mark 5 机器上的执行。
- **提示**：运行程序 main = 3 + 4 * 5，比较执行步骤和堆节点的使用。
- **进一步**：选择附录 B 中的其他程序，测试新的编译器和机器的性能。
**全面详尽的总结**

在这一节中，我们深入探讨了如何改进 G 机器，以更有效地处理算术和比较操作。主要的改进思路是引入 **严格上下文（Strict Context）**，并根据上下文选择合适的编译方案。

**主要内容回顾：**

1. **问题的提出**：
- 现有的 G 机器在处理算术操作时，需要通过函数调用，导致执行效率低下。
- 直接替换算术指令可能导致过早求值，违反惰性求值的原则，甚至引入错误。
2. **解决方案**：
- **引入严格上下文和惰性上下文**，区分表达式的求值需求。
- **定义新的编译方案**：**E 编译方案**：用于严格上下文，直接生成算术指令，避免不必要的函数调用。**C 编译方案**：用于惰性上下文，保留惰性求值的特性。
3. **严格上下文的识别和传播**：
- 通过递归定义，识别处于严格上下文的表达式。
- 严格上下文可以通过算术操作、条件表达式、`let` 和 `letrec` 等结构递归地传播到子表达式。
4. **修改编译器和机器**：
- **更新编译器**：修改 `compileR` 和 `compileE`，实现新的编译方案。
- **更新 G 机器的状态转换规则**：添加新的 `Unwind` 转换规则，支持对任意对象求值到 WHNF。
5. **示例分析**：
- 通过具体的示例，展示了改进后的编译器如何生成更高效的代码，避免过早求值的问题。
6. **讨论与思考**：
- **继承属性的应用**：将严格上下文视为继承属性，子表达式继承父表达式的严格性。
- **严格性分析的局限性**：无法在编译时完全确定所有表达式的严格性，只能针对特定的情况进行优化。
- **研究前沿**：强调了在编译器中更广泛地应用严格性分析的可能性，以及相关的研究工作。
**重要的概念和技巧：**

- **严格上下文与惰性上下文**：理解表达式所处的上下文对于生成高效的代码至关重要。
- **编译方案的选择**：根据上下文选择适当的编译方案（E 或 C），以平衡性能和惰性求值的需求。
- **递归的编译过程**：编译器需要递归地分析表达式的结构，传递上下文信息。
- **编译器理论中的继承属性**：将上下文视为属性，利用属性文法的思想进行编译器设计。
- **G 机器的扩展**：通过修改状态转换规则，使机器能够支持新的编译方案和求值策略。
**总结**

通过本节的学习，您了解了如何改进 G 机器，以更高效地处理算术和比较操作。这涉及到对编译器和机器的深入理解和修改，包括：

- **引入严格性分析**：通过识别严格上下文，编译器能够生成更高效的代码。
- **新的编译方案**：E 编译方案允许直接生成算术指令，避免不必要的函数调用和堆操作。
- **机器的修改**：为了支持新的编译方案，需要修改 G 机器的状态转换规则，特别是 `Unwind` 指令。
- **平衡性能和惰性求值**：在改进性能的同时，确保不违反惰性求值的原则，避免过早求值导致的错误。
这些知识对于理解函数式语言的实现和编译器的优化策略非常重要。在实际的编译器中，严格性分析和其他优化技术可以进一步提高程序的执行效率。通过学习和实践，您将能够更深入地理解编译器和解释器的设计原理，并将这些概念应用到实际的编程和系统开发中。
 #  
 Thought for 6 seconds
**概览**

您提供的内容来自 Simon Peyton Jones 的《Implementing Functional Languages: A Tutorial》第三章，特别是 **3.8 节 "Mark 6: Adding data structures"**。这一节的主要目的是扩展 G 机器，使其能够处理任意的数据结构。在之前的版本中，G 机器只能处理数字和基本的算术运算。现在，我们要引入数据构造器（constructors）和模式匹配（case expressions），使 G 机器能够处理更复杂的数据类型，如列表、元组等。

主要内容包括：

- **引入新的核心语言构造器**：EConstr（构造器）和 ECase（case 表达式），用于表示数据结构和模式匹配。
- **对 G 机器的数据结构进行扩展**：修改机器的状态表示，添加新的节点类型 NConstr，用于表示构造器节点。
- **添加新的指令**：为 G 机器的指令集添加新的指令，如 Pack、Casejump、Split 和 Print，以支持构造器和模式匹配的操作。
- **修改评估器和编译器**：实现新指令的状态转换规则，并修改编译器，使其能够编译包含数据结构和模式匹配的程序。
- **示例和练习**：通过具体的示例，如 length 函数，展示新功能的实现，并提供练习以帮助理解。
**详细解析**

### **3.8 Mark 6: 添加数据结构**

在这一节中，我们将扩展 G 机器，使其能够处理任意的数据结构。这涉及到在核心语言中引入新的构造器和模式匹配表达式，并对 G 机器的数据结构、指令集、评估器和编译器进行相应的修改。

#### **3.8.1 概述**

为了在程序中使用数据结构，我们需要在核心语言中引入两个新的构造器：

- **EConstr**：用于表示数据构造器（constructors）。
- **ECase**：用于表示 case 表达式，即模式匹配。
例如，在核心语言中，一个具有标签 `t` 和元数（arity）`a` 的构造器可以表示为 `Pack{t,a}`。在列表数据类型中，我们通常有两个构造器：

- 空列表 []，表示为 Pack{1,0}，即标签为 1，元数为 0。
- 非空列表 (:)，表示为 Pack{2,2}，即标签为 2，元数为 2。
**示例：length 函数**

为了更好地理解，我们可以看看如何使用 `case` 表达式来定义列表的 `length` 函数：

```haskell
length xs = case xs of
    <1> -> 0;
    <2> y ys -> 1 + length ys
```

- **解释**：**第一步**：当我们计算 case xs of 时，首先需要将 xs 求值到弱头部范式（WHNF）。**第二步**：一旦 xs 被求值，我们可以根据它的构造器标签来选择对应的分支。如果 xs 的标签是 1，表示列表为空，则返回 0。如果 xs 的标签是 2，表示列表非空，具有两个组件 y 和 ys，则计算 1 + length ys。
**关于构造器的饱和**

- 我们假设每当我们试图拆解一个构造器时，它已经应用了正确数量的参数，即构造器是 **饱和的（saturated）**。
- 例如，对于构造器 Cons，如果它需要两个参数，那么只有在应用了两个参数后，才认为它是饱和的。
**返回结构化数据**

- 现在，核心语言程序可以返回一个结构化的数据对象，而不仅仅是一个数字。
- 我们需要使 G 机器能够以惰性的方式打印结构化数据对象。
#### **3.8.2 数据结构**

为了支持新的数据结构，我们需要对 G 机器的状态表示和节点类型进行修改。

##### **扩展 G 机器的状态**

- **添加 gmOutput 组件**：用于存储程序的输出结果。
```haskell
type GmState = (GmOutput, GmCode, GmStack, GmDump, GmHeap, GmGlobals, GmStats)
```
- **定义 GmOutput 类型**：它是一个字符列表，即字符串。
```haskell
type GmOutput = [Char]
```
- **访问函数**：我们需要为新的状态组件编写访问函数。
```haskell
getOutput :: GmState -> GmOutput
getOutput (o, i, stack, dump, heap, globals, stats) = o

putOutput :: GmOutput -> GmState -> GmState
putOutput o' (o, i, stack, dump, heap, globals, stats)
  = (o', i, stack, dump, heap, globals, stats)
```
- **练习 3.31**：**任务**：对其他访问函数进行相应的修改，以适应新的状态表示。
##### **扩展节点类型**

- **添加 NConstr 构造器**：用于表示构造器节点。
```haskell
data Node
  = NNum Int          -- 数字节点
  | NAp Addr Addr     -- 应用节点
  | NGlobal Int GmCode-- 全局节点
  | NInd Addr         -- 间接节点
  | NConstr Int [Addr]-- 构造器节点，包含标签和组件的地址列表
```
- **NConstr 构造器**：**参数**：**Int**：构造器的标签（tag）。**[Addr]**：构造器组件的地址列表。
- **实例化 Eq 类型类**：
```haskell
instance Eq Node where
  NNum a == NNum b = a == b
  NAp a b == NAp c d = False
  NGlobal a b == NGlobal c d = False
  NInd a == NInd b = False
  NConstr a b == NConstr c d = False
```
**解释**：只在比较数字节点时需要检查值是否相等，其他情况下返回 False。
#### **3.8.3 打印结果**

为了显示程序的输出，我们需要修改打印函数。

##### **修改 showState 函数**

```haskell
showState :: GmState -> Iseq
showState s
  = iConcat [showOutput s, iNewline,
             showStack s, iNewline,
             showDump s, iNewline,
             showInstructions (getCode s), iNewline]
```

- **添加 showOutput s**：显示输出组件。
##### **定义 showOutput 函数**

```haskell
showOutput :: GmState -> Iseq
showOutput s = iConcat [iStr "Output:\"", iStr (getOutput s), iStr "\""]
```

- **解释**：将 gmOutput 组件的内容显示为字符串。
##### **修改 showNode 函数**

由于我们扩展了节点类型，需要更新 `showNode` 函数，以处理新的 `NConstr` 节点。

```haskell
showNode :: GmState -> Addr -> Node -> Iseq
showNode s a (NNum n) = iNum n
showNode s a (NGlobal n g) = iConcat [iStr "Global ", iStr v]
  where v = head [n | (n, b) <- getGlobals s, a == b]
showNode s a (NAp a1 a2) = iConcat [iStr "Ap ", iStr (showaddr a1),
                                    iStr " ", iStr (showaddr a2)]
showNode s a (NInd a1) = iConcat [iStr "Ind ", iStr (showaddr a1)]
showNode s a (NConstr t as)
  = iConcat [iStr "Cons ", iNum t, iStr " [",
             iInterleave (iStr ", ") (map (iStr . showaddr) as), iStr "]"]
```

- **解释**：对于 NConstr 节点，显示其标签和组件的地址列表。
#### **3.8.4 指令集**

我们需要为 G 机器添加新的指令，以支持构造器和模式匹配。

##### **完整的指令集**

```haskell
data Instruction
  = Slide Int
  | Alloc Int
  | Update Int
  | Pop Int
  | Unwind
  | Pushglobal Name
  | Pushint Int
  | Push Int
  | Mkap
  | Eval
  | Add | Sub | Mul | Div
  | Neg
  | Eq | Ne | Lt | Le | Gt | Ge
  | Cond GmCode GmCode
  | Pack Int Int         -- 新的指令
  | Casejump [(Int, GmCode)]
  | Split Int
  | Print
```

- **新的指令**：**Pack Int Int**：创建构造器节点。**Casejump [(Int, GmCode)]**：根据构造器标签跳转到对应的代码序列。**Split Int**：将构造器的组件解包到堆栈上。**Print**：打印堆栈顶的值。
##### **更新 showInstruction 函数**

**练习 3.32**：

- **任务**：扩展 showInstruction 函数，添加对新指令的显示支持。
#### **新指令的状态转换规则**

##### **Pack 指令**

**状态转换规则（3.30）**：

```less
o  Pack t n : i   a1 : ... : an : s   d   h   m
=> o  i   a : s   d   h[a : NConstr t [a1, ..., an]]   m
```

- **解释**：**指令**：Pack t n，构造一个标签为 t、元数为 n 的构造器。**堆栈**：堆栈顶部有 n 个元素，对应构造器的组件。**操作**：在堆中创建一个 NConstr 节点，标签为 t，组件为 [a1, ..., an]。将新节点的地址 a 压入堆栈。
##### **Casejump 指令**

**状态转换规则（3.31）**：

```vbnet
o  Casejump [..., t -> i', ...] : i   a : s   d   h[a : NConstr t ss]   m
=> o  i' ++ i   a : s   d   h   m
```

- **解释**：**指令**：Casejump，包含一个映射列表，将构造器标签映射到对应的代码序列。**堆栈**：堆栈顶是地址 a，对应一个 NConstr 节点，标签为 t。**操作**：根据标签 t，选择对应的代码序列 i'。将 i' 追加到当前的指令序列 i 之前。将地址 a 压入堆栈。
##### **Split 指令**

**状态转换规则（3.32）**：

```less
o  Split n : i   a : s   d   h[a : NConstr t [a1, ..., an]]   m
=> o  i   a1 : ... : an : s   d   h   m
```

- **解释**：**指令**：Split n，将构造器的 n 个组件解包到堆栈上。**堆栈**：堆栈顶是地址 a，对应一个 NConstr 节点，组件为 [a1, ..., an]。**操作**：将组件的地址依次压入堆栈。
##### **Print 指令**

**对于数字节点（3.33）**：

```less
o  Print : i   a : s   d   h[a : NNum n]   m
=> o ++ [n]  i   s   d   h   m
```

- **解释**：**操作**：将数字 n 添加到输出字符串 gmOutput，然后继续执行。
**对于构造器节点（3.34）**：

```less
o  Print : i   a : s   d   h[a : NConstr t [a1, ..., an]]   m
=> o  i' ++ i   a1 : ... : an : s   d   h   m
```

- **解释**：**操作**：生成代码 i'，用于打印构造器的组件。将 i' 追加到当前的指令序列 i 之前。将组件的地址压入堆栈。
**新的 Unwind 规则（3.35）**

当堆栈顶是一个构造器节点时，`Unwind` 指令需要特殊处理：

```less
[Unwind]   a : s   (i', s') : d   h[a : NConstr n as]   m
=> i'   a : s'   d   h   m
```

- **解释**：**操作**：从 Dump 中恢复之前的执行上下文，将地址 a 压入堆栈。
**练习 3.33**：

- **任务**：实现新指令的状态转换规则，修改 dispatch 函数以处理新指令。
#### **3.8.5 编译器**

为了支持新的语言构造器，我们需要修改编译器，添加新的编译方案。

##### **新的编译方案**

在 **图 3.14** 中，定义了新的编译方案，包括 `E`、`C`、`D` 和 `A`。

- **E 编译方案**：用于在严格上下文中编译表达式，确保求值到 WHNF。**E[[case e of alts]] ρ**：
```haskell
E[[case e of alts]] ρ = E[[e]] ρ ++ [Casejump D[[alts]] ρ]
```
**E[[Pack{t,a} e1 ... ea]] ρ**：
```haskell
E[[Pack{t,a} e1 ... ea]] ρ
  = C[[ea]] ρ+0 ++ ... ++ C[[e1]] ρ+(a−1) ++ [Pack t a]
```
- **C 编译方案**：用于在惰性上下文中编译表达式，构建表达式的图。**C[[Pack{t,a} e1 ... ea]] ρ**：
```haskell
C[[Pack{t,a} e1 ... ea]] ρ
  = C[[ea]] ρ+0 ++ ... ++ C[[e1]] ρ+(a−1) ++ [Pack t a]
```
- **D 编译方案**：用于编译 `case` 表达式的各个替代（alternatives）。**D[[alts]] ρ**：
```haskell
D[[alt1 ... altn]] ρ = [A[[alt1]] ρ, ..., A[[altn]] ρ]
```
- **A 编译方案**：用于编译每个替代。**A[[<t> x1 ... xn -> body]] ρ**：
```haskell
A[[ x1 ... xn -> body]] ρ
  = t -> [Split n] ++ E[[body]] ρ' ++ [Slide n]
where ρ' = ρ+n[x1 → 0, ..., xn → n−1]
```
##### **实现编译器函数**

- **compileAlts 函数**：对应于 `D` 编译方案，用于编译替代列表。
```haskell
compileAlts :: (Int -> GmCompiler) -> [CoreAlt] -> GmEnvironment -> [(Int, GmCode)]
compileAlts comp alts env
  = [(tag, comp (length names) body (zip names [0..] ++ argOffset (length names) env))
     | (tag, names, body) <- alts]
```
**参数**：**comp**：用于编译替代体的编译器函数（对应于 A 编译方案）。**alts**：替代列表。**env**：当前环境。
- **compileE' 函数**：用于在编译替代体时，添加 `Split` 和 `Slide` 指令。
```haskell
compileE' :: Int -> GmCompiler
compileE' offset expr env
  = [Split offset] ++ compileE expr env ++ [Slide offset]
```
- **练习 3.34**：**任务**：修改 compile 函数，更新 initialCode，在程序结束时添加 Print 指令。
- **练习 3.35**：**任务**：为编译器函数 compileE 和 compileC 添加新的情况，以处理 Pack 和 case 表达式。
#### **3.8.6 在比较中使用新的布尔值表示**

现在，我们可以将布尔值表示为构造器：

- **True**：表示为 Pack{2,0}，标签为 2，元数为 0。
- **False**：表示为 Pack{1,0}，标签为 1，元数为 0。
##### **实现条件函数**

我们可以通过在程序中定义 `if` 函数，使用 `case` 表达式来选择分支：

```haskell
if c t f = case c of
    <1> -> f;
    <2> -> t
```

##### **修改比较指令的状态转换规则**

**新的规则（3.36）**：

```less
o  op : i   a0 : a1 : s   d   h[a0 : NNum n0, a1 : NNum n1]   m
=> o  i   a : s   d   h[a : NConstr b []]   m
```

- **解释**：**操作**：执行比较操作 op，得到布尔值 b。将结果表示为构造器节点 NConstr b []，其中 b 是 1（表示 False）或 2（表示 True）。
##### **修改 boxBoolean 函数**

```haskell
boxBoolean :: Bool -> GmState -> GmState
boxBoolean b state
  = putStack (a : getStack state) (putHeap h' state)
  where (h', a) = hAlloc (getHeap state) (NConstr b' [])
        b' = if b then 2 else 1
```

- **解释**：将布尔值 b 转换为标签 b'，True 为 2，False 为 1。在堆中创建一个 NConstr 节点，标签为 b'，没有组件。
**练习 3.37**：

- **任务**：运行附录 B 中的示例程序，例如阶乘函数：
```haskell
fac n = if (n == 0) 1 (n * fac (n - 1))
```
#### **3.8.7 扩展接受的语言**

我们注意到，有些合法的表达式目前的编译器无法编译。这些表达式包括：

1. 在非严格上下文中出现的 ECase 表达式，即在使用 C 编译方案的表达式中。
2. 应用于参数数量不足的 EConstr 表达式，即构造器未饱和。
##### **解决方案**

- **使用程序转换技术**：将无法编译的表达式转换为等价的、可编译的形式。
- **对于 ECase**：**示例**：
```haskell
f x = Pack{2,2} (case x of <1> -> 1; <2> -> 2) Pack{1,0}
```
**转换为**：
```haskell
f x = Pack{2,2} (g x) Pack{1,0}
g x = case x of <1> -> 1; <2> -> 2
```
**解释**：将 `case` 表达式提取为一个新的超级组合子 `g`。
- **对于未饱和的 EConstr**：**示例**：
```haskell
prefix p xs = map (Pack{2,2} p) xs
```
**转换为**：
```haskell
prefix p xs = map (f p) xs
f p x = Pack{2,2} p x
```
**解释**：将未饱和的构造器应用转换为一个新的超级组合子 `f`。
##### **修改 Pushglobal 指令**

另一种解决方法是修改 `Pushglobal` 指令，使其能够处理构造器名称 `Pack{t,a}`。

- **当函数存在时（3.37）**：
```less
o  Pushglobal Pack{t,n} : i   s   d   h[Pack{t,n} : a]   m
=> o  i   a : s   d   h   m
```
- **当函数不存在时（3.38）**：
```less
o  Pushglobal Pack{t,n} : i   s   d   h   m
=> o  i   a : s   d   h[a : NGlobal n [Pack t n, Update 0, Unwind]]   m
   [Pack{t,n} : a]
```
- **解释**：**当全局环境中没有找到 Pack{t,n} 时**，创建一个新的全局节点，包含代码 [Pack t n, Update 0, Unwind]。**这样就可以直接将未饱和的构造器当作函数来调用**。
##### **修改编译器**

- **修改 C 编译方案**：
```haskell
C[[Pack{t,a}]] ρ = [Pushglobal "Pack{t,a}"]
```
- **练习 3.38**：**任务**：实现对 Pushglobal 指令的扩展，修改编译器，使其能够处理未饱和的构造器。
**全面详尽的总结**

在这一节中，我们扩展了 G 机器，使其能够处理任意的数据结构。这是通过在核心语言中引入新的构造器（`EConstr`）和模式匹配表达式（`ECase`）来实现的。为了支持这些新的语言特性，我们对 G 机器的数据结构、指令集、评估器和编译器进行了全面的修改。

**主要内容回顾：**

1. **引入新的核心语言构造器**：
- **EConstr（构造器）**：用于表示数据构造器，如列表的 [] 和 (:)。
- **ECase（case 表达式）**：用于模式匹配，选择性地执行代码。
2. **扩展 G 机器的数据结构**：
- **添加 gmOutput 组件**：用于存储程序的输出结果。
- **扩展节点类型**：添加 NConstr 构造器，表示构造器节点，包含标签和组件列表。
3. **添加新的指令**：
- **Pack**：构造一个新的构造器节点。
- **Casejump**：根据构造器标签跳转到对应的代码序列。
- **Split**：将构造器的组件解包到堆栈上，方便访问。
- **Print**：打印堆栈顶的值，包括数字和构造器。
4. **修改评估器和编译器**：
- **实现新指令的状态转换规则**：定义了新的状态转换规则，以支持新的指令。
- **修改编译器**：添加新的编译方案（E、C、D、A），使其能够编译包含数据结构和模式匹配的程序。
5. **示例和练习**：
- **length 函数**：展示了如何编译和执行包含模式匹配的函数。
- **fac 函数**：演示了如何使用新的布尔值表示来实现递归函数。
- **练习**：通过一系列练习，帮助读者深入理解新内容，包括修改访问函数、实现新指令、修改编译器等。
6. **扩展接受的语言**：
- **处理未饱和的构造器和在非严格上下文中的 case 表达式**：提出了使用程序转换技术和修改 Pushglobal 指令的解决方案。
**重要的概念和技巧：**

- **构造器和模式匹配的实现**：通过添加新的节点类型和指令，实现了对数据结构和模式匹配的支持。
- **指令的状态转换规则**：详细定义了新指令的操作，确保在执行过程中正确处理构造器和模式匹配。
- **编译器的扩展**：使用新的编译方案，处理包含数据结构的表达式和 case 表达式。
- **惰性求值和 WHNF**：继续强调了在惰性求值环境下，如何正确地求值表达式，特别是在处理模式匹配时。
- **程序转换技术**：介绍了如何通过重写程序，解决编译器无法直接处理的表达式。
**总结**

通过本节的学习，您了解了如何在 G 机器中添加对任意数据结构的支持。这包括在核心语言中引入新的构造器和模式匹配表达式，对 G 机器的数据结构和指令集进行扩展，以及修改评估器和编译器。您还学会了如何实现新的指令的状态转换规则，如何修改编译器以处理新的语言特性，以及如何通过程序转换技术解决编译器的限制。

这些知识对于理解函数式语言的实现和编译器的设计非常重要。它展示了如何在解释器和编译器中支持复杂的数据结构和模式匹配，这是函数式编程语言的重要特性。在实际的编译器中，类似的技术被用于支持高级的语言特性，如代数数据类型、模式匹配、类型推导等。

通过深入理解这些概念，您将能够更好地掌握函数式编程语言的原理，并将这些知识应用到实际的编程和系统开发中。
 #  
 Thought for 10 seconds
**概览**

本节（**3.9 Mark 7: 进一步的改进**）讨论了如何改进 G 机器（G-machine），使其在处理算术运算时更加高效。之前的 Mark 6 版本已经能够执行基本的算术操作，但是每次算术运算都会在堆（heap）中创建和访问节点，这在实际机器上是比较昂贵的操作。

为了解决这个问题，作者引入了一个新的组件 **V 栈（V-stack）**，用于存储计算过程中的中间数值。通过将数值直接存储在 V 栈中，而不是堆中，我们可以减少对堆的访问，提高程序的执行效率。

主要内容包括：

- **现有问题的分析**：即使在 Mark 6 机器中，简单的算术表达式仍然会频繁地访问堆，导致性能问题。
- **引入 V 栈**：通过在机器状态中添加一个新的 V 栈组件，直接在栈中存储数值，避免了不必要的堆操作。
- **指令集的修改**：添加了新的指令，如 Pushbasic、Mkint、Get 等，并修改了算术指令，使其在 V 栈上操作。
- **示例分析**：通过具体的示例程序，如 main = 3 + 4 * 5 和阶乘函数 fac，展示了新的 V 栈如何提高效率。
- **数据结构的修改**：更新了 G 机器的状态表示和相关的访问函数，以支持 V 栈。
- **编译器的修改**：引入了新的编译方案 **B 编译方案**，以及更新的 **E 编译方案** 和 **R 编译方案**，使编译器能够生成利用 V 栈的高效代码。
- **练习和思考**：提供了一系列练习，帮助读者深入理解 V 栈的实现和新编译方案的设计。
**详细解析**

### **3.9 Mark 7: 进一步的改进**

在之前的 Mark 6 机器中，我们已经能够直接使用算术指令来提高简单算术表达式的执行效率。然而，每次算术操作仍然需要在堆中创建新的节点，这在实际的机器上是一个相对昂贵的操作。

#### **现有问题的分析**

考虑以下简单的程序：

```haskell
main = 3 + 4 * 5
```

使用 Mark 6 编译器生成的代码如下：

```csharp
[Pushint 5, Pushint 4, Mul, Pushint 3, Add]
```

执行这段代码需要使用 **五个堆节点**。每次数字被推入堆栈，都会在堆中创建一个新的数字节点。

**问题**：

- **堆操作的代价高昂**：在实际机器上，创建和访问堆中的节点比在栈中操作要慢得多。
- **效率问题**：简单的算术运算需要频繁地访问堆，降低了程序的执行效率。
#### **引入 V 栈**

为了减少对堆的访问，我们可以将中间的数值直接存储在一个新的栈中，即 **V 栈（V-stack）**。

- **V 栈的作用**：用于存储计算过程中产生的中间数值，避免了将数值放入堆中。
- **优势**：**减少堆操作**：中间数值直接在栈中操作，减少了堆的访问次数。**提高效率**：在实际机器上，栈操作比堆操作要快得多。
#### **修改后的代码**

使用 Mark 7 编译器，针对上述程序生成的代码如下：

```csharp
[Pushbasic 5, Pushbasic 4, Mul, Pushbasic 3, Add, Mkint]
```

**解释**：

- **Pushbasic n**：将数值 n 推入 V 栈，而不是创建堆节点。
- **算术指令（如 Mul、Add）**：直接在 V 栈上操作，而不是在堆上操作。
- **Mkint**：将 V 栈顶的数值从 V 栈移到堆中，创建一个数字节点，并将其地址压入 S 栈。
**执行过程**：

1. **Pushbasic 5**：将 5 推入 V 栈。
2. **Pushbasic 4**：将 4 推入 V 栈。
3. **Mul**：弹出 V 栈顶的两个数值 5 和 4，计算乘积 20，并将结果 20 推入 V 栈。
4. **Pushbasic 3**：将 3 推入 V 栈。
5. **Add**：弹出 V 栈顶的两个数值 20 和 3，计算和 23，并将结果 23 推入 V 栈。
6. **Mkint**：将 V 栈顶的数值 23 从 V 栈移到堆中，创建一个数字节点，将其地址压入 S 栈。
**结果**：

- **减少了堆节点的使用**：只有在最终结果时才在堆中创建节点，减少了堆操作。
- **提高了执行效率**：大部分算术操作都在 V 栈中完成，速度更快。
#### **V 栈的工作原理示例**

##### **阶乘函数的执行**

考虑阶乘函数的定义：

```haskell
fac n = if (n == 0) 1 (n * fac (n - 1))
```

使用 Mark 7 编译器，生成的代码序列为：

```mathematica
[Pushbasic 0, Push 0, Eval, Get, Eq,
 Cond [Pushint 1, Update 1, Pop 1, Unwind]
      [Pushint 1, Push 1, Pushglobal "-", Mkap, Mkap,
       Pushglobal "fac", Mkap, Eval, Get,
       Push 0, Eval, Get, Mul, Mkint, Update 1, Pop 1, Unwind]]
```

**解释**：

- **Pushbasic 0**：将 0 推入 V 栈，用于比较。
- **Push 0**：将参数 n 的地址压入 S 栈。
- **Eval**：对参数 n 进行求值，结果是一个数字节点的地址。
- **Get**：将数字节点的值取出，推入 V 栈。
- **Eq**：比较 V 栈顶的两个数值，结果（True 或 False）推入 V 栈。
- **Cond**：根据 V 栈顶的布尔值，选择执行真分支或假分支。
**执行过程示意图**

1. **初始状态**：
- V 栈为空。
- S 栈有一个元素，指向参数 n。
2. **执行 Pushbasic 0**：
- V 栈：[0]。
3. **执行 Push 0, Eval, Get**：
- 对参数 n 求值，将其值（假设为 1）推入 V 栈。
- V 栈：[1, 0]。
4. **执行 Eq**：
- 比较 V 栈顶的两个数值 1 和 0，结果为 False（在 V 栈中表示为 1）。
- V 栈：[1]。
5. **执行 Cond**：
- 根据 V 栈顶的布尔值 1（False），选择执行假分支。
6. **执行假分支的代码**：
- 计算 fac (n - 1)，递归调用。
- 计算 n * fac (n - 1)，结果推入 V 栈。
- 使用 Mkint 将结果移到堆中，创建数字节点，地址压入 S 栈。
**优势**：

- **中间计算都在 V 栈中进行**，减少了对堆的访问。
- **递归调用时，仅在必要时访问堆**。
#### **数据结构的修改**

为了支持 V 栈，我们需要对 G 机器的状态表示进行修改。

##### **添加 V 栈到机器状态**

```haskell
type GmState = (GmOutput, GmCode, GmStack, GmDump, GmVStack, GmHeap, GmGlobals, GmStats)
```

- **GmVStack**：新的 V 栈组件，表示为整数列表。
```haskell
type GmVStack = [Int]
```

##### **访问函数的修改**

- **获取 V 栈**：
```haskell
getVStack :: GmState -> GmVStack
getVStack (o, i, stack, dump, vstack, heap, globals, stats) = vstack
```
- **设置 V 栈**：
```haskell
putVStack :: GmVStack -> GmState -> GmState
putVStack vstack' (o, i, stack, dump, vstack, heap, globals, stats)
  = (o, i, stack, dump, vstack', heap, globals, stats)
```
**练习 3.39**：

- **任务**：对其他访问函数进行相应的修改，以适应新的状态表示。
##### **修改状态显示函数**

- **修改 showState 函数**：
```haskell
showState :: GmState -> Iseq
showState s
  = iConcat [showOutput s, iNewline,
             showStack s, iNewline,
             showDump s, iNewline,
             showVStack s, iNewline,
             showInstructions (getCode s), iNewline]
```
- **添加 showVStack 函数**：
```haskell
showVStack :: GmState -> Iseq
showVStack s
  = iConcat [iStr "Vstack:[",
             iInterleave (iStr ", ") (map iNum (getVStack s)),
             iStr "]"]
```
#### **指令集的修改**

为了利用 V 栈，我们需要添加新的指令，并修改现有的指令。

##### **新的指令**

- **Pushbasic n**：将整数 `n` 推入 V 栈。**状态转换规则（3.41）**：
```less
o  Pushbasic n : i   s   d   v   h   m
=> o  i   s   d   n : v   h   m
```
- **Mkint**：将 V 栈顶的整数移到堆中，创建数字节点，地址压入 S 栈。**状态转换规则（3.43）**：
```less
o  Mkint : i   s   d   n : v   h   m
=> o  i   a : s   d   v   h[a : NNum n]   m
```
- **Mkbool**：类似于 `Mkint`，但创建的是布尔值的构造器节点。**状态转换规则（3.42）**：
```less
o  Mkbool : i   s   d   t : v   h   m
=> o  i   a : s   d   v   h[a : NConstr t []]   m
```
**其中**：t 为 1（表示 False）或 2（表示 True）。
- **Get**：将 S 栈顶的节点值取出，推入 V 栈。**对于数字节点（3.45）**：
```less
o  Get : i   a : s   d   v   h[a : NNum n]   m
=> o  i   s   d   n : v   h   m
```
**对于构造器节点（3.44）**：
```less
o  Get : i   a : s   d   v   h[a : NConstr t []]   m
=> o  i   s   d   t : v   h   m
```
##### **修改算术指令**

- **算术指令（如 Add、Sub、Mul、Div）**：**状态转换规则（3.39）**：
```less
o  op : i   s   d   n0 : n1 : v   h   m
=> o  i   s   d   n0 op n1 : v   h   m
```
**解释**：从 V 栈弹出两个数值 n0 和 n1，计算结果，推入 V 栈。
- **一元算术指令（如 Neg）**：**状态转换规则（3.40）**：
```java
o  Neg : i   s   d   n : v   h   m
=> o  i   s   d   (-n) : v   h   m
```
##### **修改条件指令**

- **Cond t f**：根据 V 栈顶的布尔值，选择执行 `t` 或 `f` 分支。**V 栈顶为 2（True）（3.46）**：
```less
o  Cond t f : i   s   d   2 : v   h   m
=> o  t ++ i   s   d   v   h   m
```
**V 栈顶为 1（False）（3.47）**：
```less
o  Cond t f : i   s   d   1 : v   h   m
=> o  f ++ i   s   d   v   h   m
```
##### **练习 3.40**：

- **任务**：扩展指令数据类型，添加新的指令。重定义 showInstruction 函数，支持新的指令显示。实现新的指令的状态转换规则。修改 dispatch 函数，处理新的指令。
#### **编译器的修改**

为了生成利用 V 栈的新代码，我们需要修改编译器，添加新的编译方案。

##### **初始化 V 栈**

在 `compile` 函数中，需要将 V 栈初始化为空列表：

```haskell
compile :: CoreProgram -> GmState
compile program
  = ([], initialCode, [], [], [], heap, globals, statInitial)
  where (heap, globals) = buildInitialHeap program
```

##### **更新编译器的初始堆**

在 `buildInitialHeap` 中，编译器需要编译所有的超级组合子，包括预定义的原语函数。

- **添加原语函数的定义**：
```haskell
primitives :: [(Name, [Name], CoreExpr)]
primitives = [("+", ["x", "y"], EAp (EAp (EVar "+") (EVar "x")) (EVar "y")),
              ("-", ["x", "y"], EAp (EAp (EVar "-") (EVar "x")) (EVar "y")),
              ("*", ["x", "y"], EAp (EAp (EVar "*") (EVar "x")) (EVar "y")),
              ("/", ["x", "y"], EAp (EAp (EVar "/") (EVar "x")) (EVar "y")),
              ("negate", ["x"], EAp (EVar "negate") (EVar "x")),
              ("==", ["x", "y"], EAp (EAp (EVar "==") (EVar "x")) (EVar "y")),
              ("~=", ["x", "y"], EAp (EAp (EVar "~=") (EVar "x")) (EVar "y")),
              (">=", ["x", "y"], EAp (EAp (EVar ">=") (EVar "x")) (EVar "y")),
              (">", ["x", "y"], EAp (EAp (EVar ">") (EVar "x")) (EVar "y")),
              ("<=", ["x", "y"], EAp (EAp (EVar "<=") (EVar "x")) (EVar "y")),
              ("<", ["x", "y"], EAp (EAp (EVar "<") (EVar "x")) (EVar "y")),
              ("if", ["c", "t", "f"], EAp (EAp (EAp (EVar "if") (EVar "c")) (EVar "t")) (EVar "f")),
              ("True", [], EConstr 2 0),
              ("False", [], EConstr 1 0)]
```
- **解释**：将原语函数定义为超级组合子，让编译器为它们生成代码。这样可以利用编译器的新功能，生成更高效的代码。
##### **引入 B 编译方案**

为了在编译时利用 V 栈，我们引入了新的 **B 编译方案**。

- **B 编译方案的目标**：编译需要求值到整数或布尔值的表达式，将结果留在 V 栈上。
- **B 编译方案的定义（图 3.18）**：**整数常量**：
```haskell
B[[i]] ρ = [Pushbasic i]
```
**let 表达式**：
```haskell
B[[let x1 = e1; ...; xn = en in e]] ρ
  = C[[e1]] ρ+0 ++ ... ++ C[[en]] ρ+(n−1) ++
    B[[e]] ρ' ++ [Pop n]
  where ρ' = ρ+n[x1 → n−1, ..., xn → 0]
```
**算术和比较表达式**：
```haskell
B[[e0 op e1]] ρ = B[[e1]] ρ ++ B[[e0]] ρ ++ [Op]
```
其中 Op 是对应的算术或比较指令。**negate 表达式**：
```haskell
B[[negate e]] ρ = B[[e]] ρ ++ [Neg]
```
**条件表达式**：
```haskell
B[[if e0 e1 e2]] ρ = B[[e0]] ρ ++ [Cond (B[[e1]] ρ) (B[[e2]] ρ)]
```
**默认情况**：
```haskell
B[[e]] ρ = E[[e]] ρ ++ [Get]
```
使用 E 编译方案编译表达式，然后使用 Get 将结果取到 V 栈。
- **B 编译方案的上下文传播**：**如果 let 或 letrec 表达式在 B 严格上下文中**，则其主体 e 也在 B 严格上下文中。**条件表达式 if e0 e1 e2**：e0、e1 和 e2 都在 B 严格上下文中。**算术和比较表达式的操作数**：如果表达式 e0 op e1 在 B 严格上下文中，则 e0 和 e1 也在 B 严格上下文中。**negate e**：如果 negate e 在 B 严格上下文中，则 e 也在 B 严格上下文中。
- **B 编译方案的应用**：用于编译需要求值到整数或布尔值的表达式，结果保存在 V 栈上。
**练习 3.41**：

- **任务**：实现 B 编译方案。
##### **修改 E 编译方案**

E 编译方案也需要更新，以利用 B 编译方案。

- **E 编译方案的定义（图 3.19）**：**整数常量**：
```haskell
E[[i]] ρ = [Pushint i]
```
**let 表达式**：
```haskell
E[[let x1 = e1; ...; xn = en in e]] ρ
  = C[[e1]] ρ+0 ++ ... ++ C[[en]] ρ+(n−1) ++
    E[[e]] ρ' ++ [Slide n]
  where ρ' = ρ+n[x1 → n−1, ..., xn → 0]
```
**case 表达式**：
```haskell
E[[case e of alts]] ρ = E[[e]] ρ ++ [Casejump DE[[alts]] ρ]
```
**算术和比较表达式**：
```haskell
E[[e0 op e1]] ρ = B[[e0 op e1]] ρ ++ [Mkint]
```
对于比较表达式，使用 [Mkbool]。**negate e**：
```haskell
E[[negate e]] ρ = B[[negate e]] ρ ++ [Mkint]
```
**条件表达式**：
```haskell
E[[if e0 e1 e2]] ρ = B[[e0]] ρ ++ [Cond (E[[e1]] ρ) (E[[e2]] ρ)]
```
**默认情况**：
```haskell
E[[e]] ρ = C[[e]] ρ ++ [Eval]
```
- **E 编译方案的上下文传播**：在 E 编译方案中，如果一个表达式需要求值到 WHNF，并且是整数或布尔值，则使用 B 编译方案。
**练习 3.42**：

- **任务**：实现新的 E 编译方案。
##### **修改 R 编译方案**

R 编译方案也需要更新，以利用新的编译方案。

- **R 编译方案的定义（图 3.20）**：**let 表达式**：
```haskell
R[[let x1 = e1; ...; xn = en in e]] ρ d
  = C[[e1]] ρ+0 ++ ... ++ C[[en]] ρ+(n−1) ++
    R[[e]] ρ' (n + d)
  where ρ' = ρ+n[x1 → n−1, ..., xn → 0]
```
**条件表达式**：
```haskell
R[[if e0 e1 e2]] ρ d = B[[e0]] ρ ++ [Cond (R[[e1]] ρ d) (R[[e2]] ρ d)]
```
**case 表达式**：
```haskell
R[[case e of alts]] ρ d = E[[e]] ρ ++ [Casejump DR[[alts]] ρ d]
```
**默认情况**：
```haskell
R[[e]] ρ d = E[[e]] ρ ++ [Update d, Pop d, Unwind]
```
- **R 编译方案的上下文传播**：**let 或 letrec 表达式**：其主体 e 也在 R 严格上下文中。**条件表达式 if e0 e1 e2**：e1 和 e2 在 R 严格上下文中。e0 在 B 严格上下文中。
**练习 3.43**：

- **任务**：实现新的 R 编译方案。
#### **进一步的改进和练习**

##### **Eval 指令的修改**

在 Mark 7 机器中，`Eval` 指令没有将 V 栈保存到 Dump 中。这与 [Peyton Jones 1987] 中描述的 G 机器有所不同。

- **新的 Eval 状态转换规则（3.48）**：
```less
o  Eval : i   a : s   d   v   h   m
=> o  [Unwind]   [a]   (i, s, v) : d   []   h   m
```
- **解释**：将当前的指令序列 i、S 栈 s 和 V 栈 v 一起保存到 Dump 中。将 V 栈清空。
**练习 3.44**：

- **任务**：实现新的 Eval 转换规则。找出需要修改的其他指令，以适应新的 Eval 转换规则。
##### **优化布尔运算**

**练习 3.45**：

- **任务**：修改编译规则，以优化布尔运算符 `&`、`|` 和 `not`。
- **提示**：可以将布尔运算符也编译为在 V 栈上操作的指令。定义新的指令，如 And、Or、Not，并修改编译器和状态转换规则。
##### **添加 Return 指令**

**练习 3.46**：

- **任务**：添加一个 `Return` 指令，状态转换规则为（3.49）：
```css
o  [Return]   [a0, ..., ak]   (i, s) : d   v   h   m
=> o  i   ak : s   d   v   h   m
```
- **修改 compileR**：在知道堆栈顶的项已经是 WHNF 时，使用 `Return` 指令代替 `Unwind`。
##### **添加 UpdateInt 和 UpdateBool 指令**

**练习 3.47**：

- **任务**：定义 UpdateInt n 指令，其效果与 [Mkint, Update n] 相同。实现对应的状态转换规则。修改 compileR，生成这些新的指令。
- **思考**：为什么新的指令比原来的指令序列更好？**提示**：减少了指令数量，提高了执行效率。
**全面详尽的总结**

在这一节中，我们通过引入 **V 栈（V-stack）**，对 G 机器进行了进一步的改进。主要目标是减少对堆的访问，提高算术运算的执行效率。

**主要内容回顾**：

1. **问题的提出**：
- **堆操作的开销**：在之前的 G 机器版本中，每次算术运算都需要在堆中创建和访问节点，导致性能下降。
2. **引入 V 栈**：
- **V 栈的作用**：用于存储计算过程中的中间数值，避免频繁的堆操作。
- **数据结构的修改**：在 G 机器的状态中添加 V 栈组件，修改相关的访问函数和状态显示函数。
3. **指令集的修改**：
- **新的指令**：如 Pushbasic、Mkint、Mkbool、Get、Cond 等，支持在 V 栈上操作。
- **修改算术指令**：算术和比较指令直接在 V 栈上操作，减少了堆的访问。
4. **编译器的修改**：
- **引入 B 编译方案**：用于编译需要求值到整数或布尔值的表达式，结果保存在 V 栈上。
- **修改 E 和 R 编译方案**：利用 B 编译方案，生成更高效的代码。
- **编译器的初始化**：将原语函数定义为超级组合子，让编译器为它们生成代码。
5. **示例分析**：
- **简单算术表达式**：展示了如何利用 V 栈执行 main = 3 + 4 * 5，减少了堆操作。
- **阶乘函数**：详细分析了使用 V 栈执行递归函数的过程。
6. **进一步的改进**：
- **修改 Eval 指令**：新的状态转换规则，更好地处理 V 栈。
- **优化布尔运算**：提出了如何优化布尔运算符的编译和执行。
7. **练习和思考**：
- 提供了一系列练习，帮助读者深入理解 V 栈的实现、新编译方案的设计，以及如何进一步优化 G 机器。
**重要的概念和技巧**：

- **V 栈的引入**：通过在栈中直接操作数值，提高了算术运算的效率，减少了堆的访问。
- **编译方案的扩展**：引入了新的 B 编译方案，更新了 E 和 R 编译方案，实现了更高效的代码生成。
- **上下文传播**：在编译过程中，严格上下文和 B 严格上下文的传播，决定了使用哪个编译方案。
- **指令集的设计**：新的指令集支持在 V 栈上操作，体现了设计抽象机器时的灵活性和优化思路。
**总结**

通过本节的学习，您了解了如何通过引入 V 栈，进一步优化 G 机器的性能。我们从问题的分析出发，提出了改进方案，对数据结构、指令集、评估器和编译器进行了全面的修改。通过具体的示例，展示了新的设计如何提高程序的执行效率。

在实际的编译器和抽象机器的设计中，类似的优化思路广泛存在。通过减少不必要的内存访问，利用更高效的数据结构和操作，可以显著提高程序的性能。

这些知识对于理解函数式语言的实现和编译器的优化策略非常重要。在下一章中，作者将介绍 TIM（Transputer Implementation Machine），进一步探讨抽象机器的设计和实现。
 #  
 Thought for 9 seconds
**概览**

您提供的内容是来自 Simon Peyton Jones 的《Implementing Functional Languages: A Tutorial》第四章，题为 **"TIM: The Three Instruction Machine"**。这一章介绍了一种新的抽象机器，称为 **TIM（Three Instruction Machine）**，即三指令机器。

TIM 看起来与我们之前看到的 G 机器（G-machine）和模板实例化机器（Template Instantiation Machine）非常不同。然而，通过一系列相对简单的步骤，我们可以将 G 机器转换为 TIM。这一章的目标是描述这些步骤，从而展示 TIM 的工作原理，定义一个完整的最小化 TIM 编译器和评估器，然后开发一系列改进和优化。

TIM 由 Fairbairn 和 Wray 发明，他们的原始论文值得阅读。然而，本章的发展超出了他们的工作，包括一些新的想法，这些想法主要来自 Guy Argo。

**详细解析**

### **4.1 背景：TIM 的工作原理**

为了理解 TIM 的工作原理，让我们从一个示例函数定义开始：

```haskell
f x y = g E1 E2
```

其中 `E1` 和 `E2` 是任意（可能复杂的）表达式，`g` 是另一个函数。

在模板实例化机器和 G 机器中，这个函数的求值会执行如下的简化（reduction）：

```python
       @                 reduces to                @
      / \                                        / \
     @   y                                      y   @
    / \                                        / \
   f   x                                      g   E2
                                           / \
                                          E1
```

在这个图中，`E1` 和 `E2` 是表达式的图（graph）。例如，如果 `E1` 是 `(x + y) * (x - y)`，那么 `g` 的第一个参数就是 `(x + y) * (x - y)` 的图。这意味着我们需要在堆（heap）中构建这个表达式的图，这可能是非常耗费资源的，因为 `g` 可能根本不使用它的第一个参数。

我们希望找到一种方法，限制为函数参数构建图所需的工作量。

#### **4.1.1 扁平化（Flattening）**

**步骤 1**：为了减少为函数参数构建图的工作量，我们可以将 `f` 的定义替换为以下新的定义：

```haskell
f x y = g (c1 x y) (c2 x y)
c1 x y = E1
c2 x y = E2
```

我们引入了两个辅助函数 `c1` 和 `c2`。这个定义显然与原始定义等价，但是不管 `E1` 多大多复杂，在 `f` 的化简过程中唯一需要做的工作就是构建 `(c1 x y)` 的图。

**优点**：

- 对于 G 机器实现来说，还有一个额外的好处。
- 在原始定义中，E1 会由 C 编译方案编译；在编译算术表达式时，无法利用 E 编译方案中的优化。
- 但在新的定义中，E1 现在是一个超级组合子（supercombinator）的右侧，因此所有这些优化都适用。
- 我们可以更高效地计算 (x + y) * (x - y)。
**递归扁平化**：

- 当然，E1 和 E2 自身可能包含大型表达式，这些表达式将由 C 编译方案编译（例如，如果 E2 是 (h E3 E4)）。
- 因此，我们必须对 c1 和 c2 的右侧再次应用这种转换。
- 结果是一个 **扁平化的程序**（flattened program），因为没有表达式具有嵌套结构。
#### **4.1.2 元组化（Tupling）**

**步骤 2**：接下来，我们观察到 `c1` 和 `c2` 都应用于 `x` 和 `y`，因此我们必须在调用 `g` 之前构建 `(c1 x y)` 和 `(c2 x y)` 的图。

如果 `c1` 和 `c2` 有很多参数，而不仅仅是两个，那么这些图可能会变得相当大。由于这两个图非常相似，我们自然会想，能否让这些参数图共享一些公共部分，以避免重复，从而减少堆的分配。

我们可以通过第二个转换来表达这个想法：

```haskell
f x y = let tup = (x, y)
        in g (c1 tup) (c2 tup)
c1 (x, y) = E1
c2 (x, y) = E2
```

**想法**：

- f 首先将它的参数打包成一个元组，然后将这个单一的元组传递给 c1 和 c2。
- 这样，f 的化简过程如下：
```python
      @             reduces to                  @
     / \                                       / \
    @   y                                     y   /@
   / \                                       / @
  f   x                                     g   c2
                                         / \
                                        c1
                                        |
                                      tup
                                      / \
                                     x   y
```

- 在这个图中，箭头指向的 tup 包含了 x 和 y。
- 通过这种方式，我们只需要构建一个元组 tup，而不是为每个 (c1 x y) 和 (c2 x y) 构建单独的图。
#### **4.1.3 去除主干（Spinelessness）**

**步骤 3**：观察上面的图，你会发现主干（spine）指向的参数总是形如 `(c tup)`，其中 `c` 是某个超级组合子，`tup` 是元组。

在化简过程中，我们在堆栈上构建一个指向这些参数的指针栈。但由于它们现在都具有相同的形式，我们可以直接将参数本身（即它们的根）压入栈中！

因此，在 `f` 化简之后，堆栈看起来像这样：

```lua
Stack:
|----------------|
| c2             | ----> tup
|----------------|
| c1             |
|----------------|
```

- 堆栈中的每个项现在都是一个 **代码指针** 和一个 **元组指针** 的组合。你可以将这个组合视为一个 **闭包（closure）**，即定义了一个函数（代码指针）和它的环境（元组指针）。
- 一个这样的闭包的元组被称为一个 **帧（frame）**。
- 指向一个帧的指针被称为 **帧指针（frame pointer）**。
- 注意，现在堆中没有主干了；堆栈就是正在求值的表达式的主干。**TIM 是一个无主干的机器（spineless machine）**。
#### **4.1.4 一个示例**

现在是时候看一个 TIM 程序如何工作的示例了。考虑以下函数定义：

```haskell
compose2 f g x = f (g x x)
```

**扁平化后的形式**：

```haskell
compose2 f g x = f (c1 g x)
c1 g x = g x x
```

**TIM 的执行过程**：

1. **进入 compose2 时**，它的三个参数将位于堆栈的顶部，如下所示：
```lua
Stack:
|----------------|
| x-code | x-frm |  -- x
|----------------|
| g-code | g-frm |  -- g
|----------------|
| f-code | f-frm |  -- f
|----------------|
```
2. **构建帧**：
- 我们首先需要将这些参数的闭包形成一个帧，并将当前的 **帧指针（frame pointer）** 指向它。
- 我们可以使用指令：
```mathematica
Take 3
```
- 执行 `Take 3` 后，机器的状态如下：
```lua
Frame pointer --> Frame:
|----------------|
| f-code | f-frm |  -- f
|----------------|
| g-code | g-frm |  -- g
|----------------|
| x-code | x-frm |  -- x
|----------------|
```
- 堆栈现在为空。
3. **准备 f 的参数**：
- `f` 只有一个参数，即 `(g x x)`。我们需要将其闭包压入堆栈。
- 由于这个闭包的帧指针就是当前的帧指针，因此指令只需要提供一个代码标签：
```mathematica
Push (Label "c1")
```
- 这会将 `(c1, 当前帧指针)` 这个闭包压入堆栈。
4. **进入 f**：
- `f` 是 `compose2` 的参数，而不是全局的超级组合子，因此它在当前帧中表示为一个闭包。
- 我们需要获取这个闭包，将它的帧指针加载到帧指针寄存器中，将它的代码指针加载到程序计数器中。
- 我们可以使用指令：
```mathematica
Enter (Arg 1)  -- f 是参数 1
```
- 执行 `Enter (Arg 1)` 后，机器的状态如下：
```lua
Program counter: f-code
Frame pointer: f-frm
Stack:
|----------------|
| c1 | 当前帧指针 |  -- 参数 (g x x)
|----------------|
```
5. **处理 c1**：
- 当需要 `(g x x)` 的闭包时，它将通过 `Enter` 指令进入，程序计数器将指向 `c1`，帧指针指向最初包含 `f`、`g` 和 `x` 的帧。
- 在这个时候，我们需要为 `g` 准备参数，即 `x` 和 `x`，然后进入 `g`。
- `c1` 的代码可以是：
```mathematica
c1:
  Push (Arg 3)  -- x 是参数 3
  Push (Arg 3)  -- 再次是 x
  Enter (Arg 2) -- g 是参数 2
```
- `Push (Arg 3)` 指令从当前帧中获取 `x` 的闭包，并将其压入堆栈。
- 然后 `Enter (Arg 2)` 指令将 `g` 应用于现在在堆栈上的参数。
#### **4.1.5 使用状态转换规则定义机器**

现在，我们已经看到了一些 TIM 程序的执行，让我们使用状态转换规则来精确定义每个指令的效果。

首先，我们必须定义机器的状态。它是一个五元组：

```arduino
(instructions, frame pointer, stack, heap, code store)
```

或简写为 `(i, f, s, h, c)`。其中：

- **instructions**：当前的指令序列。
- **frame pointer**：当前的帧指针。
- **stack**：堆栈，用于存储闭包。
- **heap**：堆，存储帧。
- **code store**：代码存储，包含所有的代码片段，每个都有一个标签。
现在，我们为每个指令开发状态转换规则。

##### **Take n 指令**

`Take n` 将堆栈顶部的 `n` 个元素组成一个新的帧，并将当前的帧指针指向它。

**状态转换规则（4.1）**：

```ruby
Take n : i   f   c1 : ... : cn : s   h   c
=> i   f'  s   h[f' : [c1, ..., cn]]   c
```

- **解释**：**指令**：Take n**堆栈**：堆栈顶部有 n 个闭包 c1 到 cn。**操作**：创建一个新的帧 f'，包含这些闭包。将 f' 添加到堆 h 中。将当前的帧指针 f 更新为 f'。从堆栈中弹出 n 个闭包。
##### **Push 指令**

`Push` 指令有多个寻址模式（addressing modes）。我们首先定义一个重要的关系：

**Push / Enter 关系**：

- **描述**：如果指令 Push arg 将一个闭包 (i, f) 压入堆栈，那么 Enter arg 将加载 i 到程序计数器，将 f 加载到当前的帧指针中。
**寻址模式**：

1. **Push (Arg k)**：从当前帧中获取第 `k` 个闭包，压入堆栈。**状态转换规则（4.2）**：
```less
Push (Arg k) : i   f   s   h[f : [(i1, f1), ..., (ik, fk), ..., (in, fn)]]   c
=> i   f   (ik, fk) : s   h   c
```

- **解释**：**指令**：Push (Arg k)**当前帧**：f，包含闭包列表 [(i1, f1), ..., (ik, fk), ..., (in, fn)]。**操作**：从当前帧中获取第 k 个闭包 (ik, fk)。将其压入堆栈。
2. **Push (Label l)**：从代码存储中获取标签 `l` 对应的代码，构建一个闭包 `(i', f)`，将其压入堆栈。**状态转换规则（4.3）**：
```css
Push (Label l) : i   f   s   h   c[l : i']
=> i   f   (i', f) : s   h   c
```

- **解释**：**指令**：Push (Label l)**代码存储**：c，包含标签 l 对应的代码 i'。**操作**：构建闭包 (i', f)，其中 i' 是代码指针，f 是当前帧指针。将闭包压入堆栈。
3. **Push (Code i')**：指令自身包含代码序列 `i'`，构建闭包 `(i', f)`，压入堆栈。**状态转换规则（4.4）**：
```css
Push (Code i') : i   f   s   h   c
=> i   f   (i', f) : s   h   c
```

- **解释**：**指令**：Push (Code i')**操作**：构建闭包 (i', f)。将其压入堆栈。
- **备注**：这种方式避免了必须为每个代码片段命名标签的麻烦。
4. **Push (IntConst n)**：处理整数常量。**状态转换规则（4.5）**：
```java
Push (IntConst n) : i   f   s   h   c
=> i   f   (intCode, n) : s   h   c
```

- **解释**：**指令**：Push (IntConst n)**操作**：构建闭包 (intCode, n)，其中 intCode 是整数闭包的代码序列，n 是整数值，放在帧指针的位置。将闭包压入堆栈。
- **备注**：我们将整数值存储在帧指针的位置，这是假设整数的大小不超过帧指针。intCode 是整数闭包的代码序列，暂时可以设为空序列 []。
##### **Enter 指令**

`Enter` 指令有相同的寻址模式，根据 `Push` / `Enter` 关系，我们可以定义它们的状态转换规则。

1. **Enter (Label l)**：**状态转换规则（4.6）**：
```css
[Enter (Label l)]   f   s   h   c[l : i]
=> i   f   s   h   c
```

- **解释**：**操作**：将代码存储中标签 l 对应的代码 i 加载到程序计数器。保持帧指针不变。
2. **Enter (Arg k)**：**状态转换规则（4.7）**：
```r
[Enter (Arg k)]   f   s   h[f : [(i1, f1), ..., (ik, fk), ..., (in, fn)]]   c
=> ik   fk   s   h   c
```

- **解释**：**操作**：从当前帧中获取第 k 个闭包 (ik, fk)。将代码指针 ik 加载到程序计数器。将帧指针 fk 加载为当前的帧指针。
3. **Enter (Code i')**：**状态转换规则（4.8）**：
```vbnet
[Enter (Code i')]   f   s   h   c
=> i'   f   s   h   c
```

- **解释**：**操作**：将代码指针 i' 加载到程序计数器。保持帧指针不变。
4. **Enter (IntConst n)**：**状态转换规则（4.9）**：
```r
[Enter (IntConst n)]   f   s   h   c
=> intCode   n   s   h   c
```

- **解释**：**操作**：将整数闭包的代码 intCode 加载到程序计数器。将整数值 n 加载为当前的帧指针（用于存储整数值）。
#### **4.1.6 编译**

现在，我们已经精确定义了每个 TIM 指令的行为。接下来，我们需要描述如何将程序转换为 TIM 指令。我们使用一组编译方案，就像之前一样。

##### **编译方案**

- **超级组合子（supercombinator）** 使用 **SC 编译方案**（见 **图 4.1**）。**SC 编译方案**：
```haskell
SC[[f x1 ... xn = e]] ρ = Take n : R[[e]] ρ[x1 → Arg 1, ..., xn → Arg n]
```
**解释**：SC 将超级组合子编译为一个 Take n 指令，然后调用 R 编译方案。环境 ρ 增加了对参数的绑定，每个参数绑定到 Arg k。
- **R 编译方案**：**目标**：生成 TIM 代码，将表达式 `e` 应用于堆栈上的参数。**定义**：
```haskell
R[[e1 e2]] ρ = Push (A[[e2]] ρ) : R[[e1]] ρ
R[[a]] ρ = Enter (A[[a]] ρ)  -- 其中 a 是整数、变量或超级组合子
```
**解释**：如果表达式是应用 e1 e2，则首先编译 e2，将其压入堆栈，然后递归编译 e1。如果表达式是一个整数、变量或超级组合子，则直接进入它。
- **A 编译方案**：**目标**：为表达式 `e` 生成 TIM 的寻址模式。**定义**：
```haskell
A[[x]] ρ = ρ x            -- 如果 x 被 ρ 绑定
A[[n]] ρ = IntConst n     -- 如果 n 是整数
A[[e]] ρ = Code (R[[e]] ρ)  -- 其他情况
```
**解释**：如果表达式是变量，在环境中查找它的绑定。如果是整数，使用 IntConst n。其他情况下，将表达式编译为代码序列，并使用 Code 寻址模式。
**编译过程的特点**：

- **扁平化的实现**：通过 R 和 A 编译方案，“即时地”执行了扁平化过程。
- **递归**：编译器会递归地编译表达式，直到遇到基本的元素（整数、变量、超级组合子）。
- **避免了更新**：到目前为止，没有提到更新（updating），因为在无主干的机器中，没有主干节点需要更新。
#### **4.1.7 更新**

- **问题**：由于现在主干已经消失，可能会出现共享的参数被多次求值的情况，即工作被重复。
- **必要性**：正确地执行更新是无主干实现的薄弱环节。如果不执行更新，可能会导致无限量的工作重复。
- **解决**：我们将在后续的 **4.5 节**中讨论更新的问题。
**全面详尽的总结**

本节介绍了 TIM（Three Instruction Machine，三指令机器），并展示了它如何通过一系列步骤从 G 机器转换而来。

**主要内容回顾**：

1. **问题的提出**：
- 在 G 机器和模板实例化机器中，函数调用需要在堆中构建参数的图，这可能是耗费资源且低效的，特别是当参数是复杂表达式时。
- 可能会出现为函数参数构建大量图的情况，而这些图可能不会被实际使用。
2. **扁平化（Flattening）**：
- **目标**：减少为函数参数构建图的工作量。
- **方法**：将函数的复杂参数提取为辅助函数（超级组合子），使得在函数调用时，只需要构建这些辅助函数的图。
- **结果**：优化了编译过程，复杂表达式的求值可以利用编译器的优化策略，如 E 编译方案。
3. **元组化（Tupling）**：
- **目标**：减少重复的参数图的构建。
- **方法**：将函数的参数打包成一个元组，传递给辅助函数，从而共享公共部分，减少堆的分配。
4. **去除主干（Spinelessness）**：
- **概念**：在 TIM 中，堆中没有主干，堆栈成为表达式求值的主干。
- **实现**：将参数的闭包直接压入堆栈，使用帧来组织环境。
5. **TIM 的示例**：
- **函数 compose2**：通过详细的执行过程，展示了 TIM 如何处理函数调用、参数传递和闭包的构建。
6. **状态转换规则的定义**：
- **机器状态**：定义了 TIM 的状态组成，包括指令序列、帧指针、堆栈、堆和代码存储。
- **指令的状态转换规则**：精确定义了 Take、Push 和 Enter 指令的行为，以及不同寻址模式的处理。
7. **编译器的设计**：
- **编译方案**：使用 SC、R 和 A 编译方案，将程序转换为 TIM 指令。
- **即时扁平化**：通过编译方案的设计，实现了表达式的即时扁平化，避免了构建复杂的嵌套图。
8. **更新的问题**：
- **挑战**：无主干的实现可能导致共享的参数被多次求值，需要解决更新的问题。
- **后续讨论**：将在后续章节中详细讨论如何正确地实现更新。
**重要的概念和技巧**：

- **闭包（Closure）**：由代码指针和帧指针组成，表示一个函数及其环境。
- **帧（Frame）**：由一组闭包组成，表示函数的环境。
- **寻址模式（Addressing Modes）**：TIM 中指令可以使用不同的寻址模式，如 Arg、Label、Code、IntConst。
- **Push / Enter 关系**：Push 指令将闭包压入堆栈，Enter 指令根据相同的寻址模式进入闭包的代码。
- **即时扁平化**：在编译过程中，通过编译方案的设计，动态地将复杂的表达式扁平化。
**总结**

通过本节的学习，您了解了 TIM 的基本工作原理，以及如何从 G 机器转换为 TIM。TIM 通过去除主干、使用帧和闭包来组织环境，提高了执行效率。编译器的设计使用了编译方案，实现了即时的扁平化和优化。

TIM 的独特之处在于其三指令的核心（尽管实际实现中会有更多的指令和寻址模式），以及无主干的设计，这为函数式语言的实现提供了新的思路。

在后续的章节中，您将看到 TIM 如何进一步处理更新、算术操作、数据结构和模式匹配，以及如何优化 TIM 的实现。
 #  
 Thought for 1m 13s
**概览**

本节（**4.2 Mark 1: 一个最小的 TIM**）致力于开发一个最小但完整的 TIM（Three Instruction Machine，三指令机器）实现。TIM 是一种用于实现函数式编程语言的抽象机器，具有简单的指令集和执行模型。

在这一节中，我们将构建一个不包含算术运算、数据结构或更新（updates）的最小 TIM 实现。这些特性将在后续章节中添加。

主要内容包括：

- TIM 的总体结构，与之前的模板实例化解释器类似。
- TIM 的数据类型定义，包括指令、寻址模式、机器状态等。
- 编译器的实现，如何将程序编译为 TIM 指令。
- 评估器（解释器）的实现，如何执行 TIM 指令。
- 输出结果的显示，如何格式化并显示机器的状态和执行结果。
- 一些练习，帮助读者巩固对 TIM 的理解。
- 关于垃圾收集的简要讨论。
**详细解析**

### **4.2 Mark 1: 一个最小的 TIM**

在本节中，我们将从头开始，逐步构建一个最小化的 TIM 实现。TIM 是一种抽象机器，旨在以简洁的方式执行函数式编程语言的代码。TIM 的指令集非常简单，主要包括 `Take`、`Enter` 和 `Push` 三条指令。

#### **4.2.1 总体结构**

TIM 的总体结构与之前的模板实例化解释器类似。我们将定义一个 `run` 函数，它是多个函数的组合：

```haskell
runProg = showResults . eval . compile . parse
```

- **parse**：将源代码解析为抽象语法树（AST）。
- **compile**：将 AST 编译为 TIM 的初始状态。
- **eval**：执行 TIM 指令，生成一系列机器状态。
- **showResults**：将最终的机器状态转换为可读的输出。
此外，我们还提供了 `fullRun` 函数，可以显示所有的中间状态，便于调试和理解程序的执行过程：

```haskell
fullRun = showFullResults . eval . compile . parse
```

需要注意的是，我们需要导入语言模块，以便使用核心语言的定义和解析功能。

#### **4.2.2 数据类型定义**

为了实现 TIM，我们需要定义一些数据类型。这些数据类型包括指令、寻址模式、机器状态、堆栈、堆、代码存储等。

##### **TIM 指令**

TIM 的指令集非常简单，包括：

- **Take n**：从堆栈顶部取出 n 个元素，组成一个新的帧（frame），并更新当前的帧指针。
- **Enter am**：根据寻址模式 am，进入相应的代码和帧。
- **Push am**：根据寻址模式 am，将一个闭包压入堆栈。
对应的指令数据类型定义如下：

```haskell
data Instruction = Take Int
                 | Enter TimAMode
                 | Push TimAMode
```

##### **寻址模式**

寻址模式（Addressing Mode）用于在指令中指定操作数的位置或获取方式。TIM 的寻址模式包括：

- **Arg Int**：从当前帧中获取第 n 个参数。
- **Label [Char]**：从代码存储中获取标签为 l 的代码序列。
- **Code [Instruction]**：指令自身包含代码序列 il。
- **IntConst Int**：整数常量。
对应的寻址模式数据类型定义如下：

```haskell
data TimAMode = Arg Int
              | Label [Char]
              | Code [Instruction]
              | IntConst Int
```

##### **TIM 机器状态**

TIM 机器的状态由以下几个部分组成：

- **指令流**：当前的指令序列，表示为 [Instruction]。
- **帧指针**：指向当前帧的指针，类型为 FramePtr。
- **堆栈**：存储闭包的堆栈，类型为 TimStack。
- **值栈**：用于存储数值的栈，目前未使用，类型为 TimValueStack。
- **转储（Dump）**：用于保存中间状态的栈，目前未使用，类型为 TimDump。
- **堆**：存储帧的堆，类型为 TimHeap。
- **代码存储**：存储已编译的代码段，类型为 CodeStore。
- **统计信息**：用于记录执行过程中的统计数据，类型为 TimStats。
对应的状态类型定义如下：

```haskell
type TimState = ([Instruction], -- 当前的指令序列
                 FramePtr,       -- 当前帧指针
                 TimStack,       -- 参数堆栈
                 TimValueStack,  -- 值栈（暂未使用）
                 TimDump,        -- 转储（暂未使用）
                 TimHeap,        -- 帧的堆
                 CodeStore,      -- 代码存储
                 TimStats)       -- 统计信息
```

##### **帧指针**

帧指针通常是堆中某个帧的地址，但在某些情况下，它也可能用于存储整数值，或者尚未初始化。为了区分这些情况，我们将 `FramePtr` 定义为一个代数数据类型：

```haskell
data FramePtr = FrameAddr Addr -- 帧的地址
              | FrameInt Int    -- 整数值
              | FrameNull       -- 未初始化
```

这样做的好处是：

- 当我们需要将整数值存储在帧指针中时，可以使用 FrameInt 构造器。
- 当帧指针尚未初始化时，可以使用 FrameNull，有助于在运行时捕获错误。
##### **堆栈和闭包**

堆栈用于存储闭包（Closure），每个闭包包含一个代码指针和一个帧指针。对应的类型定义如下：

```haskell
type TimStack = [Closure]
type Closure = ([Instruction], FramePtr)
```

##### **值栈和转储**

值栈和转储目前尚未使用，因此我们先为它们定义占位符类型：

```haskell
data TimValueStack = DummyTimValueStack
data TimDump = DummyTimDump
```

##### **堆和帧**

堆用于存储帧，每个帧是一个闭包的列表。帧的数据类型定义如下：

```haskell
type TimHeap = Heap Frame
type Frame = [Closure]
```

为了操作帧，我们定义了一些辅助函数：

- **fAlloc**：在堆中分配一个新的帧，返回更新后的堆和新的帧指针。
- **fGet**：从指定的帧中获取第 n 个闭包。
- **fUpdate**：更新指定帧中的第 n 个闭包。
- **fList**：将帧转换为闭包列表，用于打印。
对应的函数类型定义如下：

```haskell
fAlloc :: TimHeap -> [Closure] -> (TimHeap, FramePtr)
fGet :: TimHeap -> FramePtr -> Int -> Closure
fUpdate :: TimHeap -> FramePtr -> Int -> Closure -> TimHeap
fList :: Frame -> [Closure]
```

这些函数允许我们在堆中构建帧，提取和更新帧中的组件。

##### **代码存储**

代码存储（CodeStore）用于存储已编译的代码段，每个代码段都有一个名称（标签）。我们将代码存储表示为一个关联列表，将名称映射到指令列表：

```haskell
type CodeStore = ASSOC Name [Instruction]
```

为了方便，我们定义了一个辅助函数 `codeLookup`，用于在代码存储中查找指定标签的代码，如果找不到则抛出错误：

```haskell
codeLookup :: CodeStore -> Name -> [Instruction]
codeLookup cstore l
  = aLookup cstore l (error ("Attempt to jump to unknown label " ++ show l))
```

##### **统计信息**

统计信息用于记录执行过程中的一些指标，例如执行的指令数量、堆的使用情况等。我们将统计信息定义为一个抽象数据类型，以便于扩展：

```haskell
statInitial :: TimStats
statIncSteps :: TimStats -> TimStats
statGetSteps :: TimStats -> Int
```

在初始实现中，我们仅记录执行的步数，类型定义如下：

```haskell
type TimStats = Int -- 执行的步数
statInitial = 0
statIncSteps s = s + 1
statGetSteps s = s
```

##### **其他依赖**

我们还需要引入一些辅助代码，例如堆的数据类型和其他库函数，这些代码可以通过导入 `util.lhs`（一个包含常用工具函数的模块）来获得：

```haskell
-- :a util.lhs -- 堆的数据类型和其他库函数
```

#### **4.2.3 编译程序**

编译器的主要任务是将解析后的程序转换为 TIM 的初始状态。这包括：

- 初始化机器状态的各个组件。
- 编译超级组合子（supercombinator）定义。
- 设置初始的环境和代码存储。
`compile` 函数的定义如下：

```haskell
compile :: CoreProgram -> TimState
compile program
  = ([Enter (Label "main")], -- 初始指令
     FrameNull,              -- 初始帧指针（未初始化）
     initialArgStack,        -- 参数堆栈
     initialValueStack,      -- 值栈
     initialDump,            -- 转储
     hInitial,               -- 初始堆（空）
     compiled_code,          -- 编译后的代码存储
     statInitial)            -- 初始统计信息
  where
    sc_defs = preludeDefs ++ program
    compiled_sc_defs = map (compileSC initial_env) sc_defs
    compiled_code = compiled_sc_defs ++ compiledPrimitives
    initial_env = [(name, Label name) | (name, args, body) <- sc_defs]
                 ++ [(name, Label name) | (name, code) <- compiledPrimitives]
```

- **初始指令**：[Enter (Label "main")]，表示程序从 main 函数开始执行。
- **初始帧指针**：FrameNull，尚未初始化。
- **参数堆栈**：initialArgStack，初始化为空列表 []。
- **值栈和转储**：使用之前定义的占位符。
- **初始堆**：hInitial，一个空的堆。
- **编译后的代码存储**：compiled_code，包含编译后的超级组合子和原语（primitives）。
- **初始统计信息**：statInitial。
编译超级组合子时，我们使用 `compileSC` 函数：

```haskell
compileSC :: TimCompilerEnv -> CoreScDefn -> (Name, [Instruction])
compileSC env (name, args, body)
  = (name, Take (length args) : instructions)
    where
      instructions = compileR body new_env
      new_env = (zip2 args (map Arg [1..])) ++ env
```

- **compileSC 的输入**：env：环境，一个将名称映射到寻址模式的关联列表。(name, args, body)：超级组合子的名称、参数列表和函数体。
- **compileSC 的输出**：(name, instructions)：超级组合子的名称和对应的指令列表。
- **过程**：首先生成一个 Take 指令，取参数的数量为 length args。然后使用 compileR 编译函数体 body，生成指令列表 instructions。构建新的环境 new_env，将参数名称与对应的 Arg n 寻址模式关联起来。
编译表达式时，我们使用 `compileR` 和 `compileA` 函数，这两个函数直接对应于编译方案中的 `R` 和 `A` 编译方案。

```haskell
compileR :: CoreExpr -> TimCompilerEnv -> [Instruction]
compileR (EAp e1 e2) env = Push (compileA e2 env) : compileR e1 env
compileR (EVar v) env = [Enter (compileA (EVar v) env)]
compileR (ENum n) env = [Enter (compileA (ENum n) env)]
compileR e env = error "compileR: can't do this yet"

compileA :: CoreExpr -> TimCompilerEnv -> TimAMode
compileA (EVar v) env = aLookup env v (error ("Unknown variable " ++ v))
compileA (ENum n) env = IntConst n
compileA e env = Code (compileR e env)
```

- **compileR**：处理应用表达式 EAp e1 e2：先编译 e2，将其结果压入堆栈，然后递归编译 e1。处理变量 EVar v：生成 Enter 指令，进入变量对应的闭包。处理整数常量 ENum n：生成 Enter 指令，进入整数常量。其他情况暂时不处理，抛出错误。
- **compileA**：处理变量 EVar v：在环境中查找变量 v，获取对应的寻址模式。处理整数常量 ENum n：生成 IntConst n 寻址模式。其他情况：将表达式递归编译为代码序列，使用 Code 寻址模式。
#### **4.2.4 评估器**

评估器（解释器）负责执行编译后的 TIM 指令。`eval` 函数的定义与之前的模板实例化机器相似：

```haskell
eval :: TimState -> [TimState]
eval state = state : rest_states
  where
    rest_states
      | timFinal state = []
      | otherwise = eval next_state
    next_state = doAdmin (step state)

doAdmin :: TimState -> TimState
doAdmin state = applyToStats statIncSteps state
```

- **eval**：接受一个 TIM 状态 state，返回一个 TIM 状态的列表。如果 state 是最终状态，则返回空列表。否则，执行 step 函数获取下一个状态，并递归调用 eval。
- **doAdmin**：在执行 step 之前，更新统计信息，例如增加步骤计数。
- **timFinal**：判断一个状态是否为最终状态。当指令序列为空时，表示程序执行完毕。
```haskell
timFinal :: TimState -> Bool
timFinal ([], frame, stack, vstack, dump, heap, cstore, stats) = True
timFinal _ = False
```

- **applyToStats**：将统计更新函数应用于状态的统计信息组件。
```haskell
applyToStats :: (TimStats -> TimStats) -> TimState -> TimState
applyToStats stats_fun (instr, frame, stack, vstack, dump, heap, cstore, stats)
  = (instr, frame, stack, vstack, dump, heap, cstore, stats_fun stats)
```

##### **执行一个步骤**

`step` 函数负责执行一个指令，并返回更新后的状态。

- **处理 Take n 指令**：
```haskell
step ((Take n : instr), fptr, stack, vstack, dump, heap, cstore, stats)
  | length stack >= n = (instr, fptr', drop n stack, vstack, dump, heap', cstore, stats)
  | otherwise = error "Too few args for Take instruction"
  where
    (heap', fptr') = fAlloc heap (take n stack)
```

- **解释**：如果堆栈上的元素数量至少为 n，则取出前 n 个元素，组成一个新的帧，更新堆和帧指针。否则，抛出错误。
- **处理 Enter am 指令**：
```haskell
step ([Enter am], fptr, stack, vstack, dump, heap, cstore, stats)
  = (instr', fptr', stack, vstack, dump, heap, cstore, stats)
    where
      (instr', fptr') = amToClosure am fptr heap cstore
```

- **处理 Push am 指令**：
```haskell
step ((Push am : instr), fptr, stack, vstack, dump, heap, cstore, stats)
  = (instr, fptr, closure : stack, vstack, dump, heap, cstore, stats)
    where
      closure = amToClosure am fptr heap cstore
```

- **amToClosure 函数**：
```haskell
amToClosure :: TimAMode -> FramePtr -> TimHeap -> CodeStore -> Closure
amToClosure (Arg n) fptr heap cstore = fGet heap fptr n
amToClosure (Code il) fptr heap cstore = (il, fptr)
amToClosure (Label l) fptr heap cstore = (codeLookup cstore l, fptr)
amToClosure (IntConst n) fptr heap cstore = (intCode, FrameInt n)
```

- **解释**：根据不同的寻址模式，amToClosure 返回对应的闭包。对于 Arg n，从当前帧中获取第 n 个闭包。对于 Code il，使用给定的指令序列和当前帧指针构建闭包。对于 Label l，从代码存储中获取标签对应的指令序列，构建闭包。对于 IntConst n，构建一个整数常量的闭包，帧指针中存储整数值。
#### **4.2.5 打印结果**

为了查看程序的执行结果和中间状态，我们需要定义一系列函数来格式化并显示 TIM 的状态。

- **showFullResults**：显示所有的状态，包括超级组合子定义、状态转换和统计信息。
```haskell
showFullResults :: [TimState] -> [Char]
showFullResults states
  = iDisplay (iConcat [
      iStr "Supercombinator definitions", iNewline, iNewline,
      showSCDefns first_state, iNewline, iNewline,
      iStr "State transitions", iNewline,
      iLayn (map showState states), iNewline, iNewline,
      showStats (last states)
    ])
  where
    (first_state : rest_states) = states
```

- **showResults**：仅显示最终状态和统计信息。
```haskell
showResults :: [TimState] -> [Char]
showResults states
  = iDisplay (iConcat [
      showState last_state, iNewline, iNewline, showStats last_state
    ])
  where
    last_state = last states
```

- **showSCDefns**：显示超级组合子的代码。
```haskell
showSCDefns :: TimState -> Iseq
showSCDefns (instr, fptr, stack, vstack, dump, heap, cstore, stats)
  = iInterleave iNewline (map showSC cstore)

showSC :: (Name, [Instruction]) -> Iseq
showSC (name, il)
  = iConcat [
      iStr "Code for ", iStr name, iStr ":", iNewline,
      iStr " ", showInstructions Full il, iNewline, iNewline
    ]
```

- **showState**：显示机器的状态，包括指令序列、帧、堆栈、值栈、转储等。
```haskell
showState :: TimState -> Iseq
showState (instr, fptr, stack, vstack, dump, heap, cstore, stats)
  = iConcat [
      iStr "Code: ", showInstructions Terse instr, iNewline,
      showFrame heap fptr,
      showStack stack,
      showValueStack vstack,
      showDump dump,
      iNewline
    ]
```

- **showFrame**：显示当前的帧。
```haskell
showFrame :: TimHeap -> FramePtr -> Iseq
showFrame heap FrameNull = iStr "Null frame ptr" `iAppend` iNewline
showFrame heap (FrameAddr addr)
  = iConcat [
      iStr "Frame: <",
      iIndent (iInterleave iNewline (map showClosure (fList (hLookup heap addr)))),
      iStr ">", iNewline
    ]
showFrame heap (FrameInt n)
  = iConcat [ iStr "Frame ptr (int): ", iNum n, iNewline ]
```

- **showStack**：显示堆栈中的闭包。
```haskell
showStack :: TimStack -> Iseq
showStack stack
  = iConcat [ iStr "Arg stack: [",
              iIndent (iInterleave iNewline (map showClosure stack)),
              iStr "]", iNewline
            ]
```

- **showClosure**：显示一个闭包，包括代码指针和帧指针。
```haskell
showClosure :: Closure -> Iseq
showClosure (i, f)
  = iConcat [ iStr "(", showInstructions Terse i, iStr ", ",
              showFramePtr f, iStr ")"
            ]
```

- **showFramePtr**：显示帧指针。
```haskell
showFramePtr :: FramePtr -> Iseq
showFramePtr FrameNull = iStr "null"
showFramePtr (FrameAddr a) = iStr (show a)
showFramePtr (FrameInt n) = iStr "int " `iAppend` iNum n
```

- **showStats**：显示统计信息。
```haskell
showStats :: TimState -> Iseq
showStats (instr, fptr, stack, vstack, dump, heap, code, stats)
  = iConcat [
      iStr "Steps taken = ", iNum (statGetSteps stats), iNewline,
      iStr "No of frames allocated = ", iNum (hSize heap), iNewline
    ]
```

##### **打印指令**

为了更好地查看指令和指令序列，我们定义了 `showInstructions` 和 `showInstruction` 函数。

- 我们希望根据需要以不同的详细程度显示指令序列：**Full**：完整显示指令序列，每条指令一行。**Terse**：简要显示指令序列，限制显示的指令数量。**None**：不显示指令序列。
- **HowMuchToPrint** 类型定义：
```haskell
data HowMuchToPrint = Full | Terse | None
```

- **showInstructions**：将指令列表转换为可显示的序列。
```haskell
showInstructions :: HowMuchToPrint -> [Instruction] -> Iseq
showInstructions None il = iStr "{..}"
showInstructions Terse il
  = iConcat [iStr "{", iIndent (iInterleave (iStr ", ") body), iStr "}"]
    where
      instrs = map (showInstruction None) il
      body | length il <= nTerse = instrs
           | otherwise = (take nTerse instrs) ++ [iStr ".."]
showInstructions Full il
  = iConcat [iStr "{ ", iIndent (iInterleave sep instrs), iStr " }"]
    where
      sep = iStr "," `iAppend` iNewline
      instrs = map (showInstruction Full) il
```

- **showInstruction**：将单个指令转换为可显示的序列。
```haskell
showInstruction :: HowMuchToPrint -> Instruction -> Iseq
showInstruction d (Take m) = iStr "Take " `iAppend` iNum m
showInstruction d (Enter x) = iStr "Enter " `iAppend` showArg d x
showInstruction d (Push x) = iStr "Push " `iAppend` showArg d x

showArg :: HowMuchToPrint -> TimAMode -> Iseq
showArg d (Arg m) = iStr "Arg " `iAppend` iNum m
showArg d (Code il) = iStr "Code " `iAppend` showInstructions d il
showArg d (Label s) = iStr "Label " `iAppend` iStr s
showArg d (IntConst n) = iStr "IntConst " `iAppend` iNum n
```

- **nTerse**：在简要模式下显示的指令数量。
```haskell
nTerse = 3
```

#### **练习**

**练习 4.1**：

- **任务**：使用以下 `main` 定义运行机器：
```haskell
main = S K K 4
```
- **解释**：`S K K` 是恒等函数，因此 `main` 应该化简为 `4`，机器应该停止执行。可以尝试一些更复杂的例子，例如：
```haskell
id = S K K ;
id1 = id id ;
main = id1 4
```
**练习 4.2**：

- **任务**：添加更多的性能测量指标，例如：计算执行时间，每条指令计为一个时间单位，Take 指令根据帧的大小计时。测量堆的使用情况，打印运行过程中堆的总分配量。考虑帧的大小，以便与模板实例化版本的结果进行比较。测量最大堆栈深度。
**练习 4.3**：

- **任务**：如果 n = 0，那么 Take n 没有任何作用。修改 compileSC 的定义，识别这种情况，对 CAF（无参数的超级组合子）省略 Take 指令。
#### **4.2.6 垃圾收集**

像任何基于堆的系统一样，TIM 需要一个垃圾收集器。但它还需要一些额外的复杂性。

- **问题**：当执行垃圾收集时，我们需要知道哪些帧需要保留。对于堆栈上的每个闭包，我们需要追踪它们引用的帧。
- **空间泄漏**：如果我们盲目地保留所有帧，可能会导致保留了不必要的数据，造成空间泄漏。
- **解决方案**：每个闭包由一个代码指针和一个帧指针组成。代码指针“知道”它将需要帧中的哪些元素。我们可以将这些信息记录下来，让垃圾收集器只保留需要的帧元素。具体来说，我们可以将代码指针指向一个包含使用的槽（slot）编号列表和代码本身的对。在实际实现中，列表可能被编码为位掩码。如何获取有用槽的列表？只需找到正在编译的表达式的自由变量，并使用环境将它们映射到槽编号。
**全面详尽的总结**

在这一节中，我们构建了一个最小但完整的 TIM（Three Instruction Machine，三指令机器）实现。TIM 是一种用于实现函数式编程语言的抽象机器，具有简单的指令集和执行模型。

**主要内容回顾**：

1. **总体结构**：
- TIM 的结构与之前的模板实例化解释器类似，包括 parse、compile、eval 和 showResults 函数。
- 提供了 fullRun 函数，可以显示所有的中间状态。
2. **数据类型定义**：
- 定义了 TIM 的指令集，包括 Take、Enter 和 Push 指令。
- 定义了寻址模式 TimAMode，用于指令指定操作数的位置或获取方式。
- 定义了 TIM 机器的状态，包括指令序列、帧指针、堆栈、堆、代码存储和统计信息。
- 定义了辅助的数据类型和函数，用于操作堆和帧。
3. **编译器的实现**：
- 实现了 compile 函数，将程序编译为 TIM 的初始状态。
- 使用 compileSC、compileR 和 compileA 函数，直接对应于编译方案中的 SC、R 和 A 编译方案。
- 通过环境将名称映射到寻址模式，方便了变量和超级组合子的处理。
4. **评估器的实现**：
- 实现了 eval 函数，递归地执行 TIM 指令，生成一系列机器状态。
- step 函数处理每个指令，包括 Take、Enter 和 Push。
- 使用 amToClosure 函数，根据寻址模式获取闭包。
5. **输出结果的显示**：
- 实现了 showResults 和 showFullResults 函数，格式化并显示机器的状态和执行结果。
- 定义了多种显示函数，显示指令序列、堆栈、帧、闭包等。
- 提供了不同的显示模式（Full、Terse、None），控制指令序列的显示程度。
6. **练习**：
- 提供了几个练习，帮助读者巩固对 TIM 的理解，包括运行简单的程序、添加性能测量指标和优化编译器。
7. **垃圾收集的讨论**：
- 介绍了 TIM 中垃圾收集的问题，特别是如何避免空间泄漏。
- 提出了通过记录代码需要的帧元素，来优化垃圾收集的方法。
**重要的概念和技巧**：

- **闭包和帧**：TIM 使用闭包和帧来表示函数和其环境，每个闭包包含一个代码指针和一个帧指针。
- **寻址模式**：通过定义多种寻址模式，TIM 的指令可以灵活地获取操作数。
- **编译方案的实现**：将编译方案直接转换为编译器函数，实现了从源代码到 TIM 指令的编译过程。
- **抽象数据类型**：使用抽象数据类型封装复杂的数据结构（如堆、帧、统计信息），提高了代码的可维护性和可扩展性。
- **调试和输出**：提供了丰富的输出函数，便于观察机器的状态和执行过程。
**总结**

通过本节的学习，您深入了解了 TIM 的基本实现，包括其数据结构、编译器和评估器的设计。我们从头开始，逐步构建了一个最小的 TIM，实现了核心的指令集和执行模型。

TIM 的设计强调了简洁性和可扩展性，通过简单的指令和数据结构，实现了对函数式编程语言的支持。在后续的章节中，我们将继续完善 TIM，添加算术运算、数据结构和更新等特性，并讨论进一步的优化。

这些知识对于理解函数式语言的实现和抽象机器的设计非常重要。通过掌握 TIM 的实现原理，您可以更深入地理解编译器和解释器的工作方式，以及如何在实际中设计和实现高效的语言运行时系统。
Thought for 44 seconds
**概览**

本节（**4.3 Mark 2: 添加算术运算**）旨在为 TIM（Three Instruction Machine，三指令机器）添加算术运算支持。之前的 TIM 实现无法处理算术表达式，因此无法运行有趣的程序，如递归函数或需要条件判断的程序。

在这一节中，我们将详细探讨如何在 TIM 中添加算术运算。首先，我们将介绍算术运算在 TIM 中的工作原理，以及需要做出的修改。然后，我们将具体实现这些修改，包括添加新的指令、修改编译器和评估器。接着，我们将讨论改进编译方案，使得编译器生成更高效的代码。最后，我们会通过练习来巩固所学的内容。

**详细解析**

### **4.3 Mark 2: 添加算术运算**

#### **4.3.1 概述：算术运算如何工作**

**背景**

最初，Fairbairn 和 Wray 在他们的 TIM 机器中采用了一种相当复杂的方案来处理算术运算。他们的主要动机是保持机器的最小化，但他们的方法难以理解，并且需要大量调整才能实现高效的实现。

**我们的方案**

相反，我们将以与 G 机器（G-machine）中的 V 栈（V-stack）完全类似的方式修改 TIM。我们的目标是：

- 引入一个 **值栈（value stack）**，用于存储已计算的（未装箱的）整数。
- 扩展指令集，添加一系列指令 Op op，它们在值栈的顶部元素上执行算术操作，并将结果留在值栈的顶部。
**示例**

例如，`Op Sub` 指令从值栈中移除顶部的两个元素，执行减法操作，然后将结果压入值栈。其状态转换规则为：

**状态转换规则（4.10）**：

```java
Op Sub : i   f   s   n1 : n2 : v   h   c
=> i   f   s   (n1 - n2) : v   h   c
```

- **解释**：**指令**：Op Sub**状态**：**指令序列**：i**帧指针**：f**堆栈**：s**值栈**：n1 : n2 : v（n1 和 n2 是整数）**堆**：h**代码存储**：c**操作**：从值栈中弹出 n1 和 n2。计算 n1 - n2。将结果压入值栈。
通过这种方式，我们可以轻松地定义一系列算术指令，如 `Op Add`、`Op Sub`、`Op Mult`、`Op Div`、`Op Neg` 等。

**处理函数参数的求值**

现在，考虑以下函数定义：

```haskell
sub a b = a - b
```

我们需要生成什么样的代码来实现 `sub`？它需要执行以下步骤：

1. 使用 Take 2 将它的两个参数组成一个帧。
2. 计算 b 的值，将其放入值栈。
3. 计算 a 的值，同样将其放入值栈。
4. 使用 Op Sub 指令计算 a - b，结果留在值栈的顶部。
5. **返回**调用者。
**挑战**

`a` 和 `b` 都表示为闭包，保存在当前的帧中。对一个闭包，我们唯一能做的就是 **进入**（`Enter`）它。那么，我们需要进入 `a` 的闭包，但进入一个整数值的闭包意味着什么呢？到目前为止，我们只进入过函数，而整数不是函数。

**关键概念：整数不变性**

这里有一个关键的想法：

**整数不变性（Integer invariant）**：

- **描述**：当一个整数值的闭包被进入时，它计算整数的值，将其压入值栈，然后 **进入** 参数堆栈顶部的闭包。
**解释**：

- 参数堆栈（Argument Stack）顶部的闭包称为 **续延（Continuation）**，因为它指示了整数计算完成后应该做什么。
- 续延由一个指令序列和一个帧指针组成，说明了当整数计算完成后要执行的操作，以及当前的帧指针（以防在计算整数的过程中被修改）。
- 换句话说，续延是一个完全普通的闭包。
**sub 的代码**

基于上述概念，`sub` 的代码如下：

```haskell
sub:
  Take 2
  Push (Label L1)   -- 将续延压入堆栈
  Enter (Arg 2)     -- 计算 b
L1:
  Push (Label L2)   -- 再次压入续延
  Enter (Arg 1)     -- 计算 a
L2:
  Op Sub            -- 计算 a - b，结果在值栈顶部
  Return            -- 返回
```

**解释各个步骤**：

1. **Take 2**：将堆栈顶部的两个闭包组成一个新的帧，并更新帧指针。
2. **Push (Label L1)**：将续延压入参数堆栈。续延是一个闭包，包含标签 L1 对应的指令序列和当前的帧指针。
3. **Enter (Arg 2)**：进入参数 2 的闭包，计算 b。
4. **L1 标签**：执行续延的指令序列。
- **Push (Label L2)**：再次将续延压入参数堆栈，续延指向标签 L2。
- **Enter (Arg 1)**：进入参数 1 的闭包，计算 a。
5. **L2 标签**：执行第二个续延的指令序列。
- **Op Sub**：从值栈中弹出两个整数，计算 a - b，将结果压入值栈。
- **Return**：返回调用者。
**Return 指令的作用**

`Return` 指令应该做什么？由于 `sub` 返回的值是一个整数，并且在 `Op Sub` 指令之后，这个整数在值栈的顶部，因此 `Return` 所需要做的就是从参数堆栈顶部弹出闭包（续延）并 **进入** 它：

**状态转换规则（4.11）**：

```ruby
[Return]   f   (i', f') : s   v   h   c
=> i'   f'   s   v   h   c
```

- **解释**：**指令**：Return**参数堆栈**：顶部是闭包 (i', f')（续延）。**操作**：弹出参数堆栈顶部的闭包 (i', f')。将指令序列 i' 加载到程序计数器。将帧指针更新为 f'。继续执行。
**使用 Push (Code ...) 代替标签**

在上面的代码中，我们使用了标签 `L1` 和 `L2` 来编写 `sub` 的代码。这不是唯一的方法，另一种方法是使用 `Push (Code ...)` 指令，这样就不需要发明新的标签。

使用 `Push (Code ...)` 的方式，`sub` 的代码变为：

```haskell
sub:
  Take 2
  Push (Code [
    Push (Code [Op Sub, Return]),
    Enter (Arg 1)
  ])
  Enter (Arg 2)
```

- **解释**：Push (Code [ ... ])：将一个包含指令序列的闭包压入参数堆栈。这样避免了发明新的标签的麻烦。然而，这种方式可能不太直观，因此在解释中我们继续使用标签，以便更容易理解代码片段。
#### **处理整数常量**

现在，我们回到整数常量的问题。考虑表达式 `(sub 4 2)`。它将被编译为以下代码：

```haskell
Push (IntConst 2)
Push (IntConst 4)
Enter (Label "sub")
```

- **解释**：将整数常量 2 和 4 压入参数堆栈，作为闭包。进入标签为 sub 的代码，执行 sub 函数。
**问题**

`sub` 的代码将很快进入闭包 `(IntConst 2)`，这会将整数 `2` 放入帧指针，并跳转到 `intCode`。目前，`intCode` 是一个空的指令序列（因此，如果我们进入一个整数，机器将停止）。我们需要更改 `intCode`，使其按照整数不变性工作。

**解决方案**

根据 **整数不变性**，`intCode` 必须将整数压入值栈，然后 **返回**。因此，我们将 `intCode` 定义为：

```haskell
intCode = [PushV FramePtr, Return]
```

- **PushV FramePtr**：一个新指令，将当前帧指针中伪装的数字（即整数值）压入值栈。
- **Return**：返回，执行参数堆栈顶部的续延。
**PushV FramePtr 指令**

`PushV FramePtr` 是一个新指令，其状态转换规则为：

**状态转换规则（4.12）**：

```less
PushV FramePtr : i   f   s   v   h   c
=> i   f   s   n : v   h   c
```

- **解释**：**指令**：PushV FramePtr**帧指针**：f，其中存储了整数值 n（因为我们将整数值存储在帧指针的位置）。**操作**：将 n 压入值栈。继续执行后续的指令 i。
#### **4.3.2 将简单的算术运算添加到实现中**

现在，我们准备修改我们的实现，以支持算术运算。

**步骤**

1. **修改值栈的类型定义和初始化**：
```haskell
type TimValueStack = [Int]
initialValueStack = []
```

- 将值栈定义为一个整数列表，用于存储计算的整数值。
- 初始化值栈为空列表。
2. **扩展指令集**：
- 添加新的指令 PushV、Return 和 Op 到指令数据类型中。
- 还添加了 Cond 指令，这是后续练习的主题。
- 注意，TIM 不再是一个三指令机器了！
```haskell
data Instruction = Take Int
                 | Push TimAMode
                 | PushV ValueAMode
                 | Enter TimAMode
                 | Return
                 | Op Op
                 | Cond [Instruction] [Instruction]
data Op = Add | Sub | Mult | Div | Neg
        | Gr | GrEq | Lt | LtEq | Eq | NotEq
        deriving (Eq)
```

- **Op 构造器**：定义了各种算术运算和比较运算。
3. **定义 ValueAMode 数据类型**：
- 目前，`PushV` 指令的参数只能是 `FramePtr`，但我们很快会添加第二种形式，允许将字面整数常量压入值栈。
- 因此，定义一个代数数据类型 `ValueAMode`：
```haskell
data ValueAMode = FramePtr
                | IntVConst Int
```
- **FramePtr**：表示从帧指针获取整数值。
- **IntVConst Int**：表示一个整数常量。
4. **修改 showInstruction 函数**：
- 更新 showInstruction 函数，以处理新的指令和数据结构。
5. **修改 step 函数**：
- 修改评估器的 `step` 函数，以实现新的指令。这只是将状态转换规则翻译为 Miranda 语言的问题。
- **实现新的指令**：**PushV**：根据其状态转换规则，实现将整数值压入值栈的功能。**Return**：实现从参数堆栈弹出续延并进入它的功能。**Op**：实现算术操作，在值栈顶部的元素上执行相应的运算。
6. **添加算术运算的原语定义到 compiledPrimitives**：
- 将 `+`、`-` 等运算的代码添加到 `compiledPrimitives` 中。
- 回想一下，当我们在程序中写 `p - q` 时，解析器将其转换为：
```haskell
EAp (EAp (EVar "-") (EVar "p")) (EVar "q")
```
- 我们需要为 `-`（以及其他运算）提供合适的代码，添加到代码存储中。
- 编译器可以像对待其他超级组合子一样处理 `-`。
- **示例**：`-` 的代码可以与我们之前为 `sub` 开发的代码完全相同。
7. **修改 intCode 并初始化参数堆栈**：
- 现在 `intCode` 不再是空的，我们必须初始化堆栈，使其具有一个合适的续延（返回地址），以便 `main` 返回。
- 方法是让 `compile` 函数初始化堆栈，包含闭包 `([], FrameNull)`，通过重新定义 `initialArgStack`：
```haskell
initialArgStack = [([], FrameNull)]
```
- 这个续延具有一个空的指令序列，因此机器将在值栈顶部的结果被计算后停止。
**练习 4.4**

- **任务**：在你的原型中实现这些更改。尝试一些简单的示例，例如：
```haskell
four = 2 * 2
main = four + four
```
- **目标**：验证算术运算的实现是否正确。
**练习 4.5**

- **问题**：我们仍然无法执行“有趣”的程序，因为我们还没有条件判断（conditional），没有条件判断就无法使用递归。
- **解决方案**：添加一个新的指令 `Cond i1 i2`，它从值栈顶部移除一个值，检查它是否为零，如果是，则继续执行指令序列 `i1`，否则执行 `i2`。**状态转换规则（4.13）**：
```r
[Cond i1 i2]   f   s   0 : v   h   c
=> i1   f   s   v   h   c

[Cond i1 i2]   f   s   n : v   h   c
=> i2   f   s   v   h   c
（其中 n ≠ 0）
```
**解释**：**指令**：Cond i1 i2**值栈**：顶部的值为 0 或非零。**操作**：如果值为 0，执行指令序列 i1。如果值为非零，执行指令序列 i2。
- **添加原语 if**：需要添加一个原语 `if`，其行为如下：
```java
if 0 t f = t
if n t f = f  （其中 n ≠ 0）
```
- **任务**：使用 `Cond` 指令，为 `if` 编写 TIM 代码，并将其添加到 `compiledPrimitives` 中。最后，可以使用以下阶乘函数测试改进后的系统：
```haskell
factorial n = if n 1 (n * factorial (n - 1))
main = factorial 3
```
#### **4.3.3 算术运算的编译方案**

**改进编译器**

正如在 G 机器中一样，我们可以为我们的机器做更好的编译工作。

**问题**

考虑以下函数：

```haskell
f x y z = (x + y) * z
```

按照目前的方式，它将被解析为：

```haskell
f x y z = * (+ x y) z
```

然后，`f` 的代码将被编译为调用标准函数 `*` 和 `+` 的代码。

**改进的想法**

我们可以做得更好！例如，我们可以直接在函数内部执行这些运算，而不是为 `(+ x y)` 构建一个闭包并将其传递给 `*`。

**改进后的步骤**：

1. 计算 x。
2. 计算 y。
3. 将它们相加。
4. 计算 z。
5. 将之前的结果与 z 相乘。
6. 返回结果。
- **优势**：不需要构建任何闭包。不需要任何跳转（除了需要计算 x、y 和 z 的部分）。
**引入新的编译方案：B 编译方案**

为了表达这种改进，我们引入一个新的编译方案，处理其值为整数的表达式，称为 **B 编译方案**。

**定义**：

- 对于任何值为整数的表达式 `e`，以及任何代码序列 `cont`，
- **B[[e]] ρ cont** 是一个代码序列，当在环境 `ρ` 描述的当前帧下执行时，将表达式 `e` 的值压入值栈，然后执行代码序列 `cont`。
- **编译方案使用了** **Continuation-Passing Style**（续延传递风格），其中参数 `cont` 指示了值计算完成后要执行的操作。
**编译方案的具体定义**

**R 编译方案**（修改后）：

- **R[[e]] ρ** 是 TIM 代码，它将表达式 e 的值应用于堆栈上的参数。
- 规则：如果 `e` 是算术表达式，如 `e1 + e2` 或一个数字，则使用 `B` 编译方案：
```haskell
R[[e]] ρ = B[[e]] ρ [Return]
```
如果 `e` 是应用 `e1 e2`：
```haskell
R[[e1 e2]] ρ = Push (A[[e2]] ρ) : R[[e1]] ρ
```
如果 `e` 是变量或超级组合子：
```haskell
R[[a]] ρ = Enter (A[[a]] ρ)
```
**A 编译方案**：

- **A[[e]] ρ** 是 TIM 寻址模式，用于表达式 e 在环境 ρ 下。
- 规则：如果 `x` 在环境 `ρ` 中有绑定：
```haskell
A[[x]] ρ = ρ x
```
如果 `n` 是整数常量：
```haskell
A[[n]] ρ = IntConst n
```
其他情况：
```haskell
A[[e]] ρ = Code (R[[e]] ρ)
```
**B 编译方案**：

- **B[[e]] ρ cont** 是 TIM 代码，它在环境 ρ 下计算表达式 e，将其值（应为整数）压入值栈，然后继续执行代码序列 cont。
- 规则：**处理算术运算**：对于 `e1 + e2`：
```haskell
B[[e1 + e2]] ρ cont = B[[e2]] ρ (B[[e1]] ρ (Op Add : cont))
```
**解释**：先编译 e2，将其值压入值栈，然后继续编译 e1。计算 e1 的值后，执行 Op Add，然后继续执行 cont。对于其他算术运算符，规则类似。**处理整数常量**：
```haskell
B[[n]] ρ cont = PushV (IntVConst n) : cont
```
**解释**：将整数常量 n 压入值栈，然后继续执行 cont。**其他情况**：
```haskell
B[[e]] ρ cont = Push (Code cont) : R[[e]] ρ
```
**解释**：将续延 cont 压入参数堆栈，然后使用 R 编译方案编译 e。
**新指令**

- 当 `B` 编译方案被要求编译一个常量时，我们需要一个指令 `PushV (IntVConst n)`，将整数常量压入值栈。
- 其状态转换规则为：**状态转换规则（4.14）**：
```less
PushV (IntVConst n) : i   f   s   v   h   c
=> i   f   s   n : v   h   c
```
- **解释**：**指令**：PushV (IntVConst n)**操作**：将整数常量 n 压入值栈。继续执行后续的指令 i。
**总结**

通过引入 `B` 编译方案，我们可以生成更高效的代码，避免不必要的闭包构建和函数调用。在编译算术表达式时，`B` 编译方案直接在值栈上操作，利用算术指令 `Op op`。

**练习 4.6**

- **任务**：实现改进的编译方案。将你的实现与之前的性能进行比较。
- **目标**：验证新的编译方案能够生成更高效的代码，提高程序的执行性能。
**练习 4.7**

- **任务**：为 `R` 编译方案添加一个新规则，匹配一个完整的 `if` 应用。你应该能够生成比调用 `if` 原语更好的代码。实现此更改并测量性能改进。
- **目标**：优化条件表达式的编译，生成更高效的代码。
**练习 4.8**

- **问题**：假设我们希望将条件表达式推广到处理更通用的算术比较，例如以下所需的：
```haskell
fib n = if (n < 2) 1 (fib (n - 1) + fib (n - 2))
```
- **要求**：实现一个新的指令 Op Lt，它从值栈顶部弹出两个项，比较它们，然后根据比较结果将 1 或 0 压入值栈。现在，Cond 指令可以检查这个结果。
- **任务**：实现一系列这样的比较指令，并在 B 编译方案中为它们添加特殊情况，方式与其他算术运算符完全相同。测试你的改进。
- **目标**：支持更复杂的条件判断，使得程序能够进行递归和复杂的逻辑操作。
**练习 4.9**

- **问题**：在上一个练习中，你可能想知道为什么我们不修改 `Cond` 指令，使其具有额外的“比较模式”。它可以根据该模式比较值栈顶部的两个项，并相应地采取行动。我们为什么不这样做？
- **提示**：考虑以下程序会发生什么？
```haskell
multipleof3 x = ((x / 3) * 3) == x
f y = if (multipleof3 y) 0 1
```
- **讨论**：如果 Cond 指令包含比较操作，我们可能无法正确处理复杂的表达式，如 multipleof3 x。因此，我们将比较操作作为独立的指令（如 Op Eq），在值栈上操作，然后 Cond 指令仅根据值栈顶部的值（0 或非零）决定执行哪个分支。
**参考**

本节的内容在 [Argo 1989] 中进行了讨论，并且与 [Peyton Jones 1987] 的第 20 章中讨论的改进 G 机器编译方案完全对应。

**全面详尽的总结**

在本节中，我们深入探讨了如何为 TIM 添加算术运算支持，以及如何改进编译器以生成更高效的代码。

**主要内容回顾**：

1. **添加算术运算的必要性**：
- 原始的 TIM 无法处理算术表达式，限制了程序的复杂性。
- 为了运行有趣的程序（如递归函数），需要添加算术运算和条件判断。
2. **引入值栈（Value Stack）**：
- 值栈用于存储已计算的（未装箱的）整数，避免将整数值存储在堆或闭包中，提高了效率。
3. **扩展指令集**：
- 添加了新的指令 Op op，在值栈顶部的元素上执行算术操作。
- 添加了 PushV 指令，将整数值压入值栈。
- 添加了 Return 指令，从参数堆栈弹出续延并进入它。
- 添加了 Cond 指令，用于条件判断。
4. **整数不变性（Integer Invariant）**：
- 当进入一个整数值的闭包时，计算整数的值，将其压入值栈，然后进入参数堆栈顶部的闭包（续延）。
5. **修改实现**：
- 修改了值栈的定义和初始化。
- 扩展了指令集，定义了新的指令和数据类型。
- 修改了评估器的 step 函数，处理新的指令。
- 添加了算术运算的原语定义到代码存储中。
- 修改了 intCode 和初始参数堆栈，支持整数计算和程序的正常返回。
6. **添加条件判断**：
- 添加了 Cond 指令，实现条件判断的功能。
- 添加了 if 原语，支持条件表达式。
- 能够编译和运行递归函数，如阶乘函数。
7. **改进编译器**：
- 引入了新的编译方案 B，用于编译值为整数的表达式。
- B 编译方案直接在值栈上操作，避免了不必要的闭包构建和函数调用。
- 修改了 R 和 A 编译方案，使其与 B 编译方案协同工作。
8. **支持更复杂的条件和比较**：
- 通过添加新的算术和比较指令，如 Op Lt、Op Eq 等，支持更复杂的条件判断。
- 改进了程序的表达能力，可以编译和运行如斐波那契数列等复杂程序。
9. **练习和思考**：
- 通过练习，巩固了对 TIM 算术运算和编译器改进的理解。
- 讨论了设计选择的原因，如为什么不将比较操作集成到 Cond 指令中。
**重要的概念和技巧**：

- **值栈的引入**：通过使用值栈，我们可以高效地处理算术运算，避免了在堆或闭包中存储和操作整数值。
- **整数不变性**：为整数值的闭包定义了统一的行为，使得进入整数值的闭包能够正确地将值压入值栈并继续执行续延。
- **续延（Continuation）的概念**：通过将续延作为普通的闭包，我们能够控制计算的流程，特别是在处理递归和条件判断时。
- **编译器的改进**：引入 `B` 编译方案，使编译器能够直接在值栈上操作，生成更高效的代码。
- **指令集的设计**：扩展指令集，添加新的指令，以支持更丰富的语言特性，如算术运算和条件判断。
**总结**

通过本节的学习，我们成功地为 TIM 添加了算术运算支持，并改进了编译器的效率。我们深入理解了值栈的作用、整数不变性和续延的概念，学会了如何扩展指令集和修改评估器。

我们还学习了如何改进编译器，使其生成更高效的代码，避免不必要的闭包构建和函数调用。这些技巧对于实现高效的函数式编程语言运行时系统至关重要。

在后续的章节中，我们将继续完善 TIM，添加更多的特性和优化，进一步探讨函数式编程语言的实现细节。
 #  
 Thought for 8 seconds
**概览**

本节（**4.5 Mark 4: 更新机制**）探讨了如何在 TIM（Three Instruction Machine，三指令机器）中实现 **更新（updating）**，以实现 **图归约（graph reduction）** 而非 **树归约（tree reduction）**。此前，我们的 TIM 实现重复地计算共享的表达式（redex），这会导致重复计算，浪费计算资源。本节的目标是引入更新机制，以确保共享的表达式只被计算一次，其结果被缓存（memoized）供后续使用。

我们将详细讨论：

- **更新的基本技术**：介绍在 TIM 中实现更新的关键概念和步骤，包括使用 **PushMarker** 指令和 **转储（dump）**。
- **编译 PushMarker 指令**：如何修改编译器，在适当的位置插入 PushMarker 指令，以实现更新机制。
- **更新机制的问题**：讨论初始更新机制存在的问题，如 **相同更新（identical updates）** 和 **间接链（indirection chains）**，以及它们的影响。
- **处理 let(rec) 绑定的变量的更新**：提出一种改进方案，解决 let(rec)-bound 变量的更新问题，避免相同更新的问题。
- **消除间接链**：进一步改进更新机制，解决间接链的问题，并优化超级组合子（supercombinator）参数的更新。
- **更新部分应用**：讨论如何处理部分应用（partial application）的更新，以及相应的实现细节。
通过本节的学习，您将深入理解 TIM 中更新机制的实现，以及如何优化更新以提高程序的性能和效率。

**详细解析**

### **4.5 Mark 4: 更新机制**

#### **4.5.1 更新的基本技术**

**背景**

在前面的实现中，TIM 执行的是 **树归约（tree reduction）**，而不是 **图归约（graph reduction）**。这意味着当一个共享的表达式（redex）被多次引用时，我们会重复计算它，而不是计算一次并共享结果。

**问题**

- **重复计算**：共享的表达式被多次计算，导致效率低下。
- **目标**：实现图归约，确保共享的表达式只被计算一次，并将结果更新到原来的位置，以供后续引用。
**TIM 中的更新机制**

由于 TIM 是一个 **无主干的机器（spineless machine）**，它的更新机制需要与 G 机器有所不同。关键的想法是：

- **延迟更新**：不像 G 机器那样在每次归约后进行更新。相反，当开始计算一个闭包（closure）时（即进入闭包时），执行以下步骤：**保存当前状态**：将当前的堆栈和正在进入的闭包的地址压入 **转储（dump）**，这是机器状态的新组件。**设置陷阱（mouse-trap）**：设置一个“陷阱”，当闭包的计算完成时触发。**正常计算**：在一个新的堆栈上正常进行闭包的计算。**触发更新**：当陷阱被触发时，用闭包的正常形式（normal form）更新它，并从转储中恢复旧的堆栈。
**详细解释**

- **陷阱（mouse-trap）**：由于闭包的计算是在一个新的堆栈上进行的，最终计算会停止，因为 Return 指令发现堆栈为空，或者超级组合子被应用的参数不足。此时，表达式已经达到了（头部）正常形式（head normal form），因此应该进行更新。更新后，恢复之前保存的堆栈，继续执行。
**处理整数值的闭包更新**

为了具体说明，我们首先关注 **值为整数类型的闭包** 的更新。

**PushMarker 指令**

- 在进入闭包之前，执行一个新的指令 PushMarker x，它通过将一些信息压入转储来设置更新机制。
- **PushMarker x** 将以下内容压入转储：**当前堆栈**。**当前的帧指针**，它指向要更新的闭包所在的帧。**索引 x**，表示要更新的闭包在帧中的位置。
**状态转换规则（4.15）**

```less
PushMarker x : i   f   s   v   d   h   c
=> i   f   []   v   ((f, x, s) : d)   h   c
```

- **解释**：**指令**：PushMarker x**状态**：**指令序列**：i**帧指针**：f**堆栈**：s**值栈**：v**转储**：d**堆**：h**代码存储**：c**操作**：将当前堆栈 s、帧指针 f 和索引 x 组成的三元组 (f, x, s) 压入转储 d。将堆栈重置为空列表 []，开始在新的堆栈上计算。保持其他状态不变。
**计算完成后的更新**

当闭包的计算完成后，通常会执行 `Return` 指令，但此时堆栈为空，这触发了更新机制。

**状态转换规则（4.16）**

1. **进行更新**
```less
[Return]   f   []   n : v   (fu, x, s) : d   h   c
=> [Return]   f   s   n : v   d   h'   c

其中，h' = h[fu : ..., dx-1, (intCode, n), dx+1, ...]
```

- **解释**：**指令**：Return**堆栈**：为空列表 []。**值栈**：n : v，n 是计算得到的整数值。**转储**：(fu, x, s) : d，包含需要更新的帧指针 fu、索引 x 和保存的堆栈 s。**操作**：用闭包 (intCode, n) 更新帧 fu 中索引为 x 的位置。这里，intCode 是一个特殊的代码序列，当进入时会将整数值 n 压入值栈并返回。从转储中弹出 (fu, x, s)，恢复保存的堆栈 s。重新执行 Return 指令，以处理可能存在的进一步更新。
1. **继续执行**
```ruby
[Return]   f   (i', f') : s   n : v   d   h   c
=> i'   f'   s   n : v   d   h   c
```

- **解释**：**指令**：Return**堆栈**：(i', f') : s，顶部是一个闭包（续延）。**操作**：将闭包 (i', f') 的指令序列 i' 加载到程序计数器。更新帧指针为 f'。继续执行。
**总结**

- **PushMarker** 指令在进入需要更新的闭包之前设置更新机制。
- **Return** 指令在计算完成后触发更新机制，更新闭包，并恢复之前的堆栈。
#### **4.5.2 编译 PushMarker 指令**

**关键问题**

现在，我们需要解决的问题是：**编译器应该在哪里插入 PushMarker 指令？**

- **目标**：确保每个共享的闭包（即 redex）只被计算一次，并在计算完成后用其结果更新原来的位置。
**重要概念**

- **在 TIM 中，"redex" 是一个闭包**。
- **必须小心复制闭包**，因为一旦存在两个副本，就无法共享它们的计算。
**示例**

考虑以下函数定义：

```haskell
g x = h x x
h p q = q - p
```

**当前编译的代码**

对于 `g`，当前生成的代码是：

```haskell
[ Take 1, Push (Arg 1), Push (Arg 1), Enter (Label "h") ]
```

- **问题**：两个 Push (Arg 1) 指令分别从当前帧中获取 x 的副本，然后 h 将独立地计算它们。
- **结果**：x 被重复计算，无法共享。
**解决方案**

- **不复制闭包，而是使用指向它的间接引用**。
- **间接引用（indirection）**：用 Push (Code [Enter (Arg 1)]) 替换 Push (Arg 1)，这将创建一个闭包，其代码序列为 [Enter (Arg 1)]，帧指针为当前帧。
**进一步改进**

- **设置更新机制**：在进入共享的闭包之前，插入 PushMarker 指令。
修改后的代码：

```haskell
Push (Code [PushMarker 1, Enter (Arg 1)])
```

- **解释**：**Push (Code [PushMarker 1, Enter (Arg 1)])**：构建一个闭包，当进入时，首先执行 PushMarker 1，设置更新机制，然后 Enter (Arg 1)，进入闭包 x。
**更新的编译方案**

- **更新间接引用（updating indirection）**：Code [PushMarker n, Enter (Arg n)]，表示对帧中第 n 个闭包的更新间接引用。
- **对于进入参数（arguments）**：**必须使用更新间接引用**：将 Enter (Arg 1) 替换为 Enter (Code [PushMarker 1, Enter (Arg 1)])。
**修改编译方案**

- **编译方案 SC 和 R 的更改**：在构建环境时，将每个变量绑定到一个更新间接寻址模式。例如，在 `let(rec)` 的 `R` 编译方案中，新的环境 `ρ'` 定义为：
```css
ρ' = ρ[x1 → J [[d + 1]], ..., xn → J [[d + n]]]
```
其中，`J [[d]] = Code [PushMarker d, Enter (Arg d)]`
#### **4.5.3 实现更新机制**

为了实现新的更新机制，我们需要做以下更改：

1. **定义转储（Dump）的数据类型**：
```haskell
type TimDump = [(FramePtr, Int, TimStack)]
initialDump = []
```

- **解释**：转储是一个三元组的堆栈，表示需要更新的帧指针、索引和保存的堆栈。初始化为空列表。
2. **添加 PushMarker 指令到指令类型**：
```haskell
data Instruction = Take Int
                 | Enter TimAMode
                 | Push TimAMode
                 | PushMarker Int
                 | Return
                 | ...
```

- 更新 showInstruction 函数，处理新的指令。
3. **修改 step 函数**：
- 添加 PushMarker 指令的处理。
- 修改 Return 指令的处理，以实现更新机制。
4. **修改编译器**：
- **compileSC**：修改 `SC` 编译方案，构建环境时，将变量绑定到更新间接寻址模式。
- **compileR**：在 `let(rec)` 的情况下，构建环境时使用更新间接寻址模式。
- 使用辅助函数 `mkUpdIndMode` 实现 `J` 编译方案：
```haskell
mkUpdIndMode :: Int -> TimAMode
mkUpdIndMode n = Code [PushMarker n, Enter (Arg n)]
```
**练习 4.16**

- **任务**：按照描述实现更新机制。
- **验证**：运行测试程序，观察 PushMarker 如何将更新信息添加到转储，Return 如何执行更新。
**示例测试程序**

```haskell
f x = x + x
main = f (1 + 2)
```

- **期望**：(1 + 2) 的计算只发生一次。
#### **4.5.4 更新机制的问题**

尽管上述更新机制简单，但存在 **效率低下** 的问题。主要有两个问题，由 Argo [Argo 1989] 首次区分。

**问题 1：相同更新（Identical Updates）**

- **描述**：对于像 f x = x + x 这样的函数，f 将对其参数 x 的每次使用都进入一个更新间接引用。
- **结果**：第一次使用时，x 被更新为其值。第二次使用时，再次进行更新，覆盖 x，但这是完全多余的。
- **影响**：导致不必要的重复更新，浪费计算资源。
**问题 2：间接链（Indirection Chains）**

- **描述**：当一个函数将其参数作为参数传递给另一个函数时，更新间接引用会堆叠，形成间接链。
- **示例**：
```haskell
g x = x + x
f y = g y
main = f (1 + 2)
```
f 将对其参数 y 使用更新间接引用。g 对其参数 x 也使用更新间接引用。**结果**：g 进入了一个间接的间接引用，形成了间接链。
- **影响**：间接链会增加计算的开销，降低效率。
**严重情况**

- **尾递归函数**：
```haskell
horrid n m = if (n = 0) m (horrid (n - 1) m)
```
在这种情况下，每次递归调用都会在 m 上添加一个间接引用，导致大量的间接链堆积。
**结论**

- 这两个问题需要解决，以提高更新机制的效率。
#### **4.5.5 更新 let(rec)-bound 变量**

**改进思路**

- 对于 let(rec) 绑定的变量，我们可以采用一种更好的方法，避免相同更新的问题。
**示例**

考虑以下超级组合子定义：

```haskell
f x = let y = ...
      in g y y
```

- 其中，... 是 y 的任意右侧表达式。
**当前生成的代码**

```haskell
f:
  Take 2
  Move 2 (Code [...code for y...])
  Push (Code [PushMarker 2, Enter (Arg 2)])  -- 对 y 的更新间接引用
  Push (Code [PushMarker 2, Enter (Arg 2)])  -- 对 y 的更新间接引用
  Enter (Label "g")
```

- **问题**：y 的每次使用都进行了更新间接引用，可能导致相同更新的问题。
**改进后的代码**

```haskell
f:
  Take 2
  Move 2 (Code (PushMarker 2 : [...code for y...]))  -- y 的自更新闭包
  Push (Code [Enter (Arg 2)])  -- 对 y 的非更新间接引用
  Push (Code [Enter (Arg 2)])  -- 对 y 的非更新间接引用
  Enter (Label "g")
```

- **解释**：**自更新闭包**：在 Move 指令中，为 y 构建一个自更新闭包，其代码以 PushMarker 2 开始。**非更新间接引用**：在使用 y 时，使用非更新的间接引用 Code [Enter (Arg 2)]。
**优点**

- **避免相同更新**：y 的更新只发生一次，因为自更新闭包在第一次进入时会进行更新，之后就不再发生。
- **简化代码**：减少了更新间接引用的使用。
**一般思路**

- **对 let(rec) 绑定的变量**：**在定义处**：为每个右侧表达式构建一个 **自更新闭包**，即在代码序列的开头添加 PushMarker 指令。
- **在使用处**：**使用非更新的间接引用**，即 Code [Enter (Arg n)]。
**实现修改**

1. **修改 R 编译方案**：
- 在构建环境时，对 let(rec) 绑定的变量，使用非更新间接引用寻址模式 I。
2. **引入新的编译方案 U**：
- 用于在 `let(rec)` 的 `R` 编译方案中编译定义的右侧表达式。
- **U 编译方案**：**输入**：表达式 e，更新位置 u，环境 ρ，起始帧槽位置 d。**输出**：更新后的帧槽位置 d'，寻址模式 am。**操作**：生成代码序列，以 PushMarker u 开头，用于构建自更新闭包。
- **R 编译方案中 let 的修改**（参见 **图 4.4**）：对每个右侧表达式 ei，使用 U 编译方案。构建新的环境 ρ'，将变量绑定到非更新间接引用寻址模式 I。
**练习 4.18**

- **任务**：尝试这个想法，测量其在节省步骤方面的有效性。
**练习 4.19**

- **问题**：对于已经是正常形式的表达式（如整数常量），在 `U` 编译方案中生成 `PushMarker` 指令是多余的。
- **解决方案**：修改 `U` 编译方案，对于正常形式的表达式，直接返回 `IntConst` 寻址模式。
- **任务**：修改 `U` 编译方案和相应的 `compileU` 函数，验证修改的正确性。
#### **4.5.6 消除间接链**

**改进思路**

- 之前的改进解决了 let(rec)-bound 变量的相同更新问题。
- 现在，我们希望扩展这个思路，**消除超级组合子参数的相同更新和间接链问题**。
**新策略**

- **调用约定**：采用以下约定：**每个参数闭包都可以自由复制而不会丢失共享**。
- **解释**：这样，被调用的函数可以自由地复制参数闭包，无需担心重复计算。避免了因为间接链导致的效率问题。
**如何实现**

- **分析参数**：**常量**：闭包可以自由复制。**超级组合子**：闭包可以自由复制。**let(rec)-bound 变量**：使用前面的改进，闭包可以自由复制。**当前超级组合子的参数**：根据新约定，可以自由复制。**非原子表达式**：需要特殊处理。
- **处理非原子表达式**：**目标**：将非原子表达式的闭包转换为可自由复制的形式。**方法**：将表达式转换为 `let` 绑定的形式。**示例**：
```haskell
f (factorial 20)
```
转换为：
```haskell
let arg = factorial 20 in f arg
```
**效果**：为 arg 构建一个自更新闭包。将 arg 作为参数传递给 f，可以自由复制。
**重新编写编译方案**

- **修改 R 编译方案**（参见 **图 4.5**）：**应用表达式的两种情况**：**参数是原子表达式**（超级组合子、本地变量或常量）：
```haskell
R[[e a]] ρ d = (d1, Push (A[[a]] ρ) : is)
```
使用 A 编译方案生成寻址模式。**参数是非原子表达式**：
```haskell
R[[e_fun e_arg]] ρ d = (d2, Move (d + 1) am_arg : Push (Code [Enter (Arg (d + 1))]) : is_fun)
```
使用 U 编译方案为参数表达式 e_arg 构建自更新闭包，存储在新的帧槽 d + 1 中。将非更新的间接引用 Code [Enter (Arg (d + 1))] 压入堆栈。
- **修改 A 编译方案**：仅处理原子表达式（变量或常量），不再处理非原子表达式。不需要帧槽位置 d，因为不再使用帧槽。
**练习 4.20**

- **任务**：实现这个修订后的编译方案，测量与之前版本的性能差异。
**结论**

- **效果**：消除了间接链和相同更新的问题，提高了更新机制的效率。
- **观察**：TIM 在这种优化下，更加接近 G 机器的行为，特别是在参数传递和更新方面。
#### **4.5.7 更新部分应用**

**问题**

- **部分应用**：当一个函数被应用的参数少于其参数列表时，返回一个部分应用的闭包。
- **在更新机制中，如何处理部分应用的更新？**
**示例**

```haskell
add a b = a + b
twice f x = f (f x)
g x = add (x * x)
main = twice (g 3) 4
```

- **分析**：g 3 计算得到 add (3 * 3)，这是对 add 的部分应用（仅有一个参数）。twice 传递了 g 3 作为 f 的参数，需要处理部分应用的更新。
**解决方案**

- **当 Take 指令发现堆栈上的参数不足时，需要执行更新**。
- **步骤**：**在 Take 指令之前添加 UpdateMarkers 指令**。**UpdateMarkers**：检查堆栈上的参数数量。如果参数不足，触发更新机制。
**状态转换规则（4.17）**

1. **参数足够的情况**
```less
UpdateMarkers n : i   f   c1 : ... : cm : s   v   d   h   c
=> i   f   c1 : ... : cm : s   v   d   h   c   （当 m ≥ n 时）
```

- **解释**：**参数足够**：堆栈上的参数数量 m 大于等于 n。**操作**：UpdateMarkers 什么都不做，继续执行。
1. **参数不足的情况**
```less
UpdateMarkers n : i   f   c1 : ... : cm : []   v   (fu, x, s') : d   h   c
=> UpdateMarkers n : i   f   c1 : ... : cm : s'   v   d   h'   c   （当 m < n 时）

其中，h' = h[fu : ..., dx-1, (i', f'), dx+1, ...]
```

- **解释**：**参数不足**：堆栈上的参数数量 m 小于 n。**操作**：从转储中弹出 (fu, x, s')。**更新闭包**：用部分应用的闭包 (i', f') 更新帧 fu 中索引为 x 的位置。**新的堆栈**：将当前堆栈 c1 : ... : cm 压在保存的堆栈 s' 上。**重新执行**：重新执行 UpdateMarkers n，以处理可能存在的进一步更新。
**构建部分应用的闭包**

- **闭包 (i', f')**：**代码指针 i'**：构建一个代码序列，包含：
```haskell
Push (Arg m)
...
Push (Arg 1)
UpdateMarkers n
i   （原始的指令序列）
```
**解释**：将部分应用的参数压入堆栈，执行 `UpdateMarkers`，然后继续执行原始的指令序列 `i`。**帧指针 f'**：指向一个新的帧，包含参数闭包 c1, ..., cm。
**注意事项**

- **复制参数闭包**：由于之前的修改，参数闭包可以自由复制，因此在构建新的帧时复制参数闭包是安全的。
**练习 4.21**

- **任务**：实现 `UpdateMarkers` 指令，修改编译器，在每个 `Take` 指令之前插入一个 `UpdateMarkers` 指令。
- **测试程序**：
```haskell
pair x y f = f x y
fst p = p K
snd p = p K1
main = let w = pair 2 3
       in (fst w) * (snd w)
```
**目标**：观察 w 被更新为 (pair 2 3) 的部分应用。
- **进一步测试**：修改 `w` 的右侧表达式，使其更复杂，例如：
```haskell
main = let w = if (2 * 3 > 4) (pair 2 3) (pair 3 2)
       in (fst w) * (snd w)
```
**练习 4.22**

- **优化**：当 `n = 0` 时，`UpdateMarkers 0` 没有任何作用。
- **任务**：修改 `compileSC`，在适当的时候省略 `UpdateMarkers` 和 `Take` 指令。
- **提示**：这与之前的练习 4.3 类似。
**额外说明**

- **实际实现中的优化**：在实际实现中，不需要每次更新都重新构建代码序列 i'。可以预先定义部分应用的代码序列，直接引用。
- **参数复制的安全性**：由于之前的修改，参数闭包可以自由复制，因此在更新时复制参数是安全的。
- **优化调用已知超级组合子的情况**：如果调用的超级组合子被应用的参数数目足够，UpdateMarkers 一定不会触发更新。可以优化编译器，在这种情况下，直接进入超级组合子的代码，省略 UpdateMarkers。
**全面详尽的总结**

在本节中，我们深入探讨了 TIM（Three Instruction Machine）中的更新机制，实现图归约以避免重复计算共享的表达式。通过引入更新机制，我们确保共享的闭包（redex）只被计算一次，其结果被缓存供后续使用。

**主要内容回顾**：

1. **更新的基本技术**：
- **更新机制的引入**：通过在进入闭包之前使用 PushMarker 指令，设置更新机制，将当前堆栈和需要更新的闭包信息保存到转储（dump）。
- **更新的触发**：当计算完成后，Return 指令发现堆栈为空，触发更新机制，用计算结果更新闭包，并恢复之前的堆栈。
2. **编译 PushMarker 指令**：
- **关键问题**：确定编译器应该在哪里插入 PushMarker 指令。
- **解决方案**：在构建环境时，将变量绑定到更新间接引用，使用 Code [PushMarker n, Enter (Arg n)]。
3. **更新机制的问题**：
- **相同更新问题**：同一闭包被多次更新，导致效率低下。
- **间接链问题**：更新间接引用堆叠，形成间接链，增加计算开销。
4. **处理 let(rec)-bound 变量的更新**：
- **改进方案**：在定义处构建自更新闭包（self-updating closure），使用 PushMarker 指令。
- **使用处优化**：在使用 let(rec)-bound 变量时，使用非更新的间接引用，避免相同更新问题。
5. **消除间接链**：
- **新的调用约定**：每个参数闭包都可以自由复制，不会丢失共享。
- **实现方法**：对于非原子表达式的参数，使用 let 表达式，将其转换为可自由复制的闭包。
- **编译方案的修改**：调整 R 和 A 编译方案，处理参数传递和更新。
6. **更新部分应用**：
- **问题**：当函数被部分应用时，如何处理更新。
- **解决方案**：在 Take 指令之前插入 UpdateMarkers 指令，检查参数数量，不足时触发更新机制。
- **构建部分应用的闭包**：构建包含参数的闭包和相应的代码序列，处理更新。
**重要的概念和技巧**：

- **更新机制的实现**：通过 PushMarker 和 Return 指令，配合转储，实现闭包的更新。
- **自更新闭包（Self-updating Closure）**：在闭包的代码序列开头添加 PushMarker 指令，使其在第一次进入时自我更新。
- **消除相同更新和间接链**：优化更新机制，避免效率低下的问题。
- **自由复制的参数闭包**：采用新的调用约定，使参数闭包可以自由复制，简化了更新机制。
- **编译器的调整**：修改编译方案和编译器，实现新的更新策略和优化。
**总结**

通过本节的学习，我们深入理解了 TIM 中更新机制的实现，以及如何优化更新以提高程序的性能和效率。我们解决了在初始更新机制中存在的相同更新和间接链问题，提出了更高效的更新策略。

这些优化使得 TIM 更加接近 G 机器的行为，特别是在参数传递和更新方面。通过引入自由复制的参数闭包和自更新闭包，我们大大简化了更新机制，同时提高了程序的执行效率。

在后续的章节中，我们将继续探讨 TIM 的其他优化和特性，进一步完善函数式语言的实现。
 #  
 Thought for 1m 21s
**概览**

本节（**4.6 Mark 5: 结构化数据**）深入探讨了如何在 TIM（Three Instruction Machine，三指令机器）中添加 **代数数据类型（algebraic data types）** 的支持。虽然可以通过高阶函数来实现数据结构（参见 **2.8.3 节**），但这种方法效率较低。因此，本节借鉴了我们在算术运算中使用的方法，来处理更一般的数据结构。

我们将探讨以下内容：

- **一般方法**：如何处理数据结构，特别是列表和模式匹配的实现。
- **编译方案和过渡规则**：详细介绍如何修改编译器和机器的过渡规则，以支持新的指令和数据结构。
- **实践应用**：通过示例程序，测试新的实现，并观察更新机制的正确性。
- **打印列表**：讨论如何让程序返回并打印列表，而不仅仅是整数。
- **直接使用数据结构**：探讨为什么不能直接在 Switch 指令的分支中使用数据结构的组件，并提供解释。
通过本节的学习，您将了解如何在 TIM 中实现数据结构，特别是列表，以及如何在机器中支持模式匹配和构造函数。同时，您将理解在编译器和评估器中需要进行哪些修改，以支持这些新的特性。

**详细解析**

### **4.6 Mark 5: 结构化数据**

#### **4.6.1 一般方法**

**背景**

- 之前，我们可以使用高阶函数来实现数据结构（参见 **2.8.3 节**），但这种方法效率低下。
- 为了提高效率，我们希望在 TIM 中直接支持代数数据类型，如列表和模式匹配。
**目标**

- 添加对代数数据类型的支持，使得 TIM 可以高效地处理结构化数据。
- 借鉴我们在算术运算中使用的方法，扩展到更一般的数据结构。
**示例：实现 is_empty 函数**

我们首先考虑一个简单的函数 `is_empty`，它判断列表是否为空，返回 `1` 表示空，返回 `0` 表示非空。

**代码**

```haskell
is_empty xs = case xs of
  <1> -> 1
  <2> y ys -> 0
cons a b = Pack{2,2} a b
nil = Pack{1,0}
main = is_empty (cons 1 nil)
```

**解释**

- **Pack{tag, arity}**：构造函数的表示方式，其中 tag 是标签，arity 是元数（参数数量）。nil（空列表）：Pack{1,0}，标签为 1，元数为 0。cons（构造非空列表）：Pack{2,2}，标签为 2，元数为 2。
- **case 表达式**：用于模式匹配，根据 xs 的值进行分支。
**编译 case 表达式**

- 与算术运算符需要对其参数求值类似，case 表达式需要对 xs 求值。
- 然后，根据返回对象的标签（tag）进行多路跳转。
**实现方案**

借鉴我们在算术运算中使用的方法，提出以下约定：

1. **评估数据对象的闭包**：
- 将一个 **续延（continuation）** 压入参数堆栈，然后进入要评估的闭包。
2. **评估到头部正常形式（head normal form）** 后：
- 从堆栈中弹出续延并进入。
3. **返回数据对象的标签（tag）**：
- 将标签压入 **值栈（value stack）** 的顶部。
4. **返回数据对象的组件（components）**：
- 如果有组件（如 cons 的 a 和 b），则在一个由新寄存器 **数据帧指针（data frame pointer）** 指向的帧中返回。
**is_empty 的代码**

```haskell
is_empty:
  Take 1 1               -- 一个参数
  Push (Label "cont")    -- 压入续延
  Enter (Arg 1)          -- 评估 xs
cont:
  Switch [
    1 -> [PushV (IntVConst 1), Return],
    2 -> [PushV (IntVConst 0), Return]
  ]
```

**解释**

- **Take 1 1**：取一个参数，初始化帧。
- **Push (Label "cont")**：将续延压入参数堆栈。
- **Enter (Arg 1)**：进入参数 xs 的闭包，开始评估 xs。
- **cont 标签**：**Switch 指令**：根据值栈顶部的标签进行多路跳转。**1 -> [PushV (IntVConst 1), Return]**：如果标签为 1，压入整数常量 1，然后返回。**2 -> [PushV (IntVConst 0), Return]**：如果标签为 2，压入整数常量 0，然后返回。
**Switch 指令**

- **作用**：根据值栈顶部的值（标签），进行多路跳转，执行对应的指令序列。
**使用数据对象的组件**

在上述 `is_empty` 函数中，我们没有使用列表节点的组件。现在考虑一个需要使用组件的函数，例如 `sum` 函数：

```haskell
sum xs = case xs of
  <1> -> 0
  <2> y ys -> y + sum ys
```

- **sum 函数**：计算列表中元素的和。
- **新的特性**：在表达式 y + sum ys 中，使用了列表节点的组件 y 和 ys。
**如何获取组件**

- **数据帧指针（data frame pointer）**：当评估 xs 后，组件 y 和 ys 会在一个由 **数据帧指针** 指向的帧中返回。**问题**：为什么不能使用普通的帧指针？**答案**：因为评估组件时，可能需要改变帧指针，导致无法正确访问组件。
**sum 的代码**

```haskell
sum:
  Take 3 1                -- 一个参数，两个额外的槽位用于 y 和 ys
  Push (Label "cont")     -- 压入续延
  Enter (Arg 1)           -- 评估 xs
cont:
  Switch [
    1 -> [PushV (IntVConst 0), Return],
    2 -> [
      Move 2 (Data 1),    -- 将 y 移动到当前帧的槽位 2
      Move 3 (Data 2),    -- 将 ys 移动到当前帧的槽位 3
      ...                 -- 计算 y + sum ys 的代码
    ]
  ]
```

**解释**

- **Take 3 1**：取一个参数，帧有 3 个槽位（1 个参数槽位，2 个用于 y 和 ys）。
- **Move 指令**：**Move 2 (Data 1)**：将数据帧中第 1 个组件（y）复制到当前帧的槽位 2。**Move 3 (Data 2)**：将数据帧中第 2 个组件（ys）复制到当前帧的槽位 3。
- **Data 寻址模式**：用于访问数据帧指针指向的帧中的闭包。
**总结**

一个 `case` 表达式的编译包括以下五个步骤：

1. **压入续延**：将续延压入参数堆栈。
2. **评估被检查的闭包**：进入要评估的闭包，当其评估完成后，会进入步骤 1 中压入的续延。
3. **执行 Switch 指令**：续延使用 Switch 指令，根据值栈顶部的标签进行多路跳转。
4. **移动数据对象的组件**：
- 每个 Switch 的分支开始时，使用 Move 指令将数据对象的组件复制到当前帧。
- **注意**：复制闭包时，必须确保闭包可以自由复制（参见 **4.5.6 节**）。
5. **执行分支的代码**：每个分支继续执行其对应的代码，按照通常方式编译。
**生成构造函数的代码**

现在，我们考虑如何为 `Pack{tag, arity}` 表达式生成代码。例如，表达式：

```haskell
Pack{1,2} e1 e2
```

- **作用**：构建一个列表节点（cons）。
**生成的代码**

```haskell
Push (...e2 的寻址模式...)
Push (...e1 的寻址模式...)
Enter (Label "Pack{1,2}")
```

**解释**

- 将 e2 和 e1 的闭包压入参数堆栈。
- 进入标签为 Pack{1,2} 的代码，执行构造函数。
**Pack{1,2} 的代码**

```haskell
Pack{1,2}:
  UpdateMarkers 2
  Take 2 2
  ReturnConstr 1
```

**解释**

- **UpdateMarkers 2**：检查是否需要更新。
- **Take 2 2**：取两个参数，构建一个包含两个组件的帧，将指针存储在当前帧指针中。
- **ReturnConstr 1**：进入续延。将标签 1 压入值栈。将当前帧指针复制到数据帧指针。**注意**：ReturnConstr 需要检查是否需要更新，并在必要时执行更新。
#### **4.6.2 数据结构的过渡规则和编译方案**

现在，我们详细说明新的构造的过渡规则和编译方案。

**Switch 指令的过渡规则（4.18）**

```less
[Switch [... t -> i ...]]   f   fd   s   t : v   d   h   c
=> i   f   fd   s   v   d   h   c
```

- **解释**：**指令**：Switch，根据值栈顶部的标签 t，跳转到对应的指令序列 i。**fd**：数据帧指针，指向数据对象的组件所在的帧。**操作**：加载对应的指令序列 i，继续执行。
**ReturnConstr 指令**

`ReturnConstr` 有两个过渡规则，因为它需要考虑可能需要更新的情况。

1. **没有需要更新的情况（4.19）**
```csharp
[ReturnConstr t]   f   fd   (i', f') : s   v   d   h   c
=> i'   f'   f   s   t : v   d   h   c
```

- **解释**：**指令**：ReturnConstr t**堆栈**：顶部是续延 (i', f')。**操作**：将续延 (i', f') 的指令序列 i' 加载到程序计数器。更新帧指针为 f'。将标签 t 压入值栈。将当前帧指针 f 复制到数据帧指针 fd。继续执行。
1. **需要更新的情况（4.20）**
```css
[ReturnConstr t]   f   fd   []   v   (fu, x, s) : d   h   c
=> [ReturnConstr t]   f   fd   s   v   d   h'   c

其中，h' = h[fu : ..., d_{x-1}, ([ReturnConstr t], f), d_{x+1}, ...]
```

- **解释**：**指令**：ReturnConstr t**堆栈**：为空 []，触发更新机制。**转储**：(fu, x, s) : d，需要更新的闭包信息。**操作**：用闭包 ([ReturnConstr t], f) 更新帧 fu 中索引为 x 的位置。恢复保存的堆栈 s。重新执行 ReturnConstr t 指令，以处理可能存在的进一步更新。
**编译方案的修改**

- **R 编译方案**：增加对构造函数和 case 表达式的处理。
- **辅助编译方案 E**：用于编译 case 表达式的分支。
**R 编译方案的修改（见图 4.6）**

1. **构造函数的编译**
```lua
R[[Pack{t,a}]] ρ d = (d, [UpdateMarkers a, Take a a, ReturnConstr t])
```

- **解释**：构造函数直接编译为指令序列 [UpdateMarkers a, Take a a, ReturnConstr t]。
1. **case 表达式的编译**
```lua
R[[case e of alt1 ... altn]] ρ d = (d', Push (Code [Switch [branch1 ... branchn]]) : is_e)

其中，
(d1, branch1) = E[[alt1]] ρ d
...
(dn, branchn) = E[[altn]] ρ d
(d', is_e) = R[[e]] ρ max(d1, ..., dn)
```

- **解释**：编译 case 表达式为：先编译被检查的表达式 e，得到指令序列 is_e。将 Switch 指令的分支 branch1 ... branchn 编译出来。使用 Push (Code [Switch ...]) 压入续延。
**E 编译方案**

- **用于编译 case 表达式的分支**。
```lua
E[[ x1 ... xn -> body]] ρ d = (d', t -> (is_moves ++ is_body))

其中，
is_moves = [Move (d + 1) (Data 1), ..., Move (d + n) (Data n)]
(d', is_body) = R[[body]] ρ' (d + n)
ρ' = ρ[x1 -> Arg (d + 1), ..., xn -> Arg (d + n)]
```

- **解释**：**is_moves**：使用 Move 指令，将数据对象的组件复制到当前帧的槽位中。**新的环境 ρ'**：将模式中的变量绑定到新的槽位。**编译 body**：使用新的环境 ρ' 编译分支的主体。
#### **4.6.3 实践应用**

现在，我们可以使用新的机制来实现列表和布尔值，使用以下 Core 语言定义：

```haskell
cons = Pack{2,2}
nil = Pack{1,0}
true = Pack{2,0}
false = Pack{1,0}
if cond tbranch fbranch = case cond of
  <1> -> fbranch
  <2> -> tbranch
```

**注意**

- 之前，我们为 if 添加了特殊的指令和编译方案。
- 现在，if 只是一个普通的超级组合子，可以像其他组合子一样处理。
- 在编译器中，可以保留对 if 的特殊处理，但现在可以生成 Switch 指令，而不需要 Cond 指令。
**练习 4.23**

- **任务**：实现新的指令和编译方案。
- **测试程序**：
```haskell
length xs = case xs of
  <1> -> 0
  <2> p ps -> 1 + length ps
main = length (cons 1 (cons 2 nil))
```
- **目标**：验证新实现是否正确计算列表的长度。
**更有趣的示例**

- **程序**：
```haskell
append xs ys = case xs of
  <1> -> ys
  <2> p ps -> cons p (append ps ys)
main = let xs = append (cons 1 nil) (cons 2 nil)
       in length xs + length xs
```
- **解释**：xs 被使用了两次，但 append 的工作应该只进行一次。这个示例可以验证更新机制是否正确工作。
**练习 4.24**

- **问题**：如果构造函数的元数 a 为零，R[[Pack{t,a}]] 会生成 [UpdateMarkers 0, Take 0 0, ReturnConstr t]。
- **任务**：优化 R 编译方案和 compileR 函数，为这种情况生成更好的代码（类似于练习 4.22）。
#### **4.6.4 打印列表**

之前的示例程序都返回整数。现在，我们希望程序能够返回并打印列表。

**解决方案**

- **输出组件**：在机器状态中添加一个额外的组件，用于表示输出。
- **Print 指令**：从值栈中消费一个数字，将其添加到输出中。
**修改 compile 函数**

- **当前**：compile 使用续延 ( [], FrameNull ) 初始化堆栈，当进入时机器停止。
- **修改**：将续延改为执行打印操作的代码。
**新的续延**

```haskell
topCont:
  Switch [
    1 -> [],                 -- 如果列表为空，机器停止
    2 -> [
      Move 1 (Data 1),       -- 头部元素
      Move 2 (Data 2),       -- 尾部列表
      Push (Label "headCont"),
      Enter (Arg 1)          -- 评估头部元素
    ]
  ]
headCont:
  Print,
  Push (Label "topCont"),
  Enter (Arg 2)              -- 对尾部列表执行相同操作
```

**解释**

- **topCont**：**Switch 指令**：根据列表是否为空进行分支。如果列表为空（标签为 1），则没有指令，机器停止。如果列表非空（标签为 2）：使用 Move 指令将头部元素和尾部列表复制到当前帧。压入续延 headCont。进入头部元素的闭包，评估头部元素。
- **headCont**：**Print 指令**：从值栈中消费一个数字，添加到输出中。压入续延 topCont，对尾部列表执行相同的操作。
**注意**

- **topCont 需要一个具有 2 个槽位的帧**，用于存储头部和尾部。
- **compile 函数需要为 topCont 分配这个帧**，并在初始化堆栈时使用 (topCont, frame)。
**练习 4.25**

- **任务**：按照描述实现列表打印功能。
- **注意**：需要在机器状态中添加一个额外的组件（输出）。
- **提示**：可以使用 Push (Code ...) 代替 Push (Label "headCont")，甚至可以对 topCont 做同样的处理，使用一些递归技巧。
**测试程序**

```haskell
between n m = if (n > m) nil (cons n (between (n + 1) m))
main = between 1 4
```

- **目标**：生成并打印从 1 到 4 的列表。
**练习 4.26**

- **问题**：希望在程序运行时，随着元素变得可用，立即打印列表元素。
- **当前问题**：使用 showFullResults：会打印所有的状态，输出过多。使用 showResults：只打印最后的状态，直到程序结束才有输出。
- **任务**：修改 `showResults`，使其在产生输出时打印。**方法**：比较连续的状态对中的输出组件，当输出变长时，打印新增加的元素。
- **其他改进**：在每个状态（或每十个状态）打印一个点，以粗略表示每个输出步骤之间的工作量。
#### **4.6.5 直接使用数据结构**

**问题**

- **为什么不能直接在 Switch 指令的分支中，使用数据结构的组件？**
- **即**：在 Switch 分支中，使用 Data 寻址模式，而不需要 Move 指令。
**答案**

- **示例**：再次考虑 `sum` 函数：
```haskell
sum xs = case xs of
  <1> -> 0
  <2> y ys -> y + sum ys
```
- **分析**：在计算 y + sum ys 时，需要首先评估 y，这可能需要大量计算，并可能改变 **数据帧指针**。当需要评估 ys 时，数据帧指针可能已经改变，无法再访问 ys。
- **结论**：通过将数据对象的组件移动到当前帧，我们可以在后续的计算中保留它们。
**优化可能性**

- **特殊情况**：当组件不需要进一步评估时，可以直接使用数据帧中的组件。
- **示例**：`head` 函数
```haskell
head xs = case xs of
  <1> -> error
  <2> y ys -> y
```
- **优化**：在第二个分支中，可以直接使用 Enter (Data 1)，无需 Move 指令。
- **类似地**，如果在 `case` 表达式的某个分支中，变量未被使用，则无需将其移动到当前帧。
**全面详尽的总结**

在本节中，我们详细讨论了如何在 TIM（Three Instruction Machine）中添加对代数数据类型的支持，以高效地处理结构化数据，如列表和布尔值。通过引入新的指令和编译方案，我们成功地在 TIM 中实现了数据结构的支持。

**主要内容回顾**：

1. **一般方法**：
- 通过将续延压入参数堆栈，然后进入要评估的闭包，实现对数据对象的评估。
- 使用 Switch 指令，根据值栈顶部的标签进行多路跳转。
- 引入 **数据帧指针（data frame pointer）**，用于指向数据对象的组件所在的帧。
2. **编译方案和过渡规则**：
- **Switch 指令**：根据标签跳转到对应的指令序列。
- **ReturnConstr 指令**：用于返回构造函数的结果，处理可能的更新。
- 修改了 **R 编译方案**，增加了对构造函数和 case 表达式的处理。
- 引入了辅助编译方案 **E**，用于编译 case 表达式的分支。
3. **实践应用**：
- 实现了列表和布尔值，测试了 length 和 append 等函数。
- 验证了更新机制的正确性，确保共享的工作只被执行一次。
4. **打印列表**：
- 添加了输出组件和 Print 指令，使得程序可以返回并打印列表。
- 修改了初始的续延，使其能够处理列表的打印。
5. **直接使用数据结构**：
- 讨论了为什么不能直接在 Switch 指令的分支中使用数据结构的组件。
- 解释了在某些情况下，需要将组件移动到当前帧，以确保后续计算中可以访问它们。
**重要的概念和技巧**：

- **数据帧指针（Data Frame Pointer）**：用于指向数据对象的组件所在的帧，解决了在评估组件时帧指针可能改变的问题。
- **Switch 指令**：实现了模式匹配的多路跳转，基于值栈顶部的标签。
- **ReturnConstr 指令**：用于返回构造函数的结果，并处理更新机制。
- **闭包的自由复制**：为了安全地复制数据对象的组件，必须确保闭包可以自由复制，不会丢失共享或导致重复计算。
- **编译器的扩展**：通过修改编译方案和编译器，实现了对数据结构和模式匹配的支持。
**总结**

通过本节的学习，我们成功地在 TIM 中添加了对代数数据类型的支持，实现了高效的结构化数据处理。我们深入理解了如何在机器中实现模式匹配、构造函数，以及如何处理数据对象的组件。

这些改进使得 TIM 能够处理更复杂的程序和数据结构，提高了语言的表达能力和运行效率。同时，我们学会了如何在编译器和评估器中进行必要的修改，以支持新的语言特性。

在后续的章节中，我们将继续探讨 TIM 的其他优化和特性，进一步完善函数式语言的实现。
 #  
 Thought for 22 seconds
**概览**

本节（**4.8 总结**）总结了 TIM（Three Instruction Machine，三指令机器）的最终编译方案，并在 **图 4.7** 和 **图 4.8** 中给出了详细的编译规则。这些编译方案涵盖了如何将函数式语言的表达式编译为 TIM 指令序列，包括超级组合子（supercombinator）、表达式、构造函数、`case` 表达式等。

作者提出了一个明显的问题：“TIM 比 G 机器更好还是更差？” 这个问题难以回答，因为我们的原型对于探索设计选择非常有用，但在进行严肃的性能比较时却不够好。作者指出，探索另一种评估模型（如 TIM）可能非常有启发性，因为它提出了结合 TIM 和 G 机器方面的其他设计途径。例如，**Spineless Tagless G-machine（STG 机器）** 就是尝试这样做的一种方法，它采用了 TIM 的无主干性（spinelessness）和更新机制，但其堆栈由指向堆对象的指针组成（如 G 机器），而不是 TIM 中的代码-帧对。

在本节中，我们将深入解析 TIM 的最终编译方案，详细解释各个编译规则，包括：

- **SC 编译方案**：超级组合子的编译规则。
- **R 编译方案**：表达式的编译规则。
- **E 编译方案**：case 表达式分支的编译规则。
- **U 编译方案**：处理 let 和 letrec 绑定的变量的编译规则。
- **A 编译方案**：生成寻址模式的规则。
- **I 编译方案**：生成间接寻址模式的规则。
- **B 编译方案**：用于编译值为整数或算术表达式的表达式。
通过对这些编译方案的详细解析，我们将全面理解 TIM 的编译过程，以及它如何处理不同类型的表达式和结构。

**详细解析**

### **4.8 总结**

在之前的章节中，我们逐步构建了 TIM 的功能，包括处理算术运算、更新机制、结构化数据等。现在，我们将在 **图 4.7** 和 **图 4.8** 中总结 TIM 的最终编译方案。这些编译方案定义了如何将高层次的函数式语言表达式编译为 TIM 的指令序列。

#### **TIM 编译方案概述**

TIM 的编译方案主要包括以下几个部分：

1. **SC 编译方案（SC[[def]] ρ）**：用于编译超级组合子定义。
2. **R 编译方案（R[[e]] ρ d）**：用于编译一般表达式。
3. **E 编译方案（E[[alt]] ρ d）**：用于编译 case 表达式的分支。
4. **U 编译方案（U[[e]] u ρ d）**：用于编译 let 和 letrec 绑定的变量。
5. **A 编译方案（A[[e]] ρ）**：用于生成表达式的 TIM 寻址模式。
6. **I 编译方案（I[[d]]）**：用于生成间接寻址模式。
7. **B 编译方案（B[[e]] ρ d cont）**：用于编译值为整数或算术表达式的表达式。
接下来，我们将详细解释每个编译方案的规则和作用。

#### **1. SC 编译方案**

**定义**：

- **SC[[def]] ρ** 是在环境 ρ 下编译超级组合子定义 def 的 TIM 代码。
**规则**：

```haskell
SC[[f x1 ... xn = e]] ρ = UpdateMarkers n : Take d' n : is
```

- **解释**：**UpdateMarkers n**：在 Take 指令之前插入 UpdateMarkers 指令，用于处理可能的更新。**Take d' n**：取 n 个参数，构建一个具有 d' 个槽位的帧。d' 是在编译表达式 e 时使用的最大帧槽位数。**is**：编译表达式 e 的指令序列。
**环境**：

- 在编译表达式 `e` 时，环境 `ρ` 被扩展，绑定超级组合子的参数：
```haskell
ρ[x1 → Arg 1, ..., xn → Arg n]
```
#### **2. R 编译方案**

**定义**：

- **R[[e]] ρ d** 是一个二元组 (d', is)，其中 is 是在环境 ρ 下编译表达式 e 的 TIM 代码。
- 代码假设帧的前 d 个槽位已被占用，使用槽位 (d + 1 ... d')。
**规则**：

1. **处理整数或算术表达式**：
```haskell
R[[e]] ρ d = B[[e]] ρ d [Return]
```

- **解释**：如果 e 是一个整数或算术表达式，使用 B 编译方案编译它，然后在指令序列后添加 [Return]。
2. **处理超级组合子或本地变量**：
```haskell
R[[a]] ρ d = (d, [Enter (A[[a]] ρ)])
```

- **解释**：如果 a 是超级组合子或本地变量，生成指令 [Enter (A[[a]] ρ)]。
3. **处理应用表达式，参数为原子表达式**：
```haskell
R[[e a]] ρ d = (d1, Push (A[[a]] ρ) : is)
```

- **条件**：`a` 是超级组合子、本地变量或整数。
- **解释**：编译 e，得到指令序列 is。将 a 的寻址模式压入堆栈。
4. **处理应用表达式，参数为非原子表达式**：
```haskell
R[[e_fun e_arg]] ρ d = (d2, Move (d + 1) am_arg : Push I[[d + 1]] : is_fun)
```

- **解释**：使用 U 编译方案编译参数表达式 e_arg，结果存储在帧槽位 d + 1。将间接寻址模式 I[[d + 1]] 压入堆栈。编译函数表达式 e_fun，得到指令序列 is_fun。
5. **处理 let 表达式**：
```haskell
R[[let x1 = e1; ... ; xn = en in e]] ρ d = (d', moves ++ is)
```

- **解释**：使用 U 编译方案编译每个绑定的表达式 ei，结果存储在帧槽位 d + i。构建新的环境 ρ'，将 xi 绑定到间接寻址模式 I[[d + i]]。编译表达式 e，使用新的环境 ρ'。
#### **3. E 编译方案**

**定义**：

- **E[[alt]] ρ d** 是一个二元组 (d', branch)，其中 branch 是在环境 ρ 下编译的 Switch 分支。
- 代码假设帧的前 d 个槽位已被占用，使用槽位 (d + 1 ... d')。
**规则**：

```haskell
E[[ x1 ... xn -> body]] ρ d = (d', t -> (is_moves ++ is_body))
```

- **解释**：**is_moves**：将数据对象的组件移动到当前帧的指令序列。
```haskell
is_moves = [Move (d + 1) (Data 1), ..., Move (d + n) (Data n)]
```
**新的环境 ρ'**：将模式中的变量 `xi` 绑定到帧槽位 `d + i`。
```haskell
ρ' = ρ[x1 → Arg (d + 1), ..., xn → Arg (d + n)]
```
**is_body**：在环境 `ρ'` 下编译 `body` 的指令序列。
#### **4. U 编译方案**

**定义**：

- **U[[e]] u ρ d** 是一个二元组 (d', am)，其中 am 是在环境 ρ 下编译表达式 e 的 TIM 寻址模式。
- 如果通过 am 地址的闭包被进入，它将用其正常形式更新当前帧的槽位 u。
- 代码假设帧的前 d 个槽位已被占用，使用槽位 (d + 1 ... d')。
**规则**：

1. **处理整数常量**：
```haskell
U[[n]] u ρ d = (d, IntConst n)
```

- **解释**：如果 e 是整数常量，返回整数常量的寻址模式。
2. **处理其他情况**：
```haskell
U[[e]] u ρ d = (d', Code (PushMarker u : is))
```

- **解释**：在代码序列前添加 PushMarker u，用于设置更新机制。使用 R 编译方案编译表达式 e，得到指令序列 is。
#### **5. A 编译方案**

**定义**：

- **A[[e]] ρ** 是在环境 ρ 下表达式 e 的 TIM 寻址模式。
**规则**：

1. **处理整数常量**：
```haskell
A[[n]] ρ = IntConst n
```
2. **处理变量**：
```haskell
A[[x]] ρ = ρ x
```

- **解释**：如果 x 在环境 ρ 中有绑定，使用该绑定的寻址模式。
#### **6. I 编译方案**

**定义**：

- **I[[d]]** 是帧槽位 d 的间接寻址模式。
**规则**：

```haskell
I[[d]] = Code [Enter (Arg d)]
```

- **解释**：生成一个代码序列 [Enter (Arg d)]，用于间接访问帧槽位 d。
#### **7. B 编译方案**

**定义**：

- **B[[e]] ρ d cont** 是一个二元组 (d', is)，其中 is 是在环境 ρ 下编译表达式 e 的 TIM 代码。
- 代码将 e 的值（应为整数）压入值栈顶部，然后继续执行代码序列 cont。
- 代码假设帧的前 d 个槽位已被占用，使用槽位 (d + 1 ... d')。
**规则**：

1. **处理算术运算**：
```haskell
B[[e1 + e2]] ρ d cont = B[[e2]] ρ d1 is1
```

- **解释**：先编译 e2，将其值压入值栈。然后编译 e1，在指令序列后添加 Op Add : cont。
2. **处理整数常量**：
```haskell
B[[n]] ρ d cont = (d, PushV (IntVConst n) : cont)
```

- **解释**：将整数常量 n 压入值栈，然后继续执行 cont。
3. **处理其他情况**：
```haskell
B[[e]] ρ d cont = (d', Push (Code cont) : is)
```

- **解释**：将续延 Code cont 压入参数堆栈。使用 R 编译方案编译表达式 e，得到指令序列 is。
#### **补充说明**

**关于 UpdateMarkers 指令**

- 在超级组合子和构造函数的编译中，我们在 `Take` 指令之前插入 `UpdateMarkers` 指令。
- **目的**：处理可能需要的更新。如果在进入闭包时发现堆栈上的参数不足，则需要触发更新机制。
**关于闭包的自由复制**

- 在处理参数时，我们采用了 **自由复制参数闭包** 的策略，这意味着参数闭包可以被自由复制而不会丢失共享。
- **好处**：消除了间接链和相同更新的问题，提高了更新机制的效率。
**关于构造函数的编译**

- 构造函数 `Pack{t,a}` 被直接编译为：
```haskell
R[[Pack{t,a}]] ρ d = (d, [UpdateMarkers a, Take a a, ReturnConstr t])
```
- **解释**：构造函数的代码序列包括 UpdateMarkers、Take 和 ReturnConstr 指令。
**TIM 与 G 机器的比较**

作者提出了一个问题：“TIM 比 G 机器更好还是更差？”

- **难以回答**：因为原型实现对于探索设计选择非常有用，但在进行严肃的性能比较时却不够好。
- **主要区别**：**TIM**：采用了 **无主干性（spinelessness）** 和独特的更新机制，堆栈由 **代码-帧对** 组成。**G 机器**：堆栈由指向堆对象的指针组成，参数以指针的形式传递。
- **探索的价值**：通过研究另一种评估模型（如 TIM），可以启发其他设计途径，结合 TIM 和 G 机器的优点。
- **STG 机器**：作者提到了 **Spineless Tagless G-machine（STG 机器）**，它结合了 TIM 的无主干性和 G 机器的堆栈结构。
**全面详尽的总结**

在本节中，我们总结了 TIM（Three Instruction Machine）的最终编译方案，详细介绍了各个编译规则。这些编译方案定义了如何将函数式语言的表达式编译为 TIM 的指令序列，涵盖了超级组合子、一般表达式、`case` 表达式、构造函数、`let` 和 `letrec` 表达式等。

**主要内容回顾**：

1. **SC 编译方案**：
- 用于编译超级组合子定义。
- 插入 UpdateMarkers 和 Take 指令，处理参数和可能的更新。
2. **R 编译方案**：
- 用于编译一般表达式。
- 处理整数或算术表达式、超级组合子、本地变量、应用表达式、let 和 letrec 表达式等。
3. **E 编译方案**：
- 用于编译 case 表达式的分支。
- 将数据对象的组件移动到当前帧，构建新的环境编译分支的主体。
4. **U 编译方案**：
- 用于编译 let 和 letrec 绑定的变量。
- 构建自更新闭包，处理可能的更新。
5. **A 编译方案**：
- 用于生成表达式的 TIM 寻址模式。
- 处理整数常量和变量。
6. **I 编译方案**：
- 用于生成间接寻址模式。
- 生成访问帧槽位的代码序列。
7. **B 编译方案**：
- 用于编译值为整数或算术表达式的表达式。
- 将表达式的值压入值栈，继续执行后续代码。
**重要的概念和技巧**：

- **更新机制**：通过 `UpdateMarkers` 指令和自更新闭包，实现对闭包的更新，避免重复计算。
- **自由复制参数闭包**：采用自由复制参数闭包的策略，消除了间接链和相同更新的问题，提高了效率。
- **构造函数的编译**：直接将构造函数编译为指令序列，避免了需要在代码存储中为每个构造函数定义代码。
- **数据帧指针（Data Frame Pointer）**：用于处理数据对象的组件，解决了在评估组件时帧指针可能改变的问题。
- **编译器的扩展**：通过修改编译方案和编译器，实现了对各种语言特性的支持，包括算术运算、更新机制、结构化数据等。
**TIM 与 G 机器的比较**：

- **难以直接比较**：由于原型实现的限制，难以对 TIM 和 G 机器进行严肃的性能比较。
- **探索的价值**：研究 TIM 提供了新的设计思路，可以结合 TIM 和 G 机器的优点，开发更高效的实现。
- **STG 机器**：Spineless Tagless G-machine 是结合 TIM 和 G 机器特性的一种实现，采用了 TIM 的无主干性和更新机制，但堆栈由指向堆对象的指针组成。
**总结**

通过本节的学习，我们全面理解了 TIM 的最终编译方案，掌握了各个编译规则的作用和实现细节。这些编译方案为 TIM 提供了完整的功能，包括处理超级组合子、一般表达式、构造函数、`case` 表达式、`let` 和 `letrec` 表达式等。

我们还讨论了 TIM 与 G 机器的比较，认识到探索不同的评估模型对于设计更高效的实现具有重要价值。TIM 的一些特点，如无主干性和更新机制，已经在其他实现（如 STG 机器）中得到应用。

通过深入理解 TIM 的编译方案和实现细节，我们为进一步研究函数式语言的实现奠定了坚实的基础。在后续的学习中，我们可以探讨如何结合 TIM 和 G 机器的优点，开发更高效、更强大的实现。
Thought for 14 seconds
**概览**

本章（**第五章：并行 G-机器**）旨在开发一个抽象的并行 G-机器及其编译器。这个并行 G-机器基于 ESPRIT 项目 415 中开发的并行 G-机器的简化版本。有兴趣的读者可以参考 [Kingdon 等人 1991] 的相关资料。

本章的主要内容包括：

- **并行函数式编程**：讨论在函数式语言中编写并行程序的优势，以及与并行命令式编程的对比。
- **并行图归约**：介绍如何使用图归约技术实现并行计算，包括任务的创建、调度和同步机制。
- **示例分析**：通过一个简单的并行程序示例，深入解释并行 G-机器的执行过程，包括任务的创建、任务间的交互以及图的变化。
通过本章的学习，您将了解并行函数式编程的基本概念，理解并行 G-机器的工作原理，以及如何利用图归约实现并行计算。

**详细解析**

### **5.1 引言**

本章的目标是开发一个用于并行执行函数式程序的 G-机器及其编译器。G-机器是一种用于实现惰性（lazy）函数式语言的抽象机器，能够高效地执行函数式程序。

并行函数式编程旨在利用多处理器系统的计算能力，加速程序的执行。然而，编写并行程序并非易事，尤其是在命令式编程中。本章将探讨如何在函数式编程的范式下，实现并行计算，从而简化并行程序的编写。

### **5.1.1 并行函数式编程**

#### **并行命令式编程的挑战**

在编写并行命令式程序时，程序员面临着诸多挑战，包括：

1. **设计并行算法**：程序员需要构思一个满足问题规范的并行算法。
2. **实现并行性**：将并行算法转换为编程语言提供的并行构造。这通常需要：
- 确定并发任务。
- 定义任务之间的接口，以允许它们进行同步和通信。
- 保护共享数据，防止多个任务同时访问同一变量（例如，使用锁或信号量）。
3. **任务分配**：程序员可能需要负责将任务分配给处理器，确保需要相互通信的任务被分配到物理上连接的处理器上。
4. **调度和正确性**：在没有程序员控制的调度策略的系统中，程序员必须证明在所有可能的任务操作交错下，程序都能正确执行。
#### **函数式编程的优势**

与此相对，在函数式编程中，只有第一个点适用：**设计并行算法**。这是因为：

- **无副作用**：函数式编程强调纯函数和不可变数据，消除了并发访问共享数据时的冲突。
- **隐式并行性**：函数式程序的计算可以被自动并行化，编译器或运行时系统可以识别可并行执行的部分。
- **确定性**：函数式程序的执行结果是确定的，与任务的调度或执行顺序无关。
#### **示例：并行求和程序**

考虑以下示例程序 `psum n`，它计算从 `1` 到 `n` 的整数和：

```haskell
psum n = dsum 1 n;

dsum lo hi = let mid = (lo + hi) / 2 in
             if (hi == lo)
               then hi
               else (dsum lo mid) + (dsum (mid + 1) hi)
```

**解释**：

- dsum 函数是一个经典的分治算法，将求和问题分成两个大致相等的子问题，然后将它们的结果相加。
- dsum lo hi 计算从 lo 到 hi 的整数和。
- 当 lo 等于 hi 时，返回 hi；否则，计算 dsum lo mid 和 dsum (mid + 1) hi，然后将结果相加。
**并行性**：

- dsum lo mid 和 dsum (mid + 1) hi 可以并行计算，因为它们相互独立。
- 这意味着该函数 **允许并发地评估其主体中的多个子表达式**。
**对比：串行算法**

为了比较，我们可以编写一个串行算法 `ssum`：

```haskell
ssum n = if (n == 1)
           then 1
           else n + ssum (n - 1)
```

- ssum n 计算从 1 到 n 的整数和。
- 这是一个递归算法，必须先计算 ssum (n - 1)，才能计算 ssum n。
- **数据依赖性**：ssum n 中的加法操作只能在 ssum (n - 1) 已经计算完成后才能进行，导致了顺序执行。
#### **并行算法的特征**

一个函数实现了一个并行算法，当它允许 **同时评估其主体中的两个或更多子表达式** 时，即存在并行性。

#### **并行编程的对比**

与并行命令式编程相比，函数式编程中的并行性具有以下特点：

- **无需新的语言构造**：不需要引入新的语言构造来表达并行性、同步或通信。并行性是隐式的，当机器有空闲资源时，会动态创建新的任务来执行。
- **数据共享的安全性**：不需要特殊措施来保护并发任务之间的共享数据。由于函数式编程强调不可变数据，共享数据不会导致冲突。
- **证明的简化**：无需新的证明技术来推导并行程序的正确性。对顺序执行的函数式程序的证明技术同样适用于并行程序。
- **结果的确定性**：程序的结果是确定的，不会因为调度算法而导致两次运行的结果不同。
#### **简化的特征**

总的来说，函数式编程允许我们方便地表达并行算法，而无需解决大量的底层问题。我们可以概括为：

**一个并行命令式程序详细指定了资源分配决策，而并行函数式程序甚至不提及这些决策。**

这意味着机器必须能够自动做出资源分配决策。当这些决策不最优时，我们可能会在执行效率上有所损失。

#### **引入注解**

虽然函数式语言提供了高度的抽象，但这也对编译时和运行时的资源分配提出了很高的要求。为了不将所有资源分配决策留给系统，我们引入了一种 **注解（annotation）**，即 `par`，用于显式地启动新的并行线程。

**par 注解的语法和含义**：

```haskell
par E1 E2 = E1 E2
```

- **含义**：par 是应用（application）的同义词，但它表示表达式 E2 应该由一个并发任务来计算。
- **作用**：par 注解指示编译器或运行时系统将 E2 的计算作为一个并行任务。
**修改示例程序**

我们现在使用 `par` 注解重写 `dsum` 函数：

```haskell
dsum lo hi = let mid = (lo + hi) / 2 in
             let add x y = x + y
             if (lo == hi)
               then hi
               else par (add (dsum lo mid))
                        (dsum (mid + 1) hi)
```

**解释**：

- 我们定义了一个辅助函数 add，用于将两个数相加。
- 在 par 注解中，add (dsum lo mid) 和 dsum (mid + 1) hi 是两个表达式：dsum (mid + 1) hi 将作为一个并发任务来计算。add (dsum lo mid) 将在主线程中计算。
- 这使得两个子问题的计算可以并行进行。
**注解的使用**

- par 注解可以由程序员插入，也可以由聪明的编译器自动插入。
- 在本书的范围内，我们假设 par 注解已经被插入到程序中。
### **5.1.2 并行图归约**

#### **图归约技术**

在本书中，我们已经看到，图归约是一种用于实现惰性函数式语言的有效技术。它在并行计算中也有以下优势：

- **去中心化**：没有顺序的程序计数器，图归约是分散和分布式的。
- **并行归约**：可以在图的多个位置同时进行归约，调度的相对顺序不会影响结果。
- **通信与同步**：所有的通信和同步都通过图来完成。
#### **并行模型**

- **任务（Task）**：一个任务是一个顺序计算，其目的是将特定的子图归约为弱头部正常形式（WHNF，Weak Head Normal Form）。
- **Spark Pool（任务池）**：当前可执行的任务集合称为 Spark Pool。当处理器需要工作时，会从 Spark Pool 中获取新任务并执行。
- **虚拟处理器**：任务可以被看作是虚拟处理器。
**任务的创建与执行**：

- 初始时，只有一个任务，其工作是评估整个程序。
- 在执行过程中，可能会创建新任务来评估主任务稍后需要的表达式。这些新任务被放入 Spark Pool 中，以便其他处理器在空闲时可以获取并执行。
- **Sparking（引燃）**：将任务放入 Spark Pool 的过程称为 Sparking。
#### **任务间的交互**

- **Evaluate-and-Die 模型**：一种任务管理模型，其中每个图节点都有一个锁定位（lock bit）。当锁定位为开（on）时，表示有任务正在评估该节点；当锁定位为关（off）时，表示没有任务在评估该节点。
- **三种情况**：**子任务尚未开始**：父任务需要评估某个子图，而该子图的任务已被引燃但尚未开始。在这种情况下，父任务可以直接评估该子图，就像没有子任务一样。父任务会设置锁定位。当子任务尝试执行时，发现锁定位已被设置，会立即丢弃自己。**子任务正在执行**：子任务已开始但尚未完成。父任务必须等待子任务完成，才能继续。这称为 **父任务被子任务阻塞**。**子任务已完成**：节点已被评估为 WHNF，且锁定位被清除。父任务可以直接获取该子图的值，无需等待。
**优势**：

- **最小化阻塞**：只有当父任务和子任务实际发生冲突时，才会发生阻塞。
- **简化同步**：阻塞机制是唯一的任务间通信和同步形式。一旦图的一部分被评估为 WHNF，任何数量的任务都可以同时查看它，而不会发生冲突。
#### **示例：并行程序的执行**

现在，我们通过一个简单的并行程序示例，演示并行 G-机器的执行过程。

**示例程序**：

```haskell
main = par I (I 3)
```

- **I 是恒等函数**：I x = x
- **解释**：在 par 注解下，我们希望并行地计算 I 和 (I 3)。
**编译器生成的代码**

一个优秀的编译器会为 `main` 生成以下代码：

```haskell
e1 ++ par

其中，e1 = [Pushint 3, Pushglobal "I", Mkap, Push 0]
par = [Par, Pushglobal "I", Mkap, Update 0, Pop 0, Unwind]
```

**解释**：

- **e1**：用于构建表达式 (I 3) 的代码序列。Pushint 3：将整数 3 压入堆栈。Pushglobal "I"：将全局函数 I 的地址压入堆栈。Mkap：构建应用节点，表示 (I 3)。Push 0：将刚刚构建的节点的地址压入堆栈顶部。
- **par**：用于处理 par 注解的代码序列。Par：引燃一个新任务，评估堆栈顶部的节点。Pushglobal "I"：将全局函数 I 的地址压入堆栈。Mkap：构建应用节点，表示 I。Update 0：更新节点。Pop 0：弹出堆栈顶部的元素。Unwind：开始对图进行归约。
**执行过程**

**初始状态**：

- 只有一个任务（任务 1）在执行，其工作是构建并评估表达式 (I 3)。
- 执行 e1 代码序列后，机器状态如图（a）所示（图 5.1）。
**图（a）说明**：

- 堆栈上有指向节点 (I 3) 的指针。
- 任务 1 准备执行 Par 指令。
**执行 Par 指令**：

- Par 指令会创建一个新任务（任务 2），用于评估堆栈顶部的节点。
- 任务 1 和任务 2 的状态如图（b）所示（图 5.1）。
**图（b）说明**：

- 任务 1 继续执行剩余的代码。
- 任务 2 被创建，准备执行其代码序列 [Unwind]。
**任务的执行**：

- **任务 1**：执行 Pushglobal "I"，将 I 的地址压入堆栈。执行 Mkap，构建应用节点，表示 I。
- **任务 2**：执行 Unwind，开始对其分配的节点进行归约。
**状态更新**：

- 图（c）和图（d）展示了任务 1 和任务 2 的执行状态（图 5.2）。
- 任务 1 完成了 main 的实例化。
- 任务 2 完成了其 Unwind 操作。
**继续执行**：

- **任务 1**：执行 Update 0，更新节点。执行 Unwind，开始对 main 进行归约。
- **任务 2**：执行 Push 0，这是 I 函数代码中的第一条指令。
**状态更新**：

- 图（e）和图（f）展示了此时的机器状态（图 5.3）。
- 任务 1 开始对图进行展开（unwind）。
- 任务 2 执行 Update，更新其节点。
**任务完成**：

- 图（g）和图（h）展示了任务 2 完成后的状态（图 5.4）。
- 任务 2 已经完成了其工作。
- 任务 1 继续按照顺序 G-机器的方式执行。
**总结**：

- 这个示例展示了如何在并行 G-机器中，通过 par 注解，引燃新任务以并行执行。
- 任务间的交互通过锁定位和更新机制来管理，确保了正确的同步和结果的确定性。
**全面详尽的总结**

本章详细介绍了并行函数式编程和并行 G-机器的基本概念，以及如何利用图归约技术实现并行计算。

**主要内容回顾**：

1. **并行函数式编程的优势**：
- **高抽象层次**：无需引入新的语言构造或显式的并行控制，程序员可以专注于并行算法的设计。
- **隐式并行性**：并行性由编译器或运行时系统自动管理，减少了程序员的负担。
- **数据安全性**：由于不可变数据和纯函数的特性，数据共享不会导致并发冲突。
- **确定性**：程序的结果与任务的调度和执行顺序无关，避免了调试并发问题的复杂性。
2. **图归约在并行计算中的应用**：
- **任务模型**：将计算划分为多个任务，每个任务负责将特定的子图归约为 WHNF。
- **Spark Pool**：管理当前可执行的任务集合，处理器从中获取任务执行。
- **Evaluate-and-Die 模型**：通过锁定位和更新机制，管理任务间的同步和通信，确保正确性。
3. **任务间的交互和同步**：
- **三种可能的交互情况**：子任务尚未开始、子任务正在执行、子任务已完成。
- **阻塞机制**：只有当父任务和子任务实际发生冲突时，父任务才会被阻塞，最大限度地提高了并行性。
- **锁定位和更新机制**：用于管理任务间的同步，确保结果的正确性和确定性。
4. **并行程序的执行示例**：
- 通过对简单的并行程序 main = par I (I 3) 的执行过程进行详细分析，展示了并行 G-机器的工作原理。
- 解释了任务的创建、任务间的交互、图的变化以及执行状态的更新。
**重要的概念和技巧**：

- **par 注解**：用于显式地指示并行性，启动新的并行任务。
- **任务（Task）**：并行计算的基本单元，负责归约特定的子图。
- **Spark Pool**：管理和调度任务的机制，支持动态任务分配。
- **Evaluate-and-Die 模型**：通过锁定位和更新机制，实现任务间的同步和通信。
- **图归约技术**：利用图结构表示程序和数据，实现分布式和去中心化的并行计算。
**总结**

通过本章的学习，我们了解到函数式编程在并行计算中的独特优势，以及如何利用图归约技术实现高效的并行执行。并行 G-机器为函数式语言的并行实现提供了一个强大的模型，能够自动管理并行任务的创建、调度和同步。

这种模型避免了传统并行编程中的复杂性，使程序员可以专注于并行算法的设计，而无需关心底层的资源分配和同步细节。结果是，我们能够更方便地编写高性能的并行程序，充分利用多处理器系统的计算能力。

在后续的章节中，我们将进一步探讨并行 G-机器的实现细节、优化策略以及在实际系统中的应用。
 #  
 Thought for a few seconds
**概览**

本节（**5.2 Mark 1: 最小并行 G-机器**）旨在构建一个基本的并行 G-机器，该机器基于第三章介绍的 G-机器的某个版本（除了 Mark 1 以外，因为我们需要确保实现更新机制）。为了将并行性引入 G-机器，我们需要添加并行执行的机制。

本节主要内容包括：

- **基本假设**：关于并行 G-机器的基本设计假设，如共享全局图、无限处理器和不对图节点加锁。
- **数据类型定义**：定义并行 G-机器所需的数据类型，包括全局状态和局部状态，以及相关的访问函数。
- **求值器（Evaluator）**：描述并行 G-机器的求值器 eval 的实现，解释如何处理多个处理器，以及如何调度和执行任务。
- **新指令的转换规则**：特别是 Par 指令的作用和实现。
- **编译器的修改**：如何修改编译器以支持 par 注解，并生成适当的代码，包括对不同版本的 G-机器的处理。
- **结果的打印**：如何修改结果显示函数以适应并行 G-机器，包括状态和统计信息的显示。
- **练习**：通过一系列练习，帮助理解并实践并行 G-机器的实现和行为。
通过本节的学习，您将了解如何在 G-机器中引入并行性，理解并行 G-机器的结构和运行机制，以及如何修改编译器和求值器以支持并行执行。

**详细解析**

### **5.2 Mark 1: 最小并行 G-机器**

我们将构建一个最小的并行 G-机器，可以基于第三章中的任何 G-机器（除了 Mark 1，因为我们需要确保更新机制的存在）。为了引入并行性，我们需要添加相关的并行机制。

#### **基本假设**

在构建并行 G-机器时，我们做出以下基本假设：

1. **共享全局图（Graph）**：所有处理器都可以访问共享的全局图。也就是说，所有处理器操作在同一个图上，共享同一块内存空间。
2. **无限数量的处理器**：我们假设有无限数量的处理器。这意味着任何时候都可以获得一个处理器来执行任务。这是一个理想化的假设，用于简化实现和分析。
3. **图节点不加锁**：我们不对图节点进行锁定。这意味着不同的任务可能会重新评估同一个表达式，可能会导致重复计算。
这些假设的目的是简化并行 G-机器的实现，使我们能够专注于并行机制的核心概念，而不必处理复杂的同步和资源管理问题。

#### **5.2.1 数据类型定义**

在并行机器中，状态 `PgmState` 被分为两个部分：

- **全局组件（pgmGlobalState）**：包含全局数据结构，例如堆（heap）、全局变量映射、任务池（Spark Pool）等。
- **局部组件（pgmLocalState）**：包含将要执行程序的处理器列表。每个处理器都有自己的局部状态。
```haskell
type PgmState = (PgmGlobalState, [PgmLocalState])
```

##### **全局状态组件**

全局状态由五个组件组成：

1. **gmOutput**：输出流，保存程序执行的输出结果，通常是一个字符串。
```haskell
type GmOutput = [Char]
```
获取输出的函数：
```haskell
pgmGetOutput :: PgmState -> GmOutput
pgmGetOutput ((o, heap, globals, sparks, stats), locals) = o
```
2. **gmHeap**：堆，用于存储节点（Node）。
```haskell
type GmHeap = Heap Node
```
获取堆的函数：
```haskell
pgmGetHeap :: PgmState -> GmHeap
pgmGetHeap ((o, heap, globals, sparks, stats), locals) = heap
```
3. **gmGlobals**：全局变量映射，将超级组合子（supercombinator）的名称映射到堆中的唯一节点地址。
```haskell
type GmGlobals = ASSOC Name Addr
```
获取全局变量映射的函数：
```haskell
pgmGetGlobals :: PgmState -> GmGlobals
pgmGetGlobals ((o, heap, globals, sparks, stats), locals) = globals
```
4. **gmSparks**：任务池（Spark Pool），用于保存通过 `par` 注解创建的需要并发执行的任务的节点地址。
```haskell
type GmSparks = [Addr]
```
获取任务池的函数：
```haskell
pgmGetSparks :: PgmState -> GmSparks
pgmGetSparks ((o, heap, globals, sparks, stats), locals) = sparks
```
5. **gmStats**：统计信息，记录每个任务执行的时钟周期数（执行指令数）。
```haskell
type GmStats = [Int]
```
获取统计信息的函数：
```haskell
pgmGetStats :: PgmState -> GmStats
pgmGetStats ((o, heap, globals, sparks, stats), locals) = stats
```
##### **局部状态组件**

局部状态由处理器列表组成，每个处理器被表示为一个任务（Task）。每个处理器的状态由五个部分组成：

```haskell
type PgmLocalState = (GmCode, GmStack, GmDump, GmVStack, GmClock)
```

- **GmCode**：指令流（Instruction stream），即待执行的指令列表。
```haskell
type GmCode = [Instruction]
```
- **GmStack**：堆栈，存储指向堆中节点的地址列表。
```haskell
type GmStack = [Addr]
```
- **GmDump**：用于保存堆栈和指令序列的堆栈（Dump Stack），用于实现非严格求值（如延迟求值）。
```haskell
type GmDump = [GmDumpItem]
type GmDumpItem = (GmCode, GmStack)
```
- **GmVStack**：值栈（Value Stack），用于保存计算过程中产生的值（如整数）。
```haskell
type GmVStack = [Int]
```
- **GmClock**：时钟，记录任务已经执行的指令数（时钟周期数）。
```haskell
type GmClock = Int
```
##### **状态访问函数**

为了方便访问状态中的各个部分，我们定义了一些状态访问函数。

全局状态的设置函数（put functions）：

```haskell
putOutput :: GmOutput -> GmState -> GmState
putHeap :: GmHeap -> GmState -> GmState
putSparks :: GmSparks -> GmState -> GmState
putStats :: GmStats -> GmState -> GmState
```

全局状态的获取函数（get functions）：

```haskell
getOutput :: GmState -> GmOutput
getHeap :: GmState -> GmHeap
getGlobals :: GmState -> GmGlobals
getSparks :: GmState -> GmSparks
getStats :: GmState -> GmStats
```

处理器局部状态的设置函数：

```haskell
putCode :: GmCode -> GmState -> GmState
putStack :: GmStack -> GmState -> GmState
putDump :: GmDump -> GmState -> GmState
putVStack :: GmVStack -> GmState -> GmState
putClock :: GmClock -> GmState -> GmState
```

处理器局部状态的获取函数：

```haskell
getCode :: GmState -> GmCode
getStack :: GmState -> GmStack
getDump :: GmState -> GmDump
getVStack :: GmState -> GmVStack
getClock :: GmState -> GmClock
```

**练习 5.1**

**任务**：实现上述类型的状态访问函数。

**提示**：这些函数的实现类似于前面的状态访问函数，需要从 `PgmState` 中提取相应的组件。

#### **5.2.2 求值器（Evaluator）**

求值器 `eval` 的结构与 G-机器中的求值器类似，但需要处理多个处理器。

```haskell
eval :: PgmState -> [PgmState]
eval state = state : restStates
  where
    restStates | gmFinal state = []
               | otherwise = eval (doAdmin (steps state))
```

**解释**：

- eval 函数接受一个状态 state，返回一个状态列表，表示状态的演变过程。
- gmFinal state 用于判断机器是否终止。
- steps 函数执行每个处理器的一个步骤。
- doAdmin 函数用于执行一些管理工作，如更新统计信息，清理完成的任务。
**steps 函数**

`steps` 函数执行以下步骤：

1. **提取上一次调用 steps 时产生的 spark（任务）地址**。
2. **将 spark 地址转换为新的任务（newtasks）**。
3. **将 spark pool 置为空**（因为 spark 已经被处理）。
4. **为每个将要执行的处理器递增其时钟（clock）**。
5. **使用 mapAccuml 对每个处理器执行一次 step 转换**。
```haskell
steps :: PgmState -> PgmState
steps state = mapAccuml step global' local'
  where
    ((out, heap, globals, sparks, stats), local) = state
    newtasks = [makeTask a | a <- sparks]
    global' = (out, heap, globals, [], stats)
    local' = map tick (local ++ newtasks)
```

**解释**：

- mapAccuml 函数用于累积地对列表中的每个元素应用函数 step，同时维护一个累积器（全局状态）。
- makeTask 函数将 spark 地址转换为新的任务。
- tick 函数递增处理器的时钟。
**makeTask 函数**

根据所使用的 G-机器版本，`makeTask` 函数有所不同。

对于基于 G-机器 Mark 2 或 Mark 3 的实现：

```haskell
makeTask :: Addr -> PgmLocalState
makeTask addr = ([Unwind], [addr], [], [], 0)
```

对于基于 G-机器 Mark 4 及以后的实现：

```haskell
makeTask :: Addr -> PgmLocalState
makeTask addr = ([Eval], [addr], [], [], 0)
```

**tick 函数**

用于递增处理器的时钟：

```haskell
tick :: PgmLocalState -> PgmLocalState
tick (i, stack, dump, vstack, clock) = (i, stack, dump, vstack, clock + 1)
```

**机器的终止条件**

机器在以下条件下终止：

- Spark Pool 为空，且没有正在执行任务的处理器。
```haskell
gmFinal :: PgmState -> Bool
gmFinal s = second s == [] && pgmGetSparks s == []
```

**step 函数**

`step` 函数对单个处理器执行一步操作：

```haskell
step :: PgmGlobalState -> PgmLocalState -> GmState
step global local = dispatch i (putCode is state)
  where
    (i:is) = getCode state
    state = (global, local)
```

- getCode state 获取处理器的指令序列。
- dispatch 函数根据当前指令 i 调度执行相应的操作。
**doAdmin 函数**

`doAdmin` 函数用于执行一些管理工作，例如清理完成的任务，更新统计信息。

```haskell
doAdmin :: PgmState -> PgmState
doAdmin ((out, heap, globals, sparks, stats), local) = ((out, heap, globals, sparks, stats'), local')
  where
    (local', stats') = foldr filter ([], stats) local
    filter (i, stack, dump, vstack, clock) (local, stats)
      | i == []   = (local, clock : stats)
      | otherwise = ((i, stack, dump, vstack, clock) : local, stats)
```

- foldr filter ([], stats) local 遍历处理器列表 local，过滤出未完成的任务，将完成的任务的时钟数添加到 stats 中。
- 如果处理器的指令序列为空 i == []，表示任务已完成。
#### **新指令的转换规则**

在并行 G-机器中，我们需要添加一个新的指令 `Par`，用于实现并行性。

##### **Par 指令**

**作用**：

- Par 指令将栈顶的节点地址添加到 Spark Pool 中，表示该节点需要被并发地评估。
**转换规则（5.1）**：

```less
 
=>  
```

- 第一元组 <h, m, t> 表示全局状态，其中 h 是堆，m 是全局变量映射，t 是 Spark Pool。
- 第二元组 <Par : i, a : s> 表示处理器的局部状态，Par : i 是指令序列，a : s 是栈。
**解释**：

- Par 指令的作用是将栈顶的地址 a 添加到 Spark Pool t 中。
- 然后继续执行剩余的指令序列 i，栈为 s。
**par 函数的实现**

```haskell
par :: GmState -> GmState
par s = s
```

**注意**：在这里，`par` 函数的实现为空（`s = s`），需要根据实际情况修改，以实现将地址添加到 Spark Pool。

**练习 5.2**

**任务**：

- 修改 showInstruction、dispatch 和 instruction 函数，使得 Par 指令被正确处理。
**提示**：

- showInstruction 函数需要能够显示 Par 指令。
- dispatch 函数需要能够识别并调用 par 函数处理 Par 指令。
- instruction 函数需要包含对 Par 指令的处理。
#### **5.2.3 编译程序**

为了在并行机器上编译程序，我们需要修改编译器，使其能够处理 `par` 注解。

对于基于 G-机器 Mark 2 到 Mark 6 的实现，我们可以通过为 `par` 函数提供一个编译后的原语来构建一个简单的编译器。

编译器的另一个修改在于 `compile` 函数，现在各种组件位于不同的位置，并且有多个处理器。

**新的 compile 函数定义**：

```haskell
compile :: CoreProgram -> PgmState
compile program = (([], heap, globals, [], []), [initialTask addr])
  where
    (heap, globals) = buildInitialHeap program
    addr = aLookup globals "main" (error "main undefined")
```

**解释**：

- 初始化全局状态，包括输出、堆、全局变量映射、Spark Pool 和统计信息。
- 创建一个初始任务 initialTask addr，其中 addr 是 main 函数在堆中的地址。
- 处理器列表包含一个初始任务。
**initialTask 函数**

根据所使用的 G-机器版本，`initialTask` 函数有所不同。

对于基于 G-机器 Mark 2 或 Mark 3 的实现：

```haskell
initialTask :: Addr -> PgmLocalState
initialTask addr = (initialCode, [addr], [], [], 0)
```

```haskell
initialCode :: GmCode
initialCode = [Unwind]
```

对于基于 G-机器 Mark 4 或 Mark 5 的实现：

```haskell
initialCode :: GmCode
initialCode = [Eval]
```

对于支持数据结构的 G-机器 Mark 6 和 Mark 7：

```haskell
initialCode :: GmCode
initialCode = [Eval, Print]
```

**为机器添加 par 原语**

我们需要在机器的原语定义中添加 `par` 函数的编译版本。

对于基于 G-机器 Mark 2 到 Mark 6 的实现，添加以下内容到 `compiledPrimitives`：

```haskell
("par", 2, [Push 1, Push 1, Mkap, Push 2, Par, Update 2, Pop 2, Unwind])
```

**解释**：

- 当 `par` 函数应用于两个参数 `E1` 和 `E2` 时，上述指令序列执行以下任务：**构建 E1 E2 的应用节点**：
```haskell
[Push 1, Push 1, Mkap]
```
Push 1：将第一个参数 E1 的地址压入栈（假设第一个参数在栈的位置 1）。Push 1：再次将 E1 的地址压入栈。Mkap：构建一个应用节点，将栈顶的两个元素组合为一个应用节点（E1 E1）。**处理并行性**：
```haskell
[Push 2, Par]
```
Push 2：将第二个参数 E2 的地址压入栈（假设第二个参数在栈的位置 2）。Par：将栈顶的地址（E2）添加到 Spark Pool，创建一个并发任务。**更新和清理栈**：
```haskell
[Update 2, Pop 2, Unwind]
```
Update 2：更新栈位置 2 的节点（可能是用于实现更新机制）。Pop 2：弹出栈顶的两个元素。Unwind：开始对图进行展开（unwind），评估节点。
**基于 G-机器 Mark 7 的实现**

对于基于 G-机器 Mark 7 的实现，情况稍微复杂一些。

需要修改编译器的 `compileR` 和 `compileE` 函数，识别涉及 `par` 的特殊情况。

**修改 compileR 函数**

```haskell
compileR (EAp (EAp (EVar "par") e1) e2) args = compileC e2 args ++ [Push 0, Par] ++ compileC e1 (argOffset 1 args) ++ [Mkap, Update n, Pop n, Unwind]
  where
    n = #args
```

**解释**：

- 当识别到表达式是 par e1 e2 时，进行特殊处理。
- 首先，使用 compileC 编译 e2，将结果压入栈。
- 然后，使用 [Push 0, Par] 将 e2 的地址添加到 Spark Pool。
- 接下来，编译 e1，并构建应用节点。
- 最后，执行更新和清理操作。
**修改 compileE 函数**

```haskell
compileE (EAp (EAp (EVar "par") e1) e2) args = compileC e2 args ++ [Push 0, Par] ++ compileC e1 (argOffset 1 args) ++ [Mkap, Eval]
```

**解释**：

- 与 compileR 的区别在于，使用 Eval 而不是 Update、Pop、Unwind。
- Eval 用于将创建的应用节点求值到弱头部正常形式（WHNF）。
**在原语中添加 par 函数**

```haskell
("par", ["x", "y"], (EAp (EAp (EVar "par") (EVar "x")) (EVar "y")))
```

**注意**：我们也可以将这种方法用于基于 G-机器 Mark 5 或 Mark 6 的实现。

**练习 5.3**

**任务**：对编译器进行修改，定义 `par` 函数。

**练习 5.4**

**问题**：为什么在 `compileR` 和 `compileE` 的特殊情况下，我们在构造第一个参数之前对第二个参数进行 spark？

**答案**：

- 我们希望 e2 的评估能够尽早开始，因此在构造第一个参数 e1 之前，就将 e2 添加到 Spark Pool 中，供其他处理器并发地评估。
- 这有助于最大限度地利用并行性，使 e2 的计算不被 e1 的构造所阻塞。
#### **5.2.4 打印结果**

在计算出机器的状态列表后，我们需要使用 `showResults` 函数来控制状态的显示。它会打印出：

- 超级组合子的代码。
- 状态转换过程。
- 统计信息。
**showResults 函数**

```haskell
showResults :: [PgmState] -> [Char]
```

**其他显示函数**

- **showSC**：用于显示超级组合子的代码。
```haskell
showSC :: PgmState -> (Name, Addr) -> Iseq
```
- **showState**：用于显示处理器的局部状态。在并行机器中，可能有多个处理器在执行。
```haskell
showState :: PgmState -> Iseq
```
- **showStats**：用于显示统计信息。
```haskell
showStats :: PgmState -> Iseq
```
- **showOutput**：用于显示输出。
```haskell
showOutput :: GmOutput -> Iseq
```
**练习 5.5**

**任务**：

- 修改 `showResults`、`showSC`、`showState`、`showStats` 和 `showOutput` 函数，使其适应并行 G-机器的状态显示。
- 定义一个新的显示函数 `showSparks`，用于显示 Spark Pool。
```haskell
showSparks :: GmSparks -> Iseq
```
**练习 5.6**

**任务**：在并行 G-机器上运行以下程序：

```haskell
main = par (S K K) (S K K 3)
```

- **问题**：需要多少机器周期？
- **对比**：运行等效的顺序程序：
```haskell
main = S K K (S K K 3)
```
- **分析**：比较并行和顺序执行的效率。
**练习 5.7**

**问题**：当运行以下程序时会发生什么？

```haskell
main = par I (I 3)
```

- **问题**：在这个程序中使用 par 是否合理？
**分析**：

- par I (I 3) 将 I 和 (I 3) 并行评估。
- 由于 I 是恒等函数，评估 I 不需要任何计算，立即返回自身。
- 而 (I 3) 需要计算 I 3，返回 3。
- 在这种情况下，引燃 I 并不能带来并行执行的优势，可能导致额外的开销。
**全面详尽的总结**

在本节中，我们构建了一个最小的并行 G-机器，实现了在 G-机器中引入并行性的机制。通过添加 `Par` 指令和修改编译器，我们使得 G-机器能够处理 `par` 注解，实现并行任务的创建和执行。

**主要内容回顾**：

1. **基本假设**：
- **共享全局图**：所有处理器共享同一个全局图。
- **无限数量的处理器**：假设随时有处理器可用来执行任务。
- **图节点不加锁**：允许多个任务同时访问或评估同一个节点。
2. **数据类型定义**：
- **全局状态组件**：包括输出、堆、全局变量映射、Spark Pool 和统计信息。
- **局部状态组件**：处理器列表，每个处理器包含指令流、堆栈、Dump 堆栈、值栈和时钟。
- **状态访问函数**：定义了获取和设置全局和局部状态的函数，方便在求值器和指令实现中使用。
3. **求值器（Evaluator）**：
- **eval 函数**：处理并行机器的状态演变，管理处理器的执行和任务的调度。
- **steps 函数**：对每个处理器执行一步操作，处理新创建的任务，更新全局状态和局部状态。
- **makeTask 函数**：将 Spark Pool 中的地址转换为新的任务，添加到处理器列表中。
- **doAdmin 函数**：管理任务的完成状态，更新统计信息，清理完成的任务。
4. **新指令的转换规则**：
- **Par 指令**：用于创建并行任务，将栈顶的地址添加到 Spark Pool 中。
- **Par 指令的实现**：修改 dispatch 和 instruction 函数，添加对 Par 指令的处理。
5. **编译器的修改**：
- **添加 par 函数的编译版本**：在原语定义中添加 par 函数的实现，生成适当的指令序列。
- **修改 compileR 和 compileE 函数**：对于涉及 par 的特殊情况，进行特殊处理，以最大化并行性。
6. **结果的打印**：
- **修改显示函数**：调整 showResults、showSC、showState、showStats 和 showOutput 函数，以适应并行 G-机器的状态显示。
- **添加 showSparks 函数**：用于显示 Spark Pool 的状态，方便调试和分析。
7. **练习**：
- **练习 5.1 至 5.7**：通过一系列练习，帮助理解并实践并行 G-机器的实现，包括状态访问函数的编写、指令的处理、编译器的修改以及对程序执行的分析。
**重要的概念和技巧**：

- **并行任务的创建和执行**：通过 Par 指令和 Spark Pool，实现并行任务的管理。
- **无限处理器的假设**：简化了资源管理，但在实际实现中需要考虑处理器的数量限制。
- **图节点不加锁的影响**：可能导致重复计算，需要在实际实现中权衡性能和复杂性。
- **编译器的修改策略**：对于特殊的语言构造（如 par），需要在编译器中进行特殊处理，以生成高效的代码。
**总结**

通过本节的学习，我们成功地将并行性引入到 G-机器中，构建了一个最小的并行 G-机器模型。我们详细讨论了并行 G-机器的结构，包括全局状态和局部状态的定义，求值器的实现，以及新指令的转换规则。

我们还学习了如何修改编译器，以支持 `par` 注解和并行任务的创建。通过调整编译器的 `compileR` 和 `compileE` 函数，我们能够生成适当的指令序列，实现并行执行。

此外，我们讨论了如何显示并行机器的执行结果，包括处理器的状态、Spark Pool 的状态和统计信息。这有助于我们分析并行程序的执行过程，理解并行性的影响。

最后，通过一系列练习，我们巩固了对并行 G-机器的理解，并实践了其实现和分析。这为我们进一步研究并行函数式编程和并行 G-机器的优化奠定了基础。

在后续的章节中，我们将继续探讨并行 G-机器的改进和优化，包括资源管理、任务调度、负载均衡等方面，以实现更加高效和实际的并行执行。
 #  
 Thought for 2m 46s
**概览**

在本节中，我们深入探讨了并行 G-机器的发展，特别是从 Mark 1 到 Mark 4 的演变。我们首先认识到 Mark 1 机器存在的一个主要问题：可能会创建许多任务来减少堆中的同一节点，从而导致工作重复。为了解决这个问题，我们在 Mark 2 中引入了 **“评估并消亡（evaluate-and-die）”** 模型，通过在展开（unwinding）过程中锁定节点，防止多个任务同时评估同一节点。

接下来，我们讨论了 Mark 3 机器，它引入了更现实的调度策略，限制了可用处理器的数量，并考虑了保守和推测性并行的概念。最后，我们介绍了 Mark 4 机器，通过将阻塞的任务附加到导致阻塞的节点上，从而优化了阻塞任务的处理。

通过这些改进，我们旨在构建一个更高效、更现实的并行 G-机器，并深入理解在懒惰函数式语言中实现并行性的挑战和解决方案。

**详细解析**

### **5.3 Mark 2：评估并消亡模型（Evaluate-and-Die Model）**

#### **Mark 1 机器的问题**

在 Mark 1 并行 G-机器中，存在一个重要的问题：可能会创建多个任务来同时减少堆中的同一节点。这导致了计算的重复，浪费了资源和时间。为了避免这种情况，我们需要一种机制来防止多个任务同时评估同一节点。

#### **解决方案：节点锁定**

**锁定机制**：当一个任务开始评估一个节点时，我们将该节点 **锁定**。这意味着其他任务在遇到这个节点时，会发现它已被锁定，从而阻止对其进行评估。

**解锁机制**：一旦节点的评估完成并得到其弱头部正常形式（WHNF，Weak Head Normal Form），我们需要 **解锁** 该节点，以允许阻塞的任务继续。

#### **选择在 Unwind 指令中锁定节点的原因**

- **Unwind 指令**：在 G-机器中，Unwind 指令用于展开表达式，寻找可以被简化的最左侧表达式（redex）。
- **为什么不在 Eval 指令中锁定**：使用 Eval 指令可能无法捕获所有需要锁定的情况，特别是当在展开过程中遇到已锁定的节点时。
- **因此**，Unwind 是唯一需要检查节点值的指令，也是唯一会导致任务阻塞的指令，因此在 Unwind 中进行节点的锁定和阻塞处理是合适的。
#### **在 Update 指令中解锁节点**

- **Update 指令**：当我们将一个表达式的值更新到堆中时，需要解锁之前锁定的节点。
- **解锁整个展开路径（spine）**：由于在更新 redex（可归约表达式）的根节点之前，其展开路径上的所有节点都已经是 WHNF，我们应该解锁从 redex 根节点以下的所有节点。
### **5.3.1 节：节点数据结构**

为了实现上述机制，我们需要对节点的数据结构进行一些修改，添加新的节点类型以表示锁定的节点。

#### **添加新的节点类型**

我们引入两个新的节点类型：

- **NLAp**：表示锁定的应用节点（Application Node）。
- **NLGlobal**：表示锁定的全局节点（Global Node）。
Haskell 中节点的数据类型定义如下：

```haskell
data Node = NNum Int              -- 数字
          | NAp Addr Addr         -- 应用节点
          | NGlobal Int GmCode    -- 全局节点
          | NInd Addr             -- 间接节点
          | NConstr Int [Addr]    -- 构造函数节点
          | NLAp Addr Addr        -- 锁定的应用节点
          | NLGlobal Int GmCode   -- 锁定的全局节点
```

#### **练习 5.8**

**任务**：修改 `showNode` 函数，以处理新的锁定节点类型 `NLAp` 和 `NLGlobal`，以正确显示锁定节点的信息。

### **5.3.2 节：指令集**

在修改了节点的数据结构后，我们需要调整指令集，以在适当的地方锁定和解锁节点。

#### **锁定和解锁节点**

我们需要在以下情况下锁定节点：

- **在 Unwind 指令中锁定节点**：当展开一个表达式时，我们需要锁定遇到的应用节点和零参数的全局节点。
- **在 Update 指令中解锁节点**：当更新一个节点时，我们需要解锁展开路径上所有的锁定节点。
#### **定义锁定和解锁函数**

**锁定函数 lock**：

```haskell
lock :: Addr -> GmState -> GmState
lock addr state = putHeap (newHeap (hLookup heap addr)) state
  where
    heap = getHeap state
    newHeap (NAp a1 a2) = hUpdate heap addr (NLAp a1 a2)
    newHeap (NGlobal n c)
      | n == 0    = hUpdate heap addr (NLGlobal n c)
      | otherwise = heap  -- 对于非零参数的全局节点，不锁定
```

- **作用**：将未锁定的节点转换为锁定节点。
- **说明**：只有应用节点和零参数的全局节点需要锁定。
**解锁函数 unlock**：

```haskell
unlock :: Addr -> GmState -> GmState
unlock addr state = newState (hLookup heap addr)
  where
    heap = getHeap state
    newState (NLAp a1 a2) =
      unlock a1 (putHeap (hUpdate heap addr (NAp a1 a2)) state)
    newState (NLGlobal n c) =
      putHeap (hUpdate heap addr (NGlobal n c)) state
    newState n = state  -- 对于其他节点类型，不做处理
```

- **作用**：将锁定的节点转换回未锁定的节点。
- **递归解锁**：对于锁定的应用节点，需要递归地解锁其左子节点，以解锁整个展开路径。
#### **调整指令的转换规则**

**Unwind 指令的转换规则**：

1. **对于应用节点**：
```less
 <[Unwind], a : s>
=>  <[Unwind], a1 : a : s>
```

- **解释**：将节点 a 从 NAp 转换为锁定的 NLAp，并继续展开其左子节点 a1。
2. **对于零参数的全局节点**：
```less
 <[Unwind], a : s>
=>  
```

- **解释**：将节点 a 从 NGlobal 转换为锁定的 NLGlobal，并加载其代码 c。
**Update 指令的转换规则**：

- **解锁展开路径上的节点**：在更新节点时，将展开路径上的锁定节点解锁。
```less
 
=>  
```
**解释**：具体的堆状态会更新节点，并解锁锁定的节点。
#### **练习 5.9**

**任务**：修改 `unwind` 和 `update` 函数，使用 `lock` 和 `unlock` 函数，实现上述转换规则。

- **注意**：在重新排列堆栈时，需要能够“穿透”锁定的节点，因此需要修改 `getArg` 函数：
```haskell
getArg (NLAp a1 a2) = a2
```
### **练习 5.10**

**任务**：在你的机器上运行以下程序：

```haskell
main = twice' (twice' (twice' (S K K))) 3
twice' f x = par f (f x)
```

- **目的**：观察改进后的并行 G-机器在处理嵌套的 par 调用时的行为，以及节点锁定机制如何防止重复计算。
### **练习 5.11**

**问题**：一个分治算法的程序在每个运行的进程中，每隔 30 条指令就执行一次 `par` 指令。这些进程不会结束。

- **问**：在模拟的时钟滴答中，需要经过多少次滴答，才能使得任务数量达到宇宙中电子的数量？（提示：宇宙中大约有 $10^{85}$ 个电子。）
- **解答思路**：这是一个指数增长的问题。每个进程每 30 条指令产生一个新的任务，任务数量会呈指数级增长。需要计算经过多少次滴答，任务数量达到 $10^{85}$。
### **练习 5.12**

**问题**：如果每个处理器的成本是 £0.01，那么练习 5.11 中的程序可以运行多久，直到没人能负担得起这台机器？（提示：美国联邦预算大约是 £$5 \times 10^{12}$。）

- **解答思路**：计算处理器总成本何时超过 £$5 \times 10^{12}$，然后根据任务增长率，计算需要多少时间。
### **5.4 Mark 3：现实的并行 G-机器**

#### **物理和经济限制**

- **无限处理器的假设不现实**：练习 5.11 和 5.12 显示了无限制的并行性在现实中不可行，会很快耗尽资源。
- **需要一个更现实的模型**：限制同时运行的任务数量，以反映实际硬件的限制。
#### **引入调度策略**

**调度策略**：决定在有限的处理器资源下，哪些任务可以执行。

- **限制处理器数量**：设置一个固定的处理器数量，例如 machineSize = 4。
- **任务调度**：当任务数量超过处理器数量时，需要决定哪些任务优先执行。
#### **保守并行和推测性并行**

- **保守并行（Conservative Parallelism）**：任务的结果肯定会被需要。
- **推测性并行（Speculative Parallelism）**：任务的结果可能不需要。
**在本书中**，我们只关注保守并行，因为推测性并行涉及到更复杂的优先级和调度问题。

#### **修改求值器**

**主要变化在 steps 函数中**：

- **不再将所有创建的任务都添加到机器中**。
- **使用 scheduler 函数** 来选择可以执行的任务。
```haskell
steps :: PgmState -> PgmState
steps state = scheduler global' local'
  where
    ((out, heap, globals, sparks, stats), local) = state
    newtasks = [makeTask a | a <- sparks]
    global' = (out, heap, globals, [], stats)
    local' = local ++ newtasks
```

**scheduler 函数**：

- **实现简单的调度策略**：选择前 machineSize 个任务运行，将它们放在调度队列的末尾。
- **这是**：一种 **轮询调度（Round-Robin Scheduling）**。
```haskell
scheduler :: PgmGlobalState -> [PgmLocalState] -> PgmState
scheduler global tasks = (global', nonRunning ++ tasks')
  where
    running = map tick (take machineSize tasks)
    nonRunning = drop machineSize tasks
    (global', tasks') = mapAccuml step global running
```

#### **练习 5.13**

**问题**：如果执行的任务在下一步中没有被放置在调度队列的末尾，会发生什么？

- **提示**：尝试修改调度策略，观察任务执行的影响，例如可能会导致某些任务得不到公平的执行机会。
#### **练习 5.14**

**改进**：只有在有空闲处理器时，才从 Spark Pool 中创建新任务。

- **任务**：修改 steps 函数，实现这一改进。
#### **练习 5.15**

**改进**：只调度可以继续执行的任务。

- **问题**：目前我们可能调度已经处于 WHNF 的节点，或者尝试展开已锁定节点而被阻塞的任务。
- **任务**：修改 scheduler 函数，避免调度无法继续的任务。
#### **练习 5.16**

**实验**：尝试使用其他调度策略，例如调度任务池中的最后一个任务。

- **问题**：调度策略是否会对程序的执行时间产生影响？
### **5.5 Mark 4：改进阻塞的处理**

#### **当前阻塞处理的问题**

- **阻塞任务留在机器的本地状态中**，调度器需要遍历大量的阻塞任务来寻找可运行的任务，效率低下。
#### **改进方案：将阻塞任务附加到导致阻塞的节点**

- **待处理列表（Pending List）**：每个锁定的节点包含一个待处理列表，保存所有因该节点阻塞的任务。
- **好处**：**减少调度器的负担**：不需要遍历阻塞任务。**直接关联**：阻塞任务与阻塞原因直接关联，解锁时方便处理。
#### **待处理列表的使用**

1. **锁定节点时**：初始化其待处理列表为空 []。
2. **任务遇到锁定节点时**：将自己添加到该节点的待处理列表中。
3. **节点解锁时**：将其待处理列表中的所有任务转移到机器的本地状态中，以便调度器可以调度它们。
### **5.5.1 节：数据结构**

#### **修改节点数据结构**

添加待处理列表的字段：

```haskell
data Node = NNum Int                   -- 数字
          | NAp Addr Addr              -- 应用节点
          | NGlobal Int GmCode         -- 全局节点
          | NInd Addr                  -- 间接节点
          | NConstr Int [Addr]         -- 构造函数节点
          | NLAp Addr Addr PgmPendingList        -- 锁定的应用节点
          | NLGlobal Int GmCode PgmPendingList   -- 锁定的全局节点
```

- **PgmPendingList**：表示任务列表的类型。
```haskell
type PgmPendingList = [PgmLocalState]
```

#### **练习 5.17**

**任务**：修改 `showNode` 函数，以适应新的节点定义，正确显示锁定节点和其待处理列表。

#### **修改 gmSparks 的类型**

- **从**：type GmSparks = [Addr]（地址列表）
- **改为**：type GmSparks = [PgmLocalState]（任务列表）
#### **练习 5.18**

**任务**：

- 修改 par 指令的转换，使其将任务放入 Spark Pool，而不是地址。
- 修改 showSparks 函数，显示 Spark Pool 中任务的数量。
- 修改 steps 函数，因为现在不需要将 Spark Pool 中的项目转换为任务。
### **5.5.2 节：锁定和解锁**

#### **解锁时处理待处理任务**

**定义 emptyPendingList 函数**：

```haskell
emptyPendingList :: [PgmLocalState] -> GmState -> GmState
emptyPendingList tasks state = putSparks (tasks ++ getSparks state) state
```

- **作用**：将节点待处理列表中的任务转移到 Spark Pool 中。
#### **练习 5.19**

**任务**：修改 `unlock` 函数，使其在解锁节点时，将待处理列表中的任务转移到 Spark Pool。

#### **锁定节点时初始化待处理列表**

- **修改 lock 函数**，在锁定节点时，初始化其待处理列表为空 []。
#### **练习 5.20**

**任务**：修改 `lock` 函数，使其为新锁定的节点赋予一个空的待处理列表。

#### **任务阻塞时的处理**

- **问题**：当一个任务尝试展开一个锁定的节点时，需要将其放入该节点的待处理列表，并从本地状态中移除。
- **解决方案**：将阻塞的任务替换为一个 **空任务（emptyTask）**，以保持本地状态的结构一致。
```haskell
emptyTask :: PgmLocalState
emptyTask = ([], [], [], [], 0)
```

#### **Unwind 指令的新转换规则**

1. **对于锁定的应用节点**：
```less
 <[Unwind], a : s>
=>  emptyTask
```

- **解释**：将任务添加到节点的待处理列表中，并将其替换为空任务。
2. **对于锁定的全局节点**：
```less
 <[Unwind], a : s>
=>  emptyTask
```
#### **练习 5.21**

**任务**：修改 `unwind` 函数，实现 Unwind 指令的新转换规则。

- **注意**：需要在重新排列堆栈时，修改 `getArg` 函数：
```haskell
getArg (NLAp a1 a2 pl) = a2
```
#### **练习 5.22**

**任务**：修改 `scheduler` 函数，将不可运行的任务放入 Spark Pool。

#### **练习 5.23**

**任务**：修改 `doAdmin` 函数，从本地状态中过滤掉空任务 `emptyTask`，以免影响任务调度。

### **5.6 结论**

- **实现懒惰函数式语言的并行性是可行的**：通过共享内存的方式，利用图作为通信和同步的媒介。
- **优化是必要的**：初始的简单方案（Mark 1）存在效率问题，需要通过锁定机制、有限处理器和改进的阻塞处理来优化。
- **挑战依然存在**：**推测性并行的处理**：需要解决任务优先级和资源分配的问题，目前未在本章中实现。**发现并行性**：在大型程序中找到非推测性的并行性是困难的，可能需要使用抽象解释等高级技术。**分布式内存并行机器**：与共享内存的实现类似，但在实际中需要处理消息传递和死锁等复杂问题。
**全面详尽的总结**

在本节中，我们从 Mark 1 开始，逐步改进并行 G-机器，解决了在并行执行懒惰函数式语言时遇到的关键问题。我们引入了节点锁定机制，防止了重复计算，提高了资源利用效率。在 Mark 3 中，我们考虑了现实的硬件限制，限制了同时运行的任务数量，并引入了调度策略来管理任务执行。

为了进一步优化，我们在 Mark 4 中改进了阻塞任务的处理方式，将阻塞的任务直接附加到导致阻塞的节点上，减少了调度器的负担，提高了系统的整体效率。

**主要收获**：

- **节点锁定和解锁机制**：有效地防止了重复计算，确保了任务间的正确同步。
- **有限处理器和调度策略**：通过限制处理器数量，模拟了现实的硬件环境，并通过调度策略优化了任务的执行顺序。
- **阻塞任务的高效管理**：通过待处理列表，将阻塞任务与其阻塞原因直接关联，简化了阻塞任务的管理和调度。
**挑战和未来工作**：

- **推测性并行的实现**：需要解决任务优先级、资源管理和任务删除等复杂问题。
- **发现并行性**：在大型程序中识别可并行的部分依然是一个挑战，可能需要借助抽象解释等高级技术。
- **分布式内存的实现**：在分布式环境中实现并行 G-机器，需要解决消息传递和避免死锁等问题。
通过对并行 G-机器的深入理解和改进，我们为进一步研究和实现高效的并行懒惰函数式语言奠定了坚实的基础。这些探索不仅有助于理论上的完善，也为实际应用提供了宝贵的经验和指导。
 #  
 Thought for 11 seconds
**概览**

本章（**第六章：Lambda 提升**）旨在扩展我们之前讨论的抽象机器所能接受的程序集合，特别是允许局部函数定义的存在。为了处理局部函数定义，我们有两种选择：

1. **在机器中添加处理环境（environment）的机制**。
2. **将程序转换为没有局部函数定义的形式**，即所有的函数都被定义为超级组合子（supercombinator）。
在本书中，我们一直采用第二种方法。为了实现这一点，我们需要对程序进行转换，这引出了 **Lambda 提升（Lambda Lifting）** 的概念。此外，本章还介绍了 **完全惰性（full laziness）** 的概念，这是一种对函数式语言的优化，同样通过程序转换来实现。

在深入探讨 Lambda 提升之前，我们需要改进表达式数据类型（`expr`），使其能够更灵活地表示程序中的各种信息，例如自由变量、绑定层次、类型信息、严格性分析和共享分析等。

本章的主要内容包括：

- **改进表达式数据类型**：通过参数化表达式类型，允许在抽象语法树中添加注解（annotation），以便在不同的编译阶段添加和使用各种分析信息。
- **探讨添加注解的方式**：讨论了在抽象语法树中添加注解的不同方法，以及这些方法可能带来的问题。
- **引入参数化的表达式类型**：通过参数化绑定符号和注解类型，设计了一种更灵活的表达式数据类型，以满足在编译过程中添加和使用注解的需求。
- **练习**：通过编写通用的 Pretty Printer 函数，练习如何处理新的参数化表达式数据类型和注解。
**详细解析**

### **6.1 引言**

在本章中，我们将探讨如何扩展之前讨论的抽象机器所能接受的程序集合，特别是引入 **局部函数定义（local function definitions）**。在此之前，我们的抽象机器只能处理全局定义的函数，即所有函数都被定义为超级组合子（supercombinator）。

为了处理局部函数定义，我们有两种选择：

1. **添加环境机制**：在抽象机器中添加处理环境（environment）的机制，以便在执行时能够访问局部定义的函数和变量。
2. **程序转换**：将程序转换为没有局部函数定义的形式，即 **所有的函数都被提升为顶层定义（supercombinator）**。这种转换过程被称为 **Lambda 提升（Lambda Lifting）**。
在本书中，我们一直采用第二种方法，即通过程序转换来消除局部函数定义。这种方法的好处是：

- **简化抽象机器的设计**：不需要在机器中处理复杂的环境机制。
- **统一处理函数定义**：所有的函数都被提升为顶层定义，简化了编译和执行过程。
此外，本章还将在适当的时候介绍 **完全惰性（full laziness）** 的概念。这是一种对函数式语言的优化技术，同样通过程序转换来实现。

### **6.2 改进表达式数据类型**

在开始正式的程序转换之前，我们需要改进表达式数据类型，使其能够更灵活地表示程序中的各种信息，例如自由变量、绑定层次、类型信息、严格性分析和共享分析等。

#### **导入模块**

首先，我们需要导入语言和实用工具模块：

```haskell
module Lambda where
import Utils
import Language
```

#### **现有的表达式数据类型的问题**

不幸的是，`Language` 模块中定义的数据类型（如 `coreExpr`、`coreProgram` 等）对于我们在本章中的需求来说不够灵活。许多编译器的各个阶段都会在抽象语法树（AST）上添加信息，我们需要一种系统化的方法来表示这些信息。

**示例**：需要添加信息的编译器分析包括：

- **自由变量分析（Free-variable analysis）**：确定在表达式中使用的自由变量。
- **绑定层次分析（Binding level analysis）**：确定变量的绑定深度或层次。
- **类型推导（Type inference）**：为表达式中的每个子表达式和绑定变量推导类型。
- **严格性分析（Strictness analysis）**：分析函数参数的严格性。
- **共享分析（Sharing analysis）**：确定哪些表达式可以共享计算结果。
#### **添加注解的初步方法**

最明显的方法是在表达式数据类型中添加一个新的构造子，用于表示注解，例如：

```haskell
expr * = EVar name
       | ...
       | EAnnot annotation (expr *)
```

同时，定义一个用于注解的辅助数据类型，可以根据需要进行扩展：

```haskell
annotation ::= FreeVars (set name)
             | Level num
```

这样，我们就可以在抽象语法树中的任何位置添加注解节点。

##### **存在的问题**

虽然这种方法看起来灵活，但在实践中存在两个主要缺点：

1. **使用注解信息困难**：
- 如果一个编译器阶段需要使用前一个阶段在每个树节点上添加的注解信息（例如自由变量信息），处理起来会非常麻烦。
- 假设注解节点直接位于每个树节点之上，但数据类型允许在每个节点上出现多个注解节点，甚至可能没有注解节点。
- 即使程序员保证每个节点之上恰好有一个注解节点，且它是自由变量注解，编译器在提取注解时仍需要进行模式匹配来检查这些断言。
- 这些问题导致了：**程序员需要进行无法验证的断言**：需要手动保证注解的正确性。**实现上的开销**：在提取注解时需要进行额外的模式匹配和检查。
2. **需要两种不同形式的注解**：
- **第一种**：如上所述，对表达式进行注解。
- **第二种**：对变量的绑定出现（binder）进行注解，例如 `let(rec)` 定义的左侧、`lambda` 抽象或 `case` 表达式中的绑定变量。
- **示例**：在类型推导中，编译器不仅需要为每个子表达式推导类型，还需要为每个绑定变量推导类型。
- 虽然可以使用表达式注解来注解绑定符号，但这样做非常笨拙和不方便。
#### **解决方案**

首先，我们解决第二个问题，因为它有一个简单的解决方案。

##### **参数化表达式中的绑定符号类型**

回顾第一章中 `expr` 类型的定义（回顾自 1.3 节）：

```haskell
expr *
  ::= EVar name              -- 变量
     | ENum num              -- 数字
     | EConstr num num       -- 构造函数（标签，元数）
     | EAp (expr *) (expr *) -- 应用
     | ELet isRec [(*, expr *)] (expr *)  -- Let(rec) 表达式
     | ECase (expr *) [alter *]           -- Case 表达式
     | ELam [*] (expr *)                  -- Lambda 抽象
```

其中，`expr *` 表示参数化的表达式，`*` 是绑定符号的类型。

`coreExpr` 是一种特殊的 `expr`，其中绑定符号的类型是 `name`：

```haskell
coreExpr == expr name
```

通过参数化 `expr`，我们可以定义其他形式的表达式。例如，`typedExpr` 可以表示绑定符号带有类型注解的表达式：

```haskell
typedExpr = expr (name, typeExpr)
```

其中，`typeExpr` 是表示类型表达式的数据类型。

##### **参数化注解类型**

为了在表达式中添加注解，我们可以重用相同的技术，通过 **参数化表达式的数据类型，使其能够携带注解**。

我们的目标是：

- **在抽象语法树的每个节点上都携带注解**。
- **注解的类型可以灵活指定**。
一种可能的方法是在每个构造子中添加一个额外的字段，用于存储注解信息。然而，这在实际使用中不太方便，例如，如果我们希望在给定表达式的顶部提取注解信息，而不需要对根节点进行模式匹配。

因此，我们引入以下想法：

- **树的每一层都是一个对（pair）**，其第一分量是注解，第二分量是抽象语法树节点。
#### **定义参数化的表达式数据类型**

下面是相应的 Haskell 数据类型定义：

```haskell
type AnnExpr a b = (b, AnnExpr' a b)

data AnnExpr' a b = AVar Name
                  | ANum Int
                  | AConstr Int Int
                  | AAp (AnnExpr a b) (AnnExpr a b)
                  | ALet Bool [AnnDefn a b] (AnnExpr a b)
                  | ACase (AnnExpr a b) [AnnAlt a b]
                  | ALam [a] (AnnExpr a b)

type AnnDefn a b = (a, AnnExpr a b)
type AnnAlt a b = (Int, [a], AnnExpr a b)
type AnnProgram a b = [(Name, [a], AnnExpr a b)]
```

**解释**：

- **AnnExpr a b**：表示带有注解的表达式，其中：`a`：绑定符号的类型（binder type）。`b`：注解的类型（annotation type）。`AnnExpr a b` 是一个对，第一分量是注解 `b`，第二分量是 `AnnExpr' a b`，表示表达式节点。
- **AnnExpr' a b**：定义了各种表达式节点的构造子，包括变量、数字、构造函数、应用、`let`、`case` 和 `lambda` 抽象。
- **AnnDefn a b**：表示 `let` 定义中的绑定和表达式。
- **AnnAlt a b**：表示 `case` 表达式中的替代（alternative），包括标签、绑定符号列表和表达式。
- **AnnProgram a b**：表示一个程序的列表，每个元素是一个三元组，包括函数名、参数列表和带注解的表达式。
**注意**：

- 通过在 `AnnExpr` 中引入注解，我们确保了 **抽象语法树的每个节点都携带注解**。
- **互相递归**：`AnnExpr` 和 `AnnExpr'` 之间的互相递归确保了这一点。
- **类型参数化**：注解的类型 `b` 和绑定符号的类型 `a` 都是参数化的，可以根据需要灵活指定。
#### **优势**

- **注解类型显式化**：表达式所携带的注解类型在类型系统中显式体现，编译器可以在编译时检查注解的类型。
- **方便提取注解**：由于每个节点都包含注解，可以直接访问，而不需要对节点进行模式匹配。
- **支持对绑定符号的注解**：通过参数化绑定符号的类型 `a`，我们可以为绑定符号添加注解，例如类型信息或自由变量信息。
#### **存在的弱点**

- **代码冗余**：我们不得不为 `AnnExpr'` 和 `expr` 定义两套基本相同的构造子，这导致了代码的重复。
- **无法避免的原因**：在 Hindley-Milner 类型系统中，似乎无法避免这种情况。
- **选择保留 expr 类型**：虽然我们可以放弃 `expr` 类型，完全使用 `AnnExpr`，但有两个原因不这样做：**类型不完全同构**：`expr *` 与 `AnnExpr * **` 之间不完全同构，因为后者将 `((), ⊥)` 与 `⊥` 区分开来，而前者不区分。**书写繁琐**：在构建和模式匹配类型为 `AnnExpr * **` 的树时，需要书写大量的 `()`，会非常繁琐。
#### **总结**

通过参数化表达式的数据类型，我们实现了一种灵活的方法，可以在抽象语法树中添加注解，并为绑定符号添加注解。这种方法在现代函数式编程语言提供的代数数据类型中体现了其优势，但也暴露了一些弱点，例如代码的重复和类型系统的限制。

### **练习 6.1**

**任务**：

我们的现有 Pretty Printer 函数 `pprint`（在 1.5 节中定义）只能打印 `coreProgram` 类型的程序。为了打印 Lambda 提升过程中产生的中间结果，我们需要一个能够显示类型为 `program *` 的值的函数 `pprintGen`（`Gen` 表示 "generic"，通用的）。

`pprintGen` 需要一个额外的参数，用于指定如何打印绑定符号：

```haskell
pprintGen :: (* -> iseq)  -- 从绑定符号到 iseq 的函数
          -> program *    -- 要格式化的程序
          -> [char]       -- 输出的字符串
```

例如，一旦我们编写了 `pprintGen`，我们就可以用它来定义 `pprint`：

```haskell
pprint prog = pprintGen iStr prog
```

**要求**：

- 编写 pprintGen 的定义，以及相关的辅助函数 pprExprGen 等。
**思路**：

- **program * 类型**：表示绑定符号类型为 `*` 的程序。
- **需要提供一个函数**：用于将绑定符号转换为 `iseq`，以便打印。
- **pprintGen 的作用**：遍历程序的抽象语法树，使用提供的函数打印绑定符号。
**实现步骤**：

1. **定义 pprintGen 函数**：
- 接受一个函数 `(* -> iseq)`，用于打印绑定符号。
- 遍历程序的定义列表，调用辅助函数 `pprScDefnGen`。
2. **定义 pprScDefnGen 函数**：
- 用于打印超级组合子的定义。
- 接受打印绑定符号的函数，格式化输出。
3. **定义 pprExprGen 函数**：
- 用于打印表达式。
- 在遇到绑定符号时，使用提供的函数进行打印。
### **练习 6.2**

**任务**：

对类型为 `annProgram * **` 的值进行类似的处理。这里，我们需要两个额外的参数，一个用于格式化绑定符号，一个用于格式化注解：

```haskell
pprintAnn :: (* -> iseq)   -- 从绑定符号到 iseq 的函数
          -> (** -> iseq)  -- 从注解到 iseq 的函数
          -> annProgram * **  -- 要显示的程序
          -> [char]        -- 输出的字符串
```

**要求**：

- 编写 pprintAnn 的定义，以及相关的辅助函数。
**思路**：

- **annProgram * ** 类型**：表示绑定符号类型为 `*`，注解类型为 `**` 的带注解的程序。
- **需要提供两个函数**：一个用于打印绑定符号，一个用于打印注解。
- **pprintAnn 的作用**：遍历带注解的程序的抽象语法树，使用提供的函数打印绑定符号和注解。
**实现步骤**：

1. **定义 pprintAnn 函数**：
- 接受两个函数，分别用于打印绑定符号和注解。
- 遍历程序的定义列表，调用辅助函数 `pprAnnScDefn`。
2. **定义 pprAnnScDefn 函数**：
- 用于打印带注解的超级组合子的定义。
- 接受打印绑定符号和注解的函数，格式化输出。
3. **定义 pprAnnExpr 函数**：
- 用于打印带注解的表达式。
- 在遇到绑定符号和注解时，使用提供的函数进行打印。
**全面详尽的总结**

在本章中，我们探讨了如何扩展之前讨论的抽象机器，以接受包含局部函数定义的程序。我们讨论了两种可能的解决方案：

1. **在机器中添加处理环境的机制**：这需要在抽象机器中实现环境的支持，以处理局部变量和函数的绑定和查找。
2. **通过程序转换消除局部函数定义**：即将所有局部函数提升为顶层定义（超级组合子）。这种转换被称为 **Lambda 提升（Lambda Lifting）**。
在本书中，我们采用了第二种方法，因为它可以简化抽象机器的设计，不需要在机器中处理环境的复杂性。

为了实现 Lambda 提升和其他程序转换，我们需要在抽象语法树中添加各种注解，例如自由变量信息、类型信息等。然而，现有的表达式数据类型（如 `coreExpr`）在灵活性上有所不足，无法满足我们的需求。

我们讨论了在抽象语法树中添加注解的不同方法，发现直接在表达式类型中添加注解构造子存在一些问题，例如：

- **难以保证注解的一致性**：程序员需要手动保证每个节点都有正确的注解，无法通过类型系统进行检查。
- **实现上的复杂性**：在提取注解时需要进行额外的模式匹配，增加了实现的开销。
为了解决这些问题，我们引入了参数化的表达式数据类型，通过参数化绑定符号类型和注解类型，实现了更灵活的表达式表示方法。具体来说，我们定义了 `AnnExpr a b` 类型，其中 `a` 是绑定符号的类型，`b` 是注解的类型。这样，我们可以在抽象语法树的每个节点上携带注解，并通过类型系统来保证注解的正确性。

这种方法的优势在于：

- **注解类型在类型系统中显式化**，编译器可以在编译时检查注解的类型。
- **方便地添加和使用注解**，无需在每次提取注解时进行复杂的模式匹配。
- **支持对绑定符号的注解**，可以在编译过程中为绑定符号添加类型信息、自由变量信息等。
然而，这种方法也有一些不足之处：

- **代码的重复**：我们需要为 `AnnExpr'` 和 `expr` 定义两套基本相同的构造子，增加了代码的冗余。
- **类型系统的限制**：在 Hindley-Milner 类型系统中，似乎无法避免这种代码重复。
最后，通过练习 6.1 和 6.2，我们练习了如何编写通用的 Pretty Printer 函数，以处理新的参数化表达式数据类型和注解。这有助于我们深入理解新的数据类型的结构，以及如何在实际编程中使用它们。

通过本章的学习，我们了解了在实现函数式语言编译器时，如何灵活地表示和处理抽象语法树中的各种信息。参数化的数据类型和注解机制使得我们能够在编译的不同阶段添加和使用各种分析信息，为后续的程序转换和优化奠定了基础。

在接下来的章节中，我们将进一步探讨 Lambda 提升的实现，以及如何通过程序转换来优化函数式程序的执行。
 #  
 Thought for 9 seconds
**概览**

本节（**6.3 Mark 1: 一个简单的 Lambda 提升器**）主要讨论了如何通过 **Lambda 提升（Lambda Lifting）** 来处理函数式编程语言中的局部函数定义。Lambda 提升是一种程序转换技术，它将程序中的局部函数转换为全局的超级组合子（supercombinator），从而消除了嵌套的 Lambda 抽象。这种转换使得程序更容易在没有环境机制的抽象机器（如我们之前讨论的 G-机器）上实现。

本节的主要内容包括：

- **引入 Lambda 提升的概念**：解释为什么需要消除自由变量，以及 Lambda 提升如何解决这个问题。
- **示例演示**：通过具体的示例展示如何将含有自由变量的局部函数转换为没有自由变量的全局函数。
- **实现一个简单的 Lambda 提升器**：详细介绍实现 Lambda 提升器的三个主要步骤，包括计算自由变量、抽象 Lambda 表达式，以及重命名变量使其唯一化。
- **代码实现和解释**：提供了完整的代码实现，并逐步解释了每个函数的作用和实现细节。
**详细解析**

### **6.3 Mark 1：一个简单的 Lambda 提升器**

#### **引入**

在实现一个具有词法作用域的编程语言时，我们需要处理函数或过程可能包含自由变量的情况。如果不以某种方式消除这些自由变量，基于环境的实现需要操作链接的环境帧，而基于归约的系统由于在替换过程中需要重命名而变得复杂得多。

**Lambda 提升（Lambda Lifting）** 是一种流行的方法，尤其在图归约（graph reduction）实现中，用于消除函数定义中的所有自由变量。这个概念由 [Johnsson 1985] 提出，但最初由 [Hughes 1983] 独立开发。

在我们的上下文中，Lambda 提升将一个 Core 语言的程序转换为一个等价的、没有嵌套 Lambda 抽象的程序。

#### **示例**

考虑以下程序：

```haskell
f x = let g = \y. x*x + y in (g 3 + g 4)
main = f 6
```

在这个程序中，`g` 是一个局部函数，通过 Lambda 抽象 `\y. x*x + y` 定义。注意到 `x` 是在 `g` 中的自由变量，因为它在 `g` 的定义中使用，但不在 `g` 的参数中。

**Lambda 提升的步骤**：

1. **识别自由变量**：找到 Lambda 抽象中的自由变量。在这个例子中，`x` 是 `\y. x*x + y` 的自由变量。
2. **创建新的超级组合子**：定义一个新的超级组合子 `$g`，将自由变量作为额外的参数。
3. **替换原有的 Lambda 抽象**：用对新的超级组合子的应用来替换原有的 Lambda 抽象。
转换后的程序如下：

```haskell
$g x y = x*x + y
f x = let g = $g x in (g 3 + g 4)
main = f 6
```

**解释**：

- 新的超级组合子 `$g` 是一个顶层函数，接受 `x` 和 `y` 作为参数。
- 在 `f` 中，`g` 被定义为 `$g x`，即部分应用 `$g`，绑定了自由变量 `x`。
- 调用 `g 3` 和 `g 4` 时，实际上是调用 `$g x 3` 和 `$g x 4`。
#### **处理递归的情况**

如果 `g` 是递归的，例如：

```haskell
f x = letrec g = \y. cons (x*y) (g y) in g 3
main = f 6
```

在这种情况下，`x` 和 `g` 都是 `\y. cons (x*y) (g y)` 的自由变量。通过 Lambda 提升，我们将它们都作为额外的参数：

```haskell
$g g x y = cons (x*y) (g y)
f x = letrec g = $g g x in g 3
main = f 6
```

**注意**：

- 在新的超级组合子 `$g` 中，`g` 和 `x` 都是参数。
- 在 `f` 中，`g` 被定义为 `$g g x`，其中 `g` 是递归的，因此需要传递自身。
#### **关于全局函数的处理**

对于全局定义的函数，例如内置函数或顶层定义的函数，我们不需要将它们作为自由变量处理。例如：

```haskell
h p q = p*q
f x = let g = \y. (h x x) + y in (g 3 + g 4)
main = f 6
```

在这个例子中，`h` 是一个全局函数，我们不需要将其作为自由变量，因为它可以直接在 `$g` 的主体中引用。同样的道理适用于内置的 `+` 和 `*` 函数。

**结论**：只有在 Lambda 抽象中出现的超级组合子的参数和由 Lambda 抽象或 `let(rec)` 表达式绑定的变量，才需要作为自由变量处理。

#### **与其他语言的比较**

值得注意的是，词法作用域的问题并不限于函数式语言。例如，Pascal 允许在另一个函数中本地声明一个函数，而内部函数可能有由外部作用域绑定的自由变量。而 C 语言不允许这样的本地定义。

在没有副作用的情况下，可以简单地将一个本地函数定义转换为一个全局函数：只需将自由变量作为额外的参数，并在每次调用时添加这些参数。这正是 Lambda 提升所做的。

### **6.3.1 实现一个简单的 Lambda 提升器**

现在，我们准备实现一个简单的 Lambda 提升器。它将接受一个 `coreProgram`，返回一个等价的、没有 `ELam` 构造子的 `coreProgram`。

```haskell
lambdaLift :: CoreProgram -> CoreProgram
```

**Lambda 提升器的三个主要步骤**：

1. **计算自由变量（free variable analysis）**：
- **目的**：在表达式的每个节点上注解其自由变量。
- **原因**：在下一步中，我们需要知道每个 Lambda 抽象的自由变量，以决定要添加哪些额外的参数。
- **函数**：
```haskell
freeVars :: CoreProgram -> AnnProgram Name (Set Name)
```
这里，`AnnProgram Name (Set Name)` 是带有自由变量注解的程序。`Set Name` 是一个集合，用于存储自由变量的名称。
2. **抽象 Lambda 表达式（abstracting lambda expressions）**：
- **目的**：将每个 Lambda 抽象 `\x1 ... xn. e` 转换为一个新的超级组合子，并将其自由变量作为额外的参数。
- **方法**：将 Lambda 抽象替换为如下形式：
```bash
(let sc = \v1 ... vm x1 ... xn. e in sc) v1 ... vm
```
其中，`v1 ... vm` 是自由变量列表。我们使用一个 `let` 表达式来给新的超级组合子命名为 `sc`。
- **函数**：
```haskell
abstract :: AnnProgram Name (Set Name) -> CoreProgram
```
`abstract` 函数接受带有自由变量注解的程序，返回一个新的 `coreProgram`，其中 Lambda 抽象被替换了。
3. **重命名变量（renaming variables）**：
- **目的**：遍历程序，为每个变量赋予一个唯一的名称。
- **原因**：确保在整个程序中，每个变量都是唯一的，特别是我们在上一阶段引入的 `sc` 变量。
- **函数**：
```haskell
rename :: CoreProgram -> CoreProgram
```
4. **收集超级组合子（collecting supercombinators）**：
- **目的**：收集所有的超级组合子定义到一个列表中，并将它们放在程序的顶层。
- **函数**：
```haskell
collectSCs :: CoreProgram -> CoreProgram
```
**Lambda 提升器的总体定义**：

```haskell
lambdaLift = collectSCs . rename . abstract . freeVars
```

- 这表示 lambdaLift 是这四个函数的组合：首先计算自由变量，然后抽象 Lambda 表达式，接着重命名变量，最后收集超级组合子。
**辅助函数**：

为了方便观察发生了什么，我们定义了一个函数 `runS`（`S` 代表 "simple"），它整合了解析器和打印器：

```haskell
runS = pprint . lambdaLift . parse
```

**为什么要分成多个步骤**：

- 虽然可以在单个阶段完成所有工作，但将其分为多个步骤有许多优点：**可读性和可维护性**：每个单独的阶段更容易理解。**可重用性**：某些阶段可以被重复使用，例如 `freeVars` 函数。**模块化**：更容易对算法进行修改。
**注意事项**：

- 有些编译器可能会通过省略 `collectSCs` 阶段来生成更好的代码，因为这样可以更好地了解超级组合子的上下文。例如：
```haskell
let f = (\v x. v - x) v
in ...f...f...
```
在这里，`abstract` 阶段已经将 `v` 作为自由变量移出了 `\x` 抽象。如果编译器能够直接在上下文中构造 `f` 的闭包，它可以更有效地访问 `v`，不需要在调用 `f` 时将 `v` 移动到堆栈上。
- **嵌套的 Lambda 抽象**：`abstract_e` 函数将会分别处理两个嵌套的 Lambda 抽象，生成两个超级组合子。为了优化，我们可以在 Lambda 提升之前合并直接嵌套的 `ELam`，这等同于 [Hughes 1983] 提到的 η-抽象优化。
### **6.3.2 计算自由变量**

**核心函数**：`freeVars_e`

```haskell
freeVars_e :: (Set Name) -- 候选的自由变量集合（局部变量）
            -> CoreExpr   -- 要注解的表达式
            -> AnnExpr Name (Set Name) -- 带有自由变量注解的表达式
```

- **参数**：**lv**：局部变量的集合，表示在当前作用域中已绑定的变量。**CoreExpr**：要处理的表达式。
- **返回值**：带有自由变量注解的表达式。
**主函数**：`freeVars`

```haskell
freeVars :: CoreProgram -> AnnProgram Name (Set Name)
```

- 对程序中的每个超级组合子定义，应用 `freeVars_e`。
- **实现**：
```haskell
freeVars prog = [ (name, args, freeVars_e (setFromList args) body)
                | (name, args, body) <- prog
                ]
```
对于每个超级组合子：**name**：超级组合子的名称。**args**：参数列表。**body**：函数体。**setFromList args**：将参数列表转换为集合，作为初始的局部变量集合 `lv`。
**freeVars_e 函数的实现**

1. **处理数字（ENum）**：
```haskell
freeVars_e lv (ENum k) = (setEmpty, ANum k)
```

- 数字没有自由变量，返回空集合。
2. **处理变量（EVar）**：
```haskell
freeVars_e lv (EVar v) | setElementOf v lv = (setSingleton v, AVar v)
                       | otherwise         = (setEmpty, AVar v)
```

- 如果变量 `v` 在局部变量集合 `lv` 中，那么它是一个自由变量，返回包含 `v` 的单元素集合。
- 否则，返回空集合。
3. **处理应用（EAp）**：
```haskell
freeVars_e lv (EAp e1 e2) = (setUnion (freeVarsOf e1') (freeVarsOf e2'), AAp e1' e2')
  where
    e1' = freeVars_e lv e1
    e2' = freeVars_e lv e2
```

- 递归地处理 e1 和 e2，然后取它们的自由变量集合的并集。
4. **处理 Lambda 抽象（ELam）**：
```haskell
freeVars_e lv (ELam args body) = (setSubtraction (freeVarsOf body') (setFromList args), ALam args body')
  where
    body' = freeVars_e new_lv body
    new_lv = setUnion lv (setFromList args)
```

- 将参数列表 `args` 添加到局部变量集合 `lv` 中，形成新的局部变量集合 `new_lv`。
- 递归地处理函数体 `body`。
- 自由变量集合为函数体的自由变量集合减去参数列表。
5. **处理 Let(rec) 表达式（ELet）**：
```haskell
freeVars_e lv (ELet is_rec defns body) = (setUnion defnsFree bodyFree, ALet is_rec defns' body')
  where
    binders = bindersOf defns
    binderSet = setFromList binders
    body_lv = setUnion lv binderSet
    rhs_lv = if is_rec then body_lv else lv

    rhss' = map (freeVars_e rhs_lv) (rhssOf defns)
    defns' = zip2 binders rhss'

    freeInValues = setUnionList (map freeVarsOf rhss')
    defnsFree = if is_rec then setSubtraction freeInValues binderSet else freeInValues

    body' = freeVars_e body_lv body
    bodyFree = setSubtraction (freeVarsOf body') binderSet
```

- **binders**：定义中的绑定变量列表。
- **binderSet**：绑定变量集合。
- **body_lv**：在处理 `body` 时的局部变量集合，包含当前的 `lv` 和 `binders`。
- **rhs_lv**：在处理右侧表达式时的局部变量集合。如果是递归定义（`is_rec` 为 `True`），则 `rhs_lv` 包含 `body_lv`。否则，`rhs_lv` 仅为当前的 `lv`。
- **处理右侧表达式**：对每个右侧表达式递归调用 `freeVars_e`，得到 `rhss'`。将绑定变量和处理后的右侧表达式组合成新的定义列表 `defns'`。
- **计算定义中的自由变量集合 defnsFree**：对所有右侧表达式的自由变量集合取并集。如果是递归定义，减去绑定变量集合。
- **处理 body**：递归调用 `freeVars_e`，得到 `body'`。计算 `body` 中的自由变量集合 `bodyFree`，减去绑定变量集合。
- **最终的自由变量集合**：`defnsFree` 和 `bodyFree` 的并集。
**辅助函数**：

- **freeVarsOf**：提取带注解的表达式的自由变量集合。
```haskell
freeVarsOf :: AnnExpr Name (Set Name) -> Set Name
freeVarsOf (free_vars, expr) = free_vars
```
### **6.3.3 生成超级组合子**

在这一阶段，我们将每个 Lambda 抽象替换为一个新的超级组合子应用于其自由变量。

**主函数**：`abstract`

```haskell
abstract :: AnnProgram Name (Set Name) -> CoreProgram
```

- 对程序中的每个超级组合子定义，应用 `abstract_e`。
- **实现**：
```haskell
abstract prog = [ (sc_name, args, abstract_e rhs)
                | (sc_name, args, rhs) <- prog
                ]
```
**辅助函数**：`abstract_e`

```haskell
abstract_e :: AnnExpr Name (Set Name) -> CoreExpr
```

- **参数**：带有自由变量注解的表达式。
- **返回值**：处理后的 `CoreExpr`，其中 Lambda 抽象被替换。
**实现**：

1. **处理变量和数字**：
```haskell
abstract_e (free, AVar v) = EVar v
abstract_e (free, ANum k) = ENum k
```
2. **处理应用**：
```haskell
abstract_e (free, AAp e1 e2) = EAp (abstract_e e1) (abstract_e e2)
```
3. **处理 Let(rec) 表达式**：
```haskell
abstract_e (free, ALet is_rec defns body) = ELet is_rec [ (name, abstract_e body) | (name, body) <- defns ] (abstract_e body)
```
4. **处理 Lambda 抽象**（关键部分）：
```haskell
abstract_e (free, ALam args body) = foldll EAp sc (map EVar fvList)
  where
    fvList = setToList free
    sc = ELet nonRecursive [("sc", sc_rhs)] (EVar "sc")
    sc_rhs = ELam (fvList ++ args) (abstract_e body)
```

- **步骤**：**获取自由变量列表 fvList**：将自由变量集合转换为列表。**创建新的超级组合子 sc**：使用 `ELet` 表达式，定义一个新的超级组合子 `sc`。**sc_rhs**：新的超级组合子的函数体。构造一个新的 `ELam`，其参数列表为 `fvList ++ args`，即自由变量列表加上原来的参数列表。函数体为递归调用 `abstract_e` 处理过的 `body`。**应用超级组合子**：使用 foldll EAp，将超级组合子 sc 应用于每个自由变量。**结果**：一个新的表达式，其中 Lambda 抽象被替换为超级组合子应用于自由变量。
### **6.3.4 变量重命名**

这一阶段，我们需要为程序中的每个变量赋予唯一的名称，以确保变量不冲突，特别是之前引入的 `sc`。

**辅助函数**：`rename_e`

```haskell
rename_e :: ASSOC Name Name  -- 环境：将旧名字映射到新名字
         -> NameSupply       -- 名字供应器
         -> CoreExpr         -- 输入的表达式
         -> (NameSupply, CoreExpr) -- 返回新的名字供应器和处理后的表达式
```

**主函数**：`rename`

```haskell
rename :: CoreProgram -> CoreProgram
```

- 使用 `mapAccuml` 和 `rename_sc` 对每个超级组合子进行处理。
- **实现**：
```haskell
rename prog = second (mapAccuml rename_sc initialNameSupply prog)
  where
    rename_sc ns (sc_name, args, rhs) = (ns2, (sc_name, args', rhs'))
      where
        (ns1, args', env) = newNames ns args
        (ns2, rhs') = rename_e env ns1 rhs
```
- **newNames 函数**：
```haskell
newNames :: NameSupply -> [Name] -> (NameSupply, [Name], ASSOC Name Name)
newNames ns old_names = (ns', new_names, env)
  where
    (ns', new_names) = getNames ns old_names
    env = zip2 old_names new_names
```
为旧的名字分配新的唯一名字，返回更新后的名字供应器、新的名字列表，以及旧名字到新名字的映射。
**rename_e 的实现**

1. **处理变量（EVar）**：
```haskell
rename_e env ns (EVar v) = (ns, EVar (aLookup env v v))
```

- 如果变量在环境中有映射，使用新的名字，否则保持不变。
2. **处理数字（ENum）**：
```haskell
rename_e env ns (ENum n) = (ns, ENum n)
```
3. **处理应用（EAp）**：
```haskell
rename_e env ns (EAp e1 e2) = (ns2, EAp e1' e2')
  where
    (ns1, e1') = rename_e env ns e1
    (ns2, e2') = rename_e env ns1 e2
```
4. **处理 Lambda 抽象（ELam）**：
```haskell
rename_e env ns (ELam args body) = (ns1, ELam args' body')
  where
    (ns1, args', env') = newNames ns args
    (ns2, body') = rename_e (env' ++ env) ns1 body
```

- 为参数列表中的每个变量分配新的名字，更新环境。
- 递归处理函数体。
5. **处理 Let(rec) 表达式（ELet）**：
```haskell
rename_e env ns (ELet is_rec defns body) = (ns3, ELet is_rec (zip2 binders' rhss') body')
  where
    (ns1, body') = rename_e body_env ns body
    binders = bindersOf defns
    (ns2, binders', env') = newNames ns1 binders
    body_env = env' ++ env
    (ns3, rhss') = mapAccuml (rename_e rhsEnv) ns2 (rhssOf defns)
    rhsEnv = if is_rec then body_env else env
```

- 对绑定变量分配新名字，更新环境。
- 如果是递归定义，右侧表达式的环境包括新的绑定变量。
- 递归处理右侧表达式和函数体。
### **6.3.5 收集超级组合子**

最后，我们需要将所有的超级组合子收集起来，并放在程序的顶层。

**辅助函数**：`collectSCs_e`

```haskell
collectSCs_e :: CoreExpr -> ([CoreScDefn], CoreExpr)
```

- **参数**：一个 `CoreExpr`。
- **返回值**：一个超级组合子定义的列表，以及处理后的表达式。
**主函数**：`collectSCs`

```haskell
collectSCs :: CoreProgram -> CoreProgram
```

- 使用 `mapAccuml` 和 `collect_one_sc` 对每个超级组合子进行处理。
- **实现**：
```haskell
collectSCs prog = concat (map collect_one_sc prog)
  where
    collect_one_sc (sc_name, args, rhs) = (sc_name, args, rhs') : scs
      where
        (scs, rhs') = collectSCs_e rhs
```
**collectSCs_e 的实现**

- 对表达式的每个子表达式递归调用 `collectSCs_e`，收集超级组合子。
- **处理数字和变量**：
```haskell
collectSCs_e (ENum k) = ([], ENum k)
collectSCs_e (EVar v) = ([], EVar v)
```
- **处理应用**：
```haskell
collectSCs_e (EAp e1 e2) = (scs1 ++ scs2, EAp e1' e2')
  where
    (scs1, e1') = collectSCs_e e1
    (scs2, e2') = collectSCs_e e2
```
- **处理 Lambda 抽象**：
```haskell
collectSCs_e (ELam args body) = (scs, ELam args body')
  where
    (scs, body') = collectSCs_e body
```
- **处理 Let(rec) 表达式**（关键部分）：
```haskell
collectSCs_e (ELet is_rec defns body) = (rhss_scs ++ body_scs ++ local_scs, mkELet is_rec non_scs' body')
  where
    (rhss_scs, defns') = mapAccuml collectSCs_d [] defns

    scs' = [(name, rhs) | (name, rhs) <- defns', isELam rhs]
    non_scs' = [(name, rhs) | (name, rhs) <- defns', not (isELam rhs)]
    local_scs = [(name, args, body) | (name, ELam args body) <- scs']

    (body_scs, body') = collectSCs_e body

    collectSCs_d scs (name, rhs) = (scs ++ rhs_scs, (name, rhs'))
      where
        (rhs_scs, rhs') = collectSCs_e rhs
```
**步骤**：对定义列表中的每个定义，递归调用 `collectSCs_d`，收集右侧表达式中的超级组合子。将定义列表分为两部分：**超级组合子定义 scs'**：形式为 `v = \args. e`。**非超级组合子定义 non_scs'**：其他形式的定义。将超级组合子添加到 `local_scs`。递归处理函数体 `body`，收集其中的超级组合子。最终的超级组合子列表为 `rhss_scs ++ body_scs ++ local_scs`。
**辅助函数**：

- **isELam**：判断一个表达式是否是 `ELam`。
```haskell
isELam :: Expr a -> Bool
isELam (ELam args body) = True
isELam other = False
```
- **mkELet**：构造一个 `ELet` 表达式。
```haskell
mkELet is_rec defns body = ELet is_rec defns body
```
**全面详尽的总结**

在本节中，我们详细探讨了 **Lambda 提升** 的概念和实现。Lambda 提升是一种程序转换技术，旨在消除函数定义中的自由变量，通过将局部的 Lambda 抽象提升为全局的超级组合子。这种转换有助于简化抽象机器的实现，因为不再需要处理环境和自由变量。

**主要内容回顾**：

1. **引入 Lambda 提升**：
- **问题**：在词法作用域的编程语言中，函数可能包含自由变量，需要复杂的环境机制来处理。
- **解决方案**：通过 Lambda 提升，将自由变量作为额外的参数传递给新的超级组合子，消除自由变量。
2. **示例演示**：
- **非递归和递归的例子**：展示了如何处理含有自由变量的局部函数定义，以及递归函数的情况。
- **处理全局函数**：说明全局定义的函数不需要作为自由变量处理。
3. **实现一个简单的 Lambda 提升器**：
- **四个主要步骤**：**计算自由变量（freeVars）**：遍历表达式，计算每个节点的自由变量集合。**抽象 Lambda 表达式（abstract）**：将 Lambda 抽象替换为新的超级组合子应用于其自由变量。**重命名变量（rename）**：为程序中的每个变量赋予唯一的名称，避免名称冲突。**收集超级组合子（collectSCs）**：收集所有的超级组合子定义，放在程序的顶层。
- **函数实现和解释**：逐步解释了每个函数的实现细节，帮助理解 Lambda 提升的过程。
4. **代码实现和解释**：
- **freeVars_e**：计算表达式的自由变量，处理不同类型的表达式，包括变量、数字、应用、Lambda 抽象和 Let(rec) 表达式。
- **abstract_e**：将 Lambda 抽象替换为新的超级组合子应用于自由变量。
- **rename_e**：重命名变量，使每个变量在程序中都是唯一的。
- **collectSCs_e**：收集超级组合子，将它们放在程序的顶层。
**重要概念和技巧**：

- **自由变量的计算**：了解如何在递归遍历表达式的过程中计算自由变量集合。
- **Lambda 提升的转换过程**：掌握如何将 Lambda 抽象转换为超级组合子，并正确处理自由变量。
- **变量重命名**：为了避免名称冲突，需要为每个变量赋予唯一的名称，这是编译器实现中的常见技术。
- **代码的模块化和可复用性**：将 Lambda 提升器的实现分为多个阶段，每个阶段完成特定的任务，增强了代码的可读性和可维护性。
通过本节的学习，我们深入理解了 Lambda 提升的概念和实现方法，以及在函数式编程语言编译器中处理自由变量和局部函数定义的技术。这些知识对于构建高效的编译器和理解函数式编程语言的实现细节非常重要。

在后续的章节中，我们将继续探讨更复杂的程序转换和优化技术，例如完全惰性（full laziness），进一步提高函数式程序的性能。
 #  
 Thought for 2m 20s
**概览**

本节（第 6 章的 6.4 和 6.5 节）继续深入探讨 **Lambda 提升（Lambda Lifting）** 技术，这是在函数式编程语言的实现中，用于消除局部函数定义和自由变量的一种关键转换方法。此前，我们已经实现了一个简单的 Lambda 提升器，但它存在一些可以改进的地方。本节旨在对该提升器进行改进，并引入了 Johnsson 风格的 Lambda 提升。

主要内容包括：

- **6.4 Mark 2：改进简单的 Lambda 提升器****6.4.1 简单扩展**：通过练习，要求改进提升器的某些功能，如消除冗余的 `let` 表达式和处理 `case` 表达式。**6.4.2 消除冗余的超级组合子**：讨论如何避免引入不必要的超级组合子，使生成的代码更简洁高效。**6.4.3 消除冗余的局部定义**：进一步优化代码，避免在局部定义中引入多余的绑定。
- **6.5 Mark 3：Johnsson 风格的 Lambda 提升**介绍了一种由 [Johnsson 1985] 提出的 Lambda 提升变体，旨在优化递归函数的处理，使其更高效。**6.5.1 实现**：详细描述了如何实现 Johnsson 风格的 Lambda 提升器，包括各个步骤和核心函数的定义。**6.5.2 抽象函数中的自由变量**：深入解释了如何处理函数定义中的自由变量，以及如何修改抽象过程以生成更优化的代码。**6.5.3 一个棘手的问题**：指出了在处理混合了函数和变量定义的 `letrec` 表达式时可能出现的问题，并提出了改进方法。
通过这些内容，读者将深入理解 Lambda 提升的细节，以及如何优化编译器的实现，以生成更高效的代码。

**详细解析**

### **6.4 Mark 2：改进简单的 Lambda 提升器**

在之前的 6.3 节中，我们实现了一个简单的 Lambda 提升器。然而，该提升器存在一些不足之处。本节将探讨如何对其进行改进，以生成更简洁、更高效的代码。

#### **6.4.1 简单扩展**

**练习 6.3**

**问题描述**：

- 简单的 Lambda 提升器在处理 `abstract` 引入的超级组合子的 `let` 表达式时，`collectSCs` 函数会移除其中的单个绑定，导致生成了大量绑定列表为空的 `let` 表达式。
- 任务：修改 `mkELet` 函数，以消除这些冗余的 `let` 表达式。
**解释**：

- 在 Lambda 提升过程中，我们使用 `ELet` 表达式来引入新的超级组合子。然而，当 `collectSCs` 函数将这些超级组合子提取到顶层时，会移除这些绑定，使得原来的 `let` 表达式变成了没有绑定的空 `let`。
- 这些空的 `let` 表达式是多余的，没有实际作用。
- **解决方案**：修改 `mkELet` 函数，使其在遇到绑定列表为空时，直接返回 `body`，从而消除冗余的 `let` 表达式。
**实现思路**：

- 在 `mkELet` 函数中，检查绑定列表 `defns` 是否为空。
- 如果为空，则直接返回 `body`。
- 如果不为空，则返回正常的 `ELet` 表达式。
**示例代码**：

```haskell
mkELet is_rec defns body
  | null defns = body
  | otherwise  = ELet is_rec defns body
```

**练习 6.4**

**问题描述**：

- 需要为 freeVars_case、abstract_case 和 collectSCs_case 函数提供定义，并进行测试。
**解释**：

- 在之前的实现中，我们跳过了对 `case` 表达式的处理。这可能是因为示例程序中没有涉及到 `case` 表达式。
- 然而，为了使 Lambda 提升器完整并能够处理所有的 Core 语言特性，我们需要实现对 `case` 表达式的处理。
**实现思路**：

1. **freeVars_case**：
- 计算 `case` 表达式的自由变量。
- 自由变量包括被匹配的表达式的自由变量，以及所有替代（alternatives）的自由变量（减去在替代中绑定的变量）。
2. **abstract_case**：
- 对 case 表达式进行抽象处理，递归地应用 abstract_e 到被匹配的表达式和所有替代。
3. **collectSCs_case**：
- 在收集超级组合子时，处理 case 表达式，递归地收集被匹配的表达式和替代中的超级组合子。
#### **6.4.2 消除冗余的超级组合子**

**问题描述**：

- 考虑以下 Core 语言的程序：
```haskell
f = \x. x + 1
```
- 经过 Lambda 提升后，它被转换为：
```haskell
f = $f
$f x = x + 1
```
- 这样引入了一个新的超级组合子 `$f`，但实际上这是不必要的。
- **任务**：修改 `collect_one_sc` 函数（在 `collectSCs` 中），使其在右侧（rhs）是一个 Lambda 抽象时有不同的行为，从而避免在这种情况下引入新的超级组合子。
**解释**：

- 在这个例子中，`f` 已经是一个顶层函数，我们不需要为其引入新的超级组合子。
- 引入 `$f` 只是简单地包装了一层，没有实质性的改变。
- **解决方案**：在 `collect_one_sc` 函数中，当遇到右侧是一个 Lambda 抽象时，直接将其保留，而不是创建新的超级组合子。
**实现思路**：

- 修改 `collect_one_sc` 函数，使其检查右侧是否是一个 Lambda 抽象。
- 如果是，则不创建新的超级组合子，而是直接保留原有的定义。
**示例代码**：

```haskell
collect_one_sc (sc_name, args, rhs@(ELam _ _)) = (sc_name, args, rhs) : scs
  where
    (scs, _) = collectSCs_e rhs
```

#### **6.4.3 消除冗余的局部定义**

**问题描述**：

- 类似的情况也可能发生在局部定义中。考虑以下程序：
```haskell
f x = let g = (\y. y + 1) in g (g x)
```
- Lambda 提升器会将其转换为：
```haskell
f x = let g = $g in g (g x)
$g y = y + 1
```
- 这样，在 `f` 中仍然存在一个对 `g` 的局部绑定，这是多余的。
- **任务**：改进 `collectSCs_d` 函数（在 `collectSCs_e` 的 `ELet` 情况下），对右侧是 Lambda 抽象的定义进行特殊处理。对于上述示例，应该生成：
```haskell
f x = g (g x)
g y = y + 1
```
**解释**：

- 既然 `g` 已经被提升为顶层的超级组合子，就没有必要在 `f` 中再次定义它。
- **解决方案**：在处理 `let` 表达式时，如果发现绑定的右侧是一个 Lambda 抽象，并且该 Lambda 抽象已经被提升为顶层，则可以从绑定列表中移除该定义。
**实现思路**：

- 在 `collectSCs_d` 函数中，检查绑定的右侧是否是一个 Lambda 抽象。
- 如果是，则不将其包含在新的绑定列表中。
- 同时，确保在收集超级组合子时，该 Lambda 抽象已经被提升。
**示例代码**：

```haskell
collectSCs_d scs (name, rhs@(ELam _ _)) = (scs ++ scs_rhs, (name, rhs'))
  where
    (scs_rhs, rhs') = collectSCs_e rhs
    -- 不将 (name, rhs') 包含在新的绑定列表中
collectSCs_d scs defn = -- 原有的处理方式
```

### **6.5 Mark 3：Johnsson 风格的 Lambda 提升**

#### **引入**

我们的简单 Lambda 提升器存在一个问题：它会生成一些函数，这些函数在调用时需要将自身作为参数传递，这可能会降低效率。

**示例**：

- 考虑一个递归函数：
```haskell
f x = letrec g = \y. cons (x * y) (g y) in g 3
main = f 6
```
- 使用简单的 Lambda 提升器后，得到：
```haskell
$g g x y = cons (x * y) (g y)
f x = letrec g = $g g x in g 3
main = f 6
```
- 这里，`$g` 需要将自身 `g` 作为参数传递，这可能会影响性能。
**目标**：

- 通过改进 Lambda 提升器，使得递归函数可以直接调用自身，而不需要将自身作为参数传递。
- 生成的代码应为：
```haskell
$g x y = cons (x * y) ($g x y)
f x = $g x 3
main = f 6
```
- 这样，`$g` 是直接递归的，更加高效。
#### **Johnsson 风格的 Lambda 提升**

**核心思想**：

- 在处理递归函数组时，将所有函数的自由变量的集合作为额外的参数传递给每个函数。
- 这样，递归调用时，不需要传递函数自身作为参数。
**详细步骤**：

1. **识别自由变量**：
- 找出递归函数组中所有函数的自由变量。
2. **排除被绑定的变量**：
- 从自由变量集合中移除正在绑定的函数名。
3. **添加额外的参数**：
- 将剩余的自由变量作为额外的参数添加到每个函数的参数列表中。
4. **替换函数调用**：
- 将所有对递归函数的调用替换为带有新参数列表的调用。
**示例分析**：

```haskell
f x y = letrec
  g = \p. ...h...x...
  h = \q. ...g...y...
in
  ...g...h...
```

- **步骤**：**自由变量**：`g` 和 `h` 的右侧自由变量是 `g`、`h`、`x`、`y`。**排除被绑定的变量**：移除 `g` 和 `h`，剩下 `x` 和 `y`。**添加额外的参数**：将 `x` 和 `y` 添加到 `g` 和 `h` 的参数列表中。**替换函数调用**：将所有对 `g` 和 `h` 的调用替换为 `(g x y)` 和 `(h x y)`。
- **转换结果**：
```haskell
f x y = letrec
  g = \x y p. ...(h x y)...x...
  h = \x y q. ...(g x y)...y...
in
  ...(g x y)...(h x y)...
```
- **提升到顶层**：
```haskell
f x y = ...(g x y)...(h x y)...
g x y p = ...(h x y)...x...
h x y q = ...(g x y)...y...
```
#### **重要注意事项**

- **变量重命名**：在开始之前，确保所有的绑定符号都是唯一的，避免名称冲突。
- **处理自由变量**：由于在替换过程中，自由变量集合可能会发生变化，需要对自由变量集合进行更新。
#### **6.5.1 实现**

**总体结构**：

- **第一步**：重命名程序中的所有绑定符号，使其唯一。
```haskell
rename :: CoreProgram -> CoreProgram
```
- **第二步**：使用 `freeVars` 函数，为程序的每个部分注解其自由变量。
```haskell
freeVars :: CoreProgram -> AnnProgram Name (Set Name)
```
- **第三步**：进行抽象步骤，定义新的函数 `abstractJ`。
```haskell
abstractJ :: AnnProgram Name (Set Name) -> CoreProgram
```
- **第四步**：使用 `collectSCs` 函数，收集所有的超级组合子。
**Lambda 提升器的定义**：

```haskell
lambdaLiftJ = collectSCs . abstractJ . freeVars . rename
```

#### **6.5.2 抽象函数中的自由变量**

**核心函数**：`abstractJ`

- **目标**：在抽象过程中，替换递归函数的调用，使其不再需要将自身作为参数传递。
**辅助函数**：`abstractJ_e`

```haskell
abstractJ_e :: ASSOC Name [Name] -- 将每个新的超级组合子映射到其自由变量列表
             -> AnnExpr Name (Set Name) -- 输入的表达式
             -> CoreExpr -- 结果表达式
```

- **环境 env**：用于存储每个函数名与其自由变量列表的映射。
**实现细节**

1. **处理常量和应用**
- 与之前的实现类似。
2. **处理变量**
```haskell
abstractJ_e env (free, AVar g) = foldll EAp (EVar g) (map EVar (aLookup env g []))
```

- 如果变量 `g` 在环境中，则获取其自由变量列表，将其应用于 `g`。
- 否则，直接返回 `EVar g`。
3. **处理 Lambda 抽象**
```haskell
abstractJ_e env (free, ALam args body) = foldll EAp sc (map EVar fv_list)
  where
    fv_list = actualFreeList env free
    sc = ELet nonRecursive [("sc", sc_rhs)] (EVar "sc")
    sc_rhs = ELam (fv_list ++ args) (abstractJ_e env body)
```

- 使用 `actualFreeList` 函数，获取实际的自由变量列表。
- 将自由变量添加到参数列表中。
4. **处理 Let(rec) 表达式**
- 将函数定义和变量定义分开。
- 计算需要抽象的自由变量。
- 更新环境，将函数名映射到其自由变量列表。
- 递归处理函数定义和变量定义。
5. **辅助函数**
- **actualFreeList**：用于在环境中查找自由变量，获取实际的自由变量列表。
- **isALam**：用于判断一个表达式是否是 Lambda 抽象。
#### **6.5.3 一个棘手的问题**

**问题描述**：

- 当 `letrec` 中包含函数和变量定义的混合时，可能会引入不必要的参数。
- **示例**：
```haskell
f x y = letrec
  g = \p. h p + x ;
  h = \q. k + y + q ;
  k = g y
in
  g 4 ;
```
- 根据之前的算法，`g` 和 `h` 的自由变量集合是 `x`、`y`、`k`。
- 将这些自由变量添加为参数后，得到：
```haskell
g x y k p = h x y k p + x
h x y k q = k + y + q
```
- **问题**：`x` 并未在 `h` 中使用，添加它作为参数是多余的。
**解决方案**：

- 修改 abstractJ 函数，使其能够对每个函数分别计算需要的自由变量，而不是统一使用递归组的所有自由变量。
**实现思路**：

- 在计算需要抽象的自由变量时，对每个函数单独处理，获取其实际需要的自由变量集合。
- 这样，可以避免将未使用的变量添加为参数。
**挑战**：

- 这需要对算法进行较大的修改，增加复杂度。
- 需要小心处理递归函数之间的相互依赖，确保正确性。
**全面详尽的总结**

本节深入探讨了 Lambda 提升技术的改进，特别是引入了 Johnsson 风格的 Lambda 提升。通过对简单提升器的改进和对递归函数处理方式的优化，我们可以生成更高效、更简洁的代码。

**主要收获**：

- **理解了如何消除冗余的 let 表达式和超级组合子**，使得生成的代码更简洁。
- **学习了 Johnsson 风格的 Lambda 提升**，理解了如何处理递归函数，使其无需将自身作为参数传递，提升了性能。
- **认识到在处理自由变量时，需要仔细分析每个函数实际使用的变量**，避免引入多余的参数。
- **体会到在编译器实现中，细节处理和优化的重要性**，以及如何在保持正确性的前提下，提高生成代码的质量。
通过本节的学习，我们不仅掌握了更高级的 Lambda 提升技术，还了解了编译器优化中需要考虑的诸多因素。这为我们进一步深入研究函数式编程语言的实现和优化奠定了坚实的基础。
 #  
 Thought for 9 seconds
**概览**

本节（6.6 Mark 4: 一个独立的完全惰性处理过程）讨论了 **完全惰性（full laziness）** 的概念，以及如何将其与 Lambda 提升分离，通过一个涉及 `let` 表达式的转换来实现完全惰性。作者指出，之前关于完全惰性的讨论通常将其与 Lambda 提升联系在一起，但这会导致实现复杂化。本节旨在展示一种清晰的方法，通过在 Lambda 提升之前执行一个独立的完全惰性转换，来实现完全惰性。

主要内容包括：

- **完全惰性的回顾**：介绍完全惰性的概念及其重要性。
- **在包含 let(rec) 的情况下实现完全惰性的 Lambda 提升的挑战**。
- **无需 Lambda 提升的完全惰性**：提出一种在 Lambda 提升之前执行完全惰性转换的方法。
- **实现一个完全惰性的 Lambda 提升器**：详细讨论实现步骤和核心函数。
- **进一步的优化和注意事项**。
**详细解析**

### **6.6 Mark 4：一个独立的完全惰性处理过程**

#### **引入**

本节关注于函数式程序中的一个重要特性，称为 **完全惰性（full laziness）**。之前的研究通常将完全惰性与 Lambda 提升联系在一起，例如描述“完全惰性的 Lambda 提升”，但这种方法复杂且难以处理 `let(rec)` 表达式。

作者提到：

- [Hughes 1983] 给出了一个算法，但非常微妙且不处理 let(rec) 表达式。
- [Peyton Jones 1987] 涵盖了 let(rec) 表达式，但描述仅是非正式的，且未给出算法。
本节展示了如何将完全惰性与 Lambda 提升 **清晰地分离**。通过一个涉及 `let` 表达式的转换，我们可以在不增加复杂度的情况下实现完全惰性。

#### **为什么要分离完全惰性和 Lambda 提升**

- **避免复杂化**：完全惰性的实现不必与 Lambda 提升绑定在一起，可以通过独立的过程来实现。
- **防止失去惰性**：如果在没有 let(rec) 表达式的情况下执行完全惰性的 Lambda 提升，可能会意外地丢失惰性。
- **代码效率**：大多数编译器在后续阶段对 let(rec) 表达式生成的代码比其等价的 Lambda 表达式更高效。
#### **6.6.1 完全惰性的回顾**

**概念**：

- **完全惰性（full laziness）**：一种优化技术，旨在避免在函数的多次调用中重复计算不依赖于函数参数的表达式。
**示例**：

考虑以下函数：

```haskell
f x = let g = \y. x*x + y in (g 3 + g 4)
main = f 6
```

**问题**：

- 在 g 中，x*x 与 y 相加。
- x 对于 f 的调用是固定的（x = 6），但 x*x 会在每次调用 g 时重复计算。
- 这导致了不必要的计算。
**解决方案**：

- **共享计算**：希望在 `f` 的调用中共享 `x*x` 的计算结果。
- **完全惰性的 Lambda 提升器** 可以将 `x*x` 移动到外部，只计算一次。
**改进的代码**：

```haskell
$g p y = p + y
f x = let g = $g (x*x) in (g 3 + g 4)
```

- 现在，x*x 只计算一次，结果作为参数传递给 $g。
**最大自由表达式（MFE）**：

- **定义**：Lambda 抽象中的最大自由表达式是 **不包含** 该 Lambda 绑定的变量的子表达式，且不是任何更大表达式的子表达式。
- 在上述示例中，`x*x` 是 `\y` 抽象的一个 MFE。
**完全惰性的作用**：

- 相当于在循环外部移动不变的表达式，从而避免在每次循环迭代中重复计算。
#### **6.6.2 在包含 let(rec) 的情况下实现完全惰性的 Lambda 提升**

**挑战**：

- **问题描述**：如果 let 表达式被编码为 Lambda 应用，完全惰性的 Lambda 提升器可能无法检测到需要共享的计算，从而失去完全惰性。
**示例**：

考虑修改后的 `g` 定义：

```haskell
g = \y. let z = x*x
        in let p = z*z
           in p + y
```

- x*x 是一个 MFE，可以被共享。
- 但 z*z 不是 MFE，因为 z 在 \y 抽象内被绑定。
- 然而，p 仅依赖于 x，因此我们希望 z*z 也只计算一次。
**解决方案**：

- **浮动（floating）let 定义**：将 let 定义向外移动，直到它们位于任何包含其自由变量的 Lambda 抽象之外。
**转换后的代码**：

```haskell
g = let z = x*x
    in let p = z*z
       in \y. p + y
```

- 现在，x*x 和 z*z 都只会被计算一次。
**关键点**：

- **浮动策略**：确定一个 let(rec) 定义需要向外移动多远，可以使用 **词法层级编号（lexical level numbers）** 来实现。
**实现步骤**：

1. **为每个 Lambda 绑定的变量分配层级编号**：
- 表示该变量被多少个 Lambda 抽象包围。
- 例如，外层变量层级为 1，内层 Lambda 抽象中的变量层级递增。
2. **为每个 let(rec) 绑定的变量分配层级编号**：
- 取其自由变量的层级编号的最大值。
- 如果没有自由变量，则层级为 0。
3. **浮动 let(rec) 定义**：
- 将绑定变量层级为 n 的定义移动到包围层级为 n+1 的 Lambda 抽象之外，但仍在层级为 n 的抽象内。
#### **6.6.3 无需 Lambda 提升的完全惰性**

**核心思想**：

- **独立的完全惰性转换**：在 Lambda 提升之前，通过识别 MFE 并将其替换为 let 表达式，实现完全惰性。
**转换步骤**：

1. **识别 MFE**：找到所有的最大自由表达式。
2. **替换 MFE**：将每个 MFE `e` 替换为 `let v = e in v`，从而给 MFE 命名，并使其易于被浮动。
3. **浮动 let(rec) 定义**：使用之前的方法，将 `let` 定义向外移动，直到适当的位置。
4. **Lambda 提升**：在执行上述步骤后，应用普通的 Lambda 提升器。
**示例**：

回到最初的 `g` 定义：

```haskell
f x = let g = \y. x*x + y
      in (g 3 + g 4)
```

- **识别 MFE**：`x*x` 是 MFE。
- **替换 MFE**：
```haskell
f x = let g = \y. (let v = x*x in v) + y
      in (g 3 + g 4)
```
- **浮动 let 定义**：
```haskell
f x = let g = let v = x*x
              in \y. v + y
      in (g 3 + g 4)
```
- **Lambda 提升**：
```haskell
$g v y = v + y
f x = let g = let v = x*x in $g v
      in (g 3 + g 4)
```
**注意事项**：

- 通过这种方法，我们将完全惰性的实现与 Lambda 提升分离。
- 这种方法更简单，不需要在 Lambda 提升过程中处理复杂的 MFE 识别。
#### **6.6.4 一个完全惰性的 Lambda 提升器的实现**

**总体结构**：

1. **分离 Lambda（separateLams）**：
- 确保每个 `ELam` 构造子和超级组合子定义只绑定一个参数。
- 这样，完全惰性的 Lambda 提升器可以逐个处理每个 Lambda。
2. **添加层级编号（addLevels）**：
- 为每个绑定符号和表达式添加层级编号。
- 层级编号表示变量或表达式所在的词法层级。
3. **识别 MFE（identifyMFEs）**：
- 通过比较表达式的层级编号和上下文层级，识别 MFE。
- 将 MFE 替换为 `let` 表达式。
4. **重命名变量（renameL）**：
- 进行重命名，使所有绑定符号唯一，避免名称捕获问题。
- 必须在 `identifyMFEs` 之后执行，因为后者会引入新的绑定。
5. **浮动 let(rec) 定义（float）**：
- 将 let(rec) 定义向外移动到适当的层级。
6. **Lambda 提升（lambdaLift）**：
- 使用普通的 Lambda 提升器，提升剩余的 Lambda 抽象。
**组合**：

```haskell
fullyLazyLift = float . renameL . identifyMFEs . addLevels . separateLams
runF = pprint . lambdaLift . fullyLazyLift . parse
```

#### **实现细节**

##### **1. 分离 Lambda（separateLams）**

- **目标**：确保每个 Lambda 抽象只绑定一个参数。
- **实现**：定义辅助函数 `separateLams_e`，递归地分离表达式中的 Lambda 抽象。对于多参数的 Lambda 抽象，将其拆分为嵌套的单参数 Lambda 抽象。**示例代码**：
```haskell
separateLams_e (ELam args body) = mkSepLams args (separateLams_e body)

mkSepLams args body = foldr mkSepLam body args
  where mkSepLam arg body = ELam [arg] body
```
- **处理超级组合子定义**：将超级组合子定义转换为等价的 Lambda 抽象。**示例代码**：
```haskell
separateLams prog = [ (name, [], mkSepLams args (separateLams_e rhs))
                    | (name, args, rhs) <- prog
                    ]
```
##### **2. 添加层级编号（addLevels）**

- **目标**：为每个绑定符号和表达式添加层级编号。
- **实现思路**：首先使用 `freeVars` 函数计算表达式的自由变量。然后，使用自由变量的信息和环境，递归地为表达式添加层级编号。
- **自由变量到层级的映射**：
```haskell
freeSetToLevel :: ASSOC Name Level -> Set Name -> Level
freeSetToLevel env free = foldll max 0 [aLookup env n 0 | n <- setToList free]
```
- **处理 Lambda 抽象**：为每个参数分配层级编号，为当前层级加 1。**示例代码**：
```haskell
freeToLevel_e level env (free, ALam args body) = (freeSetToLevel env free, ALam args' body')
  where
    body' = freeToLevel_e (level + 1) (args' ++ env) body
    args' = [(arg, level + 1) | arg <- args]
```
- **处理 let(rec) 表达式**：对于 `letrec`，需要考虑递归绑定的变量，其层级编号为 0。**示例代码**：
```haskell
freeToLevel_e level env (free, ALet is_rec defns body) = (levelOf new_body, ALet is_rec new_defns new_body)
  where
    -- ...（省略中间代码）
    level_rhs_env | is_rec = [(name, 0) | name <- binders] ++ env
                  | otherwise = env
```
##### **3. 识别 MFE（identifyMFEs）**

- **目标**：通过比较表达式的层级编号和上下文层级，识别 MFE，并将其替换为 `let` 表达式。
- **实现思路**：定义辅助函数 `identifyMFEs_e`，递归地处理表达式。如果表达式的层级编号与上下文层级不同，且是 MFE 的候选，则将其替换为 `let v = e in v`。**过滤不需要处理的 MFE**：某些表达式（如常量、变量）不需要特殊处理。定义函数 `notMFECandidate` 来判断。
- **示例代码**：
```haskell
identifyMFEs_e cxt (level, e)
  | level == cxt || notMFECandidate e = e'
  | otherwise = transformMFE level e'
  where
    e' = identifyMFEs_e1 level e
    transformMFE level e = ELet nonRecursive [(("v", level), e)] (EVar "v")
```
##### **4. 重命名变量（renameL）**

- **目标**：使所有绑定符号唯一，避免名称捕获问题。
- **实现**：定义通用的重命名函数 `renameGen`，接受一个新绑定函数作为参数。`renameL` 使用针对 `(Name, Level)` 类型的绑定符号的 `newNamesL` 函数。
- **示例代码**：
```haskell
renameL :: Program (Name, Level) -> Program (Name, Level)
renameL prog = renameGen newNamesL prog

newNamesL ns old_binders = (ns', new_binders, env)
  where
    old_names = [name | (name, level) <- old_binders]
    levels = [level | (name, level) <- old_binders]
    (ns', new_names) = getNames ns old_names
    new_binders = zip2 new_names levels
    env = zip2 old_names new_names
```
##### **5. 浮动 let(rec) 定义（float）**

- **目标**：将 `let(rec)` 定义向外移动到适当的层级。
- **实现思路**：定义辅助函数 `float_e`，递归地处理表达式，返回浮动的定义和处理后的表达式。使用一个列表 `FloatedDefns` 来存储浮动的定义。定义函数 `partitionFloats` 来将浮动的定义根据层级划分。
- **示例代码**：
```haskell
float_e (ELam args body) = (fd_outer, ELam args' (install fd_this_level body'))
  where
    args' = [arg | (arg, level) <- args]
    (first_arg, this_level) = hd args
    (fd_body, body') = float_e body
    (fd_outer, fd_this_level) = partitionFloats this_level fd_body
```
- **安装浮动的定义**：使用函数 `install`，将浮动的定义嵌套到表达式中。**示例代码**：
```haskell
install defnGroups e = foldr installGroup e defnGroups
  where
    installGroup (level, is_rec, defns) e = ELet is_rec defns e
```
**全面详尽的总结**

本节深入探讨了 **完全惰性（full laziness）** 的概念，并展示了如何在不增加实现复杂度的情况下，将其与 Lambda 提升分离，实现一个完全惰性的 Lambda 提升器。

**主要内容回顾**：

1. **完全惰性的概念和重要性**：
- 通过避免重复计算不依赖于函数参数的表达式，提高程序的性能。
- 完全惰性类似于将循环中的不变表达式移动到循环外部，只计算一次。
2. **在包含 let(rec) 的情况下实现完全惰性的挑战**：
- 如果不特别处理 `let(rec)` 表达式，可能会丢失完全惰性。
- 通过浮动 `let(rec)` 定义，可以确保共享计算的表达式只被计算一次。
3. **无需 Lambda 提升的完全惰性**：
- 提出了一个独立的完全惰性转换过程，通过识别并替换 MFE，然后浮动 `let(rec)` 定义。
- 这种方法简化了实现，并避免了在 Lambda 提升过程中处理复杂的 MFE 识别。
4. **实现一个完全惰性的 Lambda 提升器**：
- 详细讨论了实现步骤，包括分离 Lambda、添加层级编号、识别 MFE、重命名变量、浮动 `let(rec)` 定义和 Lambda 提升。
- 提供了核心函数的实现和解释。
5. **优化和注意事项**：
- 通过过滤不需要特殊处理的 MFE，避免不必要的转换。
- 使用通用的重命名函数 `renameGen`，提高代码的模块化和可重用性。
6. **进一步的优化**：
- 在下一节（6.7）中，作者将讨论如何改进浮动过程，以及处理递归定义的依赖分析。
**关键收获**：

- **完全惰性与 Lambda 提升可以分离**，通过在 Lambda 提升之前执行一个独立的完全惰性转换，可以简化实现。
- **浮动 let(rec) 定义是实现完全惰性的关键**，通过将包含共享计算的定义向外移动，确保这些计算只被执行一次。
- **使用层级编号（lexical levels）来指导浮动过程**，是一种有效的方法。
- **代码的模块化和可重用性**：通过定义通用的函数（如 `renameGen`），可以提高代码的可读性和维护性。
通过本节的学习，我们深入理解了完全惰性的实现方法，以及如何将其与 Lambda 提升分离。这种方法在编译器实现中具有重要意义，有助于生成更高效的代码。我们还了解到在处理函数式语言的编译和优化时，需要细致地分析代码结构和依赖关系，以实现最佳的性能优化。
 #  
 Thought for 7 seconds
**概览**

本节（6.7 Mark 5 和 6.8 Mark 6）继续深入探讨 **完全惰性（full laziness）** 和 **依赖分析（dependency analysis）**，并提出了一些改进完全惰性转换的方法。

- **6.7 Mark 5：完全惰性的改进****6.7.1 添加 case 表达式**：讨论了如何在完全惰性转换中处理 case 表达式。**6.7.2 消除冗余的超级组合子**：提出了避免引入不必要的超级组合子的方法，以优化生成的代码。**6.7.3 避免冗余的完全惰性**：分析了完全惰性可能带来的负面影响，并提供了优化建议。
- **6.8 Mark 6：依赖分析**介绍了如何对程序进行依赖分析，以优化 let(rec) 表达式，进一步提高代码的效率。讨论了 **强连通分量（strongly connected components）** 的概念，并详细讲解了如何实现强连通分量算法。通过依赖分析，可以将 let(rec) 块拆分为最小的定义组，有助于生成更高效的代码。
通过这些内容，读者将了解如何改进完全惰性的实现，以及如何通过依赖分析优化函数式程序的性能。

**详细解析**

### **6.7 Mark 5：完全惰性的改进**

在之前的实现中，我们已经实现了一个完全惰性的 Lambda 提升器。然而，生成的代码可能比需要的更大、更低效。本节讨论了一些改进完全惰性转换的方法，以生成更紧凑、更高效的代码。

#### **6.7.1 添加 case 表达式**

**练习 6.11**

**问题描述**：

- 需要为以下函数提供定义：freeToLevel_caseidentifyMFEs_case1float_case
- 这些函数在处理 `case` 表达式时，应该类似于处理 Lambda 抽象的方式。
**提示**：

- 在 float_case 中，需要注意那些参数列表为空的替代（alternatives）。
**解释**：

- 在之前的实现中，我们可能忽略了对 `case` 表达式的处理。
- 为了完整地处理所有表达式，我们需要扩展我们的函数，以支持 `case` 表达式。
- 处理 `case` 表达式的关键在于：**自由变量计算**：需要计算匹配表达式和所有替代中的自由变量。**层级编号**：为 case 表达式及其组件添加层级编号。**浮动**：将 case 表达式中的 let(rec) 定义按照层级进行浮动。
**实现思路**：

1. **freeToLevel_case**：
- 计算 case 表达式的层级编号。
- 递归处理匹配表达式和替代列表。
2. **identifyMFEs_case1**：
- 识别 case 表达式中的 MFE。
- 对匹配表达式和替代进行递归处理。
3. **float_case**：
- 在浮动过程中处理 case 表达式。
- 需要特别注意替代的参数列表为空的情况，避免错误。
**示例代码**（伪代码）：

```haskell
-- freeToLevel_case
freeToLevel_e level env (free, ACase expr alts) =
  (max level_expr level_alts, ACase expr' alts')
  where
    (level_expr, expr') = freeToLevel_e level env expr
    (levels_alts, alts') = unzip [ (level_alt, (tag, args, body'))
                                 | (tag, args, body) <- alts,
                                   let (level_alt, body') = freeToLevel_e level (args ++ env) body
                                 ]
    level_alts = maximum levels_alts

-- identifyMFEs_case1
identifyMFEs_e1 level (ACase expr alts) =
  ECase (identifyMFEs_e level expr) [ (tag, args, identifyMFEs_e level body)
                                    | (tag, args, body) <- alts
                                    ]

-- float_case
float_e (ECase expr alts) =
  (fd_expr ++ fd_alts, ECase expr' alts')
  where
    (fd_expr, expr') = float_e expr
    (fd_alts_list, alts') = unzip [ (fd_alt, (tag, args', body'))
                                  | (tag, args, body) <- alts,
                                    let (fd_alt, body') = float_e body,
                                    let args' = [arg | (arg, _) <- args]
                                  ]
    fd_alts = concat fd_alts_list
```

#### **6.7.2 消除冗余的超级组合子**

**问题描述**：

- 考虑以下 Core 语言表达式：
```haskell
\x. \y. x + y
```
- 在完全惰性的转换过程中，\y 抽象没有 MFE，除了 x 自身外。
- 完全惰性的转换不会影响这个表达式。
- 然而，简单的 Lambda 提升器 `lambdaLift` 会生成两个超级组合子（每个 Lambda 一个），但实际上只需要一个。
- **目标**：在传递程序给 `lambdaLift` 之前，将嵌套的 `ELam` 表达式合并为一个单一的 `ELam`，以便只生成一个超级组合子。
**解决方案**：

- 可以在一个单独的处理过程中完成这个合并，但最好是在 float 的过程中完成，这样可以节省工作量。
**提示**：

- 使用函数：
```haskell
mkELam :: [Name] -> CoreExpr -> CoreExpr
mkELam args (ELam args' body) = ELam (args ++ args') body
mkELam args other_body = ELam args other_body
```
**实现思路**：

- 在 float 函数的 ELam 情况中，修改代码以合并嵌套的 ELam。
- 这样，在 Lambda 提升阶段，多个参数的 Lambda 抽象将被视为一个整体，从而只生成一个超级组合子。
**示例代码**：

```haskell
float_e (ELam args body) = (fd_outer, mkELam args' body'')
  where
    args' = [arg | (arg, level) <- args]
    (first_arg, this_level) = head args
    (fd_body, body') = float_e body
    (fd_outer, fd_this_level) = partitionFloats this_level fd_body
    body'' = install fd_this_level body'
```

#### **6.7.3 避免冗余的完全惰性**

**问题描述**：

- **完全惰性并非没有代价**，它有两个主要的负面影响：**多个 Lambda 抽象**：如 `\x y. E`，在简单方案下会转化为一个超级组合子，但在完全惰性的方案下可能会变成两个超级组合子。这会增加应用两个参数所需的计算量，可能更昂贵。**优化机会减少**：将 MFE 提升出上下文，可能会减少编译器进行优化的机会。因为表达式脱离了原来的上下文，编译器可能无法进行某些特定的优化。
- **观察**：如果不能共享部分应用，则将 MFE 提升到嵌套的抽象之间，收益不大。将非可约表达式（non-reducible expression）的 MFE 提升出来，几乎没有收益，因为没有共享任何工作。
**改进建议**：

- **合并多个 Lambda 抽象**：在 `separateLams` 过程中，不要将那些部分应用不能被共享的多个抽象分离成单独的 `ELam`。这样，所有由单个 `ELam` 构造子绑定的变量将被赋予相同的层级编号。这确保了不会识别出在内部抽象中自由但在外部抽象中不自由的 MFE，从而避免在两个抽象之间提升 MFE。
- **修改 notMFECandidate 函数**：在 `identifyMFEs` 中，使用 `notMFECandidate` 来决定是否将某个子表达式识别为 MFE。可以在该函数中添加额外的条件，排除那些非可约的表达式，从而避免不必要的完全惰性转换。
**示例代码**：

```haskell
-- 不分离无法共享部分应用的多个抽象
separateLams_e (ELam args body)
  | canSharePartialApplications args = mkSepLams args (separateLams_e body)
  | otherwise = ELam args (separateLams_e body)
```

```haskell
-- 修改 notMFECandidate 函数
notMFECandidate (AConstr t a) = True
notMFECandidate (ANum k) = True
notMFECandidate (AVar v) = True
notMFECandidate (AOp op) = True -- 例如，操作符
notMFECandidate ae = False -- 其他的仍然作为候选
```

### **6.8 Mark 6：依赖分析**

**引入**

在函数式编程中，`let(rec)` 表达式可能包含多个定义，其中一些定义之间并没有相互依赖。通过对程序进行 **依赖分析（dependency analysis）**，可以将 `let(rec)` 块拆分为最小的定义组，并优先使用 `let` 而非 `letrec`，从而生成更高效的代码。

#### **示例**

考虑以下 Core 语言的定义：

```haskell
f x = let
         g = \y. letrec
                    h = y + 1 ;
                    k = x + 2
                 in
                    h + k
      in
         g 4
```

- 内部的 `letrec` 实际上并非递归！我们可以将其转换为：
```haskell
f x = let
         g = \y. let h = y + 1 in
                let k = x + 2 in
                   h + k
      in
         g 4
```
- 这种将 `let(rec)` 块拆分为最小的定义组，并始终优先使用 `let` 而非 `letrec` 的转换称为 **依赖分析**。
#### **依赖分析的好处**

- **减少自由变量**：在 Johnsson 风格的 Lambda 提升中，我们将 `letrec` 块中的自由变量视为一个整体。如果我们能将 `letrec` 拆分为更小的块，那么每个块中的自由变量就会减少。这会减少 `abstractJ` 函数需要添加到函数定义中的自由变量数量。
- **改进完全惰性转换**：在完全惰性的转换中，我们始终将 `let(rec)` 块中的声明放在一起。如果我们先进行依赖分析，将声明拆分为小的组，那么一些组可能会被浮动得更远。
#### **6.8.1 强连通分量**

**定义**：

- **有向图**：由一组顶点 `V` 和一组边 `E` 组成，其中每条边是一个有序对 `(v0, v1)`，表示从顶点 `v0` 到顶点 `v1` 的边。
- **强连通分量（Strongly Connected Component, SCC）**：在有向图中，如果顶点 `a` 可达顶点 `b`，且 `b` 也可达 `a`，则称 `a` 和 `b` 在同一个强连通分量中。一个强连通分量是一个 **极大** 的强连通子图。
**示例**：

考虑以下表达式：

```haskell
letrec
    x = y + 7 * tl z;
    y = 5
    z = (x, y)
in e
```

- **依赖关系**：x 依赖于 y 和 zy 不依赖任何其他变量z 依赖于 x 和 y
- **构建的有向图**：顶点：{x, y, z}边：{(x, y), (x, z), (z, x), (z, y)}
- **强连通分量**：{x, z} 是一个强连通分量（x 和 z 相互可达）{y} 是一个强连通分量
**拓扑排序**：

- 对强连通分量进行拓扑排序，确保在满足依赖关系的情况下，以正确的顺序处理定义。
- 在上述示例中，强连通分量的拓扑排序为：`{x, z} # {y}`表示 `{x, z}` 依赖于 `{y}`。
#### **6.8.2 实现强连通分量算法**

**深度优先搜索（Depth First Search, DFS）**

- **目标**：对有向图进行深度优先搜索，找到所有顶点的拓扑排序。
- **实现**：使用函数 `depthFirstSearch`，参数化于从顶点到其子节点的映射。记录已访问的顶点集和当前的顶点序列。
- **关键函数**：
```haskell
depthFirstSearch :: Ord a =>
    (a -> [a]) ->           -- 映射函数
    (Set a, [a]) ->         -- 状态：已访问集合，当前顶点序列
    [a] ->                  -- 输入的顶点序列
    (Set a, [a])            -- 最终状态
```
**生成树搜索（Spanning Search）**

- **目标**：在深度优先搜索的基础上，保留搜索过程中获得的结构化信息，找到强连通分量。
- **实现**：使用函数 spanningSearch，与 depthFirstSearch 类似，但在构建顶点序列时，将强连通的顶点放在一起。
- **关键函数**：
```haskell
spanningSearch :: Ord a =>
    (a -> [a]) ->           -- 映射函数
    (Set a, [Set a]) ->     -- 状态：已访问集合，当前顶点集序列
    [a] ->                  -- 输入的顶点序列
    (Set a, [Set a])        -- 最终状态
```
**强连通分量算法**

- **实现**：函数 `scc` 使用两次遍历：**第一次遍历**：使用 `depthFirstSearch`，获得顶点的拓扑排序。**第二次遍历**：使用 `spanningSearch`，根据反向图（使用 `ins` 映射）构建强连通分量。**函数定义**：
```haskell
scc :: Ord a =>
    (a -> [a]) ->          -- "ins" 映射
    (a -> [a]) ->          -- "outs" 映射
    [a] ->                 -- 根顶点序列
    [Set a]                -- 拓扑排序的强连通分量序列
```
#### **6.8.3 依赖分析**

**目标**：

- 对程序进行依赖分析，将 let(rec) 块拆分为最小的定义组，并优先使用 let 而非 letrec。
**实现思路**：

1. **计算自由变量**：
- 使用之前的 freeVars 函数，计算程序中每个定义的自由变量。
2. **构建依赖图**：
- 对于每个 let(rec) 块，构建依赖图，顶点为绑定的变量，边表示依赖关系。
3. **计算强连通分量**：
- 使用强连通分量算法，将依赖图分解为强连通分量。
4. **重组定义**：
- 根据强连通分量的拓扑排序，重组定义，将 `let(rec)` 块拆分为最小的定义组。
- 对于非递归的定义，使用 `let`，对于递归的定义，使用 `letrec`。
**示例代码**：

```haskell
dependency :: CoreProgram -> CoreProgram
dependency = depends . freeVars

depends :: AnnProgram Name (Set Name) -> CoreProgram
depends prog = [(name, args, depends_e rhs) | (name, args, rhs) <- prog]

depends_e :: AnnExpr Name (Set Name) -> CoreExpr
-- 处理不同的表达式类型
depends_e (free, ALet is_rec defns body)
  = foldr (mkDependLet is_rec) (depends_e body) defnGroups
  where
    binders = bindersOf defns
    binderSet | is_rec = setFromList binders
              | otherwise = setEmpty
    edges = [(n, f) | (n, (free, e)) <- defns,
                      f <- setToList (setIntersection free binderSet)]
    ins v = [u | (u, w) <- edges, v == w]
    outs v = [w | (u, w) <- edges, v == u]
    components = map setToList (scc ins outs binders)
    defnGroups = [ [(n, aLookup defns n (error "defnGroups")) | n <- ns]
                 | ns <- components
                 ]

mkDependLet is_rec dfs e = ELet is_rec [(n, depends_e e) | (n, e) <- dfs] e
```

**练习 6.16**

**问题描述**：

- 非递归的 `let` 有时会从 `letrec` 中产生非递归的定义，例如上述示例中的 `y`。
- **任务**：重新定义 `mkDependLet`，使得对于非递归的绑定，使用 `let` 而非 `letrec`。
- **提示**：使用传递给 `mkDependLet` 的定义右侧的自由变量信息。
**实现思路**：

- 在 `mkDependLet` 中，检查定义组是否是递归的。
- 如果定义组不包含递归依赖，则使用 `let`。
- 可以通过检查定义组中的变量是否在其右侧的自由变量集合中出现来确定。
**示例代码**：

```haskell
mkDependLet _ dfs e = ELet is_rec [(n, depends_e e) | (n, e) <- dfs] e
  where
    binders = [n | (n, _) <- dfs]
    binderSet = setFromList binders
    rhsFreeVars = setUnionList [free | (n, (free, _)) <- dfs]
    is_rec = not (setIsEmpty (setIntersection binderSet rhsFreeVars))
```

**全面详尽的总结**

本节深入探讨了完全惰性转换和依赖分析的改进方法，以及它们在编译器实现中的重要性。

**主要内容回顾**：

1. **改进完全惰性转换**：
- **处理 case 表达式**：扩展了完全惰性转换，以支持 `case` 表达式的处理，确保转换的完整性。
- **消除冗余的超级组合子**：通过在 `float` 过程中合并嵌套的 `ELam`，避免引入不必要的超级组合子，提高代码效率。
- **避免冗余的完全惰性**：认识到完全惰性可能带来的负面影响，如增加了应用参数所需的计算量，减少了编译器优化的机会。提出了优化建议，如在 `separateLams` 过程中，不分离无法共享部分应用的多个抽象。修改 `notMFECandidate` 函数，避免对非可约表达式进行完全惰性转换。
2. **依赖分析的实现**：
- **强连通分量**：介绍了强连通分量的概念，及其在依赖分析中的作用。
- **实现强连通分量算法**：通过深度优先搜索和生成树搜索，找到了强连通分量，并进行了拓扑排序。
- **依赖分析**：使用自由变量信息，构建依赖图，并计算强连通分量。将 `let(rec)` 块拆分为最小的定义组，优先使用 `let` 而非 `letrec`。通过依赖分析，可以减少自由变量的数量，改进 Lambda 提升和完全惰性转换的效果。
3. **优化代码生成**：
- 通过对程序进行依赖分析，可以生成更高效的代码。
- 减少了不必要的递归定义，提高了代码的性能和可读性。
**关键收获**：

- **完全惰性需要权衡**：在实现完全惰性时，需要权衡其带来的好处和可能的负面影响，避免过度优化导致性能下降。
- **依赖分析的重要性**：对程序进行依赖分析，可以更好地理解定义之间的关系，优化代码结构，生成更高效的代码。
- **算法实现细节**：深入理解了强连通分量算法的实现，以及如何将其应用于函数式编程语言的编译器中。
- **代码的模块化和可维护性**：通过将功能划分为多个模块（如 `float`、`identifyMFEs`、`dependency` 等），提高了代码的可读性和可维护性。
通过本节的学习，我们深入理解了完全惰性转换的优化方法，以及依赖分析在编译器优化中的作用。我们认识到在编译器实现中，需要细致地分析代码结构和变量依赖关系，以实现最佳的性能优化。这些技术对于构建高效的函数式编程语言编译器至关重要，为我们进一步深入研究编译器优化技术奠定了坚实的基础。
 #  
 Thought for 16 seconds
**概览**

本节（6.9 结论）总结了前面章节中关于 **Lambda 提升（Lambda Lifting）** 和 **完全惰性（Full Laziness）** 的讨论，特别是将作者的工作与 Bird 的论文 [Bird 1987] 进行了比较。作者反思了他们的方法，强调了其模块化和可组合的优势，以及在实现复杂的优化时遇到的挑战。

主要内容包括：

- **与 Bird 方法的比较**：讨论了 Bird 的形式化开发方法和作者的方法之间的差异。
- **作者方法的优势**：强调了模块化、多阶段的方法带来的好处，包括代码重用、易于修改和灵活的组合。
- **方法的缺点**：指出了由于将 Lambda 提升和 MFE（最大自由表达式）识别过程分离，导致无法利用某些优化。
- **对章节的总结**：回顾了第 6 章的主要内容和结构。
**详细解析**

### **与 Bird 方法的比较**

**Bird 的方法**

- **目标**：Bird 的目标是通过对初始规格的连续变换，形式化地开发一个高效的完全惰性的 Lambda 提升器。
- **特点**：**形式化发展**：通过一系列的变换，从初始的规范逐步推导出最终的算法。**复杂性**：最终的算法相当复杂，如果直接编写会很困难，因此这种形式化的发展过程是有价值的。
**作者的方法**

- **方法**：作者采用了将算法分解为多个非常简单的阶段的方法，每个阶段都可以直接指定和编写。
- **特点**：**简单的阶段**：每个阶段都有明确的目的，易于理解和实现。**多次遍历**：生成的程序可能存在常数因子的低效，因为它多次遍历了表达式。**优化可能**：这种低效可以通过将连续的遍合并为单个函数来轻松消除，从而消除中间数据结构。
**对比**

- **复杂性 vs. 简单性**：Bird 的方法结果复杂，需要形式化的推导。作者的方法简单明了，可以直接编写。
- **模块化**：作者的方法强调模块化，可以重用现有的函数，并且各个阶段的功能清晰。
- **优化难度**：Bird 的变换过程可能复杂，不容易直接优化。作者的方法可以通过合并阶段来优化，这是一个直接的过程。
### **作者方法的优势**

1. **模块化设计**
- **代码重用**：多次重用了现有的函数，例如 freeVars（计算自由变量）、rename（重命名变量）、collectSCs（收集超级组合子）等。
- **易于修改**：由于每个阶段都有明确的目的，所以修改某个阶段的实现相对容易。
2. **多阶段方法**
- **清晰的阶段目标**：每个阶段执行特定的任务，例如识别 MFE、浮动 let 定义、Lambda 提升等。
- **可组合性**：可以根据需要组合不同的阶段，形成各种变换。例如，可以选择是否执行依赖分析、完全惰性，以及选择使用哪种 Lambda 提升器。
- **灵活性**：这种方法允许根据具体需求定制编译器的优化过程。
3. **优化能力**
- **消除低效**：虽然多次遍历表达式可能带来常数因子的低效，但可以通过合并连续的遍，消除中间数据结构，从而优化性能。
- **易于理解和维护**：模块化的设计使得代码更易于理解和维护。
**示例**

- **修改 identifyMFEs 算法**：在第 6.7.3 节中，作者修改了 identifyMFEs 算法，使其在引入完全惰性的位置上更加选择性。这种修改在模块化的设计下变得容易实现。
### **方法的缺点**

1. **无法利用某些优化**
- **未能实现 Hughes 提出的优化**：无法利用 Hughes 提出的通过重新排列超级组合子的参数来减少 MFE 数量的优化。
- **原因**：这种优化需要将 Lambda 提升与 MFE 识别过程紧密结合，而作者的方法刻意将这两个活动分离开来。
2. **分离的局限性**
- **优化难以实现**：由于分离了 Lambda 提升和 MFE 识别，一些变换变得相当困难。
- **幸运的情况**：在作者的方法中，较大的 MFE 总是部分应用（partial applications），根据第 6.7.3 节的讨论，这些部分应用不应被识别为 MFE，因为它们并没有共享工作量。
3. **可能的性能影响**
- **没有充分利用优化机会**：由于方法的局限性，可能无法充分利用所有的优化机会，可能会影响生成代码的性能。
### **章节总结**

**第 6 章的结构**

- **6.1 简介**：介绍了 Lambda 提升的概念和重要性。
- **6.2 改进 Expr 数据类型**：为了支持 Lambda 提升，对表达式数据类型进行了改进。
- **6.3 第 1 版：简单的 Lambda 提升器**：实现了一个基本的 Lambda 提升器。
- **6.4 第 2 版：改进简单的 Lambda 提升器**：对基本的提升器进行了改进，解决了一些不足。
- **6.5 第 3 版：Johnsson 风格的 Lambda 提升**：介绍了一种优化递归函数的 Lambda 提升方法。
- **6.6 第 4 版：独立的完全惰性传递**：提出了将完全惰性与 Lambda 提升分离的方法。
- **6.7 第 5 版：完全惰性的改进**：讨论了如何改进完全惰性转换，避免冗余和优化性能。
- **6.8 第 6 版：依赖分析**：引入了依赖分析，进一步优化 let(rec) 表达式的处理。
- **6.9 结论**：总结了作者的方法，比较了其他方法的优劣，并反思了模块化设计的优势和不足。
**全面详尽的总结**

本节总结了作者在第 6 章中关于 Lambda 提升和完全惰性的工作，并将其与 Bird 的形式化方法进行了比较。通过对比，作者强调了他们的方法的以下特点：

1. **模块化和可组合性**
- **优势**：方法由多个简单的阶段组成，每个阶段都有明确的功能，易于理解、实现和修改。
- **代码重用**：多次重用了已有的函数，提高了代码的可维护性和可靠性。
- **灵活性**：可以根据需要组合不同的阶段，定制编译器的优化过程。
2. **易于优化**
- **消除低效**：虽然初始实现可能存在多次遍历带来的低效，但可以通过合并连续的遍，优化性能。
- **改进空间**：模块化设计使得优化特定阶段变得容易，例如在 identifyMFEs 算法中更加选择性地引入完全惰性。
3. **方法的局限性**
- **无法利用某些优化**：由于将 Lambda 提升和 MFE 识别过程分离，无法实现 Hughes 提出的通过参数顺序优化来减少 MFE 数量的策略。
- **潜在的复杂性**：虽然模块化带来了许多优势，但在某些情况下，分离关注点可能会使某些变换变得困难。
**反思**

- **方法论的选择**：作者的方法强调实用性和易用性，适合直接实现和修改，而 Bird 的方法更注重形式化和理论上的完备性。
- **权衡取舍**：在编译器实现中，需要在模块化设计和优化能力之间找到平衡。作者的方法在大多数情况下效果良好，但在某些优化方面可能有所不足。
- **未来工作**：认识到方法的局限性，为未来的改进提供了方向，可能需要寻找方法在保持模块化的同时，能够实现更复杂的优化。
**总体评价**

作者的方法以其模块化、可重用和易于理解的特点，在实现完全惰性的 Lambda 提升器方面取得了成功。虽然存在一些限制，但这些限制并未严重影响整体效果。通过对方法的深入分析和比较，作者为读者提供了宝贵的经验和教训，有助于进一步理解函数式编程语言的实现和优化技术。

**结论**

本节通过与 Bird 的方法的比较，深入探讨了作者在实现完全惰性的 Lambda 提升器时所采用的方法和思考。强调了模块化设计的优势，包括代码重用、易于修改和灵活组合，同时也坦诚地指出了方法的不足之处。通过这种全面的反思，读者可以更好地理解编译器实现中的权衡和选择，为今后的学习和实践提供指导。
 #  
 Thought for 25 seconds
**概览**

本节（6.9 结论）对前面章节中讨论的 **Lambda 提升（Lambda Lifting）** 和 **完全惰性（Full Laziness）** 进行了总结和反思。作者将他们的方法与 Bird 在 1987 年发表的论文进行了比较，强调了他们在实现完全惰性 Lambda 提升器时的方法论选择，以及这种选择带来的优点和局限性。

主要内容包括：

1. **与 Bird 方法的比较**：讨论了 Bird 的形式化开发方法与作者方法之间的差异，以及各自的优势和复杂性。
2. **作者方法的优势**：强调了模块化、多阶段的方法带来的好处，包括代码重用、易于修改和灵活的组合。
3. **方法的缺点**：指出了由于将 Lambda 提升和 MFE（最大自由表达式）识别过程分离，导致无法利用某些优化。
4. **对第 6 章的总结**：回顾了整个第 6 章的主要内容和结构，强调了每一节的核心思想和贡献。
**详细解析**

### **与 Bird 方法的比较**

**Bird 的方法**

- **背景**：Richard Bird 在 1987 年发表了一篇非常出色的论文，旨在正式地发展一个高效的完全惰性的 Lambda 提升器。
- **目标**：通过对初始规范的连续变换，给出一个完全惰性 Lambda 提升器的形式化开发过程。
- **特点**：**形式化发展**：Bird 的方法涉及一系列的形式化变换，从初始规范逐步推导出最终的算法。**复杂性**：最终得到的算法相当复杂，直接写下来会很困难，因此这种形式化的发展过程充分证明了其价值。
**作者的方法**

- **对比**：与 Bird 的方法形成鲜明对比，作者选择了另一种方法来实现完全惰性 Lambda 提升器。
- **方法**：他们将算法表达为多个非常简单的阶段的组合，每个阶段都可以直接指定和编写。
- **特点**：**简单性**：每个阶段都有明确的目的，可以直接实现。**多次遍历**：生成的程序可能存在常数因子的低效，因为需要多次遍历表达式。**易于优化**：这种低效可以通过将连续的遍合并为单个函数，消除中间数据结构，从而轻松地优化。
**比较**

- **复杂度 vs. 简单性**：Bird 的方法尽管形式上完备，但结果算法复杂，难以直接实现。作者的方法注重实用性，通过简单的阶段组合，易于直接实现和理解。
- **优化难度**：Bird 的变换过程可能涉及复杂的推导和证明，优化起来较为困难。作者的方法由于各个阶段功能明确，优化和调整更为直接。
- **模块化和可重用性**：作者的方法强调模块化设计，能够重用已有的函数和组件，提高了代码的可维护性和可靠性。
### **作者方法的优势**

1. **模块化设计**
- **代码重用**：多次重用了现有的函数，如 freeVars（计算自由变量）、rename（重命名变量）、collectSCs（收集超级组合子）等。这些函数在之前的章节中已经实现，可以直接用于新的转换阶段。
- **易于修改**：由于每个阶段都有明确的功能，可以独立修改而不影响整个系统。例如，在第 6.7.3 节中，他们修改了 identifyMFEs 算法，使其在引入完全惰性的位置上更加选择性。
2. **多阶段方法**
- **清晰的阶段目标**：每个阶段执行特定的任务，例如：**分离 Lambda（separateLams）**：确保每个 Lambda 抽象只绑定一个参数。**添加层级编号（addLevels）**：为每个绑定符号和表达式添加层级编号。**识别 MFE（identifyMFEs）**：识别最大自由表达式，并将其替换为 let 表达式。**浮动 let(rec) 定义（float）**：将 let(rec) 定义向外移动到适当的层级。**Lambda 提升（lambdaLift）**：提升剩余的 Lambda 抽象。
- **可组合性**：可以根据需要组合不同的阶段，形成各种变换。例如，可以选择是否执行依赖分析（dependency analysis）和完全惰性，以及选择使用哪种 Lambda 提升器（例如简单的 Lambda 提升器或 Johnsson 风格的提升器）。
- **灵活性**：这种方法允许根据具体需求定制编译器的优化过程。
3. **易于优化**
- **消除低效**：虽然初始实现可能存在多次遍历带来的低效，但可以通过将连续的遍合并为单个函数，消除中间数据结构，从而优化性能。
- **改进空间**：模块化设计使得优化特定阶段变得容易。例如，可以针对特定阶段进行性能分析和优化，而不影响其他部分。
### **方法的缺点**

1. **无法利用某些优化**
- **未能实现 Hughes 提出的优化**：无法利用 John Hughes 提出的通过重新排列超级组合子的参数来减少 MFE 数量的优化。
- **原因**：这种优化需要将 Lambda 提升与 MFE 识别过程紧密结合，而作者的方法刻意将这两个活动分离开来。
2. **分离的局限性**
- **优化难以实现**：由于分离了 Lambda 提升和 MFE 识别，一些变换变得相当困难。例如，要实现参数重新排列的优化，需要在识别 MFE 的同时进行 Lambda 提升，这与作者的方法相矛盾。
- **幸运的情况**：在作者的方法中，较大的 MFE 通常是部分应用（partial applications），根据第 6.7.3 节的讨论，这些部分应用不应被识别为 MFE，因为它们并没有共享工作量。这在一定程度上弥补了无法实现 Hughes 优化的缺憾。
3. **潜在的性能影响**
- **没有充分利用优化机会**：由于方法的局限性，可能无法充分利用所有的优化机会，可能会影响生成代码的性能，特别是在某些需要精细优化的情况下。
### **对第 6 章的总结**

**第 6 章的结构和主要内容**

- **6.1 简介（Introduction）**：介绍了 Lambda 提升的背景和重要性，以及在实现函数式编程语言编译器时面临的挑战。
- **6.2 改进 Expr 数据类型（Improving the Expr Data Type）**：为了支持 Lambda 提升，对表达式数据类型进行了改进，增加了必要的构造子和字段。
- **6.3 第 1 版：简单的 Lambda 提升器（Mark 1: A Simple Lambda Lifter）**：实现了一个基本的 Lambda 提升器，包括核心函数和算法。
- **6.4 第 2 版：改进简单的 Lambda 提升器（Mark 2: Improving the Simple Lambda Lifter）**：对基本的提升器进行了改进，解决了一些不足，如处理 `let` 表达式和消除冗余的超级组合子。
- **6.5 第 3 版：Johnsson 风格的 Lambda 提升（Mark 3: Johnsson-Style Lambda Lifting）**：介绍了一种由 Johnsson 提出的优化递归函数的 Lambda 提升方法，避免了在递归函数中传递自身作为参数。
- **6.6 第 4 版：独立的完全惰性传递（Mark 4: A Separate Full Laziness Pass）**：提出了将完全惰性与 Lambda 提升分离的方法，通过在 Lambda 提升之前执行一个独立的完全惰性转换，实现更好的性能。
- **6.7 第 5 版：完全惰性的改进（Mark 5: Improvements to Full Laziness）**：讨论了如何改进完全惰性转换，避免冗余的转换和优化性能，包括避免提升非可约表达式和合并嵌套的 Lambda 抽象。
- **6.8 第 6 版：依赖分析（Mark 6: Dependency Analysis）**：引入了依赖分析，进一步优化 `let(rec)` 表达式的处理，通过分析定义之间的依赖关系，将 `let(rec)` 块拆分为最小的定义组。
- **6.9 结论（Conclusion）**：总结了作者的方法，比较了其他方法的优劣，并反思了模块化设计的优势和不足。
**第 6 章的核心思想和贡献**

- **Lambda 提升的实现**：详细讨论了不同版本的 Lambda 提升器的实现，包括基本的实现和优化的版本，如 Johnsson 风格的提升器。
- **完全惰性的处理**：深入探讨了完全惰性的概念，提出了将其与 Lambda 提升分离的实现方法，避免了实现复杂度的增加。
- **模块化的设计方法**：强调了模块化、多阶段的方法在编译器实现中的优势，使得代码更易于理解、维护和修改。
- **优化技术的讨论**：分析了完全惰性和依赖分析在优化编译器性能中的作用，并讨论了在实现过程中遇到的挑战和解决方案。
**全面详尽的总结**

在第 6 章中，作者深入探讨了 Lambda 提升和完全惰性的实现方法，并对他们的方法与其他研究者的方法进行了比较，特别是与 Bird 的形式化方法的对比。他们的方法强调了以下几点：

1. **模块化和可组合性**
- **优势**：将算法分解为多个简单的、功能明确的阶段，使得每个阶段都可以独立实现、测试和修改。
- **代码重用**：通过重用已有的函数和组件，提高了代码的可维护性和可靠性。
- **灵活性**：可以根据需求选择性地组合不同的阶段，定制编译器的优化过程。
2. **易于优化和维护**
- **优化能力**：虽然初始实现可能存在性能低效，但可以通过合并阶段、消除中间数据结构等方式，轻松地进行优化。
- **维护性**：模块化的设计使得代码更易于理解，降低了维护的复杂度。
3. **方法的局限性**
- **无法实现某些优化**：由于刻意将 Lambda 提升和 MFE 识别过程分离，无法实现需要两者紧密结合的优化，例如 Hughes 提出的参数重新排列优化。
- **优化机会的缺失**：在某些情况下，分离的设计可能导致无法充分利用所有的优化机会，影响了生成代码的性能。
4. **对方法论的反思**
- **权衡取舍**：在编译器实现中，需要在模块化设计和优化能力之间找到平衡。作者的方法在大多数情况下效果良好，但在某些优化方面可能有所不足。
- **未来改进的方向**：认识到方法的局限性，为未来的改进提供了方向，可能需要探索如何在保持模块化的同时，实现更复杂的优化。
**结论**

作者的方法以其模块化、可重用和易于理解的特点，在实现完全惰性的 Lambda 提升器方面取得了成功。他们的多阶段方法使得各个阶段的功能清晰明确，易于修改和扩展。同时，他们也坦诚地指出了方法的不足之处，特别是无法实现某些需要将 Lambda 提升和 MFE 识别过程紧密结合的优化。

通过与 Bird 的方法的比较，作者强调了不同方法论在编译器实现中的应用和影响。他们的工作为编译器的设计和实现提供了宝贵的经验和思考，有助于读者深入理解函数式编程语言的实现和优化技术。

总的来说，本节对第 6 章的内容进行了全面的总结和反思，强调了模块化设计的优势和局限性，为读者提供了深入理解编译器优化技术的基础。

**第6章 Lambda 提升**（Chapter 6: Lambda Lifting）目录：

- **6.1 简介（Introduction）**
- **6.2 改进 Expr 数据类型（Improving the Expr Data Type）**
- **6.3 第 1 版：简单的 Lambda 提升器（Mark 1: A Simple Lambda Lifter）**
- **6.4 第 2 版：改进简单的 Lambda 提升器（Mark 2: Improving the Simple Lambda Lifter）**
- **6.5 第 3 版：Johnsson 风格的 Lambda 提升（Mark 3: Johnsson-Style Lambda Lifting）**
- **6.6 第 4 版：独立的完全惰性传递（Mark 4: A Separate Full Laziness Pass）**
- **6.7 第 5 版：完全惰性的改进（Mark 5: Improvements to Full Laziness）**
- **6.8 第 6 版：依赖分析（Mark 6: Dependency Analysis）**
- **6.9 结论（Conclusion）**
通过对第 6 章的深入学习，读者可以全面了解 Lambda 提升和完全惰性的实现方法，以及在编译器优化中需要考虑的各种因素。这为进一步研究函数式编程语言的实现和优化奠定了坚实的基础。
 #  
 Thought for 13 seconds
**概览**

本附录（附录 A：实用程序模块）提供了本书（Implementing Functional Languages: a tutorial）中使用的各种有用的类型和函数的定义。这些定义为后续章节中的实现提供了基础设施，包括堆的表示、关联列表（映射）、名称供应（生成唯一名称）、集合操作以及其他常用的函数。

具体内容包括：

- **A.1 堆类型（Heap Type）**：定义了一个抽象数据类型，用于表示垃圾回收堆（garbage-collected heap），以及对堆进行操作的函数。
- **A.2 关联列表类型（Association List Type）**：定义了关联列表（映射）的表示方式和操作函数。
- **A.3 生成唯一名称（Generating Unique Names）**：定义了一个名称供应器，用于生成在整个编译过程中唯一的名称。
- **A.4 集合（Sets）**：定义了集合的抽象数据类型及其操作函数，实现了基本的集合运算。
- **A.5 其他有用的函数定义（Other Useful Function Definitions）**：定义了一些常用的辅助函数，例如 foldll、mapAccuml、zipWith 等。
通过这些定义，读者可以了解在实现函数式语言的编译器或解释器时，如何构建基础的数据结构和工具函数，以支持更复杂的功能实现。

**详细解析**

### **模块声明和基础定义**

```haskell
> module Utils where
```

- **模块声明**：定义了一个名为 Utils 的模块，其中包含了实用程序函数和类型的定义，供其他模块导入使用。
```haskell
> -- The following definitions are used to make some synonyms for routines
> -- in the Gofer prelude to be more Miranda compatible
> shownum n = show n
> hd :: [a] -> a
> hd = head -- in Gofer standard prelude
> tl :: [a] -> [a]
> tl = tail -- in Gofer standard prelude
> zip2 :: [a] -> [b] -> [(a,b)]
> zip2 = zip -- in Gofer standard prelude
> -- can’t do anything about # = length, since # not binary.
```

- **兼容性处理**：为了使代码更兼容 Miranda 语言（本书部分示例使用 Miranda 编写），对 Gofer（一个 Haskell 方言）标准前导模块中的一些函数进行了别名定义。shownum：将 show 函数重命名为 shownum，用于将数字转换为字符串。hd 和 tl：分别是列表的头部和尾部，与 Haskell 的 head 和 tail 对应。zip2：与 Haskell 的 zip 函数相同，将两个列表组合成一个列表对。**注释**：无法将 # 定义为 length，因为 # 不是二元运算符。
### **A.1 堆类型（Heap Type）**

**概述**

堆（heap）是一个用于存储节点（对象）的抽象数据类型，在实现垃圾回收（garbage collection）机制时非常重要。堆由一组唯一的地址（地址类型为 `Addr`）和与之关联的对象（类型为 `*`）组成。这个部分定义了堆的操作接口，包括创建、分配、更新、查找和释放等操作。

#### **A.1.1 规格说明（Specification）**

定义了一组操作，用于在堆上进行各种操作：

```haskell
> hInitial :: Heap a
> hAlloc :: Heap a -> a -> (Heap a, Addr)
> hUpdate :: Heap a -> Addr -> a -> Heap a
> hFree :: Heap a -> Addr -> Heap a
```

- **hInitial**：返回一个初始化的空堆。
- **hAlloc**：在堆中分配一个新对象，返回更新后的堆和新对象的地址。参数：当前堆 Heap a，要分配的对象 a。返回值：新的堆 Heap a 和分配的地址 Addr。
- **hUpdate**：更新堆中指定地址处的对象。参数：当前堆 Heap a，要更新的地址 Addr，新的对象 a。返回值：更新后的堆 Heap a。
- **hFree**：释放堆中指定地址处的对象。参数：当前堆 Heap a，要释放的地址 Addr。返回值：更新后的堆 Heap a。
```haskell
> hLookup :: Heap a -> Addr -> a
> hAddresses :: Heap a -> [Addr]
> hSize :: Heap a -> Int
```

- **hLookup**：查找堆中指定地址的对象。参数：堆 Heap a，地址 Addr。返回值：对象 a。
- **hAddresses**：获取堆中所有对象的地址列表。
- **hSize**：获取堆中对象的数量。
```haskell
> hNull :: Addr
> hIsnull :: Addr -> Bool
```

- **hNull**：一个特殊的空地址，保证与堆中任何有效地址都不同。
- **hIsnull**：判断一个地址是否为 hNull。
```haskell
> showaddr :: Addr -> [Char]
```

- **showaddr**：将地址转换为字符串，便于打印输出。
- **注释**：通过命名为 showaddr，可以让 Miranda 在遇到 addr 类型时，使用 showaddr 函数将其转换为字符串。
#### **A.1.2 表示（Representation）**

```haskell
> type Heap a = (Int, [Int], [(Int, a)])
> type Addr = Int
```

- **堆的表示**：堆被表示为一个三元组 (Int, [Int], [(Int, a)])，包含以下三个部分：**堆中对象的数量**（Int）：即当前堆中已分配的对象数量。**未使用的地址列表**（[Int]）：可供分配的新地址。**地址到对象的映射**（[(Int, a)]）：一个关联列表，映射地址到对象。
- **地址的表示**：地址类型 Addr 定义为 Int，即整数。
**实现堆操作函数**

```haskell
> hInitial = (0, [1..], [])
```

- **初始化堆**：创建一个空堆，初始大小为 0，未使用的地址从 1 开始无限增长，当前内容为空列表。
```haskell
> hAlloc (size, (next:free), cts) n = ((size+1, free, (next,n) : cts), next)
```

- **分配对象**：参数：当前堆：(size, (next:free), cts)，其中：size：当前堆大小。(next:free)：未使用的地址列表，next 是下一个可用地址。cts：当前堆内容，即地址到对象的映射。要分配的对象 n。操作：更新堆大小 size+1。从未使用的地址列表中取出 next 作为新地址，剩余的未使用地址为 free。在堆内容 cts 中添加新映射 (next, n)。返回值：新的堆 (size+1, free, (next,n) : cts)。分配的地址 next。
```haskell
> hUpdate (size, free, cts) a n = (size, free, (a,n) : remove cts a)
```

- **更新对象**：参数：当前堆：(size, free, cts)。要更新的地址 a。新的对象 n。操作：在堆内容中，将地址 a 对应的对象更新为 n。使用辅助函数 remove 从堆内容中移除旧的 (a, _) 映射，然后添加新的 (a, n)。返回值：更新后的堆。
```haskell
> hFree (size, free, cts) a = (size-1, a:free, remove cts a)
```

- **释放对象**：参数：当前堆。要释放的地址 a。操作：减少堆大小 size-1。将释放的地址 a 加回未使用的地址列表 free。从堆内容中移除地址 a 的映射。返回值：更新后的堆。
```haskell
> hLookup (size,free,cts) a
> = aLookup cts a (error ("can’t find node " ++ showaddr a ++ " in heap"))
```

- **查找对象**：使用辅助函数 aLookup 在堆内容 cts 中查找地址 a 对应的对象。如果找不到，抛出错误。
```haskell
> hAddresses (size, free, cts) = [addr | (addr, node) <- cts]
```

- **获取堆中所有地址**：从堆内容中提取所有地址。
```haskell
> hSize (size, free, cts) = size
```

- **获取堆大小**：直接返回 size。
```haskell
> hNull = 0
> hIsnull a = a == 0
> showaddr a = "#" ++ shownum a -- Print # to identify addresses
```

- **特殊地址**：hNull 定义为 0，表示空地址。hIsnull 用于判断地址是否为 hNull。showaddr 将地址转换为字符串，地址前加上 # 以便识别。
**辅助函数**

```haskell
> remove :: [(Int,a)] -> Int -> [(Int,a)]
> remove [] a = error ("Attempt to update or free nonexistent address #" ++
> shownum a)
> remove ((a’,n):cts) a | a == a’ = cts
> | a /= a’ = (a’,n) : remove cts a
```

- **remove 函数**：从堆内容列表中移除指定地址 a 的映射。如果找到 (a', n)，且 a == a'，则移除该元素。如果 a /= a'，则保留该元素，继续递归搜索。如果列表为空，说明未找到指定的地址，抛出错误。
### **A.2 关联列表类型（Association List Type）**

**概述**

关联列表（Association List）是一个简单的键值对列表，用于实现映射（类似于字典）。在某些情况下，使用列表来表示映射更为方便，特别是在需要保持键值对的顺序或需要快速构建和遍历的情况下。

```haskell
> type ASSOC a b = [(a,b)]
```

- **类型定义**：定义了一个类型别名 ASSOC a b，表示键类型为 a，值类型为 b 的键值对列表。
**操作函数**

```haskell
> aLookup :: ASSOC a b -> a -> b -> b
> aLookup [] k’ def = def
> aLookup ((k,v):bs) k’ def | k == k’ = v
> | k /= k’ = aLookup bs k’ def
```

- **aLookup**：用于在关联列表中查找键 k’ 对应的值。参数：关联列表 alist。要查找的键 k’。默认值 def，在未找到键时返回。操作：如果列表为空，返回默认值 def。如果当前键 k 与 k’ 相等，返回对应的值 v。如果不相等，递归查找剩余的列表。**注释**：查找从列表头开始，适合用于最近的绑定覆盖先前的绑定的情况（类似于环境扩展）。
```haskell
> aDomain :: ASSOC a b -> [a]
> aDomain alist = [key | (key,val) <- alist]
>
> aRange :: ASSOC a b -> [b]
> aRange alist = [val | (key,val) <- alist]
```

- **aDomain**：返回关联列表中的所有键（域）。
- **aRange**：返回关联列表中的所有值（值域）。
```haskell
> aEmpty = []
```

- **aEmpty**：定义了一个空的关联列表。
### **A.3 生成唯一名称（Generating Unique Names）**

**概述**

在编译器实现中，经常需要生成在整个编译过程中唯一的标识符（名称），以避免命名冲突。名称供应器（Name Supply）提供了这样的功能，能够根据需要生成独一无二的名称。

**接口定义**

```haskell
> getName :: NameSupply -> [Char] -> (NameSupply, [Char])
> getNames :: NameSupply -> [[Char]] -> (NameSupply, [[Char]])
> initialNameSupply :: NameSupply
```

- **getName**：参数：名称供应器 NameSupply。前缀字符串 String，用于生成名称的前缀。返回值：更新后的名称供应器。生成的唯一名称 String，格式为 prefix_number。
- **getNames**：类似于 getName，但一次生成多个名称。参数：名称供应器 NameSupply。前缀字符串列表 String，每个前缀对应一个名称。返回值：更新后的名称供应器。生成的唯一名称列表。
- **initialNameSupply**：初始的名称供应器。
**表示和实现**

```haskell
> type NameSupply = Int
> initialNameSupply = 0
```

- **名称供应器的表示**：使用整数 Int 表示，作为唯一名称的计数器。
```haskell
> getName name_supply prefix = (name_supply+1, makeName prefix name_supply)
> getNames name_supply prefixes
> = (name_supply + length prefixes, zipWith makeName prefixes [name_supply..])
> makeName prefix ns = prefix ++ "_" ++ shownum ns
```

- **getName 实现**：增加名称供应器计数器 name_supply+1。使用 makeName 函数生成名称，格式为 prefix_number。
- **getNames 实现**：增加名称供应器计数器，增加的数量为前缀列表的长度。使用 zipWith 和 makeName 为每个前缀生成对应的唯一名称。
- **makeName 函数**：将前缀和计数器数字连接起来，形成唯一名称。
### **A.4 集合（Sets）**

**概述**

集合是一种重要的数据结构，用于存储不重复的元素集合。在编译器实现中，集合常用于表示自由变量、已访问节点等。这个部分定义了集合的抽象数据类型及其基本操作。

**接口定义**

```haskell
> setFromList :: (Ord a) => [a] -> Set a
> setToList :: (Ord a) => Set a -> [a]
> setUnion :: (Ord a) => Set a -> Set a -> Set a
> setIntersection :: (Ord a) => Set a -> Set a -> Set a
> setSubtraction :: (Ord a) => Set a -> Set a -> Set a
> setElementOf :: (Ord a) => a -> Set a -> Bool
> setEmpty :: (Ord a) => Set a
> setIsEmpty :: (Ord a) => Set a -> Bool
> setSingleton :: (Ord a) => a -> Set a
> setUnionList :: (Ord a) => [Set a] -> Set a
```

- **setFromList**：从列表创建集合，去除重复元素。
- **setToList**：将集合转换为列表。
- **setUnion**：集合并集。
- **setIntersection**：集合交集。
- **setSubtraction**：集合差集，setSubtraction a b 表示 a 中去除 b 中的元素。
- **setElementOf**：判断元素是否在集合中。
- **setEmpty**：空集合。
- **setIsEmpty**：判断集合是否为空。
- **setSingleton**：创建只包含一个元素的集合。
- **setUnionList**：将多个集合合并为一个集合。
**表示和实现**

```haskell
> type Set a = [a] -- Ordered by the sort function
```

- **集合的表示**：使用有序列表来表示集合，元素按照排序函数排序。
**实现细节**

- **创建集合**
```haskell
> setEmpty = []
> setIsEmpty s = null s
> setSingleton x = [x]
> setFromList = rmdup . sort
> where rmdup [] = []
> rmdup [x] = [x]
> rmdup (x:y:xs) | x == y = rmdup (y:xs)
> | x /= y = x: rmdup (y:xs)
```

- **setFromList**：先对列表进行排序（sort），然后使用 rmdup 函数去除重复元素。**rmdup 函数**：移除相邻的重复元素，实现去重。
- **集合运算**
```haskell
> setUnion [] [] = []
> setUnion [] (b:bs) = (b:bs)
> setUnion (a:as) [] = (a:as)
> setUnion (a:as) (b:bs) | a < b = a: setUnion as (b:bs)
> | a == b = a: setUnion as bs
> | a > b = b: setUnion (a:as) bs
```

- **setUnion（并集）**：对两个有序列表进行合并，确保结果列表有序且无重复元素。
- **setIntersection（交集）**：
```haskell
> setIntersection [] [] = []
> setIntersection [] (b:bs) = []
> setIntersection (a:as) [] = []
> setIntersection (a:as) (b:bs) | a < b = setIntersection as (b:bs)
> | a == b = a: setIntersection as bs
> | a > b = setIntersection (a:as) bs
```

- **setSubtraction（差集）**：
```haskell
> setSubtraction [] [] = []
> setSubtraction [] (b:bs) = []
> setSubtraction (a:as) [] = (a:as)
> setSubtraction (a:as) (b:bs) | a < b = a: setSubtraction as (b:bs)
> | a == b = setSubtraction as bs
> | a > b = setSubtraction (a:as) bs
```

- **元素判断**
```haskell
> setElementOf x [] = False
> setElementOf x (y:ys) = x==y || (x>y && setElementOf x ys)
```

- **setUnionList**：
```haskell
> setUnionList = foldll setUnion setEmpty
```

- 使用 foldll 函数将多个集合依次进行并集运算。
### **A.5 其他有用的函数定义（Other Useful Function Definitions）**

**概述**

在实现过程中，一些通用的辅助函数可以简化代码的编写，提高可读性和可维护性。

**定义**

```haskell
> first (a,b) = a
> second (a,b) = b
```

- **first 和 second**：提取元组的第一个和第二个元素。类似于 Haskell 的 fst 和 snd。
```haskell
> -- zipWith is defined in standard prelude
```

- **zipWith**：将两个列表按元素组合，并使用指定的函数处理对应的元素。
```haskell
> foldll :: (a -> b -> a) -> a -> [b] -> a
> foldll = foldl -- in Gofer standard prelude.
```

- **foldll**：类似于 foldl，但为了兼容性，自定义了 foldll。参数：二元函数 (a -> b -> a)，用于将累积值与列表元素组合。初始累积值 a。列表 [b]。返回值：最终的累积值 a。**作用**：从左到右遍历列表，依次更新累积值。
```haskell
> mapAccuml :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
>
> mapAccuml f acc [] = (acc, [])
> mapAccuml f acc (x:xs) = (acc2, x’:xs’)
> where (acc1, x’) = f acc x
> (acc2, xs’) = mapAccuml f acc1 xs
```

- **mapAccuml**：结合了 map 和 foldll 的功能。参数：函数 (a -> b -> (a, c))，接受累积值和列表元素，返回新的累积值和处理后的元素。初始累积值 a。列表 [b]。返回值：最终的累积值 a。处理后的列表 [c]。**作用**：遍历列表，同时更新累积值，并生成新的列表。
```haskell
> sort [] = []
> sort [x] = [x]
> sort (x:xs) = [ y | y <- xs, y < x] ++ x : [ y | y <- xs, y >= x ]
```

- **sort**：一个简单的排序函数，实现了快速排序的基本思想。对列表进行排序，返回有序列表。
```haskell
> space n = take n (repeat ’ ’)
```

- **space**：生成包含 n 个空格的字符串。用于格式化输出。
**全面详尽的总结**

附录 A 提供了本书中使用的实用程序模块的完整定义。这些定义涵盖了实现函数式语言编译器或解释器时所需的基础设施，包括：

1. **堆类型（Heap Type）**：
- 定义了一个抽象的数据类型 Heap a，用于表示垃圾回收堆。
- 提供了在堆上进行操作的函数，如分配、更新、释放、查找等。
- 通过三元组 (Int, [Int], [(Int, a)]) 来表示堆的内部结构，维护了堆的大小、未使用的地址和地址到对象的映射。
2. **关联列表类型（Association List Type）**：
- 使用类型别名 ASSOC a b 来表示键值对列表，实现了简单的映射功能。
- 提供了在关联列表上进行查找、获取键和值的函数。
3. **生成唯一名称（Generating Unique Names）**：
- 定义了名称供应器 NameSupply，用于在编译过程中生成唯一的名称，防止命名冲突。
- 通过递增计数器的方式，确保生成的名称在全局范围内唯一。
4. **集合（Sets）**：
- 定义了集合的抽象数据类型及其基本操作函数。
- 通过有序列表来表示集合，实现了集合的并集、交集、差集、元素判断等操作。
5. **其他有用的函数定义（Other Useful Function Definitions）**：
- 提供了一些常用的辅助函数，如 foldll、mapAccuml、zipWith、sort 等。
- 这些函数在遍历和处理列表、元组等数据结构时非常有用，简化了代码的编写。
通过这些定义，读者可以深入理解在实现函数式编程语言的编译器或解释器时，如何构建和操作基础的数据结构。这些实用程序模块为后续的实现提供了坚实的基础，使得复杂的功能得以在此之上构建。

本附录详细地介绍了每个模块和函数的目的、接口和实现细节，使得即使没有相关知识背景的读者也能理解这些内容。这些基础设施在编译器实现中至关重要，理解它们有助于深入理解后续章节中更复杂的实现和优化技术。
 #  
 ​
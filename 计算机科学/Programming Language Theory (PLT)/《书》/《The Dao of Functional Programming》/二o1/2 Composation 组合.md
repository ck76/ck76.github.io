[toc]



# 第 1 章：白板

编程始于**类型**（*Types*）和**函数**（*Functions*）。你可能对这两个概念已经有一些先入为主的理解，但是为了更深入地学习，我们需要暂时放下这些先入为主的观念。

## 摒弃先入为主的观念

首先，我们不应该被计算机硬件的实现所束缚。计算机只是众多计算模型中的一种，我们可以在脑海中进行计算，或者用纸和笔。这意味着物理载体与编程的思想本质上是无关的。

## 类型与函数

引用老子的话：

> **“可描述的类型不是永恒的类型。”**

换句话说，**类型**（$Type$）是一种原始概念，它无法被严格定义。我们可以称它为“对象”或“命题”，在不同的数学领域，这些术语可能会被使用来描述类似的概念。

可能存在不止一种类型，因此我们需要一种方式来命名它们。我们可以简单地给它们命名，例如类型 $a$、$b$、$c$，或者在编程语言 Haskell 中，使用 $\hask{Int}$、$\hask{Bool}$、$\hask{Double}$ 等等。这些只是为了方便交流而起的名称。

重要的是，**类型本身没有意义**，它的特性来自于它与其他类型的连接方式。这些连接由**箭头**（$Arrows$）描述。

### 箭头和函数

一个箭头有一个类型作为其**源**，另一个类型作为其**目标**。目标可以与源相同，在这种情况下，箭头会回环。

- **类型之间的箭头**称为**函数**（$Function$）。
- **对象之间的箭头**称为**态射**（$Morphism$）。
- **命题之间的箭头**称为**蕴涵**（$Entailment$）。

这些只是不同数学领域中描述箭头的术语，你可以将它们互换使用。

在逻辑中，命题是可能为真的陈述。我们将两个对象之间的箭头解释为 $a$ 蕴涵 $b$，或者说 $b$ 可以从 $a$ 推导出来。

由于两个类型之间可能存在多个箭头，所以我们需要为这些箭头命名。例如，这里有一个从类型 $a$ 到类型 $b$ 的箭头，称为 $f$：

$$
a \xrightarrow{f} b
$$

一种理解这种箭头的方式是，**函数 $f$ 接受一个类型为 $a$ 的参数，生成一个类型为 $b$ 的结果**。或者在逻辑上，$f$ 是一个证明：如果 $a$ 为真，那么 $b$ 也为真。

**注意**：类型论、lambda 演算（Lambda Calculus，编程的基础）、逻辑和范畴论之间的联系被称为 **Curry-Howard-Lambek 对应**（Curry-Howard-Lambek Correspondence）。

## 阴阳

在范畴论中，一个对象由其连接定义。箭头是两个对象连接的证明或证据。有时，两个对象之间没有箭头，它们是断开的；有时，有很多箭头连接它们；有时，只有一个箭头连接它们。

当两个对象之间只有**唯一的箭头**时，我们称这个箭头为**唯一的**。这意味着如果你找到两个这样的箭头，它们必须是相等的。

### 初始对象和终端对象

- **初始对象**（$Initial\ Object$）：对于每个对象，都有一个唯一的箭头从初始对象指向它。
- **终端对象**（$Terminal\ Object$）：对于每个对象，都有一个唯一的箭头指向终端对象。

在数学中，初始对象通常表示为 $0$，终端对象表示为 $1$。

- **从 $0$ 到任何对象 $a$ 的箭头**表示为 $\text{!`}_a$，通常缩写为 $\text{!`}$。
- **从任何对象 $a$ 到 $1$ 的箭头**表示为 $!_a$，通常缩写为 $!$。

#### 初始对象

初始对象是所有对象的源头。在 Haskell 中，初始对象被称为 $\hask{Void}$。它象征着一切事物源于其中的混沌。因为有一个从 $\hask{Void}$ 到任何对象的箭头，也有一个从 $\hask{Void}$ 到它自身的箭头：

$$
\begin{tikzcd}
\hask{Void} \arrow[loop]
\end{tikzcd}
$$

因此，$\hask{Void}$ 产生了 $\hask{Void}$ 和其他一切。

#### 终端对象

终端对象将一切联合起来。在 Haskell 中，终端对象被称为 $\hask{()}$，读作 $\hask{Unit}$。它象征着终极秩序。

在逻辑中，终端对象象征着**真理**，用 $T$ 或 $\top$ 表示。事实是，从任何对象到它都有一个箭头，这意味着无论你的假设是什么，$\top$ 都是正确的。

相对地，初始对象象征着**谬误**或**矛盾**，用 $F$ 或 $\bot$ 表示。事实是，从它到任何对象都有一个箭头，这意味着你可以从错误的前提推导出任何结论。

### 总结

我们可以将编程、范畴论和逻辑中的概念对照起来：

| 编程          | 范畴论        | 逻辑          |
| ------------- | ------------- | ------------- |
| 类型          | 对象          | 命题          |
| 函数          | 态射（箭头）  | 蕴涵          |
| $\hask{Void}$ | 初始对象，$0$ | False，$\bot$ |
| $\hask{()}$   | 终端对象，$1$ | True，$\top$  |

## 元素

一个对象没有部分，但它可能有**结构**。结构由指向该对象的箭头定义。我们可以用箭头**探测**对象。

在编程和逻辑中，我们希望初始对象 $\hask{Void}$ 没有结构，所以我们假设它没有入射箭头（除了从它自身回环的箭头）。因此，$\hask{Void}$ 没有结构。

终端对象 $\hask{()}$ 有最简单的结构。只有一个从任何对象到它的入射箭头：只有一种方式可以从任何方向探测它。在这方面，终端对象表现得像一个不可分割的点。

### 元素和全局元素

如果有多个箭头从终端对象指向某个对象 $a$，这意味着 $a$ 有某种结构：有多种方式可以“探测”它。

在范畴论中，从终端对象 $1$ 到对象 $a$ 的箭头被称为 $a$ 的**全局元素**（$Global\ Element$）：

$$
1 \xrightarrow{x} a
$$

我们通常简单地称之为**元素**。

在类型论中，$x : A$ 意味着 $x$ 是类型 $A$ 的一个值。

在 Haskell 中，我们写作：

```haskell
x :: A
```

我们说 $\hask{x}$ 是类型 $\hask{A}$ 的一个项，但在范畴论中，我们将其解释为箭头 $x : 1 \to A$，即 $\hask{A}$ 的一个全局元素。

#### $\hask{Void}$ 和 $\hask{()}$ 的元素

因为我们假设没有从任何对象到 $\hask{Void}$ 的箭头，因此 $\hask{Void}$ 没有元素。这就是为什么我们认为 $\hask{Void}$ 是空的。

终端对象 $\hask{()}$ 只有一个元素，因为只有一个从它自身到它自身的箭头 $1 \to 1$。这就是为什么我们有时称它为单一元素集。

## 箭头的对象

任何两个对象之间的箭头形成一个**集合**。在编程中，我们谈论从 $\hask{a}$ 到 $\hask{b}$ 的函数的**类型**。在 Haskell 中，我们写作：

```haskell
f :: a -> b
```

其中 $\hask{a -> b}$ 是从 $\hask{a}$ 到 $\hask{b}$ 的**函数类型**。

如果我们希望函数类型与其他类型一样被对待，我们需要一个**对象**来表示从 $\hask{a}$ 到 $\hask{b}$ 的箭头的集合。

为了完全定义这个对象，我们必须描述它与其他对象的关系，特别是与 $\hask{a}$ 和 $\hask{b}$ 的关系。我们还没有足够的工具来做到这一点，但我们会在后续章节中详细讨论。

目前，让我们记住以下区别：

- 一方面，我们有连接两个对象 $\hask{a}$ 和 $\hask{b}$ 的**箭头**。这些箭头形成一个集合。
- 另一方面，我们有一个从 $\hask{a}$ 到 $\hask{b}$ 的**箭头对象**。这个对象的“元素”被定义为从终端对象 $\hask{()}$ 到我们称为 $\hask{a -> b}$ 的对象的箭头。

在编程中，我们使用的符号往往模糊了这个区别。这就是为什么在范畴论中，我们称箭头对象为**指数对象**（$Exponential\ Object$），并将其表示为 $b^a$（源对象在指数中）。因此，以下 Haskell 语句：

```haskell
f :: a -> b
```

等同于：

$$
1 \xrightarrow{f} b^a
$$

在逻辑中，箭头 $A \to B$ 是一个蕴涵，陈述了“如果 $A$，那么 $B$”。指数对象 $B^A$ 是相应的命题。它可能为真，也可能为假，我们需要证明它。这样的证明就是 $B^A$ 的一个元素。

给我 $B^A$ 的一个元素，我就知道 $B$ 可以从 $A$ 推导出来。

---

# 第 2 章：组合

编程是关于**组合**（$Composition$）的。借用维特根斯坦（Wittgenstein）的话：

> **“对于不能分解的东西，不应该谈论。”**

这不是一种禁止，而是一种事实陈述。研究、理解和描述的过程与分解的过程是一样的，我们的语言也反映了这一点。

我们构建**对象**（$Objects$）和**箭头**（$Arrows$）的词汇，正是为了表达组合的思想。

## 组合

给定一个从 $a$ 到 $b$ 的箭头 $f$，和一个从 $b$ 到 $c$ 的箭头 $g$，它们的组合是一个直接从 $a$ 到 $c$ 的箭头。换句话说，如果有两个箭头，其中一个的目标与另一个的源相同，我们总是可以将它们组合起来，得到第三个箭头 $h$：

$$
\begin{tikzcd}
a \arrow[r, "f"] & b \arrow[r, "g"] & c
\end{tikzcd}
$$

组合的结果是 $h = g \circ f$，其中 $\circ$ 表示组合操作。我们读作：“$h$ 是 $f$ 之后的 $g$”，即首先应用 $f$，然后应用 $g$。

**注意**：组合的顺序可能看起来是反向的，但这是因为我们认为函数是在右边接受参数的。

在 Haskell 中，我们用点号表示组合：

```haskell
h = g . f
```

这就是每个程序的简要概括。为了完成 $h$，我们将其分解为更简单的问题 $f$ 和 $g$。这些问题可以进一步分解，依此类推。

### 组合的结合性

现在假设我们能够将 $g$ 自身分解为 $j \circ k$。我们有：

$$
h = (j \circ k) \circ f
$$

我们希望这个分解与以下分解相同：

$$
h = j \circ (k \circ f)
$$

这意味着，我们希望能够将 $h$ 分解为三个更简单的问题：

$$
h = j \circ k \circ f
$$

而不必关心哪个分解是先进行的。这就是组合的**结合性**（$Associativity$）。从现在起，我们将假设组合是结合的。

### 前置组合和后置组合

组合是箭头之间两种映射的来源，称为**前置组合**（$Pre$-$composition$）和**后置组合**（$Post$-$composition$）。

- **后置组合**：当你将一个箭头 $h$ 与一个箭头 $f$ 进行后置组合时，得到 $f \circ h$（箭头 $f$ 在箭头 $h$ 之后应用）。这只在 $h$ 的目标与 $f$ 的源相同时才有意义。

  我们可以将后置组合表示为一个映射 $(f \circ -)$，为 $h$ 留下一个空位。这意味着后置组合的有用性来自于“空”的部分。

- **前置组合**：相应地，你可以通过 $f$ 进行前置组合，或者应用 $(- \circ f)$ 到源自 $b$ 的箭头，将它们映射到源自 $a$ 的箭头。

### 组合映射的示意图

**后置组合**：

$$
\begin{tikzcd}
x \arrow[r, "h"] & a \arrow[r, "f"] & b
\end{tikzcd}
$$

通过后置组合 $(f \circ -)$，我们将 $h$ 映射为 $f \circ h$。

**前置组合**：

$$
\begin{tikzcd}
a \arrow[r, "f"] & b \arrow[r, "h"] & y
\end{tikzcd}
$$

通过前置组合 $(- \circ f)$，我们将 $h$ 映射为 $h \circ f$。

### 组合映射是函数

前置和后置组合是箭头的映射。由于箭头形成集合，这些映射是集合之间的**函数**。

另一种看待前置和后置组合的方式是，它们是两个孔的组合运算符 $(- \circ -)$ 的部分应用的结果，其中我们可以用一个固定的箭头预填一个孔或另一个孔。

在编程中，出射箭头被解释为从其源提取数据。入射箭头被解释为生成或构造目标。出射箭头定义接口，入射箭头定义构造器。

#### Haskell 中的前置和后置组合

在 Haskell 中，后置组合可以实现为高阶函数：

```haskell
postCompWith :: (a -> b) -> (x -> a) -> (x -> b)
postCompWith f h = f . h
```

前置组合：

```haskell
preCompWith :: (a -> b) -> (b -> x) -> (a -> x)
preCompWith f h = h . f
```

### 练习

**练习 1**：假设你有两个箭头 $f : a \to b$ 和 $g : b \to c$。它们的组合 $g \circ f$ 诱导出箭头的映射 $((g \circ f) \circ -)$。证明如果你先应用 $(f \circ -)$，然后再应用 $(g \circ -)$，结果是相同的。也就是说：

$$
((g \circ f) \circ -) = (g \circ -) \circ (f \circ -)
$$

**提示**：选择一个任意对象 $x$ 和一个箭头 $h : x \to a$，看看是否得到相同的结果。注意，这里的 $\circ$ 是多义的。在右侧，它表示两个后置组合之间的常规函数组合。

---

**练习 2**：确信前一个练习中的组合是结合的。

**提示**：从三个可组合的箭头开始。

---

**练习 3**：证明前置组合 $(- \circ f)$ 是可组合的，但组合的顺序是反向的：

$$
(- \circ (g \circ f)) = (- \circ f) \circ (- \circ g)
$$

## 函数应用

我们准备好写第一个程序了。俗话说：“千里之行，始于足下。”考虑从终端对象 $1$ 到某个对象 $b$ 的旅程。我们的第一步可以是从终端对象 $1$ 到某个对象 $a$ 的箭头 $x$，也就是 $a$ 的一个元素：

$$
1 \xrightarrow{x} a
$$

旅程的其余部分是箭头：

$$
a \xrightarrow{f} b
$$

这两个箭头可以组合，它们的组合是从 $1$ 到 $b$ 的箭头 $y$，也就是 $b$ 的一个元素：

$$
\begin{tikzcd}
1 \arrow[r, "x"] & a \arrow[r, "f"] & b
\end{tikzcd}
$$

我们可以写作：

$$
y = f \circ x
$$

我们使用 $f$ 将 $a$ 的一个**元素**映射到 $b$ 的一个**元素**。由于这是我们经常做的事情，我们称之为**函数 $f$ 对 $x$ 的应用**，并使用简写符号：

$$
y = f(x)
$$

在 Haskell 中，我们从一个类型为 $\hask{a}$ 的元素 $\hask{x}$ 开始：

```haskell
x :: a
```

我们声明一个函数 $f$，类型为 $\hask{a -> b}$：

```haskell
f :: a -> b
```

结果是 $b$ 的一个元素 $\hask{y}$：

```haskell
y :: b
y = f x
```

我们称之为将函数应用于参数。

## 恒等

你可以将箭头视为表示变化：对象 $a$ 变为对象 $b$。一个回环的箭头表示对象自身的变化。但是，变化有其对偶：没有变化，或者用老子的话来说，**无为**（$Wu\ Wei$）。

每个对象都有一个特殊的箭头，称为**恒等**（$Identity$），它使对象保持不变。这意味着，当你将这个箭头与任何其他箭头组合时，无论是入射的还是出射的，你都会得到那个箭头。

对于对象 $a$，其恒等箭头记为 $id_a$。因此，如果我们有一个箭头 $f : a \to b$，我们可以在任一侧与恒等箭头组合：

$$
id_b \circ f = f = f \circ id_a
$$

图示为：

$$
\begin{tikzcd}
a \arrow[loop left, "id_a"] \arrow[r, "f"] & b \arrow[loop right, "id_b"]
\end{tikzcd}
$$

恒等箭头对元素的作用也很容易检查。对于 $x : 1 \to a$，有：

$$
id_a \circ x = x
$$

这意味着恒等箭头使元素保持不变。

在 Haskell 中，我们使用相同的名称 $\hask{id}$ 表示所有的恒等函数（不带类型下标）。上面的方程直接翻译为：

```haskell
id x = x
```

并且它成为了函数 $\hask{id}$ 的定义。

### 初始对象和终端对象的恒等箭头

我们之前已经看到，初始对象和终端对象都有唯一的回环箭头。现在我们说，每个对象都有一个回环的恒等箭头。根据唯一性的概念，我们得出结论，之前提到的这些唯一的回环箭头必须是恒等箭头。我们现在可以标注这些图：

$$
\begin{tikzcd}
\hask{Void} \arrow[loop, "id"]
\end{tikzcd}
\quad
\begin{tikzcd}
\hask{()} \arrow[loop, "id"]
\end{tikzcd}
$$

在逻辑中，恒等箭头对应于自明的真理。它是一个简单的证明，证明“如果 $a$ 为真，那么 $a$ 为真”。这也被称为**恒等规则**（$Identity\ Rule$）。

### 恒等箭头的重要性

如果恒等什么都不做，那为什么我们还要关心它？想象你正在进行一趟旅行，组合了一些箭头，发现自己回到了起点。问题是：你做了什么，还是你浪费了时间？回答这个问题的唯一方法是将你的路径与恒等箭头进行比较。

有些往返旅行会带来变化，而有些则不会。

更重要的是，恒等箭头将允许我们比较对象。它们是**同构**（$Isomorphism$）定义的重要组成部分。

### 练习

**练习 4**：$(id_a \circ -)$ 对终止于 $a$ 的箭头做了什么？$(- \circ id_a)$ 对源自 $a$ 的箭头做了什么？

---

## 单态射

考虑函数 $\hask{even}$，它测试其输入是否为偶数：

```haskell
even :: Int -> Bool
even n = n `mod` 2 == 0
```

这是一个**多对一**的函数：所有偶数映射到 $\hask{True}$，所有奇数映射到 $\hask{False}$。输入的大部分信息被丢弃了，我们只对其偶奇性感兴趣，而不是它的实际值。通过丢弃信息，我们得到了**抽象**。

与此相反的是函数 $\hask{injectBool}$：

```haskell
injectBool :: Bool -> Int
injectBool b = if b then 1 else 0
```

这个函数不会丢弃信息。你可以从其结果中完全恢复其参数。

### 单射和单态射

不会丢弃信息的函数被称为**单射**（$Injective\ Functions$），或**单射**（$Injections$）。它们的特性是不同的输入总是映射到不同的输出。换句话说，它们不会将多个元素压缩为一个。

为了在范畴论中表达单射的概念，我们使用箭头的性质。一个箭头 $f : a \to b$ 是**单态射**（$Monomorphism$）的，如果对于任何对象 $c$ 和任何一对箭头 $g_1 : c \to a$ 和 $g_2 : c \to a$，有以下蕴涵成立：

$$
f \circ g_1 = f \circ g_2 \implies g_1 = g_2
$$

也就是说，如果组合后相等，那么它们自身也必须相等。

### 单态射的意义

要证明一个箭头 $f$ 不是单态射，只需找到一个反例：存在 $c$ 和不同的 $g_1$、$g_2$，使得 $f \circ g_1 = f \circ g_2$。

单态射通常用特殊的箭头表示，例如 $a \hookrightarrow b$ 或 $a \rightarrowtail b$。

在范畴论中，对象是不可分的，我们只能通过箭头来谈论子对象。我们说，单态射 $a \hookrightarrow b$ 选择了 $b$ 中形状为 $a$ 的子对象。

### 练习

**练习 5**：证明从终端对象来的任何箭头都是单态射。

---

## 满态射

函数 $\hask{injectBool}$ 是单射（因此是单态射），但它仅覆盖了其目标的一小部分——在无穷多个整数中只有两个值。

```haskell
injectBool :: Bool -> Int
injectBool b = if b then 1 else 0
```

相比之下，函数 $\hask{even}$ 覆盖了整个 $\hask{Bool}$（它可以生成 $\hask{True}$ 和 $\hask{False}$）。覆盖其整个目标的函数称为**满射**（$Surjection$）。

为了在范畴论中表达满射的概念，一个箭头 $f : a \to b$ 是**满态射**（$Epimorphism$）的，如果对于任何对象 $c$ 和任何一对箭头 $g_1 : b \to c$ 和 $g_2 : b \to c$，有以下蕴涵成立：

$$
g_1 \circ f = g_2 \circ f \implies g_1 = g_2
$$

也就是说，如果组合前相等，那么它们自身也必须相等。

### 满态射的意义

要证明一个箭头 $f$ 不是满态射，只需找到一个反例：存在 $c$ 和不同的 $g_1$、$g_2$，使得 $g_1 \circ f = g_2 \circ f$。

满态射通常用特殊的箭头表示，例如 $a \twoheadrightarrow b$。

### 双射和同构

在集合中，同时是单射和满射的函数称为**双射**（$Bijection$）。它在两个集合的元素之间提供了一个一对一的可逆映射。

在范畴论中，这个角色由**同构**（$Isomorphisms$）扮演。然而，一般来说，并不是真的同时是单态射和满态射的箭头就是同构的。

### 练习

**练习 6**：证明到终端对象的任何箭头都是满态射。

---

## 小结

通过这两章的学习，我们初步了解了编程中类型和函数的概念，以及它们在范畴论和逻辑中的对应关系。我们引入了初始对象和终端对象，以及恒等箭头、组合、单态射和满态射等重要概念。

在后续的章节中，我们将继续深入探讨这些概念，并引入更多的范畴论工具，帮助我们更好地理解函数式编程的本质。

---

请注意，在本解答中，我们尝试以通俗易懂的方式解释了原文的内容，并添加了更多的解释和示例，以帮助初学者更好地理解。同时，我们遵循了您指定的 Markdown 和 LaTeX 格式要求。

### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------
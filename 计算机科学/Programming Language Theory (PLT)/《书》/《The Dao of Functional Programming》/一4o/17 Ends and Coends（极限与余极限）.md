[toc]

### -------------------------

### Chapter 17: Ends and Coends（极限与余极限）

**极限 (Ends)** 和 **余极限 (Coends)** 是范畴论中的重要概念，它们是由函子之间的自然变换形成的“普遍对象”。在本章中，我们将介绍这些概念的定义、解释，以及它们在范畴论中的作用。

### 1. 余极限 (Coends)

#### 余极限的定义

余极限是某个双函子 $$ F: \mathcal{C}^{\text{op}} \times \mathcal{C} \to \mathcal{D} $$ 的特殊结构。它可以被看作是在函子 $$ F $$ 作用下的对象在范畴中的“泛化积”。

余极限的形式定义是：

$$
\int^{c \in \mathcal{C}} F(c, c)
$$

这被称为 **余极限 (coend)**，表示在范畴 $$ \mathcal{C} $$ 中，对所有对象 $$ c $$ 进行的普遍余合并。余极限是普遍的“余归并”操作，它通过将函子 $$ F $$ 在同一个对象上作用得到。

#### 余极限的直观解释

直观上，余极限可以理解为在范畴中构建一个“余并集”或“余聚集”，它将范畴中的所有对象通过特定的函子组合起来。

例如，在余极限中，双函子 $$ F $$ 的每个对象 $$ c $$ 会与 $$ F $$ 的对应映射 $$ F(c, c) $$ 一起生成一个余极限对象。我们可以将它想象为从多个范畴的对象生成的一个新的范畴对象，它包含了所有对象的信息。

### 2. 极限 (Ends)

#### 极限的定义

与余极限对偶的是极限。极限是某个双函子 $$ F: \mathcal{C}^{\text{op}} \times \mathcal{C} \to \mathcal{D} $$ 的结构，表示的是在函子 $$ F $$ 作用下的对象的“普遍积”。

极限的形式定义是：

$$
\int_{c \in \mathcal{C}} F(c, c)
$$

这个表达式称为 **极限 (end)**，它表示的是在范畴 $$ \mathcal{C} $$ 中，所有对象 $$ c $$ 的普遍限制。

#### 极限的直观解释

极限可以被视为在某个范畴中的“普遍交集”。通过这个交集，范畴中的所有对象 $$ c $$ 的信息被共同组合并在一起，以形成一个新的对象，它同时适用于所有对象 $$ c $$。

举一个直观的例子，假设 $$ F $$ 是一个表示某个数据结构的函子，那么极限就是在多个范畴的对象之间找到某种“交集”，这个交集保留了所有对象共有的特性。

### 3. 极限与余极限的关系

极限与余极限是对偶的概念。极限是通过普遍限制生成的，而余极限则是通过普遍余合并生成的。两者都涉及到在不同对象之间形成某种全局结构，只不过它们的构造方式是相反的。

- **极限**：通过交集或限制操作，生成包含所有对象信息的“积”。
- **余极限**：通过合并或聚集操作，生成一个包含所有对象信息的“余积”。

### 4. 极限与余极限的应用

极限与余极限在范畴论的很多应用中起到关键作用，它们被广泛用于定义和研究自然变换、函子之间的关系，以及更复杂的范畴结构。例如：

- **极限** 通常用于定义在某个范畴中的“统一对象”。
- **余极限** 则用于表示范畴中的“余聚集”或“余并集”。

它们也是很多其他高阶范畴论概念的基础，特别是在代数拓扑、同伦论等领域。

### 5. 极限与余极限的例子

#### 极限的例子

设 $$ F $$ 是一个从范畴 $$ \mathcal{C} $$ 到集合范畴 $$ \text{Set} $$ 的函子，极限 $$ \int_{c \in \mathcal{C}} F(c, c) $$ 的一个典型例子是一个范畴中的投影极限。投影极限就是某个对象在多个投影之间的“交集”。

#### 余极限的例子

余极限的一个例子是共产品 (coproduct) 或者余并集。在集合范畴中，余极限的结构可以表示为将多个集合通过余并集 (disjoint union) 合并起来。

### 总结

本章介绍了极限和余极限的定义、直观解释及其对偶关系。极限和余极限是范畴论中非常重要的结构，它们通过普遍对象的构造来描述函子之间的自然变换，并在范畴论的广泛应用中起到了重要的作用。

- **极限 (end)**：通过交集或限制操作生成。
- **余极限 (coend)**：通过合并或聚集操作生成。

这些概念为理解更复杂的范畴结构提供了基础，在代数、拓扑、计算机科学等多个领域都有着广泛的应用。

### -------------------------

### Chapter 17: Ends and Coends（极限与余极限）

本章将深入探讨 **极限 (Ends)** 和 **余极限 (Coends)** 的概念，并介绍它们的范畴论背景及其在编程中的应用，特别是在 Haskell 语言中的实现。我们还会讨论泛函 (Profunctors)、自然变换 (Natural Transformations)、以及与透镜 (Lenses) 相关的内容。

---

### 17.1 Profunctors（泛函）

**Profunctor** 是一种广义的函子，通常用于建模某种双向关系。泛函具有丰富的范畴论性质，并在 Haskell 编程中有广泛的应用。

#### Collages（拼接）

泛函可以通过拼接两个不同的函子来定义。拼接是一种将不同对象和映射结合起来的方式，从而形成更复杂的结构。

#### Profunctors as relations（作为关系的泛函）

泛函可以被看作某种“关系”，它将两个不同的范畴联系在一起。比如，一个泛函可以描述从一个对象到另一个对象的映射，就像关系数据库中的关系。

#### Profunctor composition in Haskell（Haskell中的泛函组合）

在 Haskell 中，泛函的组合是一种重要的操作，允许我们将不同的函子通过一些组合规则结合起来。Haskell 中的泛函组合通常使用 `procompose` 等操作符来实现。

---

### 17.2 Coends（余极限）

**Coend** 是一种余极限结构，表示某个函子在范畴中的“余归并”操作。它可以通过将双函子作用在同一个对象上来定义。

#### Extranatural transformations（超自然变换）

超自然变换是自然变换的一般化形式。它允许我们定义一种跨越多个范畴的自然变换，尤其在余极限的背景下，超自然变换起到了关键作用。

#### Profunctor composition using coends（使用余极限的泛函组合）

我们可以通过余极限来组合泛函，形成更复杂的结构。在 Haskell 中，这种组合通常使用 `coend` 和 `profunctor` 的组合方式实现。

#### Colimits as coends（作为余极限的余极限）

很多情况下，**余极限 (Colimits)** 本身可以被表示为某种余极限操作。通过 coend 计算余极限，我们可以得到范畴中的普遍余合并。

---

### 17.3 Ends（极限）

与余极限对偶的是 **极限 (Ends)**，它通过在某个范畴中对函子进行“普遍限制”来定义。

#### Natural transformations as an end（作为极限的自然变换）

自然变换可以通过极限来定义。具体来说，某些自然变换可以被看作是两个函子之间的极限操作。

#### Limits as ends（极限作为极限）

范畴论中的 **极限 (Limits)** 本身也可以通过极限来表示。这是极限的一个重要性质，它展示了极限的普遍性。

---

### 17.4 Continuity of the Hom-Functor（同态函子的连续性）

**Hom-Functor** 是将两个对象之间的态射映射为一个集合的函子。这个函子的连续性是指它可以保持某些范畴结构，比如极限和余极限。

---

### 17.5 Fubini Rule（富比尼法则）

**富比尼法则** 是在处理多重积分时的一条重要定理。在范畴论中，它可以推广到极限和余极限的计算中，帮助我们处理复杂的函子组合。

---

### 17.6 Ninja Yoneda Lemma（Ninja 代数引理）

**Yoneda 引理** 是范畴论中的一个核心定理，它揭示了函子与其表示对象之间的深层关系。Ninja 版本的 Yoneda 引理是一种更为通用的形式，适用于更复杂的范畴结构。

#### Yoneda lemma in Haskell（Haskell中的代数引理）

在 Haskell 中，Yoneda 引理有着直接的应用，可以优化某些类型的函数和结构。这也为 Haskell 编程中的函数优化提供了理论依据。

---

### 17.7 Day Convolution（Day 卷积）

**Day 卷积** 是一种在函子之间定义的卷积操作。它允许我们将两个函子通过卷积结合起来，形成更复杂的函子。

#### Applicative functors as monoids（作为单胚的应用函子）

Day 卷积可以用于将 **Applicative** 函子建模为单胚。Applicative 函子提供了一种结构化的方式来组合计算，它们在函数式编程中扮演了重要角色。

#### Free Applicatives（自由应用函子）

**自由应用函子** 是一种特殊类型的函子，提供了一种最小的结构来实现某些计算任务。通过 Day 卷积，我们可以构造出自由应用函子。

---

### 17.8 伴随态射的双范畴（The Bicategory of Profunctors）

双范畴 (Bicategory) 是一种扩展的范畴概念，它允许我们在更复杂的结构中定义态射的组合。伴随态射的双范畴是双范畴中的重要结构。

#### 双范畴中的单子（Monads in a Bicategory）

双范畴中的 **单子 (Monads)** 是一种高阶结构，它们可以看作是双范畴中的态射组合。

#### 在 Prof 中的前箭头作为单子（Prearrows as Monads in Prof）

在泛函的背景下，我们可以将 **前箭头 (Prearrows)** 看作是某种单子。这些结构在构建复杂的范畴结构时非常有用。

---

### 17.9 存在透镜（Existential Lens）

**存在透镜 (Existential Lens)** 是透镜的一种特殊形式，允许我们在不确定类型的情况下操作数据结构。

#### Haskell 中的存在透镜（Existential Lens in Haskell）

在 Haskell 中，存在透镜可以通过某些高级类型系统特性来实现，允许我们对不确定类型的数据进行操作。

#### 范畴论中的存在透镜（Existential Lens in Category Theory）

从范畴论的角度看，存在透镜是一种对范畴中的某些对象进行聚焦和操作的工具。

#### Haskell 中的类型变化透镜（Type-changing Lens in Haskell）

类型变化透镜允许我们在修改数据的同时改变数据的类型。这在 Haskell 中特别有用，因为它提供了一种灵活的方式来管理复杂数据结构。

#### 透镜组合（Lens Composition）

透镜的一个重要性质是它们可以组合。通过组合，我们可以在更复杂的数据结构中建立聚焦和操作。

#### 透镜的范畴（Category of Lenses）

透镜本身可以形成一个范畴，其中的态射是透镜之间的组合。这种范畴结构揭示了透镜的组合性和普遍性。

---

### 17.10 透镜与纤维丛 (Lenses and Fibrations)

透镜与 **纤维丛 (Fibrations)** 之间有着深刻的联系。纤维丛是一种描述空间和对象之间复杂关系的结构。

#### 传输定律 (Transport Law)

传输定律描述了如何将某些结构从一个对象传递到另一个对象。在透镜和纤维丛的背景下，这个定律非常重要。

#### 恒等定律 (Identity Law)

恒等定律是范畴论中的基本定律之一，它确保了对象和态射之间的一致性。

#### 组合定律 (Composition Law)

组合定律描述了在透镜中如何组合不同的态射，确保组合后的结果仍然满足透镜的结构要求。

#### 类型转换透镜 (Type-changing Lens)

类型转换透镜允许我们在修改数据的过程中改变其类型，这是处理复杂数据结构时的重要工具。

---

### 17.11 重要公式 (Important Formulas)

本节列出了本章讨论的所有重要公式，帮助读者快速回顾极限、余极限、透镜以及相关的范畴论结构。

### -------------------------

### 17.1 Profunctors（泛函）

在范畴论的高度抽象中，**Profunctors**（泛函）是一种将两个范畴之间的对象对映射到集合的结构。与我们熟悉的箭头不同，泛函的概念更加抽象，涉及更高阶的构造。我们可以将泛函理解为从一对对象 $⟨a, b⟩$ 映射到某个集合 $P⟨a, b⟩$，并且它也可以将一对箭头 $⟨f: s \to a, g: b \to t⟩$ 映射到一个函数 $P⟨f, g⟩: P⟨a, b⟩ \to P⟨s, t⟩$。

### 函子的层次

- **态射 (arrows)**：从对象 $a$ 到对象 $b$ 的箭头代表了一个映射。我们通常将其与熟悉的函数进行类比，函数消耗对象 $a$ 的元素并生成对象 $b$ 的元素。
- **函子 (functors)**：是范畴之间的箭头。它消耗来自一个范畴的对象和箭头，并生成另一个范畴中的对象和箭头。我们可以将其视为使用源范畴中的材料构建目标范畴中对象和箭头的一种方式。
- **自函子 (endofunctors)**：是一种特殊的函子，作用于同一个范畴，它们可以看作是容器，承载着范畴中的对象和箭头。

### Profunctors 的基本定义

泛函 $P⟨a, b⟩$ 可以理解为从两个对象 $a$ 和 $b$ 中生成一个集合。这个集合并不仅仅局限于对象本身的元素，而是通过关联它们的关系来定义。

一个典型的泛函结构可以表示如下：

$$
P⟨f, g⟩: P⟨a, b⟩ \to P⟨s, t⟩
$$

- $f: s \to a$ 是一个逆向箭头，表示从对象 $s$ 到对象 $a$ 的映射。
- $g: b \to t$ 是一个正向箭头，表示从对象 $b$ 到对象 $t$ 的映射。

这个结构表明了泛函如何处理对象和箭头的组合。

### 同态函子 (Hom-Functors) 作为 Profunctors 的模型

**Hom-Functor** 是一个很好的例子，用于直观理解 Profunctor。范畴中的同态集 (hom-set) 表示对象之间的箭头集合。在这个集合中，箭头之间可以组合。同态函子可以被看作是 Profunctor 的一个特例。它们在不同对象间的箭头集提供了桥梁，并且为对象之间的映射提供了模型。

### Profunctor 的组合 (Composition)

虽然 Profunctor 的定义较为抽象，但它的组合方式可以通过提升箭头（lifting of arrows）来理解。考虑下列情况：
- **预组合 (Precomposition)**：给定一个箭头 $f: s \to a$，可以通过提升 $f$ 将 $P⟨a, b⟩$ 映射为 $P⟨s, b⟩$，即：
  $$ P⟨f, \text{id}_b⟩: P⟨a, b⟩ \to P⟨s, b⟩ $$

- **后组合 (Postcomposition)**：给定一个箭头 $g: b \to t$，可以通过提升 $g$ 将 $P⟨a, b⟩$ 映射为 $P⟨a, t⟩$，即：
  $$ P⟨\text{id}_a, g⟩: P⟨a, b⟩ \to P⟨a, t⟩ $$

这种异质的组合方式允许我们在同态集中提升箭头，从而生成新的泛函元素。

### Profunctor 的扩展

我们可以通过提升一对箭头来扩展 Profunctor，从而在两侧同时进行操作。例如：

$$
P⟨f, g⟩: P⟨a, b⟩ \to P⟨s, t⟩
$$

在这个组合过程中，一个箭头可以“预组合”或“后组合”到 Profunctor 中，从而生成新的映射。通过这种操作，泛函的元素得以扩展，使得它们能够处理更广泛的组合场景。

### 总结

Profunctors 是范畴论中的重要抽象结构，它们允许我们在两个范畴之间建立复杂的映射。通过同态函子作为模型，我们可以理解 Profunctor 如何在对象和箭头之间建立关系，并通过箭头提升（precomposition 和 postcomposition）进行组合。

### -------------------------

### Collages（拼接）

在范畴论中，**拼接 (collage)** 是通过将两个不同的范畴连接起来形成一个新的范畴。拼接不仅保留了原来两个范畴中的对象和态射，还引入了一种新的异态射 (heteromorphisms)，这些态射连接来自两个不同范畴的对象。

### 泛函在两个范畴之间的扩展

通常，泛函是定义在一个范畴中的结构。但实际上，泛函并不需要局限于单一范畴。我们可以定义一个泛函 $P: \mathcal{C}^{\text{op}} \times \mathcal{D} \to \text{Set}$，它将范畴 $\mathcal{C}$ 和 $\mathcal{D}$ 中的对象和态射映射到集合。这种泛函通过生成从范畴 $\mathcal{C}$ 到范畴 $\mathcal{D}$ 的同态集 (hom-set)，将两个不同的范畴联系在一起。

### 拼接的定义

拼接范畴 $\mathcal{C} \star \mathcal{D}$ 的对象集合是范畴 $\mathcal{C}$ 和 $\mathcal{D}$ 中对象的并集（不相交）。同态集的定义如下：

1. 如果对象 $x$ 和 $y$ 都在范畴 $\mathcal{C}$ 中，则同态集是 $\text{Hom}_{\mathcal{C}}(x, y)$。
2. 如果对象 $x$ 和 $y$ 都在范畴 $\mathcal{D}$ 中，则同态集是 $\text{Hom}_{\mathcal{D}}(x, y)$。
3. 如果 $x$ 在 $\mathcal{C}$ 中，$y$ 在 $\mathcal{D}$ 中，则同态集是泛函 $P(x, y)$ 的值。
4. 如果 $x$ 在 $\mathcal{D}$ 中，而 $y$ 在 $\mathcal{C}$ 中，同态集为空。

态射的组合遵循通常的组合规则，但如果组合中的一个态射是 $P(x, y)$ 的元素，则需要特殊处理。这种情况涉及将态射提升至新的拼接结构。

### 异态射（heteromorphisms）

拼接范畴中的异态射是连接两个不同范畴对象的箭头。在拼接范畴中，异态射只能从范畴 $\mathcal{C}$ 的对象指向范畴 $\mathcal{D}$ 的对象，而不能反向。这些异态射代表了不同范畴之间的桥梁，形成了一个从 $\mathcal{C}$ 到 $\mathcal{D}$ 的单向箭头网络。

### 内泛函（endoprofunctor）

当我们处理从 $\mathcal{C}^{\text{op}} \times \mathcal{C}$ 到 $\text{Set}$ 的泛函时，我们称其为内泛函（endoprofunctor）。这是泛函的一种特殊形式，它定义了范畴 $\mathcal{C}$ 与其自身的拼接。

### 练习 17.1.1

**证明从两个范畴的拼接到一个有两个对象和一个箭头（以及两个恒等箭头）的“步行箭头”范畴（walking arrow category）之间存在一个函子。**

### 练习 17.1.2

**证明如果从 $\mathcal{C}$ 到步行箭头范畴存在一个函子，那么 $\mathcal{C}$ 可以分解成两个范畴的拼接。**

### 总结

拼接是范畴论中的一种结构化方式，它允许我们通过泛函将两个不同的范畴组合起来。通过引入异态射，拼接范畴扩展了原有的结构，连接了不同的对象和态射。拼接为范畴间的关系提供了一个框架，使得我们能够在不同范畴的对象之间建立交互关系。

### -------------------------

拼接 (collage) 是范畴论中的一个重要概念，用来连接两个不同的范畴，并为这些范畴之间的关系提供一种结构化的表示。这个概念最关键的地方在于，它不仅保留了两个范畴内部的结构，还允许引入从一个范畴到另一个范畴的态射（我们称之为异态射，heteromorphisms）。

### 拼接的详细定义

设有两个范畴 $\mathcal{C}$ 和 $\mathcal{D}$，我们可以构造一个新的范畴，称为它们的拼接，记作 $\mathcal{C} \star \mathcal{D}$。拼接的对象集由 $\mathcal{C}$ 和 $\mathcal{D}$ 中的对象构成（不相交的并集），即 $\mathcal{C}$ 的对象和 $\mathcal{D}$ 的对象都出现在新的范畴中，但它们之间不会互相重叠。拼接范畴的关键在于如何定义态射。

#### 同态集的定义

拼接范畴中的同态集 $\text{Hom}_{\mathcal{C} \star \mathcal{D}}(x, y)$ 的定义根据对象 $x$ 和 $y$ 的来源不同，有以下几种情况：

1. **$x$ 和 $y$ 都来自 $\mathcal{C}$：**
   - 在这种情况下，同态集 $\text{Hom}_{\mathcal{C} \star \mathcal{D}}(x, y)$ 就是 $\mathcal{C}$ 中的同态集 $\text{Hom}_{\mathcal{C}}(x, y)$。
   
2. **$x$ 和 $y$ 都来自 $\mathcal{D}$：**
   - 如果两个对象都来自 $\mathcal{D}$，那么同态集 $\text{Hom}_{\mathcal{C} \star \mathcal{D}}(x, y)$ 就是 $\mathcal{D}$ 中的同态集 $\text{Hom}_{\mathcal{D}}(x, y)$。

3. **$x$ 来自 $\mathcal{C}$，$y$ 来自 $\mathcal{D}$：**
   - 在这种情况下，我们引入了从 $\mathcal{C}$ 到 $\mathcal{D}$ 的“异态射”，这些异态射来自泛函 $P$。我们设一个双函子 $P: \mathcal{C}^{\text{op}} \times \mathcal{D} \to \text{Set}$，表示从 $\mathcal{C}$ 的对象到 $\mathcal{D}$ 的对象的某种关系或映射。同态集 $\text{Hom}_{\mathcal{C} \star \mathcal{D}}(x, y)$ 就是集合 $P(x, y)$。

4. **$x$ 来自 $\mathcal{D}$，$y$ 来自 $\mathcal{C}$：**
   - 这种情况下，同态集为空集，因为我们不允许从 $\mathcal{D}$ 到 $\mathcal{C}$ 的箭头存在。

#### 同态组合的定义

在 $\mathcal{C} \star \mathcal{D}$ 中，同态的组合规则一般与 $\mathcal{C}$ 和 $\mathcal{D}$ 中的组合规则相同。当两个对象都在同一个范畴（$\mathcal{C}$ 或 $\mathcal{D}$）中时，同态的组合规则保持不变。然而，当一个态射来自 $\mathcal{C}$，另一个来自 $\mathcal{D}$ 时，我们需要考虑如何将它们组合。

特别地，涉及泛函 $P(x, y)$ 的同态组合比较特殊。设 $f: a \to b$ 是 $\mathcal{C}$ 中的态射，而 $g: b' \to c$ 是 $\mathcal{D}$ 中的态射。为了将这两个不同来源的态射组合在一起，我们会使用泛函 $P$ 提供的结构进行“提升”，即通过某种方式将 $\mathcal{C}$ 和 $\mathcal{D}$ 中的态射组合成新的异态射。

### 异态射 (heteromorphisms)

拼接范畴引入了所谓的“异态射”，这是拼接范畴中的新特性。异态射连接了来自 $\mathcal{C}$ 的对象和 $\mathcal{D}$ 的对象。注意，异态射只允许从 $\mathcal{C}$ 中的对象指向 $\mathcal{D}$ 中的对象，而不能反向。这些异态射通过泛函 $P$ 生成，它们代表了两个不同范畴之间的桥梁。

### 例子：拼接范畴的构造

假设我们有两个范畴 $\mathcal{C}$ 和 $\mathcal{D}$，其中 $\mathcal{C}$ 有两个对象 $A$ 和 $B$，$\mathcal{D}$ 也有两个对象 $C$ 和 $D$。在拼接范畴 $\mathcal{C} \star \mathcal{D}$ 中，我们会有如下的对象和态射：

- 对象集为 $\{A, B, C, D\}$。
- $\mathcal{C}$ 中的态射 $\text{Hom}_{\mathcal{C}}(A, B)$ 依然存在。
- $\mathcal{D}$ 中的态射 $\text{Hom}_{\mathcal{D}}(C, D)$ 依然存在。
- 如果我们定义了一个泛函 $P: \mathcal{C}^{\text{op}} \times \mathcal{D} \to \text{Set}$，那么异态射 $P(A, C)$ 将允许从 $A$ 到 $C$ 的态射。

通过这种方式，拼接范畴能够连接不同范畴中的对象和态射，并在更大的范畴中组合它们的结构。

### 内泛函（endoprofunctor）

当我们定义一个从 $\mathcal{C}^{\text{op}} \times \mathcal{C}$ 到 $\text{Set}$ 的泛函时，我们称之为 **内泛函 (endoprofunctor)**。这是泛函的一种特殊形式，它描述了范畴 $\mathcal{C}$ 与其自身的拼接。换句话说，内泛函通过拼接 $\mathcal{C}$ 和 $\mathcal{C}$ 自身，形成一个从 $\mathcal{C}$ 到自身的扩展。

### 练习 17.1.1 详细解释

**证明从两个范畴的拼接到一个有两个对象和一个箭头（以及两个恒等箭头）的“步行箭头”范畴（walking arrow category）之间存在一个函子。**

要证明这个命题，我们需要展示如何从拼接范畴 $\mathcal{C} \star \mathcal{D}$ 构造到步行箭头范畴的函子。步行箭头范畴只有两个对象和一个箭头，所以我们需要将 $\mathcal{C}$ 和 $\mathcal{D}$ 的对象和态射映射到这两个对象之间的唯一箭头上。

### 练习 17.1.2 详细解释

**证明如果从 $\mathcal{C}$ 到步行箭头范畴存在一个函子，那么 $\mathcal{C}$ 可以分解成两个范畴的拼接。**

如果存在这样一个函子，我们可以将范畴 $\mathcal{C}$ 中的对象和态射分成两个部分，一个部分映射为步行箭头范畴的起点对象，另一个部分映射为终点对象。通过这种方式，$\mathcal{C}$ 可以被自然分解为两个子范畴，并通过拼接构造新的范畴。

### 总结

拼接是范畴论中的一个重要工具，它允许我们通过异态射连接不同的范畴。通过泛函 $P$，我们能够定义从一个范畴到另一个范畴的映射，从而建立更复杂的范畴结构。拼接不仅保留了原范畴的态射，还引入了新的异态射，使得我们可以在范畴间进行操作。

### -------------------------

### Profunctors as Relations（作为关系的泛函）

在范畴论中，**Profunctors**（泛函）不仅可以被看作是函子（functors），还可以理解为对象之间的某种“关系”。这种关系与传统的二元关系（binary relations）不同，它们是 **证明相关的关系** (proof-relevant relations)，即它们不仅表明两个对象之间是否相关，还包含了证明这种相关性的一些结构化信息。

### 普通关系与证明相关关系

首先，让我们回顾一下传统的关系：在集合论中，二元关系可以被看作是集合的笛卡尔积的子集。例如，在集合 $A$ 和 $B$ 之间的关系可以定义为 $R \subseteq A \times B$，其中 $R(a, b)$ 表示 $a$ 和 $b$ 之间有关系。如果 $R(a, b)$ 是真，则 $a$ 与 $b$ 是相关的；如果为假，则它们不相关。

然而，在 **Profunctors** 中，这种关系被进一步结构化。Profunctors 定义的是两者之间的 **证明相关性**。我们不仅知道 $a$ 和 $b$ 是否相关，还知道是什么使它们相关。这种“证明相关的关系”具有更丰富的信息，因为它不仅描述了关系的存在性，还包含了使这种关系成立的具体证据。

### Profunctors 的定义回顾

我们可以定义一个 Profunctor $P$ 为：

$$ P: \mathcal{C}^{\text{op}} \times \mathcal{D} \to \text{Set} $$

它将范畴 $\mathcal{C}$ 和 $\mathcal{D}$ 中的对象对映射到集合。特别地，对于每一对对象 $a \in \mathcal{C}$ 和 $b \in \mathcal{D}$，Profunctor 生成一个集合 $P(a, b)$。这个集合的元素可以被看作是证明 $a$ 与 $b$ 之间关系的“证据”。

- 如果集合 $P(a, b)$ 为空，则 $a$ 和 $b$ 之间没有关系。
- 如果 $P(a, b)$ 非空，则其中的每个元素代表了 $a$ 和 $b$ 之间关系的一个具体证明。

### Profunctors 与 Hom-Functors 的类比

我们可以将 Profunctor 类比为同态函子 (Hom-Functor)。对于每对对象 $a, b$，同态函子 $\text{Hom}(a, b)$ 生成了从 $a$ 到 $b$ 的箭头集，这些箭头集可以看作对象之间的关系。同样，Profunctor 生成了对象对之间的某种“关系集”。然而，与普通的同态集不同，Profunctor 允许我们对来自两个不同范畴的对象生成关系。

在同态函子中，自反性是隐含的，因为对于每个对象 $a$，同态集 $\text{Hom}(a, a)$ 总是非空的（至少包含恒等态射 $\text{id}_a$）。而在 Profunctors 中，自反性并不是必然的，因为 $P(a, a)$ 可能为空。因此，Profunctors 定义的关系不必满足自反性。

### Profunctors 与证明相关的关系

让我们再深入理解一下 **证明相关的关系**。假设我们有一个 Profunctor $P(a, b)$，它表明对象 $a$ 与对象 $b$ 之间存在某种关系。具体来说，如果 $P(a, b)$ 非空，则其中的每个元素都是这种关系的一个“证明”。例如：
- 如果 $P(a, b)$ 是空集合，则意味着 $a$ 和 $b$ 之间没有关系。
- 如果 $P(a, b)$ 非空，则每个元素表示一个“证明”或“证据”，说明 $a$ 和 $b$ 是相关的。

这种关系可能不是对称的，也不是自反的。比如，$P(a, a)$ 可能为空，表示自反性不成立。同时，$P(a, b)$ 和 $P(b, a)$ 可能没有对称性。

### 组合 Profunctors

Profunctors 的一个关键特性是它们可以进行组合。组合 Profunctors 类似于关系的组合，我们通过中间对象构造新的关系。换句话说，如果两个对象之间存在一个中间对象使得它们分别与中间对象相关联，那么它们之间可以通过中间对象建立联系。

#### 关系组合的例子

假设你想给手机充电，但你没有充电器。这时，你有一个朋友，他有一个充电器。你可以通过这个朋友建立一条“充电”关系，即你与朋友的关系（友情）和朋友与充电器的关系（拥有充电器）组合在一起，形成你和充电器的间接关系。

- **证明相关性**：这种组合关系中的证明不是直接从你到充电器的证明，而是由两部分构成：一部分是你与朋友的关系的证明，另一部分是朋友与充电器的关系的证明。组合的结果是一对证明，表明你可以通过朋友获得充电器。

### 形式化的关系组合

对于两个对象 $a$ 和 $c$，如果存在一个中间对象 $b$ 使得 $P(a, b)$ 和 $Q(b, c)$ 都非空，那么我们可以组合这些 Profunctors 得到新的关系 $R(a, c)$：

$$
R(a, c) = \int^{b} P(a, b) \times Q(b, c)
$$

这意味着，$R(a, c)$ 是所有中间对象 $b$ 的笛卡尔积的余极限。组合的结果是通过每个可能的中间对象 $b$ 的关系集来定义的。

### 总结

Profunctors 可以被看作是对象之间的证明相关关系，它们不仅描述了两个对象是否相关，还包含了具体的证明信息。这些关系可以进行组合，就像普通关系的组合一样。组合 Profunctors 的过程依赖于寻找中间对象，并通过中间对象建立间接关系。

### -------------------------

### Profunctor Composition in Haskell（Haskell 中的泛函组合）

在 Haskell 中，**Profunctor** 是一个重要的抽象概念，表示两个范畴之间的映射关系。Profunctors 的组合可以看作是对象之间关系的组合。理解这种组合的关键在于它需要一个中间对象来建立联系。让我们通过一些具体的代码和概念来深入探讨 Haskell 中的 Profunctor 组合。

### Profunctor 定义

在 Haskell 中，Profunctor 的基本定义如下：

```haskell
class Profunctor p where
  dimap :: (s -> a) -> (b -> t) -> p a b -> p s t
```

- `dimap` 是 Profunctor 的主要操作，它接收两个函数：
  - 第一个函数 `(s -> a)` 将对象从类型 `s` 映射到 `a`。
  - 第二个函数 `(b -> t)` 将对象从类型 `b` 映射到 `t`。
- `dimap` 将 `p a b` 的 Profunctor 映射到 `p s t`，通过对左侧进行预处理和右侧进行后处理。

### Profunctor 组合

Profunctor 的组合依赖于存在一个中间对象来弥合两个对象之间的差距。设想我们有两个对象 $a$ 和 $b$，想通过两个 Profunctors $P$ 和 $Q$ 使它们相关联。我们必须引入一个中间对象 $x$，如下图所示：

```
  a —— Q ——> x —— P ——> b
```

这里，$a$ 通过 $Q$ 关联到 $x$，$x$ 通过 $P$ 关联到 $b$。在 Haskell 中，这种组合使用 **存在类型** 来进行编码。

### Procompose 的定义

我们可以定义两个 Profunctors $p$ 和 $q$ 的组合为一个新的 Profunctor `Procompose`：

```haskell
data Procompose p q a b where
  Procompose :: q a x -> p x b -> Procompose p q a b
```

- `Procompose` 的两个参数分别表示两个证明：
  - 第一个参数是 $q \ a \ x$，表示 $x$ 与 $a$ 相关。
  - 第二个参数是 $p \ x \ b$，表示 $b$ 与 $x$ 相关。

通过这两个证明，`Procompose` 证明了 $a$ 和 $b$ 之间的关系。我们使用 GADT （广义代数数据类型）来表示中间对象 $x$ 的存在性。

### 存在类型与求和

**存在类型** 是和类型 (sum type) 的一种推广，它允许我们对所有可能的类型 $x$ 进行求和。就像在 `Either` 类型中通过注入不同的构造函数来构造值一样，存在类型允许我们选择一个特定类型 $x$，并将其注入到 `Procompose` 中。

**mapOut** 是一种操作，允许我们从 `Procompose` 类型中映射出结果：

```haskell
mapOut :: Procompose p q a b -> (forall x. q a x -> p x b -> c) -> c
mapOut (Procompose qax pxb) f = f qax pxb
```

这里，`mapOut` 使用一个多态函数来映射出结果，它对所有可能的 $x$ 进行操作。

### Profunctor 组合的实例

我们可以为 `Procompose` 定义 `Profunctor` 实例，表示组合本身也是一个 Profunctor：

```haskell
instance (Profunctor p, Profunctor q) => Profunctor (Procompose p q) where
  dimap l r (Procompose qax pxb) =
    Procompose (dimap l id qax) (dimap id r pxb)
```

这个定义表明，`Procompose` 的 Profunctor 组合可以通过以下方式实现：
- 对第一个 Profunctor 应用 `dimap l id`，将左侧的映射扩展到左边。
- 对第二个 Profunctor 应用 `dimap id r`，将右侧的映射扩展到右边。

### 泛函组合中的存在类型

在 Haskell 中，使用参数多态性来确保泛函组合的正确性。存在类型的作用是引入中间对象 $x$，通过对所有可能的类型 $x$ 进行求和，来确定正确的组合路径。这种组合方式允许我们通过一个中间对象将两个 Profunctors 组合起来，从而定义出新的关系。

然而，虽然在编程语言中这类组合是有效的，但在范畴论中，需要对这种组合进行精确的控制和补偿。范畴论中的组合过程要求我们谨慎处理对象之间的关系，以避免过度计数的问题。

### 组合过程的注意点

在进行 Profunctor 组合时，虽然我们通过中间对象 $x$ 完成了组合，但我们必须考虑组合中的一些细节：
1. **存在性问题**：在某些情况下，中间对象 $x$ 可能并不唯一，或者多个不同的 $x$ 可以实现相同的组合。这种情况可能导致重复计数。
2. **泛函的兼容性**：为了确保组合的正确性，参与组合的两个 Profunctor 必须在类型和结构上保持兼容。Haskell 通过类型系统和多态性来确保这种兼容性。

### 总结

在 Haskell 中，Profunctor 的组合可以通过引入中间对象 $x$ 来实现。我们定义了 `Procompose` 类型，用于表示两个 Profunctors 的组合关系。通过 `dimap` 函数，我们可以分别在左侧和右侧扩展组合的映射。Haskell 的类型系统和存在类型使得这种泛函组合的实现既灵活又安全。

Profunctor 组合是一种强大的抽象，它不仅适用于数学范畴论，还在编程语言中找到了具体的实现。通过这种组合，我们能够建立起对象之间更复杂的关系，并通过存在类型确保组合的正确性和多态性。

### -------------------------

### 17.2 Coends（余极限）

**余极限 (Coend)** 是范畴论中的一种特殊构造，用来处理泛函组合时的双重计数问题。在泛函组合过程中，通常会出现不同中间对象之间通过某个态射连接的情况，从而导致重复计数。为了避免这个问题，余极限提供了一种对和类型进行调整的方法，确保我们只计算每个中间对象一次。

### 泛函组合中的双重计数问题

在泛函组合的过程中，我们经常会有多个中间对象连接两个不同的对象。例如，考虑以下情况：

$$
a \xrightarrow{Q} x \xrightarrow{P} b
$$

或者：

$$
a \xrightarrow{Q} y \xrightarrow{P} b
$$

当我们组合这两个泛函时，会遇到双重计数的问题。我们既可以通过泛函 $Q⟨\text{id}, f⟩$ 使用 $y$ 作为中间对象，也可以通过泛函 $P⟨f, \text{id}⟩$ 使用 $x$ 作为中间对象。这导致了两个不同的计数。

### 解决方案：使用余极限

为了避免双重计数问题，我们必须调整我们应用泛函的方式，最终得到的结构就是 **余极限 (coend)**。余极限是对所有可能的中间对象进行适当处理的泛函组合方法。

#### 问题重述

我们要对所有对象 $x$ 在乘积 $P⟨a, x⟩ Q⟨x, b⟩$ 上求和。双重计数发生的原因是我们可以在泛函 $P$ 和 $Q$ 之间找到多个不同的连接态射。因此，我们需要关注泛函的更通用形式，即乘积 $P⟨a, x⟩ Q⟨y, b⟩$，并找到其中的对角部分（即当 $x = y$ 时的情况）。

#### 对角部分的和

我们要做的是将泛函 $P$ 的对角部分进行求和。实际上，这种构造适用于任何从范畴 $\mathcal{C}^{\text{op}} \times \mathcal{C}$ 到 $\mathcal{D}$ 的函子，而不仅仅限于 Set 值的泛函。对角部分的和由注入定义：每个对象 $\mathcal{C}$ 有一个注入（记为 $i_x$ 和 $i_y$），表示将对角项注入到泛函中。

#### 余楔形图 (co-wedge diagram)

余极限的构造基于一个叫做 **余楔形图 (co-wedge diagram)** 的交换图。该图描述了泛函 $P⟨y, x⟩$、$P⟨y, y⟩$ 和 $P⟨x, x⟩$ 之间的关系，并定义了如何通过态射 $f: x \to y$ 在不同的注入之间进行转换。

交换条件称为 **余楔条件 (co-wedge condition)**，表示对于每个态射 $f: x \to y$，我们有以下等式成立：

$$
i_x \circ P⟨f, \text{id}_y⟩ = i_y \circ P⟨\text{id}_x, f⟩
$$

这个条件确保了我们在处理泛函组合时不会重复计数。

### 余极限的定义

余极限是一个通用的余楔形图。我们用积分符号表示它：

$$
\int_{x: \mathcal{C}} P⟨x, x⟩
$$

这表示对范畴 $\mathcal{C}$ 中所有对象 $x$ 的对角部分进行和。任何配备了满足余楔条件的箭头族 $g_x: P⟨x, x⟩ \to d$ 的对象 $d$，都会有一个从余极限映射出的唯一态射 $h$：

$$
h: \int_{x: \mathcal{C}} P⟨x, x⟩ \to d
$$

该态射 $h$ 可以通过注入 $i_x$ 将所有的 $g_x$ 因式分解。

### 余极限与和类型的比较

余极限可以看作是和类型的推广。在集合范畴中，余极限可以通过所有集合 $P⟨x, x⟩$ 的带鉴别的并集来构造。然后，我们通过满足余楔条件的元素识别这些并集中的元素。例如，当存在态射 $f: x \to y$ 使得：

$$
P⟨\text{id}, f⟩(c) = b
$$

且

$$
P⟨f, \text{id}⟩(c) = a
$$

时，我们可以将元素 $a$ 和 $b$ 视为相等。

### 总结

余极限 (coend) 是一种处理泛函组合时双重计数问题的结构。它通过引入余楔形图和余楔条件，确保我们对中间对象的组合进行合理的计数。余极限可以看作是对和类型的推广，并且在范畴论中有广泛的应用。特别是在 Set 值的泛函中，余极限可以通过鉴别的并集来构造，并根据余楔条件进行元素识别。

### -------------------------

### Extranatural Transformations（超自然变换）

**超自然变换 (Extranatural transformations)** 是自然变换的推广。通常，自然变换是两个函子之间的箭头族，每个箭头依赖于源范畴中的对象，并且满足自然性条件。在 **余楔条件 (co-wedge condition)** 中，注入形成了一个对象参数化的函数族，但不能很好地契合标准自然变换的定义。超自然变换就是为了解决这种情况而提出的一种更广泛的变换。

### 自然变换与超自然变换

#### 自然变换回顾

通常，自然变换是两个函子之间的变换，满足以下交换条件：如果有两个函子 $P: \mathcal{C} \to \mathcal{D}$ 和 $Q: \mathcal{C} \to \mathcal{D}$，自然变换 $\alpha$ 将 $P$ 变换为 $Q$，即对于 $\mathcal{C}$ 中的每个对象 $x$，有一个态射 $\alpha_x: P(x) \to Q(x)$，并且对每个态射 $f: x \to y$，下图交换：

$$
P(x) \xrightarrow{\alpha_x} Q(x) \\
P(f) \downarrow \quad \quad \downarrow Q(f) \\
P(y) \xrightarrow{\alpha_y} Q(y)
$$

自然变换要求函子在箭头之间保持一致性。

#### 余楔条件与超自然变换

余楔条件涉及反变和协变的结构。在函子 $P: \mathcal{C}^{\text{op}} \times \mathcal{C} \to \mathcal{D}$ 中，$P$ 在第一个参数是反变的，在第二个参数是协变的。虽然我们可以定义一个从 $x \mapsto P⟨x, x⟩$ 的对角部分，但这并不是标准的自然变换。

**余楔条件**提供了一种最接近自然性条件的表达形式：

$$
P⟨y, x⟩ \to P⟨y, y⟩ \to P⟨x, x⟩
$$

余楔条件要求对于每个态射 $f: x \to y$，上图交换。类似于自然性方块，余楔条件涉及不同的态射提升与变换之间的交互。标准的自然性条件需要函子之间的变换，而余楔条件是泛函 $P$ 到常量泛函 $\Delta_d: \mathcal{C}^{\text{op}} \times \mathcal{C} \to \mathcal{D}$ 的特殊映射。我们可以通过推广自然性条件来理解它。

### 超自然变换的定义

**超自然变换** 是从函子 $P: \mathcal{C}^{\text{op}} \times \mathcal{C} \to \mathcal{E}$ 到函子 $Q: \mathcal{D}^{\text{op}} \times \mathcal{D} \to \mathcal{E}$ 之间的箭头族。其超自然性条件如下：

1. **在 $c$ 中的超自然性**：对于任何态射 $f: c \to c'$, 以下图表交换：

   $$
   P⟨c', c⟩ \to P⟨c', c'⟩ \to P⟨c, c⟩ \\
   \downarrow \quad \quad \downarrow \\
   Q⟨d, d⟩
   $$

2. **在 $d$ 中的超自然性**：对于任何态射 $g: d \to d'$，以下图表交换：

   $$
   P⟨c, c⟩ \to Q⟨d, d⟩ \to Q⟨d', d'⟩ \\
   \downarrow \quad \quad \downarrow \\
   Q⟨d, d'⟩
   $$

这些条件确保了超自然变换满足特定的交换关系，与标准的自然性类似，但更为灵活。

### 超自然变换与余楔条件的联系

我们可以将余楔条件解释为超自然变换的特例。超自然变换 $ \alpha_{cd}: P⟨c, c⟩ \to Q⟨d, d⟩ $ 在 $c$ 和 $d$ 中满足特定的交换条件。这表明余楔条件实际上是从 $P$ 到常量泛函 $\Delta_d$ 的超自然性。

### 余极限的通用性

余极限定义为 $(c, i)$ 的配对，其中 $c$ 是配备了从 $P$ 到常量泛函 $\Delta_c$ 的超自然变换 $i$ 的对象，并且在此类配对中具有通用性。即，对于任何配备了从 $P$ 到 $\Delta_d$ 的超自然变换 $\alpha$ 的对象 $d$，存在一个唯一的态射 $h: c \to d$，使得所有的 $\alpha_x$ 可以通过 $i_x$ 进行因式分解：

$$
\alpha_x = h \circ i_x
$$

余极限对象 $c$ 可以写作：

$$
c = \int_x P⟨x, x⟩
$$

### 练习 17.2.1

**验证对于从 $P$ 到 $\Delta_d$ 的超自然变换，第一个超自然性菱形等价于余楔条件，第二个条件是平凡的。**

要验证这一点，我们需要回顾余楔条件和超自然变换之间的关系。余楔条件要求图表在态射之间交换，这是超自然性中的第一个菱形。在第二个条件中，由于常量泛函 $\Delta_d$ 的存在，超自然性条件是平凡的。

### ------------------------------

### Colimits as Coends（作为余极限的余极限）

余极限 (colimit) 是范畴论中的一种重要结构，用来概括对象的“合并”或“归并”操作。**Coends** (余极限) 是范畴论中更广泛的概念，用来表示一种对泛函组合的结果。将 **余极限** 视为 **余极限 (coend)**，我们可以从范畴的组合操作的角度理解余极限。

### 忽略一个参数的泛函与函子

如果我们从二元泛函（两个参数的函数）开始，忽略其中一个参数，它就变成了一元泛函（函数）。类似地，如果我们从一个带有两个参数的泛函 $P⟨x, y⟩$ 开始，忽略其中一个参数，我们可以得到一个单一的函子 $F: \mathcal{C} \to \mathcal{D}$。

设有一个函子 $F: \mathcal{C} \to \mathcal{D}$，我们可以将其推广为一个 **平凡的泛函**，定义如下：
- 在对象上的作用：$P⟨x, y⟩ = F(y)$，即忽略第一个参数 $x$。
- 在箭头上的作用：$P⟨f, g⟩ = F(g)$，即只考虑第二个箭头 $g: y \to z$。

### 余极限的定义与余楔形图

对于这样的平凡泛函，我们可以构造它的余极限。考虑以下余楔形图：

$$
F(x) \xrightarrow{F(f)} F(y) \\
F(x) \xrightarrow{id} F(x)
$$

这个图表中的每个箭头 $F(f)$ 和恒等箭头 $id_{F(x)}$ 形成了一个余楔条件。我们可以通过对所有对象 $x$ 取余极限，将这个图表缩小为一个 **余锥形图 (co-cone diagram)**，其中的箭头构成余极限的锥体。

在这种情况下，我们得到了一个简化的余极限公式：

$$
\int_x F(x) = \text{colim } F
$$

这意味着通过余极限的构造方式，我们可以将余极限的结果理解为该函子的余极限。

### 从矩阵的例子理解余极限

为了更直观地理解余极限的概念，可以考虑离散范畴中泛函对应于一个矩阵的情况。在这种情况下，余极限的作用可以类比为矩阵对角线元素的和（余并集）。

设想我们有一个矩阵，其中的每一行都是函子 $F$ 作用于不同对象 $x$ 的结果。对于一个离散范畴，余极限对应于矩阵的对角线元素的和：

$$
\begin{pmatrix}
  F(a) & F(b) & F(c) & \dots \\
  F(a) & F(b) & F(c) & \dots \\
  F(a) & F(b) & F(c) & \dots \\
  \dots & \dots & \dots & \dots
\end{pmatrix}
$$

在这种矩阵表示中，每行都是相同的向量 $F(x)$，余极限即为对角线元素的和。

### 余极限的推广

对于非离散范畴，余极限的计算要更复杂一些，但本质上是对不同对象和态射上的泛函进行合并操作。余极限推广了矩阵对角线和的概念，允许我们在更复杂的范畴中进行类似的运算。

### 总结

将余极限 (colimit) 视为余极限 (coend) 提供了一种更广泛的理解方式。在离散范畴中，余极限可以被类比为矩阵的对角线元素之和。在非离散范畴中，余极限对应于泛函在整个范畴上的合并操作。通过余极限的构造，我们可以将对象和态射的组合归纳为一个统一的结构，从而揭示了余极限的通用性和实用性。

### -------------------------

### 17.3 Ends（极限）

在范畴论中，**极限 (End)** 是余极限 (Coend) 的对偶概念，就像余极限推广了伴随态射的对角元素之和，极限推广了 **乘积** 的概念。乘积通过其投影定义，而极限也是通过类似的方式定义的。

#### 极限的基本定义

极限可以理解为一种具有一系列投影态射的对象，每个投影对应一个对象。我们可以将极限看作是广义跨越 (span) 的推广。

具体地，对于每个对象 $x$ 和 $y$，我们有投影：

$$
\pi_x : d \to P⟨x, x⟩
$$

而投影之间需要满足一定的 **契条件 (wedge condition)**。契条件与余契 (co-wedge) 相对，是极限定义的核心条件。

#### 契条件 (Wedge Condition)

考虑每一个态射 $f: x \to y$，契条件要求如下图的交换：

$$
P⟨f, \text{id}_y⟩ \circ \pi_y = P⟨\text{id}_x, f⟩ \circ \pi_x
$$

这意味着，我们在 $P$ 上的结构可以通过 $f$ 从 $x$ 到 $y$ 传播，而投影 $\pi_x$ 和 $\pi_y$ 的组合方式使得这个传播保持一致。

#### 极限的定义

**极限 (end)** 是满足 **普遍性质 (universal property)** 的契结构。我们用积分符号表示极限，积分符号下方标注积分变量：

$$
\int_x P⟨x, x⟩
$$

普遍性质表明，极限对象 $e$ 是所有具有契条件的对象中最优的。具体来说，极限是一个具备一系列投影 $\pi_x$ 的对象，这些投影满足：

$$
\pi_a : \left( \int_x P⟨x, x⟩ \right) \to P⟨a, a⟩
$$

并且极限是满足契条件的对象中具有普遍性的对象。对于任何其他满足契条件的对象 $d$，如果其带有满足契条件的态射族 $g_x$，那么存在一个唯一的态射 $h: d \to \int_x P⟨x, x⟩$ 使得所有 $g_x$ 都可以通过 $h$ 因式分解为 $\pi_x$：

$$
g_x = \pi_x \circ h
$$

#### 极限的图示

可以用以下图来表示极限的普遍性：

$$
d \xrightarrow{h} \int_x P⟨x, x⟩ \xrightarrow{\pi_x} P⟨x, x⟩
$$

同时，对于每个态射 $f: x \to y$，契条件继续要求：

$$
P⟨\text{id}_x, f⟩ \circ \pi_x = \pi_y \circ P⟨f, \text{id}_y⟩
$$

#### 极限的普遍性

极限可以看作是 $(e, \pi)$ 的配对，其中 $e = \int_x P⟨x, x⟩$ 是极限对象，$\pi$ 是一个从 $\Delta_d \to e$ 的超自然变换 (extranatural transformation)，并且它在所有此类配对中具有普遍性。

契条件实际上是超自然性条件的特例。在很多具体的范畴中，例如集合范畴 (Set)，极限可以通过对所有对象 $x$ 的巨大乘积构造，然后剪除不满足契条件的元组。

#### Haskell 中的极限实现

在 Haskell 中，我们可以通过多态性 (parametricity) 来定义极限。具体来说，参数化函数自动满足契条件，因此在 Haskell 中的极限定义简化为：

```haskell
type End p = forall x. p x x
```

这意味着 **End** 类型是对于所有类型 $x$，$p x x$ 的值。Haskell 中的 **End** 实现没有展示出它是 **Coend** 的对偶，因为 Haskell 缺乏存在类型 (existential types) 的内置语法。如果 Haskell 支持存在类型，我们可以定义 **Coend** 为：

```haskell
type Coend p = exists x. p x x
```

**Coend** 和 **End** 之间的存在/普遍性对偶关系意味着构造 **Coend** 比较容易——我们只需要选择一个类型 $x$ 并提供一个 $p x x$ 的值；而构造 **End** 则需要为所有类型 $x$ 提供一个 $p x x$ 的值。

#### 极限的直观理解

如果你想象极限是在 Set-范畴中定义的，可以通过构建所有对象 $x$ 的集合 $P⟨x, x⟩$ 的乘积来开始。然后通过契条件剔除不满足要求的元组。最后剩下的元组就是极限对象的投影结果。

#### 总结

- **极限 (End)** 是余极限的对偶，它推广了乘积的概念，通过投影态射定义。
- **契条件 (Wedge condition)** 是极限的核心定义，它要求投影在态射之间的组合满足特定的交换规则。
- 极限具有普遍性，意味着任何满足契条件的对象都可以通过极限对象的态射因式分解。
- 在编程语言中，比如 Haskell，极限可以通过多态函数的定义来实现。

### -------------------------

### Natural Transformations as an End（作为极限的自然变换）

在范畴论中，**自然变换** 是两个函子之间的结构化映射，定义为一系列箭头。对于任意两个函子 $F: \mathcal{B} \to \mathcal{C}$ 和 $G: \mathcal{B} \to \mathcal{C}$，自然变换 $\alpha$ 是一组在 $\mathcal{C}$ 中的箭头 $\alpha_x: F(x) \to G(x)$，这些箭头满足某种一致性条件（自然性条件）。自然变换的集合可以通过 **极限 (End)** 的概念来简洁地定义。

### 自然变换的基本结构

自然变换 $\alpha$ 是从函子 $F$ 到 $G$ 的变换，它由在 $\mathcal{B}$ 的每个对象 $x$ 上的箭头 $\alpha_x: F(x) \to G(x)$ 组成。换句话说，$\alpha$ 是一组箭头，这些箭头将每个 $F(x)$ 映射到对应的 $G(x)$，并且满足对于 $\mathcal{B}$ 中的任何态射 $f: a \to b$，以下图表交换：

$$
F(a) \xrightarrow{\alpha_a} G(a) \\
F(f) \downarrow \quad \quad \downarrow G(f) \\
F(b) \xrightarrow{\alpha_b} G(b)
$$

### 使用极限定义自然变换

自然变换可以通过极限 (end) 的方式来定义。首先，我们将自然变换 $\alpha$ 看作是从每个同态集 $\mathcal{C}(F(x), G(x))$ 中选择一个元素 $\alpha_x$。通过引入极限的概念，$\alpha$ 被定义为：

$$
\int_{x: \mathcal{B}} \mathcal{C}(F(x), G(x))
$$

这个极限意味着我们对所有对象 $x \in \mathcal{B}$ 的同态集 $\mathcal{C}(F(x), G(x))$ 求极限，从而构成了从 $F$ 到 $G$ 的自然变换的集合。

### 契条件与自然性条件

为了验证这个定义，我们需要检查自然性条件。我们将每个 $\alpha_x$ 视为来自 $\mathcal{C}(F(x), G(x))$ 的元素，并且通过契条件来保证自然性。

契条件如下：

$$
F(f) \circ \alpha_a = \alpha_b \circ G(f)
$$

这意味着，给定任意的态射 $f: a \to b$，自然变换的分量 $\alpha_a$ 和 $\alpha_b$ 必须满足这个交换条件。这正是自然性条件的定义，确保了 $F$ 和 $G$ 在范畴 $\mathcal{B}$ 上的一致性。

### 例子：在 Haskell 中的实现

在 Haskell 中，自然变换的定义可以通过多态函数来实现。自然变换的类型被定义为：

```haskell
type Natural f g = forall x. f x -> g x
```

这里，自然变换是一个多态函数，它接受 $f x$ 并返回 $g x$，对于所有类型 $x$ 都成立。这与我们使用极限定义自然变换的方式是一致的：极限中的每个元素实际上就是一个多态函数的分量。

### 极限的普遍性与自然变换

极限的普遍性质告诉我们，对于任何其他满足契条件的箭头族 $g_x$，总是存在一个唯一的箭头 $h$，使得 $g_x = \pi_x \circ h$。这意味着，极限中的任何元素 $\alpha$ 都自动满足自然性条件，因此它是一个自然变换。

### 总结

自然变换的集合可以通过极限 (end) 来定义，具体为：

$$
[ \mathcal{B}, \mathcal{C} ](F, G) \cong \int_{x: \mathcal{B}} \mathcal{C}(F(x), G(x))
$$

- **自然变换** 是两个函子之间的变换，它满足自然性条件，即在范畴 $\mathcal{B}$ 的每个态射 $f: a \to b$ 上，交换条件成立。
- **极限** 提供了定义自然变换的方式。我们通过对同态集合 $\mathcal{C}(F(x), G(x))$ 求极限，从而得到自然变换的集合。
- 在 **Haskell** 中，自然变换被表示为多态函数，它可以看作是对所有类型的统一映射，符合极限定义的要求。

这种使用极限来定义自然变换的方式不仅简洁，还揭示了自然变换和极限之间的深层次联系。

### -------------------------

### Limits as Ends（极限作为余极限）

在范畴论中，**极限 (limit)** 和 **余极限 (colimit)** 是两个重要的概念，它们广泛应用于描述对象在范畴中的某种“汇集”或“合并”结构。正如我们可以将余极限表示为余极限（coend），同样地，我们也可以将极限 (limit) 表示为极限 (end)。这一操作通过对某个泛函的参数化进行归并，可以更简洁地描述极限的结构。

### 极限的定义与普遍锥体

正如余极限可以被视为和的推广，极限可以被看作乘积的推广。极限的定义依赖于其 **普遍锥体 (universal cone)**。设 $F: \mathcal{J} \to \mathcal{C}$ 为一个从索引范畴 $\mathcal{J}$ 到 $\mathcal{C}$ 的函子。极限是一个对象 $d$，配有一系列投影态射 $\pi_x: d \to F(x)$，满足对于任何态射 $f: x \to y$，以下条件成立：

$$
F(f) \circ \pi_x = \pi_y
$$

这个条件描述了投影态射之间的关系，保证了投影在态射之间的组合保持一致性。

### 忽略第一个参数的平凡伴随态射

类似于我们在余极限 (coend) 中通过忽略参数来定义平凡伴随态射，在极限的定义中，我们也可以定义一个 **平凡的伴随态射**：

$$
P⟨x, y⟩ = F(y)
$$

以及在箭头对上的作用：

$$
P⟨f, g⟩ = F(g)
$$

通过这种定义，极限的普遍条件可以重新表述为 **普遍锥体的条件**，即对于任何对象 $d$ 和态射族 $\{g_x: d \to F(x)\}$，存在一个唯一的态射 $h: d \to \lim F$ 使得每个 $g_x$ 都可以分解为 $h$ 和投影态射 $\pi_x$ 的组合：

$$
g_x = \pi_x \circ h
$$

### 使用极限符号表示极限

我们可以通过极限符号 $\int_x F(x)$ 来表示极限：

$$
\int_x F(x) = \lim F
$$

这个符号表明，我们对所有对象 $x$ 通过函子 $F$ 计算的结果进行 **极限 (end)** 操作，从而得到极限对象。

### 例子：极限与乘积

乘积是极限的一种特殊情况。考虑两个对象的乘积，它是从两个对象的范畴 2 到某个范畴的函子的极限。设范畴 2 只有两个对象 $a$ 和 $b$，且只有恒等态射。定义函子 $F: 2 \to \mathcal{C}$，其作用为 $F(a)$ 和 $F(b)$。乘积 $F(a) \times F(b)$ 可以通过极限来定义。

#### 证明乘积可以被定义为余极限

要证明乘积可以被定义为余极限，我们可以利用范畴 2 中没有非恒等态射的性质。由于范畴 2 中只有恒等态射，$F(a)$ 和 $F(b)$ 之间没有箭头连接，这意味着它们的余极限只涉及单独的对象。

通过极限的定义，乘积是对两个对象的函子进行 **极限操作**，其定义等价于余极限的形式：

$$
\lim F = \int_x F(x)
$$

因此，乘积可以被视为两个对象的余极限。我们通过对每个对象应用投影，最终得到极限对象，即乘积。

### 总结

- **极限** 是对乘积的推广，可以通过 **极限 (end)** 的符号 $\int_x F(x)$ 来表示。
- 我们可以通过定义平凡伴随态射，重新构造极限的普遍性条件，并用极限符号描述其结构。
- **乘积** 是极限的一个特殊情况，可以通过对两个对象的余极限来定义。

### -------------------------

### 17.4 Continuity of the Hom-Functor（同态函子的连续性）

在范畴论中，**连续函子 (continuous functor)** 是指那些能保持极限和余极限的函子。换句话说，连续函子在计算极限时具有特殊的性质：无论是在源范畴中先取极限再映射，还是先映射图表再取极限，结果是一样的。同态函子 (hom-functor) 就是这样一个重要的连续函子。

### 连续函子

设 $F: \mathcal{C} \to \mathcal{D}$ 是一个函子。如果对任何索引范畴 $\mathcal{J}$ 和任何从 $\mathcal{J}$ 到 $\mathcal{C}$ 的函子 $G$，$F$ 保持 $G$ 的极限或余极限，则称 $F$ 为 **连续** 或 **共连续 (cocontinuous)**。

这意味着：
- 如果 $\lim G$ 是 $\mathcal{C}$ 中的极限，那么 $F(\lim G) \cong \lim(F \circ G)$。
- 如果 $\text{colim} G$ 是 $\mathcal{C}$ 中的余极限，那么 $F(\text{colim} G) \cong \text{colim}(F \circ G)$。

### 同态函子的连续性

同态函子 $\mathcal{C}(-, a): \mathcal{C}^{\text{op}} \to \text{Set}$ 是一个 **在其第二个参数中连续** 的函子。这意味着，如果 $a$ 是 $\mathcal{C}$ 中的对象，那么：

$$
\mathcal{C}(x, a \times b) \cong \mathcal{C}(x, a) \times \mathcal{C}(x, b)
$$

#### 解释：
- 左侧的表达式 $\mathcal{C}(x, a \times b)$ 表示同态函子作用于乘积 $a \times b$。
- 右侧的表达式 $\mathcal{C}(x, a) \times \mathcal{C}(x, b)$ 是两个同态集合的笛卡尔乘积。

这个公式表示，映射到乘积中的箭头可以通过映射到两个对象的箭头对来定义。通过乘积的 **普遍性质 (universal property)**，这两个集合是同构的。

### 同态函子的共连续性

在同态函子的 **第一个参数** 中，它表现出 **共连续性 (cocontinuity)**。也就是说，它将余极限映射为极限。最简单的余极限是和 (coproduct)，因此我们有：

$$
\mathcal{C}(a + b, x) \cong \mathcal{C}(a, x) \times \mathcal{C}(b, x)
$$

#### 解释：
- 左侧 $\mathcal{C}(a + b, x)$ 表示同态函子作用于和 $a + b$。
- 右侧 $\mathcal{C}(a, x) \times \mathcal{C}(b, x)$ 表示映射对。

这意味着，从和中映射出的箭头可以通过从两个对象映射出的箭头对来定义。通过和的 **普遍性**，这两边也是同构的。

### 同态函子保持极限和余极限

由于同态函子的连续性和共连续性，**同态函子保持极限和余极限**。这意味着，对于极限和余极限的计算，我们可以将积分符号从同态集合中拉出。下面我们来详细分析这两种情况。

#### 极限的映射公式

在极限的情况下，公式为：

$$
\mathcal{D}\left( d, \int_a P⟨a, a⟩ \right) \cong \int_a \mathcal{D}(d, P⟨a, a⟩)
$$

这个公式说明，对于某个对象 $d$ 和一个函数 $P$，从 $d$ 到余极限的映射可以通过每个同态集合 $\mathcal{D}(d, P⟨a, a⟩)$ 的极限来表达。

#### 余极限的映射公式

在余极限的情况下，公式为：

$$
\mathcal{D}\left( \int_a P⟨a, a⟩, d \right) \cong \int_a \mathcal{D}(P⟨a, a⟩, d)
$$

这个公式表明，从余极限到某个对象 $d$ 的映射可以通过对每个同态集合 $\mathcal{D}(P⟨a, a⟩, d)$ 的余极限来表达。

### 总结

- **同态函子的连续性** 表示它在其第二个参数中保持极限，而在其第一个参数中保持余极限。
- 通过极限和余极限的普遍性质，同态函子能够在同态集合之间保持这些结构，这意味着我们可以将积分符号从同态集合中拉出。
- 极限的映射公式和余极限的映射公式展示了如何使用同态函子的连续性和共连续性来简化极限和余极限的计算。

这些性质在范畴论中广泛应用于处理函数空间、范畴之间的映射以及极限和余极限的计算。

### -------------------------

### 17.5 Fubini Rule（富比尼法则）

**富比尼法则 (Fubini's Theorem)** 是微积分中的一个重要结果，它说明在某些条件下，双重积分的顺序可以互换。类似地，在范畴论中，我们可以交换双重极限和双重余极限的顺序，这一结果也被称为富比尼法则。

### 范畴论中的富比尼法则

在范畴论中，富比尼法则适用于具有如下形式的双重极限和余极限：

$$
P: \mathcal{C} \times \mathcal{C}^{\text{op}} \times \mathcal{D} \times \mathcal{D}^{\text{op}} \to \mathcal{E}
$$

对于这样的函子，富比尼法则允许我们在以下表达式中交换极限的顺序：

$$
\int_{c \in \mathcal{C}} \int_{d \in \mathcal{D}} P⟨c, c⟩⟨d, d⟩ \cong \int_{d \in \mathcal{D}} \int_{c \in \mathcal{C}} P⟨c, c⟩⟨d, d⟩
$$

#### 解释：
- 左边的公式表示我们先对 $\mathcal{D}$ 中的对象 $d$ 求极限，然后对 $\mathcal{C}$ 中的对象 $c$ 求极限。
- 右边的公式表示我们先对 $\mathcal{C}$ 中的对象 $c$ 求极限，然后对 $\mathcal{D}$ 中的对象 $d$ 求极限。

富比尼法则表明，只要双重极限存在，这两种顺序的结果是同构的。

### 更简洁的表示

富比尼法则允许我们将双重极限合并为一个单一的极限：

$$
\int_{(c, d) \in \mathcal{C} \times \mathcal{D}} P⟨c, c⟩⟨d, d⟩
$$

在这种表示中，我们将函子 $P$ 重新解释为从 $\mathcal{C} \times \mathcal{D}$ 到 $\mathcal{E}$ 的函子，忽略了它的对偶部分 $(\mathcal{C} \times \mathcal{D})^{\text{op}}$。

### 余极限的富比尼法则

类似地，富比尼法则同样适用于余极限。对于某个函子 $P$，我们有：

$$
\text{colim}_{c \in \mathcal{C}} \text{colim}_{d \in \mathcal{D}} P⟨c, c⟩⟨d, d⟩ \cong \text{colim}_{d \in \mathcal{D}} \text{colim}_{c \in \mathcal{C}} P⟨c, c⟩⟨d, d⟩
$$

这表明我们可以自由地交换余极限的顺序，只要它们存在。

### 富比尼法则的应用

富比尼法则在处理多层极限或余极限时非常有用。它为我们提供了一个简化双重结构的工具，并且可以帮助我们更好地理解复杂的函子组合。例如，计算余极限和极限时，我们可以根据具体的计算顺序来选择最方便的方式，而不必担心顺序的影响。

富比尼法则在处理跨范畴的复合函子时，特别是在涉及 **(co)end** 的情况下，能够有效地简化复杂的极限和余极限计算。

### 总结

- **富比尼法则** 允许我们在双重极限和双重余极限中交换顺序，只要它们存在。
- 双重极限可以被合并为一个单一的极限，双重余极限也可以被合并为一个单一的余极限。
- 这一法则广泛应用于范畴论中的极限和余极限计算，尤其是在多范畴的复杂函子组合中。

这与微积分中的富比尼定理在交换积分顺序方面的作用类似，是范畴论中的一种简化工具。

### -------------------------

### 17.6 Ninja Yoneda Lemma（Ninja 代数引理）

**Yoneda 引理** 是范畴论中最重要的定理之一，它为理解函子及其与同态集的关系提供了深刻的洞见。**Ninja Yoneda 引理** 是 Yoneda 引理的一个简化和推广版本，将自然变换集合作为极限的形式表达，使得在复杂公式中更具可操作性。

### 原始的 Yoneda 引理

**Yoneda 引理** 的经典表述如下：

$$
[\mathcal{C}, \text{Set}](\mathcal{C}(a, -), F) \cong F(a)
$$

这意味着从同态函子 $\mathcal{C}(a, -)$ 到任何函子 $F$ 的自然变换的集合同构于 $F$ 在对象 $a$ 上的值。

- $\mathcal{C}(a, -)$ 是 **同态函子**，它将范畴 $\mathcal{C}$ 中的对象映射为从 $a$ 到这些对象的同态集合。
- $F$ 是从 $\mathcal{C}$ 到 **Set**（集合范畴）的函子。

### 用极限表示 Yoneda 引理

Yoneda 引理可以通过 **极限 (end)** 进行更普遍的表达。考虑函子 $F: \mathcal{C} \to \text{Set}$，我们可以将自然变换的集合表示为以下形式：

$$
\int_{x \in \mathcal{C}} \text{Set}(\mathcal{C}(a, x), F(x)) \cong F(a)
$$

这个公式的直观含义是：我们对所有对象 $x \in \mathcal{C}$ 进行积分操作，并将同态集合 $\text{Set}(\mathcal{C}(a, x), F(x))$ 汇总，结果等价于 $F(a)$。

### 逆变函子的 Ninja Yoneda 引理

对于 **逆变函子 (contravariant functor)** $G$，我们有类似的公式：

$$
\int_{x \in \mathcal{C}} \text{Set}(\mathcal{C}(x, a), G(x)) \cong G(a)
$$

这意味着我们可以对逆变函子执行类似的操作：对所有对象 $x \in \mathcal{C}$ 进行积分，并且从 $\mathcal{C}(x, a)$ 到 $G(x)$ 的同态集构成的极限等价于 $G(a)$ 的值。

### Ninja 共代数引理 (Co-Yoneda Lemma)

Ninja 版本的 Yoneda 引理不仅适用于极限，还适用于 **余极限 (coend)**。对于协变函子 $F$，共代数引理可以表示为：

$$
\int_{x \in \mathcal{C}} \mathcal{C}(x, a) F(x) \cong F(a)
$$

同样地，对于逆变函子 $G$，我们有：

$$
\int_{x \in \mathcal{C}} \mathcal{C}(a, x) G(x) \cong G(a)
$$

这些公式展示了如何将余极限应用于同态集，从而得到函子在对象 $a$ 上的值。

### Ninja Yoneda 引理的物理类比

物理学家可能会注意到，这些公式与积分中的 **狄拉克 $\delta$ 函数** 有相似性。在某些情境下，狄拉克 $\delta$ 函数用于表达函数的“选择性”，类似于伴随态射中的“分布”性质。也正因如此，伴随态射有时被称为 **分布器 (distributors)**，因为它们在范畴论中的作用类似于分布在函数空间中的作用。

### 证明共代数引理

证明共代数引理的思路依赖于同态函子的余连续性和 Yoneda 引理的推论。具体来说，关键步骤如下：

1. **应用同态函子的余连续性**：使用同态函子的余连续性，可以将积分符号提取出来，将余极限替换为极限。
   
   $$
   \int_{x \in \mathcal{C}} \text{Set}(\mathcal{C}(x, a), F(x), S) \cong \int_{x \in \mathcal{C}} \text{Set}(\mathcal{C}(x, a), S F(x))
   $$

2. **柯里化处理**：由于集合范畴是笛卡尔闭的，我们可以将积分进行柯里化操作，得到：

   $$
   \int_{x \in \mathcal{C}} \text{Set}(\mathcal{C}(x, a), S F(x)) \cong \text{Set}(F(a), S)
   $$

3. **使用 Yoneda 引理进行积分**：我们可以使用 Yoneda 引理“对 $x$ 进行积分”，并且将 $x$ 替换为 $a$，最终得到：

   $$
   \int_{x \in \mathcal{C}} \mathcal{C}(x, a) F(x) \cong F(a)
   $$

这个证明利用了 Yoneda 引理的自然性条件，即当我们考虑从 $a$ 映射到其他对象时，这些映射的集合通过某种同构性可以简化为 $F(a)$。

### 总结

- **Ninja Yoneda 引理** 是 Yoneda 引理的推广形式，使用 **极限 (end)** 和 **余极限 (coend)** 来表示自然变换集。
- 对于协变函子和逆变函子，我们可以分别使用不同的版本来表述。
- 物理学中的狄拉克 $\delta$ 函数与伴随态射有类似的行为，这种直觉帮助我们更好地理解 Yoneda 引理。
- 通过同态函子的余连续性和 Yoneda 引理的推论，我们可以证明 **共代数引理**，其过程依赖于柯里化和余极限的性质。

### -------------------------

### Yoneda Lemma in Haskell（Haskell 中的代数引理）

在 Haskell 中，我们可以通过类型构造器和多态函数来实现 **Yoneda 引理**。它描述了两个协变函子 $F$ 和 $\mathcal{C}(a, -)$ 之间的自然变换如何同构于 $F(a)$。同样的思想适用于逆变函子，通过 **Co-Yoneda 引理** 来描述逆变函子中的自然变换。这些定理可以通过 Haskell 类型系统中的多态性和高阶函数来表示。

### Yoneda 引理的 Haskell 实现

首先，我们定义一个类型构造器 `Yo`，它将接收一个函子 `f` 和一个类型 `a`，并生成一个在类型 `x` 上逆变、在类型 `y` 上协变的伴随态射：

```haskell
data Yo f a x y = Yo ((a -> x) -> f y)
```

这里，`Yo f a` 表示一种转换，它接受一个从 `a -> x` 的函数，并将其映射到函子 `f y` 上。

#### Yoneda 引理的同构实现

Yoneda 引理表明，**End (Yo f a)** （伴随态射下的极限）和 **f a**（通过对 `a` 应用函子 `f`）是同构的。我们可以通过以下两个函数来实现这种同构：

1. **`yoneda` 函数**：将伴随态射中的极限转换为函子 `f a` 的值。

```haskell
yoneda :: Functor f => End (Yo f a) -> f a
yoneda (Yo g) = g id
```

这个函数接收一个 `Yo f a` 形式的极限，并应用恒等函数 `id` 来将其映射为 `f a`。

2. **`yoneda_1` 函数**：将函子 `f a` 转换为 `Yo f a` 形式的极限。

```haskell
yoneda_1 :: Functor f => f a -> End (Yo f a)
yoneda_1 fa = Yo (\h -> fmap h fa)
```

这里，`yoneda_1` 接收一个类型为 `f a` 的值，通过 `fmap` 将 `a -> x` 的函数作用在 `fa` 上，构造出 `Yo f a` 的值。

### Co-Yoneda 引理的 Haskell 实现

类似地，**Co-Yoneda 引理** 适用于逆变函子。我们定义 `CoY` 类型构造器，它接受一个逆变的 `x -> a` 函数和一个函子 `f y`：

```haskell
data CoY f a x y = CoY (x -> a) (f y)
```

#### Co-Yoneda 引理的同构实现

1. **`coyoneda` 函数**：将 `Coend (CoY f a)` 形式的余极限转换为 `f a`。

```haskell
coyoneda :: Functor f => Coend (CoY f a) -> f a
coyoneda (Coend (CoY g fa)) = fmap g fa
```

这个函数表示如果我们有一个 `x -> a` 的函数 `g` 和一个函子 `f x` 的值 `fa`，我们可以通过 `fmap` 将 `g` 应用到 `fa` 上，得到 `f a`。

2. **`coyoneda_1` 函数**：将函子 `f a` 转换为 `Coend (CoY f a)`。

```haskell
coyoneda_1 :: Functor f => f a -> Coend (CoY f a)
coyoneda_1 fa = Coend (CoY id fa)
```

这个函数通过将 `id` 和 `fa` 注入到 `CoY` 中来创建一个余极限 `Coend`。

### 总结

- **Yoneda 引理** 和 **Co-Yoneda 引理** 可以通过 Haskell 的多态函数和类型系统来表示。
- 在 Yoneda 引理中，我们定义了一个协变伴随态射 `Yo f a`，并且证明了其极限与 `f a` 之间的同构。
- 在 Co-Yoneda 引理中，我们定义了一个逆变伴随态射 `CoY f a`，并证明了其余极限与 `f a` 之间的同构。
- 通过 `yoneda` 和 `yoneda_1`，我们可以在这两种表示之间进行转换，类似地，`coyoneda` 和 `coyoneda_1` 用于余极限的转换。


### -------------------------

### 17.7 Day Convolution（Day 卷积）

**Day 卷积** 是范畴论中的一个重要概念，它类似于电气工程师熟悉的信号卷积。在范畴论中，Day 卷积可以用于将两个函子组合成一个新的函子。它可以看作是在范畴中定义的一种“函子的卷积”，从而为函子范畴引入单胚结构 (monoidal structure)。

### Day 卷积的定义

在范畴论中，Day 卷积的定义可以通过余极限来理解。给定两个 Set-值函子 $F$ 和 $G$，Day 卷积 $(F ⋆ G)$ 是如下形式的：

$$
(F ⋆ G)(x) = \int_{a,b} \mathcal{C}(a \otimes b, x) \cdot F(a) \cdot G(b)
$$

- 这里的 $\otimes$ 是一个在范畴 $\mathcal{C}$ 上的 **张量积 (tensor product)**。
- $\mathcal{C}(a \otimes b, x)$ 是从 $a \otimes b$ 到 $x$ 的同态集。
- 余极限表示我们在所有对象 $a$ 和 $b$ 上进行汇总操作，类似于积分。

### 与电气工程中的卷积类比

电气工程中的卷积是通过移位和相乘两个信号来定义的，形式为：

$$
(f ⋆ g)(x) = \int f(y)g(x - y) dy
$$

Day 卷积的思想类似，但在范畴论中，我们没有对象的“减法”运算。因此，我们使用同态函子 $\mathcal{C}(a \otimes b, x)$ 来描述这种关系，类似于使用狄拉克 $\delta$ 函数强制满足 $a + b = x$ 的条件。

### Day 卷积的性质

1. **关联性 (Associativity)**：Day 卷积是关联的，即对于任意函子 $F$, $G$, $H$，它们的 Day 卷积满足 $(F ⋆ (G ⋆ H)) \cong ((F ⋆ G) ⋆ H)$。
   
2. **单位对象 (Unit Object)**：对于任意函子 $G$，$C(I, -)$ 与 $G$ 的 Day 卷积满足：

   $$
   (C(I, -) ⋆ G)(x) \cong G(x)
   $$

   这里，$I$ 是范畴 $\mathcal{C}$ 中的单位对象，$C(I, -)$ 是 Yoneda 函子。

### 在 Haskell 中的实现

在 Haskell 中，基于 **笛卡尔乘积** 的 Day 卷积可以使用存在类型来定义。我们通过定义一个数据类型 `Day` 来表示 Day 卷积：

```haskell
data Day f g x where
  Day :: ((a, b) -> x) -> f a -> g b -> Day f g x
```

这里，`Day f g x` 表示通过将两个函子 `f` 和 `g` 组合为一个函子 `Day f g`，并提供一个函数 `((a, b) -> x)` 来组合两个值 `a` 和 `b` 成为一个新的值 `x`。

#### Functor 实例

我们可以为 `Day f g` 定义一个 Functor 实例，表示如何将函数应用于 `Day` 中的值。

```haskell
instance (Functor f, Functor g) => Functor (Day f g) where
  fmap h (Day f fa gb) = Day (h . f) (fmap id fa) (fmap id gb)
```

- `fmap` 将函数 `h` 应用于 `Day f g x` 中的函数 `f`，并保持 `fa` 和 `gb` 不变。

#### 关联器实现

我们还可以为 Day 卷积定义一个关联器 (associator)，它将 `Day f (Day g h)` 形式转换为 `Day (Day f g) h` 形式：

```haskell
assoc :: Day f (Day g h) x -> Day (Day f g) h x
assoc (Day f fa (Day g gb hc)) = Day ($a, (b, c)) -> f (a, g (b, c))) (Day id fa gb) hc
```

- 这里，我们将 `Day f (Day g h)` 中的嵌套结构解开，通过关联性转换为 `Day (Day f g) h` 的形式。

### 总结

- **Day 卷积** 在范畴论中为 Set-值函子引入了类似张量积的单胚结构。它通过同态集 $\mathcal{C}(a \otimes b, x)$ 定义了一个函子的卷积，类似于电气工程中的卷积。
- 在 Haskell 中，Day 卷积可以通过定义存在类型来实现，并可以为其定义 Functor 实例和关联器。
- Day 卷积是关联的，并且具有单位对象的性质，可以为函子范畴提供丰富的结构。
- ### -------------------

### ----------------

### Applicative Functors as Monoids（作为单胚的应用函子）

应用函子（Applicative Functors）作为 **松弛单胚函子** (lax monoidal functors) 是一个重要的概念。就像 **单子** 可以被看作是范畴中的单胚一样，应用函子也可以看作是在范畴中的单胚结构。这一观点为理解应用函子的行为提供了一个范畴论的框架。

### 单胚与应用函子

在范畴论中，**单胚** 是一个范畴中的对象，并且它带有 **单位 (unit)** 和 **乘法 (multiplication)** 的自然变换。应用函子的结构可以类比为单胚结构。我们在 **[𝒞, Set]** 中考虑共预层范畴，在这个范畴中，通过 **Day 卷积**，应用函子展示出单胚的结构。

1. **Day 卷积**：对于函子 $F$ 和 $G$，它们的 Day 卷积定义为：
   $$
   (F ⋆ G)(x) = \int_{a,b} \mathcal{C}(a \otimes b, x) F(a) G(b)
   $$

2. **单位对象**：在笛卡尔闭范畴中，单位对象是终对象 $1$，即 $\mathcal{C}(1, a) \cong a$，而单位在 $a$ 处的分量是：
   $$
   \eta_a : a \to F(a)
   $$
   这正是 **`pure`** 函子在 Haskell 中的作用：
   ```haskell
   pure :: a -> f a
   ```

3. **乘法自然变换**：对应于 **`(<*>)`** 运算符，它可以用 Day 卷积中的自然变换表示为：
   $$
   \mu : F ⋆ F \to F
   $$

### 通过 Day 卷积推导应用函子的性质

我们可以从定义的 Day 卷积出发，推导出应用函子中自然变换的集合：

1. 我们首先考虑自然变换 $\mu$ 的集合：
   $$
   \mu \in \int_x \text{Set}((F ⋆ F)(x), F(x))
   $$

2. 代入 Day 卷积的定义，我们得到：
   $$
   \int_x \text{Set}\left( \int_{a,b} \mathcal{C}(a \otimes b, x) F(a) F(b), F(x) \right)
   $$

3. 通过 **同态函子的余连续性**，我们可以将余极限提取出来：
   $$
   \int_{x, a, b} \text{Set}\left( \mathcal{C}(a \otimes b, x) F(a) F(b), F(x) \right)
   $$

4. 我们可以在 Set 中使用 **柯里化** 将其进一步简化为：
   $$
   \int_{x, a, b} \text{Set}\left( \mathcal{C}(a \otimes b, x), \text{Set}(F(a) F(b), F(x)) \right)
   $$

5. 最后，通过 **Yoneda 引理**，我们可以对 $x$ 进行积分，得到：
   $$
   \int_{a, b} \text{Set}(F(a) F(b), F(a \otimes b))
   $$

这个结果展示了应用函子 $F$ 的结构：它的行为类似于一个单胚函子，并且乘法 $\mu$ 的自然变换描述了如何从两个 $F(a)$ 和 $F(b)$ 的值生成一个 $F(a \otimes b)$ 的值。这对应于 Haskell 中的 `(<*>)` 操作符，或更一般地说是 **`(>*<)`** 运算符：

```haskell
(>*<) :: f a -> f b -> f (a, b)
```

### 总结

- 应用函子可以被理解为在 **[𝒞, Set]** 范畴中带有 Day 卷积结构的 **单胚**。它包含两个自然变换：`pure` 和 `(<*>)`，分别对应于单位和乘法。
- 通过 Day 卷积的定义，我们可以推导出应用函子中的自然变换集合，并利用 **Yoneda 引理** 得到它们的具体形式。
- 应用函子的组合运算符 `(>*<)` 表示如何从两个函子值组合成一个新的函子值，在 Haskell 中，这通常通过 `(<*>)` 或 `pure` 实现。



### -----------------



### Free Applicatives（自由应用函子）

**自由应用函子 (Free Applicative Functors)** 是在范畴论的背景下定义的，它们是具有最小结构的应用函子，类似于自由单子是最小的单子。自由应用函子是范畴中的 **自由单胚**，通过 **Day 卷积** 结构定义。我们可以通过初始代数（即最小不动点）来构造自由应用函子，类似于我们构造自由单子的方法。

### 构造自由应用函子

在构造自由应用函子时，我们需要找到一个类似于 **列表函子** 的递归结构。列表函子通常定义为：

$$
\Phi_a x = 1 + a \otimes x
$$

在自由应用函子的构造中，$\Phi_F G$ 定义为：

$$
\Phi_F G = \mathcal{C}(I, *) + F ⋆ G
$$

其中 $⋆$ 表示 **Day 卷积**，而 $+$ 表示函子的选择。这个定义表明，自由应用函子是一个将两个函子组合在一起的结构。

### 不动点公式

自由应用函子是上述公式的 **不动点**，它通过以下递归公式定义：

$$
A_F \cong \mathcal{C}(I, *) + F ⋆ A_F
$$

这意味着 $A_F$ 是一个包含基本元素 $\mathcal{C}(I, *)$ 和通过 Day 卷积组合的结构的函子。

### 在 Haskell 中的表示

在 Haskell 中，我们可以将自由应用函子的递归公式翻译为以下数据类型 `FreeA`：

```haskell
data FreeA f x where
  DoneA :: x -> FreeA f x
  MoreA :: ((a, b) -> x) -> f a -> FreeA f b -> FreeA f x
```

- **`DoneA`**：对应于 $A_F$ 中的单位对象 $\mathcal{C}(I, *)$。它表示递归的终止，即当我们到达一个基本值 `x` 时停止。
- **`MoreA`**：对应于通过 Day 卷积组合的结构 $F ⋆ A_F$。它表示通过一个函数 `((a, b) -> x)` 组合函子 `f a` 和递归结构 `FreeA f b`。

#### Day 卷积的定义内联

我们可以将 Day 卷积定义内联化表示为：

```haskell
data Day f g x where
  Day :: ((a, b) -> x) -> f a -> g b -> Day f g x
```

`Day` 表示通过一个函数 `((a, b) -> x)` 组合两个函子 `f a` 和 `g b`。

### Monoidal 实例

为了展示 `FreeA f` 是一个应用函子，我们可以为它定义 **Monoidal 实例**。Monoidal 实例需要实现 `unit` 和 `(*>*)` 操作符，类似于我们在列表上的连接操作。`FreeA` 是列表的泛化，它可以表示为：

```haskell
class Monoidal f where
  unit :: f ()
  (>*<) :: f a -> f b -> f (a, b)
```

#### Monoidal 实例的实现

1. **`unit`**：在自由应用函子中，`unit` 是 `DoneA ()`。
2. **`(>*<)`**：我们通过递归连接两个自由应用函子的结构：

```haskell
instance Functor f => Monoidal (FreeA f) where
  unit = DoneA ()
  (DoneA x) >*< fry = fmap (x,) fry
  (MoreA abx fa frb) >*< fry = MoreA (reassoc abx) fa (frb >*< fry)
```

- 当我们遇到 `DoneA x`，我们简单地将其与另一个函子 `fry` 结合，并将 `x` 与每个元素配对。
- 当我们遇到 `MoreA abx fa frb`，我们递归调用 `(*>*)` 以将尾部 `frb` 与 `fry` 连接，并通过 `reassoc` 函数重新关联这些对。

`reassoc` 函数定义如下，用于调整两个配对的顺序：

```haskell
reassoc :: ((a, b) -> x) -> (a, (b, y)) -> (x, y)
reassoc abx (a, (b, y)) = (abx (a, b), y)
```

### Applicative 实例

在有了 Monoidal 实例后，我们可以很容易地为 `FreeA f` 定义 **Applicative 实例**：

```haskell
instance Functor f => Applicative (FreeA f) where
  pure a = DoneA a
  ff <*> fx = fmap app (ff >*< fx)
```

- **`pure`**：对应于 `DoneA` 构造函数，将一个值 `a` 包装为一个自由应用函子。
- **`(<*>)`**：我们通过将两个自由应用函子组合在一起，并使用 `fmap` 应用函数来实现 `(<*>)`。`app` 是将函数与值配对应用的函数：

```haskell
app :: (a -> b, a) -> b
app (f, a) = f a
```

### 练习：为 FreeA 定义 Functor 实例

我们可以进一步为 `FreeA f` 定义 **Functor 实例**：

```haskell
instance Functor f => Functor (FreeA f) where
  fmap f (DoneA x) = DoneA (f x)
  fmap f (MoreA abx fa frb) = MoreA ($a, b) -> f (abx (a, b))) fa (fmap f frb)
```

这个 `Functor` 实例通过递归遍历 `FreeA` 的结构，将函数 `f` 应用于 `DoneA` 或 `MoreA` 中的值。

### 总结

- **自由应用函子** 是通过递归结构构造的应用函子，它可以表示为 Day 卷积下的最小不动点。
- 在 Haskell 中，自由应用函子的定义类似于列表的泛化，它允许我们通过递归结构组合两个函子。
- **Monoidal 实例** 和 **Applicative 实例** 可以通过 `DoneA` 和 `MoreA` 构造来定义，并且可以使用递归和配对来实现。

### --------------------

### 17.8 伴随态射的双范畴（The Bicategory of Profunctors）

**伴随态射 (Profunctors)** 是范畴论中的一种重要概念，用于连接两个范畴。一个 **双范畴 (bicategory)** 是一个扩展的范畴，其中范畴定律（如结合律和单位律）只能在同构意义上成立，而非严格满足。这意味着我们允许范畴中的态射（1-态射）之间通过 2-态射连接，而 2-态射本质上是 1-态射之间的同构。

在这一章中，我们讨论了伴随态射的双范畴，即伴随态射作为双范畴中的 1-态射，自然变换作为 2-态射。

#### 伴随态射组合中的结合律

我们已经知道如何通过 **余极限 (coends)** 来组合两个伴随态射。在组合伴随态射时，我们发现组合的范畴定律不能严格满足，而是只能在 **同构意义上** 成立。具体来看，伴随态射的组合遵循 **结合律 (associativity)**，但只是 **同构**，而非严格等式。

例如，考虑伴随态射组合的结合律：

$$
((P ⋄ Q) ⋄ R)\langle s, t \rangle = \int_b \left( \int_a P\langle s, a \rangle Q\langle a, b \rangle \right) R\langle b, t \rangle
$$

与

$$
(P ⋄ (Q ⋄ R))\langle s, t \rangle = \int_a P\langle s, a \rangle \left( \int_b Q\langle a, b \rangle R\langle b, t \rangle \right)
$$

我们通过 **富比尼定理 (Fubini theorem)** 允许我们交换余极限的顺序，这两者是 **同构** 的，但并不是严格的等式。

#### 恒等伴随态射

在这个双范畴中，**恒等伴随态射** 是同态函子 $\mathcal{C}(*, =)$，其中占位符号 `*` 和 `=` 表示两个任意对象。例如，对于伴随态射 $P$：

$$
(\mathcal{C}(*, =) ⋄ P)\langle s, t \rangle = \int_a \mathcal{C}(s, a) P\langle a, t \rangle \cong P\langle s, t \rangle
$$

这个结果依赖于 **Ninja 共代数引理 (Ninja co-Yoneda lemma)**，它表明两个表达式是同构的。

#### Profunctor 双范畴的定义

我们可以通过放松范畴定律的要求，允许它们在同构意义上成立，从而构造一个双范畴。具体来说，**Prof** 是一个双范畴，其对象是范畴，伴随态射是 1-态射，自然变换是 2-态射。

- **1-态射**：伴随态射 $P: \mathcal{C}^{op} \times \mathcal{D} \to \text{Set}$。
- **2-态射**：伴随态射之间的自然变换。

在这个双范畴中，伴随态射的组合满足同构的结合律，而恒等伴随态射是同态函子。

#### 伴随态射之间的自然变换

两个伴随态射 $P$ 和 $Q$ 之间的 **自然变换 (natural transformation)** 可以表示为一个由 $\mathcal{C} \times \mathcal{D}$ 中的对象参数化的函数族 $\alpha \langle a, b \rangle$。这些函数族必须满足自然性条件，即对于任意箭头对 $\langle f: s \to a, g: b \to t \rangle$，以下图表交换：

$$
P\langle a, b \rangle \to Q\langle a, b \rangle
$$
$$
P\langle s, t \rangle \to Q\langle s, t \rangle
$$

$$
\alpha \langle a, b \rangle \quad P\langle f, g \rangle \quad Q\langle f, g \rangle \quad \alpha \langle s, t \rangle
$$

这意味着自然变换 $\alpha \langle a, b \rangle$ 是在同态集之间的函数，它们必须在两边保持自然性。

### 结论

- **双范畴 Prof** 的对象是范畴，1-态射是伴随态射，2-态射是自然变换。
- 伴随态射的组合满足同构意义上的结合律。
- 恒等伴随态射是同态函子。
- 伴随态射之间的自然变换需要满足一定的自然性条件，这确保了态射之间的变换在两个范畴中保持一致。

这个双范畴的结构为理解伴随态射之间的复杂关系提供了框架。

### ------------------

### 双范畴中的单子（Monads in a Bicategory）

在范畴论中，**单子 (monads)** 是一种可以在任意双范畴 (bicategory) 中定义的结构。我们之前讨论了 2-范畴 Cat，它由范畴、函子和自然变换组成。在 2-范畴的框架下，单子可以通过特定的态射 (1-态射) 和变换 (2-态射) 的组合来定义。

#### 双范畴中的结构

在双范畴中，态射分为不同的层次：
- **0-态射 (0-cells)** 是双范畴中的对象。例如，在 Cat 中的 0-态射是范畴 $\mathcal{C}$。
- **1-态射 (1-cells)** 是从一个对象到另一个对象的箭头。例如，在 Cat 中，1-态射是从一个范畴到另一个范畴的函子 $F: \mathcal{C} \to \mathcal{D}$。
- **2-态射 (2-cells)** 是 1-态射之间的箭头，它们通常表示自然变换。例如，在 Cat 中，2-态射是从一个函子到另一个函子的自然变换。

在这种框架下，我们可以定义 **端 1-态射 (endo-1-cells)**，即一个从范畴 $\mathcal{C}$ 到它自身的函子 $F: \mathcal{C} \to \mathcal{C}$。这些端 1-态射在 2-范畴中形成一个结构化的范畴，即 **函子范畴** $[\mathcal{C}, \mathcal{C}]$。

#### 单胚结构和端函子的组合

在函子范畴 $[\mathcal{C}, \mathcal{C}]$ 中，我们可以将端函子 $F$ 视为 1-态射。这个范畴自动配备了一个 **单胚结构**，其张量积定义为 1-态射（即函子）的组合。简单来说：
- 函子的组合 $F \circ G$ 定义了 1-态射之间的组合。
- 单胚的单位对象是 **恒等函子** $I: \mathcal{C} \to \mathcal{C}$。

在这个结构中，所有的 1-态射都可以通过函子的组合来构造。

#### 定义单子

在双范畴中，单子是由一个端 1-态射 $F$ 及其相关的 2-态射构成的。如果我们有一个 1-态射 $F: \mathcal{C} \to \mathcal{C}$，我们可以将其与自身组合，即构造 $F \circ F$。若我们能找到以下两个 **2-态射**：

1. **乘法** $μ : F \circ F \to F$，表示将两个 $F$ 组合成一个 $F$。
2. **单位** $η : I \to F$，表示从恒等函子 $I$ 到 $F$ 的态射。

这两个 2-态射必须满足类似于单子结合性和单位律的条件，即：
- **结合律**：$μ \circ (μ \circ F) = μ \circ (F \circ μ)$，确保组合函子 $F \circ F \circ F$ 的关联性。
- **单位律**：$μ \circ (η \circ F) = id_F = μ \circ (F \circ η)$，确保单位在函子的组合中保持作用。

这些条件确保 $F$ 在双范畴中具有单子的结构。

#### 单子的图示表示

我们可以使用图示表示这些定律。设 $\mathcal{C}$ 是一个双范畴的对象，$F$ 是一个从 $\mathcal{C}$ 到自身的 1-态射。通过以下图示，我们展示了单子的定义：

- **结合律**：
  $$
  \begin{array}{c}
    \mathcal{C} \overset{F}{\longrightarrow} \mathcal{C} \overset{F}{\longrightarrow} \mathcal{C} \overset{F}{\longrightarrow} \mathcal{C} \\
    \text{(F组合F组合F的关联)}
  \end{array}
  $$

- **单位律**：
  $$
  \begin{array}{c}
    \mathcal{C} \overset{I}{\longrightarrow} \mathcal{C} \overset{F}{\longrightarrow} \mathcal{C} \quad \text{(单位和恒等态射)}
  \end{array}
  $$

这些图表展示了 1-态射和 2-态射的组合如何形成单子。

#### 单子的广泛应用

单子不仅在 2-范畴 Cat 中可以定义，它们也可以在任意双范畴中定义。例如，在 **伴随态射双范畴 Prof** 中，单子可以通过伴随态射的组合和自然变换来定义。

#### 总结

- **单子** 可以在双范畴中通过端 1-态射和 2-态射的组合来定义。
- 在 2-范畴 Cat 中，单子是由函子及其组合操作构成的。
- 单子的两个关键 2-态射是 **乘法** $μ : F \circ F \to F$ 和 **单位** $η : I \to F$，它们必须满足结合律和单位律。
- 单子的定义可以推广到任意双范畴，提供了范畴论中统一的结构。

### -----------------------

### 前箭头作为单子（Prearrows as Monads in Prof）

在范畴论的框架下，**Prof** 是一个 **双范畴 (bicategory)**，其中 **伴随态射 (profunctors)** 是双范畴中的 1-态射（1-cells），自然变换是 2-态射（2-cells）。由于 Prof 是一个双范畴，我们可以在其中定义 **单子 (monads)**。

#### 单子在 Prof 中的定义

在 Prof 中，**单子** 是一种特殊的 **端伴随态射 (endo-profunctor)**，即一个自伴随态射 $P : \mathcal{C}^{op} \times \mathcal{C} \to \text{Set}$。我们可以通过 2-态射（自然变换）来定义单子所需的 **乘法 (multiplication)** 和 **单位 (unit)**。这些 2-态射表示伴随态射的组合和映射，满足单子定义中的结合律和单位律。

具体来说，单子由以下两种自然变换构成：
1. **乘法 (μ)**：$P \circ P \to P$，将两个伴随态射组合成一个。
2. **单位 (η)**：$\mathcal{C}(*, =) \to P$，表示从恒等态射到伴随态射 $P$ 的映射。

#### 自然变换作为余极限

我们可以将这些自然变换视为 **余极限 (coends)** 中的元素。例如，乘法自然变换 $\mu$ 可以表示为：

$$
\mu \in \int_{\langle a, b \rangle} \text{Set} \left( \int_x P\langle a, x \rangle P\langle x, b \rangle, P\langle a, b \rangle \right)
$$

通过 **余连续性 (co-continuity)**，这个表达式可以进一步简化为：

$$
\int_{\langle a, b \rangle, x} \text{Set} \left( P\langle a, x \rangle P\langle x, b \rangle, P\langle a, b \rangle \right)
$$

这表示将 $P\langle a, x \rangle$ 和 $P\langle x, b \rangle$ 组合成 $P\langle a, b \rangle$ 的方式。

类似地，**单位自然变换 (η)** 可以表示为：

$$
\eta \in \int_{\langle a, b \rangle} \text{Set} \left( \mathcal{C}(a, b), P\langle a, b \rangle \right)
$$

这表明从同态函子 $\mathcal{C}(a, b)$ 映射到 $P\langle a, b \rangle$ 的方式。

#### Haskell 中的前箭头（PreArrows）

在 Haskell 中，伴随态射单子被称为 **前箭头 (PreArrow)**。前箭头是一种特殊的 **Profunctor**，它提供了组合伴随态射的能力。可以通过以下类定义表示前箭头：

```haskell
class Profunctor p => PreArrow p where
  (>>>) :: p a x -> p x b -> p a b
  arr    :: (a -> b) -> p a b
```

- **`(>>>)`**：这个操作符表示伴随态射的组合，即从 $P\langle a, x \rangle$ 和 $P\langle x, b \rangle$ 组合出 $P\langle a, b \rangle$，与我们定义的 $\mu$ 自然变换类似。
- **`arr`**：这个函数表示将一个普通函数 $a \to b$ 转换为伴随态射 $P\langle a, b \rangle$，与单位自然变换 $\eta$ 类似。

#### 箭头 (Arrow) 与 Tambara 模块

**Arrow** 是 PreArrow 的一个特例，它不仅是一个 PreArrow，还是一个 **Tambara 模块**。Tambara 模块为箭头提供了额外的结构，允许它们与其他结构（如产品）相互作用。

我们将在下一章讨论 Tambara 模块以及它如何扩展箭头的功能。

### 总结

- 在双范畴 **Prof** 中，前箭头 (PreArrows) 作为 **单子** 可以定义，它们是端伴随态射，配备了乘法和单位自然变换。
- 自然变换 $\mu$ 和 $\eta$ 分别对应于伴随态射的组合和从同态函子的映射。
- 在 Haskell 中，前箭头定义为一种 **Profunctor**，提供组合和从普通函数构造伴随态射的功能。
- **Arrow** 是 PreArrow 的一种扩展形式，Tambara 模块为它们提供了更复杂的结构。

### ---------------------

### 17.9 存在透镜（Existential Lens）

**存在透镜 (Existential Lens)** 是一种重要的概念，它允许我们通过箭头（态射）来观察和操作对象的部分结构，而无需直接暴露它们的内部细节。透镜的设计遵循范畴论的核心思想，即：

- **范畴论俱乐部的第一条规则**：**你不谈论对象的内部结构**。在范畴论中，我们关注的是对象之间的箭头（态射），而不是对象的具体内部表示。我们只通过箭头的行为来了解对象。
  
- **范畴论俱乐部的第二条规则**：**如果你必须谈论对象的内部结构，请只使用箭头**。当我们不得不操作对象的一部分时，我们仍然通过态射来间接实现这一点，不暴露对象的具体细节。

#### 透镜的定义

**透镜 (Lens)** 是一种范畴中的态射结构，允许我们聚焦于对象的某个部分，并且通过箭头进行读写操作。具体而言，一个透镜可以看作是对范畴中对象的部分读写访问的封装。

通常，透镜定义为一对箭头：
1. **`get`**：从一个大对象中提取出其某个部分。
2. **`set`**：将新的部分注入到大对象中，返回修改后的大对象。

这种定义本质上符合范畴论的原则，我们不需要直接操作对象的内部数据，而是通过态射来处理对象的部分。

#### 存在透镜的特点

**存在透镜** 是透镜的扩展版本，旨在处理更加通用的情形，即当对象的结构不完全确定或存在多种可能的情况下。存在透镜允许我们处理 **不同类型** 的对象部分，并通过 **态射的存在性** 来实现对这些部分的访问。

存在透镜的核心思想是：
- 不暴露对象的具体类型或实现细节。
- 只依赖于态射的存在性条件来进行读写访问。

存在透镜可以通过下列两种方式理解：

1. **存在类型 (Existential types)**：存在透镜使用存在类型来表示对象内部的一部分。这种方式隐藏了具体的部分类型，但通过态射确保对该部分进行有效操作。
2. **态射的存在性条件**：我们通过存在一个合适的态射来定义对象的部分，而不是直接讨论对象的类型或结构。

#### 在 Haskell 中的存在透镜

在 Haskell 中，透镜可以被定义为一个函数，它将对象的某个部分进行映射。典型的透镜结构如下：

```haskell
data Lens s t a b = Lens { 
  get :: s -> a,
  set :: b -> s -> t
}
```

- **`get`**：从类型为 `s` 的大对象中提取出类型为 `a` 的部分。
- **`set`**：将类型为 `b` 的新值注入到类型为 `s` 的对象中，生成类型为 `t` 的修改后的对象。

**存在透镜** 的实现可以通过使用 **存在类型** 来隐藏部分对象的结构信息。例如，可以通过 GADT (广义代数数据类型) 来实现存在类型的透镜：

```haskell
data ExistentialLens s t where
  ExistLens :: (forall a. Lens s t a a) -> ExistentialLens s t
```

这个定义表明，我们不直接暴露对象的类型 `a`，而是通过泛型的透镜 `Lens s t a a` 来进行操作。

#### 范畴论中的存在透镜

在范畴论的背景下，存在透镜可以解释为某种 **泛函 (profunctor)**。我们通过范畴中的态射来定义对象的部分，而不是直接暴露其结构。这种定义保持了范畴论的抽象性，并允许我们通过箭头处理复杂对象的部分。

透镜可以被视为从一个范畴中的对象 `s` 投影到某个子对象 `a` 的态射，以及一个从 `a` 映射回 `s` 的态射。通过这种方式，透镜可以在更高层次上操作范畴中的对象，而无需涉及其内部细节。

#### 总结

- **存在透镜** 遵循范畴论的核心原则，通过态射来操作对象的部分结构，而不暴露具体的内部实现。
- 它使用 **态射的存在性条件** 或 **存在类型** 来实现对对象部分的读写访问。
- 在 Haskell 中，存在透镜可以通过泛型函数或 GADT 来实现，隐藏对象的具体类型。
- 在范畴论的框架下，存在透镜作为一种 **泛函**，通过态射操作对象的部分，实现范畴中对象的抽象操作。
- ### ---------------

### --------------------

### Haskell 中的存在透镜（Existential Lens in Haskell）

在 Haskell 中，**存在透镜 (Existential Lens)** 提供了一种访问和修改复合对象的部分内容的方式，而不暴露对象的完整结构。透镜的核心思想是，通过两个基本操作 **`get`** 和 **`set`** 来抽象地访问和修改对象的某个部分。

#### 复合对象的定义

当我们说一个对象是**复合的**，意味着它由多个部分组成。我们可以通过 **`get`** 函数从复合对象中提取某个部分，通过 **`set`** 函数替换对象中的该部分。下面是透镜的基本定义：

```haskell
get :: s -> a
set :: s -> a -> s
```

- **`get`**：从整体对象 `s` 中提取部分 `a`。
- **`set`**：用一个新的 `a` 替换对象 `s` 中的部分，返回修改后的对象。

#### 透镜定律（Lens Laws）

透镜定律确保透镜的操作符合直观的行为预期，例如：
1. **`get`/`set` 定律**：从对象中提取部分值，并将该值替换回去，应该不改变对象。
2. **`set`/`get` 定律**：当你设置一个新的部分值时，`get` 应该返回你刚刚设置的那个值。

这些定律帮助我们加强了透镜的概念，它们表明所有的操作都可以通过 **箭头 (态射)** 来实现，符合范畴论的原则。

#### 使用存在类型构建透镜

为了更加通用地表示复合对象的部分和剩余部分，我们可以使用 **存在类型 (existential types)**。存在类型允许我们隐藏部分结构，只暴露我们关心的那部分。

在 Haskell 中，使用存在类型来定义 **存在透镜** 的方式如下：

```haskell
data LensE s a where
  LensE :: (s -> (c, a), (c, a) -> s) -> LensE s a
```

这里，`LensE s a` 表示一个存在透镜，它包含了两个函数：
- 一个将对象 `s` 分解为一个 **剩余部分 `c`** 和 **焦点 `a`** 的函数 `s -> (c, a)`。
- 一个将焦点 `a` 和剩余部分 `c` 重新组合成完整对象 `s` 的函数 `(c, a) -> s`。

这种结构的关键点在于我们不关心 **剩余部分 `c`** 的具体类型。我们只需要知道 `s` 可以分解为 `(c, a)`，并且可以通过组合重新构造 `s`。

#### 从存在透镜推导 `get` 和 `set`

虽然存在透镜隐藏了剩余部分 `c` 的类型，但我们仍然可以通过定义函数 **`toGet`** 和 **`toSet`** 来推导出 `get` 和 `set` 函数：

```haskell
toGet :: LensE s a -> (s -> a)
toGet (LensE (l, _)) = snd . l

toSet :: LensE s a -> (s -> a -> s)
toSet (LensE (l, r)) s a = r (fst (l s), a)
```

- **`toGet`**：通过将 `LensE` 的第一部分（分解函数）应用于 `s`，我们得到一个 `(c, a)` 对。`toGet` 函数提取这个对中的 `a`，即目标部分。
- **`toSet`**：`toSet` 函数首先通过 `l` 函数将 `s` 分解为 `(c, a)`，然后用新值 `a` 和剩余部分 `c` 重新组合成新的 `s`。

这种实现中，虽然我们从未直接操作剩余部分 `c` 的具体类型，但通过存在类型的抽象，我们依然可以完成 `get` 和 `set` 的操作。

#### 无法提取“裸”剩余部分

由于存在类型的性质，我们无法直接提取对象的 **剩余部分** `c`，正如以下无法编译的代码所示：

```haskell
getResidue :: LensE s a -> c
getResidue (LensE (l, _)) = fst . l
```

这个代码无法编译的原因在于，存在类型 `c` 是被隐藏的，我们无法在类型签名中直接使用它。存在类型只允许我们操作和调解透镜的行为，但无法直接获得或暴露具体的剩余部分类型。

#### 总结

- **存在透镜 (Existential Lens)** 是一种允许我们抽象访问和修改复合对象部分内容的工具，它通过隐藏部分内部结构保持了对象的抽象性。
- 使用存在类型，我们可以在不关心具体结构的情况下操作对象的某个部分。
- `get` 和 `set` 可以通过存在透镜推导，而无需暴露剩余部分的具体类型。
- 通过这种方式，存在透镜符合范畴论的原则：只通过箭头（态射）来处理对象的部分，而不暴露其内部细节。

### ------------------

### 范畴论中的存在透镜（Existential Lens in Category Theory）

在范畴论中，**存在透镜 (Existential Lens)** 的定义可以通过 **余极限 (coend)** 来表达，类似于 Haskell 中使用存在类型来隐藏剩余部分。透镜可以看作是操作复合对象（包含多个部分）的箭头（态射），允许我们操作复合对象的某个部分（焦点）而不显露其内部结构。为了表述这个概念，范畴论使用余极限形式化表示这种结构。

#### 透镜的范畴论定义

透镜可以被视为从对象 $s$ 中提取某个部分 $a$，并且可以用一个新的部分 $b$ 替换这个部分，形成一个新的复合对象 $t$。透镜描述的是对象之间的结构关系，而不是它们的具体实现。

在范畴论中，**存在透镜** 的定义形式化为一个余极限表达式，其中剩余部分 $c$ 被隐藏，但它存在于这个结构中。这个余极限可以写为：

$$
\int_c \mathcal{C}(s, c \times a) \times \mathcal{C}(c \times b, t)
$$

这个公式的含义是：
- **$s$** 是整体对象，**$a$** 是从 $s$ 中提取的部分（焦点）。
- **$b$** 是替换后的部分，**$t$** 是替换部分后的新对象。
- **$c$** 是隐藏的剩余部分，通过 $s \to c \times a$ 和 $c \times b \to t$ 的态射来描述复合对象的操作。

#### 类型变化透镜

在范畴论中，我们可以将透镜推广为 **类型变化透镜**，即在操作对象的某个部分时，允许焦点从类型 $a$ 变化为类型 $b$。通过这种推广，透镜可以表示更广泛的结构修改，焦点部分不仅可以被提取出来，还可以被替换为不同类型的部分。

类型变化透镜通过以下公式表示：

$$
\mathcal{L}_{\langle s, t \rangle \langle a, b \rangle} = \int_c \mathcal{C}(s, c \times a) \times \mathcal{C}(c \times b, t)
$$

在这个表达式中：
- **$\langle s, t \rangle$** 表示整体对象对，$s$ 是初始复合对象，$t$ 是修改后的对象。
- **$\langle a, b \rangle$** 表示内部对象对，$a$ 是提取的焦点部分，$b$ 是替换后的新焦点。
- **$c$** 仍然是存在类型，表示对象的剩余部分，它不会显露出来，只是用于辅助对象的分解和重构。

#### 余极限下的伴随态射

在范畴论中，余极限表达式中的结构可以解释为 **伴随态射 (profunctors)** 的对角部分。我们可以看到余极限形式是协变和逆变的组合，这意味着它是一个在部分参数上协变、在部分参数上逆变的伴随态射。

这个结构在数学上可以表示为：

$$
\mathcal{C}(s, y \times a) \times \mathcal{C}(x \times b, t)
$$

这个式子意味着对象 $s$ 通过 $y$ 和 $a$ 的组合映射到对象 $t$，同时从 $x$ 和 $b$ 的组合映射到 $t$。这种组合既在 $y$ 上协变，又在 $x$ 上逆变，形成了一个 **伴随态射** 的结构。

#### 练习 17.9.1 的证明

**练习 17.9.1** 要求我们证明表达式：

$$
\mathcal{C}(s, y \times a) \times \mathcal{C}(x \times b, t)
$$

是一个在 $\langle x, y \rangle$ 上的伴随态射。这意味着我们需要证明它符合伴随态射的定义——即在某个范畴 $\mathcal{C}$ 中，对角形式是协变和逆变的。

证明思路如下：
1. **协变性**：在 $\mathcal{C}(s, y \times a)$ 中，$s$ 是初始对象，$y \times a$ 是复合对象。随着 $y$ 的变化，$y \times a$ 在 $y$ 上协变，意味着它对 $y$ 的变化是保持箭头方向的。
2. **逆变性**：在 $\mathcal{C}(x \times b, t)$ 中，$t$ 是目标对象，$x \times b$ 是复合对象。随着 $x$ 的变化，$x \times b$ 在 $x$ 上逆变，意味着它对 $x$ 的变化反转了箭头方向。

由于这个表达式同时在 $y$ 上协变、在 $x$ 上逆变，它形成了一个 **伴随态射**。

#### 总结

- **存在透镜** 在范畴论中通过 **余极限** 表达，余极限提供了处理对象部分和剩余部分的机制，同时隐藏了对象的剩余部分。
- **类型变化透镜** 是透镜的一种推广，允许操作对象的部分从一种类型变为另一种类型。
- 透镜的结构可以理解为 **伴随态射**，它在对象的某些参数上协变，在其他参数上逆变。

### ---------------------

### 范畴论中的存在透镜（Existential Lens in Category Theory）

**存在透镜 (Existential Lens)** 的概念可以通过范畴论中的 **余极限 (coend)** 来形式化。透镜的目的是在复合对象中操作某个部分（即焦点），而隐藏其他不关心的部分（即剩余部分）。这种操作在范畴论中依赖于对象之间的 **态射 (morphisms)**。

#### 透镜的定义通过余极限表示

在范畴论中，存在透镜可以使用余极限来表示存在类型，具体公式如下：

$$
\int_c \mathcal{C}(s, c \times a) \times \mathcal{C}(c \times a, s)
$$

这个公式的含义是：
- **$s$** 是复合对象的整体。
- **$a$** 是从 $s$ 中提取的焦点部分。
- **$c$** 是存在类型，表示剩余部分。通过从 $s$ 提取 $(c \times a)$，然后使用 $(c \times a)$ 构造回 $s$，我们实现了部分结构的读写操作。

#### 类型变化透镜

透镜不仅可以操作一个固定类型的部分，还可以处理 **类型变化** 的情况。在这种情况下，我们允许焦点从一种类型 $a$ 变化为另一种类型 $b$。这种扩展下的透镜被称为 **类型变化透镜**，其公式如下：

$$
\mathcal{L}_{\langle s, t \rangle \langle a, b \rangle} = \int_c \mathcal{C}(s, c \times a) \times \mathcal{C}(c \times b, t)
$$

在这个公式中：
- **$\langle s, t \rangle$** 表示复合对象的外部结构，其中 $s$ 是原始对象，$t$ 是更新后的对象。
- **$\langle a, b \rangle$** 表示焦点部分的类型变化，$a$ 是原始类型，$b$ 是新的类型。
- **$c$** 是剩余部分，通过余极限进行量化。这个 $c$ 是隐藏的，不需要显式暴露。

这意味着，透镜现在参数化了两对对象：外部对象对 $\langle s, t \rangle$ 和内部对象对 $\langle a, b \rangle$。这使得我们能够从 $s$ 中提取出类型为 $a$ 的部分，并用新的类型 $b$ 替换，从而得到更新后的对象 $t$。

#### 余极限下的伴随态射

我们可以将余极限下的结构理解为 **伴随态射 (profunctors)**。对于透镜来说，它涉及两个主要的态射：
1. **$\mathcal{C}(s, y \times a)$**：这是一个在 $y$ 上 **协变** 的态射，它表示如何从复合对象 $s$ 中提取部分 $a$。
2. **$\mathcal{C}(x \times b, t)$**：这是一个在 $x$ 上 **逆变** 的态射，它表示如何将新的部分 $b$ 重新注入到复合对象 $t$ 中。

所以在余极限下，这两个态射的组合可以写为：

$$
\mathcal{C}(s, y \times a) \times \mathcal{C}(x \times b, t)
$$

这表示我们通过在 $y$ 上协变和在 $x$ 上逆变的两个态射组合，来从 $s$ 提取部分并更新为 $t$。这种结构可以看作是 **伴随态射** 的对角部分。

#### 练习 17.9.1 证明

**练习 17.9.1** 提问要求证明：

$$
\mathcal{C}(s, y \times a) \times \mathcal{C}(x \times b, t)
$$

是一个在 $\langle x, y \rangle$ 上的 **伴随态射**。

为了证明这一点，我们需要表明该表达式是 **协变** 和 **逆变** 的组合形式。具体来说：
1. **协变性**：在 $\mathcal{C}(s, y \times a)$ 中，$y \times a$ 在 $y$ 上是协变的。这意味着，如果我们对 $y$ 施加某个态射（如 $f: y \to z$），这个态射会保持箭头方向，并影响 $y \times a$ 的结果。
2. **逆变性**：在 $\mathcal{C}(x \times b, t)$ 中，$x \times b$ 在 $x$ 上是逆变的。这意味着，如果我们对 $x$ 施加某个态射（如 $g: w \to x$），这个态射会反转箭头方向，从而影响 $x \times b$ 的结果。

因此，这个组合表达式的确是一个在 $\langle x, y \rangle$ 上的 **伴随态射**，其中 $y$ 是协变的，$x$ 是逆变的。

#### 总结

- **存在透镜** 在范畴论中可以通过余极限来定义，表示从复合对象中提取部分并通过箭头操作重新构造对象。
- **类型变化透镜** 扩展了透镜的概念，允许焦点部分从一种类型转换为另一种类型，同时保持剩余部分的隐藏。
- 通过余极限下的表达式，可以将这些操作理解为伴随态射，它们在不同的对象参数上表现出协变或逆变的性质。



### ----------------------------

### Haskell 中的类型变化透镜（Type-changing Lens in Haskell）

**类型变化透镜 (Type-changing Lens)** 是一种更加通用的透镜，它不仅可以从一个复合对象中提取某个部分，还允许替换该部分为不同的类型。在 Haskell 中，我们可以通过 **存在类型** 来定义这样的透镜。

#### 定义类型变化透镜

类型变化透镜的定义如下：

```haskell
data LensE s t a b where
  LensE :: (s -> (c, a)) -> ((c, b) -> t) -> LensE s t a b
```

- **`s`** 是原始复合对象的类型。
- **`t`** 是替换焦点部分后的新复合对象的类型。
- **`a`** 是焦点部分的原始类型。
- **`b`** 是新的焦点类型。
- **`c`** 是剩余部分，它是通过存在类型隐藏的，并且不直接显露给外部。

#### 获取和设置焦点

通过类型变化透镜，我们可以分别定义 **`get`** 和 **`set`** 操作，用于提取焦点部分和替换焦点部分：

```haskell
toGet :: LensE s t a b -> (s -> a)
toGet (LensE l r) = snd . l

toSet :: LensE s t a b -> (s -> b -> t)
toSet (LensE l r) s b = r (fst (l s), b)
```

- **`toGet`**：通过 `l :: s -> (c, a)`，提取原始对象 `s` 中的焦点部分 `a`，即取出对中的第二部分。
- **`toSet`**：通过 `l` 提取出剩余部分 `c`，并使用新焦点 `b` 和剩余部分 `c` 通过 `r :: (c, b) -> t` 重新构造新的复合对象 `t`。

#### 前向和后向传递

在类型变化透镜的定义中，`s -> (c, a)` 和 `(c, b) -> t` 被称为 **前向传递** 和 **后向传递**：
- **前向传递**：通过函数 `l :: s -> (c, a)`，从复合对象 `s` 中提取出焦点部分 `a` 和剩余部分 `c`。
- **后向传递**：通过函数 `r :: (c, b) -> t`，使用剩余部分 `c` 和新的焦点部分 `b` 构造出更新后的对象 `t`。

这种结构可以非常灵活地描述对象的变化过程，特别是在像 **神经网络** 这样的场景中，通过修改焦点部分（例如某一层的权重）来推导出整体的变化。

#### 示例：作用于乘积的透镜

一个简单的示例是作用于 **乘积类型** 的透镜，它可以提取或替换乘积中的某个分量，将另一个分量视为剩余部分。我们可以定义一个专门针对乘积的透镜，如下所示：

```haskell
prodLens :: LensE (c, a) (c, b) a b
prodLens = LensE id id
```

在这个例子中：
- **原始对象** 是一个元组 `(c, a)`，其中 `c` 是剩余部分，`a` 是焦点部分。
- **新对象** 是替换了焦点的元组 `(c, b)`，其中 `b` 是新的焦点类型。

这里，**`id`** 表示恒等函数。因为对象本身就是乘积 `(c, a)` 和 `(c, b)`，我们可以直接使用恒等函数来实现透镜的行为：
- 使用 **`id`** 作为 `l`，表示将对象拆分为 `(c, a)`。
- 使用 **`id`** 作为 `r`，表示重新组合成 `(c, b)`。

#### 总结

- **类型变化透镜** 允许从复合对象中提取部分（焦点），并在替换焦点的同时构造新的对象。
- Haskell 中的存在类型允许隐藏剩余部分的具体类型，只暴露操作的箭头。
- 前向传递和后向传递分别用于焦点的提取和更新。
- **乘积类型的透镜** 是类型变化透镜的一个简单示例，它可以轻松地从元组中提取或替换其中一个元素。

### ------------------------

### 透镜组合（Lens Composition）

透镜的一个重要特性是它们可以组合，允许我们访问和操作嵌套的复合对象。通过组合两个透镜，我们可以在外部对象中深入到某个内部组件的子组件。

#### 透镜组合的定义

假设我们有两个透镜：
1. **外部透镜**：允许我们从整体对象 $s$ 中访问并修改一个部分 $a$，产生一个新对象 $t$，该部分 $a$ 可以替换为 $b$。
2. **内部透镜**：允许我们进一步从 $a$ 中访问子部分 $a'$，并将其替换为 $b'$，从而得到新的部分 $b$。

我们想构造一个 **组合透镜**，它能够从 $s$ 中直接访问 $a'$，并将其替换为 $b'$，从而得到新的对象 $t$。组合的关键在于，将两个剩余部分的乘积作为新的剩余部分。

组合透镜的定义可以写作：

```haskell
compLens :: LensE a b a' b' -> LensE s t a b -> LensE s t a' b'
compLens (LensE l2 r2) (LensE l1 r1) = LensE l3 r3
  where 
    l3 = assoc' . bimap id l2 . l1
    r3 = r1 . bimap id r2 . assoc
```

- **`l1 :: s -> (c, a)`**：这是外部透镜的前向传递，提取出 $a$ 和剩余部分 $c$。
- **`l2 :: a -> (c', a')`**：这是内部透镜的前向传递，提取出 $a'$ 和新的剩余部分 $c'$。
- **`r1 :: (c, b) -> t`**：这是外部透镜的后向传递，使用新的 $b$ 和 $c$ 生成新的复合对象 $t$。
- **`r2 :: (c', b') -> b`**：这是内部透镜的后向传递，使用新的 $b'$ 和 $c'$ 生成新的 $b$。

#### 组合过程的详细说明

- **前向传递 (`l3`)**：
  1. 首先，我们从外部透镜的 `l1` 得到 $(c, a)$。
  2. 然后，我们将 `l2` 应用于 $a$，得到 $(c', a')$，并与剩余的 $c$ 结合。
  3. 最后，应用 `assoc'` 来处理乘积的结合性，将 $(c, (c', a'))$ 转换为 $((c, c'), a')$。

- **后向传递 (`r3`)**：
  1. 首先，我们从内部透镜的 `r2` 得到新的 $b$，即 $(c', b') -> b$。
  2. 然后，将其与剩余的 $c$ 组合，并通过 `assoc` 处理乘积的结合性。
  3. 最后，使用外部透镜的 `r1` 来生成新的对象 $t$。

#### 函数定义和辅助函数

在这个过程中，我们需要两个处理乘积的辅助函数 `assoc` 和 `assoc'` 来处理嵌套的乘积：

```haskell
assoc :: ((c, c'), b') -> (c, (c', b'))
assoc ((c, c'), b') = (c, (c', b'))

assoc' :: (c, (c', a')) -> ((c, c'), a')
assoc' (c, (c', a')) = ((c, c'), a')
```

我们还需要 `bimap` 函数，它允许我们在二元组的两个分量上应用不同的函数：

```haskell
instance Bifunctor (,) where
  bimap f g (a, b) = (f a, g b)
```

#### 示例：组合乘积透镜

让我们看一个具体的例子。我们定义两个作用于 **乘积** 的透镜，并将它们组合在一起：

```haskell
prodLens :: LensE (c, a) (c, b) a b
prodLens = LensE id id

l3 :: LensE (c, (c', a')) (c, (c', b')) a' b'
l3 = compLens prodLens prodLens
```

这里，`prodLens` 是一个作用于乘积类型的简单透镜，它直接操作乘积的第二个分量。然后我们通过 `compLens` 将两个 `prodLens` 组合起来，构造出一个新的透镜 `l3`，它可以操作嵌套的乘积结构。

#### 应用组合透镜

我们可以使用组合透镜 `l3` 来操作嵌套的乘积类型。假设我们有一个嵌套的元组：

```haskell
x :: (String, (Bool, Int))
x = ("Outer", (True, 42))
```

使用 `toGet`，我们可以从嵌套的结构中提取最内层的元素：

```haskell
toGet l3 x
-- 返回值: 42
```

使用 `toSet`，我们可以将最内层的元素替换为新的值（例如 `Char` 类型）：

```haskell
toSet l3 x 'z'
-- 返回值: ("Outer", (True, 'z'))
```

#### 总结

- 透镜可以通过组合访问嵌套的对象结构。
- 使用 `compLens` 可以组合两个透镜，一个外部透镜和一个内部透镜，生成一个新的透镜，用于访问更深层次的结构。
- **前向传递** 提取剩余部分和焦点，**后向传递** 则用新的焦点和剩余部分构造出更新的对象。
- 组合透镜的例子展示了如何通过嵌套结构的组合来操作对象的内层分量。

### ------------------------

### 透镜的范畴（Category of Lenses）

透镜的组合能力自然引出了一个问题：是否可以将透镜组织成一个范畴？答案是 **可以**，并且这样的范畴被称为 **Lens 范畴**，其对象和态射由透镜定义。

#### Lens 范畴的结构

在 **Lens** 范畴中：
- **对象** 是某个范畴（如 $\mathcal{C}$）中的 **对象对**，即 $\langle s, t \rangle$。每个对象由源对象 $s$ 和目标对象 $t$ 组成。
- **态射** 是从一个对象对 $\langle s, t \rangle$ 到另一个对象对 $\langle a, b \rangle$ 的透镜。换句话说，从对象 $\langle s, t \rangle$ 到对象 $\langle a, b \rangle$ 的态射是 $\mathcal{L}\langle s, t \rangle\langle a, b \rangle$ 中的元素。

#### 透镜作为态射

透镜的定义使其能够从 **源对象** 中提取部分，并替换该部分为目标对象的一部分。因此，从对象对 $\langle s, t \rangle$ 到对象对 $\langle a, b \rangle$ 的透镜实际上是一个态射，将 $s$ 映射到 $a$，并将 $t$ 映射到 $b$。

透镜的 **前向传递** 和 **后向传递** 分别对应于将对象分解成部分（前向）和重新组合成新的对象（后向）的过程。在范畴 Lens 中，透镜的组合对应于态射的组合。

#### 态射的组合

透镜的组合定义了态射的组合。在 **Lens 范畴** 中，两个透镜的组合使我们能够从外部对象 $s$ 中逐层深入访问更内层的子对象。

假设我们有两个透镜：
1. 从 $\langle s, t \rangle$ 到 $\langle a, b \rangle$ 的透镜，记作 $\text{LensE}(s, t, a, b)$。
2. 从 $\langle a, b \rangle$ 到 $\langle a', b' \rangle$ 的透镜，记作 $\text{LensE}(a, b, a', b')$。

我们可以组合它们，得到一个从 $\langle s, t \rangle$ 到 $\langle a', b' \rangle$ 的组合透镜，形式为：

```haskell
compLens :: LensE a b a' b' -> LensE s t a b -> LensE s t a' b'
```

这对应于范畴 Lens 中态射的组合操作。

#### 透镜范畴的对象和态射

- **对象**：$ \langle s, t \rangle $
- **态射**：从 $\langle s, t \rangle$ 到 $\langle a, b \rangle$ 的透镜，记作 $ \mathcal{L}\langle s, t \rangle\langle a, b \rangle$。

#### 范畴结构的关键点

1. **恒等透镜**：对于任意对象对 $\langle s, t \rangle$，有一个恒等透镜，它只返回自身。这对应于范畴中的恒等态射。

2. **透镜的组合**：两个透镜的组合对应于范畴中的态射组合。透镜的组合方式满足范畴的结合律。

#### 透镜组合的局限性

虽然透镜的范畴 Lens 存在，并且组合满足结合律，但这种组合公式可能过于复杂，在实际操作中不易使用。因此，在更复杂的场景中，我们可以使用 **Tambara 模块** 作为透镜的另一种表示法，它简化了组合操作。

#### 总结

- **Lens 范畴** 是一个范畴，其中对象是对象对 $\langle s, t \rangle$，态射是从一个对象对到另一个对象对的透镜。
- 透镜的组合定义了态射的组合，而恒等透镜则定义了范畴中的恒等态射。
- 在实际应用中，透镜的组合可能比较复杂，因此我们可以考虑使用其他表示法（如 Tambara 模块）来简化透镜的组合。

### ------------------------

### 17.10 透镜与纤维丛 (Lenses and Fibrations)

透镜可以通过**纤维丛**（fibrations）的语言来理解。透镜的 `get` 和 `set` 操作分别对应于纤维丛中的投影映射和纤维重新组合的操作。通过这种视角，我们可以将透镜与范畴论中的纤维丛紧密联系起来。

#### 纤维丛的基本概念

在数学中，纤维丛是一种结构，用于描述如何将一个更复杂的空间分解为更简单的部分。纤维丛的基本形式是一个 **投影映射** $p$：

$$ p: E \to B $$

这里：
- **$E$** 是纤维丛的总空间（total space），它代表复合类型，可以被分解为不同部分。
- **$B$** 是基空间（base space），表示可以从总空间中提取的某个部分。
- 投影映射 **$p$** 的作用是将总空间 $E$ 中的每个元素投影到基空间 $B$，从而抽取出它的 "焦点"。

这个投影过程与透镜的 `get` 操作十分相似，透镜通过 `get` 从整体对象中提取出焦点部分。

#### 透镜中的 `get` 与纤维丛中的投影

透镜的 `get` 操作是从复合对象中提取焦点的函数：

$$ \text{get} :: s \to a $$

在纤维丛的视角下，`get` 对应于纤维丛的投影映射 $p$，其作用是将总空间 $E$ 中的对象投影到基空间 $B$：

$$ p: E \to B $$

这里，$E$ 是复合对象的空间，$B$ 是焦点的空间。投影映射 $p$ 从总空间 $E$ 中抽取出与某个复合对象关联的焦点。

#### 透镜中的 `set` 与纤维丛中的纤维重组

透镜的另一个重要操作是 `set`，它允许将一个新的焦点替换到复合对象中，生成一个新的对象：

$$ \text{set} :: s \to a \to s $$

透镜的 `set` 操作可以理解为将新的焦点插入到原始对象的其他部分中，生成一个新的复合对象。在纤维丛的语言中，这对应于 **纤维的重组**，即将一个新的焦点与复合对象的剩余部分重新组合成一个新的整体。

在纤维丛的表示中，`set` 操作可以定义为一个映射：

$$ q: E \times B \to E $$

这里，$q$ 接受一个总空间中的某个复合对象（$E$）和一个新的焦点（$B$），然后返回一个新的复合对象。

#### 纤维丛视角下的 `get` 和 `set`

通过纤维丛的视角，我们可以重新解释透镜的两个核心操作：
1. **`get` 对应于投影映射 $p$**：这个操作从复合对象 $E$ 中提取焦点 $B$。它将总空间的元素映射到基空间中的某个点，相当于从复合对象中提取部分焦点。
2. **`set` 对应于纤维的重组 $q$**：这个操作将新的焦点插入到原始复合对象中。通过 $q$ 的作用，我们将总空间 $E$ 中的元素和基空间中的新焦点组合成一个新的复合对象。

在纤维丛的表示中，每个基空间 $B$ 的点都有一个与之关联的纤维，表示总空间 $E$ 中的所有可能组合。投影映射 $p$ 将这些纤维 "压缩" 到焦点，而 $q$ 则通过重新组合创建新的复合对象。

#### 类型变化透镜的解释

通过纤维丛，我们可以扩展这种解释到类型变化的透镜。在类型变化透镜中，焦点可以从一种类型 $a$ 变化为另一种类型 $b$，复合对象也随之变化。

设透镜的类型为：

$$ \text{LensE} \, s \, t \, a \, b $$

- **$s$** 和 **$t$** 是复合对象的源和目标类型。
- **$a$** 和 **$b$** 是焦点的源和目标类型。

在纤维丛的语言中，我们可以表示类型变化透镜为：

$$ \mathcal{L}\langle s, t \rangle \langle a, b \rangle = \int_{c} \mathcal{C}(s, c \times a) \times \mathcal{C}(c \times b, t) $$

- **$\mathcal{C}(s, c \times a)$**：表示通过前向传递将 $s$ 分解为剩余部分 $c$ 和焦点 $a$。
- **$\mathcal{C}(c \times b, t)$**：表示通过后向传递将剩余部分 $c$ 和新的焦点 $b$ 组合成新的复合对象 $t$。

这种透镜表示可以理解为一种从源到目标的复合操作，允许焦点类型的变化。

#### 总结

透镜和纤维丛之间的类比为我们提供了一个强大的工具来理解透镜的行为：
- **投影映射 $p$** 对应于透镜的 `get` 操作，它从复合对象中提取出焦点。
- **重组映射 $q$** 对应于透镜的 `set` 操作，它将新的焦点插入到原始复合对象中，生成新的对象。
- **类型变化透镜** 可以通过在纤维丛中重新组合不同类型的焦点和剩余部分来解释。

通过这种视角，透镜的行为可以与范畴论中的纤维丛相联系，为深入理解透镜的组合和变化提供了一个新的数学框架。

### ------------------------

### 传输定律 (Transport Law)

在纤维丛的框架下，传输定律解释了透镜的**`get`** 和 **`set`** 操作的关系。传输定律揭示了透镜在重新组合焦点时的关键属性，即通过设置新的焦点，再获取焦点时，应该返回刚刚设置的值。这对应于：

$$ \text{get (set s a)} = a $$

#### 纤维丛中的传输定律

透镜的传输定律可以类比为在纤维丛中 "传输" 复合对象到新的焦点所处的纤维上。具体来说，设有投影映射：

$$ p: E \to B $$

其中：
- **$E$** 是纤维丛的总空间，表示复合对象的类型。
- **$B$** 是基空间，表示焦点的类型。

同时，我们定义了一个映射 **$q$**，它负责通过新的焦点将复合对象重组为一个新的复合对象：

$$ q: E \times B \to E $$

这意味着我们将复合对象 $s \in E$ 传输到由新的焦点 $a \in B$ 指定的纤维。传输定律告诉我们：如果我们从新的焦点 $a$ 重新构建了一个对象，然后提取这个新的对象的焦点，我们应该得到 $a$ 本身。

在纤维丛的语言中，这对应于：

$$ p(q(s, a)) = a $$

即，**投影** $p$ 作用于通过 $q$ 传输得到的新对象时，应该得到新焦点 $a$。这是透镜中的基本规则：你设置了新的焦点，再提取时，返回的正是这个新设置的焦点。

#### 交换图表示

我们可以使用交换图来直观地表达传输定律：

$$
\begin{array}{c}
\begin{array}{ccc}
E \times B & \xrightarrow{q} & E \\
 & \searrow_{p} & \downarrow p \\
 &  & B
\end{array}
\end{array}
$$

这个交换图表示了以下等式的成立：

$$ p \circ q = \pi_2 $$

其中，**$\pi_2$** 是乘积 $E \times B$ 到其第二个分量的投影映射。这个投影映射在范畴论中表达了传输的行为：给定复合对象和新的焦点，重新组合之后，再通过投影 $p$ 提取焦点，应该得到设置时的焦点。

#### 使用余单模的推广

在更一般的单模范畴中，传输定律可以通过余单模的结构来解释。我们引入余单模的余单元 **$\varepsilon$**：

$$ \varepsilon: E \to 1 $$

这里，**$\varepsilon$** 起到了将结构传递到单位对象的作用。利用余单模的这一属性，我们可以推广传输定律，使得它适用于更广泛的场景，特别是在单模范畴中使用张量积时，这种表示方式显得更加通用。

#### 总结

透镜的传输定律表明，当我们通过 `set` 操作重新组合对象后，再通过 `get` 提取焦点时，得到的应该是我们设置的焦点。这一性质在纤维丛的语言中由投影映射 $p$ 和重组映射 $q$ 来表达，表示为 $p \circ q = \pi_2$。这种结构不仅在基本的透镜中成立，还可以推广到更复杂的单模范畴中，提供了一种范畴论框架下的透镜解释。

### ----------------------

<img src="https://p.ipic.vip/dwocth.png" alt="e99db76b0d71e91bda593bac76c9594e" style="zoom:50%;" />

恒等定律 (Identity Law) 通过表达透镜的 **`set/get`** 行为来说明，当我们提取焦点然后再次设置它时，整个复合对象应该保持不变。图中的示意展示了这一现象。

#### 恒等定律的数学表达
恒等定律的数学表达为：

$$ \text{set (get s)} = s $$

这意味着，从复合对象 $s$ 提取焦点，然后将这个焦点重新设置回去，应该不会改变复合对象 $s$。换句话说，设置与获取相同的焦点是一个恒等操作。

#### 纤维丛中的表达

在纤维丛的语言中，这个过程可以描述为，投影 **$p$** 提取复合对象 **$E$** 中的焦点 **$a$**，然后我们用映射 **$q$** 将这个焦点重新组合到原来的复合对象 **$s$**。这一过程可以写为以下等式：

$$ q(s, p(s)) = s $$

#### 余单模的余乘法

我们可以用余单模的余乘法来表达这个定律。设有映射 **$\delta$**：

$$ \delta : E \to E \times E $$

此映射描述了如何将复合对象分解为其自身与其焦点的“副本”在一起。**恒等定律**则要求以下组合为恒等映射：

$$ E \xrightarrow{\delta} E \times E \xrightarrow{id \times p} E \times B \xrightarrow{q} E $$

其中，**$p$** 是投影，**$q$** 是重组映射。换句话说，通过将对象 **$s$** 投影到它的焦点，然后将焦点重新组合回原来的对象，应该得到原来的对象 **$s$**。

#### 图示理解

图中的示意表示了这一过程：

- **$s = q(s, a)$** 表示我们从对象 **$s$** 中提取焦点 **$a$**，然后重新将 **$a$** 组合回 **$s$**，结果保持不变。
- **$p^*_1 a$** 表示通过投影映射 **$p$** 提取焦点。
- 蓝色箭头表示恒等操作，即对象 **$s$** 在操作前后保持不变。

这个图展示了恒等定律在纤维丛中的具体实现，说明了通过 **`set/get`** 的操作不会改变原始对象。

### --------------------

<img src="https://p.ipic.vip/7vx1y5.png" alt="db61c9b9717c3c6ebefb52782b88a3fd" style="zoom:50%;" />

组合定律（Composition Law）可以通过丛中的图表表示，描述了透镜的 **set/set** 行为。该定律表述如下：

$$
\text{set (set s a) a'} = \text{set s a'}
$$

### 直观解释
组合定律的含义是：当我们对复合对象 **s** 进行两次焦点设置操作时，第二次的设置将覆盖第一次的设置结果。因此，最后一次设置的焦点值决定最终的复合对象。

### 丛中的表示

- 在图中的橙色区域代表的是 **$E$**，即复合对象的类型。
- **$B$** 代表焦点的类型，而 **$a$** 和 **$a'$** 分别表示第一次和第二次设置操作中的焦点值。
- 投影 **$p_1$** 表示提取操作，而映射 **$q$** 是进行焦点替换的操作。

图中的两条曲线（红色和蓝色箭头）表示了两次设置操作。红色箭头表示第一次设置操作 $q(s, a)$，蓝色箭头表示第二次设置操作 $q(a', s'')$。根据组合定律，第二次的设置覆盖了第一次的结果，因此最后的结果是 **$q(a', s)$**。

### 数学表达

在范畴论中，组合定律可以用余单模中的映射来表示，如下：

$$
\text{set(set s a) a'} = \text{set s a'}
$$

通过交换图表表示，该定律说明了在透镜组合的过程中，最终设置的焦点值会覆盖之前的焦点设置。

通过 **$q$** 的两次映射操作，最终的复合对象是由第二次设置的焦点 **$a'$** 确定的，而中间的焦点 **$a$** 被覆盖。

### ------------------------

![f2d3cb6f97ad44740c3d8292a60dd17f](https://p.ipic.vip/lwj8g7.png)

类型转换透镜（Type-changing Lens）通过将传输（transport）推广到丛之间的操作，允许在不同类型之间进行焦点的提取和设置。它建立了一种纤维化的结构来表示对象之间的关系。具体来说，透镜通过从复合对象中提取焦点，并允许设置新的焦点，实现对象的类型转换。

### 基本概念

- **范畴** $\mathcal{A}$: 定义焦点类型的范畴，丛的类型化通过此范畴实现。
- **集合 $B$**: 所有焦点类型的联合集合，它在范畴 $\mathcal{A}$ 上纤维化。$\pi$ 是投影，将焦点类型的元素发送到其对应的类型。
- **丛 $E$**: 在 $B$ 上纤维化的集合，其投影为 $p$。复合投影 $\pi \circ p$ 使得 $E$ 在 $\mathcal{A}$ 上传递地纤维化，构成一个复合对象的家族。

### 图示解释

上图展示了 $E$ 中的一个元素 $s$ 通过投影 $p$ 投射到 $B$ 中的一个元素，而这个元素通过投影 $\pi$ 进一步映射到 $\mathcal{A}$ 中的某个类型 $a$。在类型转换透镜中，我们关注的是如何在 $E$ 和 $B$ 之间通过 $p$ 和 $q$ 实现不同类型的焦点设置和传输。

### 传输定律

类型转换透镜通过定义传输 $q$，使得对象可以在不同丛之间移动，并且满足以下三个主要定律：

1. **get/set 定律（传输）:**
   $$
   p(q(b, s)) = b
   $$
   这表示当我们通过 $q$ 设置一个新焦点后，投影 $p$ 应该返回我们设置的焦点。

2. **set/get 定律（恒等）:**
   $$
   q(p(s), s) = s
   $$
   这意味着如果我们设置的是我们刚刚提取的焦点，那么不会发生任何变化。即，如果我们使用之前提取的焦点作为新的焦点，那么复合对象不会改变。

3. **set/set 定律（组合）:**
   $$
   q(c, q(b, s)) = q(c, s)
   $$
   组合定律说明，最后设置的焦点是决定性的，新的设置会覆盖之前的设置操作。

通过这些定律，类型转换透镜不仅实现了从不同类型之间的传输，还确保了操作的组合性和一致性。这种结构在描述复合类型的变换以及多个类型之间的焦点操作时特别有用。

### ----------------------

### 类型转换透镜（Type-changing Lens）

类型转换透镜是一种可以在不同类型的对象之间提取和设置某些“部分”的工具。它的作用类似于在复合对象（对象有多个部分）中找到一个特定的部分，操作它并返回修改后的对象。

### 基本想法

想象你有一个大的结构，里面包含了不同的类型，比如一个对象可能包含一个字符串和一个整数。类型转换透镜允许你从这个结构中提取出其中的一部分（比如整数），并在不破坏其余部分的情况下修改这个部分。重要的是，它允许你在不同类型的对象之间切换和操作这些部分。

为了实现这种功能，类型转换透镜会通过一种叫做“纤维化”的方式管理对象的内部结构。让我们从基础开始解释：

### 范畴（Category）和投影（Projection）

- **范畴 $\mathcal{A}$**：这是我们用来描述对象类型的框架。每种类型都被视为范畴中的一个对象。
- **集合 $B$**：这是所有可能的“焦点类型”的集合。焦点是你想要从对象中提取或修改的那部分。$B$ 是通过纤维化来管理的，投影 $\pi$ 将 $B$ 中的一个元素（焦点）映射到它对应的类型。
  
- **集合 $E$**：这是一个更大的集合，它包含了那些有多个部分的对象（比如，包含焦点和其他部分）。$E$ 在 $B$ 上被纤维化，意思是它将每个焦点映射到其所属的“类型”。换句话说，$E$ 是 $B$ 的“容器”，它不仅包含焦点，还包含对象的其他部分。

### 透镜中的投影和传输

- **投影 $p$**：$p$ 是一个类似 `get` 函数的操作，作用是从复合对象中提取出焦点。这就像是从一个包含多个元素的对象中，找到你关心的部分。比如，在对象 `("hello", 42)` 中，如果焦点是整数部分，投影 $p$ 就会提取出 `42`。

- **传输 $q$**：传输是透镜的另一部分，相当于 `set` 函数。它负责替换一个对象中的某个部分，并生成一个新的对象。比如，如果你希望把 `("hello", 42)` 里的 `42` 替换为 `99`，传输 $q$ 就会把新的值放回去，生成 `("hello", 99)`。

### 图形表示

1. **投影**：
   - 投影 $p$ 就是从复合对象 $E$ 中提取出你关注的部分 $B$。
   - 比如，从 $E = ("hello", 42)$ 中，通过投影 $p$ 可以得到 $B = 42$，这里 $42$ 就是焦点部分。

2. **传输**：
   - 传输 $q$ 可以理解为将一个新的值放回对象中。
   - 比如，如果你想替换之前提取出的 $42$ 为新的值 $99$，那么传输 $q$ 就会将 `("hello", 42)` 变成 `("hello", 99)`。

### 透镜的三条重要定律

透镜的操作必须满足一些规则，以确保组合起来不会出错。这些规则就是**定律**。

1. **get/set 定律（传输定律）**：
   ```
   get (set s a) = a
   ```
   解释：当你设置了一个新值，然后立刻获取这个值时，结果应该是刚设置的那个值。也就是说，设置了新焦点之后，获取操作必须返回你刚刚设置的值。

2. **set/get 定律（恒等定律）**：
   ```
   set s (get s) = s
   ```
   解释：如果你将对象的焦点设置为它当前已经有的值，整个对象就不会改变。也就是说，设置之前提取的值不会对对象有任何影响。

3. **set/set 定律（组合定律）**：
   ```
   set (set s a) a' = set s a'
   ```
   解释：如果你先将对象的焦点设置为某个值 $a$，然后再将它设置为另一个值 $a'$，最终结果是只考虑最后一次设置的值 $a'$。这意味着最新的设置操作会覆盖之前的设置。

### 类型转换透镜的例子

假设我们有一个简单的 Haskell 例子，表示如何通过透镜操作不同的部分：

```haskell
data LensE s t a b where
  LensE :: (s -> (c, a)) -> ((c, b) -> t) -> LensE s t a b

-- 通过 LensE 提取焦点
toGet :: LensE s t a b -> (s -> a)
toGet (LensE l r) = snd . l

-- 通过 LensE 设置新的焦点
toSet :: LensE s t a b -> (s -> b -> t)
toSet (LensE l r) s a = r (fst (l s), a)
```

在上面的代码中，`LensE` 定义了一个可以提取和设置不同部分的类型转换透镜。通过 `toGet`，我们可以从复合对象中提取焦点，通过 `toSet`，我们可以将新的焦点设置回去。

### 总结

类型转换透镜不仅仅是从对象中提取部分信息，它还允许你在不同类型的对象之间切换部分信息。这种结构在很多领域中都非常有用，尤其是当你需要处理复合数据结构并确保操作的一致性时。

### --------------------





### ------------------------



### ----------------------



### --------------------





### -=---------------------

### 17.11 重要公式 (Important Formulas)

这是一个方便的速查表，用于计算范畴论中的 **(co)ends** 和其他相关公式。

---

#### 1. **Hom-函子的连续性** (Continuity of the hom-functor):

$$
\mathcal{D}\left(d, \int_{a} P⟨a, a⟩ \right) \cong \int_{a} \mathcal{D}(d, P⟨a, a⟩)
$$

此公式表明，同态函子 $\mathcal{D}(d, -)$ 保持余极限的结构。

---

#### 2. **Hom-函子的共连续性** (Co-continuity of the hom-functor):

$$
\mathcal{D}\left( \int_{a} P⟨a, a⟩, d \right) \cong \int_{a} \mathcal{D}(P⟨a, a⟩, d)
$$

这说明同态函子 $\mathcal{D}(-, d)$ 也保持极限的结构。

---

#### 3. **忍者 Yoneda 引理** (Ninja Yoneda Lemma):

$$
\int_{x} \text{Set}(\mathcal{C}(a, x), F x) \cong F a
$$

这是经典 **Yoneda 引理** 的一种简化形式，展示了如何通过余极限来恢复函子的值。

---

#### 4. **忍者 Co-Yoneda 引理** (Ninja Co-Yoneda Lemma):

$$
\int_{x} \mathcal{C}(x, a) F x \cong F a
$$

这对应于 **Co-Yoneda 引理**，适用于对协变函子的余极限计算。

---

#### 5. **反变函子（预层）的忍者 Yoneda** (Ninja Yoneda for Contravariant Functors):

$$
\int_{x} \text{Set}(\mathcal{C}(x, a), G x) \cong G a
$$

这个公式适用于反变函子 $G$ 的 Yoneda 引理。

---

#### 6. **反变函子（预层）的忍者 Co-Yoneda** (Ninja Co-Yoneda for Contravariant Functors):

$$
\int_{x} \mathcal{C}(a, x) G x \cong G a
$$

类似于协变函子的 Co-Yoneda，引理适用于反变函子的余极限。

---

#### 7. **Day 卷积** (Day Convolution):

$$
(F ⋆ G)x = \int_{a, b} \mathcal{C}(a \otimes b, x) F a G b
$$

**Day 卷积** 定义了两个函子的卷积方式，将它们组合成一个新的函子。

---

这些公式为范畴论中的极限、余极限、Yoneda 引理、以及 Day 卷积提供了简化计算的工具。它们广泛应用于同态函子、预层 (presheaves) 和函子卷积的研究中。

### ------------------------------

### 17.11 重要公式 (Important Formulas) 详解

这是一个便捷的范畴论公式速查表，特别是关于 **(co)ends**、**Yoneda 引理**、和 **Day 卷积**。下面我将详细解释每个公式的含义、背景以及应用场景。

---

#### 1. **Hom-函子的连续性** (Continuity of the hom-functor)

公式：

$$
\mathcal{D}\left(d, \int_{a} P⟨a, a⟩ \right) \cong \int_{a} \mathcal{D}(d, P⟨a, a⟩)
$$

**解释：**
- **背景**：同态函子（Hom-functor）是一个重要的结构，在范畴论中描述了两个对象之间所有态射的集合。它具有 **极限 (limit)** 保持性。
- **公式意义**：这个公式告诉我们，当我们对一个函子 $P$ 求余极限时，如果我们再应用同态函子 $\mathcal{D}(d, -)$，结果相当于将 $\mathcal{D}(d, P⟨a, a⟩)$ 对所有 $a$ 求余极限。
- **应用场景**：这个性质表明同态函子与余极限的计算可以互换，这在处理函数空间的计算或泛函分析中的积分问题时尤为重要。

---

#### 2. **Hom-函子的共连续性** (Co-continuity of the hom-functor)

公式：

$$
\mathcal{D}\left( \int_{a} P⟨a, a⟩, d \right) \cong \int_{a} \mathcal{D}(P⟨a, a⟩, d)
$$

**解释：**
- **背景**：与极限类似，余极限有对偶的概念，称为 **共极限 (colimit)**。而同态函子的共连续性指的是它保持共极限的特性。
- **公式意义**：同样地，如果我们先对 $P⟨a, a⟩$ 求余极限，再将结果映射到 $d$，等价于对每个 $P⟨a, a⟩$ 先映射到 $d$，然后对这些映射求余极限。
- **应用场景**：这个公式在处理从范畴到集合的函子映射时非常有用，特别是在处理共极限相关的问题时。

---

#### 3. **忍者 Yoneda 引理** (Ninja Yoneda Lemma)

公式：

$$
\int_{x} \text{Set}(\mathcal{C}(a, x), F(x)) \cong F(a)
$$

**解释：**
- **背景**：这是一个简化形式的 **Yoneda 引理**，它说明了从 Hom 集合 $\mathcal{C}(a, x)$ 到函子 $F$ 的自然变换与 $F(a)$ 之间的关系。
- **公式意义**：该公式表明，如果我们对从 $\mathcal{C}(a, x)$ 到 $F(x)$ 的自然变换进行积分操作（这里的积分符号表示 coend），最终的结果会等价于 $F(a)$ 的值。
- **应用场景**：Yoneda 引理是范畴论中最核心的定理之一。它在函子理论和自然变换中的应用非常广泛，帮助我们理解如何从对象 $a$ 的同态集合推导出整个函子 $F$ 的行为。

---

#### 4. **忍者 Co-Yoneda 引理** (Ninja Co-Yoneda Lemma)

公式：

$$
\int_{x} \mathcal{C}(x, a) F(x) \cong F(a)
$$

**解释：**
- **背景**：这是 **Co-Yoneda 引理** 的一个特殊版本，它描述了对变换 $\mathcal{C}(x, a)$ 和 $F(x)$ 的积分如何简化为 $F(a)$。
- **公式意义**：通过将函子 $F$ 作用在对象 $x$ 上并对其进行 coend 操作，结果会等价于 $F(a)$。
- **应用场景**：Co-Yoneda 引理为处理协变函子的余极限提供了重要工具，尤其是在代数几何中的层理论中。

---

#### 5. **反变函子（预层）的忍者 Yoneda 引理** (Ninja Yoneda for Contravariant Functors)

公式：

$$
\int_{x} \text{Set}(\mathcal{C}(x, a), G(x)) \cong G(a)
$$

**解释：**
- **背景**：该公式是针对 **反变函子 (contravariant functors)** 的 Yoneda 引理的应用，反变函子与协变函子不同，它们对同态箭头的方向进行反转。
- **公式意义**：这个公式说明了如何对从反变函子的自然变换进行 coend 操作，并得到结果 $G(a)$。
- **应用场景**：反变函子广泛应用于同调代数和代数拓扑中的对偶对象处理，因此此引理在这些领域中非常有用。

---

#### 6. **反变函子（预层）的忍者 Co-Yoneda 引理** (Ninja Co-Yoneda for Contravariant Functors)

公式：

$$
\int_{x} \mathcal{C}(a, x) G(x) \cong G(a)
$$

**解释：**
- **背景**：这是 Co-Yoneda 引理的反变版本，适用于反变函子的余极限。
- **公式意义**：通过 coend 对反变函子 $G$ 的处理结果是 $G(a)$，这意味着我们可以通过同态集合和 coend 操作来重新构建反变函子在某个对象上的行为。
- **应用场景**：类似于正变函子，反变函子也常用于对偶结构的处理，尤其是预层理论和同调代数中的应用。

---

#### 7. **Day 卷积** (Day Convolution)

公式：

$$
(F ⋆ G)(x) = \int_{a, b} \mathcal{C}(a \otimes b, x) F(a) G(b)
$$

**解释：**

- **背景**：**Day 卷积** 是一种将两个函子组合为一个新函子的方式，它基于范畴中的张量积。
- **公式意义**：公式中的 $(F ⋆ G)$ 表示两个函子 $F$ 和 $G$ 的 Day 卷积，它通过对 $a$ 和 $b$ 的 coend 计算出与对象 $x$ 相关的函数值。
- **应用场景**：Day 卷积在高阶范畴论、代数结构以及函子之间的组合中起着重要作用，它提供了一种结构化的方式来组合两个函子。

---

### 总结

这些公式为范畴论中的余极限、极限、Yoneda 引理以及 Day 卷积提供了简化和统一的视角。每个公式都基于 coend 或 end 的概念，这些概念在处理范畴中的函子组合、自然变换以及对偶性方面起到了关键作用。理解这些公式可以帮助我们更深入地掌握范畴论的工具和技术，尤其是在同调代数、拓扑、代数几何和计算机科学中的应用。

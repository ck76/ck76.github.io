[toc]

### -------------------------

### Chapter 20: Enrichment（丰盈）

老子曰：“知足者富。”

#### 20.1 Enriched Categories（丰盈范畴）

丰盈范畴（Enriched Categories）是范畴论中一个扩展的概念，主要是为了应对一些传统范畴论不足的地方。要理解它，先来回顾传统范畴的概念：

- **传统范畴（Category）**：包含**对象（objects）**和**箭头（arrows, morphisms）**。每个箭头代表两个对象之间的关联。比如在集合范畴 **Set** 中，对象是集合，箭头是集合之间的函数。所有对象之间的箭头集合被称为 **同态集（hom-set）**，例如 **Hom(A, B)** 就是对象 **A** 到 **B** 的函数集合。

然而，在某些数学构造或理论中，我们发现用集合来描述对象之间的关系不够强大或灵活。于是，**丰盈范畴**扩展了这一概念，允许同态集不是集合，而是更加复杂的结构——通常是某种**幺半范畴（monoidal category）**的对象。

##### 丰盈范畴是什么？

在丰盈范畴中，我们不再要求对象之间的关系（同态集）是简单的集合，它可以是**任何其他范畴的对象**。这意味着在一个丰盈范畴中，两个对象之间的“同态集”可能不是一个集合，而是另一个范畴中的对象，比如矢量空间、拓扑空间，甚至是其他范畴本身。这使得丰盈范畴能够描述更加复杂和丰富的结构。

- **普通范畴**：对象之间的关联通过集合来描述。
- **丰盈范畴**：对象之间的关联通过更加复杂的结构（如其他范畴的对象）来描述。

##### 为什么研究丰盈范畴？

丰盈范畴的一个动机是许多复杂的数学和编程概念可以通过丰盈范畴的语言更容易地表达。尤其是当你开始接触高等范畴论或者阅读一些高深的数学文献（例如 nLab 网站）时，丰盈范畴的术语频繁出现。丰盈范畴的理论提供了一个更灵活的框架，适用于传统范畴难以处理的情况。

##### 丰盈范畴与 Haskell 的关系

在 **Haskell** 中，**Functor** 是一个非常基础的概念。为了理解 Haskell 中的 **Functor** 定义，我们实际上需要丰盈范畴的概念。传统的 **Functor** 定义如下：

```haskell
class Functor f where
  fmap :: (a -> b) -> f a -> f b
```

在这里，**Functor** 是对类型构造器的泛化，**fmap** 是函数映射。通过丰盈范畴的观点，我们可以把 Haskell 的 **fmap** 理解为一个更复杂的结构映射。传统的范畴论中，**同态集**是简单的集合，而丰盈范畴允许我们将这些同态集替换为更加复杂的结构，这正是 Haskell 中 **fmap** 的背后思想。

##### 加权极限与余极限

丰盈范畴的一些概念，比如**加权极限（weighted limits）**和**加权余极限（weighted colimits）**，能够在处理范畴的极限和余极限时提供额外的灵活性。极限和余极限是范畴论中非常重要的构造，用来描述范畴中如何通过对象和箭头的组合形成新的对象。加权极限是一种更加广泛的极限，它允许我们对不同对象赋予不同的“权重”。

这些概念极大地扩展了传统范畴论的应用范围，并且强大到足以改变我们对数学问题的思考方式。有些人甚至提议用“所有概念都是加权（余）极限”来替代经典的“所有概念都是 Kan 扩张”。

### 总结

丰盈范畴为传统范畴论的框架提供了一个强大的扩展。在丰盈范畴中，箭头不再被限制为集合，而是可以是其他更复杂的结构。研究丰盈范畴的原因之一是它提供了更一般的数学工具，帮助我们理解像 Haskell 中 **Functor** 这样的编程概念。同时，丰盈范畴为极限、余极限等重要构造提供了更灵活的描述方式，使得范畴论的适用范围更加广泛。

### -------------------------

### Set-theoretical Foundations（集合论基础）

范畴论的基础结构相对简单，它研究对象和箭头之间的关系。然而，范畴论的一个核心依赖是**集合论**。这在范畴论的基本定义中体现得很明显：两个对象之间的关系由一个集合（**同态集**）来表示。尽管范畴论的目标是构建更加一般的数学框架，但它仍然不得不依赖于集合论的概念。

#### 依赖集合论

同态集的概念是范畴论与集合论连接的主要桥梁。在传统的范畴论中，同态集 $Hom(A, B)$ 被定义为从对象 $A$ 到对象 $B$ 的箭头构成的集合。这意味着我们在范畴论的很多推理中隐含地依赖于集合论来处理对象之间的关系。

例如，在局部小范畴中（小范畴的一个子类），每一对对象之间的箭头形成一个集合。这种做法为我们提供了很大的便利，因为集合论是数学中非常成熟且广泛接受的理论。然而，范畴论中也会遇到超越集合的情况——比如在处理**太大**的范畴时，传统的集合论工具不足以解决这些问题。

#### 丰盈范畴与集合论的联系

**丰盈范畴**（Enriched Categories）试图在范畴论中**自我扩展**，即让范畴论不仅依赖于集合，而是通过更一般的结构来定义对象之间的关系。在丰盈范畴中，我们不再仅仅用集合来定义同态集，而是引入了更加复杂的结构，比如来自其他范畴的对象。这样，丰盈范畴就不再局限于集合论的框架，而是可以用其他范畴的对象来描述对象之间的关系。

然而，这种扩展并不能完全避免集合论的依赖。尽管我们在丰盈范畴中将同态集替换为更复杂的结构，但这些结构通常还是要回到某个具有集合论性质的基础上。因此，丰盈范畴只是将模型复杂化了，却没有完全脱离集合论的基础。

#### 集合的主要属性

集合的一个基本属性是它们可以包含**元素**，而元素之间可以比较相等性。换句话说，集合不仅仅是抽象的对象，它们内部有结构：集合中可以包含其他对象，并且两个元素要么相等，要么不相等。

在范畴论中，虽然我们通常讨论的是对象与箭头的关系，但在某些时候我们也会引入“广义元素”（generalized elements）和“全局元素”（global elements）的概念：
- **广义元素**：从某个对象指向其他对象的箭头。
- **全局元素**：从范畴中的终对象（或幺元对象 $I$）指向某个对象的箭头。

这些元素在范畴论中提供了一种类比于集合论中元素的工具。不过，集合的最核心的特性是它定义了元素之间的相等性。这一点在范畴论中不一定总是那么清楚，尤其是在丰盈范畴中。

#### 在丰盈范畴中的挑战

在传统范畴论中，我们经常通过**交换图表**来表达对象之间的关系，也就是用图形来说明某些箭头组合是相等的。这种推理方式依赖于我们能够在对象之间定义**箭头的相等性**。

然而，在**丰盈范畴**中，我们不再简单地使用集合表示对象之间的关系。这就意味着，所有涉及箭头相等的推理方式在丰盈范畴中需要重新调整。因为在丰盈范畴中，箭头被替换为更加复杂的对象，所以简单的交换图表推理在这里不再适用，必须进行更加复杂的构造。

#### 总结

丰盈范畴试图将范畴论的模型扩展到更加复杂的结构上，但它并没有完全摆脱集合论的依赖。集合论为范畴论提供了基础的结构性工具，例如元素和相等性。尽管丰盈范畴允许我们通过替换同态集来建模更复杂的系统，但在一些关键概念上，它仍然必须回归集合论的基础。这种扩展为数学和编程中的许多应用提供了灵活性，但也带来了新的挑战，尤其是在如何处理丰盈范畴中箭头的相等性问题上。

### -------------------------

### 同态对象 (Hom-Objects) 详解

在传统的范畴论中，两个对象之间的箭头被组织成一个集合，称为**同态集** $Hom(A, B)$。同态集中的每个元素代表对象 $A$ 到对象 $B$ 的一个箭头。这种定义方法依赖于集合论的基础。然而，当我们讨论**丰盈范畴**（Enriched Categories）时，我们将同态集替换为更加复杂的**同态对象**（Hom-Objects），这种替换初看似乎是一种退步，但实际上为范畴带来了更多的灵活性和结构。

#### 1. 同态对象与同态集的区别

首先要理解，同态集是 Set 范畴中的对象，即集合。集合有明确的元素，可以通过这些元素来定义对象之间的箭头。然而，同态对象则更加一般化，它不一定是集合，而是属于某个范畴中的对象。在丰盈范畴中，我们通过替换传统的同态集为属于某个**幺半范畴** $\mathcal{V}$ 的同态对象来扩展对象之间的关系。

例如，在普通范畴论中，两个对象之间的同态集可以写作：
$$ Hom(A, B) $$
它表示从对象 $A$ 到对象 $B$ 的所有箭头的集合。而在丰盈范畴中，这个同态集被替换为一个**对象**，属于某个范畴 $\mathcal{V}$，例如幺半范畴。我们用同态对象来表示：
$$ Hom_{\mathcal{V}}(A, B) $$

#### 2. 丰盈范畴中的态射丰富性

同态对象的丰富性体现在它们**所在范畴的态射**中。虽然我们不再处理具体的元素，但同态对象的复杂性和灵活性远超于简单的集合。每个同态对象都是属于某个范畴 $\mathcal{V}$ 的对象，而这个范畴可能具有更加丰富的结构，例如可以进行组合、定义单位元等操作。

- **集合的无结构性**：在普通范畴中，集合是无结构的，这意味着集合之间可以定义大量的函数。这使得我们可以用同态集的元素直接描述对象之间的关系。
- **结构化对象的范畴**：在丰盈范畴中，由于同态集被替换为同态对象，结构就变得更加复杂。同态对象之间可能有特定的结构和关系，这使得箭头更加受限，而结构也更加丰富。

#### 3. 普通范畴论作为特例

丰盈范畴并不是对普通范畴论的完全替代，它实际上将普通范畴论作为特例来处理。在普通范畴论中，同态集是 Set 范畴中的对象。而在丰盈范畴中，同态对象来自某个更一般的范畴 $\mathcal{V}$。例如，$\mathcal{V}$ 可以是幺半范畴、拓扑范畴，甚至某种张量范畴。

#### 4. 丰盈范畴中的基本原理

为了理解丰盈范畴的基本原理，我们需要重新考虑范畴中的一些核心操作，例如**箭头的复合**和**单位箭头**。在传统的范畴论中，这些操作可以通过集合论来解释，但在丰盈范畴中，我们必须基于幺半范畴 $\mathcal{V}$ 中的结构进行定义。

- **箭头的复合**：在普通范畴中，箭头的复合可以看作是同态集之间的一个函数：
  $$ \circ : Hom(b, c) \times Hom(a, b) \to Hom(a, c) $$
  而在丰盈范畴中，这个复合操作需要在同态对象之间进行，我们可以写作：
  $$ \circ : Hom_{\mathcal{V}}(b, c) \otimes Hom_{\mathcal{V}}(a, b) \to Hom_{\mathcal{V}}(a, c) $$
  其中，$\otimes$ 表示幺半范畴中的张量积操作。

- **单位箭头**：在普通范畴中，单位箭头可以通过从单位对象 1 到 $Hom(a, a)$ 的函数来定义：
  $$ j_a : 1 \to Hom(a, a) $$
  在丰盈范畴中，单位箭头由幺半范畴 $\mathcal{V}$ 中的单位对象来定义。

#### 5. 幺半范畴的作用

丰盈范畴的定义依赖于幺半范畴 $\mathcal{V}$。幺半范畴是具有**结合律**和**单位元**的范畴，类似于代数中的幺半群。在丰盈范畴中，同态对象之间的复合需要满足幺半范畴的这些基本性质。

- **结合律**：复合的结合律对应于幺半范畴中的结合律。无论你如何组合箭头，它们的复合方式保持一致。
- **单位元**：每个对象都有一个单位箭头，它对应于幺半范畴中的单位元。这保证了箭头的自反性。

#### 6. 总结

**同态对象**的引入扩展了范畴论的定义，使我们能够用更加复杂的结构来定义对象之间的关系。这并不是一种退步，相反，它赋予了范畴论更大的灵活性和表达力。通过使用幺半范畴 $\mathcal{V}$，我们可以在同态对象中引入更加丰富的结构，从而为研究更加复杂的系统提供了理论工具。

在丰盈范畴中，传统的范畴论只是一个特例。同态对象为我们提供了新的视角，将箭头之间的关系推广到更复杂的范畴结构中，而这些结构的核心在于幺半范畴的操作。在这种推广下，范畴论中的复合和单位操作得以自然地推广，丰富了我们对范畴结构的理解。

### -------------------------

### 丰盈范畴详解（Enriched Categories）

在范畴论的传统定义中，两个对象之间的同态集 $Hom(A, B)$ 是一个集合，表示对象 $A$ 到对象 $B$ 的所有箭头的集合。然而，**丰盈范畴（Enriched Categories）** 对这一概念进行了扩展。在丰盈范畴中，同态集不再是集合，而是来自某个**幺半范畴** $\mathcal{V}$ 的对象。这样，两个对象之间的关系可以拥有更多的结构和复杂性。这种方法极大地扩展了范畴论的应用领域，允许我们处理更加复杂的系统。

#### 1. 幺半范畴与丰盈范畴的基本构造

首先，定义丰盈范畴的核心是一个幺半范畴 $\mathcal{V}$。幺半范畴是一种特殊的范畴，它具有**张量积**（类似于乘法）和**单位对象**（类似于乘法的单位元）。在幺半范畴 $\mathcal{V}$ 中，有两个基本操作：

- **张量积** $\otimes$：给定 $\mathcal{V}$ 中的两个对象 $a$ 和 $b$，它们的张量积是另一个对象 $a \otimes b$。
- **单位对象** $I$：它是 $\mathcal{V}$ 中的一个特殊对象，对于所有对象 $a$，都有 $I \otimes a = a \otimes I = a$。
  

此外，幺半范畴中的结合性和单位性由下列自然同构表达：
- **结合子** $\alpha: (a \otimes b) \otimes c \to a \otimes (b \otimes c)$
- **单位子** $\lambda: I \otimes a \to a$ 和 $\rho: a \otimes I \to a$

在这些结构之上，丰盈范畴 $\mathcal{C}$ 定义了其对象和同态对象。具体地，**丰盈于 $\mathcal{V}$ 的范畴** $\mathcal{C}$ 具有一组对象，对于每对对象 $a$ 和 $b$，它们之间的同态对象 $Hom(a, b)$ 是 $\mathcal{V}$ 中的一个对象。这个同态对象具有和传统同态集类似的功能，但它的结构更加复杂。

#### 2. 丰盈范畴中的复合与单位

在传统范畴中，箭头的复合是两个同态集之间的函数。我们可以写作：
$$ \circ: Hom(b, c) \times Hom(a, b) \to Hom(a, c) $$

但是，在丰盈范畴中，同态集已经被替换为来自幺半范畴 $\mathcal{V}$ 的同态对象。此时，复合操作通过 $\mathcal{V}$ 中的箭头来定义，我们可以写作：
$$ \circ: Hom(b, c) \otimes Hom(a, b) \to Hom(a, c) $$

这里的张量积 $\otimes$ 是 $\mathcal{V}$ 中的张量积操作。这意味着，丰盈范畴中的复合不是简单的箭头组合，而是涉及张量积的操作。

单位箭头也是类似的。在传统范畴中，每个对象都有一个身份箭头 $id_a$，它从 $a$ 到 $a$。在丰盈范畴中，单位对象 $I$ 通过箭头 $j_a: I \to Hom(a, a)$ 表达身份箭头的作用。单位箭头通过 $\mathcal{V}$ 中的单位对象 $I$ 来表示。

#### 3. 结合律与单位律

为了保证丰盈范畴的操作合理，复合和单位必须满足类似传统范畴中的结合律和单位律。这些规律在幺半范畴 $\mathcal{V}$ 中的结合子和单位子帮助下自然地被扩展到了丰盈范畴。

- **结合律**：复合的结合性由 $\mathcal{V}$ 中的结合子 $\alpha$ 表达：
  $$ \alpha: (Hom(c, d) \otimes Hom(b, c)) \otimes Hom(a, b) \to Hom(c, d) \otimes (Hom(b, c) \otimes Hom(a, b)) $$
  并且复合的结合性必须满足：
  $$ \circ \otimes id = id \otimes \circ $$

- **单位律**：单位律规定了身份箭头的行为。它通过 $\mathcal{V}$ 中的单位子 $\lambda$ 和 $\rho$ 来表示：
  $$ \lambda: I \otimes Hom(a, b) \to Hom(a, b) $$
  $$ \rho: Hom(a, b) \otimes I \to Hom(a, b) $$

#### 4. 反范畴与张量积范畴

在普通范畴中，我们可以通过逆转箭头的方向来构造一个**反范畴（opposite category）**。类似地，在丰盈范畴中，我们也可以定义反范畴。对于丰盈于 $\mathcal{V}$ 的范畴 $\mathcal{C}$，其反范畴 $\mathcal{C}^{op}$ 定义如下：
$$ Hom_{\mathcal{C}^{op}}(a, b) = Hom_{\mathcal{C}}(b, a) $$

此外，如果 $\mathcal{V}$ 是一个**对称幺半范畴**（即张量积满足交换律），我们还可以定义两个丰盈范畴的张量积。例如，对于两个丰盈范畴 $\mathcal{C}$ 和 $\mathcal{D}$，它们的张量积 $\mathcal{C} \otimes \mathcal{D}$ 定义为：
$$ (C \otimes D)((c, d), (c', d')) = Hom_{\mathcal{C}}(c, c') \otimes Hom_{\mathcal{D}}(d, d') $$

#### 5. 丰盈范畴的实例

普通范畴实际上可以看作是**在集合幺半范畴（Set, $\times$, 1）上丰盈的范畴**。这意味着，普通范畴中的同态集就是 Set 中的集合，张量积是集合的笛卡尔积，单位对象是单元素集合。

另一个重要的例子是**2-范畴（2-Categories）**。2-范畴中的同态对象本身就是范畴，而 2-态射（即对象之间的箭头）就是这些范畴中的箭头。例如，小范畴的 2-范畴（Cat）可以看作是在 Cat 上丰盈的。同态对象是函子范畴，它们位于 Cat 范畴中。

#### 6. 结论

丰盈范畴的核心思想是用更加丰富的结构（同态对象）替代传统范畴中的同态集。这使得我们能够在范畴论的框架内处理更加复杂的系统。通过使用幺半范畴 $\mathcal{V}$，丰盈范畴为箭头的复合、单位、结合律等操作提供了更广泛的可能性。尽管如此，丰盈范畴的定义仍然是范畴论的一个推广，普通范畴可以视作在特定幺半范畴（如 Set）上的丰盈范畴。

丰盈范畴的定义使得我们能够通过更加灵活和结构化的方式来建模对象之间的关系，从而扩展了范畴论在理论和应用中的边界。

### -------------------------

### 预序（Preorders）

**预序（preorders）** 是一种非常简单而重要的结构，它广泛应用于数学和计算机科学中。预序可以被看作是集合上的一种关系，它表示一种“不完全排序”。简单来说，它告诉我们集合中的某些元素在某种意义上是“先于”其他元素的，但它不要求所有元素都能比较。

在讨论**丰盈范畴（enriched categories）**时，预序可以看作是最简单的丰盈范畴之一。这种丰盈结构实际上看似“贫乏”，因为它提供的结构非常简单，只有两个对象和一个特别的关系。通过引入一个**幺半行箭范畴（monoidal thin arrow category）**的丰盈结构，我们可以从范畴论的角度理解预序。

#### 1. 预序的基本定义

在预序中，我们有一个集合 $P$，以及集合上的一个关系 $\leq$，满足以下两个基本条件：

1. **自反性（Reflexivity）**：对于集合 $P$ 中的每个元素 $a$，都有 $a \leq a$。这意味着每个元素在预序中都是自反的，自己小于等于自己。
2. **传递性（Transitivity）**：如果 $a \leq b$ 且 $b \leq c$，那么 $a \leq c$。这意味着，如果一个元素 $a$ 小于等于 $b$，并且 $b$ 小于等于 $c$，那么 $a$ 小于等于 $c$。

这些性质定义了一个**预序集合**。它比全序（即每两个元素都可比较的集合）更加宽松。并不是所有元素都必须能进行比较，某些元素之间可以没有任何关系。

#### 2. 幺半行箭范畴的丰盈

为了更深入地理解预序如何作为丰盈范畴出现，我们需要先了解**幺半行箭范畴**的定义。这是一个非常简单的范畴，只有两个对象——我们可以称之为 $False$ 和 $True$，分别代表“假”和“真”。这个范畴的箭头关系非常简单：

- 从 $False$ 到 $True$ 有一个箭头。
- $False$ 是初始对象，$True$ 是终对象。
- $False$ 到 $False$ 和 $True$ 到 $True$ 都有单位箭头（$id_{False}$ 和 $id_{True}$）。
  

图示如下：

```
False -------> True
  |              |
 idFalse      idTrue
```

我们可以将这个范畴变成一个**幺半范畴**，通过定义其**张量积**操作。具体来说，我们定义：
- $True \otimes True = True$
- 任何其他的张量积组合都等于 $False$，即 $True \otimes False = False$，$False \otimes True = False$，以及 $False \otimes False = False$。

此时，$True$ 是这个幺半范畴的**单位对象**，因为无论与什么对象进行张量积操作，它都保持不变：$True \otimes x = x$。

#### 3. 预序与幺半行箭范畴的关系

当我们使用这个幺半行箭范畴来丰盈一个范畴时，得到的就是一个**预序**结构。具体地，对于两个对象 $a$ 和 $b$，我们定义它们之间的**同态对象** $Hom(a, b)$ 来自幺半行箭范畴的对象。$Hom(a, b)$ 可以是 $False$ 或 $True$，并具有以下含义：

- $Hom(a, b) = True$ 表示 $a \leq b$，即 $a$ 在预序中“先于” $b$。
- $Hom(a, b) = False$ 表示 $a$ 和 $b$ 之间没有任何关系。

在这种解释下，$True$ 代表两个对象之间的一个比较关系，而 $False$ 代表没有关系。

#### 4. 复合与传递性

一个非常重要的性质是**复合的传递性**。在预序中，如果 $a \leq b$ 且 $b \leq c$，那么 $a \leq c$。在丰盈范畴的上下文中，这意味着如果 $Hom(a, b) = True$ 且 $Hom(b, c) = True$，那么 $Hom(a, c)$ 必须为 $True$。

反过来说，如果 $Hom(a, b)$ 或 $Hom(b, c)$ 是 $False$，那么 $Hom(a, c)$ 也必须是 $False$。这实际上是传递性的一种范畴论表达。

#### 5. 单位箭头与自反性

在预序中，每个对象都应该满足**自反性**，即 $a \leq a$。在丰盈范畴中，这对应于每个对象都有一个**单位箭头** $id_a: True \to Hom(a, a)$。这意味着每个对象 $a$ 对应的同态对象 $Hom(a, a)$ 总是 $True$，这正是自反性的数学表达。

#### 6. 循环与不对称性

在传统的全序中，$a \leq b$ 和 $b \leq a$ 通常意味着 $a = b$。但在预序中，这个不一定成立。可以有 $a \leq b$ 且 $b \leq a$，但 $a \neq b$。这意味着预序不要求严格的比较关系，允许某种循环的存在。

#### 7. 预序作为薄范畴

值得注意的是，预序也可以用**薄范畴（thin categories）**来表示。在薄范畴中，任何两个对象之间最多只有一个箭头。也就是说，两个对象 $a$ 和 $b$ 之间要么有箭头，要么没有箭头。这与预序中 $a \leq b$ 或 $a \not\leq b$ 的二元关系完全一致。因此，预序可以看作是一种特殊的丰盈范畴，它的结构非常简单。

#### 8. 总结

预序的范畴论解释通过使用幺半行箭范畴的丰盈结构提供了一种简洁的视角。在这种丰盈范畴中，两个对象之间的同态对象可以是 $True$（表示 $a \leq b$）或 $False$（表示 $a$ 和 $b$ 无关）。复合箭头的传递性和单位箭头的自反性自然地反映了预序的传递性和自反性。

通过这种视角，我们看到丰盈并不一定意味着增加复杂性。在预序这种情况下，它提供了更简单的结构，但同时仍然允许我们使用范畴论的语言和工具来处理这种简单的排序结构。

### -------------------------

### 自丰盈（Self-enrichment）

**自丰盈（self-enrichment）** 是范畴论中的一个概念，特别是对于那些带有特定结构的范畴来说，它们可以通过某种方式“自我封闭”——即它们的同态对象可以来自自身的结构。在这种情况下，范畴的内部同态对象取代了外部的同态集，使得这个范畴能够用自己的元素和结构进行自定义的同态映射。

#### 1. 笛卡尔闭范畴中的自丰盈

自丰盈的一个重要例子是**笛卡尔闭范畴**。一个范畴是笛卡尔闭的，如果它有以下两个性质：

- **张量积（Cartesian product）**：对于范畴中的任意两个对象 $a$ 和 $b$，它们可以构成一个乘积对象 $a \times b$，带有投影箭头 $\pi_a : a \times b \to a$ 和 $\pi_b : a \times b \to b$。
- **指数对象（Exponential object）**：对于任意两个对象 $b$ 和 $c$，存在一个对象 $[b, c]$，称为从 $b$ 到 $c$ 的**指数对象**，满足 $\mathcal{C}(a \times b, c) \cong \mathcal{C}(a, [b, c])$ 的伴随性。

在笛卡尔闭范畴中，我们能够将范畴中的同态集 $\mathcal{C}(a, b)$ 替换为某种形式的内部结构，具体来说是内部同态对象 $[a, b]$。因此，这种范畴可以说是**自丰盈的**，因为它的同态对象来源于自身的结构。

#### 2. 幺半闭范畴中的自丰盈

更广义地，任何**幺半闭范畴**（monoidal closed category）都可以被看作是自丰盈的。幺半闭范畴类似于笛卡尔闭范畴，但其张量积不必是笛卡尔积，而是更一般的张量积 $\otimes$。

在幺半闭范畴中，存在一种重要的伴随关系：
$$
\mathcal{V}(a \otimes b, c) \cong \mathcal{V}(a, [b, c])
$$
这里，$[b, c]$ 是**内部同态对象**，表示从 $b$ 到 $c$ 的箭头。这种伴随关系使得我们可以通过内部结构来定义箭头，而不必依赖于外部的同态集。

这种结构使得幺半闭范畴能够“自我封闭”，即它的同态对象可以来自自身的内部结构，因此它也是自丰盈的。

#### 3. 复合的定义

在自丰盈的范畴中，我们需要定义箭头的复合。具体来说，如果我们有两个同态对象 $[a, b]$ 和 $[b, c]$，我们需要定义它们的复合：
$$
\circ : [b, c] \otimes [a, b] \to [a, c]
$$
为了定义这个复合，我们可以借助幺半闭范畴中的伴随关系。我们首先将问题转化为如何操作这些同态集。

具体的步骤如下：
1. 首先，我们考虑整个同态集 $\mathcal{V}([b, c] \otimes [a, b], [a, c])$。这表示从 $[b, c] \otimes [a, b]$ 到 $[a, c]$ 的同态集。
2. 使用伴随关系，我们可以将这个同态集重写为：
$$
\mathcal{V}(([b, c] \otimes [a, b]) \otimes a, c)
$$
3. 现在，我们只需要从这个同态集里面选择一个元素（即定义具体的复合箭头）来完成复合。这个复合可以通过以下的图式来定义：
$$
([b, c] \otimes [a, b]) \otimes a \xrightarrow{\alpha} [b, c] \otimes ([a, b] \otimes a) \xrightarrow{id \otimes \epsilon_{a, b}} [b, c] \otimes b \xrightarrow{\epsilon_{b, c}} c
$$
这里使用了**结合子（associator）** $\alpha$ 和伴随关系中的**评估箭头** $\epsilon$。结合子和评估箭头帮助我们将两个同态对象的复合转化为对目标对象 $c$ 的箭头。

#### 4. 定义单位箭头

同样地，在自丰盈的范畴中，我们需要定义一个**单位箭头**，即从单位对象 $I$ 到同态对象 $[a, a]$ 的箭头：
$$
j_a : I \to [a, a]
$$
这个单位箭头可以从同态集 $\mathcal{V}(I, [a, a])$ 中选择。在幺半闭范畴中，我们可以利用伴随关系将其重写为：
$$
\mathcal{V}(I, [a, a]) \cong \mathcal{V}(I \otimes a, a)
$$
我们知道 $\mathcal{V}(I \otimes a, a)$ 中存在一个左幺子 $\lambda$，因此我们可以使用这个左幺子来定义单位箭头 $j_a$。

#### 5. 总结

**自丰盈范畴** 是指一个范畴的同态对象可以从它自身的结构中得出，尤其是对于笛卡尔闭范畴或幺半闭范畴。通过使用内部同态对象 $[a, b]$ 替代外部的同态集，我们可以定义出箭头的复合和单位箭头。

在自丰盈的范畴中，复合和单位的定义可以通过使用幺半闭范畴中的伴随关系和结合子来实现。伴随关系为我们提供了一种从同态集重新表达为内部同态对象的方法，而结合子和评估箭头则帮助我们定义箭头的具体复合和单位。

自丰盈的概念表明，范畴论中的丰盈不仅仅是增加新的结构，有时它也可以通过让范畴内部的结构自我支持，从而形成一个更加封闭和自洽的系统。这种自封闭的结构对于理解复杂的数学对象以及它们之间的关系提供了极大的帮助。

### -------------------------

### 20.2 丰盈函子（$\mathcal{V}$-Functors）

**丰盈函子**是普通函子在丰盈范畴中的推广。在普通范畴论中，函子（Functor）是将一个范畴的**对象**和**箭头**映射到另一个范畴中的对象和箭头的结构保持映射。同样，在丰盈范畴中，**丰盈函子**的作用不仅是将对象映射到对象，还必须将**同态对象**映射到**同态对象**。换句话说，丰盈函子在对象和箭头上的作用要符合丰盈范畴的特殊结构。

#### 1. 丰盈范畴的背景

在普通范畴中，**同态集（hom-set）**是一个对象对之间所有箭头的集合。而在丰盈范畴中，**同态对象（hom-object）**取代了同态集，并且同态对象不再是简单的集合，而是来自一个幺半范畴 $\mathcal{V}$ 中的对象。

例如，普通的 Set 范畴中的同态集是集合，但在一个丰盈范畴中，同态对象可以是来自更复杂结构的对象，比如来自幺半范畴的结构（例如向量空间、群等）。

#### 2. 丰盈函子的定义

一个普通函子 $F : \mathcal{C} \to \mathcal{D}$ 将一个范畴 $\mathcal{C}$ 中的对象 $a$ 映射到范畴 $\mathcal{D}$ 中的对象 $F(a)$，并且将 $\mathcal{C}$ 中的箭头（同态）映射到 $\mathcal{D}$ 中的箭头，保持复合和单位箭头不变。

同样地，**丰盈函子** $F : \mathcal{C} \to \mathcal{D}$ 是将两个丰盈于同一幺半范畴 $\mathcal{V}$ 的范畴 $\mathcal{C}$ 和 $\mathcal{D}$ 之间的映射。丰盈函子不仅将 $\mathcal{C}$ 中的对象映射到 $\mathcal{D}$ 中的对象，还必须将**同态对象** $\mathcal{C}(a, b)$ 映射到 $\mathcal{D}(F(a), F(b))$，其中 $a$ 和 $b$ 是 $\mathcal{C}$ 中的对象。

因此，丰盈函子的定义如下：

- 对于每对对象 $a, b \in \mathcal{C}$，丰盈函子 $F$ 必须给出一个 $\mathcal{V}$ 中的箭头：
  $$
  F_{ab} : \mathcal{C}(a, b) \to \mathcal{D}(F(a), F(b))
  $$
  这个映射表明 $F$ 不仅映射对象，也要映射对象之间的同态对象。

#### 3. 丰盈函子的性质

丰盈函子必须保持**复合**和**单位**，即在同态对象上的映射必须与同态对象的复合操作和单位操作保持一致。这可以用**交换图表**的形式来表示。

##### 复合的保持
丰盈函子 $F$ 必须将源范畴 $\mathcal{C}$ 中的同态对象 $\mathcal{C}(a, b)$、$\mathcal{C}(b, c)$ 和 $\mathcal{C}(a, c)$ 映射到目标范畴 $\mathcal{D}$ 中的相应同态对象，同时保持它们的复合关系。也就是说，$F$ 的映射要保持复合：
$$
\circ : \mathcal{C}(b, c) \otimes \mathcal{C}(a, b) \to \mathcal{C}(a, c)
$$
映射为：
$$
\circ : \mathcal{D}(F(b), F(c)) \otimes \mathcal{D}(F(a), F(b)) \to \mathcal{D}(F(a), F(c))
$$
因此，我们可以通过以下**交换图表**表示丰盈函子保持复合的性质：
$$
\xymatrix{
\mathcal{C}(b, c) \otimes \mathcal{C}(a, b) \ar[d]_{F_{bc} \otimes F_{ab}} \ar[r]^{\circ} & \mathcal{C}(a, c) \ar[d]^{F_{ac}} \\
\mathcal{D}(F(b), F(c)) \otimes \mathcal{D}(F(a), F(b)) \ar[r]^{\circ} & \mathcal{D}(F(a), F(c))
}
$$
这张图表表示了复合的保持：丰盈函子先映射同态对象再进行复合，结果与先在源范畴中复合同态对象再进行映射是相同的。

##### 单位箭头的保持
丰盈函子还必须将源范畴中的**单位箭头**保持为目标范畴中的单位箭头。对于每个对象 $a \in \mathcal{C}$，我们有源范畴 $\mathcal{C}$ 中的单位箭头 $j_a : I \to \mathcal{C}(a, a)$，以及目标范畴 $\mathcal{D}$ 中的单位箭头 $j_{F(a)} : I \to \mathcal{D}(F(a), F(a))$。

因此，单位箭头的保持可以通过以下**交换图表**表示：
$$
\xymatrix{
I \ar[d]_{id} \ar[r]^{j_a} & \mathcal{C}(a, a) \ar[d]^{F_{aa}} \\
I \ar[r]^{j_{F(a)}} & \mathcal{D}(F(a), F(a))
}
$$
这表明，丰盈函子必须将源范畴中的单位箭头映射为目标范畴中的单位箭头。

#### 4. 丰盈函子的整体图像

从整体上看，丰盈函子在保持复合和单位的同时，遵循了与普通函子类似的基本原则。然而，在丰盈范畴中，箭头不再是简单的集合，而是更加复杂的同态对象（来自幺半范畴 $\mathcal{V}$ 的对象）。丰盈函子的作用不仅是对象间的映射，更是在同态对象间的结构保持。

### 5. 总结

**丰盈函子**是丰盈范畴中的重要结构，它将源范畴中的对象和同态对象映射到目标范畴中的相应对象和同态对象，同时保持复合和单位箭头。通过交换图表，我们可以清晰地表达复合和单位的保持性质。这种结构扩展了普通函子在丰盈范畴中的作用，使得范畴论能够处理更加复杂的系统和结构。

### -------------------------

### 同态函子（The Hom-functor）

在范畴论中，同态函子是一个基本的构造，它用于描述范畴中对象之间的关系。具体来说，同态函子把范畴中的**对象对**映射到**同态集**，即对象之间的箭头（态射）的集合。而在**丰盈范畴**的背景下，情况变得更加复杂，因为我们不再使用简单的集合作为对象对之间的关系，而是使用**同态对象**，这些同态对象来自于一个幺半范畴（monoidal category）$\mathcal{V}$。

同态函子在丰盈范畴中的作用是通过从对象对之间的**同态对象**映射到幺半范畴 $\mathcal{V}$ 中的对象来实现的。我们下面将详细说明丰盈范畴中的同态函子的构造和作用。

### 1. 同态函子的定义

同态函子是一个丰盈函子，它将对象对映射到幺半范畴 $\mathcal{V}$ 中的对象。形式上，同态函子可以写成：
$$
\text{Hom}_\mathcal{C}: \mathcal{C}^{op} \otimes \mathcal{C} \to \mathcal{V}
$$
这里，$\mathcal{C}^{op}$ 是范畴 $\mathcal{C}$ 的对立范畴，$\mathcal{C} \otimes \mathcal{C}$ 是 $\mathcal{C}$ 的积范畴，$\mathcal{V}$ 是用于丰盈的幺半范畴。同态函子将每对对象 $(a, b)$ 映射到 $\mathcal{C}(a, b)$，这就是丰盈范畴中从对象 $a$ 到对象 $b$ 的**同态对象**。这不同于普通范畴中的同态集，在丰盈范畴中，同态对象来自幺半范畴 $\mathcal{V}$。

#### 对象上的作用
同态函子在对象对上的作用是直截了当的：它将对象对 $(a, b)$ 映射到它们之间的同态对象 $\mathcal{C}(a, b)$：
$$
\text{Hom}_\mathcal{C}(a, b) = \mathcal{C}(a, b)
$$
其中，$\mathcal{C}(a, b)$ 是范畴 $\mathcal{C}$ 中从对象 $a$ 到对象 $b$ 的同态对象，这个同态对象属于丰盈幺半范畴 $\mathcal{V}$。

#### 同态对象上的作用
为了使同态函子完整，我们还必须定义同态函子在同态对象上的作用。假设我们有两个对象对 $(a, a')$ 和 $(b, b')$，那么我们希望定义从同态对象之间的箭头的映射：
$$
\text{Hom}_{(a, a') \to (b, b')}: (\mathcal{C}^{op} \otimes \mathcal{C})(\langle a, a' \rangle, \langle b, b' \rangle) \to \mathcal{V}(\mathcal{C}(a, a'), \mathcal{C}(b, b'))
$$
在这里，左边是同态对象的张量积 $\mathcal{C}(b, a) \otimes \mathcal{C}(a', b')$，而右边是 $\mathcal{V}$ 中的一个**内部同态对象** $[\mathcal{C}(a, a'), \mathcal{C}(b, b')]$。我们要找的映射是：
$$
\mathcal{C}(b, a) \otimes \mathcal{C}(a', b') \to [\mathcal{C}(a, a'), \mathcal{C}(b, b')]
$$
这个映射可以通过幺半闭范畴中的伴随性来得到。

### 2. 使用伴随关系

在幺半闭范畴 $\mathcal{V}$ 中，有一个伴随关系：
$$
\mathcal{V}(X \otimes Y, Z) \cong \mathcal{V}(X, [Y, Z])
$$
利用这个伴随关系，我们可以重新解释同态函子在同态对象上的映射。对于两个同态对象 $\mathcal{C}(b, a)$ 和 $\mathcal{C}(a', b')$ 的张量积，我们希望构造一个从张量积到目标同态对象 $\mathcal{C}(b, b')$ 的箭头。通过伴随关系，这可以重写为：
$$
\mathcal{C}(b, a) \otimes \mathcal{C}(a', b') \otimes \mathcal{C}(a, a') \to \mathcal{C}(b, b')
$$
这表示通过**复合**运算，我们可以将这些同态对象组合起来，最终得到一个从 $b$ 到 $b'$ 的同态对象。

### 3. 丰盈同态函子的提升

为了进一步理解同态函子的作用，我们可以考虑从单位对象 $I$ 到某个同态对象 $\mathcal{C}(a, b)$ 的箭头：
$$
f: I \to \mathcal{C}(a, b)
$$
这个箭头表示从单位对象 $I$ 到同态对象 $\mathcal{C}(a, b)$ 的某个元素。在丰盈范畴中，单位对象 $I$ 通常用来定义同态对象的具体元素。因此，箭头 $f$ 可以理解为一个从 $a$ 到 $b$ 的态射。

通过同态函子，我们可以定义这个箭头的提升。假设我们有从 $c$ 到 $a$ 的箭头 $\mathcal{C}(c, a)$，那么可以通过 $f$ 来构造从 $c$ 到 $b$ 的箭头：
$$
\mathcal{C}(c, f): \mathcal{C}(c, a) \to \mathcal{C}(c, b)
$$
具体来说，这可以通过以下步骤来定义：
$$
\mathcal{C}(c, a) \xrightarrow{id \otimes f} \mathcal{C}(a, b) \otimes \mathcal{C}(c, a) \xrightarrow{\circ} \mathcal{C}(c, b)
$$
这里使用了复合运算 $\circ$ 将 $f$ 作用在箭头 $\mathcal{C}(c, a)$ 上。

类似地，我们可以定义 $f$ 的反变提升，作用在从 $b$ 到 $c$ 的箭头上，得到从 $a$ 到 $c$ 的箭头：
$$
\mathcal{C}(f, c): \mathcal{C}(b, c) \to \mathcal{C}(a, c)
$$
这可以表示为：
$$
\mathcal{C}(b, c) \xrightarrow{f \otimes id} \mathcal{C}(b, c) \otimes \mathcal{C}(a, b) \xrightarrow{\circ} \mathcal{C}(a, c)
$$

### 4. 总结

**同态函子**是丰盈范畴中的一个重要构造，它将对象对映射到同态对象，并且遵循幺半范畴中的伴随关系和复合律。通过同态函子，我们可以从单位对象出发，定义箭头的提升，并通过复合来得到新的箭头。同态函子为丰盈范畴中的许多构造提供了基础，它允许我们以更一般的方式处理对象之间的关系，而不仅仅依赖于集合结构。这种更加灵活的范畴论工具可以用于构造更复杂的数学结构和理论。

### -------------------------

### 丰盈余预层（Enriched Co-Presheaves）

在范畴论中，余预层（co-presheaves）是函子的一种特殊形式，它们从某个范畴 $\mathcal{C}$ 映射到集合范畴 $\textbf{Set}$。这些函子非常有用，因为它们能将范畴中的结构通过集合的形式来表示，方便进行分析与研究。余预层的形式通常是：
$$
F: \mathcal{C} \to \textbf{Set}
$$
它将范畴 $\mathcal{C}$ 的每个对象映射到一个集合，并将态射映射为集合之间的函数。

然而，当我们讨论**丰盈范畴**时，集合的形式可能并不足够泛化。在丰盈范畴中，我们希望将同态集替换为来自另一个幺半范畴 $\mathcal{V}$ 的同态对象，因此丰盈余预层便是这种推广。

### 1. 什么是丰盈余预层？

丰盈余预层是一个**丰盈函子**，它将一个范畴 $\mathcal{C}$ 的对象映射到一个**幺半闭范畴** $\mathcal{V}$ 中的对象。这意味着，在丰盈范畴的背景下，余预层不仅仅映射对象到集合，还映射到更具结构的对象，如其他幺半范畴的对象。其一般形式为：
$$
F: \mathcal{C} \to \mathcal{V}
$$
这里的 $\mathcal{V}$ 是一个**幺半闭范畴**，其中包含丰富的结构，如张量积和内部同态对象。

与普通的 $\textbf{Set}$-值余预层相比，丰盈余预层更强大，因为它将每个对象映射到 $\mathcal{V}$ 的对象，并且在 $\mathcal{C}$ 中的态射不仅映射为函数，还映射为 $\mathcal{V}$ 中的箭头。

### 2. 丰盈余预层如何工作？

丰盈余预层的核心在于它不仅要在对象之间工作，还要在态射之间映射**同态对象**。具体来说，给定 $\mathcal{C}$ 的两个对象 $a$ 和 $b$，丰盈余预层 $F$ 会将 $\mathcal{C}(a, b)$（$a$ 和 $b$ 之间的同态对象）映射到 $\mathcal{V}$ 中的**内部同态** $[F(a), F(b)]$。这是丰盈环境下非常重要的一步，它将 $\mathcal{C}$ 中的关系（态射）以 $\mathcal{V}$ 中的结构表示出来。

形式上，丰盈余预层的映射可以写作：
$$
F_{ab}: \mathcal{C}(a, b) \to [F(a), F(b)]
$$
这里，$F_{ab}$ 是从 $\mathcal{C}$ 中的同态对象 $\mathcal{C}(a, b)$ 映射到 $\mathcal{V}$ 中的内部同态 $[F(a), F(b)]$ 的箭头。

### 3. 同态函子作为丰盈余预层的例子

同态函子是丰盈余预层的一个非常重要的例子。回顾一下，在普通范畴中，同态函子可以定义为：
$$
\text{Hom}_\mathcal{C}: \mathcal{C}^{op} \times \mathcal{C} \to \textbf{Set}
$$
它将每对对象 $(a, b)$ 映射到它们之间的同态集 $\mathcal{C}(a, b)$。

在丰盈范畴中，我们将这个定义推广到丰盈余预层的情况。此时，同态函子将映射到 $\mathcal{V}$，即：
$$
\text{Hom}_\mathcal{C}: \mathcal{C}^{op} \otimes \mathcal{C} \to \mathcal{V}
$$
这个同态函子在对象对上的作用仍然是将对象对 $(a, b)$ 映射到 $\mathcal{C}(a, b)$，但此时 $\mathcal{C}(a, b)$ 是 $\mathcal{V}$ 中的对象，而不再是一个集合。具体来说，它映射为 $\mathcal{V}$ 中的一个内部同态。

### 4. 丰盈幺半闭性条件

丰盈余预层的存在依赖于 $\mathcal{V}$ 的**幺半闭**性质。这意味着 $\mathcal{V}$ 必须具有张量积 $\otimes$ 和内部同态 $[ -, - ]$。内部同态提供了一种将 $\mathcal{V}$ 中的态射组织起来的方式，允许我们定义同态对象之间的复合。

此外，如果 $\mathcal{V}$ 是幺半闭的，张量积 $\otimes$ 可以定义为一个 $\mathcal{V}$-函子。换句话说，张量积不仅作用于 $\mathcal{V}$ 中的对象，还作用于 $\mathcal{V}$ 中的箭头。此时，丰盈余预层中的张量积映射会遵循以下规则：
$$
\otimes: \mathcal{V} \times \mathcal{V} \to \mathcal{V}
$$
它不仅作用于对象对 $(A, B)$，还作用于同态 $f: A \to B$ 和 $g: C \to D$，将它们映射为 $f \otimes g: A \otimes C \to B \otimes D$。

### 5. 总结

丰盈余预层是范畴论中的余预层在丰盈范畴背景下的推广。它不仅仅将范畴中的对象映射到集合，还将它们映射到更具结构的幺半范畴 $\mathcal{V}$ 中的对象。同时，丰盈余预层还映射对象之间的同态对象，并利用幺半闭范畴的结构定义这些映射。

在实际应用中，丰盈余预层为我们提供了更广泛的工具来描述对象之间的关系，尤其是在对象不仅仅是集合，而是具有更加丰富的结构时。这种推广为数学和计算机科学中的复杂系统建模提供了更为灵活的框架。

### 练习解答提示

**Exercise 20.2.2:**
对于幺半闭范畴 $\mathcal{V}$，张量积 $\otimes$ 是 $\mathcal{V}$ 中的一个函子：
$$
\otimes: \mathcal{V} \times \mathcal{V} \to \mathcal{V}
$$
要证明这个张量积是一个 $\mathcal{V}$-函子，你需要展示它不仅作用于 $\mathcal{V}$ 的对象对 $(A, B)$ 上，还作用于态射对 $(f: A \to C, g: B \to D)$，使得：
$$
\otimes(f, g): A \otimes B \to C \otimes D
$$

### ---------------------------

### 函子强度与丰盈（Functorial Strength and Enrichment）

在范畴论和编程中，理解**函子强度**（functorial strength）与**丰盈**（enrichment）的关系是很有趣且有用的，尤其是在使用**幺半范畴**的背景下。这里我们通过具体的例子和直观的解释，详细讨论这两个概念。

#### 1. 什么是函子强度？

**函子强度**是指一个函子能够在具有张量积（通常用于表达多参数结构）的上下文中保持其结构，并且能够处理多个变量。例如，在编程语言中，强度允许我们使用某些函数来组合上下文。这在处理**monads（单子）**时特别重要，因为强度是确保我们可以在 monadic 代码中访问外部上下文的关键属性。

具体来说，假设我们有一个从范畴 $\mathcal{C}$ 到幺半范畴 $\mathcal{V}$ 的函子 $F$，我们希望这个函子不仅仅能在单一对象上工作，还能处理复合的对象。此时，函子的强度通过以下自然变换来描述：
$$
\sigma_{a,b} : a \otimes F(b) \to F(a \otimes b)
$$
这个 $\sigma_{a,b}$ 映射确保了我们能够在张量积上下文中自然地处理对象 $a$ 和 $b$，并且保持函子 $F$ 的作用。

#### 2. 为什么强度与丰盈相关？

丰盈（enrichment）使得我们可以扩展普通的范畴论结构，将同态集替换为来自某个幺半闭范畴 $\mathcal{V}$ 的同态对象。在丰盈范畴中，同态不再是普通的集合，而是幺半范畴 $\mathcal{V}$ 的对象。

如果我们回到**强度**的定义，它实际上正是在幺半范畴中工作：$\sigma_{a,b}$ 保持了对象间的张量积结构，并与丰盈的定义方式自然契合。因此，**在丰盈范畴中，强度与丰盈紧密相关**，尤其是在自丰盈的幺半闭范畴中（例如，Haskell 的范畴环境）。由于**笛卡尔闭范畴**是自丰盈的，因此在 Haskell 中定义的端函子通常是自动强大的。

#### 3. 强度的结合性和单位条件

为了确保强度在整个范畴中是自然且一致的，我们要求强度必须满足**结合性**和**单位性**条件。

- **结合性条件**描述了当我们处理多个对象的张量积时，如何确保张量积的结合性。具体公式为：
  $$
  (a \otimes b) \otimes F(c) \to F((a \otimes b) \otimes c)
  $$
  这要求函子 $F$ 在张量积上下文中保持良好的行为，与范畴中张量积的结合律兼容。

- **单位性条件**描述了张量积的单位对象（通常为 $I$，即幺元）的行为。我们希望：
  $$
  I \otimes F(a) \to F(I \otimes a) \to F(a)
  $$
  这确保了单位对象在与其他对象组合时不会引入额外的结构。

这些条件与张量积的自然性相联系，确保了函子的强度能够一致地处理张量积和单位对象。

#### 4. 丰盈端函子与 Haskell 中的 `Functor`

在丰盈范畴中，一个端函子不仅将对象映射为对象，还将同态对象映射为同态对象。因此，一个丰盈端函子具有以下映射：
$$
F_{a,b}: \mathcal{C}(a, b) \to \mathcal{C}(F(a), F(b))
$$
这意味着丰盈端函子能够保持同态对象之间的结构，而不仅仅是对象之间的映射。

将其与 Haskell 中的 `Functor` 定义进行比较，我们看到 Haskell 的 `fmap` 函数实际上就是一个丰盈函子的实现：
```haskell
class Functor f where
  fmap :: (a -> b) -> (f a -> f b)
```
这里的 `(a -> b)` 和 `(f a -> f b)` 可以类比为内部同态。因此，Haskell 中的 `Functor` 确实可以视为丰盈范畴中的丰盈函子。

#### 5. 丰盈与强度的联系

在自丰盈的范畴中，每个**强端函子**都是自动丰盈的。为了证明这一点，我们需要展示这个端函子在同态对象之间的映射是如何实现的。

使用丰盈范畴中的**同态伴随关系**，我们可以将映射 $F_{a,b}$ 写成：
$$
\mathcal{V}([a, b] \otimes F(a), F(b))
$$
这可以通过将强度 $\sigma_{a,b}$ 和伴随关系中的余单元（evaluation map）组合在一起构造出来。

#### 6. 在 Haskell 中实现强度

我们可以在 Haskell 中实现函子强度，模拟上面的定义。`strength` 函数表明如何将对象与函子的结构结合在一起：
```haskell
strength :: Functor f => (a, f b) -> f (a, b)
strength = uncurry (\a -> fmap (coeval a))
```
这里的 `coeval` 函数定义为：
```haskell
coeval :: a -> (b -> (a, b))
coeval a = \b -> (a, b)
```
它构造了一个将对象 $a$ 和 $b$ 组合成元组的函数。最终的 `strength` 函数将 $a$ 与 `f b` 中的值进行组合，得到一个新的结构 `f (a, b)`。

#### 7. 总结

**函子强度**描述了函子如何在具有张量积的上下文中工作，而**丰盈**提供了一种将普通同态集推广为幺半范畴中的同态对象的方式。二者在范畴论中紧密相关，尤其是在处理幺半闭范畴（如 Haskell 中的函子）的环境下。通过将 Haskell 中的 `Functor` 和 `fmap` 视为丰盈函子的实现，我们可以更好地理解编程语言中这些概念的数学基础。

强度与丰盈的关系表明，任何自丰盈的范畴（如笛卡尔闭范畴）中的强端函子都是自动丰盈的，这为我们在编程和数学中使用这些概念提供了坚实的理论支持。

### -------------------------

### $\mathcal{V}$-自然变换（$\mathcal{V}$-Natural Transformations）

在范畴论中，自然变换是在两个函子之间建立联系的基本构造。在普通范畴环境中，自然变换将一个函子 $F: \mathcal{C} \to \mathcal{D}$ 转换为另一个函子 $G: \mathcal{C} \to \mathcal{D}$，通过为每个对象 $a \in \mathcal{C}$ 选择一个箭头 $ \nu_a: F(a) \to G(a)$。自然性条件保证这些选择是与范畴 $\mathcal{C}$ 的结构相容的。

当我们讨论丰盈范畴时，情况变得更为复杂，因为同态不再是简单的集合，而是来自某个幺半范畴 $\mathcal{V}$ 的对象。这样，自然变换的定义也需要相应地扩展。

#### 1. 丰盈自然变换的定义

设 $\mathcal{V}$ 是一个幺半闭范畴。我们想定义两个 $\mathcal{V}$-函子 $F, G : \mathcal{C} \to \mathcal{D}$ 之间的**丰盈自然变换**（$\mathcal{V}$-natural transformation）。在这种情况下，自然变换的每个分量 $\nu_a$ 将不再是一个集合中的箭头，而是 $\mathcal{V}$ 中的一个态射。

具体来说，对于每个对象 $a \in \mathcal{C}$，自然变换 $\nu$ 的分量 $\nu_a$ 是 $\mathcal{V}$ 中的一个态射：
$$
\nu_a : I \to \mathcal{D}(F(a), G(a))
$$
这里，$I$ 是 $\mathcal{V}$ 中的单位对象，$\mathcal{D}(F(a), G(a))$ 是 $F(a)$ 和 $G(a)$ 之间的同态对象。

这相当于在 $\mathcal{V}$ 的同态对象 $\mathcal{D}(F(a), G(a))$ 中选择一个“元素”，与普通范畴中在同态集 $\mathcal{D}(F(a), G(a))$ 中选择一个箭头类似。

#### 2. 自然性条件

在普通范畴中，自然性条件保证自然变换在函数之间是“兼容”的。也就是说，对于范畴 $\mathcal{C}$ 中的任意态射 $f: a \to b$，自然变换的分量 $\nu$ 必须使以下方程成立：
$$
\nu_b \circ F(f) = G(f) \circ \nu_a
$$
这个条件保证了自然变换与函子的作用一致。

在丰盈环境中，自然性条件稍微复杂一些，因为我们需要处理的是来自 $\mathcal{V}$ 的同态对象，而不是简单的箭头。然而，本质上自然性条件的思想是相同的：对于 $\mathcal{C}$ 中的每个箭头 $f : a \to b$，我们希望以下方程成立：
$$
\nu_b \circ F(f) = G(f) \circ \nu_a
$$
这个方程涉及到 $\mathcal{D}(F(a), G(b))$ 中的元素，并保证了在 $\mathcal{V}$ 范畴中自然变换的分量是兼容的。

#### 3. 自然性条件的图表表示

我们可以使用图表来更直观地表达自然性条件。在普通范畴中，这个条件可以表示为一个交换图表，确保不同路径的组合是相等的。在丰盈范畴中，自然性条件的图表表示如下：
$$
\begin{aligned}
I \otimes \mathcal{C}(a, b) &\to \mathcal{D}(F(b), G(b)) \otimes \mathcal{D}(F(a), F(b)) \\
\downarrow & \ \ \ \ \ \ \ \ \downarrow \\
\mathcal{C}(a, b) &\to \mathcal{D}(F(a), G(b))
\end{aligned}
$$
在这个图表中，左上角的 $I \otimes \mathcal{C}(a, b)$ 代表通过 $\nu_b$ 选择的同态对象，再通过 $F(f)$ 映射。而右侧则通过 $G(f)$ 和 $\nu_a$ 实现相同的映射。自然性条件就是保证图表的路径能够正确交换。

#### 4. 端（End）与丰盈自然变换

在普通范畴论中，自然变换的集合可以通过**端**（end）来描述。具体来说，自然变换的集合可以通过如下端来定义：
$$
[ \mathcal{C}, \mathcal{D} ](F, G) \cong \int_a \mathcal{D}(F(a), G(a))
$$
这个端表达式表示在所有对象 $a \in \mathcal{C}$ 上，我们选择同态集 $\mathcal{D}(F(a), G(a))$ 中的元素。

在丰盈环境中，情况类似。端仍然可以用于定义丰盈自然变换，不过这次的端是在 $\mathcal{V}$ 范畴中的对象，而不是集合。因此，丰盈自然变换的对象由以下端表达：
$$
[ \mathcal{C}, \mathcal{D} ](F, G) \cong \int_a \mathcal{D}(F(a), G(a))
$$
这里的端 $\int_a \mathcal{D}(F(a), G(a))$ 是 $\mathcal{V}$ 范畴中的一个对象，而不是集合。它捕捉了所有自然变换的分量在 $\mathcal{V}$ 中的结构。

#### 5. 总结

**$\mathcal{V}$-自然变换**是在丰盈范畴中用于描述两个 $\mathcal{V}$-函子之间的“兼容”映射的工具。每个自然变换的分量由单位对象 $I$ 到同态对象 $\mathcal{D}(F(a), G(a))$ 的箭头给出。自然性条件确保了这些分量与函子 $F$ 和 $G$ 的作用保持一致。通过引入端，我们可以系统地描述这些丰盈自然变换的结构，类似于普通范畴中的自然变换定义。

这种自然变换在范畴论的进一步应用中，特别是在丰盈范畴和高级函数式编程中，起到了至关重要的作用。

### -------------------------

### 20.4 Yoneda 引理（Yoneda Lemma）

**Yoneda 引理**是范畴论中的一个重要定理，它描述了函子 $\mathcal{C} \to \text{Set}$ 的结构，解释了如何通过观察一个对象的**同态集**来完全确定该对象的特性。在丰盈范畴的背景下，Yoneda 引理也有了对应的推广版本。

#### 1. 回顾普通 Yoneda 引理

在普通的范畴论中，Yoneda 引理描述了 Set-值函子的结构。设 $\mathcal{C}$ 是一个范畴，$F: \mathcal{C} \to \text{Set}$ 是一个 Set-值函子。Yoneda 引理表明，从 $\mathcal{C}$ 到 Set 的函子 $\mathcal{C}(c, -)$ 与 $F$ 之间的自然变换可以通过 $F(c)$ 来唯一确定：
$$
[\mathcal{C}, \text{Set}](\mathcal{C}(c, -), F) \cong F(c)
$$
这个同构意味着从 $\mathcal{C}(c, -)$ 到 $F$ 的所有自然变换（左侧）与 $F(c)$ 的元素集（右侧）一一对应。

#### 2. 推广到丰盈范畴

在丰盈范畴的情况下，我们将普通的同态集 $\mathcal{C}(c, -)$ 替换为一个来自幺半范畴 $\mathcal{V}$ 的同态对象。同时，Set-值函子 $F$ 也变为一个 $\mathcal{V}$-值函子。

假设我们有一个 $\mathcal{V}$-范畴 $\mathcal{C}$ 和一个 $\mathcal{V}$-值函子 $F: \mathcal{C} \to \mathcal{V}$。在丰盈的情境下，Yoneda 引理也描述了从 $\mathcal{C}(c, -)$ 到 $F$ 的 $\mathcal{V}$-自然变换如何与 $F(c)$ 的元素相关联。

#### 3. 弱版本的 Yoneda 引理

**弱版本的 Yoneda 引理**处理的是 $\mathcal{V}$-自然变换的集合，但它将结果转换为 $\mathcal{V}$ 中的元素集（通过选择全局元素）。具体地，假设 $F$ 是一个 $\mathcal{V}$-值函子，Yoneda 引理告诉我们，从 $\mathcal{V}$-自然变换的角度来看：
$$
\mathcal{V}\text{-nat}(\mathcal{C}(c, -), F) \cong \mathcal{V}(I, F(c))
$$
这里，$I$ 是 $\mathcal{V}$ 的单位对象，$F(c)$ 是 $\mathcal{V}$ 中的一个对象。这个表达式的右侧 $\mathcal{V}(I, F(c))$ 代表的是 $F(c)$ 的**全局元素**，即从单位对象 $I$ 到 $F(c)$ 的态射。

换句话说，$\mathcal{V}$-自然变换的集合与 $F(c)$ 的全局元素集合是同构的。

#### 4. 强版本的 Yoneda 引理

**强版本的 Yoneda 引理**不仅仅描述自然变换的集合，它处理的是 $\mathcal{V}$-自然变换的对象，直接使用 $\mathcal{V}$ 范畴中的对象来描述这些自然变换。这里的自然变换不再仅仅是元素的集合，而是 $\mathcal{V}$ 中的对象。

强版本的 Yoneda 引理使用 **端**（end）来定义自然变换的对象。具体来说，对于 $F$ 这样的 $\mathcal{V}$-值函子，强版本的 Yoneda 引理表示为：
$$
\int_x [\mathcal{C}(c, x), F(x)] \cong F(c)
$$
这里，$\int_x$ 表示 **端**，它将 $\mathcal{C}(c, x)$ 和 $F(x)$ 之间的同态对象的所有可能组合求值，类似于普通 Yoneda 引理中的“自然变换的集合”概念。

#### 5. 弱版本与强版本的比较

- **弱版本**的 Yoneda 引理关注的是自然变换的集合，它将结果映射为 $F(c)$ 的全局元素（即从单位对象 $I$ 到 $F(c)$ 的态射）。
- **强版本**的 Yoneda 引理则更关注自然变换本身的结构，它使用端来描述自然变换之间的关系，并且直接处理的是 $\mathcal{V}$ 中的对象，而非集合。

#### 6. 自然性条件的拓展

在普通的 Yoneda 引理中，自然性条件要求从 $\mathcal{C}(c, -)$ 到 $F$ 的每一个自然变换必须与范畴 $\mathcal{C}$ 的箭头相兼容。在丰盈范畴中，自然性条件的拓展依然存在，只是这次需要处理的是 $\mathcal{V}$ 中的对象与态射。

在丰盈版本的 Yoneda 引理中，自然性条件确保从 $\mathcal{C}(c, -)$ 到 $F$ 的自然变换保持 $\mathcal{C}$ 的结构。具体来说，自然变换的每个分量必须是与 $\mathcal{C}$ 的态射兼容的 $\mathcal{V}$ 中的态射。

#### 7. 总结

**丰盈 Yoneda 引理**的核心思想与普通版本一致，都是通过同态对象（而非同态集）中的信息来唯一确定一个 $\mathcal{V}$-值函子的结构。在丰盈版本中，自然变换不再是简单的集合中的箭头，而是幺半范畴 $\mathcal{V}$ 中的态射。

- **弱版本**将自然变换的集合与全局元素联系起来。
- **强版本**则使用端来处理自然变换的对象。

这个推广允许我们在更加丰富的数学背景下处理自然变换，扩展了范畴论在更复杂系统中的应用。

### -------------------------

### 20.5 加权极限（Weighted Limits）

**加权极限**是范畴论中的一种广义极限构造，它可以看作是普通极限的推广。普通极限依赖于交换三角形或图表中的结构，而加权极限允许通过“加权”来控制图表中的选择。加权极限在丰盈范畴中也有相应的推广，称为丰盈加权极限。

#### 1. 回顾普通极限

在普通范畴论中，极限是从索引范畴 $\mathcal{I}$ 到目标范畴 $\mathcal{C}$ 的函子 $D: \mathcal{I} \to \mathcal{C}$ 的一个普遍锥形构造。这个构造描述了一个对象 $L$ 和从 $L$ 到 $D$ 的各个对象 $D(i)$ 的一组态射，使得所有三角形交换。极限的基本概念可以用图示来表示，其中索引范畴 $\mathcal{I}$ 的对象映射到范畴 $\mathcal{C}$ 中的对象，而极限就是将这些对象通过锥体结构统一到一起的“顶点”对象 $L$。

对于极限的定义，锥体的边是从极限对象 $L$ 到每个 $D(i)$ 的态射，它们必须满足某种自然性条件，使得每个三角形都交换。

#### 2. 丰盈环境中的问题

当我们在丰盈范畴中考虑极限时，遇到的主要问题是，普通极限依赖于同态集 $\mathcal{C}(x, D(i))$ 的结构。在丰盈范畴中，同态集被替换为同态对象 $\mathcal{C}(x, D(i))$，这些对象并不总是像集合一样具有简单的“元素”。这就引发了一个问题：如何在丰盈范畴中定义类似的“锥体”？

##### 锥体的重新表述

我们可以将普通极限中的锥体重新表述为从常量函子 $\Delta L$ 到 $D$ 的自然变换。这意味着锥体可以看作是自然变换的集合：
$$
\text{Cone}(L, D) = [\mathcal{I}, \text{Set}](\Delta L, D)
$$
这个公式意味着，锥体可以通过选择同态集 $\mathcal{C}(L, D(i))$ 中的态射来构建自然变换。在丰盈范畴中，这种选择则变得更加复杂，因为同态对象可能是更复杂的结构，而不是简单的态射集合。

#### 3. 加权的引入

为了在丰盈范畴中更灵活地处理这种结构，我们引入了**加权**的概念。加权极限通过引入一个加权函子 $W: \mathcal{I} \to \text{Set}$ 来代替常量函子 $\Delta L$，为不同的对象赋予不同的权重。换句话说，锥体不再仅仅是从 $\mathcal{C}(x, D(i))$ 中选择一个态射，而是考虑了加权选择的影响。

在这个设置下，**加权锥体**由以下自然变换的集合来表示：
$$
\text{Cone}(W, D) = [\mathcal{I}, \text{Set}](W, \mathcal{C}(x, D*))
$$
这里，$W$ 是索引范畴 $\mathcal{I}$ 上的加权函子，而 $D$ 是目标范畴中的函子。通过这个加权函数，我们可以定义更加灵活的“锥体”，它不仅依赖于对象之间的态射，还包含了权重信息。

#### 4. 丰盈加权极限

在丰盈范畴中，我们可以直接推广这一构造。设 $\mathcal{C}$ 是一个丰盈于 $\mathcal{V}$ 的范畴，而 $W: \mathcal{I} \to \mathcal{V}$ 是一个加权函子，$D: \mathcal{I} \to \mathcal{C}$ 是一个目标函子。丰盈加权极限可以定义为：
$$
\mathcal{C}(x, \lim_W D) \cong [\mathcal{I}, \mathcal{V}](W, \mathcal{C}(x, D*))
$$
这里，$\mathcal{V}$ 替代了 $\text{Set}$，两边都表示 $\mathcal{V}$ 中的对象。同态对象 $\mathcal{C}(x, \lim_W D)$ 是从 $x$ 到加权极限对象 $\lim_W D$ 的态射，而右侧表示从 $W$ 到 $\mathcal{C}(x, D(i))$ 的自然变换的对象。

这个等式意味着，任何从 $x$ 到 $\lim_W D$ 的态射都可以通过自然变换来因子分解，这与普通极限的普遍性质一致。

#### 5. 加权余极限

加权极限的对偶是**加权余极限**。加权余极限通过对立范畴 $\mathcal{I}^{\text{op}}$ 来定义：
$$
\mathcal{C}(\text{colim}_W D, x) \cong [\mathcal{I}^{\text{op}}, \mathcal{V}](W, \mathcal{C}(D*, x))
$$
这里，$\text{colim}_W D$ 表示加权余极限，它也是通过自然变换的普遍性质来定义的，只不过这次是处理余锥体。

#### 6. 应用与重要性

加权极限和加权余极限在范畴论中是极为重要的工具，它们允许我们以更加灵活的方式处理对象之间的关系。通过引入加权函数，我们能够定义更加一般的极限和余极限，这些结构在丰盈范畴中的许多应用中尤为重要。

在普通范畴中，加权极限可以用于描述许多熟悉的构造，如：
- **端（End）**和**余端（Coend）**：端和余端本质上是加权极限和加权余极限的特殊形式。
- **Kan 扩张**：Kan 扩张是另一类可以通过加权极限和余极限描述的构造。

通过这种推广，丰盈加权极限在建模复杂系统时提供了更加强大的工具。例如，在编程语言理论中，它们可以用于描述和组合复杂的数据结构和过程。

#### 总结

加权极限通过引入加权函数，使得极限的定义更加灵活，能够处理更加复杂的对象关系。丰盈加权极限则是这个概念的进一步推广，它允许我们在丰盈范畴中构建和分析复杂的极限结构。

这些加权极限和余极限在许多数学和编程的领域中都有广泛的应用，例如端、Kan 扩张等。通过加权极限，我们能够将许多范畴论中的基本构造推广到更加复杂的丰盈范畴中。

### -------------------------

### 20.6 端作为加权极限（Ends as Weighted Limits）

**端**是范畴论中的一种特殊结构，通常可以看作是多个对象之间的一种极限构造。它与积或极限有许多共同点，但具有其独特的定义方式。**加权极限**为我们提供了描述端的一种更加广泛的框架，使得我们可以将端解释为加权极限，并进一步推广到丰盈范畴中。

#### 1. 什么是端？

端 (end) 通常用于描述在函子之间的自然变换，其构造与极限非常相似。简单来说，端可以被看作是多个态射的“平衡点”，在这个平衡点上，每个态射都相互一致。具体来说，对于一个从 $\mathcal{C}^{\text{op}} \times \mathcal{C} \to \text{Set}$ 的函子 $P$，端 $\int_c P(c, c)$ 是一个满足如下条件的对象 $e$：
- 存在一组投影 $\pi_c : e \to P(c, c)$。
- 对于 $\mathcal{C}$ 中的任意态射 $f : c \to c'$，投影满足 $P(f, c') \circ \pi_{c'} = P(c, f) \circ \pi_c$。

这些投影 $\pi_c$ 构成了端的基本结构，与极限的构造类似，它们描述了从端到各个对象的映射。

#### 2. 将端表达为加权极限

为了将端表述为加权极限，我们首先需要引入**同态函子** (Hom-functor) 作为加权。对某个从 $\mathcal{C}^{\text{op}} \times \mathcal{C} \to \mathcal{D}$ 的函子 $P$，我们使用同态函子 $Hom_\mathcal{C}$ 作为权重来定义端。这个权重选择的是 $\mathcal{C}(c, c)$ 中的同态对象，因此加权极限的定义为：
$$
\int_c P(c, c) = \lim_{Hom_\mathcal{C}} P
$$

这里，$P$ 是一个丰盈范畴中的函子，$\lim_{Hom_\mathcal{C}} P$ 表示基于同态函子 $Hom_\mathcal{C}$ 作为权重的加权极限。

#### 3. 普通范畴中的例子

在普通范畴（例如 Set-丰盈范畴）中，端的定义可以通过同构来验证。考虑从某个对象 $d$ 到加权极限 $\lim_{Hom_\mathcal{C}} P$ 的映射。根据定义，我们有：
$$
\mathcal{D}(d, \lim_{Hom_\mathcal{C}} P) \cong [\mathcal{C}^{\text{op}} \times \mathcal{C}, \text{Set}](Hom_\mathcal{C}, \mathcal{D}(d, P(*, *)))
$$
这里，$Hom_\mathcal{C}$ 是权重函子，而 $P$ 是我们定义的图表。上式中的同态集是从 $d$ 到加权极限的态射。我们可以使用 **Yoneda 引理** 来证明这个公式的合理性，并将自然变换的集合表示为端：
$$
\int_{c, c'} \text{Set}(\mathcal{C}(c, c'), \mathcal{D}(d, P(c, c')))
$$

通过这一公式，我们将端的定义简化为多个对象之间的自然变换，类似于极限的定义。

#### 4. 丰盈环境中的端

在丰盈环境中，我们将 Set 替换为一个更加一般的幺半范畴 $\mathcal{V}$。端的定义仍然适用，但现在两侧的结构都变得更加复杂。具体来说，我们有：
$$
\mathcal{C}(d, \lim_{Hom_\mathcal{C}} P) \cong [\mathcal{C}^{\text{op}} \times \mathcal{C}, \mathcal{V}](Hom_\mathcal{C}, \mathcal{C}(d, P(*, *)))
$$
其中，$[\mathcal{C}^{\text{op}} \times \mathcal{C}, \mathcal{V}]$ 表示从 $\mathcal{C}^{\text{op}} \times \mathcal{C}$ 到 $\mathcal{V}$ 的自然变换对象。同态对象 $\mathcal{C}(d, P(c, c'))$ 描述了 $d$ 到 $P$ 的各个对象之间的关系。

#### 5. 余端作为加权余极限

**余端**是端的对偶，类似地，我们可以将余端定义为一个加权余极限。余端的定义如下：
$$
\int_c P(c, c) = \text{colim}_{Hom_{\mathcal{C}^{\text{op}}}} P
$$
余端描述的是从某个对象到一组对象的映射出属性，与端的映射入属性相对。

#### 6. 总结

通过将端定义为加权极限，我们可以在更加一般的丰盈范畴中处理这一构造。这种推广使得端不仅能够处理普通范畴中的自然变换，还能够适用于更加复杂的丰盈范畴。借助同态函子作为权重，端的结构得到了更加灵活的定义，使其可以用于描述更多复杂的现象。

### -------------------------

### 20.7 Kan 扩张（Kan Extensions）详解

**Kan 扩张**是范畴论中一个重要的构造，它是通过某种方式将一个函子推广到一个更大的范畴的过程。可以说，Kan 扩张为我们提供了在不同范畴之间“平滑”转换函子的工具，极限和余极限都是 Kan 扩张的特殊情况。在本节中，我们将深入理解如何将 Kan 扩张看作加权极限和加权余极限。

#### 1. 什么是 Kan 扩张？

首先，Kan 扩张分为两类：**左 Kan 扩张**和**右 Kan 扩张**。

- **右 Kan 扩张**描述的是一个函子如何通过向“前延展”到一个更大的范畴，它为我们提供了一种以保持结构的方式从范畴 $\mathcal{B}$ 到 $\mathcal{D}$ 推出新的函子的方法。
- **左 Kan 扩张**则是通过“向后延展”来定义的，主要处理的是逆向的映射。

我们将从右 Kan 扩张开始，因为它与极限的定义更接近。

#### 2. 右 Kan 扩张的定义

右 Kan 扩张 $Ran_P F$ 是给定范畴中的某种“最优”函子扩展。具体来说，对于两个范畴 $\mathcal{B}$ 和 $\mathcal{D}$，以及两个函子 $P: \mathcal{C} \to \mathcal{B}$ 和 $F: \mathcal{C} \to \mathcal{D}$，右 Kan 扩张定义为一个函子 $Ran_P F: \mathcal{B} \to \mathcal{D}$，满足如下的条件：对于 $\mathcal{D}$ 中的任意对象 $d$，有：
$$
\mathcal{D}(d, (Ran_P F)(e)) \cong \int_c \mathcal{B}(e, P(c)) \pitchfork \mathcal{D}(d, F(c))
$$

其中，$\pitchfork$ 表示一类自然变换。直观上，这意味着 $Ran_P F$ 是以“最自然的方式”将 $F$ 延展到整个 $\mathcal{B}$，使得 $F$ 在 $P$ 上的行为得以保留。

#### 3. 从极限到 Kan 扩张

在 Set-丰盈范畴中，极限和余极限是 Kan 扩张的特例。特别地，我们可以通过奇点函子（即将所有对象映射到单位对象的函子）来将极限或余极限定义为 Kan 扩张。在丰盈环境中，加权极限则进一步推广了这一构造，使得 Kan 扩张可以看作加权极限。

右 Kan 扩张的公式为：
$$
(Ran_P F)(e) \cong \int_c \mathcal{B}(e, P(c)) \pitchfork F(c)
$$

这个公式表明，右 Kan 扩张是基于从范畴 $\mathcal{B}$ 中的对象 $e$ 到范畴 $\mathcal{C}$ 中的对象 $c$ 的自然变换集的。

#### 4. 推导 Kan 扩张公式

为了更好地理解 Kan 扩张，特别是右 Kan 扩张，我们可以通过推导它的公式来深入理解其本质。

首先，从 $\mathcal{D}(d, (Ran_P F)(e))$ 开始：
$$
\mathcal{D}(d, (Ran_P F)(e))
$$

代入右 Kan 扩张的定义：
$$
\mathcal{D}(d, \int_c \mathcal{B}(e, P(c)) \pitchfork F(c))
$$

使用同态函子的连续性，可以将端运算移出同态集：
$$
\int_c \mathcal{D}(d, \mathcal{B}(e, P(c)) \pitchfork F(c))
$$

接着，我们应用自然变换的定义，将其表达为同态集的集合：
$$
\int_c \text{Set}(\mathcal{B}(e, P(c)), \mathcal{D}(d, F(c)))
$$

这与加权极限的定义非常相似。换句话说，右 Kan 扩张可以通过一个加权极限来表达。最终公式为：
$$
(Ran_P F)(e) = \lim_{\mathcal{B}(e, P(-))} F
$$

这就是右 Kan 扩张作为加权极限的定义。

#### 5. 左 Kan 扩张

左 Kan 扩张 $Lan_P F$ 是右 Kan 扩张的对偶。对于左 Kan 扩张，公式为：
$$
(Lan_P F)(e) = \text{colim}_{\mathcal{B}(P(-), e)} F
$$

与右 Kan 扩张相似，左 Kan 扩张也可以被视为加权余极限。

#### 6. 总结

- **右 Kan 扩张**和**左 Kan 扩张**是范畴论中两个重要的概念，它们分别通过极限和余极限来推广函子的定义。
- **加权极限**为 Kan 扩张提供了一个更加通用的框架，在丰盈环境中尤其有用。
- 通过 Yoneda 引理和自然变换的定义，我们可以推导出 Kan 扩张的具体公式，从而更加深入理解它的结构。

Exercise 20.7.1 要求推导左 Kan 扩张的公式，这类似于右 Kan 扩张的推导过程，但使用的是余极限的概念。

### -------------------------

### 20.7 Kan 扩张（Kan Extensions）详解

#### 什么是 Kan 扩张？

在范畴论中，**Kan 扩张**是一种将函子扩展到一个更大范畴的方式。这个扩展既保持原有的结构，又确保映射的自然性。Kan 扩张分为两种：**左 Kan 扩张**和**右 Kan 扩张**。

- **左 Kan 扩张**：通过给定的函子向后延展。我们希望通过已有的数据构造新的结构。
- **右 Kan 扩张**：通过给定的函子向前延展，它描述了如何将一个小范畴的结构延展到一个更大的范畴中。

Kan 扩张在范畴论中非常重要，因为它可以表达极限和余极限，也可以描述更复杂的数学现象，比如函子之间的最优延拓。

#### 右 Kan 扩张的定义

右 Kan 扩张可以直观地理解为一种“最优的向前延展”。设有范畴 $\mathcal{C}$、$\mathcal{B}$ 和 $\mathcal{D}$，以及两个函子：
- $P: \mathcal{C} \to \mathcal{B}$，
- $F: \mathcal{C} \to \mathcal{D}$。

右 Kan 扩张 $Ran_P F$ 是一个从 $\mathcal{B}$ 到 $\mathcal{D}$ 的函子，它将 $F$ 的结构最优地延展到 $\mathcal{B}$。

更具体地，$Ran_P F$ 在 $\mathcal{B}$ 中的每个对象 $e$ 处的值定义为：
$$
(Ran_P F)(e) \cong \int_{c \in \mathcal{C}} \mathcal{B}(e, P(c)) \pitchfork F(c)
$$
这表示为：$Ran_P F$ 是通过从 $P$ 在 $c$ 上的结构（$\mathcal{B}(e, P(c))$）和 $F$ 在 $c$ 上的值（$F(c)$）的最优结合得到的。

#### 什么是极限和余极限？

极限和余极限是 Kan 扩张的特例。极限可以看作是在给定数据下，某种“最优的通用对象”。比如，给定一系列对象和态射，极限是一个对象，它与其他所有对象通过态射保持一致。

极限的定义是通过一个锥形图表。图表中的锥体形成一个封闭的结构，确保所有的态射组合在一起构成一个最优的对象。余极限则是极限的对偶，它描述了一种“最优的扩展”。

通过奇点函子（constant functor），我们可以将极限和余极限看作特殊的 Kan 扩张。

#### 右 Kan 扩张的推导

现在，让我们推导右 Kan 扩张的公式。

1. 从一个对象 $d$ 到右 Kan 扩张 $Ran_P F(e)$ 的同态集开始：
   $$
   \mathcal{D}(d, (Ran_P F)(e))
   $$

2. 代入右 Kan 扩张的定义：
   $$
   \mathcal{D}(d, \int_c \mathcal{B}(e, P(c)) \pitchfork F(c))
   $$

3. 使用同态函子的连续性，我们可以将端（$\int$）移出同态集：
   $$
   \int_c \mathcal{D}(d, \mathcal{B}(e, P(c)) \pitchfork F(c))
   $$

4. 然后，我们将 $\pitchfork$ 运算替换为自然变换的定义。pitchfork $\pitchfork$ 的意思是构造一个从 $\mathcal{B}(e, P(c))$ 到 $F(c)$ 的自然变换：
   $$
   \int_c \text{Set}(\mathcal{B}(e, P(c)), \mathcal{D}(d, F(c)))
   $$

5. 最终，我们可以将这个自然变换的定义与加权极限的定义对应起来：
   $$
   \mathcal{D}(d, \lim_{\mathcal{B}(e, P(-))} F)
   $$

这个公式意味着右 Kan 扩张可以视为一个加权极限。对于每一个对象 $e$，右 Kan 扩张通过选择从 $\mathcal{B}(e, P(c))$ 的自然变换来最优地构造出 $F(c)$ 的加权极限。

#### 右 Kan 扩张的最终公式

推导的最终公式可以写为：
$$
(Ran_P F)(e) = \lim_{\mathcal{B}(e, P(-))} F
$$
换句话说，右 Kan 扩张是通过某种自然变换的“加权极限”构造的。这个公式在丰盈环境中同样有效。

#### 左 Kan 扩张的定义

左 Kan 扩张是右 Kan 扩张的对偶。它的定义是通过加权余极限来表示的。

设 $P: \mathcal{C} \to \mathcal{B}$ 和 $F: \mathcal{C} \to \mathcal{D}$，那么左 Kan 扩张 $Lan_P F$ 定义为：
$$
(Lan_P F)(e) = \text{colim}_{P(-), e} F
$$
这意味着左 Kan 扩张是通过对对象的加权余极限来构造的，它将对象的结构扩展到新的范畴。

#### 小结

- **右 Kan 扩张**：定义为通过一个加权极限来最优地扩展函子 $F$ 的结构。
- **左 Kan 扩张**：是右 Kan 扩张的对偶，使用加权余极限进行构造。
- **极限和余极限**：它们是 Kan 扩张的特殊情况，通过常量函子（奇点）来实现的。
  

通过理解 Kan 扩张，我们可以更好地理解范畴论中的函子扩展机制。

### -------------------------

### 第20章：丰盈（Enrichment）详解

#### 20.1 丰盈范畴（Enriched Categories）

**丰盈范畴**的概念是范畴论中的一个扩展，它允许我们用更丰富的结构来代替通常的同态集。在普通的范畴中，两个对象之间的同态集是集合，但在丰盈范畴中，我们使用对象（同态对象）来代替这些同态集。这种丰盈结构能够处理更复杂的数学现象，例如在不同的范畴中刻画对象之间的关系。

##### Set-theoretical foundations（集合论基础）

范畴论依赖于集合论的基础，但集合本身可能不够灵活，无法捕捉到更复杂的结构。丰盈范畴允许我们用不同的幺半范畴（monoidal categories）来替代集合，使得我们可以建模更复杂的系统。例如，在丰盈范畴中，两个对象之间的“关系”不再是简单的箭头，而是可以更复杂地体现为某种对象（同态对象）。

##### Hom-Objects（同态对象）

在丰盈范畴中，两个对象之间的关系由一个**同态对象**来表示。虽然同态对象不像同态集那样有具体的元素，但它们能捕捉到两个对象之间更复杂的关系。通过同态对象的态射，我们能够将范畴论中的操作扩展到更广泛的结构中。换句话说，同态对象是用来替代普通范畴中的箭头（态射）的。

##### Enriched Categories（丰盈范畴）

**丰盈范畴**的核心是引入一个幺半范畴 $\mathcal{V}$，这个范畴有张量积和单位对象。丰盈范畴 $\mathcal{C}$ 的同态对象来自 $\mathcal{V}$。具体来说，丰盈范畴中的复合由幺半范畴中的张量积来定义，而单位箭头则由幺半范畴中的单位对象来定义。

##### Examples（示例）

一个普通的范畴可以被视为在 $(\textbf{Set}, \times, 1)$ 上丰盈的范畴。在更复杂的结构中，比如 2-范畴（2-categories），我们可以在 Cat 范畴上丰盈。Cat 范畴中的对象是范畴，态射是函子，2-态射是自然变换。

##### Preorders（预序）

丰盈并不总是增加更多的结构。在预序结构中，两个对象之间的同态对象只有两种可能：True 或 False。这种丰盈结构对应着对象之间的顺序关系。

##### Self-enrichment（自丰盈）

自丰盈意味着一个范畴可以在自身上丰盈。比如，Set 范畴可以看作是自丰盈的，因为它的同态对象是集合。类似地，幺半闭范畴通常是自丰盈的，这使得我们可以在这种范畴中定义更复杂的结构。

#### 20.2 $\mathcal{V}$-函子（V-Functors）

**$\mathcal{V}$-函子**是从一个丰盈范畴到另一个丰盈范畴的映射，它不仅要映射对象，还要映射同态对象。与普通范畴的函子不同，$\mathcal{V}$-函子需要保持丰盈结构，这意味着它必须尊重同态对象之间的张量积和单位对象。

##### The Hom-functor（同态函子）

**同态函子**是一个重要的丰盈函子，它将对象对映射到它们之间的同态对象。这个函子是丰盈范畴的一个基本构件，它帮助我们定义自然变换和其他复杂的范畴构造。

##### Enriched co-presheaves（丰盈余预层）

**余预层**是一个从一个范畴到 Set 的函子。在丰盈范畴中，余预层可以推广为 $\mathcal{V}$-值函子。这个扩展允许我们在更复杂的结构中处理余预层的概念。

##### Functorial strength and enrichment（函子强度与丰盈）

函子的**强度**是指它能够处理张量积的能力。在丰盈范畴中，强度与丰盈密切相关。自丰盈范畴中的每个强函子都是自动丰盈的，这为我们在编程中处理 monads（幺半群）提供了有力支持。

#### 20.3 $\mathcal{V}$-自然变换（V-Natural Transformations）

自然变换是两个函子之间的映射。在丰盈范畴中，自然变换的每个分量是从单位对象到同态对象的箭头。这种 $\mathcal{V}$-自然变换不仅仅是两个函子之间的简单映射，它保留了丰盈范畴中的结构，并且必须满足自然性条件。

#### 20.4 Yoneda 引理（Yoneda Lemma）

**Yoneda 引理**在丰盈环境中的推广为 $\mathcal{V}$-自然变换的集合。我们使用 $I \to \mathcal{V}(F(c), G(c))$ 的箭头来捕捉自然变换。强版本的 Yoneda 引理则使用端（end）来表示自然变换的对象。

#### 20.5 加权极限（Weighted Limits）

**加权极限**是极限的一个推广，它引入了权重来为每个对象加上不同的“重要性”。加权极限不仅允许我们在范畴中定义极限，还可以处理更加灵活的极限形式。加权极限可以在丰盈范畴中表示为自然变换的集合，或者用更普遍的结构来刻画。

#### 20.6 端作为加权极限（Ends as Weighted Limits）

**端（ends）**可以被看作是一种特殊的极限，它的结构类似于锥体。端可以通过加权极限来表示，这一形式推广到丰盈范畴中，允许我们在复杂的范畴结构中计算端。通过端的加权极限公式，我们可以看到端与极限的深层联系。

#### 20.7 Kan 扩张（Kan Extensions）

**Kan 扩张**是一种将函子扩展到更大范畴的自然方式。在普通范畴中，极限和余极限是 Kan 扩张的特例。在丰盈环境中，Kan 扩张可以被表示为加权极限或加权余极限。右 Kan 扩张可以看作通过极限来构造最优的函子扩展，而左 Kan 扩张则通过余极限来构造。

- **右 Kan 扩张**：使用加权极限来扩展函子。
- **左 Kan 扩张**：使用加权余极限来扩展函子。

### 总结

**丰盈范畴**通过将同态集替换为同态对象，允许我们在更复杂的结构中刻画对象之间的关系。这为范畴论提供了极大的灵活性，使得我们能够处理更广泛的数学现象。从余预层、自然变换到 Yoneda 引理，再到极限、端以及 Kan 扩张，丰盈范畴扩展了这些基本概念，使其能够应用于更复杂的数学结构。

这种扩展不仅为理论数学提供了工具，也为计算机科学中的编程语言设计、类型系统和幺半群结构提供了坚实的基础。在这个扩展的框架中，很多熟悉的范畴论结构可以重新表述为加权极限或余极限，从而揭示出它们与 Kan 扩张的深层联系。

### -------------------------






























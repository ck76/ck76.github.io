[toc]

这段文字讨论了**递归**和**自然数**的引入与消去规则，主要通过范畴论的角度来解释如何定义自然数及其递归结构。

### 1. **递归的概念**：
递归是一种通过将复杂任务分解为简单步骤来解决问题的模式。每一步通过之前的步骤定义，递归结构可以是无限的。正如在两个镜子之间的反射中，我们看到的图像是前一个图像的“继承者”一样，递归也是基于这种“继承”的概念。

### 2. **自然数的定义**：
- 自然数集合是通过两个基本规则定义的：**引入规则**和**消去规则**。
- **引入规则**是定义自然数的起点。零（$$Z$$）通过从终端对象映射到自然数对象来定义，即$$Z: 1 \to N$$。
- 继承者（$$S$$）表示自然数的“下一个”数字，即对于每一个自然数$$n$$，通过箭头$$S: N \to N$$得到其继承者$$S(n)$$。
- 使用这些规则，我们可以构造出任意自然数，如$$One = S(Z)$$和$$Two = S(S(Z))$$。

#### 在Haskell中的实现：
```haskell
data Nat where
    Z :: Nat
    S :: Nat -> Nat

zero, one, two :: Nat
zero = Z
one = S zero
two = S one
```
这里的$$Z$$表示零，$$S$$表示继承者，每个自然数通过递归的方式构造。

### 3. **消去规则**：
消去规则允许我们从自然数中提取信息。它的复杂性在于其递归性质。对于自然数$$N$$，我们通过一个函数$$h: N \to a$$定义一个映射，其中$$h$$可以分解为两个箭头：
- 第一个箭头$$init: 1 \to a$$，表示从$$Z$$开始生成的第一个元素。
- 第二个箭头$$step: a \to a$$，表示如何从当前元素生成下一个元素。

递归的核心是通过$$init$$和$$step$$生成一个序列$$a_0, a_1, a_2, \dots$$，其中：
- $$a_0 = init$$，即从零生成的初始元素；
- $$a_1 = h \circ S \circ Z$$，即从零的继承者生成的下一个元素；
- $$a_2 = h \circ S \circ S \circ Z$$，以此类推。

这些规则可以描述递归映射：所有递归映射$$h$$都可以用一对$$init$$和$$step$$来唯一确定。消去规则的作用是将任意自然数映射到目标对象上，且这些映射必须是递归的。

### 4. **递归映射的唯一性**：
递归映射的唯一性要求确保从$$Z$$和$$S$$生成的自然数序列没有其他不属于自然数的数字（例如，不能在序列中插入其他数字如$$*1$$）。这意味着每个自然数序列都是由$$Z$$和$$S$$唯一生成的。

### 总结：
递归通过定义起点（$$Z$$）和继承者（$$S$$）来生成自然数。引入规则负责构造自然数，而消去规则通过递归映射从自然数中提取信息。所有从自然数到其他对象的递归映射都可以通过一个初始值（$$init$$）和递归步（$$step$$）唯一确定。这种定义自然数和递归的方式在范畴论和编程语言中都有重要应用，例如在Haskell中用递归来定义自然数。



### ----------------------

在编程中，**消去规则**（也称为递归消去规则）通常用于定义递归函数，它允许我们将自然数映射到其他对象。本文讨论了如何在 Haskell 中通过递归器 `rec` 来实现递归函数，并通过自然数类型 `Nat` 实现加法。

### 1. **递归器的定义**：
在 Haskell 中，递归器 `rec` 是一个通用的工具，它接受两个参数：
- **`init`**：初始值，表示递归的起点。
- **`step`**：递归步，表示如何通过递归将当前的值转换为下一个值。

```haskell
rec :: a -> (a -> a) -> (Nat -> a)
rec init step = \n ->
  case n of
    Z -> init
    (S m) -> step (rec init step m)
```

- **解释**：
  - 如果递归数 `n` 是零 (`Z`)，那么我们返回初始值 `init`。
  - 如果 `n` 是某个数的继承者 (`S m`)，我们递归地应用 `rec`，并将结果传递给 `step` 函数。

### 2. **使用递归器实现加法**：
我们可以通过递归器 `rec` 实现自然数加法。例如，下面是如何定义加法的：

```haskell
plus :: Nat -> Nat -> Nat
plus n = rec init step
  where
    init = n
    step = S
```

- **解释**：
  - `init = n`：初始值是 `n`，即加法中的第一个数。
  - `step = S`：每次递归时，使用继承者函数 `S` 来增加结果。

通过 `plus n m`，我们创建一个函数，它接受另一个自然数 `m`，并将 `n` 加到 `m` 上。如果 `m` 是零，则返回 `n`；如果 `m` 是继承者，则递归地处理 `m` 的前一个值。

### 3. **直接实现加法**：
尽管递归器 `rec` 是一种通用方法，程序员通常更喜欢直接实现递归函数。在 Haskell 中，我们可以用以下方式实现加法：

```haskell
plus :: Nat -> Nat -> Nat
plus n m = case m of
  Z -> n
  (S k) -> S (plus k n)
```

- **解释**：
  - 如果 `m` 是零 (`Z`)，那么结果是 `n`。
  - 如果 `m` 是某个数 `k` 的继承者 (`S k`)，我们递归地对 `k` 和 `n` 进行加法运算，并将结果传递给 `S`。

### 4. **迭代与递归的对比**：
- **迭代**：在命令式语言中，程序员通常使用迭代来代替递归。迭代通过一个明确的顺序执行多个步骤，通常对应于自然的流程（如循环）。
  
- **递归**：递归适用于处理递归定义的数据结构，如列表或树。递归通过假设前面的步骤已经完成，直接处理当前步骤。

**尾递归优化**：在编译器中，递归通常会被优化为循环形式，这被称为**尾递归优化**，以提高程序的效率。

### 5. **练习：柯里化加法的递归实现**：
题目要求实现一个柯里化版本的加法，将其映射为一个从自然数 `N` 到函数对象 `N^N` 的映射。

提示中给出的类型：
- `init :: Nat -> Nat`
- `step :: (Nat -> Nat) -> (Nat -> Nat)`

我们可以通过递归器 `rec` 来实现该映射：

```haskell
plusCurried :: Nat -> (Nat -> Nat)
plusCurried n = rec init step
  where
    init = \m -> n  -- 初始值是将 n 加到任意 m 上
    step = \f -> (\m -> S (f m))  -- 每次递归调用 f，并将结果传给 S
```

- **解释**：
  - `init` 是一个函数，它将 `n` 作为初始值，作用到另一个自然数 `m` 上。
  - `step` 是递归步骤，它接收一个函数 `f`，并生成一个新函数。这个新函数将 `f` 递归作用于 `m`，然后将结果传递给继承者 `S`。

### 总结：
在编程中，递归和迭代是两种常见的解决问题的方式。递归器 `rec` 为我们提供了一种通用的递归实现方法，在处理自然数和其他递归数据结构（如列表、树）时非常有效。通过递归器实现的加法展示了如何使用递归方法分解复杂的操作。

### ---------------------------

在7.2节中，我们详细讨论了**列表（Lists）**的定义及其递归规则。列表是编程中最基本的数据结构之一，尤其在Haskell等函数式编程语言中，列表具有广泛的应用。以下将通过更详细的解释和Haskell代码展示如何定义和操作列表，以及如何使用消去规则和折叠来操作列表。

### 1. **列表的定义**

一个列表要么是**空的（Nil）**，要么是由**头部元素（Cons）**和尾部列表组成的。这种定义自然是递归的，因为一个列表可以是一个元素后跟另一个列表，而这个列表本身可以是空的或再由更多元素构成。

**引入规则（Constructor Rules）：**
- **Nil**：表示空列表。
- **Cons**：表示一个列表，由一个元素`a`和另一个列表`L_a`组成。

在Haskell中，这可以定义为：

```haskell
data List a where
  Nil :: List a
  Cons :: (a, List a) -> List a
```

- **Nil**表示空列表。
- **Cons**表示一个非空列表，由一个元素和另一个列表组成。

### 2. **消去规则（Elimination Rules）**

假设我们有一个从`List a`映射到某个类型`c`的函数`h`。为了从列表中消去数据，我们需要定义如何处理`Nil`和`Cons`。

在消去规则中，我们引入了两个箭头：
- **`init`**：从空列表`Nil`映射到结果类型`c`的初始值。
- **`step`**：处理一个非空列表的递归步，即将头部元素和递归处理后的尾部结果结合起来，生成新的结果。

这个递归模式可以表示为一个函数`recList`，它接受初始值`init`和递归步`step`，并递归处理列表：

```haskell
recList :: c -> ((a, c) -> c) -> (List a -> c)
recList init step = \as ->
  case as of
    Nil -> init
    Cons (a, as) -> step (a, recList init step as)
```

- 如果列表是空的（`Nil`），返回初始值`init`。
- 如果列表是非空的（`Cons`），递归处理列表的尾部，并将头部元素和递归结果传递给`step`函数。

### 3. **Haskell 中的列表语法**

Haskell 中的列表是一种非常常用的数据结构，因此Haskell提供了简化的内置语法：
- 列表类型`[a]`表示`List a`。
- `Nil`对应空列表`[]`。
- `Cons`对应中缀构造函数`:`。

例如，可以对列表进行模式匹配：

```haskell
h :: [a] -> c
h [] = -- 处理空列表的情况
h (a : as) = -- 处理非空列表的情况
```

### 4. **折叠（Fold）**

折叠是一种消去规则的具体实现形式，它将一个列表递归地“折叠”成一个单一的值。这种操作在Haskell中被称为**`foldr`**（右折叠），它的类型签名如下：

```haskell
foldr :: (a -> c -> c) -> c -> [a] -> c
```

- `step`：处理当前元素与递归结果的函数。
- `init`：空列表时的初始值。
- `[a]`：要折叠的列表。

`foldr`的递归实现类似于我们定义的`recList`：

```haskell
foldr step init = \as ->
  case as of
    [] -> init
    (a : as) -> step a (foldr step init as)
```

通过`foldr`，我们可以实现许多常见的列表操作，例如求和：

```haskell
sum :: [Nat] -> Nat
sum = foldr plus Z
```

在这里，`sum`函数使用`foldr`将自然数列表中的元素相加。

### 5. **练习题**

#### 练习 7.2.1：自然数的一元编码

**问题**：如果我们用终端对象（`1`）代替列表中的元素`a`，会发生什么？提示涉及到自然数的**一元编码**。

**解答**：
- 如果用终端对象`1`代替`a`，列表中的每个元素都是相同的，因此这个列表只表示元素的**数量**。这就是自然数的一元编码：列表的长度对应于自然数的值。

#### 练习 7.2.2：从`List a`映射到`1 + a`的映射

**问题**：从列表`[a]`映射到`Maybe a`（即`1 + a`）的映射有多少种？我们能用列表递归器实现它们吗？

**解答**：
- `Maybe a`可以是`Nothing`或`Just a`。通过递归器，我们可以定义一个函数从列表中提取第一个元素，如果列表为空则返回`Nothing`。

```haskell
h :: [a] -> Maybe a
h [] = Nothing
h (a : as) = Just a
```

这是从`List a`映射到`Maybe a`的一个简单实现。

#### 练习 7.2.3：提取列表的第三个元素

**问题**：实现一个函数，从列表中提取第三个元素，如果列表不够长则返回`Maybe a`。

**解答**：
可以通过递归和模式匹配实现：

```haskell
third :: [a] -> Maybe a
third (_ : _ : a : _) = Just a
third _ = Nothing
```

- 如果列表有至少三个元素，返回第三个元素。
- 如果列表不足三个元素，返回`Nothing`。

### 总结：

- **列表**是一种递归定义的数据结构，由两个引入规则：`Nil`和`Cons`。
- 通过递归器`recList`，可以对列表进行递归操作，类似于`foldr`折叠。
- 列表的递归消去规则允许我们定义许多实用的函数，包括求和、提取元素等。在Haskell中，`foldr`提供了一种方便的方式来实现递归操作。
- 练习题展示了如何通过列表递归器实现各种操作，包括提取元素和实现列表的一元编码。

### ---------------

在7.3节中，讨论了**函子性（Functoriality）**，它涉及如何在保留数据结构的同时转换其内容。在Haskell中，列表是一种常见的递归数据结构，而**函子性**的核心思想就是能够将一个函数应用到列表的每个元素上，从而得到一个新的列表。

### 1. **函子性的概念**

函子性本质上是一种转换数据结构“内容”的能力。在范畴论的背景下，函子是从一个范畴到另一个范畴的映射，同时保留了范畴中的结构。在编程中，我们可以把这种结构转换理解为对数据结构（如列表）的映射。

具体来说，对于列表`L_a`，它包含类型`a`的元素。给定一个函数`f : a -> b`，我们希望将`f`应用于列表中的每个元素，将`L_a`映射为一个包含类型`b`的列表`L_b`。

### 2. **如何定义列表的映射**

列表是一种递归数据结构，由两个基本构造：
- **Nil**：空列表。
- **Cons**：由一个元素和另一个列表构成。

为了将类型`L_a`映射为类型`L_b`，我们需要定义一个从列表`L_a`到`L_b`的映射`h : L_a -> L_b`。这个过程需要两个步骤：
1. 当输入是空列表时，输出也应该是空列表。
2. 当输入是非空列表时，递归地对列表的头部应用函数`f`，并对尾部继续递归。

#### 2.1. **映射空列表**

空列表的映射非常简单：空列表中的内容本质上是“无”，所以它可以直接映射为另一个类型的空列表。

```haskell
h(Nil_a) = Nil_b
```

即，空列表`L_a`被映射为空列表`L_b`。

#### 2.2. **映射非空列表**

对于非空列表`Cons (a, L_a)`，我们将头部元素`a`通过函数`f`映射为`b`，并递归地将`L_a`映射为`L_b`：

```haskell
h(Cons_a (a, L_a)) = Cons_b (f a, h L_a)
```

### 3. **列表映射的定义（Haskell代码实现）**

我们可以使用递归器来定义一个列表映射函数。Haskell中，递归器可以通过`recList`函数实现，类似于前面讨论的自然数递归器。

```haskell
mapList :: (a -> b) -> List a -> List b
mapList f = recList init step
  where
    init = Nil
    step (a, bs) = Cons (f a, bs)
```

- `init = Nil`：空列表映射为空列表。
- `step (a, bs)`：非空列表通过递归将元素`a`应用函数`f`，然后将其与映射后的尾部列表`bs`合并。

#### 3.1. **使用内置语法的实现**

在Haskell中，列表有内置的语法表示。我们可以直接定义`map`函数来实现列表的映射：

```haskell
map :: (a -> b) -> [a] -> [b]
map f [] = []
map f (a : as) = f a : map f as
```

- 如果输入列表是空的，返回空列表`[]`。
- 如果输入列表是非空的，递归地对头部元素`a`应用函数`f`，并对尾部列表`as`进行递归映射。

### 4. **一个错误的列表映射（badMap）**

我们可以考虑另一种不正确的映射实现，假设我们忽略了头部元素，只递归地映射尾部列表：

```haskell
badMap :: (a -> b) -> [a] -> [b]
badMap f [] = []
badMap f (a : as) = badMap f as
```

在这种情况下，每次递归调用都丢弃了当前的头部元素，只对尾部进行递归。这样做会导致所有头部元素被丢弃，最终返回一个空列表。这个函数的问题在于它忽略了对头部元素的处理。

**为什么这个实现是错误的？**

当我们将这个`badMap`应用于任何函数时，它都会丢弃列表中的所有元素。例如，如果我们将`badMap`应用于恒等函数`id`，原本我们希望得到原列表，但是由于`badMap`丢弃了所有元素，返回的将是空列表。

```haskell
badMap id [1, 2, 3] == []
```

这是一个错误的行为，因为正确的`map`应该返回原列表。

### 5. **总结**

- **函子性**表示将一个函数应用到列表的每个元素上，并保持列表的结构不变。
- 在Haskell中，`map`是列表的函子性操作，它将函数作用于列表的每个元素，生成一个新的列表。
- 列表的映射可以通过递归器`recList`实现，也可以直接使用内置的语法和模式匹配来定义`map`函数。
- 不正确的映射函数（如`badMap`）忽略了列表中的元素，导致不符合预期的行为。我们将在下一章进一步探讨为什么这类错误会产生问题。

### 6. **示例**

```haskell
-- 正确的 map 函数
map :: (a -> b) -> [a] -> [b]
map f [] = []
map f (x:xs) = f x : map f xs

-- 错误的 map 函数
badMap :: (a -> b) -> [a] -> [b]
badMap f [] = []
badMap f (x:xs) = badMap f xs

-- 测试
main = do
  print $ map id [1, 2, 3]       -- [1, 2, 3]
  print $ badMap id [1, 2, 3]    -- []
```

- 正确的`map id [1, 2, 3]`会返回原列表`[1, 2, 3]`。
- 错误的`badMap id [1, 2, 3]`返回空列表`[]`。

通过对比，我们可以看到，函数式编程中的函子性通过保持数据结构的完整性和元素的映射规则，确保了程序的健壮性和正确性。


### Well-formed paths 详解：

图中展示了路径（paths）的良构性判断规则，主要包含以下两条规则：

#### 1. **变量路径规则（Path for Variables）**
$$
\frac{x : val \in \Gamma}{\Gamma \vdash_{wf} x}
$$
**解释**：如果变量 $x$ 是上下文 $\Gamma$ 中的一个值 ($x : val \in \Gamma$)，则可以判断 $x$ 是一个良构路径 ($\Gamma \vdash_{wf} x$)。这意味着变量路径是良构的，如果它在上下文中存在，并且是一个值类型。

#### 2. **选择器路径规则（Path for Selectors）**
$$
\frac{\Gamma \vdash_{wf} p}{\Gamma \vdash_{wf} p.n}
$$
**解释**：如果路径 $p$ 是良构的路径 ($\Gamma \vdash_{wf} p$)，则路径 $p.n$ 也是一个良构路径 ($\Gamma \vdash_{wf} p.n$)。这里，$n$ 是 $p$ 的一个字段或方法调用，良构性继承自 $p$ 的良构性。

### 总结：

- **变量路径规则**：如果变量在上下文中是一个值类型，则它是良构路径。
- **选择器路径规则**：如果路径 $p$ 是良构路径，那么对 $p$ 进行字段选择或方法调用也是良构路径。

这两个规则定义了如何从基本的良构变量逐步构建更复杂的良构路径，确保路径的语法和语义都保持正确。

### --------------------

### Well-formed lifetimes 详解：

图中展示了生命周期（lifetime）的良构性判断规则，主要包括两条规则：

#### 1. **一般生命周期规则（General Lifetime Rule）**
$$
\frac{\alpha : lft \in \Gamma}{\Gamma \vdash_{wf} \alpha}
$$
**解释**：如果生命周期标识符 $\alpha$ 属于上下文 $\Gamma$，即 $\alpha$ 是上下文中的一个生命周期变量，则可以判断该生命周期 $\alpha$ 是良构的 ($\Gamma \vdash_{wf} \alpha$)。这意味着在上下文 $\Gamma$ 中声明的生命周期是良构的。

#### 2. **静态生命周期规则（Static Lifetime Rule）**
$$
\Gamma \vdash_{wf} static
$$
**解释**：无论上下文 $\Gamma$ 的内容如何，静态生命周期（`static`）总是被认为是良构的 ($\Gamma \vdash_{wf} static$)。静态生命周期通常是指程序运行期间始终有效的生命周期（类似于 Rust 中的 `'static` 生命周期）。

### 总结：

- **一般生命周期规则**：如果生命周期 $\alpha$ 已在上下文中声明为生命周期类型（$lft$），那么它是良构的。
- **静态生命周期规则**：静态生命周期 `static` 总是被视为良构的，无需额外条件。

这两条规则定义了如何判断生命周期是否良构，从而确保生命周期的使用在程序中保持一致性和正确性。

### -------------------------

### Well-formed external lifetime contexts 详解

图中定义了外部生命周期上下文的良构性规则。

#### 1. **空外部上下文规则（Empty External Context Rule）**
$$
\Gamma \vdash_{wf} \emptyset
$$
**解释**：在上下文 $\Gamma$ 中，空的外部上下文 $\emptyset$ 总是良构的。这意味着，如果没有定义任何外部生命周期上下文，则认为该上下文是良构的。

#### 2. **扩展外部上下文规则（Extend External Context Rule）**
$$
\frac{\Gamma \vdash_{wf} \mathbf{L} \quad \Gamma \vdash_{wf} \kappa \quad \Gamma \vdash_{wf} \kappa' }{\Gamma \vdash_{wf} \mathbf{L}, \kappa \subseteq_e \kappa'}
$$
**解释**：若上下文 $\Gamma$ 中的外部上下文 $\mathbf{L}$ 是良构的，同时生命周期 $\kappa$ 和 $\kappa'$ 也分别是良构的，并且 $\kappa \subseteq_e \kappa'$ 成立，则扩展后的外部上下文 $\mathbf{L}, \kappa \subseteq_e \kappa'$ 也是良构的。这表明在外部上下文中，生命周期之间的包含关系需要维持，并且所有的生命周期声明必须是良构的。

### 总结

- **空上下文规则**：空的外部生命周期上下文总是良构的。
- **扩展上下文规则**：要扩展一个良构的外部上下文，必须确保新添加的生命周期和生命周期之间的包含关系是良构的，并且生命周期本身也是良构的。

这些规则确保了外部生命周期上下文在程序中使用时是良构的，维护了生命周期的正确性和一致性。

### -----------------------

### Well-formed Local Lifetime Contexts 详解

图中定义了局部生命周期上下文的良构性规则。

#### 1. **空局部上下文规则（Empty Local Context Rule）**
$$
\Gamma \vdash_{wf} \emptyset
$$
**解释**：在上下文 $\Gamma$ 中，空的局部上下文 $\emptyset$ 是良构的。与外部生命周期上下文类似，当没有局部生命周期上下文时，认为它是良构的。

#### 2. **扩展局部上下文规则（Extend Local Context Rule）**
$$
\frac{\Gamma \vdash_{wf} \mathbf{L} \quad \Gamma \vdash_{wf} \kappa \quad \forall \kappa' \in \bar{\kappa}. \Gamma \vdash_{wf} \kappa' }{\Gamma \vdash_{wf} \mathbf{L}, \kappa \subseteq_l \bar{\kappa}}
$$
**解释**：如果局部上下文 $\mathbf{L}$ 是良构的，并且 $\kappa$ 是良构的，同时 $\bar{\kappa}$ 中的每一个 $\kappa'$ 都是良构的，那么扩展后的局部上下文 $\mathbf{L}, \kappa \subseteq_l \bar{\kappa}$ 也是良构的。这表明，局部上下文中的生命周期可以扩展，但需要确保新引入的生命周期和原有生命周期之间的局部包含关系是良构的。

### 总结

- **空上下文规则**：空的局部生命周期上下文总是良构的。
- **扩展上下文规则**：要扩展一个良构的局部上下文，必须确保新添加的生命周期与其他生命周期的包含关系是良构的，并且所有生命周期本身也必须是良构的。

这些规则确保了局部生命周期上下文在程序中是正确构造的，维护了生命周期的局部包含关系的有效性。

### -------------------------------

### Well-formed Types 详解

图中定义了类型的良构性规则。它为各种类型如何被认为是良构提供了形式化定义。

#### 1. **基本类型的良构性**
- **基本类型：**
  $$
  \frac{T : type \in \Gamma}{\Gamma \vdash_{wf} T}
  $$
  **解释**：在上下文 $\Gamma$ 中，如果 $T$ 是一个类型，则 $T$ 被认为是良构的。
  
- **布尔类型：**
  $$
  \Gamma \vdash_{wf} bool
  $$
  **解释**：布尔类型 $bool$ 在任何上下文 $\Gamma$ 下总是良构的。

- **整数类型：**
  $$
  \Gamma \vdash_{wf} int
  $$
  **解释**：整数类型 $int$ 在任何上下文 $\Gamma$ 下总是良构的。

- **拥有关系类型：**
  $$
  \frac{\Gamma \vdash_{wf} \tau}{\Gamma \vdash_{wf} own_n \tau}
  $$
  **解释**：如果 $\tau$ 是一个良构的类型，那么拥有关系类型 $own_n \tau$ 也是良构的。

#### 2. **引用类型的良构性**
- **生命周期相关的引用类型：**
  $$
  \frac{\Gamma \vdash_{wf} \kappa \quad \Gamma \vdash_{wf} \tau}{\Gamma \vdash_{wf} \&^{\kappa}_{\mu} \tau}
  $$
  **解释**：如果生命周期 $\kappa$ 和类型 $\tau$ 都是良构的，那么 $\kappa$ 和修饰符 $\mu$ （如 `mut` 或 `shr`）组合的引用类型 $\&^{\kappa}_{\mu} \tau$ 也是良构的。这种类型表示受生命周期和可变性修饰的引用类型。

#### 总结

- 基本类型如 $bool$ 和 $int$ 是在任何上下文下都被认为是良构的。
- 拥有类型 $own_n \tau$ 和引用类型 $\&^{\kappa}_{\mu} \tau$ 的良构性依赖于它们内部类型的良构性和生命周期约束的良构性。
- 通过这些规则，可以确保程序中所有类型的有效性和一致性。

这些规则提供了一套形式系统，来验证 Rust 风格类型系统中各类复杂类型的有效性。



这两个推导规则分别描述了 *依赖乘积* ($\Pi$) 和 *依赖和* ($\Sigma$) 类型的良构性规则。我们来分别解释这两个推导规则。

### 1. 依赖乘积（Dependent Product，$\Pi$）类型的良构性规则：

#### 公式：
$$
\frac{\forall i. \Gamma \vdash_{wf} \bar{\tau}_i}{\Gamma \vdash_{wf} \Pi \bar{\tau}}
$$

#### 解释：
- **前提**：对于所有的 $i$，在上下文 $\Gamma$ 中，$\bar{\tau}_i$ 是一个良构的类型。
- **结论**：在上下文 $\Gamma$ 中，依赖乘积类型 $\Pi \bar{\tau}$ 是一个良构的类型。

依赖乘积类型可以类比于函数的类型，描述了返回类型依赖于输入参数类型的情形。在编程语言中，依赖乘积类型常用于表示参数化类型，其中返回的类型可以依据参数而改变。

例如：
$$
\Pi x : \text{nat}. \text{List}(x)
$$
表示一个函数，其输入为自然数 $x$，返回值的类型是长度为 $x$ 的列表。

### 2. 依赖和（Dependent Sum，$\Sigma$）类型的良构性规则：

#### 公式：
$$
\frac{\forall i. \Gamma \vdash_{wf} \bar{\tau}_i}{\Gamma \vdash_{wf} \Sigma \bar{\tau}}
$$

#### 解释：
- **前提**：对于所有的 $i$，在上下文 $\Gamma$ 中，$\bar{\tau}_i$ 是一个良构的类型。
- **结论**：在上下文 $\Gamma$ 中，依赖和类型 $\Sigma \bar{\tau}$ 是一个良构的类型。

依赖和类型描述了一个类型对，其第二个分量依赖于第一个分量的值。在编程语言中，这常用于表示某个数据类型的同时保存某个值及其相关的类型信息。

例如：
$$
\Sigma x : \text{nat}. \text{List}(x)
$$
表示一个数据类型，其中包含一个自然数 $x$，以及长度为 $x$ 的列表。

### 总结：
- **依赖乘积类型** $\Pi \bar{\tau}$：类似于函数类型，表示返回类型依赖于输入参数类型。
- **依赖和类型** $\Sigma \bar{\tau}$：类似于依赖对，表示类型中某些部分依赖于其他部分的值。

这两个规则确保了在上下文 $\Gamma$ 中构造这两种依赖类型是合法且良构的。



此推导规则描述了 *带有生命周期参数的函数类型* 的良构性规则。下面逐步解释各个部分的含义：

### 公式：
$$
\frac{\Gamma, \bar{\alpha}, F : lft \vdash_{wf} \mathbb{E} \quad \forall i. \Gamma, \bar{\alpha} : lft \vdash_{wf} \bar{\tau}_i \quad \Gamma, \bar{\alpha} : lft \vdash_{wf} \tau}{\Gamma \vdash_{wf} \forall \bar{\alpha}. fn(F : \mathbb{E}; \bar{\tau}) \to \tau}
$$

### 解释：

#### 前提部分：
- **$\Gamma, \bar{\alpha}, F : lft \vdash_{wf} \mathbb{E}$**：上下文 $\Gamma$ 和生命周期变量 $\bar{\alpha}$ 构成的环境中，表达式环境 $\mathbb{E}$ 是良构的。
  
- **$\forall i. \Gamma, \bar{\alpha} : lft \vdash_{wf} \bar{\tau}_i$**：对于每个参数类型 $\bar{\tau}_i$，在上下文 $\Gamma$ 和生命周期变量 $\bar{\alpha}$ 的环境中，这些参数类型都是良构的。这表示所有参数类型在指定的生命周期内是合法的。
  
- **$\Gamma, \bar{\alpha} : lft \vdash_{wf} \tau$**：在上下文 $\Gamma$ 和生命周期变量 $\bar{\alpha}$ 的环境中，返回类型 $\tau$ 也是良构的。

#### 结论部分：
- **$\Gamma \vdash_{wf} \forall \bar{\alpha}. fn(F : \mathbb{E}; \bar{\tau}) \to \tau$**：基于前面的前提，我们可以得出结论，在上下文 $\Gamma$ 中，生命周期参数化的函数类型 $\forall \bar{\alpha}. fn(F : \mathbb{E}; \bar{\tau}) \to \tau$ 是良构的。

### 总结：
这个推导规则用于验证在 Rust 或 Lambda-Rust 等语言中，带有生命周期参数的函数类型是否良构。该规则说明了在上下文中，首先需要确保生命周期参数和所有函数参数的类型良构，并且返回类型也需要良构，才能得出整个函数类型的良构性。



这个推导规则描述了递归类型 $\mu T. \tau$ 的良构性规则。它的核心要求是类型 $T$ 必须只出现在 $\tau$ 中的指针或函数类型之下，这样可以确保递归类型的结构是合法的，不会导致不合法的自引用或无穷递归。

### 公式解释
$$
\frac{\Gamma, T : type \vdash_{wf} \tau \quad T \text{ only occurs below pointer or function types in } \tau}{\Gamma \vdash_{wf} \mu T. \tau}
$$

- **前提**：
  - $\Gamma, T : type \vdash_{wf} \tau$：在上下文 $\Gamma$ 中，$\tau$ 是一个良构的类型，其中 $T$ 被引入作为类型。
  - $T$ 仅仅出现在 $\tau$ 的指针或函数类型下：$T$ 的出现位置受到限制，确保它只位于指针类型或函数类型的嵌套结构之内。这通常是为了避免无穷递归的类型结构，例如直接的 $T = T$ 自引用。

- **结论**：
  - 在上下文 $\Gamma$ 中，$\mu T. \tau$ 是一个良构的递归类型。递归类型通常用于定义数据结构，比如树或链表，它们可以递归地引用自身。

### 举例
设 $\tau = \&T \to \text{int}$，那么 $\mu T. \tau = \mu T. (\&T \to \text{int})$ 就是一个合法的递归类型，因为 $T$ 仅出现在一个指针类型之下。

然而，如果 $\tau = T$，则 $\mu T. T$ 就是不合法的递归类型，因为 $T$ 是直接自引用的，这会导致不良构的类型。

### 总结
该规则确保递归类型的定义是安全的，不会导致无穷递归或其他类型不良构的问题。通过限制 $T$ 只出现在指针或函数类型下，保证了递归类型的合理性。

### ----------------------------

这组推导规则描述了良构类型上下文（Well-formed Type Contexts）的规则，确定了在给定上下文下类型上下文是如何构造和验证的。以下逐步解释每条规则的含义：

### 规则 1：
$$
\Gamma \vdash_{wf} \emptyset
$$
#### 解释：
在空上下文 $\Gamma$ 中，空类型上下文 $\emptyset$ 是良构的。这意味着，没有类型变量的上下文显然是良构的。

### 规则 2：
$$
\frac{\Gamma \vdash_{wf} T \quad \Gamma \vdash_{wf} p \quad \Gamma \vdash_{wf} \tau}{\Gamma \vdash_{wf} T, p \triangleleft \tau}
$$
#### 解释：
该规则表明，如果：
- 在上下文 $\Gamma$ 中，类型 $T$ 是良构的；
- 路径 $p$ 是良构的；
- 类型 $\tau$ 是良构的；

那么，类型上下文 $T$ 与路径 $p \triangleleft \tau$ 也是良构的。这表示可以在良构的类型上下文中添加新的类型映射。

### 规则 3：
$$
\frac{\Gamma \vdash_{wf} T \quad \Gamma \vdash_{wf} p \quad \Gamma \vdash_{wf} \kappa \quad \Gamma \vdash_{wf} \tau}{\Gamma \vdash_{wf} T, p \triangleleft^{\dagger\kappa} \tau}
$$
#### 解释：
这条规则是在前一条规则的基础上，添加了生命周期 $\kappa$ 的条件。如果：
- 在上下文 $\Gamma$ 中，类型 $T$ 是良构的；
- 路径 $p$ 是良构的；
- 生命周期 $\kappa$ 是良构的；
- 类型 $\tau$ 是良构的；

那么，类型上下文 $T$ 与路径 $p \triangleleft^{\dagger\kappa} \tau$ 也是良构的。这表示在生命周期约束下，可以将新的类型映射添加到上下文中。

### 总结：
这些推导规则确定了在给定上下文下，如何构造和验证类型上下文的良构性。规则 1 确定空上下文显然是良构的，而规则 2 和规则 3 扩展了这种良构性，允许添加路径和生命周期的约束来构造更加复杂的类型上下文。

### -------------------------

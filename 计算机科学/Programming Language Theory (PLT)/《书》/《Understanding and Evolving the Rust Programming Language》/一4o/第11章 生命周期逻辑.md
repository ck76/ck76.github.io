



### 详解

#### 1. **LFTL-BEGIN**
- - ### LFTL-BEGIN 详解
  
    公式：
    $$
    True \overset{\ast}{\Rightarrow}_{\mathcal{N}_{lft}} \exists \kappa. [\kappa]_1 * ([\kappa]_1 \overset{\ast}{\Rightarrow}_{\mathcal{N}_{lft}} [\dagger \kappa])
    $$
  
    #### 解释：
  
    - **生命周期开始：**  
      该规则描述了生命周期的开始，表示在某一时刻引入一个生命周期 $\kappa$。该生命周期可以被表示为一个标记 $[\kappa]_1$。
  
    - **符号解读：**
      - $True \overset{\ast}{\Rightarrow}_{\mathcal{N}_{lft}}$: 表示在生命周期管理上下文 $\mathcal{N}_{lft}$ 中从 $True$ 开始推导出接下来的生命周期规则。
      - $\exists \kappa$: 存在一个生命周期标识符 $\kappa$。
      - $[\kappa]_1$: 一个生命周期标识符 $\kappa$ 被引入，且其级别为 1。
      - $*$: 分配操作，表示这些规则同时成立。
      - $[\kappa]_1 \overset{\ast}{\Rightarrow}_{\mathcal{N}_{lft}} [\dagger \kappa]$: 该生命周期 $[\kappa]_1$ 最终可以通过某种推导转换为终止状态 $[\dagger \kappa]$，表示生命周期结束。
      
    - **生命周期的跟踪：**
      这个公式展示了生命周期 $\kappa$ 是如何开始的。首先引入生命周期标识符 $[\kappa]_1$，并且随着时间推移，生命周期将逐步演变，最后变为终结状态 $[\dagger \kappa]$。其中 $\overset{\ast}{\Rightarrow}_{\mathcal{N}_{lft}}$ 描述了生命周期中的资源转换过程。
  
    - **实际应用：**
      该规则可能用于描述资源管理系统中生命周期的创建过程。例如，在编程语言的资源分配中，当某个对象或资源的生命周期开始时，该对象被分配生命周期 $\kappa$，并通过该规则持续跟踪其状态，直到生命周期终结。

#### 2. **LFTL-TOK-TIMELESS**
公式：
$$
timeless([\kappa]_q)
$$

- **解释：**
  - 这个公式中的关键词 `timeless` 表示生命周期 $\kappa$ 是无时效性的（不会随着时间改变）。
  - $\kappa$ 以某种特定形式 $[\kappa]_q$ 存在，不会受到时间限制的影响，也就是说这个生命周期状态将保持不变，直到明确结束。
  - 该规则可以用于生命周期的延续部分，特别是对于那些在时间维度上不依赖的资源管理场景。

#### 3. **LFTL-END-PERSIST**
公式：
$$
persistent([\dagger\kappa])
$$

- **解释：**
  - 这个规则表示生命周期 $\kappa$ 已经结束。
  - `persistent([\dagger\kappa])` 表示结束状态是持续存在的。$\dagger\kappa$ 代表了生命周期的终结状态，它不再发生变化，状态一旦结束，就会被持久化，确保生命周期的正确回收。
  - 这常用于处理生命周期相关的资源，在资源释放后，确保其状态不会被反复使用或者重新分配。

### 总结：
- 这些公式描述了生命周期管理中的三个核心操作：
  1. **开始**生命周期 ($LFTL-BEGIN$)，引入并跟踪生命周期 $\kappa$。
  2. **无时效性**生命周期 ($LFTL-TOK-TIMELESS$)，确保生命周期在时间维度上是稳定的。
  3. **结束**生命周期 ($LFTL-END-PERSIST$)，确保生命周期 $\kappa$ 的终结是持久化的，不会被反复使用。



### LFTL-TOK-FRACT 详解

公式：
$$
[\kappa]_{q+q'} \overset{**}{\longleftrightarrow} [\kappa]_q * [\kappa]_{q'}
$$

#### 解释：
- **符号解读：**
  - $[\kappa]_{q+q'}$: 表示生命周期 $\kappa$ 的碎片化管理，其中碎片化的值是 $q + q'$。这指的是该生命周期拥有一个总计为 $q + q'$ 的权限值。
  - $**$: 双向推导符号，表示该式可以向两个方向推导。
  - $[\kappa]_q$: 生命周期 $\kappa$ 被分配了一个权限值 $q$。
  - $[\kappa]_{q'}$: 生命周期 $\kappa$ 还拥有一个权限值 $q'$，并且这两个权限可以合并为总计为 $q + q'$ 的一个完整生命周期。

- **实际应用：**
  该规则用于表示生命周期权限的拆分和组合。通过这个规则，我们可以将一个完整的生命周期权限 $[\kappa]_{q+q'}$ 拆分成两个独立的权限 $[\kappa]_q$ 和 $[\kappa]_{q'}$，反之亦然。这在管理资源生命周期时，能够允许将权限动态分配或合并，符合资源分配和共享的场景。

### LFTL-TOK-INTER 详解

公式：
$$
[\kappa \cap \kappa']_q \overset{**}{\longleftrightarrow} [\kappa]_q * [\kappa']_q
$$

#### 解释：
- **符号解读：**
  - $[\kappa \cap \kappa']_q$: 表示两个生命周期 $\kappa$ 和 $\kappa'$ 的交集 $\cap$，且该交集具有权限 $q$。
  - $[\kappa]_q * [\kappa']_q$: 表示生命周期 $\kappa$ 和 $\kappa'$ 各自具有权限 $q$，并且通过相乘操作合并。

- **实际应用：**
  该公式表示两个生命周期之间的交集关系。如果两个生命周期的交集拥有某个权限 $q$，那么我们也可以将该权限分配给各个生命周期。这可以用于管理多个生命周期的交集和权限共享场景。

### LFTL-TOK-UNIT 详解

公式：
$$
True \overset{\ast}{\longrightarrow} [\varepsilon]_q
$$

#### 解释：
- **符号解读：**
  - $True$: 这是一个布尔值，表示某个状态的成立。
  - $[ε]_q$: 表示生命周期的单位 $ε$，且该单位拥有权限 $q$。

- **实际应用：**
  该规则表示生命周期的单位元素 $ε$ 的生成。通过该公式，可以将一个真值状态转化为 $ε$，表示生命周期的最小单位。

### LFTL-END-UNIT 详解

公式：
$$
[\dagger ε] \overset{\ast}{\longrightarrow} False
$$

#### 解释：
- **符号解读：**
  - $[\dagger ε]$: 这是生命周期 $ε$ 的终结状态，表示该生命周期已经结束。
  - $False$: 布尔值，表示生命周期终结后状态为假。

- **实际应用：**
  该规则描述生命周期单位 $ε$ 的结束。当生命周期终结时，结果将转化为布尔假值，这通常用于表示资源生命周期已经不再有效。

### LFTL-END-INTER 详解

公式：
$$
[\dagger \kappa \cap \kappa'] \overset{**}{\longleftrightarrow} [\dagger \kappa] \lor [\dagger \kappa']
$$

#### 解释：
- **符号解读：**
  - $[\dagger \kappa \cap \kappa']$: 这是两个生命周期 $\kappa$ 和 $\kappa'$ 的交集的终结状态。
  - $[\dagger \kappa] \lor [\dagger \kappa']$: 这是两个生命周期 $\kappa$ 和 $\kappa'$ 中至少有一个终结时的状态，表示该交集状态的推导。

- **实际应用：**
  该规则用于处理多个生命周期交集的终结状态。如果两个生命周期的交集状态终结了，那么其两个组成部分之一或全部都会进入终结状态。

### LFTL-NOT-OWN-END 详解

公式：
$$
[\kappa]_q * [\dagger \kappa] \overset{\ast}{\longrightarrow} False
$$

#### 解释：
- **符号解读：**
  - $[\kappa]_q$: 生命周期 $\kappa$ 具有权限 $q$。
  - $[\dagger \kappa]$: 生命周期 $\kappa$ 的终结状态。
  - $False$: 表示终结后的状态为假。

- **实际应用：**
  该规则表示在生命周期 $\kappa$ 终结后，即使它拥有某个权限 $q$，也会导致状态为 $False$。这个规则用于确保生命周期终结后，相关资源或权限不再有效。

### -----------------------------

## Lifetime inclusion (all derived from the definition)

### LFTL-INCL 详解

公式：
$$
\kappa \subseteq \kappa' := \Box \left( \left( \forall q. \left( [\kappa]_q \propto_{\mathcal{N}_{\text{lft}}} q' \cdot [\kappa']_{q'} \right) \right) \ast \left( [\dagger \kappa'] \overset{\ast}{\propto_{\mathcal{N}_{\text{lft}}}} [\dagger \kappa] \right) \right)
$$

#### 解释：
- **符号解读：**
  - $\kappa \subseteq \kappa'$：表示生命周期 $\kappa$ 包含于生命周期 $\kappa'$，即 $\kappa$ 的所有权限和时间范围都包括在 $\kappa'$ 中。
  - $\Box$：表明这是一个永真条件。
  - $\forall q$：对于每一个权限值 $q$。
  - $[\kappa]_q$ 和 $[\kappa']_{q'}$：分别表示生命周期 $\kappa$ 和 $\kappa'$ 在权限值 $q$ 和 $q'$ 下的碎片。
  - $\propto_{\mathcal{N}_{\text{lft}}}$：这是一个关系符号，表示生命周期之间的某种依赖或比例关系，特别是在 $\mathcal{N}_{\text{lft}}$ 语境下的操作。

- **实际应用：**
  这个公式说明了两个生命周期之间的包含关系。该公式通过两个条件来定义：
  1. $\kappa$ 的每一个权限值 $q$ 都可以通过某种比例关系与 $\kappa'$ 的某个 $q'$ 关联。
  2. 当 $\kappa'$ 生命周期终结时，$\kappa$ 也应当终结（反映在 $[\dagger \kappa'] \overset{\ast}{\propto_{\mathcal{N}_{\text{lft}}}} [\dagger \kappa]$ 中）。

- **总结：**
  该规则用来确保生命周期的包含性。如果生命周期 $\kappa$ 被包含在 $\kappa'$ 中，那么它意味着 $\kappa$ 的所有权限都依赖于 $\kappa'$ 的权限分配，且 $\kappa$ 的终结事件必须在或早于 $\kappa'$ 的终结。这在系统中用于管理资源的生命周期依赖关系，确保生命周期管理符合逻辑的包含性。

### LFTL-INCL-REFL

公式：
$$
\kappa \subseteq \kappa
$$

#### 解释：
这是**反身性（reflexivity）**规则。反身性规则表明：任何生命周期 $\kappa$ 本身都包含于自身。也就是说，$\kappa$ 的所有权限、时间范围和其他属性自然是包含在 $\kappa$ 内的，这是生命周期逻辑中的一个基础规则。

- **符号解释：**
  - $\kappa \subseteq \kappa$：生命周期 $\kappa$ 包含于自身。

- **实际含义：**
  反身性规则确保生命周期的基本性质。无论如何，一个生命周期总是包含自己，这是生命周期逻辑中最基础的推理规则。

### LFTL-INCL-TRANS

公式：
$$
\kappa_1 \subseteq \kappa_2 \ast \kappa_2 \subseteq \kappa_3 \rightarrow \kappa_1 \subseteq \kappa_3
$$

#### 解释：
这是**传递性（transitivity）**规则。传递性规则表明：如果生命周期 $\kappa_1$ 包含于 $\kappa_2$，并且 $\kappa_2$ 又包含于 $\kappa_3$，那么可以得出结论 $\kappa_1$ 也包含于 $\kappa_3$。这种传递性是一种生命周期的推论规则，它使得我们能够通过中间生命周期推断出更大的包含关系。

- **符号解释：**
  - $\kappa_1 \subseteq \kappa_2$：生命周期 $\kappa_1$ 包含于 $\kappa_2$。
  - $\kappa_2 \subseteq \kappa_3$：生命周期 $\kappa_2$ 包含于 $\kappa_3$。
  - $\rightarrow$：表示根据前提推导出结论。
  - $\kappa_1 \subseteq \kappa_3$：推导出的结论，表示 $\kappa_1$ 也包含于 $\kappa_3$。

- **实际应用：**
  该规则在多个生命周期的依赖链中起关键作用，允许我们推理复杂的包含关系。通过传递性，可以从多个生命周期之间的包含关系推出一个最终的结论，简化了生命周期管理中的推导过程。



### LFTL-INCL-ISECT

公式：
$$
\kappa \cap \kappa' \subseteq \kappa
$$

#### 解释：
这是**交集包含性（Intersection Inclusion）**规则。这个规则表明：如果我们取两个生命周期 $\kappa$ 和 $\kappa'$ 的交集 $\kappa \cap \kappa'$，那么这个交集一定是包含于 $\kappa$ 的。这是显而易见的，因为交集是取两个集合的共同部分，故其自然包含于原始集合之一。

- **符号解释：**
  - $\kappa \cap \kappa'$：表示生命周期 $\kappa$ 和 $\kappa'$ 的交集。
  - $\subseteq$：表示包含关系，前者被包含于后者。
  - $\kappa$：交集一定包含在 $\kappa$ 中。

- **实际应用：**
  该规则用于在不同生命周期的交集操作中推导出包含关系，可以用于验证和推导两个生命周期重叠部分的有效性。

---

### LFTL-INCL-GLB

公式：
$$
\kappa \subseteq \kappa' \ast \kappa \subseteq \kappa'' \rightarrow \kappa \subseteq \kappa' \cap \kappa''
$$

#### 解释：
这是**最小上界包含性（Greatest Lower Bound Inclusion）**规则。这个规则表明：如果一个生命周期 $\kappa$ 被包含于 $\kappa'$，同时也被包含于 $\kappa''$，那么它也被包含于 $\kappa'$ 和 $\kappa''$ 的交集 $\kappa' \cap \kappa''$。此规则类似于取两个生命周期的**最小上界**，即它们的交集。

- **符号解释：**
  - $\kappa \subseteq \kappa'$：表示生命周期 $\kappa$ 被包含于 $\kappa'$。
  - $\ast$：逻辑连接符，表示两个条件都为真。
  - $\kappa' \cap \kappa''$：表示 $\kappa'$ 和 $\kappa''$ 的交集。
  - $\rightarrow$：表示根据前提推导出结论。

- **实际应用：**
  该规则用于推导多个生命周期同时包含某个生命周期时，可以通过其交集来进行验证。这对推导多个生命周期相交部分的属性尤为重要。

### ------------------------------

##  Full borr

### LFTL-BORROW

公式：
$$
\blacktriangleright P \mathrel{\overset{*}{\mathcal{N}_{\text{lft}}}} \&^{\kappa_{\text{full}}} P \ast \left( [\dagger \kappa] \overset{*}{\mathcal{N}_{\text{lft}}} \blacktriangleright P \right)
$$

#### 解释：
这是**借用规则（Borrow Rule）**，主要用于推理生命周期借用的相关性质。

- **符号解释：**
  - $\blacktriangleright P$：表示断言 $P$ 作用于生命周期借用的情形。$P$ 是某个逻辑条件或断言。
  - $\mathcal{N}_{\text{lft}}$：生命周期的名称空间，表示正在管理的生命周期区域。
  - $\overset{*}{\mathcal{N}_{\text{lft}}}$：表示某个状态或操作影响整个生命周期。
  - $\&^{\kappa_{\text{full}}} P$：表示带有生命周期 $\kappa_{\text{full}}$ 的并行断言 $P$。
  - $[\dagger \kappa]$：表示终止的生命周期 $\kappa$，与生命周期借用的结束有关。
  - $\ast$：连接符，表示逻辑上的结合或并行，类似于乘法。
  - $\blacktriangleright P$：表示最终 $P$ 成立。
  
#### 分步解释：
1. **借用开始条件：** 
   $\blacktriangleright P$ 表示借用的初始状态满足断言 $P$。接下来我们处理和管理整个生命周期（$\overset{*}{\mathcal{N}_{\text{lft}}}$）。
   
2. **生命周期借用操作：**
   $\&^{\kappa_{\text{full}}} P$ 表示在生命周期 $\kappa_{\text{full}}$ 上执行并行操作 $P$。这意味着在该生命周期的持续期间，断言 $P$ 始终成立。

3. **借用结束条件：**
   $[\dagger \kappa] \overset{*}{\mathcal{N}_{\text{lft}}} \blacktriangleright P$ 表示在生命周期 $\kappa$ 结束时，生命周期管理器 $\mathcal{N}_{\text{lft}}$ 继续维持 $P$ 的有效性，并且最终 $P$ 断言仍然成立。

- **实际应用：**
  该规则用于生命周期管理中的借用机制，特别是在 Rust 等拥有严格生命周期的编程语言中。它帮助程序员在推理借用时保持断言的有效性，避免借用生命周期结束后产生未定义行为。

### LFTL-BOR-SPLIT

公式：
$$
\&^{\kappa_{\text{full}}}(P \ast Q) \overset{*}{\mathcal{N}_{\text{lft}}} \&^{\kappa_{\text{full}}} P \ast \&^{\kappa_{\text{full}}} Q
$$

#### 解释：
该公式定义了借用分割（Borrow Splitting）的规则，在生命周期管理的场景中，它描述了如何将一个并行的断言 $P \ast Q$ 分割为两个独立的断言 $P$ 和 $Q$，并且这些断言保持在相同的生命周期 $\kappa_{\text{full}}$ 之内。

- **符号解释：**
  - $\&^{\kappa_{\text{full}}}(P \ast Q)$：表示在生命周期 $\kappa_{\text{full}}$ 中，条件 $P$ 和 $Q$ 并行地成立。$\ast$ 是逻辑结合符，表示并行的断言。
  - $\mathcal{N}_{\text{lft}}$：生命周期管理器，负责管理借用的生命周期区域。
  - $\overset{*}{\mathcal{N}_{\text{lft}}}$：表示在整个生命周期中管理或监控。
  - $\&^{\kappa_{\text{full}}} P$ 和 $\&^{\kappa_{\text{full}}} Q$：表示分别在生命周期 $\kappa_{\text{full}}$ 中，断言 $P$ 和 $Q$ 独立成立。
  
#### 分步解释：
1. **分割前的并行条件：**
   借用分割前，$\&^{\kappa_{\text{full}}}(P \ast Q)$ 表示在生命周期 $\kappa_{\text{full}}$ 内，条件 $P$ 和 $Q$ 是并行成立的。这里，$P \ast Q$ 表示 $P$ 和 $Q$ 同时为真。

2. **生命周期管理器的应用：**
   借用分割过程通过 $\overset{*}{\mathcal{N}_{\text{lft}}}$ 由生命周期管理器来控制，确保在整个生命周期管理过程中，分割操作是安全的。

3. **分割后的断言：**
   经过分割，$\&^{\kappa_{\text{full}}} P \ast \&^{\kappa_{\text{full}}} Q$ 表示 $P$ 和 $Q$ 分别在生命周期 $\kappa_{\text{full}}$ 中独立成立。这意味着 $P$ 和 $Q$ 现在可以单独地处理，但它们仍然都受限于相同的生命周期。

- **实际应用：**
  该规则用于在生命周期借用中将并行断言进行分解，从而使得各个条件可以独立验证。在 Rust 等语言中，这样的规则可以确保复杂借用的分离和合理性，尤其在多线程或并发编程的环境下。

### ----------------------

##  Q Full borrows (deriv



### LFTL-BOR-ACC

公式：
$$
\&^{\kappa_{\text{full}}} P \ast [\kappa]_q \propto \mathcal{N}_{\text{lft}} \blacktriangleright P
$$

#### 解释：

这个公式描述了生命周期借用的访问规则，用于确保在给定的生命周期 $\kappa$ 中条件 $P$ 和借用标记 $[\kappa]_q$ 同时成立，并且这个借用遵循生命周期管理器 $\mathcal{N}_{\text{lft}}$ 的规则。这里的核心是保证条件 $P$ 在该生命周期内的安全性。

- **符号解释：**
  - $\&^{\kappa_{\text{full}}} P$：表示在生命周期 $\kappa_{\text{full}}$ 内，断言 $P$ 成立。
  - $[\kappa]_q$：这是借用标记，表示在生命周期 $\kappa$ 内的某个借用，其中 $q$ 表示借用的量级或强度。
  - $\propto \mathcal{N}_{\text{lft}}$：表示借用过程是由生命周期管理器 $\mathcal{N}_{\text{lft}}$ 控制的。这个符号强调了借用的相互关系或依赖。
  - $\blacktriangleright P$：表示条件 $P$ 是在这个借用上下文中被接受的，意味着 $P$ 在满足所有条件的情况下被安全访问。

#### 分步解释：

1. **借用标记 $[\kappa]_q$ 与条件 $P$ 的组合：**
   该公式的左侧，$\&^{\kappa_{\text{full}}} P \ast [\kappa]_q$，表示在生命周期 $\kappa_{\text{full}}$ 内的条件 $P$ 和借用标记 $[\kappa]_q$ 同时存在。$[\kappa]_q$ 指定了生命周期的某个借用强度（$q$），$P$ 是在这个借用范围内有效的条件。

2. **生命周期管理器 $\mathcal{N}_{\text{lft}}$ 的参与：**
   $\propto \mathcal{N}_{\text{lft}}$ 说明借用过程需要生命周期管理器的参与，确保借用的安全性。这通常用于管理资源或对象的借用，确保这些资源在生命周期 $\kappa$ 结束前是安全的。

3. **条件 $P$ 的访问：**
   右侧的 $\blacktriangleright P$ 表示条件 $P$ 在当前借用上下文中是可以安全访问的。这个符号确保了在借用标记存在且生命周期管理器正常工作时，条件 $P$ 的访问是经过验证和被接受的。

- **实际应用：**
  该规则用于控制并验证在生命周期系统中对条件的访问，确保在生命周期管理器的监督下，资源的借用和访问是安全的。在 Rust 等语言中，该规则可以防止未定义行为，例如使用已经过期的借用或资源。这一规则帮助编译器或借用检查器在编译时验证借用的正确性。



### LFTL-REBORROW 公式详解

公式：

$$
\kappa' \subseteq \kappa \ast \&^{\kappa_{\text{full}}} P \Rightarrow \mathcal{N}_{\text{lft}} \&^{\kappa_{\text{full}}} P \ast ([\dagger \kappa'] \Rightarrow \mathcal{N}_{\text{lft}} \&^{\kappa_{\text{full}}} P)
$$

#### 解释：

该公式描述了生命周期中的**重新借用规则**，用于处理在给定的生命周期内，资源可以被安全地重新借用的情况。通过这种方式，我们可以确保即使一个资源被多个借用者引用，也能保证其安全性和有效管理。

- **符号解释：**
  - $\kappa' \subseteq \kappa$：表示生命周期 $\kappa'$ 是 $\kappa$ 的子集，意味着在生命周期 $\kappa'$ 的范围内可以进行资源的操作。
  - $\ast$：这是逻辑上的“与”操作，表示多个条件同时成立。
  - $\&^{\kappa_{\text{full}}} P$：表示在生命周期 $\kappa_{\text{full}}$ 内，断言 $P$ 成立。
  - $\Rightarrow \mathcal{N}_{\text{lft}}$：表示借用是由生命周期管理器 $\mathcal{N}_{\text{lft}}$ 控制的，确保资源借用的安全性。
  - $[\dagger \kappa']$：表示生命周期 $\kappa'$ 已经结束，或者在资源管理的过程中该生命周期被标记为过期或完成。

#### 分步解释：

1. **生命周期关系：**  
   $\kappa' \subseteq \kappa$ 表示 $\kappa'$ 是 $\kappa$ 的子生命周期，这意味着在 $\kappa$ 的生命周期内，重新借用可以发生在 $\kappa'$ 中。这通常用于描述在一个大的生命周期内进行局部的借用。

2. **借用和断言 $P$ 的条件：**  
   在公式的左侧，$\&^{\kappa_{\text{full}}} P$ 表示在生命周期 $\kappa_{\text{full}}$ 内，条件 $P$ 成立。此时，借用行为是受控制的，即我们可以断言 $P$ 在这个生命周期内是安全的。

3. **重新借用的影响：**  
   $\Rightarrow \mathcal{N}_{\text{lft}} \&^{\kappa_{\text{full}}} P$ 表示借用行为的结果是受生命周期管理器 $\mathcal{N}_{\text{lft}}$ 控制的。管理器负责监控这些借用行为，以防止不安全的资源访问。

4. **借用结束：**  
   公式中有 $[\dagger \kappa']$，这是生命周期 $\kappa'$ 已经结束的标记。当这个条件成立时，意味着借用行为已经结束或即将结束，生命周期管理器会确保这个借用操作不会影响到原有的生命周期 $\kappa$。

5. **最终安全性保证：**  
   最终，公式确保无论如何重新借用，$\kappa'$ 的结束不会影响到 $\kappa$ 内的资源安全，整个过程都由生命周期管理器 $\mathcal{N}_{\text{lft}}$ 进行控制。

- **实际应用：**  
  该规则主要应用于借用检查器中的**重新借用检查**，例如 Rust 编程语言中复杂的生命周期管理。重新借用允许我们在不违反安全规则的情况下，将资源在不同的子生命周期内进行传递。这个公式保证了重新借用的安全性和生命周期的一致性。



### LFTL-BOR-EXISTS 公式详解

公式：

$$
\&^{\kappa_{\text{full}}}(\exists x. P) \Rightarrow \mathcal{N}_{\text{lft}} \exists x. \&^{\kappa_{\text{full}}} P
$$

**解释：**

这个公式描述了生命周期系统中的一个借用规则，即**存在性借用 (Existential Borrowing)**。它允许在生命周期 $\kappa_{\text{full}}$ 中表明有某个实体 $x$ 使得某个条件 $P$ 成立，进而可以推导出在该生命周期内对这个实体的有效借用。

- **符号解释：**
  - $\&^{\kappa_{\text{full}}} (\exists x. P)$：在生命周期 $\kappa_{\text{full}}$ 中，存在某个 $x$ 使得断言 $P$ 成立。这表示我们正在处理一个关于某个实体 $x$ 的存在性陈述。
  - $\Rightarrow \mathcal{N}_{\text{lft}}$：这是生命周期管理器，确保借用行为是安全的。
  - $\exists x. \&^{\kappa_{\text{full}}} P$：表示存在一个具体的 $x$，并且在生命周期 $\kappa_{\text{full}}$ 中，断言 $P$ 对该实体 $x$ 成立。

#### 分步详解：

1. **存在性陈述的引入：**
   在生命周期 $\kappa_{\text{full}}$ 中，如果我们知道存在某个实体 $x$ 满足断言 $P$，则我们可以得出一个更具体的断言：**存在 $x$**，使得这个断言 $P$ 对 $x$ 成立。

2. **生命周期的安全性：**
   在生命周期管理中，所有的借用操作必须由生命周期管理器 $\mathcal{N}_{\text{lft}}$ 控制，确保借用行为不会引起数据竞争或者未定义行为。在这个公式中，$\Rightarrow \mathcal{N}_{\text{lft}}$ 表示生命周期管理器负责监控这个存在性断言。

3. **实体的作用域：**
   公式中，$\exists x. \&^{\kappa_{\text{full}}} P$ 表示不仅存在 $x$，而且 $x$ 满足 $P$ 的条件，并且该条件在生命周期 $\kappa_{\text{full}}$ 内始终成立。这确保了借用在 $\kappa_{\text{full}}$ 内的正确性。

4. **使用场景：**
   该规则应用在处理**借用时的存在性约束**。例如，假设我们有某种数据结构，其中存在某个对象 $x$ 满足某些性质 $P$，此时借用系统会确保在该生命周期内我们可以安全地对这个对象进行操作。

- **实际意义：**
   这个规则对于借用检查器（如 Rust 的借用检查器）很重要，确保在存在性条件下的借用行为可以被安全、正确地追踪。通过这样的规则，生命周期管理器可以确认借用过程中不会发生内存问题。



### LFTL-BOR-SHORTEN 公式详解

公式：

$$
\kappa' \sqsubseteq \kappa \ast \&^{\kappa_{\text{full}}} P \ast \&^{\kappa'_{\text{full}}} P
$$

**解释：**

这个规则描述了生命周期借用中的“缩短借用 (Shorten Borrowing)”操作。它允许我们将一个较长的生命周期借用“缩短”成一个更短的生命周期，前提是较短的生命周期是较长生命周期的一个子集。缩短生命周期的操作不会影响借用的安全性和完整性。

- **符号解释：**
  - $\kappa' \sqsubseteq \kappa$：表示 $\kappa'$ 是 $\kappa$ 的子生命周期。即 $\kappa'$ 的存活时间小于或等于 $\kappa$ 的存活时间。
  - $\&^{\kappa_{\text{full}}} P$：在生命周期 $\kappa$ 内断言 $P$ 成立。表示我们在生命周期 $\kappa$ 中借用了资源，并且满足某种性质 $P$。
  - $\ast$：通常用于表示结合操作，类似于逻辑上的“与”操作。

#### 分步详解：

1. **生命周期的子集关系：**
   公式左边的 $\kappa' \sqsubseteq \kappa$ 表明，$\kappa'$ 是 $\kappa$ 的子集，换句话说，$\kappa'$ 的生命周期比 $\kappa$ 短。这是进行生命周期缩短操作的基本条件。

2. **借用完整性：**
   在生命周期 $\kappa$ 内对资源进行借用时，断言 $P$ 成立，即 $\&^{\kappa_{\text{full}}} P$。这意味着，资源在生命周期 $\kappa$ 内是完整的、可以安全使用的。

3. **借用缩短：**
   当借用的生命周期可以从 $\kappa$ 缩短为 $\kappa'$ 时，新的借用 $\&^{\kappa'_{\text{full}}} P$ 表明资源在缩短后的生命周期 $\kappa'$ 内依然满足条件 $P$，并且可以被安全地使用。

4. **结合操作：**
   公式中的 $\ast$ 操作表示借用的结合。它说明我们可以在较长生命周期和较短生命周期的组合下进行借用，借用行为在这两个生命周期内都满足断言 $P$。

- **实际意义：**
   借用检查器（如 Rust）会使用此规则来确保在不违反借用规则的情况下，安全地将一个较长的借用缩短到一个较短的生命周期。这个缩短操作通常在函数调用时出现，尤其是在生命周期约束较为复杂的情况下，借用检查器需要通过这样的规则来进行生命周期缩减。

通过该规则，系统可以安全地将生命周期缩短为 $\kappa'$，并且确保在整个生命周期 $\kappa$ 和 $\kappa'$ 内资源的一致性和完整性。

### ---------------------------



## 🥑11.3 Fractured borrows

### Figure 11.2: Proof rules for fractured borrows (all derived

公式 **LFTL-BOR-FRACTURE** 是关于生命周期借用中分裂 (Fracture) 操作的规则。公式如下：

$$
\&^{\kappa_{\text{full}}} \Phi(1) \quad \Rightarrow \quad \ast \mathcal{N}_{\text{lft}} \quad \&^{\kappa_{\text{frac}}} \Phi
$$

### 公式解读：

这个规则描述了将完整借用生命周期进行分裂成部分借用生命周期的过程。此规则在生命周期管理中的分解（fracture）操作中起到了关键作用。

#### 公式符号解释：

1. **$\&^{\kappa_{\text{full}}} \Phi(1)$：**
   该表达式表示在完整的生命周期 $\kappa_{\text{full}}$ 内有一个命题 $\Phi(1)$ 成立，$\Phi$ 是关于借用状态的命题或断言。在这个上下文中，$\Phi(1)$ 通常意味着我们对资源拥有完全的控制。

2. **$\Rightarrow$ (变换)：**
   表示从完整借用转换为部分借用的过程。

3. **$\ast \mathcal{N}_{\text{lft}}$：**
   这是一个逻辑连结操作符，表明生命周期框架中保持一致性。在这个情况下，$\mathcal{N}_{\text{lft}}$ 表示资源借用的一个不变量或某种逻辑资源。在分裂操作中保持某些不变量成立。

4. **$\&^{\kappa_{\text{frac}}} \Phi$：**
   表示生命周期 $\kappa_{\text{frac}}$ 的部分借用。在这里，$\Phi$ 命题依然成立，但这个生命周期借用已经不是完整的了，而是部分（fractional）的。

### 分步解释：

1. **完整生命周期借用：**
   初始条件 $\&^{\kappa_{\text{full}}} \Phi(1)$ 表示我们在生命周期 $\kappa_{\text{full}}$ 内对资源有完全的控制。换句话说，借用是完整的，我们拥有对资源的完全所有权。

2. **分裂操作：**
   通过分裂 (Fracture) 操作，我们可以将这个完整的生命周期借用转换为部分借用。公式右侧的 $\&^{\kappa_{\text{frac}}} \Phi$ 表示我们现在对资源只有部分控制，而不再拥有全部所有权。

3. **不变量保持：**
   在分裂过程中，$\ast \mathcal{N}_{\text{lft}}$ 表示在分裂的过程中有某种不变量（如资源安全性或借用正确性）依然得到保持。这是为了确保在多个生命周期借用中不会破坏原来的逻辑约束。

### 实际应用：

在系统中进行借用检查时，分裂 (Fracture) 操作允许我们将一个完整的借用分成多个部分借用，这种操作非常有用，尤其是在并发环境或多线程编程中，我们可以安全地将一个资源的控制权分散到多个部分，以允许多个实体同时操作资源。

通过该规则，系统保证了借用的一致性和安全性，即使资源的控制被部分化，我们仍然可以确保各部分借用的安全。

公式 **LFTL-FRACT-SHORTEN** 描述了生命周期分数化借用中的“缩短”规则。公式如下：

$$
\frac{\kappa' \sqsubseteq \kappa}
{\&^{\kappa_{\text{frac}}} \Phi \quad \ast \quad \&^{\kappa'_{\text{frac}}} \Phi}
$$

### 公式解读：

该公式定义了如何在生命周期包含关系 $\kappa' \sqsubseteq \kappa$ 的情况下对部分借用进行缩短 (Shorten) 操作。

#### 公式符号解释：

1. **$\kappa' \sqsubseteq \kappa$：**
   这是前提条件，表示 $\kappa'$ 是 $\kappa$ 的子生命周期，或者说 $\kappa'$ 的范围小于或等于 $\kappa$ 的范围。这意味着我们可以在更小范围或更短时间内进行资源的部分借用。

2. **$\&^{\kappa_{\text{frac}}} \Phi$：**
   这表示在生命周期 $\kappa$ 内，我们对命题 $\Phi$ 有部分借用，意味着对资源的部分控制。

3. **$\ast$ (连结)：**
   逻辑连结符表示生命周期中的两个断言成立。这里，它表示在 $\kappa$ 和 $\kappa'$ 两个生命周期内，命题 $\Phi$ 都部分成立。

4. **$\&^{\kappa'_{\text{frac}}} \Phi$：**
   这表示生命周期缩短至 $\kappa'$ 后，命题 $\Phi$ 依然成立，且我们仍然对该资源有部分借用，只是这个借用的时间段或范围已经缩短。

### 分步解释：

1. **前提：**
   前提 $\kappa' \sqsubseteq \kappa$ 表示生命周期 $\kappa'$ 是 $\kappa$ 的一个子生命周期。换句话说，$\kappa'$ 的范围比 $\kappa$ 更小或更短。这种包含关系允许我们将一个较长生命周期的借用缩短。

2. **缩短过程：**
   如果我们在生命周期 $\kappa$ 内对资源有部分借用（表示为 $\&^{\kappa_{\text{frac}}} \Phi$），那么我们可以根据 $\kappa' \sqsubseteq \kappa$ 的包含关系，将这个部分借用缩短为在生命周期 $\kappa'$ 内的部分借用。

3. **保持不变的资源控制：**
   在这种缩短操作中，命题 $\Phi$ 在生命周期 $\kappa$ 和 $\kappa'$ 内都成立。无论生命周期范围如何变化，借用的逻辑条件保持不变。

### 实际应用：

该规则在生命周期借用管理中至关重要，因为它允许我们根据需要将借用的生命周期缩短。在实际编程中，这可以应用于管理资源的生存期，尤其是在并发编程或多线程环境中，我们可以安全地缩短借用范围而不影响资源的一致性或安全性。

通过该规则，系统可以确保生命周期的缩短操作是安全的，并且在缩短后的生命周期内，资源依然遵循相同的借用条件。这种缩短操作可以帮助优化资源管理，确保在短时间内精确控制资源的使用。



公式 **LFTL-FRACT-PERSIST** 描述了生命周期分数借用中的持久性特性。公式如下：

$$
persistent(\&^{\kappa_{\text{frac}}} \Phi)
$$

### 公式解读：

该公式表达了一个分数借用的持久性属性，也就是说，在生命周期 $\kappa$ 内的分数借用 $\Phi$ 是**持久的** (persistent)。

#### 公式符号解释：

1. **persistent**： 
   这个关键词表示某个命题或状态是持久的，意味着它一旦成立，在未来的所有时间或所有情况下依然成立。换句话说，资源的分数借用在生命周期内是无法撤销或更改的。

2. **$\&^{\kappa_{\text{frac}}} \Phi$**：
   这表示在生命周期 $\kappa$ 内，我们对命题 $\Phi$ 具有分数借用的权利。分数借用意味着我们只对资源有部分的控制权，而不是完全的所有权。

### 分步解释：

1. **分数借用的持久性：**
   公式中声明，如果我们在生命周期 $\kappa$ 内对命题 $\Phi$ 有分数借用，那么这种借用是持久的。也就是说，这种借用的权利在 $\kappa$ 生命周期内将持续有效，直到 $\kappa$ 结束为止。

2. **不可撤销性：**
   持久性意味着分数借用是不可撤销的，一旦某个借用成立，它将一直存在，直到生命周期结束。这在资源管理中非常重要，尤其是在并发环境中，可以确保资源不会被意外释放或更改。

### 实际应用：

该规则用于编程中的借用管理系统，尤其是在 Rust 语言等支持细粒度生命周期管理的系统中。当声明一个资源的分数借用时，通过持久性规则确保该借用在生命周期 $\kappa$ 内始终有效。这使得资源的管理更加安全可靠，防止因生命周期结束之前的误操作导致的资源一致性问题。

通过这条规则，系统能够确保生命周期内的部分资源借用是持久的，不会在生命周期未结束时失效或被其他操作干扰。



公式 **LFTL-FRACT-ACC** 表示分数借用的可访问性规则。公式如下：

$$
\forall q_1, q_2. \Phi(q_1 + q_2) \overset{**}{\sim} \Phi(q_1) * \Phi(q_2)
$$

$$
\frac{\&^{\kappa_{\text{frac}}} \Phi \ast ([\kappa]_q \propto \mathcal{N}_{\text{lft}} \ q'. \ \triangleright \Phi(q'))}
     {\&^{\kappa_{\text{frac}}} \Phi \ast ([\kappa]_q \propto \mathcal{N}_{\text{lft}})}
$$

### 公式解释：

这条规则说明了对于某个生命周期 $\kappa$ 的分数借用 $\Phi$ ，如果我们有 $q_1$ 和 $q_2$ 的分数，我们可以将 $\Phi(q_1 + q_2)$ 分解成 $\Phi(q_1)$ 和 $\Phi(q_2)$ 的组合。

#### 公式符号解释：

1. **$\forall q_1, q_2$**： 
   表示对所有的分数 $q_1$ 和 $q_2$，即我们将任意两个分数借用进行组合。

2. **$\Phi(q_1 + q_2)$**：
   表示当我们结合了分数 $q_1$ 和 $q_2$ 后的借用状态。

3. **$** \Phi(q_1) * \Phi(q_2)$**：
   表示借用可以被分解为两个独立的借用，分别为 $q_1$ 和 $q_2$ 的部分。

4. **$\overset{**}{\sim}$**：
   表示两边的逻辑关系是同等效力的，右边的分解和左边的组合是等价的操作。

5. **$\&^{\kappa_{\text{frac}}} \Phi$**：
   表示对 $\kappa$ 生命周期下的分数借用。

6. **$[\kappa]_q \propto \mathcal{N}_{\text{lft}}$**：
   这里表示在生命周期管理 $\mathcal{N}_{\text{lft}}$ 下，我们正在处理生命周期的分数借用资源。

### 分步解释：

1. **分数借用的组合与分解：**
   我们可以看到该规则是关于分数借用的组合与分解，即我们可以将不同分数的借用 $\Phi(q_1 + q_2)$ 分解为 $\Phi(q_1)$ 和 $\Phi(q_2)$。这使得在借用资源时可以更灵活地处理不同部分的资源。

2. **资源管理：**
   公式中的 $\mathcal{N}_{\text{lft}}$ 代表了生命周期管理系统，这种规则确保了当我们借用不同部分的资源时，资源不会被意外地重复使用或者丢失。



公式 **LFTL-FRACT-ACC-ATOMIC** 解释了如何在生命周期管理中进行分数借用的原子性访问。公式如下：

$$
\&^{\kappa_{\text{frac}}} \Phi \to * \left( \text{True} \ \mathcal{N}_{\text{lft}} \propto \emptyset \ b, q. \ \text{ifthenelse}(b, \triangleright \Phi(q), [\dagger \kappa]) \right)
$$

### 公式解释：

这个公式描述了如何通过原子操作访问生命周期 $\kappa$ 相关的分数借用 $\Phi$，并使用条件语句控制资源的访问或释放。

#### 公式符号解释：

1. **$\&^{\kappa_{\text{frac}}} \Phi$**：
   表示对生命周期 $\kappa$ 的分数借用 $\Phi$。

2. **$\to *$**：
   表示将分数借用 $\Phi$ 应用于某个条件判断。

3. **$\text{True} \ \mathcal{N}_{\text{lft}} \propto \emptyset$**：
   表示生命周期管理器 $\mathcal{N}_{\text{lft}}$ 在没有额外资源的情况下保证此访问是真实的操作。

4. **$b, q$**：
   表示布尔变量 $b$ 和分数 $q$，是条件语句中的核心参数。

5. **$\text{ifthenelse}(b, \triangleright \Phi(q), [\dagger \kappa])$**：
   表示条件判断：
   - 如果 $b$ 为真，则执行 $\triangleright \Phi(q)$，即对 $\Phi$ 进行访问。
   - 如果 $b$ 为假，则触发 $\dagger \kappa$，即释放或销毁生命周期。

### 分步解释：

1. **分数借用的原子访问：**
   在该规则中，我们使用条件语句来控制对资源的访问。首先，生命周期管理器 $\mathcal{N}_{\text{lft}}$ 会确保当前没有资源被多次借用。然后，通过 $b$ 和 $q$ 的判断，我们决定是否进行借用或释放生命周期资源。

2. **条件控制访问：**
   `ifthenelse(b, \triangleright \Phi(q), [\dagger \kappa])` 解释了如何通过条件语句访问生命周期资源。如果条件 $b$ 为真，则访问资源 $\Phi$。如果 $b$ 为假，则释放或终止与生命周期 $\kappa$ 相关的借用资源。

3. **确保原子性：**
   这个公式确保了所有的生命周期借用操作都是原子的，避免了资源的竞争或错误访问。

### ---------------------------------

### Figure 11.3: Proof rules for atomic borrows (all derived)

公式 **LFTL-BOR-AT** 解释了在并发场景中借用生命周期的行为。公式如下：

$$
\mathcal{N} \# \mathcal{N}_{\text{lft}} * \&^{\kappa_{\text{full}}} P \Rightarrow * \mathcal{N}_{\text{lft}} \&^{\kappa'/\mathcal{N}_{\text{at}}} P
$$

### 公式解释：

这个公式描述了在涉及并发的场景下，生命周期 $\kappa$ 的借用行为，特别是当多个线程或任务并行访问资源时，如何保证借用的安全性。

#### 公式符号解释：

1. **$\mathcal{N} \# \mathcal{N}_{\text{lft}}$**：
   表示生命周期管理器 $\mathcal{N}$ 和生命周期 $\mathcal{N}_{\text{lft}}$ 在并行访问资源时的隔离关系。符号 `$\#$` 表示两者之间存在并发隔离，确保不会发生资源冲突。

2. **$\&^{\kappa_{\text{full}}} P$**：
   表示对生命周期 $\kappa$ 进行全额借用 $P$，意味着该资源的完整性是需要维护的，任何借用者都要遵循这一完整借用的规则。

3. **$\Rightarrow *$**：
   表示借用操作的执行，其结果将影响后续的并发访问。

4. **$\mathcal{N}_{\text{lft}} \&^{\kappa'/\mathcal{N}_{\text{at}}} P$**：
   表示在借用生命周期 $\kappa$ 之后，资源 $P$ 仍然可以由 $\kappa'$ 通过另一个并发生命周期 $\mathcal{N}_{\text{at}}$ 来访问。

### 分步解释：

1. **并发隔离：**
   借用规则在并发的情况下首先确保 $\mathcal{N}$ 和 $\mathcal{N}_{\text{lft}}$ 之间是隔离的。并发的隔离意味着即使多个任务或线程同时访问生命周期资源，借用的完整性和正确性依然得以保证。

2. **完整借用：**
   在 $\&^{\kappa_{\text{full}}} P$ 中，表明资源 $P$ 是通过完整的生命周期 $\kappa$ 进行借用的，这意味着没有其他借用方可以并发访问该资源。

3. **结果的并发访问：**
   通过 $\Rightarrow *$，公式指出在并发隔离和完整借用保证下，生命周期管理器 $\mathcal{N}_{\text{lft}}$ 允许通过 $\kappa'/\mathcal{N}_{\text{at}}$ 继续访问资源 $P$，即允许某种级别的并发访问。

### 结论：

该公式确保了在并发程序中借用生命周期资源时的安全性。通过确保并发隔离，生命周期借用操作可以安全地在多个任务或线程之间执行，不会引起资源竞争或冲突。



公式 **LFTL-AT-SHORTEN** 描述了在并发场景中，如何通过缩短生命周期来保持资源访问的正确性。公式如下：

$$
\frac{\kappa' \subseteq \kappa}{\&^{\kappa/\mathcal{N}_{\text{at}}} P \overset{*}{\longmapsto} \&^{\kappa'/\mathcal{N}_{\text{at}}} P}
$$

### 公式解释：

这个公式展示了当生命周期 $\kappa'$ 是 $\kappa$ 的子生命周期（通过 $\subseteq$ 关系表示）时，资源 $P$ 的生命周期可以从 $\kappa$ 缩短到 $\kappa'$，并依然保持资源访问的安全性。

#### 公式符号解释：

1. **$\kappa' \subseteq \kappa$**：
   表示 $\kappa'$ 是 $\kappa$ 的子生命周期。即 $\kappa'$ 的存续期小于或等于 $\kappa$，这允许在缩短生命周期时依然保持对资源 $P$ 的有效访问。

2. **$\&^{\kappa/\mathcal{N}_{\text{at}}} P$**：
   表示资源 $P$ 在生命周期 $\kappa$ 下通过 $\mathcal{N}_{\text{at}}$ 进行访问。

3. **$\overset{*}{\longmapsto}$**：
   表示资源生命周期的转换规则，即在满足一定条件（如 $\kappa' \subseteq \kappa$）时，允许将生命周期从 $\kappa$ 缩短为 $\kappa'$。

4. **$\&^{\kappa'/\mathcal{N}_{\text{at}}} P$**：
   表示资源 $P$ 现在在缩短后的生命周期 $\kappa'$ 下，通过 $\mathcal{N}_{\text{at}}$ 继续访问。

### 分步解释：

1. **子生命周期关系：**
   首先，公式前提要求 $\kappa'$ 是 $\kappa$ 的子生命周期，确保我们可以安全地缩短生命周期。

2. **资源访问转换：**
   如果满足 $\kappa' \subseteq \kappa$，那么资源 $P$ 可以在生命周期 $\kappa$ 下进行完整的借用。当我们将生命周期缩短为 $\kappa'$ 后，资源 $P$ 仍然可以在 $\kappa'$ 下被安全访问。

3. **并发保证：**
   通过 $\mathcal{N}_{\text{at}}$，资源在新的生命周期下依然保证并发安全性。这种转换通过 $\overset{*}{\longmapsto}$ 保证访问规则的一致性。

### 结论：

该公式确保了在并发程序中缩短生命周期的操作是安全的，允许资源在更短的生命周期中被访问，同时不会破坏原有的并发访问安全性。



公式 **LFTL-AT-PERSIST** 表达了关于并发场景中某个资源 $P$ 在特定生命周期和命名空间（$\mathcal{N}_{\text{at}}$）下具有持久性（persistent）的特性。公式如下：

$$
\text{persistent}(\&^{\kappa/\mathcal{N}_{\text{at}}} P)
$$

### 公式解释：

- **persistent**：表示在当前上下文中，资源 $P$ 的访问权限在生命周期 $\kappa$ 和并发命名空间 $\mathcal{N}_{\text{at}}$ 下是持久的。也就是说，一旦资源被借用，它在这个生命周期和命名空间内是持久有效的，不会因为生命周期的变化或并发访问的变化而失效。

- **$\&^{\kappa/\mathcal{N}_{\text{at}}} P$**：表示资源 $P$ 在生命周期 $\kappa$ 下通过并发命名空间 $\mathcal{N}_{\text{at}}$ 进行访问。

### 分步解释：

1. **持久性定义**：
   “持久性”是指在并发程序中，某个资源的访问权限在一个特定的上下文内不会被撤销。该公式表明，资源 $P$ 一旦在生命周期 $\kappa$ 和命名空间 $\mathcal{N}_{\text{at}}$ 下被持有，它的访问权限将持续有效。

2. **结合生命周期与命名空间**：
   资源 $P$ 的持久性不仅取决于生命周期 $\kappa$，还受限于命名空间 $\mathcal{N}_{\text{at}}$ 的约束。持久性意味着在这两个条件下，资源的访问权限不会丢失或变得无效。

3. **并发访问保证**：
   在并发编程中，这个公式提供了一个安全机制，使得即使在多线程或异步操作中，资源 $P$ 的访问也能在生命周期 $\kappa$ 和 $\mathcal{N}_{\text{at}}$ 命名空间中保持稳定和持久。

### 结论：

公式 **LFTL-AT-PERSIST** 表明资源 $P$ 在特定生命周期和命名空间下具有持久性。它保障了资源访问的安全性，即使在并发环境中，资源的访问权限也不会轻易丢失。



公式 **LFTL-AT-ACC-TOK** 表示在生命周期 $\kappa$ 和命名空间 $\mathcal{N}$ 下，对资源 $P$ 的访问权限和相关的时间戳标记的机制。公式如下：

$$
\&^{\kappa/\mathcal{N}_{\text{at}}} P \overset{*}{\Rightarrow} ([\kappa]_q \mathcal{N}_{\text{lft}} \mathcal{N} \propto \mathcal{N}_{\text{lft}} \triangleright P)
$$

### 公式解释：

- **$\&^{\kappa/\mathcal{N}_{\text{at}}} P$**：表示资源 $P$ 在生命周期 $\kappa$ 和命名空间 $\mathcal{N}_{\text{at}}$ 下的借用访问权限。
  
- **$\overset{*}{\Rightarrow}$**：表明通过借用机制将资源 $P$ 与某个逻辑状态相关联。这个状态可以通过一些时间戳或令牌来保证。

- **$[\kappa]_q$**：表示资源 $P$ 在量化级别 $q$ 下被绑定到生命周期 $\kappa$。

- **$\mathcal{N}_{\text{lft}}$**：表示与资源生命周期相关联的命名空间标记，用来标识资源何时有效。

- **$\propto \mathcal{N}_{\text{lft}} \triangleright P$**：表示资源 $P$ 和 $\mathcal{N}_{\text{lft}}$ 命名空间的时间戳标记有特定的关系。这个关系意味着 $P$ 依赖于生命周期 $\kappa$ 的状态，同时该状态是由命名空间 $\mathcal{N}_{\text{lft}}$ 负责管理的。

### 分步解释：

1. **资源访问**：
   该公式表明，资源 $P$ 在生命周期 $\kappa$ 和命名空间 $\mathcal{N}_{\text{at}}$ 下可以通过借用来访问。在这种情况下，资源 $P$ 的访问权限和借用机制受限于生命周期 $\kappa$ 的约束。

2. **时间戳标记**：
   在公式的右侧部分，$[\kappa]_q$ 指代了一个与生命周期 $\kappa$ 相关联的时间戳标记，表明资源 $P$ 在此生命周期内是可用的。

3. **借用和命名空间的关系**：
   命名空间 $\mathcal{N}_{\text{lft}}$ 负责追踪资源 $P$ 的生命周期并确保其在该生命周期内的借用是有效的。通过 $\mathcal{N}_{\text{lft}} \propto \mathcal{N}_{\text{lft}} \triangleright P$ 表示命名空间 $\mathcal{N}_{\text{lft}}$ 确保资源 $P$ 的借用权限根据生命周期和命名空间的状态来进行调整。

### 结论：

公式 **LFTL-AT-ACC-TOK** 描述了如何通过生命周期和命名空间来管理资源 $P$ 的借用和访问权限。这确保了资源的访问是受生命周期状态和命名空间管理的约束的，提供了一种安全的并发访问管理机制。

### --------------

## 🥑11.5 Indexed borrows: Unifying persistent borrowin

### Figure 11.5: Proof rules for indexed borrows (all primitive

### 1. **LFTL-BOR-IDX**

公式：
$$
\&^{\kappa_{\text{full}}} P \overset{**}{\Rightarrow} \exists i. \&^{\kappa_i} P \ast [\text{Bor} : i]_1
$$

解释：
- **$\&^{\kappa_{\text{full}}} P$** 表示资源 $P$ 在生命周期 $\kappa_{\text{full}}$ 下的完整借用。
- **$\overset{**}{\Rightarrow}$** 表示通过借用机制对资源进行标记，允许访问资源 $P$。
- **$\exists i. \&^{\kappa_i} P$** 表示存在一个索引 $i$，资源 $P$ 在生命周期 $\kappa_i$ 下也是可访问的。
- **$[\text{Bor} : i]_1$** 表示借用的索引或位置被标记为 $i$，确保在访问 $P$ 时保持该位置。

此公式描述了一种索引借用机制，通过在资源 $P$ 上引入索引 $i$，允许对 $P$ 进行有约束的借用，并在访问时提供相应的索引信息。

---

### 2. **LFTL-IDX-PERSIST**

公式：
$$
\text{persistent}(\&^{\kappa_i} P)
$$

解释：
- **$\text{persistent}$** 表示持久性，即某些资源或状态不会随时间变化或被回收。
- **$\&^{\kappa_i} P$** 表示资源 $P$ 在生命周期 $\kappa_i$ 下被借用。

此公式表明资源 $P$ 在生命周期 $\kappa_i$ 下是持久的，意味着 $P$ 的状态不会随着时间而失效，允许在生命周期内的任何时刻安全地访问资源。

---

### 3. **LFTL-IDX-TIMELESS**

公式：
$$
\text{timeless}([\text{Bor} : i]_q)
$$

解释：
- **$\text{timeless}$** 表示不依赖于时间的访问或状态，意思是该资源或标记的状态不会因为时间的流逝而发生变化。
- **$[\text{Bor} : i]_q$** 表示在生命周期或借用上下文中，有量化级别 $q$ 的索引 $i$ 与资源或借用位置 $\text{Bor}$ 相关联。

此公式表示，索引 $i$ 是时间无关的，即可以在任何时刻访问，并且不会因时间推移而影响它的有效性。

---

### 总结

- **LFTL-BOR-IDX** 公式描述了对资源的索引借用机制，通过添加索引来跟踪资源的访问位置。
- **LFTL-IDX-PERSIST** 强调了资源在生命周期内的持久性，不会随生命周期的结束而失效。
- **LFTL-IDX-TIMELESS** 则说明了某些借用标记是时间无关的，可以安全地在任意时刻访问。





公式 **LftL-Idx-Iff** 的结构如下：

$$
\triangle \Box (P ** Q) \\
\frac{\quad}{\&^{\kappa}_{i} P -** \&^{\kappa}_{i} Q}
$$

### 公式解释：
1. **$\triangle \Box (P ** Q)$**: 这个部分通常表示在逻辑推导中必须保持的前提条件。这里的 $\triangle$ 和 $\Box$ 分别表示“可能性” (diamond) 和“必然性” (box) 的逻辑运算符，而 **$P ** Q$** 代表两个条件的分离合取 (separating conjunction)。
   
   在分离逻辑中，$P ** Q$ 意味着 $P$ 和 $Q$ 可以在不重叠的资源上并行操作，即它们之间是独立的。这在资源分配或所有权推理中非常重要，常用于验证并发程序。

2. **$&^{\kappa}_{i} P -** &^{\kappa}_{i} Q$**: 这个表示一个从 $P$ 到 $Q$ 的强制转化 (entailment) ，其中 $P$ 和 $Q$ 都是关于索引 $i$ 的借用 $&^{\kappa}_{i}$ 的部分资源。这个操作符 $-**$ 在分离逻辑中表示蕴含 (entailment)，其含义是“给定 $P$，我们可以推出 $Q$。”

### 含义：
该规则的语义是：如果我们能够在前提条件下证明分离逻辑 $P ** Q$ 的正确性，那么我们可以从资源 $P$ 得到资源 $Q$，即完成从 $P$ 到 $Q$ 的逻辑推导。公式中的索引 $i$ 代表某种特定的借用状态或资源的部分引用，$\kappa$ 是其相关的生命周期 (lifetime) 限制。

在并发系统中，这种推理机制帮助我们推导程序的安全性：当多个进程或线程以分离的方式共享资源时，必须确保每一部分的操作不干扰其他部分，同时保证最终的正确性和一致性。



公式 **LftL-Idx-Shorten** 的结构如下：

$$
\frac{\kappa' \sqsubseteq \kappa}{\&^{\kappa}_{i} P -** \&^{\kappa'}_{i} P}
$$

### 公式解释：
1. **$\kappa' \sqsubseteq \kappa$**: 这里的 $\sqsubseteq$ 表示生命周期 (lifetime) 的包含关系，意思是 $\kappa'$ 是 $\kappa$ 的子生命周期 (sub-lifetime)。这表明 $\kappa'$ 的生命周期可能比 $\kappa$ 短或等于 $\kappa$。

2. **$&^{\kappa}_{i} P -** &^{\kappa'}_{i} P$**: 在分离逻辑中，这个公式表示从 $P$ 在生命周期 $\kappa$ 下的引用，推导出在生命周期 $\kappa'$ 下的引用。$-**$ 表示蕴含 (entailment)，即通过这个推导，我们可以从 $P$ 的生命周期 $\kappa$ 转换到生命周期 $\kappa'$，前提是 $\kappa'$ 是 $\kappa$ 的子生命周期。

### 含义：
该规则的语义是，如果 $P$ 的生命周期 $\kappa'$ 是 $\kappa$ 的子生命周期 (sub-lifetime)，那么我们可以将 $P$ 在 $\kappa$ 下的引用转换为在更短生命周期 $\kappa'$ 下的引用。这在生命周期的管理中非常重要，尤其是当我们想要安全地缩短借用 (borrowing) 的范围时。

这种规则确保了在生命周期缩短的情况下，资源的借用仍然是安全的，即我们可以在不违反安全性的情况下使用更短的生命周期去操作相同的资源。这有助于在程序的生命周期管理中确保资源的有效使用并防止悬挂引用 (dangling references) 等问题。



这些公式主要描述了 Lifetime (生命周期) 管理系统的借用和权限模型，它们展示了不同场景下关于生命周期、权限和引用的推理规则。这里分别解释这两个公式的含义：

1. **Lftl-Idx-Iff:**
   - **公式结构：**
     - 上方的推理表达了在某个上下文中，两个命题 $P$ 和 $Q$ 可以通过合取操作 $**$ 相结合，且这些命题有着必要的条件（用 $\box$ 表示）。
     - 下方推导显示，如果能证明 $P$ 和 $Q$ 在这种上下文中的合取成立，那么可以通过分离连接（用 $-\ast$ 表示）将它们分别提取出来，即在 $\kappa_i$ 相关的权限下 $P$ 可以导出 $Q$。
   - **解释：**
     - 这个规则表明，如果在生命周期上下文中 $P$ 和 $Q$ 的断言之间有合取关系且合适的前提满足，那么可以将 $P$ 通过分离连接的方式推导出 $Q$。这在借用或所有权系统中，描述了如何从两个有关联的命题中提取某个条件。

2. **Lftl-Idx-Shorten:**
   - **公式结构：**
     - 上方表达了两个生命周期 $\kappa'$ 和 $\kappa$ 之间的包含关系：$\kappa' \sqsubseteq \kappa$，即 $\kappa'$ 被 $\kappa$ 包含或是 $\kappa$ 的子集。
     - 下方推导指出，在此包含关系下，可以通过分离连接规则，表示当权限涉及 $\kappa_i$ 时，如果 $P$ 在生命周期 $\kappa$ 中有效，那么它在生命周期 $\kappa'$ 中也有效。
   - **解释：**
     - 这个规则表明，当一个生命周期 $\kappa'$ 被包含在 $\kappa$ 中时，如果某个命题 $P$ 在 $\kappa$ 生命周期中有效（也就是它持有的借用或所有权），那么在缩短的生命周期 $\kappa'$ 中，它仍然有效。这种推理规则在借用检查中尤为重要，用于处理生命周期缩短的情形。

这两个公式的关键在于描述了生命周期系统中的不同推理操作如何处理借用权限与生命周期的关系，确保在不同生命周期和上下文下的断言能够有效和一致。





公式 **Lftl-Idx-Fract** 主要描述了关于索引借用 (`Bor : i`) 的分数所有权。公式的结构如下：

$$
[ Bor : i ]_{q+q'} ** [ Bor : i ]_q * [ Bor : i ]_{q'}
$$

### 公式解释：
1. **$[ Bor : i ]_{q+q'}$** 表示总的借用，拥有索引 $i$ 的整体借用权限，它的强度为 $q + q'$。这是对借用的全局引用。
   
2. **$[ Bor : i ]_q$** 和 **$[ Bor : i ]_{q'}$** 分别表示该借用被分成了两个部分，$q$ 部分和 $q'$ 部分。它们表示对借用权限的部分引用。
   
3. **$**$ 运算符表示将两个部分合并为整体的操作。

### 含义：
这个规则表达了在借用模型中的部分引用（fractional ownership）。即使借用权限被分割成两部分，它们仍然是同一引用的不同份额，合在一起就构成了完整的借用。这种模型在并发环境下很重要，可以用于描述多个线程对同一个资源的部分借用，而每个部分的引用强度可以不同。

该规则也确保了在处理分数引用时，合并后的结果依然保持一致性，体现了 Rust 等语言中的借用检查机制。



公式 **LftL-Idx-Acc** 表示与生命周期管理相关的访问控制规则，具体如下：

$$
\&^{\kappa_i} P \ast \left( \left[ \text{Bor} : i \right]_1 \ast \left[ \kappa \right]_q \propto \mathcal{N}_{lft} \triangleright P \right)
$$

### 公式详解：

1. **$\&^{\kappa_i} P$**：这里 $\&^{\kappa_i} P$ 表示在生命周期 $\kappa_i$ 内存在某种对资源 $P$ 的引用 (借用)。生命周期 $\kappa_i$ 是用于控制该引用在程序中的有效期的。

2. **$*$ (星号)**：在分离逻辑中，$*$ 表示逻辑上的并列，意味着同时存在两个不相交的条件。这通常用于表示在特定资源管理的场景中同时存在的条件。

3. **$\left[ \text{Bor} : i \right]_1$**：这一部分表示生命周期索引 (Borrow Index)，其中 $\text{Bor} : i$ 表示在索引 $i$ 处的借用 (Borrow)，且 $1$ 表示这是一个不可分割的单一部分。

4. **$\left[ \kappa \right]_q$**：这一部分表示与生命周期 $\kappa$ 相关的分数标记，$q$ 表示该生命周期的具体份额。在分数化的生命周期管理中，生命周期可以被拆分为多份，并以不同的权限形式存在。

5. **$\propto \mathcal{N}_{lft}$**：$\propto$ 表示比例或依赖关系，$\mathcal{N}_{lft}$ 是生命周期相关的某种规范 (lifetime management norm)，用于控制和管理生命周期的访问权限。

6. **$\triangleright P$**：$\triangleright$ 表示在特定条件下，我们可以访问或操作 $P$。在这种情况下，它表示我们在特定生命周期管理的规则下能够安全地操作资源 $P$。

### 含义：

该规则描述了在生命周期索引和分数标记的背景下，如何访问资源 $P$。通过生命周期索引 (Borrow Index) 和分数生命周期控制，可以确保资源的借用和访问在程序运行时是安全的。这种规则保证了在分离逻辑中，不同生命周期内的资源不会冲突，且在适当的生命周期管理规范下，资源的访问权限能够被合理地控制。

在实际编程场景中，这种规则主要用于处理复杂的资源借用和生命周期管理，确保资源在并发环境下的安全访问并避免数据竞争或不安全的资源释放。



公式 **LftL-Idx-Bor-Unnest** 表示生命周期索引和借用操作的解嵌套规则，具体如下：

$$
&^{\kappa_i} P \ast &^{\kappa^{\prime}_{full}} \left( [\text{Bor} : i]_1 \right) \Rightarrow \ast_{\mathcal{N}_{lft}} &^{\kappa^{\prime}_{full}} &\cap \kappa^{\prime} P
$$

### 公式详解：

1. **$&^{\kappa_i} P$**：表示生命周期 $\kappa_i$ 控制下的资源 $P$ 的引用借用。$&$ 表示引用，$\kappa_i$ 是生命周期的标识符，表明资源 $P$ 在该生命周期内是安全的。

2. **$*$ (星号)**：分离逻辑中的星号表示并列关系，说明两个条件可以同时成立并相互独立。

3. **$&^{\kappa^{\prime}_{full}} \left( [\text{Bor} : i]_1 \right)$**：这一部分表示对借用索引的引用，$\kappa^{\prime}_{full}$ 表示这是一个完整的生命周期 (full lifetime)，而 $[\text{Bor} : i]_1$ 表示这个借用 (Borrow) 操作在索引 $i$ 处不可分割 (单独处理)。

4. **$\ast_{\mathcal{N}_{lft}}$**：这个符号表示结合 $\mathcal{N}_{lft}$ 的操作，$\mathcal{N}_{lft}$ 是与生命周期相关的规范或管理逻辑，负责控制引用和生命周期之间的关系。

5. **$&^{\kappa^{\prime}_{full}} &\cap \kappa^{\prime} P$**：表示在 $\kappa^{\prime}$ 生命周期下的资源 $P$，并且在该生命周期的引用与生命周期管理逻辑 $\mathcal{N}_{lft}$ 一致。$&\cap$ 表示生命周期的交集操作，确保生命周期 $\kappa^{\prime}$ 与引用的其他生命周期一致。

### 含义：

该规则描述了在生命周期管理中的借用引用如何被解嵌套 (unnest)。当我们对生命周期内的资源 $P$ 进行借用时，特别是当借用操作涉及生命周期索引时 (如 $[\text{Bor} : i]_1$)，我们需要通过规范 $\mathcal{N}_{lft}$ 来管理和控制这些引用。

该公式说明了如何在嵌套的生命周期控制下，将借用操作转换为一种可安全解嵌套的形式，确保资源 $P$ 在生命周期的管理下是安全的并且遵守规范 $\mathcal{N}_{lft}$。这是在复杂的引用和生命周期管理场景下确保并发安全和资源生命周期正确性的重要一环。

### --------------------
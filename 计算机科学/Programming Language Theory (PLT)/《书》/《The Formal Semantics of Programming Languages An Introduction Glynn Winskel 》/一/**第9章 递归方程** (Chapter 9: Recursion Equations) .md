[toc]



# 第9章 递归方程

本章将探讨一个简单的编程语言 **REC**，它支持在整数上的函数的递归定义。与指令式语言 IMP 相比，REC 是一个**应用式（applicative）**语言。它可以以**值调用（call-by-value）**或**名调用（call-by-name）**的方式进行求值。对于每种求值方式，我们都将提供其操作语义和指称语义，并证明它们是等价的。

## 9.1 REC 语言

**REC** 是一个简单的编程语言，旨在支持函数的递归定义。它具有以下语法集合：

- **数字** $n \in \mathbb{Z}$：正整数和负整数（包括零）。
- **变量** $x \in \text{Var}$：表示整数的变量集合。
- **函数变量** $f, g, h, \dots \in \text{Fvar}$：函数变量集合。

对于每个函数变量 $f \in \text{Fvar}$，假定它具有一个**元数（arity）** $a_f \in \omega$，即它接受的参数数量。当 $a_f = 0$ 时，函数 $f$ 的调用 $f()$，即零参数函数，一般直接写作 $f$。

**REC** 的**项（terms）**（记作 $t, t_0, t_1, \dots$）具有以下语法：

- **基本项**：
  - 数字：$n$
  - 变量：$x$
- **算术运算**：$t_1 \ \text{op} \ t_2$，其中 $\text{op}$ 是加法、减法或乘法。
- **条件表达式**：$\text{if } t_0 \ \text{then } t_1 \ \text{else } t_2$
- **函数调用**：$f(t_1, \dots, t_{a_f})$

为了简化，我们将**布尔表达式**视为项本身，其中 $0$ 被理解为真值 **true**，所有非零数字被理解为假值 **false**。因此，可以将逻辑或运算编码为 $x$，将逻辑非运算 $¬b$ 编码为条件表达式 $\text{if } b \ \text{then } 1 \ \text{else } 0$，基本布尔操作如等于测试 $(t_0 = t_1)$ 可以表示为 $(t_0 - t_1)$（参见下面的练习9.1）。

我们称一个项是**封闭的（closed）**，当它不包含任何来自 $\text{Var}$ 的变量。

**函数变量 $f$ 的定义**由一个声明（declaration）给出，通常形式为：

$$
f(x_1, \dots, x_{a_f}) = t
$$

其中 $t$ 是函数 $f$ 的定义，$x_1, \dots, x_{a_f}$ 是参数变量。

**注意**：

- 在函数定义 $f(x_1, \dots, x_{a_f}) = t$ 中，$t$ 中出现的变量必须包含在 $x_1, \dots, x_{a_f}$ 中。
- 定义可以是**递归的**，即 $t$ 中可以包含函数变量 $f$ 本身，甚至其他函数变量 $g, h$ 等。
- 我们不允许对同一个函数变量有两个定义。

### 举例

例如，以下是一个合法的函数定义：

$$
\begin{align*}
\text{fact}(x) &= \text{if } x \ \text{then } 1 \ \text{else } x \times \text{fact}(x - 1)
\end{align*}
$$

这是一个计算阶乘的递归函数定义。

### 关于操作语义的思考

对于 REC 的操作语义的选择并不那么明确。考虑以下定义：

$$
f = f + 1
$$

这是一个零参数函数的定义。根据计算直觉，$f$ 的值应该等于 $f + 1$，这又等于 $(f + 1) + 1$，如此反复下去。因此，对 $f$ 的求值应该永不终止。实际上，如果 $f$ 的求值终止于某个整数值 $n$，那么这将满足一个矛盾的等式 $n = n + 1$。

再考虑另一个定义：

$$
g(x) = 1
$$

在求值 $g(t)$ 时，对于某个项 $t$，我们有两种选择：

1. **值调用（call-by-value）**：首先求值参数 $t$，一旦得到一个整数值 $n$，然后继续求值 $g(n)$。
2. **名调用（call-by-name）**：直接进入 $g$ 的定义，将参数 $t$ 替换到定义中所有出现的变量 $x$ 处。

当参数 $t$ 是 $f$ 时，这两种选择有着截然不同的效果：

- **值调用**：首先尝试求值 $f$，由于 $f$ 的求值永不终止，因此 $g(f)$ 的求值也永不终止。
- **名调用**：直接使用 $g$ 的定义，$g(f) = 1$，求值立即终止，结果为 $1$。

**总结**：

- **值调用**要求首先对参数求值，然后再将其传递给函数定义。
- **名调用**直接将未求值的参数传递给函数定义。

当参数被需要时，值调用更有效，因为它只对参数求值一次；否则，名调用可能需要多次求值相同的参数。在某些情况下，如上例中的 $g(f)$，如果参数从未被使用，名调用可以避免不必要的计算。

---

**练习9.1：**

根据你对 REC 中项的非正式理解，你认为以下声明中的函数 $s$ 计算的是什么？

$$
\begin{align*}
s(x) &= \text{if } x \ \text{then } 0 \ \text{else } f(x, 0 - x) \\
f(x, y) &= \text{if } x \ \text{then } 1 \ \text{else } (\text{if } y \ \text{then } -1 \ \text{else } f(x - 1, y - 1))
\end{align*}
$$

**任务**：

1. 分析函数 $s$ 的计算过程，解释它的功能。
2. 在 REC 中定义一个函数 $lt(x, y)$，如果 $x < y$，则返回 $0$（即真），否则返回一个非零数（即假）。

**解答**：

1. **分析函数 $s(x)$ 的计算过程**：

   - 函数 $s(x)$ 定义为：

     $$
     s(x) = \text{if } x \ \text{then } 0 \ \text{else } f(x, 0 - x)
     $$

     回忆一下，我们将 $0$ 视为真（true），非零数视为假（false）。因此，条件表达式的判断条件为：

     - 如果 $x = 0$（真），则返回 $0$。
     - 如果 $x \ne 0$（假），则计算 $f(x, 0 - x)$。

   - 函数 $f(x, y)$ 定义为：

     $$
     f(x, y) = \text{if } x \ \text{then } 1 \ \text{else } (\text{if } y \ \text{then } -1 \ \text{else } f(x - 1, y - 1))
     $$

     同样地，条件判断中：

     - 如果 $x = 0$（真），则返回 $1$。
     - 如果 $x \ne 0$（假），继续判断 $y$：
       - 如果 $y = 0$（真），则返回 $-1$。
       - 如果 $y \ne 0$（假），则递归调用 $f(x - 1, y - 1)$。

   - **综合分析**：

     - 当 $x = 0$ 时，$s(0) = 0$。
     - 当 $x \ne 0$ 时，计算 $f(x, 0 - x)$：
       - 注意到 $0 - x = -x$。
       - 当 $x > 0$ 时，$-x < 0$，所以 $0 - x \ne 0$（假）。
       - 当 $x < 0$ 时，$-x > 0$，所以 $0 - x \ne 0$（假）。

     - 在 $f(x, -x)$ 中：

       - 如果 $x = 0$，返回 $1$。
       - 否则，检查 $y$：
         - 如果 $y = 0$，返回 $-1$。
         - 否则，递归调用 $f(x - 1, y - 1)$。

     - 由于 $x$ 和 $-x$ 的符号相反，它们同时为零的情况只有当 $x = 0$。因此，$f(x, -x)$ 将递归地减小 $x$ 和 $y$，直到其中一个为零。

   - **结论**：

     - 函数 $s(x)$ 的作用是判断 $x$ 的符号：
       - 如果 $x = 0$，返回 $0$。
       - 如果 $x > 0$，最终 $f(x, -x)$ 会在 $x$ 变为 $0$ 时返回 $1$。
       - 如果 $x < 0$，最终 $f(x, -x)$ 会在 $y$（即 $-x$）变为 $0$ 时返回 $-1$。

     - 因此，$s(x)$ 返回：

       - $0$，如果 $x = 0$。
       - $1$，如果 $x > 0$。
       - $-1$，如果 $x < 0$。

     - **功能**：$s(x)$ 判断整数 $x$ 的符号，返回 $0$（零）、$1$（正数）或 $-1$（负数）。

2. **在 REC 中定义函数 $lt(x, y)$，如果 $x < y$，则返回 $0$（真），否则返回非零数（假）**：

   我们可以利用递归和条件表达式来定义 $lt(x, y)$。

   **定义**：

   $$
   lt(x, y) = \text{if } x \ \text{then } (\text{if } y \ \text{then } lt(x - 1, y - 1) \ \text{else } 1) \ \text{else } (\text{if } y \ \text{then } 0 \ \text{else } 1)
   $$

   **解释**：

   - 当 $x = 0$（真）时：
     - 如果 $y = 0$（真），则返回 $1$（假），因为 $0 \geq 0$。
     - 如果 $y \ne 0$（假），则返回 $0$（真），因为 $0 < y$（$y$ 非零，即 $y > 0$）。
   - 当 $x \ne 0$（假）时：
     - 如果 $y = 0$（真），则返回 $1$（假），因为 $x \geq 0$。
     - 如果 $y \ne 0$（假），递归调用 $lt(x - 1, y - 1)$。

   **这个定义可能有些复杂，可以简化**：

   我们可以定义一个辅助函数 $sub(x, y)$，计算 $x - y$。

   但由于没有更复杂的语言特性，我们可以直接定义：

   $$
   lt(x, y) = \text{if } (x - y) \ \text{then } 1 \ \text{else } 0
   $$

   其中 $(x - y)$ 计算 $x - y$，如果结果为零（即 $x - y = 0$），则返回 $0$（真），表示 $x = y$。如果 $x - y < 0$，则结果为负数，非零，表示 $x < y$。

   **因此，修改定义为**：

   $$
   lt(x, y) = \text{if } (x - y) \ \text{then } 1 \ \text{else } 0
   $$

   但这并不能准确区分 $x < y$ 的情况。

   **更好的方法**：

   定义一个递归函数来比较 $x$ 和 $y$：

   $$
   lt(x, y) = \text{if } x \ \text{then } (\text{if } y \ \text{then } lt(x - 1, y - 1) \ \text{else } 1) \ \text{else } (\text{if } y \ \text{then } 0 \ \text{else } 1)
   $$

   这个函数递归地减少 $x$ 和 $y$，直到其中一个为零。

   - 如果 $x = 0$ 且 $y \ne 0$，则返回 $0$，表示 $x < y$。
   - 如果 $x \ne 0$ 且 $y = 0$，则返回 $1$，表示 $x \geq y$。
   - 如果 $x = y = 0$，则返回 $1$，表示 $x = y$。
   - 如果 $x$ 和 $y$ 都非零，递归比较 $x - 1$ 和 $y - 1$。

   **简化后的定义**：

   $$
   lt(x, y) = \text{if } y \ \text{then } (\text{if } x \ \text{then } lt(x - 1, y - 1) \ \text{else } 0) \ \text{else } 1
   $$

   **总结**：

   - 如果 $y = 0$，则返回 $1$（假），因为 $x \geq y$。
   - 如果 $x = 0$，$y \ne 0$，返回 $0$（真），因为 $x < y$。
   - 否则，递归比较 $x - 1$ 和 $y - 1$。

---

## 9.2 值调用的操作语义

假设有一个声明 $d$，由以下函数定义组成：

$$
\begin{cases}
f_1(x_1, \dots, x_{a_1}) = t_1 \\
\vdots \\
f_k(x_1, \dots, x_{a_k}) = t_k
\end{cases}
$$

其中，$t_i$ 是函数 $f_i$ 的定义，参数为 $x_1, \dots, x_{a_i}$，$i = 1, \dots, k$。

在这些定义的基础上，我们给出 REC 中**封闭项（closed terms）**的求值规则。

我们使用符号：

$$
t \ \xrightarrow{d}_{va} \ n
$$

表示**在声明 $d$ 下，项 $t$ 在值调用（call-by-value）模式下求值为整数值 $n$**。

求值关系的规则如下：

1. **（数字）**：

   $$
   \frac{}{\quad n \ \xrightarrow{d}_{va} \ n \quad} \quad \text{(num)}
   $$

   **解释**：数字 $n$ 求值为自身 $n$。

2. **（运算）**：

   $$
   \frac{t_1 \ \xrightarrow{d}_{va} \ n_1 \quad t_2 \ \xrightarrow{d}_{va} \ n_2}{\quad t_1 \ \text{op} \ t_2 \ \xrightarrow{d}_{va} \ n_1 \ \text{op} \ n_2 \quad} \quad \text{(op)}
   $$

   **解释**：对两个项 $t_1$ 和 $t_2$ 求值，得到 $n_1$ 和 $n_2$，然后计算 $n_1 \ \text{op} \ n_2$。

3. **（条件为真）**：

   $$
   \frac{t_0 \ \xrightarrow{d}_{va} \ n_0 \quad t_1 \ \xrightarrow{d}_{va} \ n_1 \quad n_0 = 0}{\quad \text{if } t_0 \ \text{then } t_1 \ \text{else } t_2 \ \xrightarrow{d}_{va} \ n_1 \quad} \quad \text{(condt)}
   $$

   **解释**：当条件 $t_0$ 求值为 $0$（真）时，求值 $t_1$。

4. **（条件为假）**：

   $$
   \frac{t_0 \ \xrightarrow{d}_{va} \ n_0 \quad t_2 \ \xrightarrow{d}_{va} \ n_2 \quad n_0 \ne 0}{\quad \text{if } t_0 \ \text{then } t_1 \ \text{else } t_2 \ \xrightarrow{d}_{va} \ n_2 \quad} \quad \text{(condf)}
   $$

   **解释**：当条件 $t_0$ 求值为非零（假）时，求值 $t_2$。

5. **（函数调用）**：

   $$
   \frac{t_1 \ \xrightarrow{d}_{va} \ n_1 \quad \dots \quad t_{a_i} \ \xrightarrow{d}_{va} \ n_{a_i} \quad t_i[n_1 / x_1, \dots, n_{a_i} / x_{a_i}] \ \xrightarrow{d}_{va} \ n}{\quad f_i(t_1, \dots, t_{a_i}) \ \xrightarrow{d}_{va} \ n \quad} \quad \text{(fn)}
   $$

   **解释**：

   - 首先，对参数 $t_1, \dots, t_{a_i}$ 逐个求值，得到 $n_1, \dots, n_{a_i}$。
   - 然后，将这些值替换到函数定义 $t_i$ 中的参数变量 $x_1, \dots, x_{a_i}$。
   - 最后，求值替换后的函数体 $t_i[n_1 / x_1, \dots, n_{a_i} / x_{a_i}]$，得到结果 $n$。

**注释**：

- **规则（num）**：直接求值数字。
- **规则（op）**：对运算符左右两边的项分别求值，然后应用对应的算术运算。
- **规则（condt）和（condf）**：根据条件的求值结果，选择求值分支。
- **规则（fn）**：严格按照值调用的方式，先求值参数，再应用函数定义。

### 例子

例如，对于加法操作：

$$
\frac{3 \ \xrightarrow{d}_{va} \ 3 \quad 4 \ \xrightarrow{d}_{va} \ 4}{\quad 3 + 4 \ \xrightarrow{d}_{va} \ 7 \quad} \quad \text{(op)}
$$

**注意**：我们将区分语法上的运算符 $\text{op}$ 和整数上的实际运算 $\text{op}$。

---

**命题9.2**：求值关系是确定的，即如果 $t \ \xrightarrow{d}_{va} \ n_1$ 且 $t \ \xrightarrow{d}_{va} \ n_2$，那么 $n_1 = n_2$。

**证明**：

- 通过对求值规则的结构归纳，可以证明对于给定的项 $t$，其求值结果是唯一的。
- 每个规则的应用都是确定的，没有非确定性的情况。

---

## 9.3 值调用的指称语义

在指称语义中，项的意义是在变量和函数变量的环境下赋予的。

### 变量环境

- **变量环境** $ρ$：是一个从变量集合 $\text{Var}$ 到整数集合 $\mathbb{N}$ 的函数：

  $$
  ρ : \text{Var} \rightarrow \mathbb{N}
  $$

- **变量环境的 cpo**：记作 $\text{Env}_{va} = [\text{Var} \rightarrow \mathbb{N}]$。

### 函数变量环境

- **函数变量环境** $φ$：是一个元组 $φ = (φ_1, \dots, φ_k)$，其中每个 $φ_i$ 是一个从整数元组到扩展整数的连续函数：

  $$
  φ_i \in [\mathbb{N}^{a_i} \rightarrow \mathbb{N}_\bot]
  $$

  其中 $\mathbb{N}_\bot$ 表示带底元素的整数 cpo，即 $\mathbb{N}$ 加上底元素 $\bot$。

- **函数变量环境的 cpo**：记作 $\text{Fenv}_{va} = [\mathbb{N}^{a_1} \rightarrow \mathbb{N}_\bot] \times \dots \times [\mathbb{N}^{a_k} \rightarrow \mathbb{N}_\bot]$。

### 项的指称

- 对于一个项 $t$，其指称是一个函数：

  $$
  [t]_{va} \in [\text{Fenv}_{va} \rightarrow [\text{Env}_{va} \rightarrow \mathbb{N}_\bot]]
  $$

- 指称函数 $[t]_{va}$ 的定义通过结构归纳给出：

  1. **数字**：

     $$
     [n]_{va} = λφ.λρ. \lnJ
     $$

     **解释**：数字 $n$ 的指称是一个恒等于 $n$ 的常函数。

  2. **变量**：

     $$
     [x]_{va} = λφ.λρ. ρ(x)
     $$

     **解释**：变量 $x$ 的指称是在环境 $ρ$ 中查找其值。

  3. **算术运算**：

     $$
     [t_1 \ \text{op} \ t_2]_{va} = λφ.λρ. [t_1]_{va}(φ)(ρ) \ \text{op}_\bot \ [t_2]_{va}(φ)(ρ)
     $$

     其中，$\text{op}_\bot$ 是算术运算 $\text{op}$ 的严格扩展（参见第8.3.4节）。

  4. **条件表达式**：

     $$
     [\text{if } t_0 \ \text{then } t_1 \ \text{else } t_2]_{va} = λφ.λρ. \text{Cond}([t_0]_{va}(φ)(ρ), [t_1]_{va}(φ)(ρ), [t_2]_{va}(φ)(ρ))
     $$

     其中，$\text{Cond}$ 是条件函数，定义如下（参见后面）。

  5. **函数调用**：

     $$
     [f_i(t_1, \dots, t_{a_i})]_{va} = λφ.λρ. (\text{let } v_1 \Leftarrow [t_1]_{va}(φ)(ρ), \dots, v_{a_i} \Leftarrow [t_{a_i}]_{va}(φ)(ρ) . φ_i(v_1, \dots, v_{a_i}))
     $$

     **解释**：

     - 首先，对参数 $t_1, \dots, t_{a_i}$ 进行求值，得到 $v_1, \dots, v_{a_i}$。
     - 然后，使用函数环境中的 $φ_i$ 计算 $φ_i(v_1, \dots, v_{a_i})$。

**注意**：

- 在算术运算中，使用了严格扩展的算术操作 $\text{op}_\bot$，即如果任一操作数为 $\bot$，结果为 $\bot$。
- 条件函数 $\text{Cond}$ 定义如下：

  $$
  \text{Cond}(z_0, z_1, z_2) = \begin{cases}
  z_1 & \text{如果 } z_0 = \l0J \\
  z_2 & \text{如果 } z_0 = \lnJ, n \ne 0 \\
  \bot & \text{否则}
  \end{cases}
  $$

- $\text{Cond}$ 可以通过布尔值的条件表达式来定义。

### 函数环境的确定

- 给定一个声明 $d$，由以下定义组成：

  $$
  \begin{cases}
  f_1(x_1, \dots, x_{a_1}) = d_1 \\
  \vdots \\
  f_k(x_1, \dots, x_{a_k}) = d_k
  \end{cases}
  $$

- 我们需要确定一个函数环境 $φ = (φ_1, \dots, φ_k)$，使得对于所有 $i$：

  $$
  φ_i = λn_1, \dots, n_{a_i}. [d_i]_{va} φ [n_1 / x_1, \dots, n_{a_i} / x_{a_i}]
  $$

  **解释**：

  - $φ_i$ 是一个从参数 $n_1, \dots, n_{a_i}$ 到 $\mathbb{N}_\bot$ 的函数。
  - 它的值由函数定义 $d_i$ 的指称，在变量环境 $ρ$ 中，其中 $x_j$ 被替换为对应的参数 $n_j$。

- 这些是递归方程，我们需要找到其最小不动点。

### 不动点的求解

- 定义一个连续函数 $F : \text{Fenv}_{va} \rightarrow \text{Fenv}_{va}$，使得：

  $$
  F(φ) = (λn_1, \dots, n_{a_1}. [d_1]_{va} φ [n_1 / x_1, \dots, n_{a_1} / x_{a_1}], \dots, λn_1, \dots, n_{a_k}. [d_k]_{va} φ [n_1 / x_1, \dots, n_{a_k} / x_{a_k}])
  $$

- 函数环境 $φ$ 是 $F$ 的不动点，即 $φ = F(φ)$。

- 利用不动点定理，我们可以找到 $F$ 的最小不动点：

  $$
  φ = \text{fix}(F)
  $$

- 这样，我们就确定了函数变量的含义。

### 闭项的求值

- 对于一个闭项 $t$，其指称为 $[t]_{va} φ ρ$，结果在 $\mathbb{N}_\bot$ 中。
- 由于 $t$ 是闭项，其指称结果与变量环境 $ρ$ 无关。

---

**例子**：

1. **捕获值调用的效果**：

   考虑以下声明：

   $$
   \begin{cases}
   f = f + 1 \\
   h(x) = 1
   \end{cases}
   $$

   - 这是一个零参数函数 $f$ 的递归定义。
   - 根据指称语义，$f$ 和 $h$ 的指称由 $φ = (φ_1, φ_2)$ 给出，其中：

     $$
     φ = \text{fix}(λφ. ([f + 1]_{va} φ, λm. [1]_{va} φ [m / x]))
     $$

   - 计算：

     - $φ_1 = \bot$，因为 $f$ 的定义导致无穷递归，其最小不动点为 $\bot$。
     - $φ_2 = λm. \l1J$，即 $h(x)$ 恒等于 $1$。

   - 因此：

     $$
     [f]_{va} φ ρ = φ_1 = \bot \\
     [h(f)]_{va} φ ρ = \bot
     $$

     因为在求值 $h(f)$ 时，需要先求值 $f$，但 $f$ 的求值发散，结果为 $\bot$。

2. **阶乘函数**：

   考虑以下声明：

   $$
   f(x) = \text{if } x \ \text{then } 1 \ \text{else } x \times f(x - 1)
   $$

   - 根据指称语义，我们需要求解 $φ = \text{fix}(F)$，其中 $F$ 是：

     $$
     F(φ) = λm. [\text{if } x \ \text{then } 1 \ \text{else } x \times f(x - 1)]_{va} φ [m / x]
     $$

   - 通过递归计算，我们可以得到 $φ(m) = m!$，即 $φ$ 实际上是阶乘函数。

---

## 9.4 值调用下语义的等价性

我们的目标是证明**操作语义**和**指称语义**是一致的。

**定理9.8**：对于闭项 $t$，整数 $n$，以及任意变量环境 $ρ$，有：

$$
t \ \xrightarrow{d}_{va} \ n \quad \Longleftrightarrow \quad [t]_{va} φ ρ = \lnJ
$$

其中，$φ$ 是由声明 $d$ 确定的函数环境，即 $φ = \text{fix}(F)$。

**证明思路**：

- 我们需要证明双向的蕴含：
  1. 如果 $t \ \xrightarrow{d}_{va} \ n$，则 $[t]_{va} φ ρ = \lnJ$。
  2. 如果 $[t]_{va} φ ρ = \lnJ$，则 $t \ \xrightarrow{d}_{va} \ n$。

- 证明将分为两个主要的引理，每个引理对应一个方向。

### 引理9.5（替换引理）

对于项 $t$，整数 $n$，有：

$$
[t]_{va} φ ρ [n / x] = [t [n / x]]_{va} φ ρ
$$

**解释**：在指称语义中，用 $n$ 替换变量 $x$，然后求值，等价于在项中先替换 $x$ 为 $n$，再求指称。

**证明**：

- 通过对项 $t$ 进行结构归纳，证明替换在指称语义下的等价性。

### 引理9.6

如果 $t$ 是闭项，$t \ \xrightarrow{d}_{va} \ n$，那么 $[t]_{va} φ ρ = \lnJ$。

**证明**：

- 使用规则归纳（rule induction）证明，对于所有的求值规则，如果操作语义中 $t$ 求值为 $n$，那么指称语义中 $[t]_{va} φ ρ = \lnJ$。
- 对每个规则，证明在假设前提成立的情况下，结论也成立。

### 引理9.7

对于闭项 $t$，如果 $[t]_{va} φ ρ = \lnJ$，那么 $t \ \xrightarrow{d}_{va} \ n$。

**证明**：

- 定义一个从操作语义导出的函数环境 $ψ$，使得对于所有 $i$，有：

  $$
  ψ_i(n_1, \dots, n_{a_i}) = \begin{cases}
  \lnJ & \text{如果 } t_i[n_1 / x_1, \dots, n_{a_i} / x_{a_i}] \ \xrightarrow{d}_{va} \ n \\
  \bot & \text{否则}
  \end{cases}
  $$

- 证明 $ψ$ 是函数 $F$ 的一个前不动点，即 $F(ψ) \sqsubseteq ψ$。
- 由于 $φ = \text{fix}(F)$ 是 $F$ 的最小不动点，且 $F$ 是单调连续的，因此 $φ \sqsubseteq ψ$。
- 利用指称语义的单调性，证明如果 $[t]_{va} φ ρ = \lnJ$，则 $t \ \xrightarrow{d}_{va} \ n$。

---

**结论**：

- 通过上述引理，我们证明了操作语义和指称语义在值调用下是等价的。

---

**总结**：

- 本章介绍了 REC 语言及其值调用的操作语义和指称语义。
- 我们定义了项、变量环境、函数环境以及项的指称语义。
- 通过构造函数环境的最小不动点，确定了函数变量的含义。
- 最后，我们证明了操作语义和指称语义的等价性，确保了语言语义定义的一致性。

### ---------------------------

# 第9章 递归方程（续）

## 9.5 名调用的操作语义

在名调用（call-by-name）模式下，我们为 REC 中的封闭项的求值指定规则。

假设有一个声明 $d$，包含以下定义方程：

$$
\begin{cases}
f_1(x_1, \dots, x_{a_1}) = d_1 \\
\vdots \\
f_k(x_1, \dots, x_{a_k}) = d_k
\end{cases}
$$

其中 $d_i$ 是函数 $f_i$ 的定义，$i = 1, \dots, k$。

在名调用的情况下，求值被形式化为关系 $t \ \xrightarrow{d}_{na} \ n$，表示**在声明 $d$ 下，项 $t$ 在名调用模式下求值为整数值 $n$**。

**求值关系的规则如下**：

1. **（数字）**：

   $$
   \frac{}{\quad n \ \xrightarrow{d}_{na} \ n \quad} \quad \text{(num)}
   $$

   **解释**：

   - **前提条件**：无。
   - **结论**：数字 $n$ 求值为自身 $n$。

2. **（运算）**：

   $$
   \frac{t_1 \ \xrightarrow{d}_{na} \ n_1 \quad t_2 \ \xrightarrow{d}_{na} \ n_2}{\quad t_1 \ \text{op} \ t_2 \ \xrightarrow{d}_{na} \ n_1 \ \text{op} \ n_2 \quad} \quad \text{(op)}
   $$

   **解释**：

   - **前提条件**：
     - $t_1$ 求值为 $n_1$。
     - $t_2$ 求值为 $n_2$。
   - **结论**：$t_1 \ \text{op} \ t_2$ 求值为 $n_1 \ \text{op} \ n_2$。
   - **符号说明**：
     - $\text{op}$ 表示加法、减法或乘法运算。

3. **（条件为真）**：

   $$
   \frac{t_0 \ \xrightarrow{d}_{na} \ n_0 \quad t_1 \ \xrightarrow{d}_{na} \ n_1 \quad n_0 = 0}{\quad \text{if } t_0 \ \text{then } t_1 \ \text{else } t_2 \ \xrightarrow{d}_{na} \ n_1 \quad} \quad \text{(condt)}
   $$

   **解释**：

   - **前提条件**：
     - $t_0$ 求值为 $n_0$。
     - $t_1$ 求值为 $n_1$。
     - $n_0 = 0$（条件为真）。
   - **结论**：$\text{if } t_0 \ \text{then } t_1 \ \text{else } t_2$ 求值为 $n_1$。

4. **（条件为假）**：

   $$
   \frac{t_0 \ \xrightarrow{d}_{na} \ n_0 \quad t_2 \ \xrightarrow{d}_{na} \ n_2 \quad n_0 \ne 0}{\quad \text{if } t_0 \ \text{then } t_1 \ \text{else } t_2 \ \xrightarrow{d}_{na} \ n_2 \quad} \quad \text{(condf)}
   $$

   **解释**：

   - **前提条件**：
     - $t_0$ 求值为 $n_0$。
     - $t_2$ 求值为 $n_2$。
     - $n_0 \ne 0$（条件为假）。
   - **结论**：$\text{if } t_0 \ \text{then } t_1 \ \text{else } t_2$ 求值为 $n_2$。

5. **（函数调用）**：

   $$
   \frac{d_i[t_1 / x_1, \dots, t_{a_i} / x_{a_i}] \ \xrightarrow{d}_{na} \ n}{\quad f_i(t_1, \dots, t_{a_i}) \ \xrightarrow{d}_{na} \ n \quad} \quad \text{(fn)}
   $$

   **解释**：

   - **前提条件**：将函数定义 $d_i$ 中的参数变量 $x_1, \dots, x_{a_i}$ 替换为对应的参数项 $t_1, \dots, t_{a_i}$，得到的新项 $d_i[t_1 / x_1, \dots, t_{a_i} / x_{a_i}]$ 求值为 $n$。
   - **结论**：$f_i(t_1, \dots, t_{a_i})$ 求值为 $n$。

**注意**：

- 与值调用的规则相比，唯一的区别在于最后一条规则（fn）。在名调用中，不需要在应用函数之前对参数进行求值。
- **求值关系是确定性的**。

---

**命题9.9**：如果 $t \ \xrightarrow{d}_{na} \ n_1$ 且 $t \ \xrightarrow{d}_{na} \ n_2$，那么 $n_1 = n_2$。

**证明**：

- 通过对求值规则的**规则归纳（rule induction）**，可以证明对于给定的项 $t$，其求值结果是唯一的。
- 每个规则的应用都是确定的，没有非确定性的情况。
- 因此，求值关系是确定的。

---

## 9.6 名调用的指称语义

与值调用类似，我们将项赋予指称语义，即在变量和函数变量的环境下，将其映射为 $N_\bot$ 中的值。不过，在名调用的情况下，环境的形式略有不同。这是因为在名调用中，函数不需要预先对其参数进行求值。

### 变量环境

- **变量环境** $ρ$：是一个从变量集合 $\text{Var}$ 到扩展整数 $N_\bot$ 的函数：

  $$
  ρ : \text{Var} \rightarrow N_\bot
  $$

- **变量环境的 cpo**：记作 $\text{Env}_{na} = [\text{Var} \rightarrow N_\bot]$。

### 函数变量环境

- **函数变量环境** $φ$：是一个元组 $φ = (φ_1, \dots, φ_k)$，其中每个 $φ_i$ 是一个从项的元组到 $N_\bot$ 的连续函数：

  $$
  φ_i : N_\bot^{a_i} \rightarrow N_\bot
  $$

- **函数变量环境的 cpo**：记作 $\text{Fenv}_{na} = [N_\bot^{a_1} \rightarrow N_\bot] \times \dots \times [N_\bot^{a_k} \rightarrow N_\bot]$。

### 项的指称

- 对于一个项 $t$，其指称是一个函数：

  $$
  [t]_{na} \in [\text{Fenv}_{na} \rightarrow [\text{Env}_{na} \rightarrow N_\bot]]
  $$

- 指称函数 $[t]_{na}$ 的定义通过结构归纳给出：

  1. **数字**：

     $$
     [n]_{na} = λφ.λρ. \lnJ
     $$

     **解释**：数字 $n$ 的指称是一个恒等于 $n$ 的常函数。

  2. **变量**：

     $$
     [x]_{na} = λφ.λρ. ρ(x)
     $$

     **解释**：变量 $x$ 的指称是在环境 $ρ$ 中查找其值。

  3. **算术运算**：

     $$
     [t_1 \ \text{op} \ t_2]_{na} = λφ.λρ. [t_1]_{na} φ ρ \ \text{op}_\bot \ [t_2]_{na} φ ρ
     $$

     **解释**：对 $t_1$ 和 $t_2$ 的指称求值，然后应用严格扩展的算术运算 $\text{op}_\bot$。

  4. **条件表达式**：

     $$
     [\text{if } t_0 \ \text{then } t_1 \ \text{else } t_2]_{na} = λφ.λρ. \text{Cond}([t_0]_{na} φ ρ, [t_1]_{na} φ ρ, [t_2]_{na} φ ρ)
     $$

     **解释**：使用条件函数 $\text{Cond}$，根据 $t_0$ 的指称结果，选择 $t_1$ 或 $t_2$ 的指称结果。

  5. **函数调用**：

     $$
     [f_i(t_1, \dots, t_{a_i})]_{na} = λφ.λρ. φ_i([t_1]_{na} φ ρ, \dots, [t_{a_i}]_{na} φ ρ)
     $$

     **解释**：直接将参数的指称结果传递给函数环境中的 $φ_i$，而不预先对参数求值。

**注意**：

- **条件函数 $\text{Cond}$** 定义与之前相同，处理 $\bot$ 的情况。
- 在名调用中，变量环境 $ρ$ 将变量映射到 $N_\bot$，而不是 $N$，以支持未求值的参数。

---

**引理9.10**：对于 REC 的所有项 $t$，其指称 $[t]_{na}$ 是一个连续函数：

$$
[t]_{na} \in [\text{Fenv}_{na} \rightarrow [\text{Env}_{na} \rightarrow N_\bot]]
$$

**证明**：

- 通过对项 $t$ 的结构归纳，并使用第8.4节中的结果，可以证明 $[t]_{na}$ 是连续的。
- 每个构造（数字、变量、运算、条件、函数调用）的指称都是由连续函数组合而成的，因此整体是连续的。

---

**引理9.11**：对于 REC 的所有项 $t$，如果环境 $ρ, ρ' \in \text{Env}_{na}$ 在 $t$ 中出现的所有变量上给出的结果相同，那么对于任意 $φ \in \text{Fenv}_{na}$，有：

$$
[t]_{na} φ ρ = [t]_{na} φ ρ'
$$

特别地，闭项 $t$ 的指称 $[t]_{na} φ ρ$ 与变量环境 $ρ$ 无关。

**证明**：

- 通过对项 $t$ 的结构归纳，可以证明当 $ρ$ 和 $ρ'$ 在 $t$ 中的变量上相同时，$[t]_{na} φ ρ$ 和 $[t]_{na} φ ρ'$ 相等。
- 由于闭项 $t$ 不含变量，其指称与 $ρ$ 无关。

---

### 函数环境的确定

声明 $d$ 由以下定义组成：

$$
\begin{cases}
f_1(x_1, \dots, x_{a_1}) = d_1 \\
\vdots \\
f_k(x_1, \dots, x_{a_k}) = d_k
\end{cases}
$$

定义函数 $F : \text{Fenv}_{na} \rightarrow \text{Fenv}_{na}$，使得：

$$
F(φ) = (λz_1, \dots, z_{a_1}. [d_1]_{na} φ [z_1 / x_1, \dots, z_{a_1} / x_{a_1}], \dots, λz_1, \dots, z_{a_k}. [d_k]_{na} φ [z_1 / x_1, \dots, z_{a_k} / x_{a_k}])
$$

其中，$z_i \in N_\bot$。

**注意**：

- 变量环境的更新操作可以在第8.4节的元语言中定义。
- $F$ 是连续的，因此存在其最小不动点：

  $$
  φ = \text{fix}(F)
  $$

---

**例子**：

为了了解指称语义如何捕获名调用的求值方式，考虑以下声明：

$$
\begin{cases}
f = f + 1 \\
h(x) = 1
\end{cases}
$$

根据名调用的指称语义，$f$ 和 $h$ 的指称由 $φ = (φ_1, φ_2)$ 给出，其中：

$$
\begin{align*}
(φ_1, φ_2) &= \text{fix}(λφ. ([f + 1]_{na} φ, λz \in N_\bot. [1]_{na} φ [z / x])) \\
&= \text{fix}(λφ. (φ_1 +_\bot 1, λz \in N_\bot. \l1J)) \\
&= (\bot, λz \in N_\bot. \l1J)
\end{align*}
$$

- $φ_1 = \bot$，因为 $f$ 的定义导致无限递归，其最小不动点为 $\bot$。
- $φ_2 = λz \in N_\bot. \l1J$，即 $h(x)$ 恒等于 $1$，与参数 $x$ 无关。

因此，对于闭项 $t$，我们有：

$$
[t]_{na} φ ρ = \lnJ \quad \text{当且仅当} \quad t \ \xrightarrow{d}_{na} \ n
$$

---

## 9.7 名调用下语义的等价性

证明名调用下操作语义和指称语义的等价性的总体策略与值调用的情况类似。一方面，我们使用规则归纳，另一方面，我们利用不动点的性质，不过方式有所不同。我们从一个关于替换的引理开始。

### 引理9.12（替换引理）

设 $t, t'$ 为项，$φ \in \text{Fenv}_{na}$，$ρ \in \text{Env}_{na}$。则有：

$$
[t]_{na} φ ρ [[t']_{na} φ ρ / x] = [t [t' / x]]_{na} φ ρ
$$

**解释**：在指称语义中，用 $[t']_{na} φ ρ$ 替换变量 $x$ 的指称，然后求值，等价于在项中先替换 $x$ 为 $t'$，再求指称。

**证明**：

- 通过对项 $t$ 进行简单的结构归纳，可以证明上述等式成立。
- 这个证明留作练习。

---

### 引理9.13

设 $t$ 为闭项，$n$ 为整数，$ρ$ 为变量环境。如果 $t \ \xrightarrow{d}_{na} \ n$，则 $[t]_{na} φ ρ = \lnJ$。

**证明**：

- 我们对闭项 $t$ 和整数 $n$，定义性质 $P(t, n)$：

  $$
  P(t, n) \quad \Longleftrightarrow \quad [t]_{na} φ ρ = \lnJ
  $$

- 通过**规则归纳（rule induction）**，证明当 $t \ \xrightarrow{d}_{na} \ n$ 时，$P(t, n)$ 成立。

- **对于规则（num）**：

  - $n \ \xrightarrow{d}_{na} \ n$。
  - $[n]_{na} φ ρ = \lnJ$。
  - 因此，$P(n, n)$ 成立。

- **对于规则（op）**：

  - 假设 $t_1 \ \xrightarrow{d}_{na} \ n_1$，$t_2 \ \xrightarrow{d}_{na} \ n_2$，并且 $P(t_1, n_1)$，$P(t_2, n_2)$ 成立。
  - 计算 $[t_1 \ \text{op} \ t_2]_{na} φ ρ = [t_1]_{na} φ ρ \ \text{op}_\bot \ [t_2]_{na} φ ρ = \ln_1J \ \text{op}_\bot \ \ln_2J = \ln_1 \ \text{op} \ n_2J$。
  - 因此，$P(t_1 \ \text{op} \ t_2, n_1 \ \text{op} \ n_2)$ 成立。

- **对于规则（condt）和（condf）**：

  - 类似处理，依据条件计算结果，证明 $P$ 性质成立。

- **对于规则（fn）**：

  - 假设 $d_i[t_1 / x_1, \dots, t_{a_i} / x_{a_i}] \ \xrightarrow{d}_{na} \ n$，并且 $P(d_i[t_1 / x_1, \dots, t_{a_i} / x_{a_i}], n)$ 成立。
  - 根据函数调用的指称语义：

    $$
    [f_i(t_1, \dots, t_{a_i})]_{na} φ ρ = φ_i([t_1]_{na} φ ρ, \dots, [t_{a_i}]_{na} φ ρ)
    $$

  - 由于 $φ$ 是不动点，满足：

    $$
    φ_i(z_1, \dots, z_{a_i}) = [d_i]_{na} φ [z_1 / x_1, \dots, z_{a_i} / x_{a_i}]
    $$

  - 因此，有：

    $$
    [f_i(t_1, \dots, t_{a_i})]_{na} φ ρ = [d_i]_{na} φ [[t_1]_{na} φ ρ / x_1, \dots, [t_{a_i}]_{na} φ ρ / x_{a_i}] ρ
    $$

  - 根据替换引理（引理9.12），有：

    $$
    [d_i [t_1 / x_1, \dots, t_{a_i} / x_{a_i}]]_{na} φ ρ = \lnJ
    $$

  - 因此，$P(f_i(t_1, \dots, t_{a_i}), n)$ 成立。

- 因此，通过规则归纳，证明了当 $t \ \xrightarrow{d}_{na} \ n$ 时，$[t]_{na} φ ρ = \lnJ$。

---

### 引理9.14

设 $t$ 为闭项，$n$ 为整数，$ρ$ 为变量环境。如果 $[t]_{na} φ ρ = \lnJ$，则 $t \ \xrightarrow{d}_{na} \ n$。

**证明**：

- 令 $φ = \text{fix}(F)$，并定义其近似序列 $φ^{(r)}$，即：

  $$
  φ^{(0)} = \bot \\
  φ^{(r+1)} = F(φ^{(r)})
  $$

- 我们通过对 $r$ 进行数学归纳，证明对于所有闭项 $t$：

  $$
  [t]_{na} φ^{(r)} ρ \sqsubseteq \text{res}(t)
  $$

  其中，$\text{res}(t) = \lnJ$，如果 $t \ \xrightarrow{d}_{na} \ n$；否则，$\text{res}(t) = \bot$。

- **基始情况**（$r = 0$）：

  - $φ^{(0)} = \bot$。
  - 对于所有函数变量，$φ_i^{(0)} = \bot$。
  - 对于闭项 $t$，由于函数变量的指称为 $\bot$，因此 $[t]_{na} φ^{(0)} ρ$ 至多为 $\bot$。
  - 因此，$[t]_{na} φ^{(0)} ρ \sqsubseteq \text{res}(t)$。

- **归纳步骤**（假设对于 $r$ 成立，证明对于 $r + 1$ 也成立）：

  - 对于函数变量 $f_i$，有：

    $$
    φ_i^{(r+1)}(z_1, \dots, z_{a_i}) = [d_i]_{na} φ^{(r)} [z_1 / x_1, \dots, z_{a_i} / x_{a_i}] ρ
    $$

  - 对于闭项 $t$，通过结构归纳，证明 $[t]_{na} φ^{(r+1)} ρ \sqsubseteq \text{res}(t)$。

  - 关键在于处理函数调用的情况，利用归纳假设和指称函数的单调性。

- 由于 $φ^{(r)}$ 单调递增，且 $φ = \bigsqcup_{r} φ^{(r)}$，因此有：

  $$
  [t]_{na} φ ρ = \bigsqcup_{r} [t]_{na} φ^{(r)} ρ \sqsubseteq \text{res}(t)
  $$

- 如果 $[t]_{na} φ ρ = \lnJ$，则存在 $r$，使得 $[t]_{na} φ^{(r)} ρ = \lnJ$，因此 $t \ \xrightarrow{d}_{na} \ n$。

---

**定理9.15**：对于闭项 $t$，整数 $n$，有：

$$
t \ \xrightarrow{d}_{na} \ n \quad \Longleftrightarrow \quad [t]_{na} φ ρ = \lnJ
$$

其中，$φ = \text{fix}(F)$。

**证明**：

- 结合引理9.13和引理9.14，完成证明。

---

**练习9.16**：

**问题**：在上述引理9.14的证明中使用的方法可以替代先前在值调用情况下的证明。请使用对近似序列的数学归纳，给出引理9.7的另一种证明。

**解答**：

- **思路**：

  - 在值调用情况下，我们可以定义函数环境的近似序列 $φ^{(r)}$，并使用数学归纳证明，对于所有闭项 $t$，有：

    $$
    [t]_{va} φ^{(r)} ρ \sqsubseteq \text{res}(t)
    $$

    其中，$\text{res}(t) = \lnJ$，如果 $t \ \xrightarrow{d}_{va} \ n$；否则，$\text{res}(t) = \bot$。

  - 通过对 $r$ 进行归纳，类似地处理函数调用和其他构造，证明指称语义与操作语义的等价性。

- **步骤**：

  1. 定义函数环境的近似序列：

     $$
     φ^{(0)} = \bot \\
     φ^{(r+1)} = F(φ^{(r)})
     $$

  2. 对于 $r = 0$，证明基始情况成立。

  3. 假设对于 $r$ 成立，证明对于 $r + 1$ 也成立。

  4. 处理函数调用的情况，利用归纳假设和指称函数的单调性。

  5. 证明当 $[t]_{va} φ ρ = \lnJ$ 时，$t \ \xrightarrow{d}_{va} \ n$。

- **结论**：

  - 通过类似的方法，可以给出引理9.7的另一种证明，使用对近似序列的数学归纳。

---

## 9.8 局部声明

从编程语言的角度来看，REC 是相当受限的。特别地，REC 的一个程序本质上是一个待求值的项和一个声明的组合，用于确定其函数变量的含义。大多数函数式编程语言会允许根据需要定义函数变量，即允许局部声明，例如：

$$
\text{let rec } f(x_1, \dots, x_{a_f}) = d \ \text{in } t
$$

这为 $f$ 提供了一个递归定义，项 $t$ 在此定义下求值。

这些语言通常支持同时递归，例如：

$$
\text{let rec } f_1(x_1, \dots, x_{a_1}) = d_1, \dots, f_k(x_1, \dots, x_{a_k}) = d_k \ \text{in } t
$$

这同时递归地定义了一组函数 $f_1, \dots, f_k$。

### 指称语义的处理

为了理解如何为这样的语言给出指称语义，考虑以下例子：

$$
S = \text{let rec } A = t \ \text{and } B = u \ \text{in } v
$$

其中，$A$ 和 $B$ 被假定为不同的、元数为 $0$ 的函数变量。为明确起见，假设求值是名调用的。

**S 的指称**可以表示为：

$$
[S]_{φ} ρ = [v]_{φ [α / A, β / B]} ρ
$$

其中，$(α, β)$ 是以下连续函数的最小不动点：

$$
(α, β) \mapsto ([t]_{φ [α / A, β / B]} ρ, [u]_{φ [α / A, β / B]} ρ)
$$

**解释**：

- 我们在函数环境 $φ$ 中，用新的定义 $A \mapsto α$，$B \mapsto β$ 来更新。
- $(α, β)$ 是一个递归方程的最小不动点，定义了 $A$ 和 $B$ 的含义。

---

**练习9.17**：

**问题**：

1. 写出扩展 REC 的语法，以支持局部声明。
2. 尝试为扩展的语言在名调用下提供指称语义。
3. 在值调用的情况下，如何修改你的语义？

**解答**：

1. **扩展语法**：

   在 REC 的基础上，添加局部声明的语法规则：

   $$
   t ::= \dots \mid \text{let rec } f(x_1, \dots, x_{a_f}) = d \ \text{in } t \mid \text{let rec } f_1 = d_1, \dots, f_k = d_k \ \text{in } t
   $$

2. **名调用下的指称语义**：

   - 对于局部声明 $\text{let rec } f = d \ \text{in } t$，其指称可以定义为：

     $$
     [\text{let rec } f = d \ \text{in } t]_{φ} ρ = [t]_{φ [α / f]} ρ
     $$

     其中，$α$ 是以下不动点：

     $$
     α = [d]_{φ [α / f]} ρ
     $$

   - 对于多个函数的同时递归定义，类似处理，求解一个不动点。

3. **值调用下的修改**：

   - 在值调用下，变量环境和函数环境的定义不同，需要在指称语义中体现。
   - 在函数调用时，需要对参数进行求值，然后再应用函数定义。
   - 更新指称语义的定义，确保在函数调用的指称中，参数被预先求值。

---

**总结**：

- 虽然同时递归增加了语言的表达能力，但实际上，对于支持单个函数的局部声明的语言来说，同时递归并没有增加表达能力，尽管它可以提高效率。
- 例如，上述程序 $S$ 可以被替换为：

  $$
  T = \text{let rec } B = (\text{let rec } A = t \ \text{in } u) \ \text{in } (\text{let rec } A = t \ \text{in } v)
  $$

  其中，$A$ 和 $B$ 是不同的、元数为 $0$ 的函数变量。

- 证明这是合法的，是 Bekić 定理的本质内容，我们将在下一章讨论。

---

## 9.9 进一步阅读

关于递归方程的语言和语义的其他介绍可以在以下文献中找到：[59]、[21]、[13] 和 [58]（后者基于 [13]），尽管这些文献主要集中在名调用的情况。Zohar Manna 的书 [59] 包含了 Jean Vuillemin 关于递归方程的论文工作 [99]。

本章受到了 Robin Milner 的一些旧讲义的影响，这些讲义基于 Gordon Plotkin 早期的笔记（尽管这里的证明有所不同）。值调用情况下的证明类似于 Andrew Pitts 的剑桥讲义 [75]。

对于通过局部声明扩展的语言，其操作语义可能变得有些复杂，至少对于静态绑定，需要携带关于声明时环境的信息——参见 [101] 以获取一个初级的介绍。

---

**注**：文中的数字 [59]、[21]、[13] 等是参考文献的编号，可以在原书的参考文献部分找到对应的文献信息。

### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------
[toc]



### **第15章 表示定理**

#### **引言**

本章的目标是研究系统 **F** 的“力量”，以识别可表示的算法类。例如，如果 **f** 是类型为 **Int→Int** 的封闭项（closed term），它对应一个从自然数到自然数的函数 **|f|**，定义为：

$$
f(n) \longrightarrow |f|(n)
$$

其中，**|f|** 是一个集合论意义上的函数。

**|f|** 是一个递归函数，实际上我们有一个计算它的过程：

1. **构造项**：写出项 **f(n)**。
2. **归约**：对 **f(n)** 进行规范化（normalisation）；由于强规范化定理，我们知道任何归约策略都将使其达到（相同的）正常形。
3. **观察结果**：规范化的结果是一个数码（numeral） **m**；我们已经看到，对于系统 **T**，这是正确的，对系统 **F** 也同样适用，我们将在后面证明。
4. **定义函数值**：设 **|f|(n) = m**。

在本章的第一部分，我们将证明 **|f|** 在二阶 Peano 算术（PA₂）中是可证明全定义的（provably total）。这需要仔细研究上一章中强规范化的证明。

在第二部分，我们将再次使用 **Heyting** 的思想，主要是 **Martin-Löf** 的实现方法（realisability method），证明其逆命题：如果一个函数在 PA₂ 中是可证明全定义的，那么它是可表示的。

---

### **15.1 可表示函数**

#### **15.1.1 数码（Numerals）**

**命题**：任何类型为 **Int = ΠX. X→(X→X)→X** 的封闭正常项 **t** 都是某个自然数 **n** 的数码。

**证明**：

- **头部正常形（Head Normal Form）**：在系统 **F** 中，我们可以使用头部正常形的概念（参见第3.4节）。
  
- **形式分析**：项 **t** 必须具有以下形式：
  
  $$
  \Lambda X.\ \lambda x^X.\ \lambda y^{X \to X}.\ v
  $$
  
  其中，**v** 类型为 **X**，因此不能是一个抽象。

- **归纳证明**：我们证明 **v** 的形式为：

  $$
  y\ (y\ (\dots\ (y\ x)\ \dots))
  $$

  即对 **x** 应用 **n** 次 **y**，其中 **n** 是自然数。

- **细节**：

  - 如果 **v** 是 **w\ u** 或 **w\ U**，且 **w \ne y**，由于 **v** 是正常的，**w** 必须是 **w'\ u'** 或 **w'\ U'** 的形式，但 **w'** 的类型比 **x** 和 **y** 更复杂，因此 **w'** 必须是一个抽象，这与 **v** 正常形的假设矛盾。

  - 因此，**v** 要么是 **x**，对应 **n = 0**，要么是 **y\ v'**，其中对 **v'** 应用归纳假设。

---

**备注**：如果我们采用类型 **Int = ΠX. (X→X)→(X→X)** 的变体，我们将得到几乎相同的结果，但对于 **1** 存在一个变体：

$$
\Lambda X.\ \lambda y^{X \to X}.\ y
$$

这反映了语法中的一些小瑕疵。在归纳数据类型中也会出现类似的情况，即类型 **T** 的封闭正常形“几乎”是由构造函数 **f_i** 组合而成的项，但通常只是在“几乎”的意义上。

然而，归纳类型的递归方案，按照 **f_i** 定义，表明这些由 **f_i** 构造的项在某种精确的意义上在其他项中是“稠密”的。

---

#### **15.1.2 全递归函数**

回到最初的问题，我们想要刻画在系统 **F** 中可表示的函数。我们已经看到，这些函数是递归的，即可计算的。

**命题**：存在一个全递归函数，它在系统 **F** 中不可表示。

**证明**：

- **选择函数**：我们选择**规范化操作**作为函数。这是一个将项（用整数表示）映射到其规范形的函数。

- **编码**：我们将项表示为固定有限字母表的符号串，因此可以编码为整数。

- **函数定义**：

  - 如果整数 **n** 编码项 **t**，且 **u** 是 **t** 的规范形，编码为 **m**，则定义 **N(n) = m**。

  - 如果 **n** 不编码任何系统 **F** 的项，则令 **N(n) = 0**。

- **不可表示性**：

  - **假设反证**：假设存在类型为 **Int→Int** 的项 **t**，表示函数 **N**。

  - 设 **n** 是 **t** 的编码。

  - 构造项 **t\ n**，其编码为 **A(n, ](n))**，其中 **A**、**]**、**[** 是一些可在系统 **F** 中表示的函数。

  - 然后，**N(A(n, ](n)))** 是 **t\ n** 的规范形的编码。

  - 根据定义，**t\ n** 规范化为 **N(A(n, ](n))) = ](D(n))**，其中 **D(n) = [(N(A(n, ](n)))) + 1**。

  - 于是，得到 **D(n) = D(n) + 1**，矛盾。

- **结论**：因此，**N** 不能在系统 **F** 中表示。

**说明**：这是递归理论中一个著名结果的变体，即全递归函数的集合不能被单一的全递归函数枚举。

---

#### **15.1.3 可证明全定义的函数**

一个从自然数到自然数的全递归函数 **f**，如果在某个算术系统 **A** 中可证明其全定义（provably total），则称为 **A** 中的可证明全定义函数。

- **形式化**：存在一个算法 **e**，代表 **f**，使得 **A** 证明了“对于所有 **n**，程序 **e**，输入 **n**，终止并返回一个整数”的公式。

- **举例**：使用 Kleene 表示法，**A** 证明：

  $$
  \forall n.\ \exists m.\ T_1(e, n, m)
  $$

  其中，**T₁(e, n, m)** 表示程序 **e** 在输入 **n** 上终止，输出 **m**。

- **说明**：终止性通常由一个 **Π₀²** 公式表达。

---

**在第7.4节**，我们看到系统 **T** 中可表示的函数在 Peano 算术 **PA** 中是可证明全定义的，反之亦然。

在这里，我们有：

**命题**：系统 **F** 中可表示的函数在二阶 Peano 算术 **PA₂** 中是可证明全定义的。

**证明**：

- **算法描述**：类型为 **Int→Int** 的项 **f** 对应一个算法，给定输入 **n**，返回 **|f|(n)**。

- **终止性证明**：我们需要证明该算法终止。利用强规范化定理，通过检查证明中使用的数学原理，我们可以得到结果。

- **关键点**：主要涉及 **f** 的可约性，以及数码的可约性（这是直接的）。我们只使用有限的可约性，避免了可约性在全局上不可定义的问题。

- **可约性谓词**：可通过对项（编码为整数）的集合进行二阶量化来定义。

- **使用的数学原理**：

  - **归纳法**：对涉及到的类型的可约性谓词进行归纳。

  - **理解公理和二阶量化**：允许我们从参数化可约性中定义可约性候选。

- **结论**：PA₂ 正是具有归纳、理解和二阶量化的算术系统。

---

**备注**：

- **关于可证明全定义函数的地位**：

  - **如果算术系统 **A** 是 **1-一致的（1-consistent）**，即不证明任何错误的 **Σ₀¹** 公式（如我们希望 **PA**、**PA₂** 和 **ZF 集合论** 是这样的），那么通过对角线论证可以表明存在全递归函数不在 **A** 中可证明全定义。

  - **否则**（即使 **A** 是一致的，但不是 **1-一致的**，例如 **A = PA + ¬consis(PA)**），**A** 可以证明实际上是部分的递归函数的全定义性，甚至可以证明所有递归函数的全定义性（但基于错误的原因，或修改了程序）。

---

### **15.2 从证明到程序**

上述命题的逆命题也是成立的，因此我们有：

**定理**：系统 **F** 中可表示的函数正好是 **PA₂** 中可证明全定义的函数。

---

**原始证明**（[Gir71]）使用了一个技术性较强的函数解释（functional interpretation）方法。我们在这里给出一个更简单的证明，受 **[Martin-Löf 1970]** 的启发。

首先，我们将 **PA₂** 替换为其直觉主义版本 **HA₂**（Heyting 二阶算术），它更接近于系统 **F**。这是可行的，因为在证明算法的全定义性方面，**HA₂** 与 **PA₂** 一样强。

- **Gödel 翻译**：将 **¬¬** 放在“足够多的地方”，使得如果 **A** 在 **PA₂** 中可证，那么 **A^{¬¬}** 在 **HA₂** 中可证。

- **示例**：一个 **Π₀²** 公式 **∀n.\ ∃m.\ T₁(e, n, m)**，其 **¬¬** 翻译为 **∀n.\ ¬¬∃m.\ T₁(e, n, m)**。

- **结论**：标准的证明论考虑表明，第二个公式在 **HA₂** 中可证，当且仅当第一个公式可证。

---

#### **15.2.1 HA₂ 的形式化**

**变量类型**：

- **一阶变量**：ξ, η, ζ, ...
- **二阶变量**：X, Y, Z, ...

**基本函数符号**：

- **O**（零，零元函数符号）
- **S**（后继函数，单元函数符号）

**公式的构造**：

- **原子公式**：

  - **a ∈ X**，其中 **a** 是项（例如 **Sⁿ O** 或 **Sⁿ ξ**），**X** 是集合变量。
  - **a = b**，其中 **a** 和 **b** 是项。

- **逻辑联结词**：⇒（蕴涵），可以定义其他联结词，如 ∧，∨，⊥。

- **量词**：∀ξ.（对一阶变量的全称量化），∃ξ.（存在量化），∀X.（对集合变量的全称量化）

**注意**：∃X. 可以通过定义来引入，类似于第11.3节。

**等式的公理**：显然的（无量词）等式公理。

**关于 S 的公理**：

- **否定公理**：¬(S ξ = O)
- **相等性公理**：S ξ = S η ⇒ ξ = η

**自然演绎规则**（参见第2章和第10章）：

- 对于 ⇒，∀ξ.，∃ξ. 使用通常的规则。

- 对于 ∀X.，引入规则为：

  - **全称引入（∀₂I）**：

    $$
    \frac{\text{证明了 } A}{\forall X.\ A}
    $$

  - **全称消除（∀₂E）**：

    $$
    \frac{\forall X.\ A}{A[\{\xi.\ C\}/X]}
    $$

    - **解释**：在 **A** 中，将所有 **a ∈ X** 替换为 **C[a/ξ]**。

**理解公理的变体**：

- 通过 ∀₂E，我们可以得到 **∃Y.\ ∀ξ.(C \Leftrightarrow ξ ∈ Y)**。

**归纳模式**：

- 虽然没有显式的归纳模式，但可以定义：

  $$
  \text{Nat}(\xi) \triangleq \forall X.\ (O \in X \Rightarrow \forall η.\ (\eta \in X \Rightarrow S η \in X) \Rightarrow \xi \in X)
  $$

- 然后，可以证明归纳模式：

  $$
  A[O/ξ] \wedge \forall η.\ (\text{Nat}(η) \Rightarrow A[η/ξ] \Rightarrow A[S η/ξ]) \Rightarrow \forall η.\ (\text{Nat}(η) \Rightarrow A[η/ξ])
  $$

---

#### **15.2.2 HA₂ 到系统 F 的翻译**

将 HA₂ 的每个公式 **A** 映射到系统 **F** 的类型 **[[A]]**，定义如下：

1. **等式**：[[ a = b ]] = S，其中 **S** 是 **F** 中的任意固定类型，至少有一个封闭项，例如 **S = ΠX. X→X**。这表示等式没有算法内容。

2. **元素关系**：[[ a ∈ X ]] = X（视作 **F** 中的类型变量）

3. **蕴涵**：[[ A ⇒ B ]] = [[ A ]] → [[ B ]]

4. **一阶量化**：[[ ∀ξ. A ]] = [[ ∃ξ. A ]] = [[ A ]]

5. **二阶量化**：[[ ∀X. A ]] = ΠX. [[ A ]]

**注意**：

- 一阶变量 ξ, η, ... 在翻译中完全消失，因此 **[[ A[a/ξ] ]] = [[ A ]]**。

- 可以类似地定义其他联结词，例如：

  $$
  [[ A \wedge B ]] = \Pi X.\ ([[ A ]] \to [[ B ]] \to X) \to X
  $$

  其中 **X** 不在 **A** 或 **B** 中自由出现。

**示例**：

- **自然数类型**：

  $$
  [[ \text{Nat}(\xi) ]] = \Pi X.\ X \to (X \to X) \to X = \text{Int}
  $$

---

接下来，我们需要对 HA₂ 中的推导 **δ** 进行类似的翻译，将其从假设 **A_i** 推导出公式 **A**，并映射到系统 **F** 的项 **[[ δ ]]**，类型为 **[[ A ]]**，自由变量为类型 **[[ A_i ]]** 的变量 **x_i**。此外，此翻译必须尊重转换规则。

- **假设**：如果 **δ** 是假设 **A_i**，则 **[[ δ ]] = x_i**。

- **公理**：翻译为虚设项。

- **蕴涵规则**：在 **F** 中翻译为抽象和应用。

  - **引入规则（⇒I）**：如果 **δ** 是从假设 **C** 推导出 **B** 的证明，则翻译为 **λy. [[ δ ]]**，其中 **y** 对应于 **C**。

  - **消除规则（⇒E）**：如果对 **δ**（证明 **C**）和 **ε**（证明 **C ⇒ B**）应用 **⇒E**，则翻译为 **[[ ε ]] [[ δ ]]**。

- **一阶量化**：∀I、∀E、∃I 翻译为空，因为 **[[ A[a/ξ] ]] = [[ A ]]**。

- **存在量化消除（∃E）**：如果 **δ** 证明 **∃ξ. C**，**ε** 从 **C** 推导出 **D**，则完整的证明翻译为 **[[ ε ]] [[ δ ]]/y**，其中 **y** 对应于 **C**。

- **二阶量化（∀₂）**：

  - **引入规则（∀₂I）**：翻译为 **ΛX. [[ δ ]]**。

  - **消除规则（∀₂E）**：翻译为 **[[ δ ]] [[ C ]]**。

---

#### **15.2.3 可证明全定义函数的表示**

在 HA₂ 中，公式 **Nat(Sⁿ O)** 有一个（正常的）推导 **˘n**：

1. 假设 **O ∈ X**。
2. 通过反复应用 **S**，得到 **Sⁿ⁻¹ O ∈ X**。
3. 假设 **∀η. (η ∈ X ⇒ S η ∈ X)**。
4. 通过 **∀E**，得到 **Sⁿ⁻¹ O ∈ X ⇒ Sⁿ O ∈ X**。
5. 通过 **⇒E**，得到 **Sⁿ O ∈ X**。
6. 通过 **⇒I**，对假设进行抽象，得到完整的推导。

翻译到系统 **F** 中，对应于数码 **n**。

**引理**：**˘n** 是 **Nat(Sⁿ O)** 的唯一正常推导。

---

现在，设 **A[n, m]** 是表示算法在输入 **n** 上终止并输出 **m = f(n)** 的公式。假设我们有一个推导 **δ**，在 HA₂ 中证明了：

$$
\forall ξ. (\text{Nat}(ξ) ⇒ \exists η. (\text{Nat}(η) ∧ A[ξ, η]))
$$

则我们得到一个系统 **F** 的项 **[[ δ ]]**，类型为：

$$
[[ \forall ξ. (\text{Nat}(ξ) ⇒ \exists η. (\text{Nat}(η) ∧ A[ξ, η])) ]] = \text{Int} \to (\text{Int} \times [[ A ]])
$$

定义项 **t = λx. π_1 ([[ δ ]] x)**，类型为 **Int → Int**，它保留了定理的算法内容。

对于任意 **n ∈ N**，通过 **δ** 的推导，可以得到 **Nat(Sⁿ O)**，其翻译对应于 **n˘**。然后，通过 **δ**，得到 **∃η. (\text{Nat}(η) ∧ A[Sⁿ O, η])**。

由于推导是正常的，它最终以引入规则结束，得到 **Nat(Sᵐ O) ∧ A[Sⁿ O, Sᵐ O]**。应用 **∧1E**，得到 **Nat(Sᵐ O)** 的推导，其翻译等价于 **t n**。

根据引理，该推导规范化为 **˘m**，因此 **t n** 规范化为 **m**。由于 **A[Sⁿ O, Sᵐ O]** 在 HA₂ 中可证，因此在标准模型中为真，即 **m = f(n)**。

**结论**：**f** 在系统 **F** 中可表示。

---

**问题**：然而，我们的证明有一个错误：在 15.2.2 中，我们无法解释公理 **¬(S ξ = O)**，因为没有类型为 **[[ ¬(S ξ = O) ]] = S → \text{Emp}** 的封闭项。

**解决方法**：

- **引入垃圾项（junk term）**：在系统 **F** 中添加一个垃圾项 **Ω**，类型为 **\text{Emp} = ΠX. X**，将问题公理解释为 **λx^S. Ω**。

- **解释**：在规范化 **t n** 的过程中，这个垃圾项会消失，因为我们已经证明结果是一个数 **m**。

- **美学考虑**：但这并不理想，我们希望保持在纯粹的系统 **F** 中。

---

#### **15.2.4 无未定义对象的证明**

为了避免添加垃圾项，我们可以通过一种编码，将每个类型映射到一个可居住的类型，同时保持规范化，从而在纯粹的系统 **F** 中进行解释。

**命题**：对于系统 **F**（带有垃圾项）的任何类型为 **Int → Int** 的封闭项 **t**，存在纯粹系统 **F** 中的封闭项 **t'**，使得如果 **t n** 规范化为 **m**，则 **t' n** 也规范化为 **m**。

**结论**：如果 **t** 表示函数 **f**，那么 **t'** 也表示 **f**，因此表示定理（正确地）得证。

**证明**：

- **类型转换**：定义一个函数 **hh⋅ii**，将类型转换为可居住的类型：

  1. **基本类型**：hhXii = X
  2. **函数类型**：hhU → Vii = hhUii → hhVii
  3. **全称类型**：hhΠX. Vii = ΠX. X → hhVii

- **性质**：

  $$
  hhT[U/X]ii = hhTii[hhUii/X]
  $$

- **项的转换**：对项 **t**，定义 **hhtii**：

  - **变量**：hhy^{T}ii = y^{hhTii}
  - **抽象**：hhλy^{U}. vii = λy^{hhUii}. hhvii
  - **应用**：hht\ uii = hhtii\ hhuii
  - **类型抽象**：hhΛX. vii = ΛX. λx^{X}. hhvii（注意 **x** 可以在 **hhvii** 中出现）
  - **类型应用**：hht\ Uii = hhtii\ hhUii\ ι_{U}
  - **垃圾项**：hhΩii = ι_{\text{Emp}} = ΛX. λx^{X}. x

- **性质验证**：

  - **替换的保留**：

    $$
    hht[u/y^{U}]ii = hhtii[hhuii/y^{hhUii}]
    $$

  - **规范化的保留**：如果 **t → u**，则 **hhtii → hhuii**。

- **数码的转换**：

  - **类型**：hhIntii = ΠX. X → X → (X → X) → X

  - **数码项**：hhnii = ΛX. λx^{X}. λy^{X}. λz^{X \to X}. z^{n} y

- **最终项**：将类型为 **Int → Int** 且含有垃圾项的项 **t**，替换为纯系统 **F** 中的项：

  $$
  t' = λz^{\text{Int}}. \text{contract}(hhtii(\text{weaken}\ z))
  $$

  其中 **weaken** 和 **contract** 是用于调整类型的辅助函数。

---

### **总结**

本章通过深入研究系统 **F** 的表示能力，探讨了可表示函数的特性，证明了系统 **F** 中可表示的函数正好是二阶 Peano 算术 **PA₂** 中可证明全定义的函数。

- **主要结果**：

  - **系统 **F** 的强规范化**：所有系统 **F** 的项都是强规范化的。

  - **可表示函数的刻画**：系统 **F** 中可表示的函数是 **PA₂** 中可证明全定义的函数，反之亦然。

- **关键步骤**：

  - **证明系统 **F** 的函数在 **PA₂** 中可证明全定义**：通过分析强规范化证明，利用二阶量化和理解公理。

  - **从证明到程序的转换**：将 **HA₂** 中的证明翻译为系统 **F** 中的项。

  - **处理未定义对象的问题**：通过在系统 **F** 中引入垃圾项，或通过类型和项的转换，消除未定义对象，保持在纯系统 **F** 中。

- **方法论**：

  - **利用直觉主义算术 **HA₂** 和系统 **F** 之间的联系**。

  - **通过类型和项的转换，保留算法内容和规范化特性**。

---

### **后续展望**

- **进一步研究系统 **F** 的表示能力**：探讨其他类型系统的表示能力，研究更强系统（如 **System Fω**）的规范化和表示定理。

- **深入理解强规范化和可约性**：研究可约性候选和参数化可约性的更深层次性质，探索在不同逻辑系统中的应用。

- **逻辑和类型系统之间的桥梁**：继续探索逻辑证明与计算机程序之间的对应关系，深化对 **Curry-Howard 对应**的理解。

---

如果您对本章的任何部分有疑问，或者需要更详细的解释和推导，请随时提出来！

### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------
[toc]



### **第3章 Curry-Howard同构**

#### **引言**

在上一章中，我们看到**海廷（Heyting）**的思想在自然演绎的框架下表现得非常出色。我们将利用这一观察，通过建立一个**类型化项的形式系统**，来讨论隐藏在证明背后的**函数对象**。这个系统的意义将通过我们已经写下的**函数方程**来阐明。

事实上，这些方程可以以两种不同的方式来理解，这再次体现了**感觉（Sense）**和**指称（Denotation）**之间的二分：

- **静态观点**：将这些方程视为定义项的相等性的方程，即**指称的相等性**。这是一个静态的、描述性的视角。
- **动态观点**：将这些方程视为**重写规则**，允许我们通过**化简到正常形式**来计算项。这是一个**操作性的、动态的**视角，是在逻辑这一方面唯一真正有成果的视角。

然而，正如在逻辑中一样，**第二种观点**（动态的、操作性的）相对于第一种观点（静态的、指称的）发展得还不够充分。例如，关于程序的**指称语义**（如Scott的语义）非常丰富：在这种语义中，程序的执行过程中没有任何变化。然而，几乎没有任何成熟的关于程序的**操作语义**（我们不考虑那些粗略地将规范化步骤逐步解释的特设语义）。**建立一个真正的算法操作语义**可能是计算机科学中最重要的问题。

**类型和命题之间的对应关系**由[Howard]阐述。

---

### **3.1 λ演算**

#### **3.1.1 类型**

当我们以海廷的精神思考证明时，**公式变成了类型**。具体来说：

1. **原子类型**：$T_1, T_2, \dots, T_n$ 是类型。
2. **构造类型**：
   - 如果 $U$ 和 $V$ 是类型，那么 $U \times V$ 和 $U \to V$ 也是类型。
3. **类型的定义**：目前，只有通过上述方式（1和2）构造的类型才是类型。

这对应于命题演算的 $(\land, \Rightarrow)$ 片段：

- **原子命题**写作 $T_i$。
- **合取“$\land$”**对应于**笛卡尔积“$\times$”**。
- **蕴涵“$\Rightarrow$”**对应于**函数类型“$\to$”**。

#### **3.1.2 项**

**证明变成了项**；更准确地说，**一个公式 $A$ 的证明变成了一个类型为 $A$ 的项**。具体来说：

1. **变量项**：$x^T_0, x^T_1, x^T_2, \dots$ 是类型为 $T$ 的项。
   - **解释**：这些变量代表类型 $T$ 的任意项。
2. **构造对**：如果 $u$ 和 $v$ 分别是类型为 $U$ 和 $V$ 的项，那么 $\langle u, v \rangle$ 是类型为 $U \times V$ 的项。
3. **投影**：
   - **第一投影**：如果 $t$ 是类型为 $U \times V$ 的项，那么 $\pi_1 t$ 是类型为 $U$ 的项。
   - **第二投影**：$\pi_2 t$ 是类型为 $V$ 的项。
4. **λ抽象**：
   - 如果 $v$ 是类型为 $V$ 的项，$x^U_n$ 是类型为 $U$ 的变量，那么 $\lambda x^U_n . v$ 是类型为 $U \to V$ 的项。
   - **注意**：我们假设通过某种方式解决了**绑定变量**和**替换**的问题，这使我们可以忽略绑定变量的名字，认为绑定变量没有个性。
5. **应用**：
   - 如果 $t$ 和 $u$ 分别是类型为 $U \to V$ 和 $U$ 的项，那么 $t \ u$ 是类型为 $V$ 的项。

---

### **3.2 指称意义**

**类型**表示我们正在讨论的对象的种类。例如：

- 类型为 $U \to V$ 的对象是**从 $U$ 到 $V$ 的函数**。
- 类型为 $U \times V$ 的对象是一个**有序对**，由一个 $U$ 的对象和一个 $V$ 的对象组成。
- **原子类型**的具体含义取决于上下文。

**项**非常精确地遵循了我们用于海廷语义和自然演绎的五种模式：

1. **变量**：类型为 $T$ 的变量 $x^T$ 表示类型为 $T$ 的任意项 $t$（只要用 $t$ 替换 $x^T$）。
2. **构造对**：$\langle u, v \rangle$ 是 $u$ 和 $v$ 的有序对。
3. **投影**：$\pi_1 t$ 和 $\pi_2 t$ 分别是 $t$ 的第一个和第二个投影。
4. **λ抽象**：$\lambda x^U . v$ 是一个函数，将类型为 $U$ 的任意 $u$ 映射到 $v[u / x]$，即 $v$ 中的 $x^U$ 被视为 $u$ 的占位符。
5. **应用**：$t \ u$ 是将函数 $t$ 应用于参数 $u$ 的结果。

在**指称**层面，我们有以下（主要的）等式：

$$
\pi_1 \langle u, v \rangle = u \\
\pi_2 \langle u, v \rangle = v \\
(\lambda x^U . v) \ u = v[u / x]
$$

以及（次要的）等式：

$$
\langle \pi_1 t, \pi_2 t \rangle = t \\
\lambda x^U . (t \ x) = t \quad (\text{当 } x \text{ 不在 } t \text{ 中自由出现时})
$$

这些次要等式从未得到充分的重视。

#### **定理**

由这些等式给出的系统是**一致的**且**可判定的**。

- **一致性**：意味着对于不同的变量 $x$ 和 $y$，无法证明 $x = y$。
- 虽然这个结果对整个等式集合都成立，但人们通常只考虑前三个等式。
- 这个定理是**Church-Rosser 性质**和**规范化定理**（见第4章）的结果。

---

### **3.3 操作意义**

一般来说，**项代表程序**。程序的目的是**计算**（或至少以方便的形式呈现）其**指称**。程序的类型被视为一种**规范**，即程序（抽象地）做了什么。

#### **讨论：**

**相关的问题是**：这个规范的**相关部分**是什么？换句话说，当我们提供这类信息时，我们是否足够精确——例如，是否应该说明这个计算是如何完成的？或者是否过于精确——仅仅说明程序接受两个整数作为参数并返回一个整数是否足够？

**从句法的角度**，答案并不清楚：

- 例如，本书中考虑的类型系统只涉及最基本的信息（将整数映射到整数）。
- 而一些系统（如[KriPar]）提供了关于程序计算了什么的**指称性**信息。

#### **一般观点：**

抽象掉任何特定的句法选择，我们应该将**类型**视为**连接事物的说明**。

- 设想我们使用**模块**进行编程，即封闭的单元，可以将它们**插接（plug）**在一起。
- 一个模块是完全封闭的，我们无权打开它。
- 我们只能选择使用它与否，以及选择使用的方式（即如何插接）。
- **模块的类型**由所有可能的、不导致崩溃的插接方式完全确定。
- 特别地，我们总是可以在发生故障或为了优化目的时，用另一个相同类型的模块替换它。

这个**任意插接**的想法似乎是可以数学化的，但尝试这样做会使我们偏离太远。

#### **变量和值的双重性：**

- 一个类型为 $T$ 的项 $t$，依赖于类型分别为 $U_1, U_2, \dots, U_n$ 的变量 $x_1, x_2, \dots, x_n$，应被视为一个**插接说明**，而不是简单地将 $x_i$ 替换为类型为 $U_i$ 的项 $u_i$ 的结果。
- 该项有一些位置（根据传统，由变量表示），我们可以在其中插入适当类型的输入。
  - 例如，每个 $x_i$ 的出现对应于插入一个类型为 $U_i$ 的项 $u_i$ 的可能性，同一个项被同时插入到每个实例中。
- 同样，$t$ 本身，作为类型为 $T$ 的项，是一个插接说明，因此可以插入到另一个项中类型为 $T$ 的变量 $y$ 的位置。

这种将**变量**和**值**视为同一插接现象的双重方面的方法，使我们能够将算法的执行视为一个**对称的输入/输出过程**。

**操作性解释**仍处于萌芽状态（参见附录B）。

#### **重写规则：**

由于缺乏对如何操作性地解释项的更清晰的想法，我们采用了一种特设的概念，尽管不完美但还不错：

- 我们将 **3.2** 中的等式**非对称化**，并将它们变成**重写规则**。
- 这种重写可以被视为计算所讨论的项的一个初步程序。
- 这并不坏，因为我们缺乏的操作语义肯定与这个基于逻辑基本对称性的计算过程非常接近。

因此，我们可以希望通过对**规范化**的深入研究，在操作层面上取得进展。

---

### **3.4 转换**

#### **正常项的定义：**

一个项是**正常的**，如果它的任何子项都不具有以下形式：

1. $\pi_1 \langle u, v \rangle$
2. $\pi_2 \langle u, v \rangle$
3. $(\lambda x^U . v) \ u$

#### **转换（Conversion）：**

当一个项 $t$ 满足以下三种情况之一时，它可以**转换**为一个项 $t'$：

1. 如果 $t = \pi_1 \langle u, v \rangle$，则 $t' = u$。
2. 如果 $t = \pi_2 \langle u, v \rangle$，则 $t' = v$。
3. 如果 $t = (\lambda x^U . v) \ u$，则 $t' = v[u / x]$。

- **约简式（Redex）**：$t$ 称为**约简式**。
- **约简结果（Contractum）**：$t'$ 称为**约简结果**。
- 它们始终具有相同的类型。

#### **归约（Reduction）：**

- 一个项 $u$ **归约**到一个项 $v$，如果存在从 $u$ 到 $v$ 的转换序列，即存在序列 $u = t_0, t_1, \dots, t_{n-1}, t_n = v$，对于 $i = 0, 1, \dots, n-1$，$t_{i+1}$ 是通过将 $t_i$ 中的一个约简式替换为其约简结果而获得的。
- 我们记作 $u \to v$，表示“$u$ 归约到 $v$”。
- **$\to$** 是自反的和传递的关系。

#### **正常形式：**

- 一个项 $t$ 的**正常形式**是一个项 $u$，满足 $t \to u$，且 $u$ 是正常的。
- 我们将在下一章看到，**正常形式存在且唯一**。

#### **引理：**

一个项 $t$ 是正常的，当且仅当它是以下形式的**头部正常形式（Head Normal Form）**：

$$
\lambda x_1. \lambda x_2. \dots \lambda x_n. y \ u_1 \ u_2 \dots u_m
$$

- 其中 $y$ 可能是，也可能不是 $x_i$ 之一。
- 并且 $u_j$ 也是正常的。

**证明：**

- **归纳法**应用于 $t$：
  - 如果 $t$ 是一个变量或抽象，则无需处理。
  - 如果 $t$ 是一个应用，即 $t = u \ v$，我们对 $u$ 应用归纳假设。由于 $t$ 是正常的，$u$ 不能是一个抽象。

#### **推论：**

- 如果 $t$ 的自由变量的类型严格比 $t$ 的类型简单，或者特别地，如果 $t$ 是闭项（没有自由变量），那么它是一个抽象。

---

### **3.5 同构的描述**

这实际上只是对**证明与函数项之间对应关系**的精确陈述，现在函数项具有了精确的地位，我们可以精确地描述这一对应关系。

在一边，我们有带有**假设包裹（parcels of hypotheses）**的证明，这些包裹用整数标记；在另一边，我们有类型化项的系统。

#### **对应关系：**

1. **假设规则：**

   - 对于在包裹 $i$ 中的假设 $A$ 的推导：

     $$
     A \ (\text{在包裹 } i)
     $$

   - 对应的项是变量 $x^A_i$。

2. **合取引入（$\land$-Introduction）：**

   - 对于推导：

     $$
     \begin{array}{c}
     \vdots \\
     A \\
     \vdots \\
     B \\
     \hline
     A \land B
     \end{array}
     $$

   - 对应的项是 $\langle u, v \rangle$，其中 $u$ 和 $v$ 分别对应于 $A$ 和 $B$ 的推导。

3. **合取消去（$\land$-Elimination）：**

   - 对于推导：

     $$
     \begin{array}{c}
     \vdots \\
     A \land B \\
     \hline
     A
     \end{array}
     $$

     - 对应的项是 $\pi_1 t$，其中 $t$ 对应于 $A \land B$ 的推导。

   - 对于推导：

     $$
     \begin{array}{c}
     \vdots \\
     A \land B \\
     \hline
     B
     \end{array}
     $$

     - 对应的项是 $\pi_2 t$。

4. **蕴涵引入（$\Rightarrow$-Introduction）：**

   - 对于推导：

     $$
     \begin{array}{c}
     [A] \ (\text{包裹 } i) \\
     \vdots \\
     B \\
     \hline
     A \Rightarrow B
     \end{array}
     $$

   - 对应的项是 $\lambda x^A_i . v$，其中被消除的假设形成包裹 $i$，$v$ 对应于 $B$ 的推导。

5. **蕴涵消去（$\Rightarrow$-Elimination）：**

   - 对于推导：

     $$
     \begin{array}{c}
     \vdots \\
     A \\
     \vdots \\
     A \Rightarrow B \\
     \hline
     B
     \end{array}
     $$

   - 对应的项是 $t \ u$，其中 $t$ 和 $u$ 分别对应于 $A \Rightarrow B$ 和 $A$ 的推导。

---

### **3.6 同构的意义**

严格来说，**3.5** 中定义的是一个**双射（bijection）**。我们不能称之为**同构（isomorphism）**，因为这要求两边已经存在相同类型的结构。

事实上，自然演绎中存在**规范化**的传统：

- 一个证明是**规范的**，当且仅当它不包含任何引入规则和消去规则的序列，例如：

  1. **合取引入后立即合取消去：**

     $$
     \begin{array}{c}
     \vdots \\
     A \\
     \vdots \\
     B \\
     \hline
     A \land B \\
     \hline
     A
     \end{array}
     $$

  2. **蕴涵引入后立即蕴涵消去：**

     $$
     \begin{array}{c}
     [A] \\
     \vdots \\
     B \\
     \hline
     A \Rightarrow B \\
     \hline
     B
     \end{array}
     $$

对于这些情况，可以定义一个**转换**的概念。

在第2章中，我们通过“等于”一词来识别推导；现在，我们将这些识别视为**重写**，即将等式左边的推导重写为右边的推导。

#### **同构的建立：**

我们有一个**同构**，因为在我们已经引入的双射下，在两种情况下（并且从历史角度来看是独立的）引入的**转换**、**规范性**和**归约**的概念完全对应。

特别地，我们在 **3.4** 中提到的**规范化定理**在自然演绎中有一个精确的对应。

#### **头部正常形式：**

我们将在 **10.3.1** 节讨论**头部正常形式**的类似物。

#### **意义和影响：**

- **同构的兴趣**在于两边的**差异**，否则它的意义何在？
- 在我们感兴趣的情况下，**函数**一侧具有**操作性**，这是形式证明所不具备的。
- **证明**一侧以其**逻辑**方面为特点，先验地与算法考虑无关。

#### **方法论的影响：**

- **所有好的（构造性的）逻辑都必须具有操作性方面**。
- **反之，不能在不考虑隐含对称性的情况下使用类型化演算，这些对称性正是逻辑的对称性**。通常，基于逻辑谬误的类型改进是行不通的。

#### **总结：**

基本上，同构的两边无疑是**同一个对象**，偶然地以两种不同的方式表示。

- **证明**方面似乎更少依赖于偶然的直觉，是研究算法的方式。
- **函数**方面更具表现力，更直接，应该保留在**启发式**的角色。

---

### **总结**

本章深入探讨了 **Curry-Howard 同构**，即 **证明** 与 **程序** 之间的对应关系。

- 我们首先介绍了 **类型** 和 **项** 的定义，将命题逻辑的 $(\land, \Rightarrow)$ 片段对应到类型系统中。
- 接着，讨论了类型和项的 **指称意义**，以及项如何表示程序，程序的类型如何作为规范。
- 然后，我们探讨了项的 **操作意义**，并引入了 **转换** 和 **归约** 的概念，讨论了项的 **规范化**。
- 我们描述了 **证明和函数项之间的对应关系**，详细阐述了如何将自然演绎的推导转化为类型化的项。
- 最后，我们讨论了同构的意义，指出了两边的差异以及这对方法论的影响。

---

### **后续展望**

- 在后续章节中，我们将进一步研究 **规范化定理** 和 **一致性** 等结果。
- 我们将探讨更复杂的类型系统，例如涉及 **高阶类型** 和 **多态性** 的系统。
- 我们还将研究 **Curry-Howard 同构** 在计算机科学中的应用，例如在类型系统、编程语言设计和程序验证中的作用。

如果您对本章内容有任何疑问，或者需要进一步的解释，请随时提出来！

### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------
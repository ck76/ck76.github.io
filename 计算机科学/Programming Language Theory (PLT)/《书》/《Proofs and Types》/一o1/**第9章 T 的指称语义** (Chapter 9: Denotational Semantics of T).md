[toc]



### **第9章 T的指称语义学**

#### **引言**

第8章的构造为我们已经讨论的系统提供了一个很好的**指称语义学（Denotational Semantics）**。在本章中，我们将使用这些构造来解释简单类型演算以及 **G\"odel 的 System T**。

---

### **9.1 简单类型演算**

我们在这里提出对基于箭头类型（$\to$）和乘积类型（$\times$）的简单类型演算进行解释。

**基本思想是**：

- **λ-抽象**将一个函数（$x \mapsto t[x]$）转换为一个对象；
- **应用**将一个类型为 $U \to V$ 的对象 $t$ 关联到一个从 $U$ 到 $V$ 的函数 $u \mapsto t \ u$。

换句话说，**应用**和 **λ-抽象**是互逆的操作，它们将类型为 $U \to V$ 的对象和从 $U$ 到 $V$ 的函数联系起来。

因此，我们将如下解释它们：

- **λ-抽象**通过将一个从 $A$ 到 $B$ 的稳定函数映射到其轨迹（trace），即 $A \to B$ 中的一个点；
- **应用**通过将 $A \to B$ 中的一个点映射到由其轨迹定义的函数。

#### **9.1.1 类型**

假设我们已经为每个原子类型 $S_i$ 固定了一个一致空间 $[[S_i]]$；那么，我们可以通过以下方式为每个类型 $T$ 定义 $[[T]]$：

- $[[U \times V]] = [[U]] \otimes [[V]]$，其中 $\otimes$ 表示一致空间的**直积**（见第8章）；
- $[[U \to V]] = [[U]] \to [[V]]$，其中 $\to$ 表示一致空间之间的**函数空间**（见第8.5节）。

#### **9.1.2 项**

如果 $t[x_1, \dots, x_n]$ 是一个类型为 $T$ 的项，依赖于类型分别为 $S_i$ 的自由变量 $x_i$（注意，有些 $x_i$ 实际上可能并未出现在 $t$ 中），我们将它关联到一个从 $[[S_1]], \dots, [[S_n]]$ 到 $[[T]]$ 的**稳定函数** $[[t]]$。

**具体定义如下**：

1. **变量项**：如果 $t[x_1, \dots, x_n] = x_i$，则定义：

   $$
   [[t]](a_1, \dots, a_n) = a_i
   $$

   这个函数的稳定性是显然的，因为它只是选择了输入中的第 $i$ 个元素。

2. **对（pair）**：如果 $t = \langle u, v \rangle$，我们已知函数 $[[u]]$ 和 $[[v]]$，分别从 $[[S_1]], \dots, [[S_n]]$ 映射到 $[[U]]$ 和 $[[V]]$。我们定义一个从 $[[U]], [[V]]$ 到 $[[U]] \otimes [[V]]$ 的稳定二元函数 **Pair**，定义为：

   $$
   \text{Pair}(a, b) = \{1\} \times a \cup \{2\} \times b
   $$

   然后定义：

   $$
   [[t]](a_1, \dots, a_n) = \text{Pair}([[u]](a_1, \dots, a_n), [[v]](a_1, \dots, a_n))
   $$

   这个函数仍然是稳定的，因为它是由稳定函数组成的。

3. **投影（projection）**：对于 $t = \pi_1 w$ 或 $t = \pi_2 w$，我们使用以下两个稳定函数之一进行组合：

   - $\Pi_1(c) = \{ \alpha : (1, \alpha) \in c \}$，提取第一分量；
   - $\Pi_2(c) = \{ \beta : (2, \beta) \in c \}$，提取第二分量。

   然后定义：

   $$
   [[t]] = \Pi_i \circ [[w]]
   $$

   其中 $i = 1$ 或 $2$，具体取决于 $t$ 是 $\pi_1 w$ 还是 $\pi_2 w$。

4. **λ-抽象**：如果 $t = \lambda x. v$，根据归纳假设，我们已经有一个从 $[[S]], [[U]]$ 到 $[[V]]$ 的 $(n+1)$ 元稳定函数 $[[v]]$。

   对于固定的 $a$，函数 $b \mapsto [[v]](a, b)$ 是从 $[[U]]$ 到 $[[V]]$ 的稳定函数，因此我们可以定义：

   $$
   [[t]](a) = \text{Tr}(b \mapsto [[v]](a, b))
   $$

   这里，$\text{Tr}$ 表示将稳定函数映射到其轨迹的操作。

   **验证** $[[t]]$ 的稳定性虽然繁琐，但相当直接。对于 $n = 1$ 的情况，我们需要证明：如果 $F$ 是从 $A \otimes B$ 到 $C$ 的稳定函数，它会诱导一个从 $A$ 到 $B \to C$ 的稳定函数 $G$，定义为：

   $$
   G(a) = \text{Tr}(b \mapsto F(\text{Pair}(a, b)))
   $$

   然后，$G$ 自身有一个轨迹，其公式为：

   $$
   \text{Tr}(G) = \{ (a, (b, \gamma)) : (\text{Pair}(a, b), \gamma) \in \text{Tr}(F) \}
   $$

   这说明了 $G$ 的轨迹如何从 $F$ 的轨迹构造而来。

5. **应用**：如果 $t = w \ u$，其中 $w$ 的类型为 $U \to V$，$u$ 的类型为 $U$，我们定义一个从 $[[U \to V]], [[U]]$ 到 $[[V]]$ 的稳定函数 **App**，定义为：

   $$
   \text{App}(f, a) = \{ \beta : \exists a^\circ \subset a, \ (a^\circ, \beta) \in f \}
   $$

   可以立即验证 $\text{App}$ 是稳定的。因此，我们定义：

   $$
   [[t]](s) = \text{App}([[w]](s), [[u]](s))
   $$

**练习**：读者可以尝试计算 **Pair**、$\Pi_1$、$\Pi_2$、**App** 以及步骤 4 中将 $F$ 映射到 $G$ 的函数的轨迹，以加深理解。

---

### **9.2 解释的性质**

正如我们所说，**转换（conversion）**在指称语义中变为**等同（denotational equality）**：如果 $t \to u$，则 $[[t]] = [[u]]$。

为了证明这一点，我们使用以下等式：

- $\Pi_1(\text{Pair}(a, b)) = a$
- $\Pi_2(\text{Pair}(a, b)) = b$
- $\text{App}(\text{Tr}(F), a) = F(a)$

最后一个公式需要结合一个**替换性质（substitution property）**来使用：

考虑 $v[x, u[x]/y]$，我们可以关联到它两个稳定函数：

- 通过直接计算该项的解释，即 $[[v]]$；
- 通过形成 $(n+1)$ 元函数 $[[v]](a, b)$，然后将 $[[u]](a)$ 代入，得到 $[[v]](a, [[u]](a))$。

可以证明，通过对 $v$ 进行归纳，上述两种方式得到的函数是相等的。

这个性质可以这样使用（省略辅助变量）：

$$
[[ (\lambda x. v) \ u ]] = \text{App}(\text{Tr}(a \mapsto [[v]](a)), [[u]]) = [[v]]([[u]]) = [[v[u/x]]]
$$

实际上，我们反复遇到但未认真对待的次级等式（secondary equations）也被满足：

- $\text{Pair}(\Pi_1(c), \Pi_2(c)) = c$
- $\text{Tr}(a \mapsto \text{App}(f, a)) = f$

**范畴论角度**：我们已经证明了 $\otimes$ 和 $\to$ 是一个**笛卡尔闭范畴（Cartesian Closed Category）**的乘积和指数对象，其对象是**一致空间**，态射是**稳定映射**。

然而，我们忽略了一件事：**复合（composition）**！但可以容易地证明，$G \circ F$ 的轨迹是：

$$
\{ (a_1 \cup \dots \cup a_k, \gamma) : (\{ \beta_1, \dots, \beta_k \}, \gamma) \in \text{Tr}(F), \ (a_1, \beta_1), \dots, (a_k, \beta_k) \in \text{Tr}(G) \}
$$

其中，$F$ 和 $G$ 分别是从 $A$ 到 $B$，从 $B$ 到 $C$ 的稳定函数。

---

### **9.3 G\"odel 的系统**

#### **9.3.1 布尔值**

我们将类型 $\text{Bool}$ 解释为一致空间 **Bool**：

- $[[T]] = T \overset{\text{def}}{=} \{ t \}$，表示真值；
- $[[F]] = F \overset{\text{def}}{=} \{ f \}$，表示假值。

对于 $D \ u \ v \ t$，我们使用一个从 $A, A, \text{Bool}$ 到 $A$ 的三元稳定函数 $D$ 来解释，定义为：

- $D(a, b, \emptyset) = \emptyset$（没有足够信息时返回空）；
- $D(a, b, \{ t \}) = a$（当条件为真时，返回 $a$）；
- $D(a, b, \{ f \}) = b$（当条件为假时，返回 $b$）。

因此，我们定义：

$$
[[D \ u \ v \ t]] = D([[u]], [[v]], [[t]])
$$

**重要性**：G\"odel 系统的项可以用**稳定函数**来解释，这使得定义**并行或（parallel or）**成为不可能的。

假设我们试图定义一个满足以下方程的项：

$$
t \ \langle T, x \rangle = T \\
t \ \langle x, T \rangle = T \\
t \ \langle F, F \rangle = F
$$

在 $T$ 中，如果这些方程有解，我们将得到：

- $[[t]](T, \emptyset) = T$
- $[[t]](\emptyset, T) = T$
- $[[t]](F, F) = F$

这对应于在第8.3.2节中被排除的非稳定函数 $F_0$。

#### **9.3.2 整数**

对于整数类型的解释，显而易见的想法是使用前一章中引入的一致空间 **Int**。

- $[[O]] = O \overset{\text{def}}{=} \{ 0 \}$；
- $[[S \ t]] = S([[t]])$，其中 $S(\emptyset) = \emptyset$，$S(\{ n \}) = \{ n + 1 \}$。

**问题**：这个解释**只在值的层面上**起作用；实际上，很容易找到 $u$ 和 $v$，使得：

- $R \ u \ v \ O \to T$；
- $R \ u \ v \ (S \ x) \to F$。

如果 $F$ 是解释 $x \mapsto R \ u \ v \ x$ 的函数，这迫使：

- $F(O) = \{ t \}$；
- $F(S(\emptyset)) = \{ f \}$。

但 $S(\emptyset) = \emptyset \subset O$，这与单调性矛盾。

**问题出在 $\text{Int}$ 上**：如果我们对空信息 $\emptyset$ 应用 $S$，我们再次得到 $\emptyset$，而实际上我们知道更多的信息，即我们有一个后继（某个数的后继），这可能足以进行递归步骤。

**解决方案**：我们必须修正我们的解释，添加 $0^+$ 来表示“是一个后继”的信息，即某个大于 0 的数，更一般地，添加 $p^+$ 来表示大于 $p$ 的某个数。

**定义扩展的 $\text{Int}^+$**：

- **元素**：$|\text{Int}^+| = \{ 0, 0^+, 1, 1^+, 2, 2^+, \dots \}$；
- **一致关系**：
  - $p \ \# \ q$ 当且仅当 $p = q$；
  - $p^+ \ \# \ q$ 当且仅当 $p < q$；
  - $p^+ \ \# \ q^+$ 对所有 $p, q$。

**解释**：

- 最大点（maximal points）可以是：
  - $\hat{p} = \{ 0^+, 1^+, \dots, (p - 1)^+, p \}$，表示数 $p$；
  - $f_\infty = \{ 0^+, 1^+, 2^+, \dots \}$，表示“无穷大”或“不确定的数”。

- **解释 $O$ 和 $S$**：
  - $O = \{ 0 \}$；
  - $S(a) = \{ 0^+ \} \cup \{ i + 1 : i \in a \} \cup \{ (i + 1)^+ : i^+ \in a \}$。

- **数 $p$（即 $S^p \ O$）被解释为 $\hat{p}$**。

**解释递归**：

- 给定一致空间 $A$，一个点 $o \in A$，以及一个从 $A, \text{Int}^+$ 到 $A$ 的稳定函数 $F$，我们构造一个从 $\text{Int}^+$ 到 $A$ 的稳定函数 $G$，满足：

  $$
  G(O) = o \\
  G(S(a)) = F(G(a), a) \\
  G(a) = \emptyset \quad \text{如果} \ 0, 0^+ \notin a
  $$

- $G$ 在 $\text{Int}^+$ 的有限点上是良好定义的，可以扩展为无限点上的稳定函数。

**练习**：尝试直接计算一个从 $\text{Int}^+$ 到 $\text{Int}^+$ 的稳定函数，它表示**前驱函数（predecessor）**。

#### **9.3.3 无限和不动点**

**$f_\infty$ 的作用**：

- 我们看到 $f_\infty$ 是 $S$ 的不动点：

  $$
  S(f_\infty) = f_\infty
  $$

- 我们可以尝试将它添加到 $T$ 的语法中，具有不收敛的重写规则：

  $$
  \infty \to S \infty
  $$

- 使用迭代器，我们有：

  $$
  \text{It} \ u \ v \ \infty \to v \ (\text{It} \ u \ v \ \infty)
  $$

- 因此，$\infty$ 与递归结合，为我们提供了访问**不动点 $Y$**。

**在指称语义中**：

- 当且仅当 $ha, \alpha \rangle$ 出现在 $f$ 的解释（的轨迹）中时，符号 $\alpha$ 出现在 $Yf$ 的解释中。
- 这是一种递归定义，通过重复地将 $f$ 应用于 $\emptyset$ 获得。
- $Y$ 本身的解释的符号可以用**有限树**来描述。

**讨论**：

- 我们在这里不打算深入讨论不动点（一般递归）的编程应用，这个概念目前对于类型系统来说相当陌生，尽管指称语义很好地容纳了它。
- 但从根本上说，这意味着什么呢？这是一个值得进一步探索的问题。

---

### **总结**

在本章中，我们使用第8章中的一致空间和稳定函数的构造，为**简单类型演算**和 **G\"odel 的 System T** 提供了指称语义学解释。

- **简单类型演算**：

  - 通过将 λ-抽象和应用分别解释为从稳定函数到轨迹，以及从轨迹到函数的操作，我们构建了类型系统的指称解释。
  - 证明了**转换**在指称语义中对应于**等同**，即如果 $t \to u$，则 $[[t]] = [[u]]$。
  - 讨论了类型和项的解释，以及它们的性质。

- **G\"odel 的系统**：

  - 解释了布尔类型和整数类型在一致空间中的表示，以及它们的指称语义。
  - 讨论了为什么在指称语义中无法定义**并行或（parallel or）**。
  - 为整数类型引入了扩展的 $\text{Int}^+$，以解决在递归中出现的问题。
  - 探讨了无限对象和不动点的含义，以及它们在指称语义中的表示。

---

### **后续展望**

- 在后续的章节中，我们将继续探索指称语义学的应用，以及如何在更复杂的类型系统（如 **System F**）中使用这些概念。
- 我们还将研究不动点和递归在类型系统和编程语言中的作用，以及它们与语义学的关系。

---

如果您对本章的内容有任何疑问，或者需要进一步的解释和详细讲解，请随时提出来！

### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------
[toc]



### **第7章 G\"odel的System T**

#### **引言**

我们之前研究的极其简单的类型系统，其表达能力非常有限。例如，我们能否使用它来表示整数或布尔值，如果可以，我们能否表示足够多的关于它们的函数？显然，答案是否定的。

为了获得更多的表达能力，我们不可避免地需要考虑其他方案：新的类型，或新的项，通常是两者兼有。因此，像G\"odel的System T这样的系统自然会出现，我们将在这里简要地讨论它。

然而，我们面临着双重困难：

- **逻辑视角的倒退**：像T这样的系统，从逻辑角度来看是一个倒退：新的方案并不对应于扩展逻辑系统中的证明。特别是，这使得研究它们变得困难。
- **表达能力的改进引发的进一步改进**：通过提高表达能力，这些系统暗示了进一步改进的可能性。例如，众所周知，编程语言PASCAL并没有内置列表类型！因此，我们被引导进行无休止的改进，以便能够考虑除了布尔值之外的整数、列表、树等。当然，所有这些都是以概念的简单性和模块化为代价的。

**System F** 以一种非常令人满意的方式解决了这些问题，正如我们将看到的，添加新的逻辑方案允许我们处理常见的数据类型。但首先，让我们专注于 **System T**，它已经具有相当大的表达能力。

---

### **7.1 演算**

#### **7.1.1 类型**

在第3章中，我们允许给定额外的常量类型；现在我们将指定其中的两个类型，即 **Int（整数）** 和 **Bool（布尔值）**。

- **Int**：整数类型，用于表示整数。
- **Bool**：布尔类型，用于表示布尔值（真和假）。

#### **7.1.2 项（Terms）**

除了通常的五种（变量、应用、抽象、对、投影），我们还为特定的常量 **Int** 和 **Bool** 引入了方案（schemes）。

我们保留了引入/消去（introduction/elimination）的术语，因为这些方案将在后面的 **System F** 中出现。

1. **Int-引入（Int-introduction）**：
   - **O** 是类型为 **Int** 的常量，表示零。
   - 如果 $t$ 是类型为 **Int** 的项，那么 **S t** 是类型为 **Int** 的项，表示 $t$ 的后继（即 $t+1$）。
   
2. **Int-消去（Int-elimination）**：
   - 如果 $u$、$v$、$t$ 的类型分别为 $U$、$U \to (\text{Int} \to U)$ 和 **Int**，那么 **R u v t** 的类型为 $U$。
   
   - **R** 是一个递归算子，用于定义递归函数。

3. **Bool-引入（Bool-introduction）**：
   - **T** 和 **F** 是类型为 **Bool** 的常量，分别表示真（True）和假（False）。

4. **Bool-消去（Bool-elimination）**：
   - 如果 $u$、$v$、$t$ 的类型分别为 $U$、$U$ 和 **Bool**，那么 **D u v t** 的类型为 $U$。
   
   - **D** 是一个条件运算符，相当于“if...then...else...”。

#### **意图（Intended Meaning）**

1. **O** 和 **S** 分别是零和后继函数。
   - **O** 表示整数0。
   - **S t** 表示 $t$ 的后继，即 $t+1$。

2. **R** 是一个递归算子（recursion operator）：
   - 定义：
     $$
     R \ u \ v \ O = u \\
     R \ u \ v \ (n + 1) = v \ (R \ u \ v \ n) \ n
     $$
   - 解释：$R$ 接受初始值 $u$，递归函数 $v$，和整数 $t$，返回类型为 $U$ 的结果。

3. **T** 和 **F** 是布尔值：
   - **T** 表示真（True）。
   - **F** 表示假（False）。

4. **D** 是“if...then...else...”运算，相当于按情况定义（definition by case）：
   - 定义：
     $$
     D \ u \ v \ T = u \\
     D \ u \ v \ F = v
     $$
   - 解释：如果 $t$ 是 **T**，则返回 $u$；如果 $t$ 是 **F**，则返回 $v$。

#### **转换规则（Conversions）**

除了经典的约简式（redex），我们添加以下转换规则：

- **整数递归（Int recursion）**：
  $$
  R \ u \ v \ O \to u \\
  R \ u \ v \ (S \ t) \to v \ (R \ u \ v \ t) \ t
  $$

- **布尔条件（Bool condition）**：
  $$
  D \ u \ v \ T \to u \\
  D \ u \ v \ F \to v
  $$

这些规则定义了新的约简式，允许我们进行归约。

---

### **7.2 规范化定理（Normalisation Theorem）**

在 **System T** 中，所有的归约序列都是有限的，并且导致相同的**正常形式（normal form）**。

#### **证明思路**

- **Church-Rosser 定理的扩展**：部分结果是 **Church-Rosser 定理** 的扩展；将简单系统的证明扩展到这个更复杂的情况并不困难。
  
- **强规范化结果**：另一部分是强规范化的结果，为此 **可归约性（reducibility）** 是非常适合的（Tait 发明这个概念就是为了 **System T**）。

#### **扩展中性项的概念**

首先，我们将**中性项（neutral term）**的概念扩展：

- 一个项被称为**中性的**，如果它不是以下形式的项：
  - $\langle u, v \rangle$：对（pair）
  - $\lambda x. v$：抽象
  - $O$：零
  - $S t$：后继
  - $T$：真
  - $F$：假

换句话说，中性项不属于上述形式。

#### **验证步骤**

我们在不改变任何东西的情况下，依次证明：

1. **$O$，$T$ 和 $F$ 是可归约的**：
   - 它们是原子类型的规范项（normal terms of atomic type）。
   - 根据可归约性的定义，它们是强规范化的，因此是可归约的。

2. **如果类型为 $\text{Int}$ 的项 $t$ 是可归约的，那么 $S t$ 是可归约的**：
   - 这来自于 $\nu(S t) = \nu(t)$，即 $S t$ 的规范化程度与 $t$ 相同。
   - 因此，$S t$ 是强规范化的，也是可归约的。

3. **如果 $u$，$v$，$t$ 是可归约的，那么 $D \ u \ v \ t$ 是可归约的**：
   - $u$，$v$，$t$ 是强规范化的（根据 (CR 1)）。
   - 我们可以对 $\nu(u) + \nu(v) + \nu(t)$ 进行归纳。
   - **$D \ u \ v \ t$** 是一个中性项，其归约可能是：
     - **情况1**：$D \ u' \ v' \ t'$，其中 $u \to u'$，$v \to v'$，$t \to t'$。
       - 在这种情况下，$\nu(u') + \nu(v') + \nu(t') < \nu(u) + \nu(v) + \nu(t)$，根据归纳假设，该项是可归约的。
     - **情况2**：$u$ 或 $v$，如果 $t$ 是 $T$ 或 $F$。
       - 这些项是可归约的。
   - 根据 (CR 3)，$D \ u \ v \ t$ 是可归约的。

4. **如果 $u$，$v$，$t$ 是可归约的，那么 $R \ u \ v \ t$ 是可归约的**：
   - 我们对 $\nu(u) + \nu(v) + \nu(t) + l(t)$ 进行归纳，其中 $l(t)$ 是 $t$ 的规范形式的符号数量。
   - **$R \ u \ v \ t$** 的一步归约可能是：
     - **情况1**：$R \ u' \ v' \ t'$，其中 $u \to u'$，$v \to v'$，$t \to t'$。
       - 根据归纳假设，该项是可归约的。
     - **情况2**：$u$，如果 $t = O$。
       - $u$ 是可归约的。
     - **情况3**：$v \ (R \ u \ v \ w) \ w$，其中 $S w = t$。
       - 由于 $\nu(w) = \nu(t)$，并且 $l(w) < l(t)$，根据归纳假设，$R \ u \ v \ w$ 是可归约的。
       - 因为 $v$ 和 $w$ 是可归约的，根据箭头类型的定义，$v \ (R \ u \ v \ w) \ w$ 是可归约的。

**注意**：

- 在最后一种情况下对归纳假设的使用是真正关键的：这是我们在使用可归约性的所有情况下，唯一一次真正对可归约性进行归纳。
- 对于其他情况，熟悉这个领域的人会看到，通过适当重新表述 (CR 3)，我们实际上不需要对复杂的谓词进行归纳。

---

### **7.3 表达能力：示例**

#### **7.3.1 布尔值**

一个典型的例子是逻辑连接词：

- **取反（neg）**：
  $$
  \text{neg}(u) = D \ F \ T \ u
  $$
  - 解释：如果 $u$ 是 $T$，则返回 $F$；如果 $u$ 是 $F$，则返回 $T$。

- **析取（disj，或）**：
  $$
  \text{disj}(u, v) = D \ T \ v \ u
  $$
  - 解释：如果 $u$ 是 $T$，则返回 $T$；否则返回 $v$。

- **合取（conj，且）**：
  $$
  \text{conj}(u, v) = D \ v \ F \ u
  $$
  - 解释：如果 $u$ 是 $T$，则返回 $v$；否则返回 $F$。

**示例**：

- $\text{disj}(T, x)$ 归约为 $T$。
- $\text{disj}(F, x)$ 归约为 $x$。
- 然而，对于表达式 $\text{disj}(x, T)$，我们不知道该怎么处理，因为 $x$ 可能是 $T$ 或 $F$，而我们的定义不对称。

**问题**：是否有可能定义另一个对称的析取？

- 我们将在 9.3.1 中通过语义方法看到，不存在一个项 $G$ 类型为 $\text{Bool}, \text{Bool} \to \text{Bool}$，使得：
  $$
  G \ \langle T, x \rangle = T \\
  G \ \langle x, T \rangle = T \\
  G \ \langle F, F \rangle = F
  $$
  - 这意味着我们无法定义一个完全对称的析取。

#### **7.3.2 整数**

首先，我们必须表示整数：选择 $n = S^n \ O$ 来表示整数 $n$ 是显而易见的。

**经典函数**可以通过简单的递归关系来定义。我们以加法为例：

- 定义加法的递归方程：
  $$
  x + O = x \\
  x + S y = S (x + y)
  $$

- 考虑项 $t[x, y] = R \ x \ (\lambda z_{\text{Int}}. \lambda z'_{\text{Int}}. \ S \ z) \ y$。

  - **解释**：
    - $R$ 是递归算子。
    - 初始值 $x$。
    - 递归函数 $\lambda z_{\text{Int}}. \lambda z'_{\text{Int}}. \ S \ z$。
    - $y$ 是递归的变量。

- 证明：
  - $t[x, O]$ 归约为 $x$。
  - $t[x, S y]$ 归约为：
    $$
    (\lambda z_{\text{Int}}. \lambda z'_{\text{Int}}. \ S \ z) \ (t[x, y]) \ y \\
    \to S \ t[x, y]
    $$
  - 这表明，我们可以将 $t[x, y]$ 作为 $x + y$ 的定义。

**其他示例**：

- 你可以尝试定义乘法、指数、前驱（predecessor）等。

**定义谓词**：

- 例如，定义零测试函数（null）：
  - $$
    \text{null}(O) = T \\
    \text{null}(S x) = F
    $$
  - 这可以写成：
    $$
    \text{null}(x) \overset{\text{def}}{=} R \ T \ (\lambda z_{\text{Bool}}. \lambda z'_{\text{Int}}. \ F) \ x
    $$
  - 这使我们能够将一个特征函数（类型为 $\text{Int}$）转换为一个谓词（类型为 $\text{Bool}$）。

**高阶类型的作用**：

- 这些示例都没有严重使用高阶类型。然而，随着递归中使用的类型增加，越来越多的函数变得可表达。
- 例如，如果 $f$ 类型为 $\text{Int} \to \text{Int}$，我们可以定义类型为 $\text{Int} \to \text{Int}$ 的 $it(f)$，使得：
  $$
  it(f) \ x = R \ 1 \ (\lambda z_{\text{Int}}. \lambda z'_{\text{Int}}. \ f \ z) \ x
  $$
  - 其中，$it(f) \ n$ 是 $f$ 迭代 $n$ 次应用于 $1$ 的结果，即 $f^n(1)$。

- 作为类型为 $(\text{Int} \to \text{Int}) \to (\text{Int} \to \text{Int})$ 的对象，函数 $it$ 可以表示为：
  $$
  \lambda x_{\text{Int} \to \text{Int}}. \ it(x)
  $$

- 很容易看出，通过对一些合理的函数 $f_0$ 进行有限次迭代，我们可以超过所有的**原始递归函数（primitive recursive functions）**。

  - 例如，给定函数 $f_0$，定义一个函数，给定 $n$，返回 $it^n(f_0)(1)$（这就是 Ackermann 函数），它增长得比所有原始递归函数都快。

- 这种函数在 **System T** 中很容易定义，只要我们对复杂类型（如 $\text{Int} \to \text{Int}$）进行递归。

  - 例如，考虑 $R \ f_0 \ (\lambda x_{\text{Int} \to \text{Int}}. \lambda z_{\text{Int}}. \ it(x)) \ y$，对于 $y = O$，它归约为 $f_0$，对于 $n$，它归约为 $it^n(f_0)$。

**讨论**：

- 最后，我们注意到 $R$ 中的第二个参数 $v$ 的第二个参数（即 $t$）经常未被使用。

- 我们更希望使用一个迭代器 **It** 而不是递归器 **R**，它应用于类型为 $T$ 的 $u$，类型为 $T \to T$ 的 $v$，以及类型为 **Int** 的 $t$，具有以下规则：
  $$
  It \ u \ v \ (S \ t) \to v \ (It \ u \ v \ t)
  $$

- **一阶前驱函数（predecessor）**满足方程：
  $$
  \text{pred}(O) = O \\
  \text{pred}(S x) = x
  $$
  - **pred** 无法使用迭代器 **It** 构造；**R** 是必要的。

- 实际上，如果只有迭代器，我们可以定义相同的函数，但某些带有变量的方程会消失。

  - 因此，前驱函数仍然是可定义的，但仅当 $t$ 具有特定形式（如 $n$）时，才满足 $\text{pred}(S t) = t$，也就是说，仅在值的层面上。

- 这有点令人不安（特别是在 **System F** 中，我们将只剩下迭代器），因为它表明要计算 $\text{pred}(n)$，程序需要执行 $n$ 步，这显然是过多的。

- 除了在像 **System T** 这样的系统中，我们不知道如何为前驱函数赋予类型，在这些系统中，解决方案显然是特设的（ad hoc）。

**练习**：

- 从迭代器 **It** 和配对（pairing）中定义递归器 **R**（仅限值的情况）。

- 我们将在 **System F** 中使用这个（参见 11.5.1）。

---

### **7.4 表达能力：结果**

#### **7.4.1 规范形式（Canonical Forms）**

首先，一个问题：我们有什么保证 **Int** 表示整数，**Bool** 表示布尔值，等等？

- 并不是因为我们在类型 **Int** 中表示了整数，就能立即声称该类型代表整数。

- 答案在于以下引理：

**引理**：设 $t$ 是一个闭合的规范项：

- 如果 $t$ 的类型是 **Int**，那么 $t$ 是形如 $n$ 的形式（即 $O$ 或 $S^n O$）。
- 如果 $t$ 的类型是 **Bool**，那么 $t$ 是 $T$ 或 $F$。
- 如果 $t$ 的类型是 $U \times V$，那么 $t$ 是形如 $\langle u, v \rangle$ 的形式。
- 如果 $t$ 的类型是 $U \to V$，那么 $t$ 是形如 $\lambda x. v$ 的形式。

**证明**：

- 对 $t$ 的符号数量进行归纳。

- 如果 $t$ 是 $S w$，根据归纳假设，$w$ 是形如 $n$ 的形式，因此 $t = n + 1$。

- 因此，我们假设 $t$ 不是 $O$，$T$，$F$，$\langle u, v \rangle$ 或 $\lambda x. v$ 的形式。

- 检查 $t$ 的可能形式：

  - **如果 $t$ 是 $R \ u \ v \ w$**：

    - 根据归纳假设，$w$ 是形如 $n$ 的形式。

    - 但是，$t$ 不是规范的，因为它可以进一步归约。

  - **如果 $t$ 是 $D \ u \ v \ w$**：

    - 根据归纳假设，$w$ 是 $T$ 或 $F$。

    - 但这意味着 $t$ 不是规范的，因为它可以进一步归约。

  - **如果 $t$ 是 $\pi_i w$**：

    - $w$ 是形如 $\langle u, v \rangle$ 的形式，因此 $t$ 不是规范的。

  - **如果 $t$ 是 $w \ u$**：

    - $w$ 是形如 $\lambda x. v$ 的形式，因此 $t$ 不是规范的。

- 因此，$t$ 必须是 $O$，$T$，$F$，$\langle u, v \rangle$ 或 $\lambda x. v$ 的形式。

#### **7.4.2 可表示的函数**

特别地，如果 $t$ 是 **System T** 中类型为 $\text{Int} \to \text{Int}$ 的闭合项，它定义了一个从自然数到自然数的函数 $|t|$，定义为：

- $$
  |t|(n) = m \quad \text{当且仅当} \quad t \ n \to^* m
  $$
  - 这里，$t \ n \to^* m$ 表示 $t \ n$ 归约到 $m$。

同样，类型为 $\text{Int} \to \text{Bool}$ 的闭合项定义了自然数上的谓词 $|t|$：

- $$
  |t|(n) \quad \text{成立当且仅当} \quad t \ n \to^* T
  $$

这些函数 $|t|$ 显然是可计算的：规范化算法给出了 $|t|(n)$ 作为 $n$ 的函数。因此，在 **System T** 中可表示的函数是递归的。

**问题**：我们能否描述这样的函数类？

- 一般来说，递归函数是使用部分算法定义的，其收敛性并不保证，但它们具有好的闭包性质，而完全函数则不具备。

- 作为一个部分算法，$|t|$ 相当于寻找规范形式，并在成功的情况下写下它。

- **规范化定理**因此是一个程序的证明，保证了从 **System T** 获得的所有算法的终止性。

**数学原理的需求**：

- 我们需要能够表达 $t$ 及其子项的可归约性：必须能够写出有限数量的可归约性陈述，这可以在 **皮亚诺算术（PA）** 中完成。

- 我们需要能够对这个有限数量的可归约性谓词进行数学归纳；这同样可以在 **PA** 中完成，尽管需要一些繁琐的编码（G\"odel 编码）。

**总结**：

- 终止性在算术中是可证明的：我们说 $|t|$ 在 **PA** 中是可证明的全函数。

- **反过来也是成立的**：设 $f$ 是一个在 **PA** 中可证明的全递归函数，那么我们可以在 **System T** 中找到一个类型为 $\text{Int} \to \text{Int}$ 的项 $t$，使得对于所有的 $n$，$f(n) = |t|(n)$。

- 换句话说，**System T** 的表达能力是巨大的，远远超过了计算机上可实现的范围！

- 进一步的推广并不是为了增加可表示函数的类，这个类已经太大了，而是为了扩大计算给定简单函数的特定算法的类。

  - 例如，找到一个类型系统，使得前驱函数表现良好。

**注释**：

- 我们不打算在这里给出这个反命题的证明，因为我们将在 15.2 中讨论 **System F** 的更复杂的情况。

---

### **总结**

在本章中，我们探讨了 **G\"odel 的 System T**，它通过引入新的类型（**Int** 和 **Bool**）和新的项，增强了表达能力。

- **类型**：引入了整数类型 **Int** 和布尔类型 **Bool**。

- **项**：除了基本的项之外，添加了特定的构造，用于整数和布尔值的引入和消去。

- **转换规则**：定义了新的转换规则，以处理新的构造。

- **规范化定理**：证明了在 **System T** 中，所有的归约序列都是有限的，并且导致相同的正常形式。

- **可归约性**：扩展了可归约性的概念，并验证了其在新的系统中的适用性。

- **表达能力**：展示了 **System T** 的强大表达能力，能够定义复杂的函数，如加法、乘法、Ackermann 函数等。

- **限制**：尽管 **System T** 的表达能力很强，但它在逻辑视角和类型系统的优雅性方面有所欠缺。

---

### **后续展望**

- 在后续的章节中，我们将探索 **System F**，它以更优雅的方式解决了 **System T** 中的问题，提供了更强大的类型系统。

- **System F** 允许在不引入特定数据类型的情况下，表达常见的数据结构，如列表、树等。

- 我们还将深入研究可归约性和规范化定理在更复杂的系统中的应用。

---

如果您对本章的内容有任何疑问，或者需要进一步的解释和详细讲解，请随时提出来！

### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------
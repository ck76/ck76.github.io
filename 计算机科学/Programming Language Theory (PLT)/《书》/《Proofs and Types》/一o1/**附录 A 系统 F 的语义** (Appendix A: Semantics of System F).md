[toc]



# **附录A 系统F的语义**

**作者：Paul Taylor**

---

本附录将为系统 **F** 给出一个基于**一致空间**（coherence spaces）的语义。特别地，我们将通过一种“迹”（trace）的方式解释全称抽象（universal abstraction），展示其一阶和二阶等式成立。我们将考察其项如何对所有类型都是“统一的”（uniform）。最后，我们将尝试计算一些全称类型，如 **Emp = ΠX. X**，**Sgl = ΠX. X → X**，**Bool = ΠX. X → X → X** 和 **Int = ΠX. X → (X → X) → X**。

---

## **A.1 全称类型的项**

### **A.1.1 有限近似**

我们在第11.2节中已经提到，全称类型 **ΠX. T** 的项 **ΛX. t** 被理解为一个函数，它将任何类型 **U** 映射为类型 **T[U/X]** 的项 **t[U/X]**。

特别地，全称恒等函数 **ΛX. λx. x** 的解释应当是将任何一致空间 **A** 映射为其恒等函数的迹，即：

$$
\text{Id}_A = \{(\{α\}, α) : α ∈ |A|\}
$$

**问题**：然而，我们面临着规模（size）的问题：一致空间的数量构成一个真类（proper class），因此如何将此作为一个合法的函数？

**解决方案**：我们可以像处理函数一样解决此问题，要求每个域都可以表达为有限域的“极限”（limit）。然后，通过连续性（continuity），我们可以从其在有限域上的值导出全称项在任意域上的值。由于同构意义下只有可数多个有限域，因此该函数可以由一个集合定义——只要我们确保其在同构域上的值是相等的（沿同构映射）。

### **A.1.2 饱和域**

**另一种常见但具有误导性的解决方案**是：

- 选择一个“大”域 **Ω**，它在所有相关的类型操作下都是饱和的（saturated）。
- 将我们的域 **A** 限制为 **Ω** 的“子域”。
- 例如，如果 **A** 是这样的子域，那么我们要求 **A → A** 也是这样的子域，特别地，**Ω → Ω** 也是。

这样，恒等函数作为 **Ω → Ω** 的一个元素，被视为 **Ω** 的一个子空间的元素，因此也是 **Ω** 的一个元素。

**举例**：Scott 的 **Pω** 模型 [Scott76] 是这种方法的一个著名例子，[Koymans] 详细研究了这种作为无类型 λ 演算模型的方法。

**然而**，除了并非所有域都被表示之外，这种方法还有几个陷阱：

1. **元素和类型的混淆**：在集合论中，元素和类型的概念被混淆了，而在这里，我们必须区分：

   - **Ω** 作为“元素的宇宙”。
   - **V** 作为一个域，其元素可作为类型的名称——即“类型的宇宙”。

2. **命名问题**：构造这样的 **V**，使得每个域都由 **V** 的一个点命名，这是不够的。这类似于递归函数的“值传递”解释。

   - 我们需要的是，每个变量域都由一个类型为 **V** 的项（具有相同的自由变量）命名。
   - 显然的选择是域和嵌入的范畴，但这不是我们的域之一。然而，可以通过一个域来“覆盖”它，尽管所需的技术比构造 **Ω** 要困难得多，详见 [Tay86] 的第5.6节。

3. **同构类型的区别**：同构的类型可能由 **V** 的不同元素表示，没有任何东西强制全称项在这些元素上的值相等。

   - 这意味着在 A.1.1 节末尾对有限近似的条件被违反了，全称类型有远多于对应语法中的项的点，像 **ΛX. λx. x** 这样简单的项的解释非常不经济。

4. **模型限制**：使用嵌入的范畴作为 **V**，可以为系统 **F**，更一般地为构造理论（Theory of Constructions）建模，如在 [CGW87] 和 [HylPit] 中所做的，但 Jung 已经表明，这对于当前使用的所有域范畴都是不可能的。

**总结**：上述第三点实际上失败的是项对所有类型的“统一性”（uniformity）。

### **A.1.3 统一性（Uniformity）**

**统一性**导致了我们模型的惊人经济形式。我们需要相对于“子空间”详细处理这一点，但首先考虑对类型的所有自同构（即置换）要求一个构造是统一的，这会带来什么后果。

- **直观解释**：在常见的几何概念中，这意味着构造必须是球的中心、锥的轴等等。
- **数学定义**：一个在自同构下（集合意义上）不变的群的子群称为**特征子群**（characteristic）。
- **影响**：自同构越多，“统一”的构造就越受限制。

一般来说，如果某物是统一的，那么它是“特有的”——由某种只有它满足的性质描述。

在我们的情况下，我们希望它可以由语法中的一个项定义（参见第11.2节）。在本附录的最后一节，我们将考察这在多大程度上成立。

**利用统一性**：通过制造自同构，我们可以从这个条件中获得力量。

- **一种粗略的构造**：将一个域与自身相加（lifted 或在某个子域上 amalgamated），显然具有“左右”对称性。
- **解释**：给定一个子空间包含 **A ⊂ B**，一个“统一”的 **B +_A B** 的元素不能在和的左或右部分——它必须在公共子空间 **A** 中。
- **比喻**：这就像那个驴子的难题，它因为无法在左右等距的两堆干草之间做出选择而饿死。

**类似性质**：在 Galois 理论中存在一个类似的性质（可分性）：给定一个子域包含 **K ⊂ L**，存在一个更大的域 **L ⊂ M**，使得固定 **K**（逐点）的 **M** 的自同构只固定 **K**。

- 对于域，**M** 是**正规闭包**（normal closure）——一个比我们的 **B +_A B** 更复杂的构造。

**统一性与自同构**：在任何函子理论中，包括 Scott 的理论中，统一性是一个特征。然而，对于这些理论，我们对于子域只有一个次统一性：全称项在 **A** 上的值只需要小于它在 **B** 上的值（其中 **A ⊂ B**）。

**稳定性条件的作用**：它利用了上述的可分性性质：

- **A** 是 **B** 在 **B +_A B** 中的两个副本的交集，因此根据稳定性，全称项在 **A** 上的值必须等于其在 **B** 上的值的投影的交集。
- **结论**：因此，一致空间模型是统一的。

**我们将在 A.4.1 中将这个模糊的论证精确化。**

---

## **A.2 刚性嵌入（Rigid Embeddings）**

为了使“有限近似”的概念有意义，我们必须形式化域的子域或近似的概念。

**Scott 域理论中的概念**：

- 使用嵌入-投影对（embedding-projection pair）：
  - **e: A ↪ B** 和 **p: B ↠ A**，满足 **1_A = p e**，且 **e p ≤ 1_B**。
  - 后一个复合是幂等的，称为 **B** 上的**余闭包**（coclosure）。

**解释**：

- 我们可以使用这些函数来定义当 **A** 的元素 **a** “小于” **B** 的元素 **b** 时（但反之不然），即如果 **a ≤ p b** 在 **A** 中，或等价地 **e a ≤ b** 在 **B** 中。

对于一致空间，我们将使用相同的想法，只是现在 **e** 必须是稳定的（stable）（**p** 已经是稳定的），且不等式 **e p ≤_B 1_B** 必须在 Berry 序中成立。

- **注意**：**e** 是线性的，将 **A** 识别为 **B** 的一个向下闭包的子集；它也保留并反映了原子和一致性关系。
- **表示**：因此，我们可以通过其在 web 上的限制来表示它，这是一个图的嵌入。这就证明了滥用记号 **e α** 的合理性，即存在唯一的 token **β**，使得 **e {α} = {β}**，因此我们可以将 **e** 视为 webs 之间的函数。

**e 和 p 的迹**：

- **Tr(e)**：{({α}, e α) : α ∈ |A|}
- **Tr(p)**：{({e α}, α) : α ∈ |A|}

我们经常将 **e: A → B** 写作 **e^+**，将 **p: B → A** 写作 **e^-**，对于图嵌入 **e: |A| ↪ |B|**。

**说明**：为了教学目的，将一个一一函数（如刚性嵌入）视为同构后跟包含会更容易理解：同构将数据的名称更改为其在目标中的值，包含则是所表示的值的集合的包含。在我们的情况下，我们可以对 **A** 中的点 **a** 或 token **α** 进行这种处理。

- **对于包含**：嵌入就是恒等映射，投影是限制：
  - **e(a) = a**
  - **p(b) = b ∩ |A|**

### **A.2.1 箭头的函子性**

使用成对的映射来表示近似的原因是我们需要使函数空间对其第一个参数是函子的（正的）：如果 **A'** 近似 **A**，那么我们需要 **A' → B** 近似 **A → B**，而不是反过来。

确实，如果 **e: A' ↪ A** 且 **f: B' ↪ B**，那么我们有 **e → f: (A' → B') ↪ (A → B)**，定义为：

- **(e → f)^+(t')(a) = f^+(t'(e^– a))**
- **(e → f)^–(t)(a') = f^–(t(e^+ a'))**

其中 **a ∈ A**，**a' ∈ A'**，**t: A → B**，**t': A' → B'**。

（我们留给读者验证这些不等式。）

**回顾**：**A → B** 的 tokens 形式为 **(a, β)**，其中 **a** 是 **|A|** 的 cliques（有限一致子集），**β** 是 **|B|** 的 token。

如果 **e: |A'| ↪ |A|** 和 **f: |B'| ↪ |B|** 是刚性嵌入，那么对 **A' → B'** 的 token **(a', β')** 的作用仅仅是相应的重命名，即 **(e^+ a', f β')**。

**特别地**，恒等函数 **Id_{A'}** 的 token **({α'}, α')** 被映射为 **({e α'}, e α')**，因此恒等函数是统一的，意味着：

$$
\text{Id}_{A'} = \text{Id}_A ∩ |A' → A'|
$$

其中 **A' ↪ A** 是一个子空间。

**结论**：一致空间和刚性嵌入（或等价的图和嵌入）构成一个范畴 **Gem**，并且我们已经展示了 **→** 是从 **Gem × Gem** 到 **Gem** 的协变函子。

---

## **A.3 类型的解释**

我们可以使用上述内容，将 **F** 中具有 **n** 个自由类型变量 **X₁, ..., Xₙ** 的任意类型 **T** 表示为一个函子 **[[T]]: \text{Gem}^n → \text{Gem}**，定义如下：

1. **常量类型**：如果 **T** 是一个常量类型，我们将其分配为一个一致空间 **T**，且：

   $$
   [[T]](A₁, ..., A_n) = T
   $$

   任何态射都映射为 **T** 上的恒等映射。

2. **类型变量**：如果 **T** 是变量 **X_i**，那么函子是第 **i** 个投影：

   $$
   [[X_i]](A₁, ..., A_n) = A_i
   $$

   类似地作用于态射。

3. **函数类型**：如果 **T** 是 **U → V**，且 **U** 和 **V** 已经由函子 **[[U]]** 和 **[[V]]** 解释，那么：

   $$
   [[U → V]](A₁, ..., A_n) = [[U]](A₁, ..., A_n) → [[V]](A₁, ..., A_n)
   $$

   它在态射上的值如上一节末所述。

**替换的保持**：这个定义尊重类型的替换：

$$
[[T[U_i / X_i]]] = [[T]]([[U₁]], ..., [[U_n]])
$$

由于函子性，我们立即知道如果 **A' ≅ A**，那么 **[[T]](A') ≅ [[T]](A)**。

**教学目的的假设**：我们方便地假设，如果 **A' ⊂ A** 是一个子空间，那么诱导的嵌入 **[[T]](A') ↪ [[T]](A)** 也是一个子空间包含。

### **A.3.1 全称类型的 tokens**

**解释的连续性**：如果 **β ∈ |[[T]](A)|**，那么存在一个有限的子空间 **A' ↪ A**，使得 **β ∈ |[[T]](A')|**。

- **范畴语言**：我们可以说函子保留滤过极限（filtered colimits）。

**含义**：正如在 A.1.1 节中，我们可以将注意力限制在有限一致空间上。对于任意一致空间 **A**，

$$
|[[T]](A)| = \bigcup_{\uparrow} \{|[[T]](A')| : A' ↪ A \text{ 是有限的}\}
$$

**更进一步，稳定性**：

- 如果 **A', A'' ⊂ A** 且 **β ∈ |[[T]](A')|**，**β ∈ |[[T]](A'')|**，那么 **β ∈ |[[T]](A' ∩ A'')|**，即函子保留**拉回**（pullbacks）。

**说明**：对于稳定函数，如果我们知道 **β ∈ f(a)**，那么存在最小的 **a' ⊂ a**，使得 **β ∈ f(a')**。

- **类似性质**：在这里也是如此，如果 **β ∈ |[[T]](A)|**，那么存在最小的子空间 **A' ↪ A**，使得 **β ∈ |[[T]](A')|**。

因此，**[[T]](A)** 的 token **β** 内在地携带了一个特定的有限子空间 **A' ⊂ A**，即它可以被定义的最小子空间。

- **例子**：在 web 的术语中，这仅仅是出现在 **β** 的表达式中的 tokens **α** 的集合。
- 例如，对于 **β = ({α}, α)**，唯一出现的 token 是 **α**，对应的有限空间是 **Sgl**，其 web 是一个单点集合 **{•}**。

**结论**：我们将看到，成对的 **(A, β)**，其中 **β ∈ |[[T]](A)|**，且不存在更小的 **A' ↪ A** 使得 **β ∈ |[[T]](A')|**，作为 **[[ΠX. T]]** 的（潜在）tokens。

- 如果 **A ≅ A'**，那么 **β'** 是 **β** 在诱导同构 **[[T]](A) ≅ [[T]](A')** 下的像，则 **(A', β')** 与 **(A, β)** 等价。

这些 tokens 涉及成对、有限（枚举的）集合和有限图，因此总共至多可数多个。因此，任何 **F** 的类型都可以由一个可数的一致空间表示。

**计算 **|[[T]](A)|**：从这些 tokens 出发，我们可以如下计算：

- 对于每个嵌入 **e: A' ↪ A** 和每个 token **β ∈ |[[T]](A')|**，我们有一个 token **[[T]](e)(β) ∈ |[[T]](A)|**。

然而，由于可能存在多个这样的嵌入（从而有多个 token 的副本，必须是一致的），这对 **|[[ΠX. T]]|** 的 tokens 施加了额外的（统一性）条件。

- **例如**：我们将看到 **(Sgl, •)** 不是 **[[ΠX. X]]** 的一个 token。

### **A.3.2 tokens 的线性记号**

我们可以使用第12章中引入的**线性逻辑**，为 tokens 选择一个好的记号，并表达它们的条件。

**回顾**：

- **A → B ≅ !A ⊸ B ≅ (!A ⊗ B^⊥)^⊥**

其中：

- **!A** 的 tokens 是 **|A|** 的 cliques（有限完全子图），两个 cliques 是一致的，当且仅当它们的并集是一个 clique；我们将 cliques 写为枚举的集合。

- **B^⊥** 是 **B** 的线性否定，其 web 是 **B** 的补图；方便起见，我们将其 tokens 写为 **β**。则 **β ⊥ β'** 当且仅当 **β ⊥ β'**。

- **C ⊗ D** 的 tokens 是 **(γ, δ)**，当且仅当 **γ ⊥ γ'** 且 **δ ⊥ δ'**。

**恒等函数** **ΛX. λx^X. x** 的 token 可以写为：

$$
(Sgl, (\{•\}, •))
$$

在这个记号中，我们可以很容易地说明“**α** 在 **β** 中正（或负）出现”的含义。非正式地，根据它是偶数次还是奇数次出现上划线，可以判断某个特定的出现是正的还是负的。

**有用的判定标准**：确定一个潜在的 token 是否实际可以出现。

**引理**：

- 设 **α ∈ |A|**，**β ∈ |[[T]](A)|**。
- 定义一致空间 **A^+**，通过在 **|A|** 中添加一个额外的 token **α'**，它与除 **α** 之外的其他 tokens 具有与 **α** 相同的一致性关系，且与 **α** 一致。
- 存在两个刚性嵌入 **A ↪ A^+**（其中 **α** 分别映射为 **α** 和 **α'**），因此写出 **β, β' ∈ |[[T]](A^+)|**，它们是 **β** 在这些嵌入下的像。
- 类似地，我们有 **A ↪ A^-**，其中 **α'** 与 **α** 不一致。

那么：

- **如果 **α** 未在 **β** 中出现**，则 **β = β'** 在 **[[T]](A^+)** 和 **[[T]](A^-)** 中。

- **如果 **α** 在 **β** 中正出现但不负出现**，则 **β ⊥ β'** 在 **[[T]](A^+)** 中，**β ⊥ β'** 在 **[[T]](A^-)** 中。

- **如果 **α** 在 **β** 中负出现但不正出现**，则相反。

**证明**：对类型 **T** 进行归纳。

**结论**：全称项 **ΛX. t** 的统一性迫使 **β** 在 **e1** 和 **e2** 下的像 **e1 β** 和 **e2 β** 都出现在 **|[[t]](A)|** 中（并且因此是一致的），或者都不出现，其中 **e1, e2: A' ↪ A** 是两个嵌入。

实际上，**(A', β)** 是一个 token，当且仅当上述情况成立。

**因此，我们有一个简单的推论**：

**推论**：如果 **(A, β)** 是 **[[ΠX. T]]** 的一个 token，且 **α ∈ |A|**，那么 **α** 在 **β** 中既正出现又负出现。

**说明**：这个推论不是 **(A, β)** 成为 **[[ΠX. T]]** 的 token 的充分条件，但它是确定一些简单的全称类型的非常有用的标准。

### **A.3.3 三个最简单的类型**

**情况1**：**T = X → X**

- **Token**：任何 **X → X** 的 token 形式为 **(A, (a, α))**，其中 **α** 只正出现，因此 **a = {α}**。
- **结论**：因此，这个类型只有一个 token，即所给的那个，且 **[[ΠX. X → X]] ≅ Sgl**。
- **含义**：这意味着类型 **X → X** 的唯一统一函数是恒等函数和未定义函数。

**情况2**：**T = X**

- **Token**：没有 token 可以负出现，因此根本没有 token。
- **结论**：**[[ΠX. X]] ≅ Emp**，其 web 为空，仅有完全未定义的项 **∅**。
- **原因**：如果一个项在所有类型上都是统一定义的，那么它必须与任何项一致；由于存在不一致的项，它必须是平凡的。

**说明**：显然，任何基于域理论的 **F** 模型都不能排除未定义函数，因为 **∅** 是语义上可定义的。对于更高类型，这会导致与第8.2.2节相同的逻辑复杂性。

**情况3**：**Bool = ΠX. X → X → X**

- **Token**：对于 **Bool**，token 形式为 **(Sgl, (a, (b, •)))**，使得 **a ∪ b = {•}**。
- **结果**：这并不是两个，而是三个（不一致的）解：

  1. **(Sgl, ({•}, (∅, •)))**
  2. **(Sgl, ({•}, ({•}, •)))**
  3. **(Sgl, (∅, ({•}, •)))**

- **解释**：
  
  - 第一个和第三个分别代表布尔值 **t** 和 **f**。
  - 中间的那个代表**交集**。尽管它在系统 **F** 中不可定义，但可以被视为读取两个 token 流并输出它们共有的那些的程序。
  
- **线性函数**：
  
  - **t** 和 **f** 是线性函数 **X ⅋ X ⊸ X**，因为它们只使用其参数之一。
  - **交集**是一个统一的线性函数 **X ⊗ X ⊸ X**。

**消除交集**：我们可以通过考虑“线性布尔值”来消除交集：

$$
\text{Bool}_{\text{linear}} = ΠX. X ⅋ X ⊸ X
$$

**语义上**，这个双线性函数只是二元交集，它在我们的域中是统一可定义的，因为它们是有界完备的（具有被上界的点集的并）。

**延伸讨论**：

- 如果我们将我们的域类扩展到包含 Jung 的“L-域”，其中对于每个点 **a ∈ A**，集合 **↓ a = {a' : a' ≤ a}** 是一个完备格，那么“交集”函数就变得更复杂。
- 我们可以定义 **m(a, b)** 为 **↓ a** 中集合 **{c : c ≤ a, c ≤ b}** 的并。
- 只要我们只考虑在 **↓ a** 中的格中，二元交满足分配律的域，**m: A ⊗ A ⊸ A** 是双线性的，并且在我们定义的意义下是统一的。
- 通过迭代它，我们将获得无限多的 **ΠX. X → X → X** 的附加点——但情况更糟，因为最初的规模问题再次出现，我们甚至无法在语义中形成多态类型。

---

**结论**：通过一致空间的语义，我们可以深入理解系统 **F** 中全称类型的行为，以及项的统一性如何影响可定义的函数。

如果您对某个部分有疑问，或者希望进一步解释某些概念，请告诉我！

### ---------------------------

# **附录A 系统F的语义**

**作者：Paul Taylor**

---

本附录将为系统 **F** 提供一个基于**一致空间**（coherence spaces）的语义解释。特别地，我们将通过解释全称抽象（universal abstraction）的方式，展示一阶和二阶等式的成立。我们将探讨项如何对所有类型保持**统一性**（uniformity）。最后，我们将尝试计算一些全称类型的例子，例如 **Emp = ΠX. X**，**Sgl = ΠX. X → X**，**Bool = ΠX. X → X → X** 和 **Int = ΠX. X → (X → X) → X**。

---

## **A.4 项的解释**

### **A.4.1 可变一致空间**

#### **背景和目标**

在前面的部分中，我们已经讨论了如何使用一致空间解释系统 **F** 的类型。现在，我们将继续解释系统 **F** 的**项**。

- **目标**：给出系统 **F** 的项在一致空间语义下的形式化解释。

#### **术语和符号**

- **类型解释**：一个具有 **n** 个自由类型变量 **X₁, ..., Xₙ** 的类型 **T** 被解释为一个稳定函子 **[[T]]: \text{Gem}ⁿ → \text{Gem}**，其中 **Gem** 是一致空间和刚性嵌入的范畴。

- **项**：设 **t** 是一个类型为 **T** 的项，具有自由变量 **x₁, ..., xₘ**，其类型分别为 **U₁, ..., Uₘ**，这些 **U** 的自由类型变量包含在 **X** 中。

- **解释**：**t** 将每个 **n** 元组 **A**（来自 **Gem**ⁿ）和每个 **bⱼ ∈ [[Uⱼ]](A)** 映射到一个点 **c ∈ [[T]](A)**。

- **稳定性**：函数 **b ↦ c** 必须是稳定的。

#### **简化**

为了简化讨论，我们可以将 **t** 替换为 **λx. t**，将 **T** 替换为 **U₁ → ... → Uₘ → T**，使得 **m = 0**，即没有自由变量。

- **考虑的问题**：当我们改变 **Aᵢ** 时，会发生什么？

#### **可变一致空间**

- **设定**：令 **T: \text{Gem} → \text{Gem}** 是任意的稳定函子，**τ(A) ∈ T(A)** 是在 **A** 上的一些选择的点。

- **刚性嵌入**：令 **e: A₀ ↪ A** 是一个刚性嵌入。

- **目标**：希望 **τ** 对于 **e** 是“单调的”，即 **τ(A₀) ≤ T(e)^–(τ(A))**。

#### **具体化**

- **当嵌入是子空间包含时**，上式变为：

  $$
  τ(A₀) ⊂ τ(A) ∩ |T(A₀)|
  $$

- **解释**：这意味着 **τ(A₀)** 是 **τ(A)** 与 **|T(A₀)|** 的交集。

#### **稳定性强制等式**

- **使用可分性性质**（separability property），我们可以证明稳定性在这里强制等式成立。

- **引理（Eugenio Moggi）**：

  - **设**：**e: A₀ ↪ A** 是一个刚性嵌入。

  - **构造**：令 **A ⊕_{A₀} A** 是一致空间，其 web 由两个 **|A|** 的不一致副本组成，且子图 **|A₀|** 被识别（identified）。

  - **性质**：**A** 有两个典范的刚性嵌入到 **A ⊕_{A₀} A** 中，它们的交集是 **A₀**。

#### **稳定函数的意义**

- **问题**：**τ** 是从 **\text{Gem}** 到某个未指定余域的稳定函数，这是什么意思？

- **尽管没有给出余域，我们仍然可以使用 **a ≤ e^– b**（对于 **e: A ↪ B**）的定义来计算交集。

- **表示**：将 **A₁** 和 **A₂** 表示为 **A ⊕_{A₀} A** 中的两个 **A** 的副本，它们的交集是 **A₀**。

#### **使用不等式的“投影”形式**

- **条件**：**hA'', βi** 在交集中，当且仅当：

  1. **A'' ⊂ A₁ ∩ A₂**

  2. **β ∈ τ(A₁) ∩ |T(A'')| = τ(A) ∩ |T(A'')|**

  3. **β ∈ τ(A₂) ∩ |T(A'')| = τ(A) ∩ |T(A'')|**

- **结论**：因此，**A₁** 和 **A₂** 上的值的交集正是 **τ(A) ∩ |T(A₀)|**。

- **由于稳定性**，这必须是 **A₀** 上的值 **τ(A₀)**。

#### **命题**

- **结论**：设 **τ** 是可变一致空间 **T(X₁, ..., Xₙ)** 的一个对象，且 **eᵢ: A₀ᵢ ↪ Aᵢ** 是刚性嵌入。

- **则有**：

  $$
  τ(A₀) = τ(A) ∩ |T(A₀)|
  $$

- **并且**，如果 **τ** 满足此条件，那么它是稳定的。

### **A.4.2 Token 的一致性**

#### **进一步的观察**

- **引理的更多含义**：

  - **设**：**B = A ⊕_{A₀} A**，它有一个自同构 **e**，交换 **A** 的两个副本。

  - **结论**：这必须固定 **τ(B)**，因此如果 **β ∈ \text{Tr}(τ(B))**，那么 **e β** 也在此迹中，并且必须与 **β** 一致。

- **引理**：

  - **设**：**β ∈ |T(A)|**，且 **e₁, e₂: A ↪ B** 是两个嵌入。

  - **则有**：**e₁ β ⊥ e₂ β** 在 **B** 中。

#### **逆命题**

- **引理**：

  - **设**：**β ∈ |T(A)|**，满足：

    1. **A** 对于 **β** 是最小的（minimal），即如果 **A' ⊂ A** 且 **β ∈ |T(A')|**，则 **A' = A**。

    2. **β** 在 **A** 到另一个域的任何一对嵌入下的像都是一致的。

  - **则存在**类型 **T** 的对象 **τ_{(A, β)}**，其在 **T(B)** 上的值为：

    $$
    \{T(e)(β) : e: A ↪ B\}
    $$

  - **并且**：这是原子的，即没有非平凡的子对象。

#### **检验条件**

- **计算量**：为了测试此条件，我们只需要考虑大小最多为 **|A|** 的两倍的图，因此这是一个有限的计算。

- **可递归枚举**：对于任何给定的类型，这些 tokens 是可递归枚举的。

- **等价性**：由于 **τ_{(A, β)}** 是原子的，我们必须只有一个 **ΠX. T(X)** 的 token，因此对于任何 **e: A ≅ A'** 且 **e β = β'**，**(A, β)** 和 **(A', β')** 被识别为相同。

#### **Token 的一致性**

- **问题**：我们仍然需要说明这些 tokens 何时一致。

- **引理**：

  - **设**：**β₁ ∈ |T(A₁)|** 和 **β₂ ∈ |T(A₂)|**，它们都满足上述条件。

  - **则**：对于每个一致空间 **B**，**τ_{(A₁, β₁)}(B) ⊥ τ_{(A₂, β₂)}(B)**，当且仅当对于每对嵌入 **e: A₁ ↪ C** 和 **e': A₂ ↪ C**，有 **T(e)(β₁) ⊥ T(e')(β₂)**。

### **A.4.3 系统 F 的解释**

#### **总结**

- **我们可以计算任何可变一致空间的全称抽象**。

- **命题**：

  - **设**：**T: \text{Gem} → \text{Gem}** 是一个稳定函子。

  - **则**：其全称抽象 **ΠX. T(X)** 是一个一致空间，其 tokens 是等价类 **(A, β)**，满足：

    1. **β ∈ |T(A)|**

    2. **A** 对于 **β** 是最小的（即如果 **A' ⊂ A** 且 **β ∈ |T(A')|**，则 **A' = A**，因此 **A** 是有限的）

    3. 对于任何两个刚性嵌入 **e₁, e₂: A ↪ B**，有 **T(e₁)(β) ⊥ T(e₂)(β)** 在 **T(B)** 中

    4. **(A, β)** 与 **(A', β')** 等价，当且仅当存在同构 **e: A ≅ A'**，且 **T(e)(β) = β'**（因此 **|A|** 可以视为 **N** 的子集）

    5. **(A, β)** 与 **(A', β')** 一致，当且仅当对于每对嵌入 **e: A ↪ B** 和 **e': A' ↪ B**，有 **T(e)(β) ⊥ T(e')(β')**

- **证明要点**：

  - **ΠX. T(X)** 是一个一致空间，因为如果任何 **(A, β)** 出现在一个点中，那么 **τ_{(A, β)}** 的整个都出现了。

  - 任何这些的相容并集都会产生一个统一的元素。

#### **补充说明**

- **需要证明**：如果 **T: \text{Gem} × \text{Gem} → \text{Gem}** 是稳定的，那么 **ΠX. T: \text{Gem} → \text{Gem}** 也是稳定的。

- **还需要检查**：正负性判据仍然有效。

#### **系统 F 的一致空间语义**

- **类型解释**：具有 **n** 个自由类型变量 **X** 的类型 **U** 被解释为一个稳定函子 **[[U]]: \text{Gem}ⁿ → \text{Gem}**，遵循 **A.3** 节的定义，并增加以下规则：

  4. **如果 **U = ΠX. T**，那么 **[[U]](A)** 的 web 按照前述命题给出，其中 **T(X) = [[T]](A, X)**。

     - **嵌入**：由 **e: A₀ ↪ A** 诱导的嵌入将 **[[U]](A₀)** 的 tokens 映射为相应的 tokens，其中 **α₀ᵢ** 被替换为 **eᵢ α₀ᵢ**。

- **项的解释**：类型为 **T**，具有 **m** 个自由变量 **x**，类型为 **U**（**T** 和 **U** 的自由类型变量为 **X**）的项 **t**，被解释为对于每个 **A**，赋予一个稳定函数：

  $$
  [[t]](A): [[U₁]](A) ⅋ ... ⅋ [[Uₘ]](A) → [[T]](A)
  $$

  - **满足统一性方程**：对于 **e: A₀ ↪ A** 和 **bⱼ ∈ [[Uⱼ]](A)**，有：

    $$
    [[T]](e)^– ([[t]](A)(b)) = [[t]](A₀)([[U]](e)^–(b))
    $$

#### **详细解释**

1. **变量**：

   - **解释**：变量 **xⱼ** 由第 **j** 个乘积投影解释。

     $$
     [[xⱼ]](A)(b) = bⱼ
     $$

2. **λ 抽象**：

   - **解释**：λ 抽象 **λx. u** 的解释，基于 **u** 的解释，通过**迹**给出：

     $$
     [[λx. u]](A)(b) = \{(c, δ) : δ ∈ [[u]](A)(b, c), \text{且 } c \text{ 是最小的}\}
     $$

3. **应用**：

   - **解释**：应用 **u v** 使用第8.5.2节中的公式（App）解释：

     $$
     [[u v]](A)(b) = \{δ : \exists c ⊂ [[v]](A)(b). (c, δ) ∈ [[u]](A)(b)\}
     $$

4. **全称抽象**：

   - **解释**：全称抽象 **ΛX. v** 也通过“迹”给出：

     $$
     [[ΛX. v]](A)(b) = \{[ (C, δ) ] : δ ∈ [[v]](A, C)(b), \text{且 } C \text{ 是最小的}\}
     $$

     - **等价类**：**[ (C, δ) ]** 表示等价类，**(C, δ)** 与 **(C', δ')** 等价，当且仅当 **e: C ≅ C'** 且 **[[v]](A, e)(b)(δ) = δ'**。

5. **全称应用**：

   - **解释**：全称应用 **t U** 通过应用公式给出：

     $$
     [[t U]](A)(b) = \{δ : \exists e: C ↪ [[U]](A). [ (C, δ) ] ∈ [[t]](A)(b)\}
     $$

#### **转换规则的满足**

- **原因**：转换规则成立，因为它们相当于 **ΠX. T(X)** 的对象与 **T** 的可变对象之间的双射。

- **需要证明**：一个类似于第9.2节的替换引理。

---

## **A.5 例子**

### **A.5.1 自然地（Of course）**

#### **目标**

- **计算**：我们旨在计算在第11.3节中使用系统 **F** 解释的简单类型的**一致空间表示**，如乘积、和和存在类型。

- **注意**：这些类型本质上都是从 **ΠX.(U → X) → X** 派生的，因此我们将详细考虑这个类型，并随后简单陈述其他结果。

#### **Token 的形式**

- **正负性判据**仍然对像 **U** 这样的常量有效，因此这个类型的 token 形式为：

  $$
  (Sgl, \{ (u_i, •) : i = 1, ..., k \}, • )
  $$

  - **解释**：其中 **u_i** 遍历 **U** 的有限 cliques，即 **!U** 的 tokens。

- **尽管只有一个 token（即 **•**）可用于标记 **u_i**，但它可能重复出现**。

- **因此**：token 由 **!U** 的 tokens 组成的有限集合（两两不一致）给出。

#### **符号化**

- **换句话说**，在指称语义（denotationally）上，我们有：

  $$
  ΠX.(U → X) → X ≅ (!((!U)^\perp))^\perp = ?!U
  $$

  - **其中**：我们将 **?!U** 称为 **¬¬U**（稍有滥用）。

#### **程序的效果**

- **考虑程序**：

  $$
  (Sgl, \{ (u_1, •), (u_2, •) \}, • )
  $$

- **在类型 **A** 上，给定稳定函数 **f: U → A**，其效果是：

  - **检查迹** **Tr(f)**，输出那些满足 **(u_1, α)** 和 **(u_2, α)** 都在其中的 tokens **α**。

- **这推广了我们在 **[[Bool]]** 中发现的交集。

#### **未定义项的引入**

- **不可避免的特征**：在系统 **F** 的域模型中，将 **∅** 添加到 **U** 是不可避免的，因为类型为 **¬¬U** 的程序没有终止的义务。

- **奇特之处**：我们可能有 **u₁ ≤ u₂**，即 **U** 的两个有限点（或 cliques），它们产生了 **¬¬U** 的原子 token。

  - **解释**：在某些函数上，一个会输出 **α** 而另一个不会，反之亦然。

- **原因**：这是稳定解释和 Berry 序的结果，后者比逐点序要弱得多。

  - **测试**：对函数的测试不仅是数据 **u** 是否足以输出 **α**，还涉及其必要性。

#### **乘积、和和存在类型的计算**

- **乘积类型**：

  $$
  ΠX.(U → V → X) → X ≅ ¬¬(U ⊥ V) ≅ ?(!U ⊗ !V)
  $$

  - **其中**：我们将 **⊗** 视为“线性合取”。

- **和类型**：

  $$
  ΠX.(U → X) → (V → X) → X ≅ ¬¬(U + V) ≅ ?(!U ⊕ !V)
  $$

  - **注意**：除了 **?** 之外，这就是我们在第12章中确定的和类型。

- **存在类型**：

  $$
  ΠY.(ΠX.(V(X) → Y)) → Y ≅ ¬¬(\Sigma^\circ_X V)
  $$

  - **其中**：对于一个变量类型 **T: \text{Gem} → \text{Gem}**，**\Sigma^\circ_X T(X)** 是我们在 **A.3.1** 节中遇到的**总范畴**。

### **A.5.2 自然数**

#### **目标**

- **计算**：应用我们的技术来计算自然数类型的表示：

  $$
  \text{Int} = ΠX. X → (X → X) → X
  $$

- **回顾**：除了 **F** 的项，我们还遇到了未定义项 **⊥** 和二元交 **∧**。

- **观察**：当我们尝试对这个类型的 tokens 进行分类时，线性逻辑再次出现。

#### **线性类型构造**

- **考虑**：

  $$
  (!A ⊗ !((!A ⊗ A^\perp)^\perp) ⊗ A^\perp)^\perp
  $$

- **tokens 形式**：

  $$
  (a, \{ (b_i, γ_i) : i = 1, ..., k \}, δ )
  $$

#### **应用正负性判据**

- **条件**：

  $$
  |A| = \{ δ \} ∪ \bigcup_{i=1}^k b_i = a ∪ \{ γ_1, ..., γ_k \}
  $$

- **最简单的情况**：当 **k = 0** 时，**a = \{ δ \}**。

  - **解释**：这给出了数字 **0**，解释为将起始值复制到输出，忽略过渡函数的程序。

  - **对应的 **Int** 的 token**：

    $$
    (Sgl, \{ • \}, \{ \}, • )
    $$

#### **交集现象**

- **体现**：在最简单的情况下，表现为 token：

  $$
  (Sgl, \{ α \}, \{ ( \{ α \}, α ) \}, α )
  $$

- **类似的潜在 token**：

  $$
  (α ⊥ β, \{ α \}, \{ ( \{ β \}, β ) \}, α )
  $$

  - **尽管通过了正负性判据，但实际上并不是该类型的有效 token。

#### **更深入的分析**

- **转向语法**：找到数字 **1** 的 tokens。

- **计算**：

  $$
  [[ΛX. λx. λy. y x]]
  $$

- **得到 tokens**：

  $$
  (A, a, \{ (a, γ) \}, γ )
  $$

  - **其中**：**|A|** 由 clique **a** 和 token **γ** 组成。

#### **不同情况的解释**

- **如果 **a = ∅**：
  - **程序**：忽略起始值流和过渡函数流上的所有内容，除了其值的“常数”部分，复制到输出。
  
- **如果 **a** 有 **m** 个元素**：

  - **程序**：读取过渡函数中恰好读取其输入 **m** 次的部分，并将其应用于起始值（读取 **m** 次）。

- **如果 **γ ∈ a**：

  - **程序**：仅输出过渡函数结果中包含在输入中的部分。

- **如果 **γ ∉ a**：

  - **程序**：仅输出不包含在输入中的部分。

- **如果 **γ ⊥ α**，其中 **α** 遍历 **a** 的 **m** 个 tokens 中的 **r** 个：

  - **程序**：仅在输入和输出以这种方式一致的情况下输出 **γ**。

#### **结论**

- **复杂性**：即使是数字 **1** 也是一个非常复杂的对象。

  - **本质**：相当于将过渡函数分解为一个“多项式”，其第 **m** 项恰好读取其输入 **m** 次。

  - **进一步**：根据输入和输出之间的关系分解这些项。

- **更大的数字**：这些复杂性随着我们考虑更大的数字而增加。

- **问题**：它们是否提供了 **Int** 的 tokens 的完整分类？**Int → Int** 看起来如何？

### **A.5.3 线性数字**

#### **引入**

- **尝试**：通过考虑类似于线性布尔值的自然数的线性版本，为这种混乱带来一些秩序。

- **定义**：

  $$
  \text{LInt} = ΠX. X ⊸ ((X ⊸ X) → X)
  $$

  - **注意**：我们保留了一个经典的蕴涵。

#### **应用正负性判据**

- **效果**：将 **a** 替换为 **{α}**，将 **b_i** 替换为 **{β_i}**。

- **条件**：

  $$
  |A| = \{ α, γ_1, ..., γ_k \} = \{ β_1, ..., β_k, δ \}
  $$

  - **这些元素**不一定是不同的。

- **结构**：除了由一致性给出的无向图结构，配对 **(β_i, γ_i)** 在 **A** 上引入了一个“过渡关系”。

#### **线性数字 **k**

- **由以下形式的 tokens 组成**：

  $$
  α = γ_1, β_1 = γ_2, ..., β_{k-1} = γ_k, β_k = δ
  $$

  - **仅受限于**：当且仅当 **α_i ⊥ α_j ⇔ α_{i+1} ⊥ α_{j+1}**

- **结果**：因此，它们仍然有相当多的 tokens！

#### **一般情况**

- **过渡关系**：

  - **保持一致性**，反映不一致性。

  - **包含**：从 **α** 到 **δ** 通过任何给定 token 的路径。

- **验证**：读者被邀请验证此刻画，并确定何时两个这样的 tokens 是一致的。

---

## **A.6 完全域**

#### **问题**

- **域理论的解释**：如前所述，必然引入了部分元素，如 **∅**，在一致空间的情况下还包括“交集”操作。

#### **解决方案**

- **方法**：我们可以使用类似于在可约性（reducibility）和实现性（realisability）中使用的方法，尝试消除这些部分元素。

#### **定义**

- **候选集**：对于一致空间 **A**，我们允许任何子集 **R ⊂ A** 作为**完全集合候选**（totality candidate）。

- **规则**：

  1. **如果 **R** 是 **A** 的完全集合候选，**S** 是 **B** 的完全集合候选，则我们写 **R → S** 表示类型为 **A → B** 的对象 **f** 的集合，使得 **a ∈ R ⇒ f(a) ∈ S**。

  2. **如果 **T[X, Y]** 是一个具有自由变量 **X** 和 **Y** 的类型，**S** 是一致空间 **B** 的完全集合候选，则 **f ∈ ΠX. T[S]**，即 **f** 对于一致空间 **[[ΠX. T]](B)** 是完全的，如果对于每个空间 **A** 和 **[[T]](A, B)** 的候选 **R**，我们有 **f(A) ∈ T[R, S]**。

#### **性质**

- **与可约性和实现性一样**，对于闭合类型，不再有参数多态性（parametricity）。

#### **参考**

- **更广泛的讨论**：这一主题在 [Gir85] 中更广泛地讨论。

- **引述的结果**：

  - **命题**：如果 **t** 是闭合类型 **T** 的闭合项，那么 **[[t]]** 是完全的。

  - **命题**：在 **Bool** 和 **Int** 的表示中，完全的对象正是真值和数字。

---

**总结**：通过一致空间的语义解释，我们深入了解了系统 **F** 中项和类型的行为，特别是全称类型和统一性的概念。我们探讨了如何在一致空间中解释系统 **F** 的项，以及这些解释如何满足统一性和稳定性的条件。

如果您对某个部分有疑问，或者希望进一步解释某些概念，请告诉我！

### ----------------------------

# **附录A 系统F的语义**

**作者：Paul Taylor**

---

本附录将为系统 **F** 提供一个基于**一致空间**（coherence spaces）的语义解释。特别地，我们将通过解释全称抽象（universal abstraction）的方式，展示一阶和二阶等式的成立。我们将探讨项如何对所有类型保持**统一性**（uniformity）。最后，我们将尝试计算一些全称类型的例子，例如 $\text{Emp} = \Pi X. X$，$\text{Sgl} = \Pi X. X \to X$，$\text{Bool} = \Pi X. X \to X \to X$ 和 $\text{Int} = \Pi X. X \to (X \to X) \to X$。

---

## **A.4 项的解释**

### **A.4.1 可变一致空间**

#### **背景和目标**

在前面的部分中，我们已经讨论了如何使用一致空间解释系统 **F** 的类型。现在，我们将继续解释系统 **F** 的**项**。

- **目标**：给出系统 **F** 的项在一致空间语义下的形式化解释。

#### **术语和符号**

- **类型解释**：一个具有 $n$ 个自由类型变量 $X_1, ..., X_n$ 的类型 $T$ 被解释为一个稳定函子 $\llbracket T \rrbracket: \text{Gem}^n \to \text{Gem}$，其中 $\text{Gem}$ 是一致空间和刚性嵌入的范畴。

- **项**：设 $t$ 是一个类型为 $T$ 的项，具有自由变量 $x_1, ..., x_m$，其类型分别为 $U_1, ..., U_m$，这些 $U$ 的自由类型变量包含在 $X$ 中。

- **解释**：$t$ 将每个 $n$ 元组 $A$（来自 $\text{Gem}^n$）和每个 $b_j \in \llbracket U_j \rrbracket (A)$ 映射到一个点 $c \in \llbracket T \rrbracket (A)$。

- **稳定性**：函数 $b \mapsto c$ 必须是稳定的。

#### **简化**

为了简化讨论，我们可以将 $t$ 替换为 $\lambda x. t$，将 $T$ 替换为 $U_1 \to ... \to U_m \to T$，使得 $m = 0$，即没有自由变量。

- **考虑的问题**：当我们改变 $A_i$ 时，会发生什么？

#### **可变一致空间**

- **设定**：令 $T: \text{Gem} \to \text{Gem}$ 是任意的稳定函子，$\tau(A) \in T(A)$ 是在 $A$ 上的一些选择的点。

- **刚性嵌入**：令 $e: A_0 \hookrightarrow A$ 是一个刚性嵌入。

- **目标**：希望 $\tau$ 对于 $e$ 是“单调的”，即 $\tau(A_0) \leq T(e)^{-}(\tau(A))$。

#### **具体化**

- **当嵌入是子空间包含时**，上式变为：

  $$
  \tau(A_0) \subseteq \tau(A) \cap |T(A_0)|
  $$

- **解释**：这意味着 $\tau(A_0)$ 是 $\tau(A)$ 与 $|T(A_0)|$ 的交集。

#### **稳定性强制等式**

- **使用可分性性质**（separability property），我们可以证明稳定性在这里强制等式成立。

- **引理（Eugenio Moggi）**：

  - **设**：$e: A_0 \hookrightarrow A$ 是一个刚性嵌入。

  - **构造**：令 $A +_{A_0} A$ 是一致空间，其 web 由两个 $|A|$ 的不一致副本组成，且子图 $|A_0|$ 被识别（identified）。

  - **性质**：$A$ 有两个典范的刚性嵌入到 $A +_{A_0} A$ 中，它们的交集是 $A_0$。

#### **稳定函数的意义**

- **问题**：$\tau$ 是从 $\text{Gem}$ 到某个未指定余域的稳定函数，这是什么意思？

- **尽管没有给出余域，我们仍然可以使用 $a \leq e^{-}(b)$（对于 $e: A \hookrightarrow B$）的定义来计算交集。

- **表示**：将 $A_1$ 和 $A_2$ 表示为 $A +_{A_0} A$ 中的两个 $A$ 的副本，它们的交集是 $A_0$。

#### **使用不等式的“投影”形式**

- **条件**：$hA'', \beta \rangle$ 在交集中，当且仅当：

  1. $A'' \subseteq A_1 \cap A_2$

  2. $\beta \in \tau(A_1) \cap |T(A'')| = \tau(A) \cap |T(A'')|$

  3. $\beta \in \tau(A_2) \cap |T(A'')| = \tau(A) \cap |T(A'')|$

- **结论**：因此，$A_1$ 和 $A_2$ 上的值的交集正是 $\tau(A) \cap |T(A_0)|$。

- **由于稳定性**，这必须是 $A_0$ 上的值 $\tau(A_0)$。

#### **命题**

- **结论**：设 $\tau$ 是可变一致空间 $T(X_1, ..., X_n)$ 的一个对象，且 $e_i: A'_i \hookrightarrow A_i$ 是刚性嵌入。

- **则有**：

  $$
  \tau(A_0) = \tau(A) \cap |T(A_0)|
  $$

- **并且**，如果 $\tau$ 满足此条件，那么它是稳定的。

### **A.4.2 Token 的一致性**

#### **进一步的观察**

- **引理的更多含义**：

  - **设**：$B = A +_{A_0} A$，它有一个自同构 $e$，交换 $A$ 的两个副本。

  - **结论**：这必须固定 $\tau(B)$，因此如果 $\beta \in \text{Tr}(\tau(B))$，那么 $e \beta$ 也在此迹中，并且必须与 $\beta$ 一致。

- **引理**：

  - **设**：$\beta \in |T(A)|$，且 $e_1, e_2: A \hookrightarrow B$ 是两个嵌入。

  - **则有**：$e_1 \beta \, \# \, e_2 \beta$ 在 $B$ 中（表示一致）。

#### **逆命题**

- **引理**：

  - **设**：$\beta \in |T(A)|$，满足：

    1. $A$ 对于 $\beta$ 是最小的（minimal），即如果 $A' \subset A$ 且 $\beta \in |T(A')|$，则 $A' = A$。

    2. $\beta$ 在 $A$ 到另一个域的任何一对嵌入下的像都是一致的。

  - **则存在**类型 $T$ 的对象 $\tau_{\langle A, \beta \rangle}$，其在 $T(B)$ 上的值为：

    $$
    \{\ T(e)(\beta) \mid e: A \hookrightarrow B \ \}
    $$

  - **并且**：这是原子的，即没有非平凡的子对象。

#### **检验条件**

- **计算量**：为了测试此条件，我们只需要考虑大小最多为 $|A|$ 的两倍的图，因此这是一个有限的计算。

- **可递归枚举**：对于任何给定的类型，这些 tokens 是可递归枚举的。

- **等价性**：由于 $\tau_{\langle A, \beta \rangle}$ 是原子的，我们必须只有一个 $\Pi X. T(X)$ 的 token，因此对于任何 $e: A \cong A'$ 且 $T(e)(\beta) = \beta'$，$\langle A, \beta \rangle$ 和 $\langle A', \beta' \rangle$ 被识别为相同。

#### **Token 的一致性**

- **问题**：我们仍然需要说明这些 tokens 何时一致。

- **引理**：

  - **设**：$\beta_1 \in |T(A_1)|$ 和 $\beta_2 \in |T(A_2)|$，它们都满足上述条件。

  - **则**：对于每个一致空间 $B$，$\tau_{\langle A_1, \beta_1 \rangle}(B) \, \# \, \tau_{\langle A_2, \beta_2 \rangle}(B)$，当且仅当对于每对嵌入 $e: A_1 \hookrightarrow C$ 和 $e': A_2 \hookrightarrow C$，有 $T(e)(\beta_1) \, \# \, T(e')(\beta_2)$。

### **A.4.3 系统 F 的解释**

#### **总结**

- **我们可以计算任何可变一致空间的全称抽象**。

- **命题**：

  - **设**：$T: \text{Gem} \to \text{Gem}$ 是一个稳定函子。

  - **则**：其全称抽象 $\Pi X. T(X)$ 是一个一致空间，其 tokens 是等价类 $\langle A, \beta \rangle$，满足：

    1. $\beta \in |T(A)|$

    2. $A$ 对于 $\beta$ 是最小的（即如果 $A' \subset A$ 且 $\beta \in |T(A')|$，则 $A' = A$，因此 $A$ 是有限的）

    3. 对于任何两个刚性嵌入 $e_1, e_2: A \hookrightarrow B$，有 $T(e_1)(\beta) \, \# \, T(e_2)(\beta)$ 在 $T(B)$ 中

    4. $\langle A, \beta \rangle$ 与 $\langle A', \beta' \rangle$ 等价，当且仅当存在同构 $e: A \cong A'$，且 $T(e)(\beta) = \beta'$（因此 $|A|$ 可以视为 $\mathbb{N}$ 的子集）

    5. $\langle A, \beta \rangle$ 与 $\langle A', \beta' \rangle$ 一致，当且仅当对于每对嵌入 $e: A \hookrightarrow B$ 和 $e': A' \hookrightarrow B$，有 $T(e)(\beta) \, \# \, T(e')(\beta')$

- **证明要点**：

  - $\Pi X. T(X)$ 是一个一致空间，因为如果任何 $\langle A, \beta \rangle$ 出现在一个点中，那么 $\tau_{\langle A, \beta \rangle}$ 的整个都出现了。

  - 任何这些的相容并集都会产生一个统一的元素。

#### **补充说明**

- **需要证明**：如果 $T: \text{Gem} \times \text{Gem} \to \text{Gem}$ 是稳定的，那么 $\Pi X. T: \text{Gem} \to \text{Gem}$ 也是稳定的。

- **还需要检查**：正负性判据仍然有效。

#### **系统 F 的一致空间语义**

- **类型解释**：具有 $n$ 个自由类型变量 $X$ 的类型 $U$ 被解释为一个稳定函子 $\llbracket U \rrbracket: \text{Gem}^n \to \text{Gem}$，遵循 **A.3** 节的定义，并增加以下规则：

  4. **如果** $U = \Pi X. T$，那么 $\llbracket U \rrbracket (A)$ 的 web 按照前述命题给出，其中 $T(X) = \llbracket T \rrbracket (A, X)$。

     - **嵌入**：由 $e: A_0 \hookrightarrow A$ 诱导的嵌入将 $\llbracket U \rrbracket (A_0)$ 的 tokens 映射为相应的 tokens，其中 $\alpha_{0i}$ 被替换为 $e_i \alpha_{0i}$。

- **项的解释**：类型为 $T$，具有 $m$ 个自由变量 $x$，类型为 $U$（$T$ 和 $U$ 的自由类型变量为 $X$）的项 $t$，被解释为对于每个 $A$，赋予一个稳定函数：

  $$
  \llbracket t \rrbracket (A): \llbracket U_1 \rrbracket (A) \, \curlywedge \, ... \, \curlywedge \, \llbracket U_m \rrbracket (A) \to \llbracket T \rrbracket (A)
  $$

  - **满足统一性方程**：对于 $e: A_0 \hookrightarrow A$ 和 $b_j \in \llbracket U_j \rrbracket (A)$，有：

    $$
    \llbracket T \rrbracket (e)^{-} (\llbracket t \rrbracket (A)(b)) = \llbracket t \rrbracket (A_0)(\llbracket U \rrbracket (e)^{-}(b))
    $$

#### **详细解释**

1. **变量**：

   - **解释**：变量 $x_j$ 由第 $j$ 个乘积投影解释。

     $$
     \llbracket x_j \rrbracket (A)(b) = b_j
     $$

2. **$\lambda$ 抽象**：

   - **解释**：$\lambda$ 抽象 $\lambda x. u$ 的解释，基于 $u$ 的解释，通过**迹**给出：

     $$
     \llbracket \lambda x. u \rrbracket (A)(b) = \{\, \langle c, \delta \rangle \mid \delta \in \llbracket u \rrbracket (A)(b, c), \ \text{且 } c \text{ 是最小的} \, \}
     $$

3. **应用**：

   - **解释**：应用 $u\, v$ 使用第8.5.2节中的公式（App）解释：

     $$
     \llbracket u\, v \rrbracket (A)(b) = \{\, \delta \mid \exists c \subseteq \llbracket v \rrbracket (A)(b), \ \langle c, \delta \rangle \in \llbracket u \rrbracket (A)(b) \, \}
     $$

4. **全称抽象**：

   - **解释**：全称抽象 $\Lambda X. v$ 也通过“迹”给出：

     $$
     \llbracket \Lambda X. v \rrbracket (A)(b) = \{\, [\, \langle C, \delta \rangle \, ] \mid \delta \in \llbracket v \rrbracket (A, C)(b), \ \text{且 } C \text{ 是最小的} \, \}
     $$

     - **等价类**：$[\, \langle C, \delta \rangle \, ]$ 表示等价类，$\langle C, \delta \rangle$ 与 $\langle C', \delta' \rangle$ 等价，当且仅当 $e: C \cong C'$ 且 $\llbracket v \rrbracket (A, e)(b)(\delta) = \delta'$。

5. **全称应用**：

   - **解释**：全称应用 $t\, U$ 通过应用公式给出：

     $$
     \llbracket t\, U \rrbracket (A)(b) = \{\, \delta \mid \exists e: C \hookrightarrow \llbracket U \rrbracket (A), \ [\, \langle C, \delta \rangle \, ] \in \llbracket t \rrbracket (A)(b) \, \}
     $$

#### **转换规则的满足**

- **原因**：转换规则成立，因为它们相当于 $\Pi X. T(X)$ 的对象与 $T$ 的可变对象之间的双射。

- **需要证明**：一个类似于第9.2节的替换引理。

---

## **A.5 例子**

### **A.5.1 自然地（Of course）**

#### **目标**

- **计算**：我们旨在计算在第11.3节中使用系统 **F** 解释的简单类型的**一致空间表示**，如乘积、和和存在类型。

- **注意**：这些类型本质上都是从 $\Pi X.(U \to X) \to X$ 派生的，因此我们将详细考虑这个类型，并随后简单陈述其他结果。

#### **Token 的形式**

- **正负性判据**仍然对像 $U$ 这样的常量有效，因此这个类型的 token 形式为：

  $$
  \langle \text{Sgl}, \{\, \langle u_i, \bullet \rangle : i = 1, ..., k \, \}, \bullet \rangle
  $$

  - **解释**：其中 $u_i$ 遍历 $U$ 的有限 cliques，即 $!U$ 的 tokens。

- **尽管只有一个 token（即 $\bullet$）可用于标记 $u_i$，但它可能重复出现**。

- **因此**：token 由 $!U$ 的 tokens 组成的有限集合（两两不一致）给出。

#### **符号化**

- **换句话说**，在指称语义（denotationally）上，我们有：

  $$
  \Pi X.(U \to X) \to X \cong (!((!U)^\perp))^\perp = ?!U
  $$

  - **其中**：我们将 $?!U$ 称为 $\lnot\lnot U$（稍有滥用）。

#### **程序的效果**

- **考虑程序**：

  $$
  \langle \text{Sgl}, \{\, \langle u_1, \bullet \rangle, \langle u_2, \bullet \rangle \, \}, \bullet \rangle
  $$

- **在类型 $A$ 上，给定稳定函数 $f: U \to A$，其效果是**：

  - **检查迹** $\text{Tr}(f)$，输出那些满足 $\langle u_1, \alpha \rangle$ 和 $\langle u_2, \alpha \rangle$ 都在其中的 tokens $\alpha$。

- **这推广了我们在 $\llbracket \text{Bool} \rrbracket$ 中发现的交集。**

#### **未定义项的引入**

- **不可避免的特征**：在系统 **F** 的域模型中，将 $\varnothing$ 添加到 $U$ 是不可避免的，因为类型为 $\lnot\lnot U$ 的程序没有终止的义务。

- **奇特之处**：我们可能有 $u_1 \leq u_2$，即 $U$ 的两个有限点（或 cliques），它们产生了 $\lnot\lnot U$ 的原子 token。

  - **解释**：在某些函数上，一个会输出 $\alpha$ 而另一个不会，反之亦然。

- **原因**：这是稳定解释和 Berry 序的结果，后者比逐点序要弱得多。

  - **测试**：对函数的测试不仅是数据 $u$ 是否足以输出 $\alpha$，还涉及其必要性。

#### **乘积、和和存在类型的计算**

- **乘积类型**：

  $$
  \Pi X.(U \to V \to X) \to X \cong \lnot\lnot(U \curlywedge V) \cong ?(!U \otimes !V)
  $$

  - **其中**：我们将 $\otimes$ 视为“线性合取”。

- **和类型**：

  $$
  \Pi X.(U \to X) \to (V \to X) \to X \cong \lnot\lnot(U + V) \cong ?(!U \oplus !V)
  $$

  - **注意**：除了 $?$ 之外，这就是我们在第12章中确定的和类型。

- **存在类型**：

  $$
  \Pi Y.(\Pi X.(V(X) \to Y)) \to Y \cong \lnot\lnot(\Sigma^\circ_X V)
  $$

  - **其中**：对于一个变量类型 $T: \text{Gem} \to \text{Gem}$，$\Sigma^\circ_X T(X)$ 是我们在 **A.3.1** 节中遇到的**总范畴**。

---

**总结**：通过一致空间的语义解释，我们深入了解了系统 **F** 中项和类型的行为，特别是全称类型和统一性的概念。我们探讨了如何在一致空间中解释系统 **F** 的项，以及这些解释如何满足统一性和稳定性的条件。

如果您对某个部分有疑问，或者希望进一步解释某些概念，请告诉我！

### ---------------------------

# **附录A 系统F的语义**

**作者：Paul Taylor**

---

本附录将为系统 **F** 提供一个基于**一致空间**（coherence spaces）的语义解释。特别地，我们将通过解释全称抽象（universal abstraction）的方式，展示一阶和二阶等式的成立。我们将探讨项如何对所有类型保持**统一性**（uniformity）。最后，我们将尝试计算一些全称类型的例子，例如 $\text{Emp} = \Pi X. X$，$\text{Sgl} = \Pi X. X \to X$，$\text{Bool} = \Pi X. X \to X \to X$ 和 $\text{Int} = \Pi X. X \to (X \to X) \to X$。

---

## **A.1 全称类型的项**

### **A.1.1 有限近似**

#### **背景**

在第11.2节中，我们提到，全称类型 $\Pi X. T$ 的项 $\Lambda X. t$ 被理解为一个函数，它将任何类型 $U$ 映射为类型 $T[U/X]$ 的项 $t[U/X]$。

特别地，全称恒等函数 $\Lambda X. \lambda x. x$ 的解释应当是将任何一致空间 $A$ 映射为其恒等函数的迹（trace），即：

$$
\text{Id}_A = \{ (\{\alpha\}, \alpha) : \alpha \in |A| \}
$$

#### **问题**

然而，我们面临着规模（size）的挑战：一致空间的数量构成一个真类（proper class），因此我们如何将此作为一个合法的函数？

#### **解决方案**

我们可以通过以下方法解决此问题：

- **有限近似**：要求每个域都可以表示为有限域的“极限”（limit）。
- **连续性**：通过连续性，我们可以从项在有限域上的值导出其在任意域上的值。
- **可数性**：由于同构意义下只有可数多个有限域，因此该函数可以由一个集合定义。
- **一致性**：确保其在同构域上的值是相等的（沿着同构映射）。

### **A.1.2 饱和域**

#### **另一种方法**

一种常见但可能误导的替代方案是：

- **选择“大”域 $\Omega$**：它在所有相关的类型操作下都是饱和的。
- **限制域为 $\Omega$ 的子域**：将我们的域 $A$ 限制为 $\Omega$ 的“子域”。
- **确保闭包**：例如，如果 $A$ 是这样的子域，那么 $A \to A$ 也是这样的子域，特别地，$\Omega \to \Omega$ 也是。

这样，恒等函数作为 $\Omega \to \Omega$ 的一个元素，被视为 $\Omega$ 的一个子空间的元素，因此也是 $\Omega$ 的一个元素。

#### **问题**

然而，这种方法存在一些问题：

1. **元素和类型的混淆**：需要区分 $\Omega$ 作为“元素的宇宙”和某个域 $V$，其元素可作为类型的名称——即“类型的宇宙”。

2. **命名问题**：需要每个变量域都由一个类型为 $V$ 的项（具有相同的自由变量）命名。

3. **同构类型的区别**：同构的类型可能由 $V$ 的不同元素表示，没有任何机制强制全称项在这些元素上的值相等。

4. **模型限制**：使用嵌入的范畴作为 $V$，虽然可以为系统 $F$ 建模，但不适用于所有当前使用的域范畴。

#### **统一性的问题**

上述问题的核心在于项对所有类型的**统一性**（uniformity）未得到满足。

### **A.1.3 统一性（Uniformity）**

#### **概念**

统一性要求对类型的所有自同构（例如置换），构造都是不变的。

- **直观解释**：类似于在几何中，构造必须是球的中心、锥的轴等。
- **数学定义**：一个在自同构下（集合意义上）不变的群的子群称为**特征子群**（characteristic subgroup）。
- **约束性**：自同构越多，统一性的约束就越强。

#### **利用统一性**

通过制造自同构，可以利用统一性条件：

- **构造对称性**：例如，将一个域与自身相加，形成一个具有“左右”对称性的结构。
- **统一性限制**：在这种结构中，一个“统一”的元素不能在左或右部分，只能在公共子空间中。

#### **与稳定性的关系**

稳定性条件迫使统一性成立：

- **交集一致性**：在交集中，统一项的值必须相等。
- **结论**：一致空间模型满足统一性条件。

---

## **A.2 刚性嵌入（Rigid Embeddings）**

### **概念**

为了定义域的近似，我们引入**嵌入-投影对**（embedding-projection pair）：

- **嵌入 $e: A \hookrightarrow B$**：表示 $A$ 可以嵌入到 $B$ 中。
- **投影 $p: B \twoheadrightarrow A$**：从 $B$ 投影回 $A$。
- **满足条件**：$1_A = p e$，且 $e p \leq 1_B$。

在一致空间中：

- **$e$ 是稳定的**：它是线性的，保留一致性关系。
- **表示为图嵌入**：可以将 $e$ 视为 webs 之间的函数，$e \alpha$ 表示 $e$ 在 token $\alpha$ 上的作用。

### **迹（Trace）**

- **$e$ 的迹**：$\text{Tr}(e) = \{ (\{\alpha\}, e \alpha) : \alpha \in |A| \}$
- **$p$ 的迹**：$\text{Tr}(p) = \{ (\{ e \alpha \}, \alpha) : \alpha \in |A| \}$

### **函数空间的函子性**

为了使函数空间对其第一个参数是函子的（正的），需要定义箭头类型的嵌入：

- **给定 $e: A' \hookrightarrow A$ 和 $f: B' \hookrightarrow B$**，定义 $e \to f: (A' \to B') \hookrightarrow (A \to B)$。
- **作用方式**：
  - **正向映射**：$(e \to f)^+ (t')(a) = f^+ (t'(e^- a))$
  - **反向映射**：$(e \to f)^- (t)(a') = f^- (t(e^+ a'))$

**结论**：一致空间和刚性嵌入构成范畴 $\text{Gem}$，箭头类型是从 $\text{Gem} \times \text{Gem}$ 到 $\text{Gem}$ 的协变函子。

---

## **A.3 类型的解释**

### **类型解释为函子**

任何具有 $n$ 个自由类型变量的类型 $T$，都可以解释为一个稳定函子 $\llbracket T \rrbracket: \text{Gem}^n \to \text{Gem}$。

- **常量类型**：$\llbracket T \rrbracket (A_1, ..., A_n) = T$，任何态射都映射为恒等映射。
- **类型变量**：$\llbracket X_i \rrbracket (A_1, ..., A_n) = A_i$。
- **函数类型**：$\llbracket U \to V \rrbracket (A_1, ..., A_n) = \llbracket U \rrbracket (A_1, ..., A_n) \to \llbracket V \rrbracket (A_1, ..., A_n)$。

### **替换的保持**

类型解释尊重类型的替换：

$$
\llbracket T[U_i / X_i] \rrbracket = \llbracket T \rrbracket (\llbracket U_1 \rrbracket, ..., \llbracket U_n \rrbracket)
$$

### **全称类型的 tokens**

在一致空间模型中，全称类型的 tokens 可以通过有限子空间来描述：

- **有限近似**：任何 token 都存在于某个有限子空间的解释中。
- **最小子空间**：对于每个 token，可以找到最小的子空间使其被定义。

### **线性记号表示**

使用线性逻辑，可以对 tokens 进行表示：

- **箭头类型**：$A \to B \cong !A \multimap B \cong (!A \otimes B^\perp)^\perp$
- **表示**：
  - **$!A$ 的 tokens**：$|!A|$ 是 $|A|$ 的 cliques（完全子图）。
  - **$B^\perp$ 的 tokens**：$|B^\perp|$ 是 $|B|$ 的补图。
  - **恒等函数的 token**：$(\text{Sgl}, (\{ \bullet \}, \bullet))$。

### **正负出现的判定**

- **引理**：通过考察 token 中某个元素 $\alpha$ 的正负出现，可以判定其是否为全称类型的有效 token。
- **推论**：全称类型的 tokens 中，每个元素必须既正出现又负出现。

### **简单类型的示例**

- **$T = X \to X$**：只有一个 token，对应于恒等函数。
- **$T = X$**：没有 token，因此 $\llbracket \Pi X. X \rrbracket$ 是空的一致空间。
- **$T = \text{Bool} = \Pi X. X \to X \to X$**：有三个 tokens，对应于布尔值和交集操作。

---

**总结**：通过一致空间的语义解释，我们可以深入理解系统 **F** 中全称类型和项的统一性，以及它们在不同类型上的行为。

---

如果您对某个部分有疑问，或者希望进一步解释某些概念，请告诉我！

### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------
[toc]



好的，让我们继续深入解析**第8章：有限离散图式（Finite Discrete Sketches）**。本章介绍了有限离散图式（FD sketches），它们比第7章中讨论的有限积图式更为通用，允许指定既包含积（products）又包含和（sums）的对象。我们将逐节详细解释各个概念和示例，重点在于理解定义和应用，而避免使用图示以确保内容的清晰性。

## 第8章 有限离散图式（Finite Discrete Sketches）

有限离散图式（FD sketches）是图式的一种扩展，能够同时描述积和和，从而能够更全面地刻画各种代数结构。相比于仅包含有限积的图式，FD图式能够表示如场（fields）这样复杂的结构。

### 8.1 有限离散图式简介（Finite Discrete Sketches）

#### 8.1.1 定义（Definition）

**有限离散图式（Finite Discrete Sketch）**是一个图式$S = (G, D, L) $，其中：

- **图$G $**：包含有限数量的节点和箭头，用于表示对象和态射。
- **图式约束$D $**：包含有限数量的图式约束，通常涉及极限和余极限（即积和和）。
- **锥$L $**：定义了图式中对象之间的积和和。

相比于有限积图式，FD图式不仅指定了积对象，还指定了和对象（即余积对象），从而能够描述更多样化的代数结构。

#### 8.1.2 积与和（Products and Sums）

在范畴论中：

- **积（Product）**：给定一组对象，其积对象是一个包含这些对象的通用对象，满足投影态射的唯一性条件。
- **和（Sum）**：也称为余积，是给定一组对象的“并”对象，满足注入态射的唯一性条件。

FD图式通过在图式中同时包含积和和的定义，能够描述如环、域、模等更复杂的代数结构。

#### 8.1.3 有限离散图式的特性

- **有限性**：图式中的节点和箭头都是有限的。
- **离散性**：不涉及无限的结构，便于具体构造和分析。
- **多样性**：同时包含积和和，使其适用于更广泛的代数结构描述。

### 8.2 场的图式描述（The Sketch for Fields）

为了展示FD图式的应用，我们将详细描述一个用于定义**场（Field）**的图式。场是一个具有加法和乘法运算的代数结构，满足一系列公理。

#### 8.2.1 场的定义回顾

一个**域**是一个集合$F$配备了两个二元运算$+$和$\cdot $，满足以下公理：

1. **加法群**：
   -$(F, +)$是阿贝尔群（交换群）。
2. **乘法群**：
   -$(F \setminus \{0\}, \cdot)$是阿贝尔群。
3. **分配律**：
   - 对于所有$a, b, c \in F $，有$a \cdot (b + c) = a \cdot b + a \cdot c $。

#### 8.2.2 场的图式构造

为了构造描述域的FD图式$S_{\text{Field}} $，我们需要定义以下组件：

1. **节点（Objects）**：
   - **$ 0 $**：加法的零元素。
   - **$ 1 $**：乘法的单位元素。
   - **$ F $**：场的载体对象。
   - **$ F \times F $**：积对象，用于表示二元运算。
   - **$ F \setminus \{0\} $**：去除零元素的乘法载体对象。

2. **箭头（Arrows）**：
   - **加法运算$+ : F \times F \to F $**。
   - **加法的零元素$z : 1 \to F $**。
   - **加法的逆元素$\text{inv} : F \to F $**。
   - **乘法运算$\cdot : F \times F \to F $**。
   - **乘法的单位元素$e : 1 \to F $**。
   - **乘法的逆元素$\text{inv}_{\cdot} : F \setminus \{0\} \to F $**。
   - **分配律的相关态射**，确保乘法对加法的分配。

3. **锥和图式约束（Cones and Diagram Constraints）**：
   - **加法的零元素定义**：确保$z$是加法的单位元。
   - **加法的逆元定义**：确保对于每个$a \in F $，存在$\text{inv}(a)$满足$a + \text{inv}(a) = 0 $。
   - **乘法的单位元定义**：确保$e$是乘法的单位元。
   - **乘法的逆元定义**：确保对于每个$a \in F \setminus \{0\} $，存在$\text{inv}_{\cdot}(a)$满足$a \cdot \text{inv}_{\cdot}(a) = e $。
   - **分配律的定义**：确保$a \cdot (b + c) = a \cdot b + a \cdot c $。

通过这些节点、箭头和约束，图式$S_{\text{Field}}$完整地描述了域的代数结构。

#### 8.2.3 场的模型（Models of the Sketch for Fields）

在集合范畴$\text{Set}$中，一个模型$M$的具体解释如下：

- **$ M(F) $**：一个集合，表示域的元素。
- **加法运算$M(+ ) : M(F) \times M(F) \to M(F) $**。
- **加法的零元素$M(z) : 1 \to M(F) $**，将唯一元素映射到加法的零元素。
- **加法的逆元素$M(\text{inv}) : M(F) \to M(F) $**，将每个元素映射到其加法逆元。
- **乘法运算$M(\cdot ) : M(F) \times M(F) \to M(F) $**。
- **乘法的单位元素$M(e) : 1 \to M(F) $**，将唯一元素映射到乘法的单位元素。
- **乘法的逆元素$M(\text{inv}_{\cdot}) : M(F) \setminus \{0\} \to M(F) $**，将每个非零元素映射到其乘法逆元。
- **分配律的态射**：确保乘法对加法的分配律成立。

这样的模型$M$满足域的所有公理，即$(M(F), M(+ ), M(e))$是一个域。

### 8.3 初始代数构造的修改（Modifying Initial Algebra Construction for FD Sketches）

在有限积图式中，初始代数的构造依赖于递归地生成所有由图式强制存在的元素。对于有限离散图式，初始代数的构造需要同时处理积和和，因此需要对构造方法进行相应的调整。

#### 8.3.1 初始代数的基本思想

**初始代数（Initial Algebra）**是图式模型范畴中的初始对象，具有以下特性：

- **唯一性**：对于任何其他模型，存在唯一的模型同态从初始代数指向该模型。
- **术语模型（Term Model）**：初始代数中的元素都是通过图式中定义的操作和常量“强制”生成的，没有多余的元素。

#### 8.3.2 构造方法的调整

对于FD图式，构造初始代数需要同时考虑积和和的生成。具体步骤如下：

1. **字母表扩展（Extended Alphabet）**：
   - 定义一个字母表$A_S$包含所有图式中的箭头、积和和的相关态射。
   - 包含所有操作箭头（如加法、乘法）、常量箭头（如零、单位元）以及投影和注入态射。

2. **构造规则的扩展（Extended Construction Rules）**：
   - **积相关规则**：与有限积图式中的构造规则类似，递归地生成所有由积运算生成的元素。
   - **和相关规则**：递归地生成所有由和运算生成的元素。
   - **结合律和分配律**：确保生成的元素满足图式中定义的所有代数公理，如结合律和分配律。

3. **递归生成元素（Recursively Generating Elements）**：
   - 从图式中的常量和终对象出发，递归应用积和和的构造规则，生成所有必需的元素。
   - 通过这种方式，确保初始代数中仅包含由图式强制存在的元素。

4. **唯一性和初始性验证（Uniqueness and Initiality Verification）**：
   - 验证构造出的代数确实满足初始代数的定义，即对于任何其他模型，存在唯一的同态指向该模型。
   - 确保没有多余的元素和操作，保持术语模型的特性。

#### 8.3.3 示例：域的初始代数构造

让我们以域的图式$S_{\text{Field}}$为例，说明如何构造其初始代数：

1. **常量和单位元**：
   - 初始代数中包含加法的零元素$0$和乘法的单位元素$1 $。

2. **递归应用运算**：
   - 通过加法和乘法生成所有必要的元素，如$0, 1, 0 + 1, 1 \cdot 1, (0 + 1) + 1, \ldots $。
   - 确保所有元素满足加法和乘法的公理，如交换律、结合律和分配律。

3. **唯一性验证**：
   - 验证每个元素在初始代数中都是唯一的，且仅通过图式定义的运算生成。
   - 确保初始代数中不存在未通过运算生成的多余元素。

通过上述步骤，可以构造出一个符合域定义的初始代数，其元素和运算完全由图式$S_{\text{Field}}$强制生成。

### 8.4 有限离散图式的理论（Theory of Finite Discrete Sketches）

虽然本章重点在于有限离散图式及其初始代数的构造，但有限离散图式也有其理论（theory），即对应的范畴$\text{ThFD}(S) $。这些理论的详细讨论将在第10章中进行。

### 8.5 练习题（Exercises 8.5）

**练习1**：

**题目**：

设$S$是第8.2节中构造的描述域的有限离散图式，证明$S$的初始代数确实满足域的所有公理。

**解析**：

**目标**：

验证通过构造得到的初始代数$I$确实是一个域，即满足加法和乘法的所有公理。

**步骤**：

1. **加法群**：
   - 验证$(I(F), +)$是阿贝尔群。
   - 确认存在零元素$0 $，每个元素都有逆元$\text{inv}(x) $，加法满足交换律和结合律。

2. **乘法群**：
   - 验证$(I(F) \setminus \{0\}, \cdot)$是阿贝尔群。
   - 确认存在单位元$1 $，每个非零元素都有逆元$\text{inv}_{\cdot}(x) $，乘法满足交换律和结合律。

3. **分配律**：
   - 验证对于所有$x, y, z \in I(F) $，有$x \cdot (y + z) = x \cdot y + x \cdot z $。

4. **唯一性**：
   - 确保初始代数中每个元素的生成路径唯一，避免冲突和冗余。

**结论**：

通过逐一验证加法和乘法的群性质及分配律，证明构造得到的初始代数$I$确实是一个域。

**练习2**：

**题目**：

设$S$是一个包含两个节点$a$和$b $，两个箭头$f : a \to a$和$g : a \to b $，以及一个锥。具体来说，图式包含如下组成部分：

- 节点：$ a, b $
- 箭头：$ f : a \to a $、$ g : a \to b $
- 锥：顶点为$a \times b $，基底由$f$和$g$组成。

证明在任何具有有限积的范畴$\mathcal{C}$中，图式$S$的模型范畴$\text{Mod}(S, \mathcal{C})$与范畴$\mathcal{C}$本身同构。

**解析**：

**目标**：

构造范畴同构的函子$F : \text{Mod}(S, \mathcal{C}) \to \mathcal{C}$和$G : \mathcal{C} \to \text{Mod}(S, \mathcal{C}) $，并证明它们互为逆函子。

**步骤**：

1. **构造函子$F $**：
   - **对象映射**：将模型$M$映射到$M(a) $。
   - **态射映射**：将模型同态$\alpha : M \to M'$映射到$\alpha_a : M(a) \to M'(a) $。

2. **构造函子$G $**：
   - **对象映射**：将对象$X \in \mathcal{C}$映射到模型$G(X) $，其中：
     -$G(X)(a) = X $
     -$G(X)(b) = Y $（需要定义$Y $，通常$Y = X $）
     -$G(X)(f) = \text{id}_X $
     -$G(X)(g) = \text{id}_Y $
     - 确保$G(X)$满足图式$S$的约束，即$G(X \times Y) = X \times Y $，且投影态射对应$f$和$g $。
   - **态射映射**：将$h : X \to X'$映射到同态$G(h) : G(X) \to G(X') $，其中$G(h)_a = h $，$ G(h)_b = h $。

3. **验证函子同构性**：
   - **同构性条件**：
     - **$ F \circ G = \text{id}_{\mathcal{C}} $**：
       - 对于每个对象$X \in \mathcal{C} $，$ F(G(X)) = X $。
       - 对于每个态射$h : X \to X' $，$ F(G(h)) = h $。
     - **$ G \circ F = \text{id}_{\text{Mod}(S, \mathcal{C})} $**：
       - 对于每个模型$M $，$ G(F(M)) = G(M(a))$应等于$M $。
       - 具体来说，模型$M$中的箭头$f$和$g$必须与$G(M(a))$中定义的$\text{id}_X$和$\text{id}_Y$保持一致，这通过$M$满足图式$S$的约束得以保证。

4. **结论**：

函子$F$和$G$构成了范畴同构，即$\text{Mod}(S, \mathcal{C}) \cong \mathcal{C} $。这意味着在具有有限积的范畴$\mathcal{C}$中，图式$S$的模型范畴与$\mathcal{C}$本身在结构上完全一致。

### 8.6 术语代数（Term Algebras for FD Sketches）

术语代数（Term Algebras）是初始代数的一种具体表现形式，其中代数中的元素是通过术语生成的。这种构造方法在有限积图式和有限离散图式中都起到关键作用。

#### 8.6.1 术语代数的基本概念

**术语代数（Term Algebra）**：

- **术语（Terms）**：由图式中的常量和操作符递归生成的表达式。
- **代数结构**：术语代数通过这些术语和操作定义了代数结构中的元素及其运算。

在FD图式中，术语不仅涉及积运算，还涉及和运算，因此术语代数需要处理这两种类型的运算。

#### 8.6.2 构造术语代数

构造术语代数的步骤如下：

1. **基础术语**：
   - 包含图式中的所有常量元素。
   
2. **递归应用运算**：
   - 对于每个操作符（积和和），递归地生成新的术语。
   - 例如，给定两个术语$t$和$u $，积运算$t \times u$和和运算$t + u$生成新的术语。

3. **约束处理**：
   - 通过图式中的约束（如结合律、交换律等），识别和合并等价的术语。

4. **唯一性维护**：
   - 确保每个术语在术语代数中是唯一的，避免重复或矛盾。

#### 8.6.3 示例：自然数代数

让我们以自然数代数为例，说明术语代数的构造：

1. **图式描述**：
   - 节点：终对象$1$和自然数对象$n $。
   - 箭头：零元$z : 1 \to n$和后继函数$\text{succ} : n \to n $。

2. **术语生成**：
   - 基础术语：$ z $。
   - 通过后继函数递归生成术语：
     -$\text{succ}(z)$表示 1。
     -$\text{succ}(\text{succ}(z))$表示 2。
     - 依此类推。

3. **术语代数结构**：
   - 元素：$ z, \text{succ}(z), \text{succ}(\text{succ}(z)), \ldots $。
   - 运算：$ \text{succ}$定义了从一个术语到其后继术语的映射。

通过这种方式，术语代数$T$对应于标准的自然数集合$\mathbb{N} $，且$\text{succ}$对应于标准的自然数后继函数。

#### 8.6.4 自由代数与初始代数的关系

**自由代数（Free Algebra）**是由一个类型化集合生成的初始模型，其元素完全由术语生成，并且仅包含由图式强制存在的元素。术语代数是自由代数的一种具体实现，确保了代数结构的初始性和无冗余性。

**关系总结**：

- **术语代数** 是通过术语生成初始代数的一种方法。
- **初始代数** 具备术语代数的所有性质，并且是模型范畴中的初始对象。

### 本章总结

**有限离散图式（FD sketches）**通过同时指定积和和的结构，扩展了有限积图式的表达能力，使其能够描述更复杂的代数结构，如域、环等。本章通过具体示例（如描述域的图式）和构造方法，展示了FD图式的定义、性质及其在构造初始代数中的应用。

**主要要点总结**：

1. **有限离散图式的定义与特性**：
   - FD图式不仅包含积对象，还包含和对象，使其适用于更广泛的代数结构描述。
   - 通过有限且离散的图式构造，保证了模型的可构造性和具体性。

2. **领域的图式描述**：
   - 通过详细构造域的图式，展示了如何利用FD图式描述复杂的代数结构。
   - 确保所有域的公理（如加法和乘法的群性质、分配律）在图式中得到体现。

3. **初始代数构造的扩展**：
   - 对有限积图式中的初始代数构造方法进行了扩展，以同时处理积和和运算。
   - 通过递归应用构造规则，生成初始代数，确保其满足图式定义的所有公理。

4. **术语代数的构造与应用**：
   - 术语代数通过术语生成初始代数，确保模型中仅包含由图式强制存在的元素。
   - 提供了具体的构造方法和示例，增强了对初始代数构造过程的理解。

5. **练习题的应用**：
   - 通过练习题，进一步巩固了对FD图式和初始代数构造方法的理解。
   - 通过具体示例（如域的初始代数），验证了理论的有效性和应用性。

6. **理论与应用的桥梁**：
   - 虽然本章主要聚焦于图式和初始代数的构造，但有限离散图式的理论（theory）将在后续章节中详细讨论，为更深入的代数结构研究奠定基础。

**应用与扩展**：

- **编程语言理论**：FD图式可用于形式化描述复杂数据类型和语言特性，通过初始代数构造数据类型的具体实现。
- **逻辑系统**：利用FD图式描述逻辑推理规则和证明结构，实现逻辑系统的形式化表示。
- **代数结构研究**：通过FD图式描述各种代数结构（如环、域、模等），促进对这些结构性质的深入理解和研究。

通过掌握有限离散图式及其初始代数构造方法，读者能够灵活地描述和分析各种复杂的代数结构，并在范畴论的框架下理解其内在关系和性质。

### ---------------------------

好的，让我们继续详细解析**第8章：有限离散图式（Finite Discrete Sketches）**中的**8.1节：具有和的图式（Sketches with Sums）**。本节介绍了有限离散图式（FD sketches）的基本概念，解释了如何通过引入和（sums）来扩展图式的表达能力，并通过具体例子展示了FD图式在描述不同代数结构中的应用。

## 8.1 具有和的图式（Sketches with Sums）

引入和（sums）作为图式中的余极限（cocones）以及积（products）作为极限（cones），使得图式不仅能够表达n元运算，还能够表达选择性操作（alternatives）。这对于描述如列表、自然数带溢出等数据类型尤为重要。

### 8.1.1 有限离散图式的定义（Definition of Finite Discrete Sketches）

**有限离散图式（Finite Discrete Sketch, FD sketch）**$S = (G, D, L, K)$由以下组成部分构成：

1. **有限图$G $**：
   - 包含有限数量的节点和箭头，表示对象和态射。

2. **有限集合的图式约束$D $**：
   - 包含有限数量的有限图式（diagrams），这些图式需要在模型中转化为交换图式。

3. **有限集合的离散锥$L $**：
   - 每个离散锥$C \in L$由一个顶点和有限个基底组成，表示积（product）的定义。

4. **有限集合的离散余锥$K $**：
   - 每个离散余锥$K \in K$由一个顶点和有限个基底组成，表示和（sum）的定义。

**模型（Model）**：
- 一个**FD图式**$S$在集合范畴$\text{Set}$中的模型是一个图同态$M: G \to \text{Set} $，满足：
  - 将图式约束$D$映射为交换图式。
  - 将离散锥$L$映射为积锥（product cones）。
  - 将离散余锥$K$映射为和余锥（sum cocones）。

**说明**：
- **积锥**：在模型中，积锥确保对应的对象是积对象，并且投影态射满足积的定义。
- **和余锥**：在模型中，和余锥确保对应的对象是和对象，并且注入态射满足和的定义。

通过同时引入积和和，FD图式能够描述更复杂的数据结构和代数系统，如列表（lists）、自然数带溢出（natural numbers with overflow）等。

### 8.1.2 列表的图式描述（The Sketch for Lists）

**示例：有限列表的图式（FD Sketch for Finite Lists）**

有限列表是一种基本的数据类型，支持空列表和通过将元素附加到已有列表生成非空列表的操作。为了形式化描述有限列表，我们构造一个FD图式。

**图式$S_{\text{List}}$的组成**：

1. **节点（Objects）**：
   -$1 $：终对象，表示空列表。
   -$d $：数据元素的类型。
   -$l $：列表的类型。
   -$l^+ $：非空列表的类型。

2. **箭头（Arrows）**：
   - **无箭头**：该图式中没有额外的态射箭头，所有的操作通过锥和余锥定义。

3. **锥（Cones）**：
   - **空基锥**：顶点为$1 $，基底为空，确保$1$在模型中为终对象。
   - **积锥**：
    $$
     d \times l \xrightarrow{\text{head}} l^+
    $$
    $$
     d \times l \xrightarrow{\text{tail}} l
    $$
     这表示非空列表$l^+$由一个数据元素（head）和一个列表（tail）组成，即$l^+ = d \times l $。

4. **余锥（Cocones）**：
   - **和余锥**：
    $$
     l \xrightarrow{\text{inl}} l + l^+
    $$
    $$
     l^+ \xrightarrow{\text{inr}} l + l^+
    $$
     这表示一个列表$l$要么是空列表（inl），要么是非空列表（inr），即$l = 1 + l^+ $。

**总结表达式**：
- **非空列表**：$ l^+ = d \times l $（一个非空列表由一个数据元素和一个列表组成）。
- **列表**：$ l = 1 + l^+ $（一个列表要么是空列表，要么是一个非空列表）。

**模型解释**：
- **集合范畴中的模型**$M $：
  -$M(1)$是一个包含单一元素的集合，表示空列表。
  -$M(d)$是一个集合，表示数据元素的类型。
  -$M(l)$是所有有限列表的集合。
  -$M(l^+)$是所有有限非空列表的集合。
  -$M(\text{head})$和$M(\text{tail})$分别提取非空列表的头部元素和尾部列表。

**术语代数视角**：
- 初始术语模型（Initial Term Model）包含所有通过常量和操作生成的列表元素，确保没有多余的元素。

### 8.1.3 列表图式的其他模型（Other Models of the List Sketch）

除了初始术语模型，列表图式$S_{\text{List}}$在集合范畴$\text{Set}$中还存在其他模型。这些模型可能包含初始模型中未被操作生成的“垃圾”元素。

**示例**：
- **包含无限列表的模型**：
  - **$ M(l) $**：包括所有有限和无限列表。
  - **$ M(l^+) $**：包括所有非空的有限和无限列表。
  - **$ M(\text{head}) $** 和 **$ M(\text{tail}) $**：仍然提取非空列表的头部元素和尾部列表。
  

**特点**：
- 该模型包含初始模型之外的元素，即无限列表，这些元素无法通过递归操作从常量生成，因此被视为“垃圾”（junk）。
- **无杂质性**：初始模型不包含这些“垃圾”元素，因此它们具有“无杂质性”（no junk）。

**结论**：
- 初始模型是唯一没有“垃圾”元素的模型，确保模型的纯粹性和一致性。
- 其他模型可能包含额外的元素，但这些元素在初始模型中是不存在的，体现了初始模型的普遍性和唯一性。

### 8.1.4 自然数溢出图式（The Sketch for Natural Numbers with Overflow）

**示例：自然数溢出的图式（FD Sketch for Natural Numbers with Overflow）**

为了展示FD图式如何处理溢出（overflow）问题，我们构造一个描述自然数及其溢出的图式。

**图式$S_{\text{NatOverflow}}$的组成**：

1. **节点（Objects）**：
   -$1 $：终对象。
   -$n $：自然数的类型。
   -$n_{\text{over}} $：溢出元素的类型。
   -$n + n_{\text{over}} $：所有自然数及溢出元素的类型。

2. **箭头（Arrows）**：
   - **常量箭头**：
     -$\text{zero} : 1 \to n $（自然数的零）。
   - **一元运算箭头**：
     -$\text{succ} : n \to n + n_{\text{over}} $（自然数的后继操作）。
   
3. **锥（Cones）**：
   - **空基锥**：顶点为$1 $，基底为空，确保$1$在模型中为终对象。

4. **余锥（Cocones）**：
   - **和余锥**：
    $$
     n \xrightarrow{\text{inl}} n + n_{\text{over}}
    $$
    $$
     n_{\text{over}} \xrightarrow{\text{inr}} n + n_{\text{over}}
    $$
     这表示$n + n_{\text{over}}$是$n$和$n_{\text{over}}$的和，即一个自然数要么是正常的自然数，要么是溢出元素。

**总结表达式**：
- **自然数零**：$ \text{zero} : 1 \to n $。
- **自然数后继**：$ \text{succ} : n \to n + n_{\text{over}} $。
- **类型定义**：$ n + n_{\text{over}}$表示所有自然数及其溢出。

**模型解释**：
- **集合范畴中的模型**$M $：
  -$M(1)$是一个包含单一元素的集合，表示自然数的零。
  -$M(n)$是一个集合，表示自然数。
  -$M(n_{\text{over}})$是一个集合，表示溢出元素。
  -$M(n + n_{\text{over}})$是$M(n)$和$M(n_{\text{over}})$的并集。
  -$M(\text{succ})$将每个自然数映射到其后继元素，如果达到某个上限，则映射到溢出元素。
  

**不同模型的构造**：

#### 8.1.5 自然数图式的第一个模型（The First Model: Standard Natural Numbers）

**模型描述**：
- **$ M(n) $**：标准的自然数集合$\mathbb{N} $。
- **$ M(\text{zero}) $**：映射为自然数零$0 $。
- **$ M(\text{succ}) $**：定义为$\text{succ}(i) = i + 1 $。
- **$ M(n_{\text{over}}) $**：映射为空集，表示没有溢出元素。

**特点**：
- **无溢出**：由于$M(n_{\text{over}})$是空集，所有自然数通过后继操作无限延伸，没有溢出。
- **初始术语模型**：仅包含通过操作生成的自然数元素，符合初始模型的定义。

**结论**：
- 该模型展示了如何使用FD图式构造标准自然数集合，并确保模型中的元素完全由图式定义的操作生成。

#### 8.1.6 自然数图式的第二个模型（The Second Model: Bounded Natural Numbers with Overflow）

**模型描述**：
- **$ M(n) $**：自然数集合$\{0, 1, 2, \ldots, N\} $，其中$N$是一个固定的上限。
- **$ M(n_{\text{over}}) $**：包含一个元素$\infty $，表示溢出。
- **$ M(\text{zero}) $**：映射为$0 $。
- **$ M(\text{succ}) $**：
  - 对于$i < N $，$ \text{succ}(i) = i + 1 $。
  - 对于$i = N $，$ \text{succ}(i) = \infty $。

**特点**：
- **有限性**：自然数集合被限制在$0$到$N$之间。
- **溢出处理**：达到上限$N$后，后继操作映射到$\infty $。
- **缺少逆运算**：溢出元素$\infty$没有定义逆运算，保持了域的结构。

**结论**：
- 该模型展示了如何在有限离散图式中处理自然数的溢出问题，通过引入溢出元素$\infty $，确保后继操作在达到上限时能够正确映射。

#### 8.1.7 自然数图式的第三个模型（The Third Model: Modular Arithmetic）

**模型描述**：
- **$ M(n) $**：自然数集合$\{0, 1, 2, \ldots, N\} $，与第二个模型相同。
- **$ M(n_{\text{over}}) $**：映射为空集，表示没有溢出元素。
- **$ M(\text{zero}) $**：映射为$0 $。
- **$ M(\text{succ}) $**：
  - 对于$i < N $，$ \text{succ}(i) = i + 1 $。
  - 对于$i = N $，$ \text{succ}(i) = 0 $（即模$N + 1$的运算）。

**特点**：
- **循环性**：后继操作在达到上限$N$后，重新回到$0 $，形成环状结构。
- **模运算**：该模型对应于模$N + 1$的自然数环$(\mathbb{Z}/(N+1)\mathbb{Z}, +) $。

**结论**：
- 该模型展示了通过FD图式构造循环结构，即模运算的自然数集合，强调了FD图式在描述不同代数结构中的灵活性。

### 8.1.8 有限状态机的图式描述（Sketching Finite State Machines）

**示例：有限状态机的图式（FD Sketch for Finite State Machines）**

有限状态机（Finite State Machine, FSM）是一种用于描述计算过程的模型，广泛应用于编程语言、自动机理论等领域。我们将通过构造一个FD图式来形式化描述有限状态机。

**状态机的定义**：
一个有限状态机$M$可以表示为一个四元组：
$$
M = (A, S, \phi, Y)
$$
其中：
- **$ A $**：字母表（Alphabet），固定不变。
- **$ S $**：状态集合（States）。
- **$ \phi : A \times S \to S $**：转移函数（Transition Function），描述在输入符号$a$下从状态$s$转移到状态$\phi(a, s) $。
- **$ Y \subseteq S $**：接受状态集合（Accepting States）。

**图式$S_{\text{FSM}}$的组成**：

1. **节点（Objects）**：
   - **$ S $**：状态集合。
   - **$ Y $**：接受状态集合。
   - **$ N $**：非接受状态集合。

2. **箭头（Arrows）**：
   - **转移箭头**：
     - 对于字母表$A$中的每个符号$a \in A $，存在一个箭头$\phi_a : S \to S $，表示在输入$a$下的状态转移。
   - **接受状态注入箭头**：
     -$\text{in}_Y : Y \to S $（接受状态到状态集合的注入）。
   - **非接受状态注入箭头**：
     -$\text{in}_N : N \to S $（非接受状态到状态集合的注入）。

3. **锥和余锥（Cones and Cocones）**：
   - **无锥**：该图式中没有极限锥。
   - **和余锥**：
    $$
     Y + N \xrightarrow{\text{in}_Y} S
    $$
    $$
     Y + N \xrightarrow{\text{in}_N} S
    $$
     这表示状态集合$S$是接受状态$Y$和非接受状态$N$的和，即$S = Y + N $。

**模型解释**：
- **集合范畴中的模型**$M $：
  - **$ M(S) = S $**：状态集合。
  - **$ M(Y) = Y $**：接受状态集合。
  - **$ M(N) = N $**：非接受状态集合。
  - **$ M(\phi_a) : S \to S $**：具体的转移函数。
  - **$ M(\text{in}_Y) $** 和 **$ M(\text{in}_N) $**：接受状态和非接受状态的注入映射。

**初始模型与终态模型**：
- **初始模型**：
  - 具有空状态集合的模型，通常不具实际意义。
- **终态模型（Final Algebra）**：
  - 状态集合$S$包含所有可能的语言（子集$A^*$的语言）。
  - **$ M(\phi_a) $**：将语言$L$映射为$a^{-1}L = \{ w \in A^* \mid aw \in L \} $。
  - **接受状态集合$Y $**：包含所有包含空字符串的语言。
  - **终态模型的映射**：
    - 将一个状态映射为其对应的语言，即所有能够从该状态接受的字符串集合。

**特点**：
- **初始模型**：通常包含无法通过操作生成的状态，不具实际应用价值。
- **终态模型**：对应于语言的描述，强调有限状态机与语言理论之间的联系。

**结论**：
- 通过构造有限离散图式，可以形式化描述有限状态机及其相关性质，进一步应用于自动机理论和编程语言的语义分析。

### 8.1.9 练习题（Exercises 8.1.9）

**练习1**：

**题目**：
构造一个FD图式，其唯一的模型是两元素布尔代数。

**解析**：

**目标**：
- 构造一个FD图式$S_{\text{Bool}} $，使得在集合范畴$\text{Set}$中，$ S_{\text{Bool}}$的唯一模型是两元素布尔代数。

**步骤**：

1. **布尔代数的定义回顾**：
   - **元素**：$ \{0, 1\} $。
   - **运算**：
     - **与（AND）**：$ \land : \{0,1\} \times \{0,1\} \to \{0,1\} $。
     - **或（OR）**：$ \lor : \{0,1\} \times \{0,1\} \to \{0,1\} $。
     - **非（NOT）**：$ \neg : \{0,1\} \to \{0,1\} $。
   - **公理**：满足布尔代数的基本公理，如交换律、结合律、分配律、双重否定等。

2. **图式构造**：
   - **节点（Objects）**：
     -$1 $：终对象。
     -$B $：布尔代数的载体对象。
     -$B \times B $：二元运算的积对象。
   - **箭头（Arrows）**：
     - **常量箭头**：
       -$0 : 1 \to B $（布尔代数的零元素）。
       -$1 : 1 \to B $（布尔代数的单位元素）。
     - **运算箭头**：
       -$\land : B \times B \to B $（与运算）。
       -$\lor : B \times B \to B $（或运算）。
       -$\neg : B \to B $（非运算）。
   - **锥和余锥**：
     - **积锥**：
       -$B \times B \xrightarrow{\land} B$和$B \times B \xrightarrow{\lor} B $，定义了与运算和或运算的积结构。
     - **余锥**：
       - 无需显式定义，因为非运算是单一箭头。

3. **图式约束**：
   - 定义布尔代数的公理，如交换律、结合律、分配律、双重否定等，通过图式中的图式约束$D$和锥、余锥$L $、$ K$来实现。
   - 例如，交换律可以表示为两条不同路径（$ \land \circ \text{swap}$和$\land $）在图式约束中需相等。

4. **唯一模型验证**：
   - 在$\text{Set}$中，唯一满足这些公理的模型是两元素布尔代数$\{0,1\} $，因为任何其他集合无法满足所有布尔代数的公理，或者会包含多余的元素。

**结论**：
- 通过构造包含常量、运算箭头以及相应公理的FD图式$S_{\text{Bool}} $，确保其在$\text{Set}$中的唯一模型是两元素布尔代数。

**练习2**：

**题目**：
给出一个图式的例子，该图式在$\text{Set}$中没有模型。（提示：在$\text{Set}$中，$ 1 + 1 \neq \{0,1\} $）

**解析**：

**目标**：
- 构造一个FD图式$S $，使得在集合范畴$\text{Set}$中，没有任何模型满足$S$的所有约束。

**提示分析**：
- 提示中提到$1 + 1 \neq \{0,1\} $，暗示图式中对和（sum）的定义与集合中的并集不一致，导致无法在$\text{Set}$中找到符合要求的模型。

**构造方法**：

1. **节点（Objects）**：
   -$1 $：终对象。
   -$A $：某个对象。
   -$B $：另一个对象。

2. **箭头（Arrows）**：
   -$f : 1 \to A $。
   -$g : 1 \to B $。

3. **余锥（Cocones）**：
   - 定义一个和余锥$C $：
    $$
     1 + 1 \xrightarrow{\text{inl}} A
    $$
    $$
     1 + 1 \xrightarrow{\text{inr}} B
    $$
     其中$1 + 1$表示和（sum）对象。

4. **图式约束（Diagram Constraints）**：
   - 假设$S$要求$A = B$且$f \neq g $，即两个不同的常量映射到同一个对象。

**验证**：

- 在集合范畴$\text{Set}$中，如果$A = B $，则和$1 + 1$应该对应于$A$的二元并集，即$A \times \{0,1\} $。
- 但如果$A = B $，且$f$和$g$是不同的常量映射，那么$1 + 1$必须能够同时映射到$A$的两个不同部分，这在$\text{Set}$中是不可能的，因为$A + A$等同于$A \times \{0,1\} $，而$A$无法同时包含两个不同的拷贝。

**结论**：
- 因此，这样的图式$S$在$\text{Set}$中没有模型，因为无法同时满足$A = B$和$f \neq g$的约束。

### 8.1.10 自由代数与初始代数（Term Algebras and Initial Algebras）

**术语代数（Term Algebras）**是初始代数的一种具体表现形式，其中代数中的元素由术语（terms）生成。这些术语通过图式中定义的操作和常量递归生成，确保模型中的元素完全由图式规定的方式生成。

**构造方法**：

1. **基础术语**：
   - 包含图式中的所有常量元素。

2. **递归生成术语**：
   - 对于每个运算符（积和和），递归地生成新的术语。
   - 例如，给定两个术语$t$和$u $，积运算$t \times u$和和运算$t + u$生成新的术语。

3. **约束处理**：
   - 通过图式中的约束（如结合律、交换律等），识别并合并等价的术语。

4. **唯一性维护**：
   - 确保每个术语在术语代数中是唯一的，避免重复或矛盾。

**示例：自然数溢出图式的术语代数**

考虑自然数溢出的图式$S_{\text{NatOverflow}} $，其术语代数包含以下元素：

- **常量**：$ \text{zero} $。
- **操作符**：$ \text{succ} $。

**生成的术语**：
-$\text{zero} $（表示 0）。
-$\text{succ}(\text{zero}) $（表示 1）。
-$\text{succ}(\text{succ}(\text{zero})) $（表示 2）。
- $\ldots$

**溢出处理**：
- 当达到上限$N$时，术语$\text{succ}(N)$被定义为$\infty $。

**初始代数的性质**：
- 包含所有通过操作生成的自然数及其溢出元素。
- 满足自然数的所有公理及溢出行为。

**结论**：
- 术语代数确保初始代数中仅包含由图式强制生成的元素，保持模型的纯粹性和一致性。

### 本节总结

**有限离散图式（FD sketches）**通过同时引入积和和，扩展了图式的表达能力，使其能够描述更复杂的数据类型和代数结构。以下是本节的主要要点总结：

1. **FD图式的定义**：
   - 包含有限图、有限图式约束、有限离散锥和有限离散余锥。
   - 模型在$\text{Set}$中通过图同态定义，满足积和的结构性约束。

2. **具体示例**：
   - **列表的图式**：描述了如何通过积和和定义空列表和非空列表，避免操作未定义的问题。
   - **自然数溢出图式**：展示了如何通过FD图式处理自然数的溢出问题，构造不同的模型以反映不同的运算行为。
   - **有限状态机的图式**：形式化描述有限状态机，连接自动机理论与图式方法。

3. **术语代数与初始代数**：
   - 术语代数通过递归生成术语，确保模型中仅包含由图式强制生成的元素。
   - 初始代数作为术语代数的一种实现，具有唯一性和普遍性，确保模型的纯粹性。

4. **模型多样性**：
   - FD图式允许存在多个模型，其中初始术语模型是唯一不包含“垃圾”元素的模型。
   - 其他模型可能包含通过操作无法生成的元素，但这些模型通常被视为“不纯粹”的。

5. **练习题的应用**：
   - 通过练习题，进一步理解FD图式的构造方法和模型性质，如如何构造特定代数结构的图式，以及如何识别无模型的图式。

**应用与扩展**：
- **编程语言理论**：通过FD图式形式化描述复杂的数据类型和语言特性，支持类型系统和语义分析。
- **自动机理论**：利用FD图式描述有限状态机及其行为，连接理论与实际应用。
- **代数结构研究**：通过FD图式描述各种代数结构，如布尔代数、环、域等，促进对这些结构性质的深入理解和研究。

通过掌握FD图式及其初始代数的构造方法，读者能够灵活地描述和分析各种复杂的代数结构，并在范畴论的框架下理解其内在关系和性质，为后续章节中更复杂的图式和范畴理论研究奠定坚实的理论基础。

### ----------------------------

好的，让我们继续详细解析**第8章：有限离散图式（Finite Discrete Sketches）**中的**8.2节：域的图式（The Sketch for Fields）**。本节通过构造一个有限离散图式来描述数学结构中的域（field），并探讨其模型在集合范畴中的具体表现。

## 8.2 域的图式描述（The Sketch for Fields）

有限离散图式（FD sketches）允许我们通过同时使用积（products）和和（sums）来描述复杂的代数结构，如域（field）。域是一个抽象化的数学结构，捕捉了数的算术性质。本节将详细描述如何构造一个用于定义域的FD图式，并探讨其在集合范畴中的模型。

### 8.2.1 域的模型示例（An Example of a Field）

**示例1：有理数集合作为域的模型**

考虑有理数集合$\mathbb{Q} $，它是一个标准的域。在图式$S_{\text{Field}}$的模型$M$中：

- **$ M(0)$和$M(1) $**：
  -$M(0)$映射到标准的零元素$0 $。
  -$M(1)$映射到标准的单位元素$1 $。
  
- **$ M(f)$和$M(u) $**：
  -$M(f)$映射到整个有理数集合$\mathbb{Q} $。
  -$M(u)$映射到非零有理数集合$\mathbb{Q} \setminus \{0\} $。
  
- **$ M(j) $**：
  -$M(j)$是包含映射，将非零有理数自然地嵌入有理数集合中，即$j: \mathbb{Q} \setminus \{0\} \hookrightarrow \mathbb{Q} $。

- **运算操作**：
  - 加法$+$和乘法$\ast$定义为标准的有理数加法和乘法。
  - 加法的逆元$-$对应于标准的有理数加法逆元。
  - 乘法的逆元$()^{-1}$对应于标准的有理数乘法逆元。

**其他熟悉的示例**：

- **实数集合$\mathbb{R} $** 和 **复数集合$\mathbb{C} $** 也可以作为图式$S_{\text{Field}}$的模型，运算定义与标准的实数和复数运算一致。

### 8.2.2 构建域的模型（Building a Model of the Sketch）

在构造域的模型时，我们需要按照图式$S_{\text{Field}}$的定义，从零和一开始，通过加法和乘法运算不断生成新的元素。以下是具体的构造过程和不同模型的示例：

**构造过程**：

1. **基础元素**：
   - **零元素$0 $**：通过常量箭头$0 : 1 \to f$获得。
   - **单位元素$1 $**：通过常量箭头$1 : 1 \to u$获得。

2. **生成新元素**：
   - **加法运算**$+ : f \times f \to f $：通过将两个元素相加生成新元素。例如，$ 0 + 1 = 1 $，$ 1 + 1 = 2$等。
   - **乘法运算**$\ast : f \times f \to f $：通过将两个元素相乘生成新元素。例如，$ 1 \ast 1 = 1 $，$ 1 \ast 2 = 2$等。
   - **加法逆元**$- : f \to f $：为每个元素生成其加法逆元。例如，$ -1$是$1$的加法逆元，因为$1 + (-1) = 0 $。
   - **乘法逆元**$()^{-1} : u \to u $：为每个非零元素生成其乘法逆元。例如，$ 1^{-1} = 1 $，$ 2^{-1} = \frac{1}{2}$等。

3. **构造示例模型**：

   - **有限域**：
     - **二元域$\mathbb{F}_2 $**：
       - 元素：$ \{0, 1\} $。
       - 加法和乘法定义为模 2 运算：
        $$
         + : \begin{array}{c|cc}
         + & 0 & 1 \\
         \hline
         0 & 0 & 1 \\
         1 & 1 & 0 \\
         \end{array}
         \quad
         \ast : \begin{array}{c|cc}
         \ast & 0 & 1 \\
         \hline
         0 & 0 & 0 \\
         1 & 0 & 1 \\
         \end{array}
        $$
       -$M(u) = \{1\} $，$ M(j)$是$\{1\}$到$\mathbb{F}_2$的包含映射。
       - 这是一个满足域所有公理的有限模型。

   - **有限域的扩展**：
     - 可以构造其他有限域，如$\mathbb{F}_3 $，其中$1 + 1 = 2 $，$ 1 + 2 = 0 $，$ 2 + 2 = 1 $，乘法同理。

   - **无穷域**：
     - **有理数集合$\mathbb{Q} $**、**实数集合$\mathbb{R} $**、**复数集合$\mathbb{C} $** 等都是无限域的典型模型。

**注意事项**：

- **零和单位元的唯一性**：在任何模型中，零元素$M(0)$和单位元素$M(1)$是唯一的。
- **运算的封闭性**：加法和乘法运算必须在集合内部封闭，即运算结果仍在集合中。
- **逆元的存在性**：每个元素在加法和乘法下都有逆元（非零元素在乘法下有逆元）。

### 8.2.3 域同态的性质（Properties of Field Homomorphisms）

**定义**：

一个**域同态（Field Homomorphism）**是保持域结构的映射，即：

- **加法同态**：$ h(a + b) = h(a) + h(b) $。
- **乘法同态**：$ h(a \ast b) = h(a) \ast h(b) $。
- **单位元映射**：$ h(1) = 1 $。
- **零元映射**：$ h(0) = 0 $。

**性质分析**：

1. **单射性（Injectivity）**：
   - 由于域同态$h$保持乘法逆元，即$h(a^{-1}) = h(a)^{-1} $（对于$a \neq 0 $），如果$h(a) = h(b) $，则$h(a - b) = h(a) - h(b) = 0 $。
   - 因此，$ a - b = 0 $，即$a = b $，从而$h$是单射。

2. **无同态存在两个不同模型之间的映射**：
   - 例如，存在一个域同态将$\mathbb{F}_2$映射到$\mathbb{Q}$是不可能的，因为$\mathbb{F}_2$中$1 + 1 = 0 $，而在$\mathbb{Q}$中$1 + 1 = 2 \neq 0 $。
   - 这意味着域同态必须保持加法和乘法的结构，不能引入额外的等式关系。

3. **类别理论中的影响**：
   - 由于域同态是单射，域同态之间的复合仍然是单射，这导致域的范畴（即对象为域，态射为域同态）中的态射同构只能是恒等映射。
   - 因此，域的范畴中不具备终对象，也不具备积。

**结论**：

- **域同态是单射**，这意味着两个不同的域在同一个范畴中无法通过同态映射到同一个域。
- **范畴结构**：由于不存在终对象和积，域的范畴在结构上较为复杂，无法直接应用积和和的范畴论工具。

### 8.2.4 练习题（Exercises 8.2.4）

**练习1**：

**题目**：

证明在一个域中，如果两个元素各自有乘法逆元，那么它们的积也有乘法逆元。由此推断如果$4 = 0 $，则$2 = 0 $。

**解析**：

**目标**：

1. 证明在域中，如果$a$和$b$都有乘法逆元，则$a \ast b$也有乘法逆元。
2. 推导出如果$4 = 0 $，则$2 = 0 $。

**步骤**：

1. **积的逆元存在性**：
   - 设$a$和$b$都是域中的非零元素，即$a, b \in u $，其中$u = f \setminus \{0\} $。
   - 因为$a$和$b$有乘法逆元，即存在$a^{-1}$和$b^{-1}$满足$a \ast a^{-1} = 1$和$b \ast b^{-1} = 1 $。
   - 计算$(a \ast b)^{-1} $：
    $$
     (a \ast b)^{-1} = b^{-1} \ast a^{-1}
    $$
     因为：
    $$
     (a \ast b) \ast (b^{-1} \ast a^{-1}) = a \ast (b \ast b^{-1}) \ast a^{-1} = a \ast 1 \ast a^{-1} = a \ast a^{-1} = 1
    $$
   - 因此，$ a \ast b$也有乘法逆元，即$a \ast b \in u $。

2. **推导$4 = 0$时$2 = 0 $**：
   - 在域中，定义$2 = 1 + 1 $，$ 4 = 2 + 2 $。
   - 假设$4 = 0 $：
    $$
     4 = 2 + 2 = 0
    $$
   - 在域中，每个非零元素都有乘法逆元。假设$2 \neq 0 $，则$2$有乘法逆元$2^{-1} $，使得：
    $$
     2 \ast 2^{-1} = 1
    $$
   - 但是，$ 4 = 0 $：
    $$
     4 \ast 2^{-1} = 0 \ast 2^{-1} = 0
    $$
     同时：
    $$
     4 \ast 2^{-1} = (2 + 2) \ast 2^{-1} = 2 \ast 2^{-1} + 2 \ast 2^{-1} = 1 + 1 = 2
    $$
   - 因此：
    $$
     0 = 2
    $$
   - 这与假设$2 \neq 0$矛盾，因此必须有$2 = 0 $。

**结论**：

在一个域中，如果两个元素各自有乘法逆元，那么它们的积也有乘法逆元。此外，如果在域中$4 = 0 $，则必然有$2 = 0 $。

**练习2**：

**题目**：

证明第8.2.3节的倒数第二句话，即“域的范畴中不存在积”，暗示了域的范畴不具有积（products）。

**解析**：

**目标**：

证明在域的范畴中不存在积，即没有一个对象能够作为两个域的积，满足积的定义。

**步骤**：

1. **积的定义**：

   在范畴论中，对象$P$被称为对象$A$和$B$的积，如果存在投影态射$\pi_1: P \to A$和$\pi_2: P \to B $，满足以下通用性条件：对于任何对象$Q$和态射$f: Q \to A $、$ g: Q \to B $，存在唯一态射$\langle f, g \rangle : Q \to P $，使得$\pi_1 \circ \langle f, g \rangle = f$和$\pi_2 \circ \langle f, g \rangle = g $。

2. **域范畴中积的不存在性**：

   - 假设域$A$和域$B$在域的范畴中存在积$P $。
   - 根据积的定义，存在投影态射$\pi_A: P \to A$和$\pi_B: P \to B $。
   - 对于任何域$Q$和态射$f: Q \to A $、$ g: Q \to B $，存在唯一态射$\langle f, g \rangle : Q \to P $。

3. **矛盾的构造**：

   - 选择$Q = A $，$ f = \text{id}_A $，$ g$为一个同态$g: A \to B $。
   - 根据积的定义，存在唯一态射$\langle \text{id}_A, g \rangle : A \to P $。
   - 由于域同态必须保持运算和结构，假设$P$也是一个域。
   - 由于域同态是单射，$ \langle \text{id}_A, g \rangle$必须是单射。
   
4. **具体反例**：

   - 假设$A = B = \mathbb{F}_2 $（二元域），则积$P$应满足$P = \mathbb{F}_2 \times \mathbb{F}_2 $。
   -$P$必须是一个域，但$\mathbb{F}_2 \times \mathbb{F}_2$不是一个域，因为它不是一个整环（存在零因子，例如$(1,0) \ast (0,1) = (0,0) $）。
   - 因此，假设$P$是积导致矛盾，因为$P$无法满足域的定义。

5. **推广到任意域**：

   - 对于任意两个非零域$A$和$B $，其积对象$P = A \times B$无法成为一个域，因为积的结构通常不是一个整环，无法满足域的乘法逆元要求。
   - 因此，域的范畴中不存在积。

**结论**：

通过构造反例，我们证明了域的范畴中不存在积。这意味着在域的范畴中，无法找到一个对象同时满足两个域的积定义，从而域的范畴不具备积结构。

### 本节总结

**域的图式（The Sketch for Fields）**通过定义零元、单位元、加法和乘法运算，以及相关的逆元和分配律等公理，形式化地描述了域的代数结构。通过构造不同的模型，我们可以理解域的各种性质及其在集合范畴中的表现。同时，分析域同态的性质进一步揭示了域的范畴结构的复杂性，特别是积的不存在性。

**主要要点总结**：

1. **FD图式的构造**：
   - 节点和箭头的定义捕捉了域的基本元素和运算。
   - 图式约束确保模型满足域的所有公理。

2. **域的模型示例**：
   - 标准的有理数、实数、复数集合作为无限域的模型。
   - 有限域（如二元域）的构造展示了图式在有限结构中的应用。

3. **域同态的性质**：
   - 域同态是单射，保持运算和逆元。
   - 域的范畴中不存在积，限制了范畴论工具在域研究中的应用。

4. **练习题的应用**：
   - 通过练习题巩固了对域图式构造和同态性质的理解。
   - 验证了域的范畴结构及其在范畴论中的特殊性。

通过掌握域的图式构造和模型分析，读者能够深入理解FD图式在描述复杂代数结构中的应用，为后续章节中更复杂的有限离散图式和范畴理论研究奠定坚实的基础。

### ---------------------------

好的，让我们继续详细解析**第8章：有限离散图式（Finite Discrete Sketches）**中的**8.3节：有限离散图式的术语代数（Term Algebras for FD Sketches）**。本节讨论了如何将初始术语代数的构造方法扩展到有限离散图式（FD sketches），并引入了**dæmons**这一概念来处理在和余锥（sum cocones）中进行选择的问题。

## 8.3 有限离散图式的术语代数（Term Algebras for FD Sketches）

在有限积图式中，初始术语代数的构造相对直接，通过递归地应用运算和常量生成所有必要的元素。然而，当我们扩展到有限离散图式时，情况变得复杂，因为除了积（products）外，我们还需要处理和（sums）。具体来说，当一个操作的结果位于一个和余锥的顶点时，我们必须选择结果属于哪一个分支（summand），这引入了选择的自由度，可能导致不同的术语代数模型。

### 8.3.1 Dæmons（Dæmons）

**问题**：

在FD图式中，操作的结果需要选择其位于和余锥的哪个分支，这种选择是如何进行的？没有系统的方法来自动决定这些选择，因此需要一种机制来管理这些选择的过程。

**解决方案**：

引入**dæmon**（Dæmon）这一概念，类似于麦克斯韦妖（Maxwell's Demon）在物理学中的作用，dæmon负责在构造术语代数时为每个操作的结果选择其所属的分支。具体来说，dæmon会为每一个生成的术语字符串指定一个分支编号，决定该术语应该位于哪个分支。

### 8.3.2 定义（Definition）

**定义**：

设$S$是一个FD图式，且$\kappa$是图式中任意余锥基底中节点数量的上限。一个**dæmon**$D$是一个函数：

$$
D : \text{AS}^* \to \{1, 2, \ldots, \kappa\}
$$

其中，$ \text{AS}^*$是图式$S$的基础有限积图式（FP sketch）的字母表上的所有字符串集合（参见第7.6.5节）。换句话说，dæmon 忽略了和余锥，仅基于积图式的运算进行选择。

**作用**：

在构造初始术语代数时，当需要将一个操作的结果放入和余锥的某个分支时，dæmon 根据生成的术语字符串$w$返回一个分支编号$D(w) $，决定将$w$放入哪一个分支。如果$D(w)$超过了余锥分支的数量$k(b) $，则构造过程会中止。

### 8.3.3 初始术语代数的构造（Construction of Initial Term Models for FD Sketches）

**步骤**：

1. **确定和余锥的分支编号**：
   - 对于每个余锥顶点$b $，将其分支编号为$b_1, b_2, \ldots, b_k $，其中$k \leq \kappa$是余锥的分支数量。
   - 如果$b$不是任何余锥的顶点，则令$k(b) = 1 $，且$b_1 = b $，$ u_1 = \text{id}_b $。

2. **定义同余关系$\sim $**：
   - 对术语字符串进行同余关系的定义，确保相同的术语字符串在结构上等价。

3. **应用构造规则（FD–1 至 FD–7）**：
   - **FD–1**：如果$u_i : a_i \to a$是某个余锥的包含映射，且$[x] \in I(a_i) $，则$[u_i x] \in I(a)$且$I(u_i)[x] = [u_i x] $。
   - **FD–2**：对于任意操作$f : a \to b$以及元素$[x] \in I(a) $，根据 dæmon 的选择$j = D(fx) $，将$[fx]$放入$I(b_j) $。
   - **FD–3**：对于锥中的操作$C(x_1, \ldots, x_n) $，根据 dæmon 的选择$j = D(C(x_1, \ldots, x_n)) $，将其放入$I(q_j) $。
   - **FD–4**：如果$[x_i] = [y_i]$对所有$i $，则$[C(x_1, \ldots, x_n)] = [C(y_1, \ldots, y_n)] $。
   - **FD–5**：投影态射$\pi_i$作用于锥元素时，返回对应的分量。
   - **FD–6**：确保每个元素可以通过锥的投影态射还原到其分量。
   - **FD–7**：对于图式中的等式约束，确保对应的元素在模型中也满足相同的等式。

**结果**：

如果在构造过程中没有遇到$D(w) > k(b)$的情况，则构造出的模型$I$是一个术语代数，且是$S$的初始模型的一个部分。否则，构造过程会中止，表示该 dæmon 不适用于构造初始模型。

### 8.3.4 初始模型的性质（Proposition）

**命题**：

对于每一个不导致构造过程中止的 dæmon，构造过程会递归定义一个模型$I$满足图式$S $。每个这样的模型是$S$的模型范畴中某个连通分量的初始模型。此外，对于每个连通分量，都存在一个 dæmon 生成其初始模型。

**说明**：

- **连通分量**：模型范畴中的连通分量是指在该范畴中，任意两个模型之间存在态射路径的子范畴。
- **初始模型**：每个连通分量都有一个初始模型，作为该分量中的初始对象。

**构造思路**：

给定一个模型$M $，对于其每个元素字符串$w $，如果它在某个模型中对应于一个元素，那么定义$D(w)$为该元素所属的分支编号。对于未使用的字符串，默认$D(w) = 1 $。

### 8.3.5 混淆与“垃圾”（Confusion maybe, junk no）

**口号**：

- “无垃圾，无混淆”（No junk, no confusion）

**解释**：

- **无垃圾**：每个元素都是通过图式中的操作和常量生成的，没有多余的、无法到达的元素。
- **无混淆**：元素之间的等式关系仅由图式中的公理强制，避免了额外的、未定义的等式关系。

**注意**：

在FD图式的初始模型中，某些模型可能存在混淆（confusion），即元素之间存在未被图式强制的等式关系，而其他模型则可能没有混淆。这意味着即使某些模型没有“垃圾”元素，它们仍然可能因为混淆而不符合“无混淆”的要求。

### 8.3.6 例子：自然数溢出图式（Example: Natural Numbers with Overflow）

**示例**：

考虑自然数溢出图式，构造不同的初始模型：

1. **标准自然数模型**（无溢出）：
   - **$ M(n) = \mathbb{N} $**：自然数集合。
   - **$ M(n_{\text{over}}) = \emptyset $**：没有溢出元素。
   - **运算**：$ \text{zero} = 0 $，$ \text{succ}(i) = i + 1 $。
   
   **特点**：
   - 无溢出，符合标准自然数的定义。
   - 无混淆，因为每个元素的生成路径唯一。
   
2. **有限自然数模型**（带溢出）：
   - **$ M(n) = \{0, 1, 2, \ldots, N\} $**：自然数集合，有限。
   - **$ M(n_{\text{over}}) = \{\infty\} $**：一个溢出元素。
   - **运算**：
     -$\text{zero} = 0 $
     -$\text{succ}(i) = i + 1 $（对于$i < N $）
     -$\text{succ}(N) = \infty $
   
   **特点**：
   - 有限集合，处理溢出问题。
   - 存在混淆，因为$\text{succ}(N) = \infty$引入了额外的等式关系。

3. **模运算自然数模型**（循环自然数）：
   - **$ M(n) = \{0, 1, 2, \ldots, N\} $**：自然数集合，有限。
   - **$ M(n_{\text{over}}) = \emptyset $**：没有溢出元素。
   - **运算**：
     -$\text{zero} = 0 $
     -$\text{succ}(i) = i + 1 $（对于$i < N $）
     -$\text{succ}(N) = 0 $（循环回到 0）
   
   **特点**：
   - 循环结构，对应于模$N + 1$的运算。
   - 无混淆，因为每个元素通过唯一的生成路径定义。

**结论**：

不同的初始模型通过选择不同的溢出处理方式，展示了FD图式的灵活性。这些模型可能具有不同的混淆性质，影响其作为初始模型的角色。

### 8.3.7 练习题（Exercises 8.3.7）

**练习1**：

**题目**：

1. †
   a. 证明如果$S$是一个FD图式，且$f : M \to N$是集合范畴中两个模型之间的同态（homomorphism），那么$f$的像（image）是$N$的一个子模型。
   
   b. 证明在集合范畴中，任意FD图式的模型都有一个最小的子模型。

**解析**：

**部分a**：

**目标**：

证明对于任意FD图式$S $，若$f : M \to N$是$S$在集合范畴中的两个模型$M$和$N$之间的同态，那么$f$的像$\text{Im}(f)$是$N$的一个子模型。

**步骤**：

1. **定义子模型**：

   子模型$\text{Im}(f)$是指对于$S$的模型$N $，其节点$\text{Im}(f)(a) = f(a)(M(a)) $，即$M(a)$通过$f$映射到$N(a)$的像。

2. **验证子模型的结构**：

   - **保留运算和常量**：
     - 对于图式中的每个常量箭头$c : 1 \to a $，$ f(c) = c $，因此$\text{Im}(f)(c) = c$在子模型中也成立。
     - 对于每个运算箭头$f : a \to b $，由于$f$是同态，有$f_b \circ (f_M) = f_N \circ f $，即$\text{Im}(f)$保持运算的封闭性和一致性。

   - **保留锥和余锥**：
     - 由于$f$保持积锥和和余锥的结构，子模型$\text{Im}(f)$中的积和和仍然满足图式的定义。

3. **结论**：

   因此，$ f$的像$\text{Im}(f)$满足$S$的所有定义要求，是$N$的一个子模型。

**部分b**：

**目标**：

证明在集合范畴中，任意FD图式$S$的模型都有一个最小的子模型。

**步骤**：

1. **定义最小子模型**：

   最小子模型$\text{Min}(M)$是$M$的所有子模型的交集，确保其包含$M$中所有通过图式操作生成的最小元素集。

2. **证明存在性**：

   - 考虑所有$M$的子模型的集合，定义其交集为$\text{Min}(M) $。
   - 由于$S$是有限离散图式，且所有运算和常量都是有限的，这保证了$\text{Min}(M)$也是一个模型。

3. **验证最小性**：

   - 对于任意子模型$N$的元素，若$x \in N(a) $，则$x$必须通过$S$的运算和常量生成，因此$x \in \text{Min}(M)(a) $。
   - 因此，$ \text{Min}(M)$是$M$的一个最小子模型。

4. **结论**：

   每个模型$M$都存在一个最小子模型$\text{Min}(M) $，满足任意其他子模型都包含$\text{Min}(M) $。

**总结**：

通过部分a和部分b的证明，我们证明了FD图式在集合范畴中的模型具有良好的结构性质，即同态的像是子模型，并且每个模型都有一个最小的子模型。这些性质对于理解初始模型和构造术语代数具有重要意义。

### 8.3.8 二叉树的图式描述（Binary Trees Sketch）

**示例**：

构造一个有限离散图式来描述**有序根二叉树（ordered rooted binary trees）**。在这种树中，每个节点要么没有子节点，要么有两个子节点，且左子节点和右子节点是有序的。

**图式$S_{\text{BinaryTree}}$的组成**：

1. **节点（Objects）**：
   - **$ 1 $**：表示空树。
   - **$ t $**：表示树。
   - **$ s $**：表示非空树。
   - **$ d $**：表示存储在树节点的数据。

2. **箭头（Arrows）**：
   - **空树操作**：
     -$\text{empty} : 1 \to t $：生成空树。
   - **包含非空树的注入操作**：
     -$\text{incl} : s \to t $：将非空树包含到树集合中。
   - **数据提取操作**：
     -$\text{val} : s \to d $：提取非空树根节点的数据。
   - **左右子节点操作**：
     -$\text{left} : s \to t $：提取非空树的左子树。
     -$\text{right} : s \to t $：提取非空树的右子树。

3. **锥和余锥（Cones and Cocones）**：
   - **锥（Cone）**：
    $$
     \begin{array}{ccc}
     t & \xrightarrow{\text{left}} & t \\
     t & \xrightarrow{\text{val}} & d \\
     t & \xrightarrow{\text{right}} & t \\
     \end{array}
    $$
     这表示每个非空树$s$可以唯一表示为一个三元组$(\text{left}(s), \text{val}(s), \text{right}(s)) $。
   
   - **余锥（Cocone）**：
    $$
     \begin{array}{cc}
     1 & \xrightarrow{\text{empty}} & t \\
     s & \xrightarrow{\text{incl}} & t \\
     \end{array}
    $$
     这表示每个树要么是空树（通过$\text{empty} $），要么是非空树（通过$\text{incl} $）。

**模型解释**：

- **集合范畴中的模型**$M $：
  - **$ M(1) $**：包含一个元素，表示空树。
  - **$ M(t) $**：表示所有有序根二叉树的集合。
  - **$ M(s) $**：表示所有非空有序根二叉树的集合。
  - **$ M(d) $**：表示存储在树节点的数据类型。
  - **操作**：
    - **$ M(\text{empty}) $**：映射为空树。
    - **$ M(\text{incl}) $**：将非空树包含到树集合中。
    - **$ M(\text{val}) $**、**$ M(\text{left}) $**、**$ M(\text{right}) $**：提取非空树的相应部分。

**子操作的定义**：

通过模型中的投影态射，可以定义诸如**左附加操作（left attachment）**和**右附加操作（right attachment）**，以及在根节点插入数据的操作。例如：

- **左附加操作**$\text{lat} : t \times s \to s $：
 $$
  \text{lat}(T, (L, D, R)) = (T, D, R)
 $$
  这表示将一个树$T$附加到非空树的左子树位置。

**结论**：

通过构造有限离散图式$S_{\text{BinaryTree}} $，我们能够形式化描述有序根二叉树的结构及其操作。这种图式不仅捕捉了树的基本组成部分，还允许定义额外的操作，如树的附加和插入数据，从而为进一步的代数结构分析提供了坚实的基础。

### 8.3.9 例子：没有通用初始模型的图式（Example: Sketch with No Generic Model）

**示例**：

构造一个简单的图式，其在集合范畴中没有通用的初始模型。这表明某些图式的结构要求导致无法存在一个满足所有约束的通用模型。

**图式描述**：

1. **节点（Objects）**：
   - **$ a $**：由$b + c$定义。
   - **$ b $** 和 **$ c $**：两个不同的节点。
   - **$ d $**：数据类型。
   - **$ 1 $**：终对象。

2. **箭头（Arrows）**：
   - **常量箭头**：
     -$x : d \to d $。
   - **操作箭头**：
     -$s : d \to a $。
   
3. **锥和余锥（Cones and Cocones）**：
   - **和余锥（Cocone）**：
    $$
     \begin{array}{ccc}
     b & \xrightarrow{\text{inl}} & a \\
     c & \xrightarrow{\text{inr}} & a \\
     \end{array}
    $$
     这表示$a = b + c $，即$a$要么是$b $，要么是$c $。
   
4. **图式约束（Diagram Constraints）**：
   - 无额外的图式约束。

**初始模型的构造**：

1. **基础元素**：
   -$\text{zero}$和$\text{one}$分别对应于节点$d$和$1 $。
   
2. **操作应用**：
   -$s(x)$必须属于$a = b + c $，因此必须选择$s(x)$属于$b$或$c $。
   
3. **多种初始模型**：
   - **模型1**：选择$s(x) \in b $。
   - **模型2**：选择$s(x) \in c $。
   
   这导致存在两个不同的初始模型，每个模型中$s(x)$分别位于不同的分支。

**结论**：

由于$s(x)$的选择没有被图式强制约束为特定分支，因此存在多个初始模型，每个模型对应于不同的选择。这表明在某些情况下，FD图式可能没有唯一的通用初始模型。

### 8.3.10 初始场的例子（Example: Initial Fields）

**示例**：

在抽象代数中，已知初始场（Prime Fields）有两类：

1. **有理数场**（$ \mathbb{Q} $）：这是唯一一个特征为0的初始场。
2. **有限域**（$ \mathbb{Z}/p\mathbb{Z} $）：其中$p$是一个素数，每个有限域对应于一个素数$p $。

**性质**：

- **特征**：一个域的特征是最小的正整数$p $，使得$p \cdot 1 = 0 $（即$1 + 1 + \ldots + 1 = 0 $，共$p$次）。如果不存在这样的正整数，则该域的特征为0。
  
- **初始性**：
  - **有理数场**：作为特征为0的初始场，是所有特征为0的域的初始对象。
  - **有限域**：每个素数$p$对应的有限域$\mathbb{Z}/p\mathbb{Z}$是特征为$p$的初始域。

**混淆性质**：

- **混淆**：由于初始场同构于特征为0的有理数场或有限域，每个初始模型属于不同的连通分量。特征为0的初始模型（如有理数场）与特征为素数$p$的初始模型（如有限域）在范畴中没有同态，因而不在同一个连通分量。

**结论**：

通过分析初始场的例子，我们理解到FD图式的初始模型不仅依赖于dæmon的选择，还受到域的特征限制。这进一步说明了FD图式的灵活性和复杂性，特别是在描述具有严格公理的代数结构时。

### 8.3.11 例子：二叉树的初始模型（Example: Binary Trees Initial Algebra）

**示例**：

构造一个描述**有序根二叉树**的图式，并通过初始代数的构造方法得到其初始模型。

**图式描述**：

1. **节点（Objects）**：
   - **$ 1 $**：表示空树。
   - **$ t $**：表示树。
   - **$ s $**：表示非空树。
   - **$ d $**：表示存储在树节点的数据。

2. **箭头（Arrows）**：
   - **常量箭头**：
     -$\text{empty} : 1 \to t $：生成空树。
     -$\text{incl} : s \to t $：将非空树包含到树集合中。
   - **操作箭头**：
     -$\text{val} : s \to d $：提取非空树根节点的数据。
     -$\text{left} : s \to t $：提取非空树的左子树。
     -$\text{right} : s \to t $：提取非空树的右子树。

3. **锥和余锥（Cones and Cocones）**：
   - **锥（Cone）**：
    $$
     \begin{array}{ccc}
     t & \xrightarrow{\text{left}} & t \\
     t & \xrightarrow{\text{val}} & d \\
     t & \xrightarrow{\text{right}} & t \\
     \end{array}
    $$
     这表示每个非空树$s$可以唯一表示为一个三元组$(\text{left}(s), \text{val}(s), \text{right}(s)) $。
   
   - **余锥（Cocone）**：
    $$
     \begin{array}{cc}
     1 & \xrightarrow{\text{empty}} & t \\
     s & \xrightarrow{\text{incl}} & t \\
     \end{array}
    $$
     这表示每个树要么是空树（通过$\text{empty} $），要么是非空树（通过$\text{incl} $）。

**初始模型的构造**：

1. **基础元素**：
   - **空树**：通过常量箭头$\text{empty}$生成。
   
2. **递归构造**：
   - 对于每个非空树$s $，通过操作$\text{val} $、$ \text{left} $、$ \text{right}$生成新的树。
   
3. **构造初始术语代数$I $**：
   - **$ I(s) $**：非空树集合，通过递归应用操作生成。
   - **$ I(t) = I(s) + \{\empty\} $**：树集合，包括所有非空树和空树。
   - **$ I(d) $**：数据类型的初始模型，假设已知（如整数、字符等）。
   
   **具体构造**：
   
   - **空树**：唯一元素$\empty $。
   - **非空树**：通过$\text{incl}$和$\text{val} $、$ \text{left} $、$ \text{right}$生成，如$\text{incl}(s) $，其中$s = (\text{left}(s), \text{val}(s), \text{right}(s)) $。
   
4. **唯一性验证**：

   - 对于任意模型$M $，存在唯一的同态$f : I \to M $，确保初始模型$I$是$S_{\text{BinaryTree}}$的初始模型。
   
   - 通过递归定义$f $，确保所有通过操作生成的树在$I$中唯一对应于$M$中的树。

**结论**：

初始术语代数$I$完整地描述了所有有序根二叉树，且通过唯一的同态映射到任意其他模型中。这验证了FD图式在描述递归数据结构（如二叉树）中的有效性。

### 8.3.12 练习题（Exercises 8.3.12）

**练习1**：

**题目**：

1. †
   a. 证明如果$S$是一个FD图式，且$f : M \to N$是集合范畴中两个模型之间的同态（homomorphism），那么$f$的像（image）是$N$的一个子模型。
   
   b. 证明在集合范畴中，任意FD图式的模型都有一个最小的子模型。

**解析**：

**部分a**：

**目标**：

证明对于任意FD图式$S $，如果$f : M \to N$是$S$在集合范畴中的两个模型$M$和$N$之间的同态，那么$f$的像$\text{Im}(f)$是$N$的一个子模型。

**证明步骤**：

1. **定义子模型**：

   子模型$\text{Im}(f)$是指对于每个节点$a $，有$\text{Im}(f)(a) = f(a)(M(a)) $，即$M(a)$通过同态$f$映射到$N(a)$的像。

2. **验证子模型的结构**：

   - **保留常量和操作**：
     - 对于每个常量箭头$c : 1 \to a $，$ f(c)$将模型$M$中的常量映射到模型$N$中的常量。
     - 对于每个运算箭头$f : a \to b $，同态$f$保证$f_b \circ (f_M) = f_N \circ f $，即$\text{Im}(f)$中的运算保持一致。
   
   - **保留锥和余锥**：
     - 对于每个积锥和和余锥，子模型$\text{Im}(f)$保持积和和的结构，因为同态$f$保证了运算和注入态射的映射一致性。

3. **结论**：

   因此，$ \text{Im}(f)$满足$S$的所有定义要求，是$N$的一个子模型。

**部分b**：

**目标**：

证明在集合范畴中，任意FD图式$S$的模型$M$都存在一个最小的子模型。

**证明步骤**：

1. **定义最小子模型**：

   最小子模型$\text{Min}(M)$是$M$的所有子模型的交集。由于集合范畴是幂集完备的，$ \text{Min}(M)$也是一个子模型。

2. **验证最小子模型的性质**：

   - **包含必要元素**：
     -$\text{Min}(M)$包含通过图式$S$的运算和常量生成的所有元素。
   
   - **最小性**：
     - 对于任意子模型$N$的元素$x \in N(a) $，由于$x$是通过$S$的运算和常量生成的，$ x$必然包含在$\text{Min}(M)(a)$中。
   
   - **唯一性**：
     -$\text{Min}(M)$是唯一的，因为任何两个最小子模型都必须包含相同的生成元素。

3. **结论**：

   每个模型$M$都存在一个最小子模型$\text{Min}(M) $，满足任意其他子模型都包含$\text{Min}(M) $。这确保了FD图式在集合范畴中的模型具有良好的结构性质，便于进一步的代数分析。

### 8.3.13 Pascal中的二叉树定义（Example: Binary Trees in Pascal）

**示例**：

在Pascal等编程语言中，二叉树类型通常通过指针和记录（record）结构来定义。例如：

```pascal
type
  TreePtr = ^Tree;
  Tree = record
    LeftTree, RightTree: TreePtr;
    Datum: Integer;
  end;
```

**解释**：

- **$ TreePtr $**：指向树节点的指针，允许定义空树（通过空指针）。
- **$ Tree $**：记录类型，包含左右子树指针和存储的数据。
  

**关联图式**：

在图式$S_{\text{BinaryTree}}$的视角下，这种定义对应于如下结构：

- **空树**：通过指针为空表示。
- **非空树**：通过记录结构，包含左右子树和数据元素。

**优势**：

- **利用变体记录（Variant Records）**：通过指针和记录的结合，可以在编程语言中实现类似于FD图式中和余锥的结构，使得每个树要么是空的，要么是一个非空树。
- **错误状态处理**：通过空指针和非空树的分离，编程语言能够在运行时处理异常情况，如操作空树时的错误。

**结论**：

这种编程语言中的二叉树定义与FD图式中的图式描述紧密相关，展示了图式方法在实际编程语言设计中的应用。

### 8.3.14 练习题（Exercises 8.3.14）

**练习1**：

**题目**：

1. †
   a. 证明如果$S$是一个FD图式，且$f : M \to N$是集合范畴中两个模型之间的同态（homomorphism），那么$f$的像（image）是$N$的一个子模型。
   
   b. 证明在集合范畴中，任意FD图式的模型都有一个最小的子模型。

**解析**：

**部分a**：

**目标**：

证明对于任意FD图式$S $，若$f : M \to N$是$S$在集合范畴中的两个模型$M$和$N$之间的同态，那么$f$的像$\text{Im}(f)$是$N$的一个子模型。

**证明步骤**：

1. **定义子模型**：

   令$\text{Im}(f)$在每个节点$a$上定义为$\text{Im}(f)(a) = f(a)(M(a)) $，即模型$M$中的元素通过$f$映射到$N$中的像。

2. **验证子模型的结构**：

   - **保留常量**：
     - 对于每个常量箭头$c : 1 \to a $，同态$f$保证$f(c) = c $，因此$\text{Im}(f)(c)$保持常量。
   
   - **保留运算**：
     - 对于每个运算箭头$g : a \to b $，由于$f$是同态，有：
      $$
       f(b) \circ g_M = g_N \circ f(a)
      $$
       因此，对于任意$x, y \in M(a) $，有：
      $$
       f(b)(g_M(x, y)) = g_N(f(a)(x), f(a)(y))
      $$
       这确保了在$\text{Im}(f)$中运算的封闭性和一致性。

   - **保留锥和余锥**：
     - 对于每个积锥和和余锥，$ \text{Im}(f)$保持其结构，因为同态$f$保证了投影态射和注入态射的映射一致性。

3. **结论**：

   因此，$ \text{Im}(f)$满足 FD 图式$S$的所有定义要求，是$N$的一个子模型。

**部分b**：

**目标**：

证明在集合范畴中，任意FD图式$S$的模型$M$都存在一个最小的子模型。

**证明步骤**：

1. **定义最小子模型**：

   最小子模型$\text{Min}(M)$是$M$的所有子模型的交集。由于集合范畴是完备的，$ \text{Min}(M)$也是一个子模型。

2. **验证最小子模型的性质**：

   - **包含必要元素**：
     -$\text{Min}(M)$包含通过图式$S$的运算和常量生成的所有元素。
   
   - **最小性**：
     - 对于任意子模型$N$的元素$x \in N(a) $，因为$x$是通过图式$S$的运算和常量生成的，故$x$必然包含在$\text{Min}(M)(a)$中。
   
   - **唯一性**：
     -$\text{Min}(M)$是唯一的，因为任何两个最小子模型都必须包含相同的生成元素。

3. **结论**：

   因此，每个模型$M$都存在一个最小子模型$\text{Min}(M) $，满足任意其他子模型都包含$\text{Min}(M) $。

**总结**：

通过部分a和部分b的证明，我们确认了FD图式在集合范畴中的模型具有良好的结构性质，即同态的像是子模型，并且每个模型都有一个最小的子模型。这些性质对于理解初始模型和术语代数的构造具有重要意义。

## 本节总结

**有限离散图式（FD sketches）**通过引入和（sums）和积（products），扩展了图式的表达能力，使其能够描述更复杂的代数结构，如域、列表、二叉树等。在术语代数的构造过程中，dæmon 的引入解决了在和余锥中进行选择的问题，确保了初始模型的构造过程能够系统地生成符合图式要求的模型。

**主要要点**：

1. **Dæmons 的引入**：
   - 解决在和余锥中选择分支的问题，确保术语代数的构造过程能够系统地进行。
   - 通过函数$D$为每个术语字符串指定分支编号，管理选择过程。

2. **初始术语代数的构造**：
   - 通过递归应用构造规则（FD–1 至 FD–7），生成符合图式定义的初始模型。
   - 确保生成的模型满足所有运算和公理的要求。

3. **混淆与“垃圾”**：
   - 初始模型可能存在或不存在混淆，取决于图式的结构和公理的强制性。
   - 无垃圾（no junk）确保模型中没有无法到达的元素，但混淆（confusion）则涉及元素之间未被图式强制的等式关系。

4. **具体例子**：
   - **自然数溢出图式**：展示了不同初始模型的构造方式及其混淆性质。
   - **二叉树图式**：展示了如何通过FD图式描述递归数据结构，并构造其初始模型。
   - **域的图式**：通过域的具体模型说明了FD图式在描述严格公理代数结构中的应用。

5. **练习题的应用**：
   - 通过练习题，深入理解FD图式的结构性质和模型的构造方法。
   - 验证了同态像是子模型以及每个模型都有最小子模型的理论。

**应用与扩展**：

- **编程语言设计**：利用FD图式形式化描述复杂的数据类型和语言特性，支持类型系统和语义分析。
- **自动机理论**：通过FD图式描述有限状态机及其行为，连接理论与实际应用。
- **代数结构研究**：利用FD图式描述各种代数结构，如布尔代数、环、域等，促进对这些结构性质的深入理解和研究。

通过掌握FD图式及其术语代数的构造方法，读者能够灵活地描述和分析各种复杂的代数结构，并在范畴论的框架下理解其内在关系和性质，为后续章节中更复杂的图式和范畴理论研究奠定坚实的理论基础。

### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------
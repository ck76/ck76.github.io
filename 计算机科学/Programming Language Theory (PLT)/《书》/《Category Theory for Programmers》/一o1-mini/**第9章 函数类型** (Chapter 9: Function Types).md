[toc]



好的，让我们详细解析你提供的《Category Theory for Programmers》第九章《函数类型》（Function Types）的内容。本章深入探讨了函数类型在范畴论中的意义，特别是函数类型作为内部同态集（Internal Hom）在不同范畴中的表现，以及柯里化（Currying）和指数对象（Exponential Objects）的概念。我们将逐步解释每个部分的内容，并提供相应的 Haskell 代码示例，以帮助你全面理解这些概念。

---

### **第九章：函数类型 (Function Types)**

到目前为止，我一直在略过函数类型的含义。函数类型与其他类型不同。

以 `Int` 为例：它只是一个整数集合。`Bool` 是一个包含两个元素的集合。但函数类型 `a -> b` 不止于此：它是对象 `a` 和 `b` 之间的态射集。任何范畴中两个对象之间的态射集被称为**同态集（Hom-set）**。恰好在范畴 **𝐒𝐞𝐭** 中，每个同态集本身就是同一范畴中的对象——因为它毕竟是一个集合。

在集合范畴（Set）中，同态集（hom-set）本质上只是一个集合。而对于其他范畴来说，情况则不同，它们的同态集是外部于范畴的。这些同态集甚至被称为**外部同态集**。

在范畴 **𝐂** 中，同态集是一个外部集合。

正是集合范畴 **𝐒𝐞𝐭** 的这种自我引用特性使得函数类型如此特别。但在某些范畴中，有一种方法可以构造表示同态集的对象。这种对象被称为**内部同态集**。

---

#### **9.1 泛在构造 (Universal Construction)**

让我们暂时忘记函数类型是集合，尝试从头开始构造一个函数类型，或者更一般地，构造一个内部同态集。以集合范畴 **𝐒𝐞𝐭** 为例，我们需要避免使用任何集合的特性，这样该构造就能自动适用于其他范畴。

函数类型可以被认为是一种**复合类型**，因为它与参数类型和结果类型有关系。我们已经见过复合类型的构造——那些涉及对象之间关系的类型。我们使用**泛在构造**来定义乘积类型和余积类型。我们可以使用同样的技巧来定义函数类型。我们需要一个涉及三个对象的模式：我们正在构造的函数类型、参数类型和结果类型。

**模式**：
1. **对象**：函数类型 `z`、参数类型 `a`、结果类型 `b`。
2. **态射**：应用态射 `g`，从 `z × a` 到 `b`。

在范畴论中，乘积 `z × a` 是一个对象，`g` 是一个态射。这个模式是否足够具体以通过泛在构造挑选出函数类型？并非在每个范畴中都是如此，但在我们感兴趣的范畴中确实如此。还有一个问题：是否有可能在没有首先定义乘积的情况下定义函数对象？答案是否定的：如果没有乘积类型，就没有函数类型。

**泛在构造的关键**在于通过**限制**来确保唯一性。在我们的例子中，如果 `z` 与从 `z × a` 到 `b` 的态射 `g` 比其他候选对象更好，那么当且仅当存在一个从 `z'` 到 `z` 的唯一态射 `h`，使得 `g'` 的应用通过 `g` 的应用因式分解，则 `z` 被认为是更优的。

在 Haskell 中，我们将函数类型 `a -> b` 解释为范畴的内部同态集 `b^a`。这个对象带有它自己的应用态射——从 `(a -> b) × a` 到 `b` 的一个态射——我们将其称为 `eval`。

---

#### **9.2 柯里化 (Currying)**

让我们再看看所有函数对象的候选者。这次，我们将态射 `g` 视为一个有两个变量的函数，`z` 和 `a`。

```haskell
g :: z × a -> b
```

作为一个来自乘积的态射，几乎等同于一个有两个变量的函数。特别地，在集合范畴 **𝐒𝐞𝐭** 中，`g` 是一个从对（来自集合 `z` 和集合 `a` 的值组成的对）到集合 `b` 的函数。

**普遍性质**告诉我们，对于每个这样的 `g`，存在唯一的态射 `h` 将 `z` 映射到一个函数对象 `a -> b`。

```haskell
h :: z -> (a -> b)
```

在集合范畴 **𝐒𝐞𝐭** 中，这意味着 `h` 是一个高阶函数，它接受一个类型为 `z` 的变量，并返回一个从 `a` 到 `b` 的函数。因此，普遍构造建立了两个变量函数与返回函数的一个变量函数之间的一对一对应关系。这个对应关系称为**柯里化（Currying）**，而 `h` 被称为 `g` 的柯里化版本。

这个对应关系是一对一的，因为对于任何给定的 `g` 都存在唯一的 `h`，并且对于任何给定的 `h`，你都可以使用公式重新创建两个变量的函数 `g`：

```haskell
g = eval . (h × id)
```

其中的 `eval` 是应用态射，从 `(a -> b) × a` 到 `b`。

**Haskell 中的柯里化**本质上内嵌于其语法中。例如，一个接受两个参数的函数：

```haskell
cats :: String -> String -> String
cats s1 s2 = s1 ++ s2
```

可以写成一个返回函数的单参数函数——一个 lambda 表达式：

```haskell
cats :: String -> String -> String
cats s1 = \s2 -> s1 ++ s2
```

这两个定义是等价的，并且都可以部分应用于仅一个参数，生成一个单参数函数：

```haskell
greets :: String -> String
greets = cats "Hello "
```

在 Haskell 中，类型 `(a, b) -> c` 和 `a -> b -> c` 之间存在一对一的对应关系，称为**柯里化（Currying）**和**反柯里化（Uncurrying）**。对应的高阶函数分别为：

```haskell
curry :: ((a, b) -> c) -> (a -> b -> c)
curry f a b = f (a, b)

uncurry :: (a -> b -> c) -> ((a, b) -> c)
uncurry f (a, b) = f a b
```

**解释**：
- `curry` 将一个接受对的函数转换为一个返回函数的函数。
- `uncurry` 将一个返回函数的函数转换为一个接受对的函数。

注意，`curry` 实际上是泛在构造的因式分解器。这意味着它从候选对象中生成因式分解函数。

在非函数式语言（如 C++）中，柯里化是可能的，但并不简单。你可以使用模板和函数对象来模拟，但实现起来较为复杂。

---

#### **9.3 指数对象 (Exponential Objects)**

在数学文献中，函数对象或两个对象 `a` 和 `b` 之间的内部同态对象通常被称为**指数对象**，表示为 `b^a`。这个表示法乍一看可能有些奇怪，但如果你考虑到函数与乘积之间的关系，它就非常合乎逻辑。

我们已经看到，在内部同态对象的泛在构造中我们必须使用乘积，但这种联系远不止于此。特别是，对于有限类型之间的函数，例如 Haskell 的 `Bool`、`Int`，甚至 `String`，这些函数至少在原则上可以完全备忘化或转换为可查阅的数据结构。这正是函数（态射）与函数类型（对象）之间等价性的本质。

**示例**：
- 一个从 `Bool` 到 `Int` 的纯函数完全由一对值（分别对应于 `False` 和 `True`）指定。
- 从 `Bool` 到 `Int` 的所有可能函数的集合等同于 `Int × Int` 的集合。

在 Haskell 中，函数类型 `a -> b` 被视为指数对象 `b^a`。这种理解使得函数类型与数据类型之间的关系更加清晰，尤其是在考虑到 Haskell 的懒惰计算时，函数和数据之间的边界变得模糊。

**Haskell 中的指数对象**：
```haskell
-- 定义指数对象的应用态射
eval :: (a -> b, a) -> b
eval (f, x) = f x
```

**解释**：
- `eval` 接受一个包含函数 `f` 和参数 `x` 的对 `(f, x)`，并返回 `f x`。
- 这对应于内部同态对象的应用态射，从 `(a -> b) × a` 到 `b`。

---

#### **9.4 笛卡尔闭范畴 (Cartesian Closed Categories)**

尽管我将继续使用集合范畴作为类型和函数的模型，但值得一提的是，有一个更大的范畴家族可以用于该目的。这些范畴被称为**笛卡尔闭范畴（Cartesian Closed Categories, CCC）**，而 **𝐒𝐞𝐭** 只是其中的一个例子。

一个笛卡尔闭范畴必须包含：
1. **终对象（Terminal Object）**，
2. **任意一对对象的乘积（Products）**，
3. **任意一对对象的指数对象（Exponents）**。

如果你将指数视为迭代乘积（可能是无限多次），那么你可以将笛卡尔闭范畴视为支持任意参数乘积的范畴。特别地，终对象可以视为零个对的乘积——或对象的零次幂。

从计算机科学的角度来看，笛卡尔闭范畴的有趣之处在于它们为简单类型 λ 演算提供了模型，而简单类型 λ 演算是所有类型化编程语言的基础。

**终对象和乘积有它们的对偶：初对象和余积。**一个笛卡尔闭范畴如果也支持这两个，并且在其中乘积可以分布到余积上，则被称为**双笛卡尔闭范畴（Bicartesian Closed Categories）**。我们将在下一节看到，双笛卡尔闭范畴（其中 **𝐒𝐞𝐭** 是一个主要例子）具有一些有趣的特性。

---

#### **9.5 指数对象与代数数据类型 (Exponential Objects and Algebraic Data Types)**

将函数类型解释为指数对象非常适合代数数据类型（Algebraic Data Types, ADTs）的方案。事实证明，所有高中代数中关于数字 `0` 和 `1`、和、乘积以及指数的基本恒等式在任何双笛卡尔闭范畴中，对于分别的初对象和终对象、余积、乘积和指数，几乎保持不变。我们还没有足够的工具来证明它们（如伴随函子或约内达引理），但我还是会在此列出它们，以作为宝贵的直觉来源。

##### **9.5.1 零次幂 (Zero Exponents)**

$$ a^0 = 1 $$

在范畴解释中，我们将 `0` 替换为**初对象（Initial Object）**，将 `1` 替换为**终对象（Terminal Object）**，将等号替换为**同构**。指数对象是内部同态对象。这个特定的指数对象表示从初对象到任意对象 `a` 的态射集。根据初对象的定义，只有一个这样的态射，因此同态集 **𝐂(0, a)** 是一个单元素集。在集合范畴 **𝐒𝐞𝐭** 中，一个单元素集就是终对象，因此这个恒等式在 **𝐒𝐞𝐭** 中是显然成立的。我们所说的是，它在任何双笛卡尔闭范畴中都成立。

在 Haskell 中，我们用 `()` 替换 `0`，用单位类型 `()` 替换 `1`，并用函数类型 `a -> b` 替换指数对象。这个主张是，从 `0` 到任意类型 `a` 的函数集等价于单位类型 `()` ——这是一个单元素集。换句话说，只有一个函数：

```haskell
undefined :: () -> a
undefined () = undefined
```

**解释**：
- 这个函数 `undefined` 是一个不可调用的函数，因为要调用它，你需要提供一个 `()` 值，但 `undefined` 永远不会返回一个 `a` 类型的值。
- 这反映了数学中的 `a^0 = 1`，即只有一个从初对象到任何对象的态射。

##### **9.5.2 一的幂 (One Exponent)**

$$ a^1 = a $$

这个恒等式在集合范畴 **𝐒𝐞𝐭** 中重申了终对象的定义：从任何对象到终对象都有一个唯一的态射。一般来说，从对象 `a` 到终对象的内部同态对象同构于对象 `a` 本身。

在 Haskell 中，从任何类型 `a` 到单位类型 `()` 只有一个函数：

```haskell
const () :: a -> ()
const () _ = ()
```

**解释**：
- 这个函数 `const ()` 忽略输入，始终返回 `()`。
- 这对应于数学中的 `a^1 = a`，即从终对象到任何对象的态射集同构于对象本身。

##### **9.5.3 一次幂 (First Exponent)**

$$ a^1 = a $$

这是对从终对象的态射可以用来选择对象 `a` 的“元素”的观察的重述。从终对象到 `a` 的内部同态对象同构于对象 `a` 本身。

在 Haskell 中，从任何类型 `a` 到单位类型 `()` 只有一个函数。这与上面的定义一致：

```haskell
const () :: a -> ()
const () _ = ()
```

##### **9.5.4 和的指数 (Sum Exponents)**

$$ a^{b + c} = a^b \times a^c $$

**解释**：
- 从两个对象的余积到另一个对象的指数同构于两个指数的乘积。
- 在 Haskell 中，这个代数恒等式有一个非常实际的解释。它告诉我们，从两个类型的和到另一个类型的函数等价于从每个单独类型到该类型的两个函数。

**Haskell 示例**：

假设我们有一个函数 `f`，它接受一个 `Either b c` 类型的参数并返回 `a`：

```haskell
f :: Either b c -> a
```

根据指数的指数恒等式：

$$ a^{b + c} = a^b \times a^c $$

这意味着我们可以将 `f` 分解为两个函数，一个处理 `Left b`，一个处理 `Right c`：

```haskell
fLeft :: b -> a
fLeft b = f (Left b)

fRight :: c -> a
fRight c = f (Right c)

-- 组合成一个元组
(fLeft, fRight) :: (b -> a, c -> a)
```

这两个函数 `fLeft` 和 `fRight` 分别对应于 `a^b` 和 `a^c` 的指数对象。最终，我们得到一个乘积类型 `(a^b) × (a^c)`，这与 `a^{b + c}` 同构。

---

#### **9.6 柯里-霍华德同构 (Curry-Howard Isomorphism)**

我已经提到过逻辑与代数数据类型之间的对应关系。类型和单位类型 `()` 分别对应于**假（False）**和**真（True）**。乘积类型和和类型分别对应于逻辑**合取（∧）**和**析取（∨）**。在这个方案中，我们刚刚定义的函数类型对应于逻辑**蕴涵（⇒）**。换句话说，类型 `a -> b` 可以解读为“如果 `a` 则 `b`”。

根据**柯里-霍华德同构**，每个类型都可以被解释为一个命题——一个可能为真或假的陈述或判断。这样的命题被认为是成立的，如果该类型有元素占据；否则认为是不成立的。特别地，一个逻辑蕴涵是成立的，如果对应的函数类型有元素占据，这意味着存在这样的一个函数。函数的实现是一个定理的证明。**编写程序等价于证明定理**。

让我们看看几个例子。

##### **示例1：应用态射 `eval`**

函数 `eval` 的签名是：

```haskell
eval :: ((a -> b), a) -> b
eval (f, x) = f x
```

**逻辑解释**：

$$ ((a \rightarrow b) \wedge a) \rightarrow b $$

可以这样解读这个命题：如果 `a -> b` 成立，并且 `a` 是真的，那么 `b` 必须是真的。这就是**演绎法则（Modus Ponens）**。通过实现这个函数 `eval`，我们实际上展示了这个定理的有效性。

##### **示例2：错误的命题**

考虑一个明显错误的命题：

$$ a \lor b \rightarrow a $$

这显然是错误的，因为你可以选择一个为假的 `a` 和一个为真的 `b`，这会导致 `a` 为假而命题为真，从而违反逻辑。

对应的函数签名为：

```haskell
f :: Either a b -> a
```

**解释**：
- 在 Haskell 中，无法实现这个函数，因为 `Either a b` 中的 `Right b` 无法转换为 `a`。如果尝试调用 `f (Right b)`，会导致运行时错误，因为无法返回一个 `a` 类型的值。

##### **示例3：从空类型推导任何类型**

考虑以下函数签名：

```haskell
absurd :: Void -> a
```

**解释**：
- 类型 `Void` 是一个空类型，没有任何值。
- 因此，`absurd` 函数无法被调用，因为没有 `Void` 类型的值可以传递给它。
- 这反映了逻辑中的命题“从假出发可以推导任何命题（ex falso quodlibet）”。

**Haskell 中的 `Void` 定义**：

```haskell
data Void
```

因为 `Void` 没有任何构造函数，所以无法构造 `Void` 类型的值，从而 `absurd` 函数永远不会被调用。

---

### **章节总结**

在第九章中，我们深入探讨了**函数类型（Function Types）**在范畴论中的意义，特别是函数类型作为内部同态集（Internal Hom）的表现，以及柯里化（Currying）和指数对象（Exponential Objects）的概念。我们还讨论了**笛卡尔闭范畴（Cartesian Closed Categories）**以及**柯里-霍华德同构（Curry-Howard Isomorphism）**，展示了类型理论与逻辑之间的深刻联系。

**关键要点**：

1. **同态集（Hom-sets）**：
   - 在范畴论中，两个对象之间的态射集称为同态集。
   - 在集合范畴 **𝐒𝐞𝐭** 中，同态集本身就是一个集合。

2. **内部同态集（Internal Hom）**：
   - 在某些范畴中，可以构造表示同态集的对象，称为内部同态集。
   - 函数类型 `a -> b` 在 Haskell 中被视为指数对象 `b^a`。

3. **泛在构造（Universal Construction）**：
   - 通过乘积和应用态射来构造函数类型。
   - 确保函数类型在范畴中具有唯一性。

4. **柯里化（Currying）**：
   - 将接受多个参数的函数转换为一系列接受单个参数的函数。
   - 在范畴论中，这对应于指数对象的构造。

5. **指数对象（Exponential Objects）**：
   - 表示从一个对象到另一个对象的态射集。
   - 笛卡尔闭范畴中的一个关键特性，支持函数类型的存在。

6. **笛卡尔闭范畴（Cartesian Closed Categories, CCC）**：
   - 包含终对象、任意一对对象的乘积以及指数对象。
   - 为简单类型 λ 演算提供了模型，是类型化编程语言的基础。

7. **柯里-霍华德同构（Curry-Howard Isomorphism）**：
   - 类型理论与逻辑之间的一种深刻对应关系。
   - 类型对应于命题，程序对应于定理的证明。

**总结**：

函数类型在范畴论和类型理论中占据着核心地位。通过理解函数类型作为内部同态集的意义，以及柯里化和指数对象的概念，你可以更深入地理解 Haskell 中函数的本质及其在类型系统中的作用。**柯里-霍华德同构**进一步展示了类型理论与逻辑之间的紧密联系，使得编程语言不仅是编写程序的工具，也是形式化证明的有力工具。

如果你对本章的内容有任何疑问，或需要进一步的解释，请随时提问！

### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------
[toc]



### 6.1 类型安全详解

**类型安全** (Type Safety) 是现代编程语言的重要特性，保证了在程序执行过程中，不会发生某些类型不匹配的错误。这意味着在程序运行时，诸如将一个字符串与数字相加或者将两个数字进行字符串拼接等 **非法操作** 是不可发生的。这种类型的错误，不仅在执行上毫无意义，还会导致程序执行异常终止。

在本章中，类型安全主要通过两个核心性质来表达 **静态语义** (statics) 与 **动态语义** (dynamics) 之间的 **一致性** (coherence)：
1. **类型保持** (Preservation)
2. **进展性** (Progress)

通过这两个性质的结合，可以确保程序不会进入 **stuck** 状态，即不会陷入无法进行下一步计算的情况。

---

### 1. **类型安全的直观含义**

- 类型安全的核心在于，编译器能够 **预先预测** 一个表达式的类型，并确保这个表达式在运行时遵循这些类型约束。 
- 例如，假设我们有一个语言 **L{num str}**，它包含数字和字符串两种基本类型。对于一个 **类型安全的语言**，程序在运行时将不会出现尝试将一个数字与字符串相加的情况，因为这在静态类型检查时就已经被发现并禁止。
  
  **静态语义** 和 **动态语义** 的这种一致性确保了程序在执行过程中不会发生未定义的操作。静态检查系统预测了程序的行为，并在类型检查阶段阻止了潜在的运行时错误。

### 2. **“stuck” 状态**

- 程序运行时最糟糕的情况之一就是进入 **stuck** 状态。**stuck** 的定义是：表达式 **既不是一个值**，也 **无法继续被求值**。这通常对应于运行时遇到非法操作，比如 **加法操作中一个操作数是数字而另一个是字符串** 的情况。
  
  类型安全的一个关键结论是：**stuck 状态必然是类型错误引发的**。如果一个表达式通过了类型检查，它 **不会卡住**，因为每一步的求值都能继续进行，直到得到最终结果（值）。

### 3. **类型安全定理**

类型安全可以用两个核心部分来表达：
1. **类型保持** (Preservation)：如果一个表达式 $e$ 的类型为 $τ$，并且 $e$ 可以进行一步求值变为 $e'$，则 $e'$ 的类型仍然是 $τ$。这意味着每一步求值过程都保持了表达式的类型不变。
   
   数学上表示为：
   $$
   e : τ \quad \text{且} \quad e \rightarrow e' \quad \Rightarrow \quad e' : τ
   $$

2. **进展性** (Progress)：对于一个具有类型 $τ$ 的表达式 $e$，要么 $e$ 已经是一个 **值**，要么它可以继续进行求值（即存在某个 $e'$ 使得 $e \rightarrow e'$）。这保证了类型良好的表达式不会卡在没有求值规则的位置。
   
   数学上表示为：
   $$
   e : τ \quad \Rightarrow \quad \text{要么} \quad e \text{ 是值} \quad \text{要么} \quad \exists e' \text{ 使得 } e \rightarrow e'
   $$

  **类型保持** 和 **进展性** 的结合就形成了 **类型安全** 定理。这意味着程序中每个表达式的求值过程是类型一致的，并且程序可以始终前进到某个最终状态（即值）。

### 4. **类型安全定理的细化：**

**定理 6.1** 表述了 **类型安全** 的两部分：

- **类型保持**：在求值过程中，表达式的类型不会改变。每次对表达式的操作都会产生另一个同类型的表达式。这意味着，如果我们从一个合法的类型开始，那么每一步求值也都是合法的。
  
  例如，对于一个类型为 **num** 的表达式，求值的每一步将继续保持类型为 **num**，直到得到最终值。
  
- **进展性**：保证了一个合法的表达式要么已经是一个值，要么它能继续求值。这确保了程序不会进入 **stuck** 状态。

### 5. **实际应用中的 stuck 状态**

- 在没有类型检查的编程语言中，程序有时会出现 “非法指令” 错误，这通常是由于程序试图执行未定义行为造成的。例如，在某些情况下，程序可能尝试执行不可能的操作，如 **试图将一个字符串作为函数调用** 或 **将布尔值与数字相加**。
  
  类型安全理论告诉我们，这种情况在类型安全语言中 **不可能** 发生。因为在执行之前，编译器会通过类型系统排除这些错误的程序。这也解释了为什么现代编程语言往往强调类型系统的重要性——它不仅帮助开发者避免运行时错误，还增强了代码的健壮性和可靠性。

---

### 总结

**类型安全** 通过 **类型保持** 和 **进展性** 的结合，确保程序的执行不会进入 **stuck** 状态，并且类型正确的程序总能正确求值。这种保证在现代编程语言中尤为重要，它提高了程序的正确性，减少了运行时错误，并增强了程序行为的可预测性。

这个定理为编程语言设计提供了坚实的基础，确保静态类型系统与动态执行之间的正确互动，使得程序能够 **安全** 且 **一致地执行**。

### ---------------------------------

### 6.1 保持性详解

**保持性定理** (Preservation Theorem) 确保了程序在执行的每一步中，表达式的类型不变。这是类型安全性证明的一部分。保持性通过说明在程序求值过程中，表达式的类型保持一致，即一个表达式从一种状态过渡到另一种状态时，其类型依然保持相同。

保持性定理具体表述如下：

$$
\text{Theorem 6.2 (Preservation):} \quad \text{如果 } e : τ \quad \text{且} \quad e \rightarrow e', \quad \text{则} \quad e' : τ
$$

### 1. **定理的直观理解**

保持性是对类型安全的第一部分证明。它确保了程序执行的每一步骤都不会改变表达式的类型。

- **保持性** 指的是：如果一个表达式 $e$ 具有某个类型 $\tau$，并且它能够通过某种方式过渡到另一个表达式 $e'$，那么 $e'$ 必然也具有相同的类型 $\tau$。
- 这种类型的保持使得我们能够确信在求值过程中，表达式的类型是一致的，不会发生不合法的类型变化。

### 2. **证明框架**

为了证明这个定理，我们可以使用 **规则归纳** (rule induction) 来逐一检查求值过程中每个可能的转换规则。核心思想是对每个可能的过渡情况（也就是程序中的每条转换规则），证明表达式的类型保持不变。

#### **例子 1: 加法规则**

考虑转换规则 (5.4b)：
$$
e_1 \rightarrow e'_1 \quad \Rightarrow \quad plus(e_1; e_2) \rightarrow plus(e'_1; e_2)
$$

在这种情况下，假设 $plus(e_1; e_2) : \tau$，根据 **类型推导逆推引理** (Inversion Lemma) 可知：
1. $\tau = num$ （即这个表达式的类型是数字）。
2. $e_1 : num$ 和 $e_2 : num$。

因此，通过 **归纳假设**，我们可以得出 $e'_1 : num$，即 $e'_1$ 也是数字类型。根据规则，我们可以进一步推导出 $plus(e'_1; e_2) : num$，从而证明了类型保持性。

#### **例子 2: let 绑定规则**

考虑转换规则 (5.4h)：
$$
let(e_1; x.e_2) \rightarrow [e_1/x]e_2
$$

假设 $let(e_1; x.e_2) : \tau_2$，根据 **类型推导逆推引理**，我们知道：
1. $e_1 : \tau_1$ 对某个 $\tau_1$ 成立。
2. 在上下文 $x : \tau_1$ 中，$e_2 : \tau_2$。

根据 **替换引理** (Substitution Lemma)，我们可以推导出 $[e_1/x]e_2 : \tau_2$，从而证明了类型保持性。

### 3. **保持性的细节**

- **基本操作的类型保持**：在操作层面，例如数字的加法、字符串的拼接等原始操作也是类型保持的。我们可以验证，对于 $a : num$ 和 $b : num$，如果 $a + b = c$，那么 $c : num$ 依然成立。
  
  这种操作层面的验证确保了语言的基本运算是类型保持的，不会因为基本操作导致类型错误。

- **归纳结构的适用性**：保持性的证明通常通过对转换规则的归纳来完成。在一些情况下，我们可以通过对表达式 $e$ 进行结构归纳或通过对类型的归纳来进行证明，但经验表明，使用 **规则归纳** 是最自然且最有效的方法。这是因为求值过程本质上是基于这些转换规则的，因此我们需要对每一个可能的转换情况进行检查。

### 4. **小结**

**保持性** 定理证明了在程序的每一步求值过程中，表达式的类型保持不变。通过检查所有可能的转换规则（例如加法、let 绑定等），我们可以证明每个操作都保持了类型一致性。这是类型安全性的重要组成部分，确保程序在运行时不会出现由于类型错误导致的未定义行为。

### ---------------------------------

**进展性** (Progress) 和 **保持性** (Preservation) 是类型系统中的两个核心性质，它们通常用于证明编程语言的**类型安全性**。类型安全保证了程序在运行时不会发生类型错误，而进展性和保持性则是构建类型安全性的基础理论。

### 1. **进展性** (Progress)

**进展性**性质保证了在类型系统中，如果一个表达式是**类型正确的**，那么这个表达式要么是一个**值**（即已经完全求值的结果），要么可以通过某个规则进一步**进行计算**。换句话说，进展性确保了程序不会卡在某个状态，无法进行求值或遇到无法计算的情况。

#### 进展性的定义：

对于任何一个类型正确的表达式 $e$，要么 $e$ 是一个值，要么存在另一个表达式 $e'$ 使得 $e$ 可以**进一步计算**，即：
- 如果 $e$ 是一个值，那么 $e$ 已经完成计算。
- 如果 $e$ 不是一个值，则存在某个 $e'$，使得 $e \rightarrow e'$，即 $e$ 可以一步转换为 $e'$。

#### 示例：

假设我们有一个简单的表达式计算系统，其中表达式可以是整数和加法操作。进展性的证明可以如下：

1. 如果表达式是一个**整数值**，例如 `5`，那么它已经是一个值，无法继续计算。
2. 如果表达式是一个**加法表达式**，如 `2 + 3`，它不是一个值，但可以通过规则转换为 `5`，即它可以**继续计算**。
3. 如果表达式涉及一个未定义的操作（如 `2 / "hello"`），则进展性无法得到保证，因为这不是一个类型正确的表达式。

通过进展性性质的保证，类型正确的表达式始终能够产生结果或继续演进，而不会遇到“卡住”的问题。

### 2. **保持性** (Preservation)

**保持性**性质（也称为**类型保持性**）保证了在类型系统中，如果一个表达式 $e$ 是**类型正确的**，并且它可以**一步演化**为另一个表达式 $e'$（即 $e \rightarrow e'$），那么 $e'$ 的类型与 $e$ 的类型是相同的。也就是说，类型在表达式的求值过程中是**保持不变**的。

#### 保持性的定义：

如果表达式 $e$ 有某个类型 $T$，并且 $e$ 可以转换为 $e'$，即 $e \rightarrow e'$，那么 $e'$ 的类型也是 $T$，即 $e'$ 仍然具有与 $e$ 相同的类型。

用公式表示为：
- 如果 $e : T$，并且 $e \rightarrow e'$，则 $e' : T$。

#### 示例：

考虑一个简单的表达式 `2 + 3`。在求值过程中，`2 + 3` 是类型为 `int` 的表达式。

1. 初始表达式 `2 + 3` 具有类型 `int`。
2. 通过一次求值，表达式 `2 + 3` 变为 `5`，这也是一个类型为 `int` 的值。

在整个求值过程中，保持性确保了表达式在每次演化后仍然保持相同的类型（这里都是 `int` 类型）。如果程序在求值过程中能够违反保持性，则会出现类型错误，例如本应返回整数的表达式却返回了字符串。

### 3. **进展性与保持性：类型安全的保证**

进展性和保持性共同构成了编程语言**类型安全性**的两大核心性质：

- **进展性**：确保类型正确的程序始终能够继续执行，或者最终计算出一个值。
- **保持性**：确保程序在执行过程中类型不会发生变化，即每个表达式的类型在求值过程中保持一致。

### 4. **进展性与保持性的直观理解**

#### 进展性（程序不会卡住）：
如果一个表达式类型正确，那么要么它已经是一个值（已经计算完成），要么它能够根据程序的语义继续演化。这意味着类型系统不会允许程序停滞不前或卡在无法计算的状态。

例如：
- 表达式 `5` 是类型为 `int` 的值，已经计算完成。
- 表达式 `2 + 3` 可以通过求值进一步转换为 `5`，表示进展。

#### 保持性（类型不会改变）：
在程序执行的每一步中，如果一个表达式类型正确，并且可以继续演化成新的表达式，那么新表达式的类型必须与原表达式相同。类型的保持性保证了程序在运行过程中不会出现类型不一致的情况。

例如：
- 表达式 `2 + 3` 具有类型 `int`，演化后变为 `5`，其类型仍然是 `int`。

### 5. **进展性和保持性的形式化证明**

在形式化的编程语言理论中，证明进展性和保持性通常是通过**归纳法**来完成的。以下是简要的证明思路：

#### 1. **进展性证明**：
进展性的证明通常基于表达式的归纳结构。我们基于表达式的形式逐步证明：
- 如果表达式是一个值，则进展性成立。
- 如果表达式不是值，则分析每个表达式构造子，证明它可以根据某些规则进一步计算。

#### 2. **保持性证明**：
保持性的证明通常通过演化规则与类型推导规则的一一对应来完成。证明的思路是：
- 假设表达式 $e$ 具有类型 $T$，然后对 $e$ 进行一步演化得到 $e'$，通过分析演化规则，证明 $e'$ 也具有类型 $T$。

### 6. **进展性和保持性的实际意义**

在实际编程语言设计中，进展性和保持性证明了类型系统的**健全性**（Soundness）。健全的类型系统可以防止运行时类型错误（如对非数值类型进行加法运算），并确保程序的执行行为是可预测的。

- **进展性** 确保类型正确的程序不会出现“卡住”状态。
- **保持性** 确保程序在执行过程中始终遵循类型规则。

### 7. **进展性和保持性的对比总结**

| **性质**     | **进展性** (Progress)                                    | **保持性** (Preservation)                      |
| ------------ | -------------------------------------------------------- | ---------------------------------------------- |
| **作用**     | 确保类型正确的表达式要么是值，要么可以进一步演化         | 确保表达式在演化过程中类型保持不变             |
| **关键思想** | 表达式不会卡住，类型正确的程序始终可以继续运行或完成计算 | 类型在求值过程中的一致性，保证不会发生类型错误 |
| **重要性**   | 防止程序在运行时进入无法继续计算的状态                   | 保证程序在运行时不会违背类型系统的约束         |
| **证明方法** | 基于表达式的结构进行归纳，证明每种情况都可以进行计算     | 基于演化规则与类型推导规则的一一对应来进行证明 |
| **目标**     | 保证程序的进展性，不会停滞或卡住                         | 保证程序执行过程中的类型一致性，防止类型错误   |

### 8. **总结**

- **进展性**和**保持性**是类型安全中的两个核心概念，它们一起保证了类型系统的**健全性**。
- **进展性**确保类型正确的程序不会卡住，能够继续执行或最终返回一个值。
- **保持性**确保程序在求值过程中的类型不会发生变化，从而防止类型错误。
- 通过形式化证明进展性和保持性，可以确保编程语言的类型系统是安全的，并且能够有效地防止运行时类型错误。

这两者的结合是编程语言设计中类型安全性的重要组成部分，为现代静态类型语言提供了理论基础。

### ---------------------------------

### 6.2 进展性详解

**进展性定理** (Progress Theorem) 保证了良好类型的程序不会进入“卡住”的状态，意味着一个程序要么是一个值（已经完成了计算），要么可以继续进行进一步的计算。进展性的证明依赖于一个关键引理 **6.3**，该引理定义了每个类型的表达式所对应的**值的形式**（Canonical Forms）。

### **引理 6.3: 标准形式（Canonical Forms）**

$$
\text{Lemma 6.3 (Canonical Forms):} \quad \text{如果 } e \ val \text{ 且 } e : \tau, \text{则}
$$
1. 如果 $\tau = num$，则 $e = num[n]$ 对某个数 $n$ 成立。
2. 如果 $\tau = str$，则 $e = str[s]$ 对某个字符串 $s$ 成立。

这个引理的证明依赖于对静态规则 (4.1) 和动态规则 (5.3) 的归纳推导。换句话说，如果一个表达式是一个值，并且它的类型是 $\tau$，那么根据不同的类型 $\tau$，表达式必须采取特定的形式（例如，数字或字符串）。该引理为进展性的证明奠定了基础，因为它保证我们可以推导出每个类型的表达式在求值到最终状态时的形式。

### **进展性定理**

**定理 6.4 (Progress):** 如果 $e : \tau$，则 $e$ 要么是一个值 $e \ val$，要么存在某个 $e_0$ 使得 $e \rightarrow e_0$。

这个定理的证明基于对类型推导的归纳推导。为了方便起见，我们来看具体的推导过程：

#### **证明框架**

证明的过程是通过对类型推导的规则进行归纳推导。在此，我们主要考虑 **加法规则 (4.1d)**：

$$
\frac{e_1 : num \quad e_2 : num}{plus(e_1; e_2) : num} \quad (4.1d)
$$

假设上下文为空，因为我们只考虑封闭的项。根据归纳假设，我们有：

- 要么 $e_1$ 是一个值 $e_1 \ val$，要么存在 $e_0$ 使得 $e_1 \rightarrow e_0$。如果是后者，我们可以推导出：
  
  $$
  plus(e_1; e_2) \rightarrow plus(e_0; e_2)
  $$

  这符合要求。

- 如果 $e_1$ 是一个值，则我们继续根据归纳假设对 $e_2$ 进行处理。要么 $e_2$ 是一个值，要么存在 $e_0$ 使得 $e_2 \rightarrow e_0$。如果是后者，我们可以推导出：

  $$
  plus(e_1; e_2) \rightarrow plus(e_1; e_0)
  $$

  这也符合要求。

- 如果 $e_1$ 和 $e_2$ 都是值，那么根据 **引理 6.3** (Canonical Forms)，我们知道 $e_1 = num[n_1]$ 且 $e_2 = num[n_2]$，因此我们可以使用加法规则进行求值：

  $$
  plus(num[n_1]; num[n_2]) \rightarrow num[n_1 + n_2]
  $$

#### **推导树形式表示**

我们可以将上述推导过程用推导树表示：

$$
\frac{e_1 \ val \quad e_2 \ val}{plus(e_1; e_2) \rightarrow num[n_1 + n_2]} \quad (5.4a)
$$

或者在每一步求值的过程中，也可以表示为：

$$
\frac{}{\text{num}[n_1] \ val} \quad \frac{}{\text{num}[n_2] \ val}
$$
$$
\quad \frac{\frac{}{\text{num}[n_1] \ val} \quad \frac{}{\text{num}[n_2] \ val}}{\text{plus(num[n_1]; num[n_2])} \rightarrow \text{num[n_1 + n_2]}}
$$

### **推导结构的变体与应用**

因为类型推导规则是 **语法定向的**（syntax-directed），即每种表达式形式都有唯一的类型推导规则。因此，进展性定理同样可以通过对表达式结构的归纳来证明。具体而言，可以在每一步推导时使用逆推引理来刻画表达式各部分的类型。然而，这种方法在推导规则不是完全语法定向的情况下可能无法奏效，或者导致推导过程非常复杂。

#### **总结**

通过保持性定理和进展性定理的结合，能够全面保证类型安全性。进展性定理确保了良好类型的表达式不会进入“卡住”的状态，即程序在执行中不会陷入未定义的状态。保持性定理则保证了在执行过程中，表达式的类型保持一致。因此，二者共同作用，确保静态和动态的逻辑一致性，避免出现不合法的状态。

### ---------------------------------

### 6.3 运行时错误详解

在这一节中，探讨了在语言 $L\{num \, str\}$ 中处理**运行时错误**的方式，尤其是当我们试图定义诸如除法操作（`div`）时，会遇到的错误场景。在处理运行时错误时，有两种常见的方法：

1. **增强类型系统**，以便防止任何良好类型的程序出现诸如除以零之类的错误。
2. **增加动态检查**，使得在运行时遇到除以零时能够发出错误信号。

### **问题：除以零的错误**

给出一个直观的例子，考虑我们扩展语言 $L\{num \, str\}$，为其添加一个商操作 `div`。其自然的类型规则如下：

$$
\frac{e_1 : num \quad e_2 : num}{div(e_1; e_2) : num}
$$

然而，表达式 `div(num[3]; num[0])` 在静态类型检查下是**良好类型**的，但在执行时会**卡住**，因为除数为零导致除法无法进行。这种现象说明了在类型安全的前提下，某些表达式仍可能在运行时遇到错误。

### **解决方案分析**

对于这个问题，有两种可能的解决方案：

1. **增强类型系统**，以确保没有良好类型的程序会涉及到除以零的情况。这意味着，类型检查器需要证明在使用表达式作为除数时，该表达式一定不为零。这种方法虽然是可行的，但**代价非常高**，因为我们无法静态地预测表达式在运行时是否为零。这属于**不可判定问题**，因此在实践中较难实现。
   
2. **动态检查**，即在运行时对除数为零的情况进行检测，并在遇到这种情况时发出错误信号。这种方法在现代编程语言中是更为普遍的做法，因为它允许程序在执行时进行必要的错误处理，而不强加过于严格的静态限制。

### **检查错误与未检查错误**

在模型中，重要的是要区分**已检查错误**和**未检查错误**：

- **未检查错误**（unchecked errors）是通过类型系统防止的错误。这类错误不需要在运行时进行检查，因为类型系统已经确保不会发生。例如，类型系统保证了加法的两个参数一定是数字，因此不需要在执行加法时检查类型是否正确。
  
- **已检查错误**（checked errors）是需要在运行时进行检查的错误。例如，除法操作需要检查除数是否为零，因为类型系统无法完全阻止这种情况的发生。

### **引入错误判定**

为了处理这些运行时错误，可以通过定义一个**错误判断**的推导规则，表示表达式 $e$ 会产生一个**已检查的运行时错误**。例如，以下是几个用于定义运行时错误的推导规则：

1. **除以零错误**：
   $$
   \frac{e_1 \ val}{div(e_1; num[0]) \ err} \quad (6.1a)
   $$

   当第一个表达式 $e_1$ 已经求值为一个值，而第二个表达式是零时，产生一个除以零的错误。

2. **错误传播**：
   $$
   \frac{e_1 \ err}{plus(e_1; e_2) \ err} \quad (6.1b)
   $$
   $$
   \frac{e_1 \ val \quad e_2 \ err}{plus(e_1; e_2) \ err} \quad (6.1c)
   $$

   如果一个表达式的某个子表达式已经产生错误，那么该表达式整体也会产生错误。这种错误的传播机制确保了错误能在整个表达式中正确传递。

### **引入错误表达式**

此外，可以定义一个强制引发错误的表达式 `error`，并为其提供如下的静态和动态语义：

- 静态语义：
   $$
   \frac{}{\Gamma \vdash error : \tau} \quad (6.2a)
   $$
  
   表示错误表达式 `error` 可以具有任何类型。

- 动态语义：
   $$
   \frac{}{\text{error} \ err} \quad (6.2b)
   $$

   表示 `error` 表达式会直接产生一个运行时错误。

### **进展性与错误**

**保持性定理**不会受到已检查错误的影响，保持性依然确保类型在执行过程中保持不变。然而，**进展性定理**需要修正，以考虑已检查错误的可能性。

### **进展性定理（带错误）**

**定理 6.5 (Progress With Error):** 如果 $e : \tau$，则要么 $e \ err$，要么 $e \ val$，要么存在 $e_0$ 使得 $e \rightarrow e_0$。

#### **证明思路**

证明通过对类型推导进行归纳推导，与之前的证明类似。不同的是，现在在每个推导步骤中需要考虑三种可能的情况：
1. 表达式产生了错误 $e \ err$。
2. 表达式是一个值 $e \ val$。
3. 表达式可以继续进行求值，即存在 $e_0$ 使得 $e \rightarrow e_0$。

这种三种情况的证明框架确保了，即使在运行时错误的场景下，进展性依然能够保证程序要么继续执行，要么产生正确的错误信号。

### 总结

通过引入**错误检查机制**，我们可以在不增加类型系统复杂性的前提下，保证程序的安全性。通过**错误判断**与**错误传播**，能够有效地处理诸如除以零的运行时错误，并确保程序在遇到这些错误时能够做出适当的响应，而不是陷入未定义的状态。

### ---------------------------------

### 6.4 Notes 详解

这一节中的**类型安全**概念在现代编程语言中占有重要地位。它确保程序在执行时不会出现某些无法处理的错误状态，如试图将字符串与数字相加或除以零的情况。

### **历史背景与演进**

1. **Milner的贡献 (1978):**  
   Milner 是最早明确提出**类型安全**这一概念的人。他发明了著名的口号：“**良好类型的程序不会出错** (well-typed programs do not go wrong)”。  
   - 这一概念的核心在于通过类型系统来防止程序在运行时发生某些类型错误，例如试图在数字和字符串之间进行无效操作。
   - Milner 的定义中使用了“出错” (going wrong) 这一术语，来表示**类型错误**，即程序尝试执行非法操作的情形。

2. **Wright 和 Felleisen的改进 (1994):**  
   Wright 和 Felleisen 对 Milner 的类型安全理论进行了进一步的分析，并提出了一种新的表达方式：“**良好类型的程序不会卡住** (well-typed programs do not get stuck)”。  
   - 他们观察到，**卡住状态** (stuck state) 是指程序到达一个没有进一步求值规则适用的状态，而这个状态并不是程序设计所期望的终止状态。  
   - Wright 和 Felleisen 强调，通过类型安全的分析，**没有卡住状态会出现在良好类型的程序中**。这进一步确保了程序在执行时不会陷入无法处理的状态。

3. **Martin-Löf的贡献 (1980):**  
   在这一背景下，**Martin-Löf** 引入了**规范形式** (canonical forms) 的概念，用来表示程序中可能出现的合法状态。  
   - 通过引入规范形式，程序在不同类型下的**值形式**可以被明确地定义。例如，对于类型 $\text{num}$，规范形式是具体的数字 $\text{num[n]}$，而对于 $\text{str}$，规范形式则是字符串 $\text{str[s]}$。
   - **进展性定理** (progress theorem) 正是基于这一概念建立的：如果一个程序是良好类型的，要么它已经是一个值，要么它可以继续执行下去，不会卡住。

### **关键思想总结**

- **Milner's “going wrong”** 和 **Wright & Felleisen's “getting stuck”** 是类型安全理论中的两种表达方式，分别强调程序在出现非法操作时的不同表现形式。
- **进展性定理** 和 **保持性定理** 是类型安全理论的两大支柱，它们分别保证了程序的执行过程中，不会出现卡住状态，并且类型在求值过程中始终保持一致。
- **类型安全**的核心在于确保程序的**静态分析**与其**动态行为**的一致性，从而防止程序在运行时进入非法状态。

通过这些理论的结合，**类型安全**成为了现代编程语言设计中的基本要求之一，确保了程序的健壮性和可预测性。


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------
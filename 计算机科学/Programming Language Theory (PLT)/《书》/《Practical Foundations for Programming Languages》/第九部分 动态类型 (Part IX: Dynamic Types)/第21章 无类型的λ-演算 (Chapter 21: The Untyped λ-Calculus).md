[toc]



在**Part VI 动态类型 (Dynamic Types)** 中，本节内容聚焦于 **动态类型系统** 以及 **无类型 λ-演算** (Untyped Lambda Calculus) 的介绍与讨论，同时探讨了动态类型和静态类型的结合、优化等话题。

### 主要内容概述

#### 1. **无类型 λ-演算 (The Untyped λ-Calculus)**

无类型 λ-演算是计算理论中的一种核心形式主义，它不为变量和函数指定特定的类型。由于没有类型的限制，无类型 λ-演算允许任意表达式进行组合和传递，极大增加了其表达能力。这种自由性也是其强大的原因之一，但同时也带来了安全性和一致性的问题，因为无类型的表达式可能会产生未定义的行为或导致计算错误。

#### 2. **λ-演算 (Typed λ-Calculus)**

与无类型 λ-演算不同，**带类型的 λ-演算** 为变量和函数引入了类型约束，从而确保了表达式的正确性。类型系统通过静态检查防止了不合法的函数调用和计算错误。因此，带类型的 λ-演算成为许多现代编程语言的基础，它引入了强类型系统的概念，在表达灵活性与类型安全性之间找到平衡。

#### 3. **可定义性 (Definability)**

在该部分中，讨论了在不同类型系统中，函数和操作的可定义性问题。主要探讨了哪些函数可以在无类型或带类型的 λ-演算中定义，以及如何使用 λ-演算表达更复杂的函数和计算过程。

#### 4. **Scott's 定理 (Scott's Theorem)**

**Scott's 定理** 是 λ-演算中的一个重要结果，它探讨了如何通过 λ-演算表示更复杂的函数，包括那些可能不终止的函数。Scott's 定理揭示了计算与不动点定理之间的深刻关系，展示了如何通过不动点运算符来定义递归函数。

#### 5. **无类型即单类型 (Untyped Means Uni-Typed)**

这个观点解释了在某种意义上，无类型系统实际上可以看作是所有类型统一为一个通用类型的系统。也就是说，虽然在语法上没有类型区分，但实际上每个表达式都可以看作属于一个通用的“类型”，这是一种更为泛化的类型系统观点。

### 动态类型部分 (Dynamic Typing)

#### 1. **动态类型 (Dynamic Typing)**

**动态类型** 是一种在运行时确定表达式类型的系统。与静态类型不同，动态类型不在编译时进行类型检查，而是推迟到程序运行时进行类型验证。这种灵活性使得动态类型语言非常适合快速开发和原型设计，但也带来了性能开销和潜在的运行时错误。

#### 2. **动态类型的 PCF (Dynamically Typed PCF)**

该部分探讨了如何将动态类型引入到 Plotkin’s PCF（Programming Computable Functions） 中，并如何通过动态类型系统处理 PCF 中的部分递归函数问题。

#### 3. **动态类型的变体与扩展 (Variations and Extensions of Dynamic Typing)**

这里介绍了动态类型系统的不同变体和扩展方案，例如将静态和动态类型相结合的混合类型系统（Hybrid Typing）。这些扩展不仅解决了一些动态类型带来的问题，还允许在某些情况下动态类型的优化。

#### 4. **对动态类型的批判 (Critique of Dynamic Typing)**

动态类型虽然灵活，但也带来了许多问题，例如运行时错误的可能性、难以进行优化、调试困难等。静态类型的支持者认为，动态类型系统的灵活性不足以弥补其带来的这些开销和问题。因此，这一部分主要讨论了动态类型的局限性。

### 混合类型 (Hybrid Typing)

**混合类型系统** 结合了静态和动态类型的优点。通过静态类型系统进行编译时的类型检查，同时保留动态类型系统的灵活性。在这种系统中，一部分类型在编译时确定，另一部分则在运行时验证。这样可以在保证类型安全性的同时保留一定的灵活性。

### 动态类型的优化 (Optimization of Dynamic Typing)

由于动态类型在运行时进行类型检查，因此带来了较大的性能开销。本节讨论了如何通过静态分析或其他技术优化动态类型的运行时性能。通过某些优化策略，动态类型系统的性能可以得到显著提升。

### 静态与动态类型的对比 (Static Versus Dynamic Typing)

这一部分讨论了 **静态类型** 与 **动态类型** 的优劣势对比：
- **静态类型** 在编译时保证类型安全，因此能捕获更多的错误，提供更高的安全性和优化空间。
- **动态类型** 则更加灵活，适合快速开发和迭代，但可能带来更多运行时错误和性能问题。

### 总结

**Part VI 动态类型** 部分的核心在于通过探讨动态类型与静态类型的对比、优化及其组合应用，帮助读者理解在编程语言设计中不同类型系统的选择及其影响。

### ---------------------------------

### Chapter 17: The Untyped λ-Calculus (无类型 λ-演算)

在本章中，探讨了 **无类型 λ-演算 (The Untyped λ-Calculus)**，同时引出了“无类型即单类型”的概念，即所谓的无类型语言实际上是一种具有单一递归类型的语言。这里的重点在于通过 **λ-演算** 研究编程语言的核心机制，特别是 **函数**，以及 λ-演算如何成为一种极具简洁美的形式化系统。

### 1. **类型 (Types) 与 无类型 λ-演算**

首先，**类型 (Types)** 是编程语言设计中的核心原则之一。在大多数编程语言中，类型提供了一种对数据的组织方式，并且允许编译器对代码进行静态分析。然而，某些语言（例如 Lisp、Scheme）常被称为“无类型语言 (Untyped Languages)”，因为它们不在编译时对数据类型进行约束。

但实际上，所谓的无类型语言并不是完全没有类型约束。相反，它们通常可以看作是 **单类型语言 (Uni-Typed Languages)**，即整个语言中的所有值都是统一的、单一的递归类型。这一类型允许表示任意的计算和递归结构，因此无类型 λ-演算可以看作是带有一个默认类型的语言。

### 2. **λ-演算 (The λ-Calculus)**

**λ-演算** 是由阿隆佐·丘奇 (Alonzo Church) 在 1930 年代提出的，用于描述可计算函数的通用语言。它是研究函数的数学形式主义基础，其简洁性体现在以下几个方面：
- **唯一特性 (Higher-Order Function)**：在 λ-演算中，唯一的语言特性是高阶函数。所有内容都是函数，因此每个表达式都可以应用于一个参数，而参数本身也是一个函数，结果也必须是一个函数。换句话说，在 λ-演算中，一切都可以被看作是函数。
- **应用 (Application)**：在 λ-演算中，任何表达式都可以应用到另一个表达式上。由于每个表达式都是函数，因此即便是看似简单的数字或逻辑表达式也可以被视为函数应用。
  

**λ-演算的语法**：
- $λx.e$ 代表了一个函数，它接受参数 $x$ 并返回表达式 $e$。
- $(e_1 e_2)$ 表示函数 $e_1$ 应用到参数 $e_2$ 上。

例如，表达式 $λx.x$ 表示一个身份函数，它返回自身所接受的参数。

### 3. **可定义性 (Definability)**

**Definability** 在 λ-演算中探讨了哪些函数和表达式是可以定义的。在无类型 λ-演算中，任何可以通过函数应用和组合生成的函数都可以被定义。例如，最基本的函数（如恒等函数）可以轻松定义。重要的是，所有 λ-演算中的表达式都是通过函数的组合构建起来的。

### 4. **Scott 定理 (Scott's Theorem)**

**Scott 定理** 是 λ-演算中一个重要的结果，它探讨了如何通过 λ-演算来表示更复杂的函数，特别是那些可能不终止的函数。该定理揭示了 λ-演算与不动点定理的关系，从而允许定义递归函数。

在 λ-演算中，通过不动点运算符 (Fixed Point Operator)，我们可以定义递归函数，尽管没有类型的约束。递归函数是 λ-演算表达计算的核心工具之一，它使得 λ-演算具有 Turing 完备性。

### 5. **无类型即单类型 (Untyped Means Uni-Typed)**

在这一部分中，介绍了“无类型即单类型”的观点。所谓的 **无类型 λ-演算** 实际上可以理解为拥有一个单一递归类型的语言。这意味着所有的表达式实际上都属于同一种类型（尽管在语法层面上没有类型区分）。这一点为 λ-演算的强大计算能力奠定了基础，使其能够表示任意的递归结构和函数。

这一思想表明，**无类型 (Untyped)** 和 **有类型 (Typed)** 的对立并不那么根本。实际上，许多无类型的语言在某种程度上可以看作是拥有一个通用类型的单类型语言。因此，所谓的无类型 λ-演算并不是完全没有类型，而是默认所有表达式都属于一个递归类型。

### 6. **总结**

无类型 λ-演算是计算理论中的一个核心概念，它通过极简的形式化语法展现了计算的强大力量。尽管它被称为无类型系统，但实际上它是 **单类型系统** 的特例。无类型 λ-演算的主要特性包括：
- 一切皆函数，所有表达式都可以视作函数的应用。
- 通过函数的组合，任意的递归结构和函数都可以被定义。
- 通过不动点定理，递归函数得以定义，使 λ-演算具备了计算的完整性。

无类型 λ-演算作为现代编程语言理论的基础，启发了后来的许多编程语言，特别是在函数式编程中的应用。

### ---------------------------------

### 17.1 The λ-Calculus (λ-演算)

在本节中，我们讨论了 **λ-演算 (The λ-Calculus)**，它是一个极简的形式系统，几乎所有的编程语言理论都与其紧密相关。λ-演算的核心是函数的定义和应用。

### 1. **抽象语法 (Abstract Syntax)**

在 λ-演算中，表达式的抽象语法非常简洁，定义如下：

$$
\text{Exp } u ::= x \quad (\text{变量，variable})
$$
$$
\lambda(x.u) \quad (\lambda \text{抽象，λ-abstraction})
$$
$$
\text{ap}(u_1; u_2) \quad (\text{应用，application})
$$

解释：
- $x$ 表示变量。变量是 λ-演算中的基本单位。
- $\lambda(x.u)$ 表示一个 **λ-抽象 (λ-abstraction)**，即定义了一个接受参数 $x$ 并返回表达式 $u$ 的函数。
- $\text{ap}(u_1; u_2)$ 表示 **应用 (application)**，即将表达式 $u_2$ 作为参数应用于函数 $u_1$。

### 2. **静态语法 (Statics)**

λ-演算中的静态语法是通过 **假设性判断 (Hypothetical Judgments)** 来定义的，形式如下：

$$
x_1 \, \text{ok}, \ldots, x_n \, \text{ok} \vdash u \, \text{ok}
$$

这表示在给定变量 $x_1, \ldots, x_n$ 是合法的前提下，表达式 $u$ 也是合法的。此关系通过以下规则归纳定义：

#### 规则 17.1a: 变量规则
$$
\frac{\Gamma, x \, \text{ok} \vdash x \, \text{ok}}{}
$$
解释：在环境 $\Gamma$ 中，如果 $x$ 是一个合法的变量，那么表达式 $x$ 也是合法的。

#### 规则 17.1b: 应用规则
$$
\frac{\Gamma \vdash u_1 \, \text{ok} \quad \Gamma \vdash u_2 \, \text{ok}}{\Gamma \vdash \text{ap}(u_1; u_2) \, \text{ok}}
$$
解释：如果在环境 $\Gamma$ 中，$u_1$ 和 $u_2$ 都是合法表达式，那么应用 $u_1$ 到 $u_2$ 也是合法的。

#### 规则 17.1c: λ-抽象规则
$$
\frac{\Gamma, x \, \text{ok} \vdash u \, \text{ok}}{\Gamma \vdash \lambda(x.u) \, \text{ok}}
$$
解释：如果在环境 $\Gamma$ 中，给定 $x$ 作为合法变量，表达式 $u$ 是合法的，那么 λ-抽象 $\lambda(x.u)$ 也是合法的。

### 3. **动态语法 (Dynamics)**

在 λ-演算中，**动态语法 (Dynamics)** 使用 **定义性相等 (Definitional Equality)** 来表示表达式的等价关系，而不是使用转换系统。定义性相等的形式为：

$$
\Gamma \vdash u \equiv u' 
$$

其中，$\Gamma = x_1 \, \text{ok}, \ldots, x_n \, \text{ok}$ 是环境，$u$ 和 $u'$ 是包含这些自由变量的项。此关系通过以下规则定义：

#### 规则 17.2a: 自反性
$$
\frac{}{\Gamma \vdash u \equiv u}
$$
解释：任何表达式 $u$ 都与自己相等。

#### 规则 17.2b: 对称性
$$
\frac{\Gamma \vdash u \equiv u'}{\Gamma \vdash u' \equiv u}
$$
解释：如果 $u$ 与 $u'$ 相等，那么 $u'$ 与 $u$ 也相等。

#### 规则 17.2c: 传递性
$$
\frac{\Gamma \vdash u \equiv u' \quad \Gamma \vdash u' \equiv u''}{\Gamma \vdash u \equiv u''}
$$
解释：如果 $u$ 与 $u'$ 相等，并且 $u'$ 与 $u''$ 相等，那么 $u$ 与 $u''$ 也相等。

#### 规则 17.2d: 应用相等
$$
\frac{\Gamma \vdash e_1 \equiv e'_1 \quad \Gamma \vdash e_2 \equiv e'_2}{\Gamma \vdash \text{ap}(e_1;e_2) \equiv \text{ap}(e'_1;e'_2)}
$$
解释：如果 $e_1$ 与 $e'_1$ 相等，$e_2$ 与 $e'_2$ 相等，那么应用 $\text{ap}(e_1;e_2)$ 与 $\text{ap}(e'_1;e'_2)$ 相等。

#### 规则 17.2e: λ-抽象相等
$$
\frac{\Gamma, x \, \text{ok} \vdash u \equiv u'}{\Gamma \vdash \lambda(x.u) \equiv \lambda(x.u')}
$$
解释：如果在环境 $\Gamma$ 中，$u$ 与 $u'$ 相等，那么对应的 λ-抽象 $\lambda(x.u)$ 与 $\lambda(x.u')$ 也相等。

#### 规则 17.2f: β-归约
$$
\frac{\Gamma, x \, \text{ok} \vdash e_2 \, \text{ok} \quad \Gamma \vdash e_1 \, \text{ok}}{\Gamma \vdash \text{ap}(\lambda(x.e_2);e_1) \equiv [e_1/x]e_2}
$$
解释：这是 λ-演算中最重要的 **β-归约规则**，表示 λ-抽象的应用可以通过将参数 $e_1$ 替换到表达式 $e_2$ 中来进行归约。

### 4. **结论**

λ-演算是极简而强大的形式系统，通过三个基本操作：变量、λ-抽象和应用，实现了对函数的定义和计算。它是许多现代编程语言的理论基础，在研究计算过程、函数式编程以及类型论方面具有重要意义。

### ---------------------------------

### 17.2 Definability (可定义性)

#### **背景与重要性**
λ-演算 (The λ-Calculus) 的研究之所以引人注目，主要源于其令人惊讶的表达能力。它是 **图灵完备 (Turing-complete)** 的语言，这意味着它在对自然数进行计算的能力上，与任何已知的编程语言都具有相同的表达能力。

**丘奇定律 (Church’s Law)** 声明，任何可以想象的对自然数的可计算函数 (Computable Function) 的定义方法，都与 λ-演算等价。换句话说，不论未来定义计算的方式如何变化，它们在表达自然数函数的能力上，都不会超越 λ-演算。**丘奇定律** 作为一种科学定律，类似于牛顿的万有引力定律，它预言了所有未来对计算能力的定义与 λ-演算的等价性。

#### **证明思路**
要证明 λ-演算具有图灵完备性，我们的目标是展示 λ-演算可以定义与 PCF (Plotkin's Programming Language for Computable Functions) 等价的原语操作 (Primitives)。在第10章中，我们讨论了 PCF 中对自然数的操作，因此我们需要展示自然数如何用 λ-演算中的 **λ-项 (λ-terms)** 表示。

**关键任务** 包括:
1. 定义自然数的 λ-项表示。
2. 展示如何在 λ-演算中实现类似“分支判断”的操作，即区分自然数 0 和非零数。
3. 解决如何在 λ-演算中计算自然数的前驱 (Predecessor)。
4. 实现通用递归 (General Recursion)。

#### **定义自然数 (Church Numerals)**
自然数可以通过称为 **丘奇数 (Church numerals)** 的 λ-项来表示。首先，我们定义数值 0 和 n+1，如下：

- 数值 0 的 λ-项表示：
  $$
  0 \equiv \lambda(b) \lambda(s) \, b \tag{17.3a}
  $$
  - 解释：该表达式表示一个接受两个参数的函数，$b$ 表示基础值，$s$ 表示递归步长。当自然数为 0 时，返回基础值 $b$。

- 数值 n+1 的 λ-项表示：
  $$
  n+1 \equiv \lambda(b) \lambda(s) \, s(n(b)(s)) \tag{17.3b}
  $$
  - 解释：这表示对数值 $n$ 应用递归步长 $s$，并将基础值 $b$ 作为初始值。这意味着 $n+1$ 是通过在数值 $n$ 的基础上再应用一次步长 $s$ 来构造的。

我们可以推导出，任意自然数 $n$ 的 λ-项表示 $n(u_1)(u_2)$ 等价于以下形式：
$$
n(u_1)(u_2) \equiv u_2(...(u_2(u_1)))
$$
- 解释：这意味着 $n$ 表示从基础值 $u_1$ 开始，重复应用递归步长 $u_2$ 共 $n$ 次。因此，自然数 $n$ 就是对第二个参数的 $n$ 次迭代。

#### **举例解析**

举例来说，数值 2 的 λ-项可以写为：
$$
2 \equiv \lambda(b) \lambda(s) \, s(s(b))
$$
这表示从基础值 $b$ 开始，应用两次递归步长 $s$。

#### **自然数运算**
通过丘奇数的定义，我们可以进一步定义自然数的基本运算，比如加法、乘法和取前驱。以下是 λ-演算中定义这些操作的思路：

1. **加法 (Addition)**：可以通过对两个自然数的 λ-项组合，定义为将一个自然数对应的递归步长作用于另一个自然数。

2. **乘法 (Multiplication)**：可以定义为在 λ-演算中，通过嵌套地应用递归步长，表示对一个数的每一步都再应用另一个数的所有递归步。

3. **前驱 (Predecessor)**：前驱是一个较复杂的操作，需要在 λ-演算中通过特殊的构造来实现。

#### **通用递归 (General Recursion)**
λ-演算的另一个强大特性是其能够实现 **通用递归 (General Recursion)**，这意味着我们可以定义自引用的函数，解决复杂递归问题。在 λ-演算中，这可以通过 **Y组合子 (Y Combinator)** 等技巧来实现，它是一种能使递归定义在没有显式递归语句的语言中运行的方法。

### **总结**
通过定义自然数和递归操作，λ-演算展现了其图灵完备的特性。自然数的表达方式为 λ-演算中表示任意计算过程提供了基础。通过进一步定义加法、乘法等操作，我们可以证明 λ-演算能够表达任何已知的可计算函数。

### ---------------------------------

在未类型化的 $\lambda$-演算中，我们可以定义基本的算术函数，例如后继函数、加法和乘法。这些函数的定义如下：

1. **后继函数 (Successor Function)**：
   - **定义**：$ \text{succ} \equiv \lambda (x) \lambda (b) \lambda (s) \, s(x(b)(s)) $
   - **解释**：后继函数 $ \text{succ} $ 接受一个自然数表示的 λ-项 $x$，一个基础值 $b$，以及一个递归步长 $s$。它的工作机制是应用 $x$ 并将其迭代步长 $s$ 应用到结果上，再执行一次递归步长 $s$，相当于将自然数增加 1。

2. **加法 (Addition)**：
   - **定义**：$ \text{plus} \equiv \lambda (x) \lambda (y) \, y(x)(\text{succ}) $
   - **解释**：加法 $ \text{plus} $ 接受两个自然数表示的 λ-项 $x$ 和 $y$。它的工作方式是应用 $y$ 到 $x$ 和后继函数 $ \text{succ} $ 上，从而在 $x$ 的基础上增加 $y$ 个单位，即实现了 $x + y$。

3. **乘法 (Multiplication)**：
   - **定义**：$ \text{times} \equiv \lambda (x) \lambda (y) \, y(0)(\text{plus}(x)) $
   - **解释**：乘法 $ \text{times} $ 接受两个自然数表示的 λ-项 $x$ 和 $y$。它通过应用 $y$ 到 0 和 $x$ 的加法函数上，实现了 $x$ 和 $y$ 的相加多次，从而完成了 $x \times y$ 的计算。

这些基本函数都能在未类型化的 $\lambda$-演算中实现，且具有预期的功能，例如后继函数 $\text{succ}(n)$ 的结果为 $n+1$。

### **前驱函数 (Predecessor Function)**
接下来我们要定义前驱函数 $ \text{pred} $，使其满足以下条件：

1. $ \text{pred}(0) \equiv 0 $  （前驱函数在 $0$ 的值为 $0$）
2. $ \text{pred}(n+1) \equiv n $  （前驱函数在 $n+1$ 的值为 $n$）

#### **问题与挑战**
为了计算前驱，我们必须找到一种方法，在 $n+1$ 的基础上计算出 $n$。如果只是简单地取后继，这在一般情况下似乎有效，但在基数 $0$ 时就会遇到问题，因为前驱函数应该返回 $0$ 而不是负数。因此，我们不能直接应用后继的逆运算来实现前驱，需要采用其他方法。

#### **解决方法：使用移位寄存器的直觉**
一个有效的直觉是将计算过程想象成两个“移位寄存器” (shift registers)，这两个寄存器分别存储 $n$ 的前驱和 $n$ 本身，并在每次迭代时保持这个不变量：

- 在第 $n$ 次迭代时，这两个寄存器分别包含 $n-1$ 和 $n$。
- 当我们递推到 $n+1$ 时，通过向左移位并递增，寄存器将分别存储 $n$ 和 $n+1$。

对于基数情况 ($n=0$)，寄存器初始化为 $(0, 0)$，这确保了 $ \text{pred}(0) = 0$ 的定义。这种方法的精髓在于：我们不直接通过后继运算来倒推，而是通过构造包含前驱和当前值的配对，并通过移位机制来返回前驱值。

#### **定义前驱函数**
通过这种“移位寄存器”的机制，我们可以定义前驱函数为：
$$
\text{pred} \equiv \lambda n . \, n \, (\lambda p . \, \lambda b . \, (b \, (p(s))(p))) \, (\lambda p . \, (0, 0))
$$
- **解释**：$n$ 表示一个自然数，$\lambda p$ 是一个操作，模拟了寄存器的移位，每次迭代都更新寄存器的值。基数情况则初始化寄存器为 $(0, 0)$，从而使得 $ \text{pred}(0) = 0 $。

### **总结**
未类型化的 $\lambda$-演算不仅可以表示基本的算术运算如加法和乘法，还可以通过巧妙的构造定义复杂的函数如前驱函数。通过使用函数来模拟移位寄存器，我们能够避免直接的后继逆操作所带来的问题，并确保基数情况的正确性。

### ---------------------------------

要详细讲解你提供的这些内容，我们需要分解并逐步分析公式和其背后的逻辑。

### 1. **教会风格的有序对 (Church-style Representation of Ordered Pairs)**

首先，介绍有序对的表示。使用 λ-演算的教会风格，我们可以将有序对 $ \langle u_1, u_2 \rangle $ 表示为：
$$
\langle u_1, u_2 \rangle \equiv \lambda f . f(u_1)(u_2) \tag{17.9}
$$

- **解释**：这个定义说的是，给定两个值 $u_1$ 和 $u_2$，我们可以将它们作为参数传递给某个函数 $f$，该函数会应用到 $u_1$ 和 $u_2$。这种方式通过函数参数模拟了元组的概念。

接着，我们定义两个辅助函数来分别获取这个有序对的左值和右值：
$$
u \cdot l \equiv u(\lambda x . \lambda y . x) \tag{17.10}
$$
$$
u \cdot r \equiv u(\lambda x . \lambda y . y) \tag{17.11}
$$

- **解释**：$u \cdot l$ 表示获取有序对的第一个元素，即左投影（left projection），它会忽略第二个值，只返回第一个值。同理，$u \cdot r$ 表示获取有序对的第二个元素，即右投影（right projection），忽略第一个值。

可以验证，按照这种编码方式，有：
$$
\langle u_1, u_2 \rangle \cdot l \equiv u_1
$$
$$
\langle u_1, u_2 \rangle \cdot r \equiv u_2
$$

### 2. **前驱函数的定义 (Defining the Predecessor Function)**

现在我们来定义前驱函数 $ \text{pred} $。首先定义辅助函数 $u_0^p$：
$$
u_0^p \equiv \lambda x . x(\langle 0, 0 \rangle)(\lambda y . \langle y \cdot r, \text{succ}(y \cdot r) \rangle) \tag{17.12}
$$

- **解释**：$u_0^p$ 是一个辅助函数，用于计算前驱。它接受一个自然数 $x$，然后初始化两个寄存器（存储 $0$ 和 $0$），接着通过迭代，更新寄存器的值。每次迭代都会“左移”，即将右边的值变成左边的值，并递增右边的值。

最终的前驱函数 $ \text{pred} $ 定义为：
$$
u^p \equiv \lambda x . u_0^p(x) \cdot l \tag{17.13}
$$

- **解释**：$u^p$ 应用 $u_0^p$ 计算有序对，然后通过左投影获取前驱值。

### 3. **条件语句 ifz 的定义 (Defining ifz)**

接下来，我们定义条件语句 $ \text{ifz}(u; u_0; x.u_1) $，它类似于条件判断表达式，检查 $u$ 是否为 0：
$$
u(u_0)(\lambda () [u^p(u)/x]u_1)
$$

- **解释**：这个定义的作用是：如果 $u = 0$，那么返回 $u_0$，否则，将 $u$ 的前驱值赋值给 $x$，然后计算 $u_1$。

### 4. **Y 组合子 (Y Combinator) 的定义与推导**

为了实现通用递归，我们使用著名的 $Y$ 组合子，定义如下：
$$
Y \equiv \lambda F . (\lambda f . F(f(f)))(\lambda f . F(f(f))) \tag{Y}
$$

- **解释**：$Y$ 组合子用于寻找函数的**不动点** (fixed point)，即找到满足 $f = F(f)$ 的函数 $f$。它通过将函数 $F$ 应用到自身的副本来实现递归。

#### 为什么 $Y$ 组合子有效？

通过推导，我们可以验证 $Y$ 组合子确实能够找到不动点：
$$
Y(F) = F(Y(F)) \tag{Y}
$$

**推导过程**：
- 我们想要的递归函数 $F$，每次递归时都需要调用自身。因此，我们定义 $F'$ 为：
$$
F' = \lambda f . F(f(f))
$$
- 接着，$F'(F') = F(F'(F'))$，这意味着 $F'(F')$ 是 $F$ 的不动点。
- 因此，我们将 $F'$ 定义为函数 $f$ 的递归版本，使得 $f$ 调用自身。最终，$F'(F')$ 就是我们寻找的不动点。

### 总结

未类型化的 $\lambda$-演算非常灵活，通过 λ-项可以定义自然数及其相关操作，如加法、乘法、前驱等。通过引入 $Y$ 组合子，我们可以定义通用递归，这使得 $\lambda$-演算成为图灵完全的语言，能够表示所有可计算的函数。这种递归的实现本质上是通过将函数的副本应用到自身，从而实现自调用。这为构建复杂的函数结构和实现递归提供了强大的工具。

### ---------------------------------

### Scott's Theorem 详解

**Scott's Theorem (斯科特定理)**：斯科特定理指出，对于未类型化的 $\lambda$ 演算，定义性等价 (definitional equality) 是不可判定的：即没有算法能够确定两个未类型化的 $\lambda$ 项是否在定义上等价。

#### 定理内容解释：

1. **不可判定性 (Undecidability)**：斯科特定理表明，定义性等价在 $\lambda$ 演算中无法通过算法进行判定。具体来说，对于任意两个未类型化的 $\lambda$ 项 $u$ 和 $u'$，无法有一个通用的算法来判断 $u \equiv u'$ 是否成立。这种不可判定性是因为存在某些性质无法通过有限的计算过程来验证。

2. **不可分离性 (Inseparability)**：在证明过程中，我们引入了不可分离性 (inseparability) 的概念。不可分离性意味着对于某些性质 $A_0$ 和 $A_1$，没有一个可判定的性质 $B$ 可以同时满足：
   - 当 $A_0(u)$ 成立时，$B(u)$ 成立；
   - 当 $A_1(u)$ 成立时，$B(u)$ 不成立。
   
   这种不可分离性说明了某些性质之间的复杂性，它们无法通过简单的规则或判定来分辨。

3. **行为性质 (Behavioral Properties)**：行为性质 $A$ 是指，对于两个等价的未类型化的 $\lambda$ 项 $u$ 和 $u'$，如果 $u \equiv u'$，则 $A(u)$ 当且仅当 $A(u')$ 成立。也就是说，行为性质只关心项的行为，而不关心它们的具体结构。

#### 证明分解：

斯科特定理的证明分为两部分：

1. **构造满足等价条件的项**：对于任意未类型化的 $\lambda$ 项 $u$，我们可以找到另一个未类型化的 $\lambda$ 项 $v$，使得：
   $$
   u(pvq) \equiv v
   $$
   其中 $pvq$ 是项 $v$ 的 **Godel 数 (Godel-number)**，它是 $v$ 的一个编码。通过这种编码方式，我们可以将项转换为自然数表示。

2. **不可分离性**：对于任意两个非平凡的行为性质 $A_0$ 和 $A_1$，它们是不可分离的。这意味着我们无法找到一个性质 $B$ 来同时满足 $A_0$ 和 $A_1$ 的条件。

#### 证明关键引理 (Lemma 17.1) 解释：

**引理 17.1**：对于任意未类型化的 $\lambda$ 项 $u$，存在一个未类型化的项 $v$，使得 $u(pvq) \equiv v$。

**证明概述**：

该引理证明依赖于在未类型化 $\lambda$ 演算中定义两个操作：

1. **应用操作**：
   $$
   ap(pu_1q)(pu_2q) \equiv pu_1(u_2)q
   $$
   这个操作接收两个未类型化 $\lambda$ 项的表示，构造出一个表示它们应用结果的项。这意味着我们可以通过这种方式“组合”两个表示的项，形成它们的应用操作。

2. **数字操作**：
   $$
   nm(n) \equiv pnq
   $$
   这个操作将自然数 $n$ 转换为它的教会数表示，表示为 $\lambda$ 项。这一操作确保我们可以从自然数表示中构造出数字的表示。

通过这两个操作，我们可以构造出满足 $u(pvq) \equiv v$ 的项 $v$。定义如下：
$$
v \equiv w(pwq)
$$
其中：
$$
w \equiv \lambda x . u(ap(x)(nm(x)))
$$

我们接着推导：
$$
v = w(pwq)
$$
$$
\equiv u(ap(pwq)(nm(pwq)))
$$
$$
\equiv u(pw(pwq)q)
$$
$$
\equiv u(pvq)
$$

#### Y 组合子的类比：

我们可以将这个证明过程与 **Y 组合子** 相类比。Y 组合子通过递归地将函数应用于自身，找到函数的不动点。在这里，$u$ 接收一个项的表示，并找到一个项 $v$，使得当应用 $v$ 的表示时，$u$ 能够得到 $v$ 本身。这是通过构造项的自应用来实现的，与 Y 组合子的思想非常相似。

#### 总结：

- 斯科特定理通过不可分离性和递归构造，证明了未类型化的 $\lambda$ 演算中的定义性等价是不可判定的。
- 证明过程中引入了 Godel 数编码，使得未类型化的 $\lambda$ 演算能够表示自然数和项的结构。
- Y 组合子的思想在构造不动点时起到了关键作用，这展示了 $\lambda$ 演算在定义递归和不动点方面的强大能力。

### ---------------------------------

### Lemma 17.2: Behavior of Non-Trivial Properties in Untyped $\lambda$-Calculus

#### 引理 17.2 内容详解：
**引理 17.2**：假设 $A_0$ 和 $A_1$ 是未类型化 $\lambda$ 项的两个非平凡的行为性质 (behavioral properties)，那么不存在一个未类型化的项 $w$，使得以下条件同时满足：

1. 对于每一个 $u$，$w(puq) \equiv 0$ 或 $w(puq) \equiv 1$。
   - 这是说项 $w$ 可以对每一个项 $u$ 进行分类，要么返回 $0$，要么返回 $1$。

2. 如果 $A_0(u)$ 成立，则 $w(puq) \equiv 0$。
   - 这意味着，凡是满足性质 $A_0$ 的项，其对应的编码 $puq$ 应该让 $w$ 返回 $0$。

3. 如果 $A_1(u)$ 成立，则 $w(puq) \equiv 1$。
   - 同样的，凡是满足性质 $A_1$ 的项，其对应的编码 $puq$ 应该让 $w$ 返回 $1$。

这个引理的结论是：无法找到一个未类型化 $\lambda$ 项 $w$ 来同时满足这些条件。

#### **非平凡性质 (Non-Trivial Properties) 的定义**：
性质是**非平凡的**，如果它既不是对所有未类型化 $\lambda$ 项都成立，也不是对任何未类型化 $\lambda$ 项都不成立。因此，$A_0$ 和 $A_1$ 是对一部分项成立，对另一部分不成立的性质。

### **引理 17.2 的证明：**

我们假设存在一个未类型化 $\lambda$ 项 $w$，满足引理中提到的条件，并通过反证法来证明这种项是不可能存在的。

1. 定义一个未类型化的项 $v$ 如下：
   $$
   v \equiv \lambda (x) . \text{ifz}(w(x); u_1; u_0)
   $$
   - 这个项 $v$ 通过对 $w(x)$ 的结果进行分支：
     - 如果 $w(x) = 0$，则返回 $u_1$，满足性质 $A_1$；
     - 如果 $w(x) = 1$，则返回 $u_0$，满足性质 $A_0$。
   
   - 在此定义中，$A_0(u_0)$ 和 $A_1(u_1)$ 表示 $u_0$ 满足性质 $A_0$，而 $u_1$ 满足性质 $A_1$。

2. **使用 Lemma 17.1**，我们知道对于某个未类型化的项 $t$，有：
   $$
   v(p_tq) \equiv t
   $$

3. **假设 $w(p_tq) \equiv 0$**：
   - 由 $w(p_tq) = 0$ 可得：
     $$
     t \equiv v(p_tq) \equiv u_1
     $$
   - 因为 $A_1(u_1)$ 成立，且 $A_1$ 是行为性质 (behavioral property)，我们有 $A_1(t)$ 成立。因此，$w(p_tq)$ 应该返回 $1$，这与我们假设的 $w(p_tq) \equiv 0$ 矛盾。

4. **假设 $w(p_tq) \equiv 1$**：
   - 类似地，$w(p_tq) = 1$ 可得：
     $$
     t \equiv v(p_tq) \equiv u_0
     $$
   - 由于 $A_0(u_0)$ 成立，我们得到 $A_0(t)$ 成立。因此，$w(p_tq)$ 应该返回 $0$，这与假设的 $w(p_tq) \equiv 1$ 矛盾。

因此，不论 $w(p_tq) = 0$ 还是 $w(p_tq) = 1$，都会导致矛盾，这就证明了 $w$ 无法同时满足所有条件。

### **推论 17.3: 定义性等价的不可判定性 (Undecidability of Definitional Equality)**

推论 17.3 是由引理 17.2 推导出来的，其核心思想是证明**没有算法可以决定 $u \equiv u_0$ 是否成立**。这是通过如下方式来实现的：

1. 对于固定的项 $u$，我们可以定义一个性质 $E_u$，表示：
   $$
   E_u(u_0) \iff u_0 \equiv u
   $$

2. 性质 $E_u$ 是一个未类型化 $\lambda$ 项的非平凡行为性质。根据引理 17.2，它是与其否定性质不可分离的。

3. 由于性质 $E_u$ 和它的否定性质不可分离，无法有一个通用的算法来决定 $u \equiv u_0$ 是否成立。因此，定义性等价在未类型化的 $\lambda$ 演算中是不可判定的。

### 总结：

- 引理 17.2 通过行为性质和不可分离性证明了，无法找到一个项 $w$ 来同时满足对所有项进行分类和判断的需求。
- 进一步推导出的推论 17.3 表明，定义性等价在未类型化的 $\lambda$ 演算中是不可判定的，即无法有通用算法判断两个项是否定义上等价。这是未类型化 $\lambda$ 演算的一个关键复杂性。

### ---------------------------------

### 17.4 Untyped Means Uni-Typed

#### **未类型化 (Untyped) 和 单类型化 (Uni-Typed) 的等价性**

在这节中，我们探讨了**未类型化 $\lambda$ 演算**实际上并不是真正的“未类型化”，而是可以被视为一种**单类型化**（uni-typed）的语言。这意味着每个未类型化的 $\lambda$ 项都可以被嵌入到一个拥有递归类型的类型化语言中，并且这种嵌入是忠实的：未类型化 $\lambda$ 项的执行可以被其类型化表示的执行准确反映。

这个想法的核心在于未类型化的 $\lambda$ 演算实际上是只有一个类型的语言。这个单一的类型可以通过递归类型表示为：

$$
D = \mu t.t \to t
$$

这表示类型 $D$ 是递归类型，它的形式是一个从 $D$ 到 $D$ 的函数（$D \to D$）。我们可以通过“折叠”（folding）和“展开”（unfolding）操作在这个递归类型中转换值。

#### **递归类型的解释**

递归类型 $D$ 可以看作是一个方程的解：

$$
D \cong D \to D
$$

这个方程说明，$D$ 是一个与从 $D$ 到 $D$ 的函数空间同构的类型。在传统的集合论中，这样的结构是不存在的，因为集合不能与它的函数空间同构，但在 $\lambda$ 演算的计算框架中，这种同构关系是可行的。

#### **未类型化 $\lambda$ 演算到类型化语言的嵌入**

在类型化语言 $L\{+ \times * \mu\}$ 中，我们可以将未类型化的 $\lambda$ 演算嵌入到具有递归类型的类型化系统中。具体的嵌入规则如下：

1. 变量 $x$ 的嵌入保持不变：
   $$
   x^{\dagger} = x
   $$

2. $\lambda$ 抽象的嵌入通过递归类型的**折叠**操作实现：
   $$
   (\lambda (x) u)^{\dagger} = \text{fold}(\lambda (x:D) u^{\dagger})
   $$

3. 函数应用 $u_1(u_2)$ 的嵌入通过递归类型的**展开**操作实现：
   $$
   (u_1(u_2))^{\dagger} = \text{unfold}(u_1^{\dagger})(u_2^{\dagger})
   $$

#### **嵌入示例与 $\beta$-简化的实现**

我们通过嵌入 $\lambda$ 抽象和应用操作来实现 $\beta$-简化（$\beta$-reduction）。假设有一个 $\lambda$ 表达式 $\lambda (x) u_1(u_2)$，其嵌入过程如下：

$$
(\lambda (x) u_1(u_2))^{\dagger} = \text{unfold}(\text{fold}(\lambda (x:D) u_1^{\dagger}))(u_2^{\dagger})
$$

这实际上等价于：
$$
\lambda (x:D) u_1^{\dagger}(u_2^{\dagger})
$$

进一步展开为：
$$
[u_2^{\dagger}/x]u_1^{\dagger}
$$

这说明嵌入操作与 $\lambda$ 演算中的**代换**（substitution）是兼容的，因此 $\beta$-简化可以通过嵌入后的类型化项的评估来实现。

#### **未类型化和递归类型的关系**

最终，这个嵌入展示了所谓的“未类型化” $\lambda$ 演算其实是一个类型化的语言。未类型化语言并不是通过去除类型来增强它的表达能力，而是通过将无限多个类型合并为一个递归类型，从而简化了静态类型检查。这种方式尽管减少了静态类型检查的复杂性，但也带来了额外的动态开销，因为我们需要不断在递归类型的不同形式之间进行转换。

### 结论：

- **未类型化 $\lambda$ 演算**本质上是一种具有单一递归类型的**单类型化 $\lambda$ 演算**。
- 通过递归类型 $D = \mu t.t \to t$ 的嵌入，未类型化 $\lambda$ 演算可以嵌入到类型化语言中，并且这种嵌入是**忠实**的，能够保持 $\beta$-简化的行为。
- 动态类型检查实际上是静态类型系统的一种特殊形式，它集中在处理单一递归类型。

### ---------------------------------

### 17.5 Notes

**未类型化 λ 演算**（Untyped λ-calculus）是由**阿隆佐·丘奇**（Church, 1941）提出的，用来形式化描述可计算函数（computable function）的概念。与图灵机（Turing Machine）或随机存取机（Random Access Machine）等更著名的机器模型不同，λ 演算直接以数学和编程实践的形式对可计算性进行了编码。

#### **巴伦德雷特 (Barendregt, 1984)** 的工作

**巴伦德雷特**（Barendregt）在他的书中对**未类型化 λ 演算**的各个方面进行了深入探讨，他的著作《The Lambda Calculus: Its Syntax and Semantics》被认为是该领域的经典参考资料。**Scott 定理**的证明就是基于巴伦德雷特的阐述进行改编的。

#### **斯科特 (Scott, 1980)** 的贡献

**斯科特**（Scott, 1980）首次提出了未类型化 λ 演算的模型，使用了递归类型的优雅理论。这一理论为 λ 演算提供了一个模型，揭示了 λ 演算的真正本质，即它不是完全没有类型，而是单一类型化的（unityped）。斯科特形象地将 λ 演算描述为**单类型化**（uni-typed），而不是所谓的**未类型化**（untyped），因为所有的表达式都可以被看作是同一个递归类型 $D = \mu t.t \to t$ 的值。

这种理解帮助我们从一个更抽象的角度看待 λ 演算，它不仅是一种编程语言或可计算性模型，还揭示了类型理论与编程语言设计之间的深层联系。


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------
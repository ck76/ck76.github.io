[toc]



### Chapter 18: Dynamic Typing

**动态类型**（Dynamic Typing）是一种编程语言的类型系统，与**静态类型**（Static Typing）相对立。我们在第17章中看到，所谓的未类型化语言其实可以看作是拥有单一递归类型的统一类型化语言。在未类型化的 λ 演算中，这个递归类型的形式非常简单：所有的项都是函数，因此无法因错误使用值而导致运行时错误。唯一的值消解形式（elimination form）是函数应用，且函数的第一个参数必须是另一个函数。因此，未类型化 λ 演算本质上是无错的。

然而，当语言中引入多个值类别时，这种特性就会崩溃。例如，当我们将自然数作为原语加入到未类型化 λ 演算中时（而不是使用 Church 编码来定义它们），可能会发生运行时错误，例如试图将一个数字应用到一个参数上，或者试图将一个函数与一个数字相加。

有一种编程语言设计的思潮将这个缺点转化为优点，采用了一种多类值的单一类型模型。这样的语言被称为**动态类型语言**，它似乎与**静态类型语言**相对立。然而，这种所谓的对立实际上是虚幻的：正如所谓的未类型 λ 演算实际上是单类型化的语言一样，动态语言不过是静态语言的限制形式。

### 主要观点

- **统一类型化语言**：未类型化 λ 演算之所以能避免运行时错误，是因为它实际上是单一递归类型的语言，每个项都可以被视为某种递归类型的值。这里的递归类型形式为 $D = \mu t. t \to t$，即所有值都是函数。这种简化的模型保证了语言的安全性。
  
- **运行时错误的引入**：当引入多个值类型时，比如自然数，就可能导致运行时错误，例如将一个自然数应用为函数参数或者试图对函数和数值进行相加运算。

- **动态类型化语言的本质**：动态类型语言实际上是静态语言的受限形式。这意味着在动态类型语言中，我们仅仅是将自己限制在某种类型纪律下，通过运行时检查（而非编译时检查）来确保类型安全性。

### 动态类型语言的特性

动态类型语言允许程序在运行时检查类型，而不强制在编译时进行类型检查。这使得编程的灵活性和简便性提高，但同时增加了运行时的开销和潜在的运行时错误。

然而，从本质上来说，**动态类型化语言是静态类型化语言的特例**。它们可以被视为将所有可能类型（如函数、数字等）封装在一个递归类型中的静态语言。这意味着，即使在动态语言中，仍然可以通过静态类型系统对其进行解释，尽管这不是该语言的设计初衷。

### 结论

- 动态语言并非与静态语言完全对立，它们本质上是静态语言的一个特例，通过将所有类型封装在递归类型中来实现动态检查。
- 静态语言能够在编译时确保安全性，而动态语言则依赖于运行时检查。这种类型系统的转变，虽然提高了编写代码的灵活性，但也带来了更多的运行时错误风险。

### ---------------------------------

### 18.1 Dynamically Typed PCF

为了说明**动态类型**（Dynamically Typed）的概念，本节通过定义一个动态类型版本的语言 $L_{\text{dyn}}$，对比了其与之前讨论的**部分递归函数语言** $L_{\text{nat *}}$。动态类型语言通过允许在运行时对表达式进行类型检查来提升灵活性。具体而言，$L_{\text{dyn}}$ 的语法和 $L_{\text{nat *}}$ 的基本结构类似，但在处理不同类型的值时加入了运行时的标签（tagging）机制。

#### 语法（Syntax）

$L_{\text{dyn}}$ 的抽象语法如下：

- **变量**（Variable）: $x$
- **数字**（Numeral）: $num(n)$ 表示数字 $n$
- **零**（Zero）: $zero$
- **后继者**（Successor）: $succ(d)$ 表示后继运算
- **零测试**（Zero Test）: $ifz(d; d_0; x.d_1)$ 表示对 $d$ 的条件判断，如果 $d$ 是 $zero$，则执行 $d_0$，否则对 $succ(x)$ 执行 $d_1$
- **函数抽象**（Abstraction）: $fun(λ(x) d)$ 表示函数
- **函数应用**（Application）: $ap(d_1; d_2)$ 表示应用 $d_1(d_2)$
- **递归**（Recursion）: $fix(x.d)$ 表示递归定义

这个语法中有两类值：**数字**（numbers）和**函数**（functions）。数字的形式为 $n$，而函数的形式为 $λ(x).d$。一些表达式，如 $zero$ 和 $succ(d)$，不是值，它们是操作符，用于对表达式求值。通用递归可以通过固定点算子来定义，但在这里直接使用了原语形式 $fix$ 来简化动态行为的分析。

#### 标签系统（Tagging System）

$L_{\text{dyn}}$ 的具体语法常常带有误导性，隐去了在抽象语法中的一个关键细节：每个值在运行时都附带有一个**标签**（tagging），用来指明它的类型。在抽象语法中，数字和函数都带有标签。比如，数字 $n$ 在抽象语法中会标记为 $num(n)$，而函数 $λ(x).d$ 则标记为 $fun(λ(x).d)$，以区分函数和数字。

这个标签系统的核心目的是确保在运行时能够正确区分不同类别的值。虽然在具体语法中，数字 $n$ 似乎是“裸露的”表示形式，但在抽象语法中，它被标记为数值类 $num$，以防止它与函数类的值混淆。因此，当处理 $L_{\text{dyn}}$ 中的表达式时，必须时刻关注这些标签，因为它们在运行时发挥着至关重要的作用。

#### 静态检查（Statics）

$L_{\text{dyn}}$ 的静态规则与第17章中的 $L_{\text{λ}}$ 的静态检查非常相似，它主要检查表达式中是否存在自由变量（free variables）。形式化表示为：
$$
x_1 \ \text{ok}, \dots, x_n \ \text{ok} \vdash d \ \text{ok}
$$
意思是，在假设 $x_1, \dots, x_n$ 为有效的变量的前提下，表达式 $d$ 是良构的（well-formed）。当没有自由变量时，可以简写为 $d \ \text{ok}$，表示 $d$ 是 $L_{\text{dyn}}$ 中的闭合表达式。

### 解释动态语言与静态语言的差异

在静态类型语言中，类型检查发生在编译时，确保每个表达式的类型是安全的。而在动态类型语言中，类型检查发生在运行时。具体而言，在 $L_{\text{dyn}}$ 中，每个值都附带有类型标签，例如 $num$ 和 $fun$，在函数应用或其他运算时，解释器会根据这些标签判断是否能够执行操作。

例如，当我们对一个表达式 $succ(d)$ 求值时，如果 $d$ 是数字类型（带有 $num$ 标签），则可以执行 $succ$ 操作；而如果 $d$ 是函数类型（带有 $fun$ 标签），则会产生类型错误。这个检查过程完全发生在运行时，而不是在编译时。

动态类型语言的灵活性在于它允许更自由的表达式写法，但这种灵活性带来了额外的运行时开销和潜在的运行时错误。

### ---------------------------------

在 $L_{\text{dyn}}$ 动态类型语言中，**动态检查**是确保程序在运行时处理不同类型值的关键机制。这些动态检查的任务是捕捉在静态类型语言（如 $L_{\text{nat *}}$）中永远不会发生的错误。以下是对 $L_{\text{dyn}}$ 中涉及的各种**判断形式**的详细解释。

### 判断形式概述

- **值判断**（Value Judgment）: $d \ \text{val}$  
  表示 $d$ 是一个**完全求值后的值**。  
- **单步求值判断**（One-Step Evaluation Judgment）: $d \to d'$  
  表示 $d$ 在一步中求值为 $d'$。  
- **错误判断**（Error Judgment）: $d \ \text{err}$  
  表示 $d$ 在运行时发生了错误。  
- **数值类型判断**（Numerical Class Judgment）: $d \ \text{is num} \ n$  
  表示 $d$ 是数值类，且其值为 $n$。  
- **非数值判断**（Non-Numerical Class Judgment）: $d \ \text{isn't num}$  
  表示 $d$ 不是数值类。  
- **函数类型判断**（Function Class Judgment）: $d \ \text{is fun} \ x.d$  
  表示 $d$ 是函数类，且其函数体为 $λ(x).d$。  
- **非函数判断**（Non-Functional Class Judgment）: $d \ \text{isn't fun}$  
  表示 $d$ 不是函数类。

上述的**最后四个判断形式**涉及动态类检查，它们只有在 $d$ 已经被确定为值的情况下才相关。对于肯定类检查（affirmative class-checking）来说，第二个参数表示值的底层结构，而这个参数本身并不是一个值。

### **值判断**（$d \ \text{val}$）

值判断表明表达式 $d$ 是一个完全求值的闭合表达式。具体定义规则如下：

- 对于数字类 $n$：  
  $$
  \frac{}{\text{num}(n) \ \text{val}} \tag{18.1a}
  $$
  表示数值 $num(n)$ 是一个值。

- 对于函数类 $λ(x).d$：  
  $$
  \frac{}{\text{fun}(λ(x).d) \ \text{val}} \tag{18.1b}
  $$
  表示函数抽象 $fun(λ(x).d)$ 是一个值。

### **类检查**（Class Checking）

#### 肯定类检查（Affirmative Class Checking）

肯定类检查用于确认值 $d$ 是否属于特定类别：

- 对于数值 $n$：  
  $$
  \frac{}{\text{num}(n) \ \text{is num} \ n} \tag{18.2a}
  $$
  表示 $num(n)$ 属于数值类，且其值为 $n$。

- 对于函数 $λ(x).d$：  
  $$
  \frac{}{\text{fun}(λ(x).d) \ \text{is fun} \ x.d} \tag{18.2b}
  $$
  表示 $fun(λ(x).d)$ 属于函数类，且其函数体为 $λ(x).d$。

#### 否定类检查（Negative Class Checking）

否定类检查用于排除值不属于某一类的情况：

- 数值 $num(n)$ 不能是函数类：  
  $$
  \frac{}{\text{num}(n) \ \text{isn't fun}} \tag{18.3a}
  $$

- 函数 $fun(λ(x).d)$ 不能是数值类：  
  $$
  \frac{}{\text{fun}(λ(x).d) \ \text{isn't num}} \tag{18.3b}
  $$

### **求值和错误判断**（Evaluation and Error Judgments）

#### 单步求值（Transition Judgment）

单步求值描述表达式 $d$ 如何在一步中求值为 $d'$，具体规则如下：

- **零的求值**：  
  $$
  \frac{}{\text{zero} \ 7→ \ \text{num}(z)} \tag{18.4a}
  $$
  表示 $zero$ 求值为数值 $num(z)$。

- **后继者的求值**：  
  $$
  \frac{d \ 7→ \ d'}{\text{succ}(d) \ 7→ \ \text{succ}(d')} \tag{18.4b}
  $$
  表示如果 $d$ 能求值为 $d'$，则 $succ(d)$ 可以求值为 $succ(d')$。

#### 错误判断（Error Judgment）

错误判断则涉及那些在运行时产生错误的情况。例如，当试图将一个数值应用为函数时，应该发出错误。这些错误判断是动态语言中特有的，在静态类型语言中不会出现。

### 总结

在动态类型语言 $L_{\text{dyn}}$ 中，动态检查系统的核心是确保每个操作符作用在正确的值类型上。通过这些动态类检查和求值规则，$L_{\text{dyn}}$ 提供了一种机制，在运行时捕捉那些在静态类型语言中可以通过编译器捕捉的类型错误。

### ---------------------------------

在 $L_{\text{dyn}}$ 中，**动态类型检查**确保每个操作符在运行时作用于正确的类型值上。通过一系列规则来判断表达式的值、求值过程和可能的错误。以下是对这些规则的逐步解析和说明：

### 错误判断和求值规则
1. **错误规则**：
   - 对于表达式 $succ(d)$，如果 $d$ 不是一个数值类，则会触发运行时错误：
     $$
     \frac{}{\text{succ}(d) \ \text{err}} \tag{18.4c}
     $$

2. **成功求值规则**：
   - 如果 $d$ 是数值类且表示数字 $n$，那么 $succ(d)$ 的求值结果是 $num(s(n))$，即成功递增 $n$ 的值：
     $$
     \frac{\text{d is num n}}{\text{succ}(d) \ 7→ \ \text{num}(s(n))} \tag{18.4d}
     $$

3. **数值类检查失败时的错误**：
   - 如果 $d$ 不是数值类，则应用 $succ$ 会产生错误：
     $$
     \frac{\text{d isnt num}}{\text{succ}(d) \ \text{err}} \tag{18.4e}
     $$

### 条件分支的求值
4. **条件语句的单步求值**：
   - 如果条件表达式 $d$ 还未完全求值，则继续对 $d$ 进行求值：
     $$
     \frac{d \ 7→ \ d'}{\text{ifz}(d; d_0; x.d_1) \ 7→ \ \text{ifz}(d'; d_0; x.d_1)} \tag{18.4f}
     $$

5. **条件表达式中的错误**：
   - 如果 $d$ 发生错误，那么整个条件语句都会发生错误：
     $$
     \frac{d \ \text{err}}{\text{ifz}(d; d_0; x.d_1) \ \text{err}} \tag{18.4g}
     $$

6. **零值分支**：
   - 如果 $d$ 是数值 $0$，则条件语句的结果为 $d_0$：
     $$
     \frac{\text{d is num 0}}{\text{ifz}(d; d_0; x.d_1) \ 7→ \ d_0} \tag{18.4h}
     $$

7. **非零分支**：
   - 如果 $d$ 是 $n+1$，则执行分支 $d_1$，并用 $num(n)$ 替换变量 $x$：
     $$
     \frac{\text{d is num n+1}}{\text{ifz}(d; d_0; x.d_1) \ 7→ \ [num(n)/x]d_1} \tag{18.4i}
     $$

8. **错误类型检查**：
   - 如果 $d$ 不是数值类，那么整个条件表达式将发生错误：
     $$
     \frac{\text{d isnt num}}{\text{ifz}(d; d_0; x.d_1) \ \text{err}} \tag{18.4j}
     $$

### 函数应用的求值
9. **函数应用中的求值**：
   - 如果函数部分 $d_1$ 还未完全求值，继续对其求值：
     $$
     \frac{d_1 \ 7→ \ d_1'}{\text{ap}(d_1; d_2) \ 7→ \ \text{ap}(d_1'; d_2)} \tag{18.4k}
     $$

10. **应用中的错误传播**：
   - 如果函数部分 $d_1$ 发生错误，整个应用也会发生错误：
     $$
     \frac{d_1 \ \text{err}}{\text{ap}(d_1; d_2) \ \text{err}} \tag{18.4l}
     $$

11. **函数应用的成功求值**：
   - 如果 $d_1$ 是一个函数 $λ(x).d$，则应用 $d_1(d_2)$ 的结果是将 $d_2$ 替换为 $x$ 后的函数体 $d$：
     $$
     \frac{d_1 \ \text{is fun} \ x.d}{\text{ap}(d_1; d_2) \ 7→ \ [d_2/x]d} \tag{18.4m}
     $$

12. **应用中的错误类型检查**：
   - 如果 $d_1$ 不是函数类，则应用将产生错误：
     $$
     \frac{d_1 \ \text{isn't fun}}{\text{ap}(d_1; d_2) \ \text{err}} \tag{18.4n}
     $$

### 递归的求值
13. **递归的求值**：
   - $fix(x.d)$ 的求值结果是将 $fix(x.d)$ 替换到 $x$ 中的函数体 $d$，即递归展开：
     $$
     \frac{}{\text{fix}(x.d) \ 7→ \ [\text{fix}(x.d)/x]d} \tag{18.4o}
     $$

### 相关定理
#### **类检查引理（Lemma 18.1）**：
对于任意值 $d$，有以下两种可能：
1. $d$ 是数值类，或者 $d$ 不是数值类。
2. $d$ 是函数类，或者 $d$ 不是函数类。

#### **进展定理（Theorem 18.2）**：
如果 $d$ 是一个合法的表达式，则：
- 要么 $d$ 是一个值；
- 要么 $d$ 发生错误；
- 要么存在 $d'$ 使得 $d$ 在一步求值后成为 $d'$。

#### **排他性引理（Lemma 18.3）**：
对于 $L_{\text{dyn}}$ 中的任意表达式 $d$，以下三种情况之一必然成立：
- $d$ 是一个值；
- $d$ 发生错误；
- $d$ 可以进一步求值为 $d'$。

### 总结

通过这些规则，$L_{\text{dyn}}$ 实现了动态检查和处理错误的机制。系统会确保每个表达式在运行时能正确处理不同的值类型，且通过动态类型检查，捕捉运行时可能出现的类型错误。

### ---------------------------------

在这一节中，主要讨论了动态语言 $L_{\text{dyn}}$ 的变化和扩展，以及它与之前介绍的静态语言 $L_{\text{nat}^*}$ 的差异。

### **自然数的处理差异**

在 $L_{\text{dyn}}$ 和 $L_{\text{nat}^*}$ 中，自然数的处理方式存在显著差异：

- 在 $L_{\text{nat}^*}$ 中，**零（zero）**和**后继（succ）**是自然数类型的构造形式（introductory forms）。这意味着它们是用于定义自然数的基本构造。
  
- 而在 $L_{\text{dyn}}$ 中，**零**和**后继**则是消解形式（elimination forms），即它们是在动态环境下定义并操作的数值（numerals）。这是为了确保所有自然数都属于同一类，而不是分别有单独的类来表示零和后继。

这种区别的动机是简化数值类（numbers）的实现，不再单独区分零和后继数，但同时也引入了其他的复杂性。

### **替代处理方法**

一种替代方法是将 **zero** 和 **succ(d)** 视为不同类的值，类似于静态类型系统中的处理方式。这种方式的主要变化是需要为零和后继引入显式的类检查规则：

- **条件判断的动态分支规则**如下：
  - 如果 $d$ 尚未完全求值，则继续求值：
    $$
    \frac{d \rightarrow d'}{\text{ifz}(d; d_0; x.d_1) \rightarrow \text{ifz}(d'; d_0; x.d_1)} \tag{18.5a}
    $$
  
  - 如果 $d$ 是零（zero），则返回 $d_0$：
    $$
    \frac{\text{d is zero}}{\text{ifz}(d; d_0; x.d_1) \rightarrow d_0} \tag{18.5b}
    $$

  - 如果 $d$ 是后继（succ），则执行 $d_1$，并用 $d_0$ 替换变量 $x$：
    $$
    \frac{\text{d is succ d'}}{\text{ifz}(d; d_0; x.d_1) \rightarrow [d'/x] d_1} \tag{18.5c}
    $$

  - 如果 $d$ 既不是零也不是后继，则发生错误：
    $$
    \frac{\text{d isn't zero and isn't succ}}{\text{ifz}(d; d_0; x.d_1) \text{err}} \tag{18.5d}
    $$

### **扩展：结构化数据**

通过类似的技术，可以向 $L_{\text{dyn}}$ 中添加**结构化数据**。一个经典的例子是引入空值（null）和构造器（constructor）来组合两个值：

- **抽象语法**：
  - **nil** 表示空值。
  - **cons(d_1; d_2)** 表示组合两个值形成的对偶（pair）。
  - **ifnil(d; d_0; x, y.d_1)** 是条件分支，用于区分空值和对偶。

示例如下：
- 空值：`nil`
- 对偶：`cons(d_1; d_2)` 用于将两个值组合成一个对偶。

- **ifnil** 的条件判断形式如下：
  - 如果 $d$ 是空值，则返回 $d_0$；
  - 如果 $d$ 是对偶，则将对偶的两个组成部分绑定到 $x$ 和 $y$，然后执行 $d_1$；
  - 否则发生错误。

### **列表表示**

在 $L_{\text{dyn}}$ 中，可以通过空值和对偶构造列表。例如，一个包含三个零的列表可以表示为：
$$
\text{cons}(\text{zero}; \text{cons}(\text{zero}; \text{cons}(\text{zero}; \text{nil})))
$$
这是一个有效的列表，因为它以 $nil$ 结束。

但是，如果构造如下形式的表达式：
$$
\text{cons}(\text{zero}; \text{cons}(\text{zero}; \text{cons}(\text{zero}; \lambda(x) x)))
$$
这就不再是一个有效的列表了，因为它没有以 $nil$ 结束，而是以一个函数 $\lambda(x) x$ 结束。

### **总结**

本节讨论了 $L_{\text{dyn}}$ 的变体和扩展，尤其是数值和结构化数据的处理。通过引入更多的动态类型和结构，语言的表达能力得到了扩展，但也引入了更多的类型检查和错误处理的需求。

### ---------------------------------

在这一节中，我们探讨了在动态类型语言中处理列表及其他数据结构的复杂性，尤其是通过动态类型构造（如 null 和 pair）编码列表时所遇到的问题。

### **列表连接（Append）的定义问题**

首先，我们来看看**连接两个列表的函数**定义：

$$
\text{fix} \ a \ \text{is} \ \lambda(x) \ \lambda(y) \ \text{ifnil}(x; y; x_1, x_2.\text{cons}(x_1; a(x_2)(y)))
$$

这段代码的主要功能是遍历第一个列表 $x$，将其每个元素和第二个列表 $y$ 连接起来。如果第一个列表为空 ($x$ 为 null)，则返回第二个列表；否则，它将递归调用自身，处理第一个列表的其余部分。

然而，在这种编码方式下，**存在一个问题**：**函数可以接受任何值作为参数**，无论这些值是否是列表。如果第一个参数不是列表，则在执行时会因为无法匹配 `null` 而抛出错误。然而，第二个参数可以是任何值，因为函数并不对第二个参数进行遍历，例如，你可以将一个列表与一个函数相连接，并得到一个以 $\lambda$ 表达式为结尾的“列表”。

#### **基于模式匹配的局限性**

我们进一步思考，模式匹配（如 `ifnil` 中对 null 和 pair 的匹配）在 $L_{\text{dyn}}$ 中可能不适用。因为在这个语言中，可能会存在不止这两类数据类型（如函数和数值），这使得基于 null 和 pair 的模式匹配显得有限。

### **更通用的条件分支和谓词**

为了解决这个问题，一种替代方案是**放弃数据类的模式匹配**，转而引入更一般的条件分支，允许区分 $null$ 和所有其他值，并**添加一些谓词（predicates）和解构器（destructors）**。这些谓词和解构器可以测试值的类别，并从每个类别中提取出相关的数据。

#### **扩展的表达式定义**

我们扩展了 $L_{\text{dyn}}$ 的表达式定义，新增了以下操作符：

- **cond(d; d_0; d_1)**: 一个通用的条件分支操作符，区分 $d$ 是否为 null。若 $d$ 为 null，返回 $d_0$；否则返回 $d_1$。
- **nil?(d)**: 测试 $d$ 是否为 null，若是则返回 $nil$，否则返回非 null 值。
- **cons?(d)**: 测试 $d$ 是否为对偶值（pair），类似于 $nil?$
- **car(d)**: 从对偶中提取第一个值。
- **cdr(d)**: 从对偶中提取第二个值。

这些操作符可以有效地将 $L_{\text{dyn}}$ 拓展为支持更多复杂结构的语言。通过这些操作符，我们可以定义更为通用的列表操作函数。

#### **基于谓词和解构器的连接函数**

在引入上述机制后，我们可以重新定义**列表连接函数**，如下所示：

$$
\text{fix} \ a \ \text{is} \ \lambda(x) \ \lambda(y) \ \text{cond}(x; \text{cons}(\text{car}(x); a(\text{cdr}(x))(y)); y)
$$

- 这段代码的功能与原先类似，区别在于使用了更加通用的 $cond$ 代替了 $ifnil$。
- $car$ 和 $cdr$ 分别用于从对偶中提取第一个和第二个元素。
- 这样，函数不再依赖模式匹配，而是通过测试谓词和解构器来进行处理。

### **问题：非列表操作的容忍度**

即使我们已经引入了新的语法结构，编码的问题依然存在：我们可能会遇到非列表的值。例如，$cons(\text{zero}; \lambda(x) x)$ 这样的表达式，它并不是一个合法的列表，因为它以一个函数结束，而不是 $nil$。这意味着我们需要引入更多的运行时检查来捕捉这些异常。

### **动态语言的固有限制**

一种广泛使用的替代方案是扩展条件分支，使其能够处理每种可能的数据类型。例如，在一个具有数值、函数、null 和对偶的语言中，我们可以将条件分支扩展为四个分支。每个分支针对一种数据类型进行处理。

然而，这种方法的复杂性在于，**实际编程语言中存在大量的数据类型**，这会使得条件分支变得非常复杂、臃肿。更为重要的是，即使我们能够确定一个值属于某个特定的数据类，仍然无法将该信息有效传递到条件分支的内部。例如，我们可以判断某个值 $d$ 是数值，但在执行加法操作时，仍然需要进行类型检查，并恢复原始数值。

这反映了**动态语言的一个固有限制**：它无法在静态类型系统下对类型进行完整推断和优化，而必须在运行时进行值的分类和处理。

### **总结**

通过对动态类型语言的扩展，本节探讨了如何处理更复杂的数据结构如列表，并展示了如何通过通用谓词和解构器来避免模式匹配中的问题。然而，这也暴露了动态语言的固有限制：无法在编译时静态推断值的类型，必须依赖于运行时的类型检查。

### ---------------------------------

### **18.3 Critique of Dynamic Typing (动态类型的批判)**

本节讨论了动态类型系统的优缺点，尤其是在动态类型语言 $L_{\text{dyn}}$ 中，动态类型安全性定理经常被视为动态类型优于静态类型的一个优势。然而，**动态类型的优势在某种情况下也可能成为劣势**，因为在静态类型语言中，编译器可以在编译时检测出类型错误，而动态类型则需要在运行时进行检测。这会增加运行时的开销，并可能推迟错误的发现。

### **动态类型的安全性 (Safety in Dynamic Typing)**

在动态类型语言 $L_{\text{dyn}}$ 中，**几乎所有抽象语法的程序都是良构的**，这意味着它们可以通过编译并在运行时执行。而在静态语言中，某些程序由于类型不匹配在编译时就会被拒绝。这种灵活性被认为是动态类型语言的一个优点。

然而，动态类型的灵活性带来了另一个问题：**本应在编译时检测出的错误**，例如类型不匹配等，**必须在运行时进行检测**。这意味着我们要为这些类型检查和错误处理付出额外的运行时成本。

### **动态类型中的示例——加法函数**

考虑 $L_{\text{dyn}}$ 中的一个**加法函数**，其规范是：当传入两个数值类型的参数时，返回它们的和，结果也是数值类型。这个加法函数的定义如下：

$$
\text{fun}(\lambda(x) \ \text{fix}(p.\text{fun}(\lambda(y) \ \text{ifz}(y; x; y_0.\text{succ}(p(y_0))))))
$$

### **具体语法中的加法函数**

用具体语法表示加法函数如下：
$$
\lambda(x) \ \text{fix} \ p \ \text{is} \ \lambda(y) \ \text{ifz} \ y \ \{ \text{zero} \Rightarrow x \ | \ \text{succ}(y_0) \Rightarrow \text{succ}(p(y_0)) \}
$$

这个函数看似很直观，但它隐藏了关于值类型标签的操作以及这些标签有效性的检查。接下来，我们详细分析这种标签检查的运行时成本。

### **动态类型的运行时检查成本**

1. **递归调用中的冗余检查**

加法函数的递归部分通过 $p$ 实现，其中 $p$ 绑定到一个函数值。动态类型系统中，**每次递归调用 $p$ 时，都会进行函数类型的检查**，即确认 $p$ 是一个函数。尽管在 $L_{\text{dyn}}$ 中，这个检查在递归调用中是可以保证成功的，但我们无法抑制这种冗余的检查，因为动态类型系统无法表达这种“不需要重复检查”的不变量。

2. **后继操作中的冗余检查**

在加法函数中，递归调用返回的是 $x$ 或者 $\text{succ}(p(y_0))$。其中，$\text{succ}$ 操作会检查其参数是否为数值类型，即是否属于 $num$ 类。然而，除了基例（返回 $x$）外，这个检查几乎总是成功的。实际上，$x$ 的类型可以在一开始就确定，但动态类型系统中无法表示这种不变量。因此，**后继操作中的冗余检查无法避免**。

3. **条件判断中的冗余检查**

加法函数的递归参数 $y$ 要么是最初传递给函数的参数，要么是前一个递归调用的前驱（predecessor）。只要最初的参数 $y$ 是数值类型，那么递归调用中的所有参数都应是数值类型。然而，**动态类型系统无法表达这种类型不变性**，因此条件判断语句必须在每次递归调用时进行类型检查，无法避免。

### **动态类型的开销**

在动态类型系统中，**分类操作（classification）并不是免费的**。首先，系统需要存储每个值的类型标签；其次，每次使用值时，都需要拆除（detach）其类型标签；最后，每次创建新值时，都需要重新附加（attach）类型标签。虽然这些操作不会从渐进时间复杂度上显著影响程序性能（它们只会引入一个常数因子），但这些**冗余的运行时检查**会带来非忽略不计的开销。

### **为何静态类型系统可以避免这些开销**

在静态类型系统中，所有这些类型检查都可以在**编译时完成**，并且通过类型系统可以**表达并维护这些不变量**，从而避免运行时冗余的类型检查。例如：

- 可以明确规定函数参数的类型，避免每次调用时的类型检查。
- 可以通过编译器推导出递归函数中的不变量，从而避免递归调用中的类型检查。

因此，**静态类型系统能够通过提前捕捉类型错误并维护不变量，减少运行时的开销**。这是动态类型系统所无法做到的。

### **总结**

尽管动态类型系统允许程序具有更大的灵活性，但它也带来了不可避免的运行时开销，主要体现在**冗余的类型检查**上。这些检查在静态类型语言中可以通过编译时类型检查完全避免。因此，尽管动态类型系统能够使程序更具表达力，但它也在性能和类型安全性方面做出了一些妥协。这表明，**静态类型系统在很多情况下能够更加高效和安全**。

### ---------------------------------

### 18.4 **Notes** (注释)

本节讨论了动态类型语言的起源及其对编程语言设计的持续影响，并对动态类型和静态类型的关键差异进行了澄清。

#### **动态类型语言的起源：Lisp**

最早的动态类型语言是 **Lisp**，由 **John McCarthy** 于1965年发明。Lisp 在编程语言历史上具有重要地位，它在诞生的半个世纪后仍然对语言设计产生深远影响。

Lisp 的设计核心之一是**动态类型检查**，这意味着变量的类型在运行时检查，而不是在编译时。这种灵活性使得 Lisp 成为**动态类型语言**的经典代表，也奠定了其在后续语言设计中的基础地位。

#### **动态 PCF 的性质**

**动态 PCF (Dynamic PCF)** 是一种动态类型语言，本质上与 Lisp 类似，但它对**变量绑定**进行了更严格的处理。McCarthy 自己也承认，Lisp 的最初设计在变量绑定的处理上存在缺陷，而动态 PCF 修正了这个问题。

在动态语言的讨论中，通常忽略了许多关键细节，尤其是**动态检查**的部分。本文中的动态 PCF 明确指出了这些动态检查的存在，而在许多非正式的讨论中，这些动态检查常常被省略。这种省略可能导致混淆，使得动态语言看起来与静态语言区别不大。

#### **动态 PCF 与静态 PCF 的差异**

尽管动态 PCF 和静态 PCF 在**表面语法**上几乎一致（除了静态 PCF 有类型注释，动态 PCF 没有），但它们的**底层运行机制**截然不同。动态 PCF 依赖于运行时的类型检查，而静态 PCF 则依赖于编译时的类型检查。

因此，**静态 PCF 不能简单地被看作是动态 PCF 加上类型系统的结果**。这与普遍的误解相反，实际上，动态 PCF 和静态 PCF 在处理类型和程序执行的方式上存在**本质区别**。动态 PCF 的运行依赖于运行时的类型动态分类，而静态 PCF 则通过类型系统在编译时就确保类型安全性。

### **总结**

Lisp 是最早的动态类型语言，动态 PCF 可以看作其核心，但对变量绑定进行了修正。虽然动态 PCF 和静态 PCF 表面上非常相似，但它们在**运行时行为**上存在根本性差异，动态 PCF 强调运行时检查，而静态 PCF 强调编译时的类型验证。


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------
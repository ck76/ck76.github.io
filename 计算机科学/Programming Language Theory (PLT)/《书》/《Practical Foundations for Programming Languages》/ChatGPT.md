



```
我现在在阅读一本书《Practical Foundations for Programming Languages》它的内容可能涉及：计算机科学、类型论、范畴论、代数、逻辑学、群论、拓扑学等领域等...但是主要还是和程序语言设计原理相关。

现在我希望我帮助我有条理的理解它的内容。包括解释内容和各种概念的历史，原因，解释等等等等...各个方面的内容。（不止局限于这些）

我的任务是帮我拓宽我的视野，不局限于这本书，帮我从更加全方位的视野理解和学习【《Practical Foundations for Programming Languages》】【编程语言设计原理】等领域的知识。

我提供给我的内容可能是英文的，但是解释的时候请用中文，但是关键的概念名词用中英双语:中文(English)，这样有助于记忆。

解释的时候改用公式用公式进行解释，然后公式需要详解。因为它们总是很抽象，使用很多符号。所以我需要解释它们的意思以及公式的意思作用等等。
---
该使用公式的时候请使用公式，然后提供相应的公式的详细讲解。
请一定要注意这一点：行内公式和特殊字符只用单$包裹。只有多行公式采用双$$包裹。这样就符合标准markdown语法了。
比如行内(这些需要嵌入到段落的句子中):对于 $a:A$ 我们有 $f(a) \equiv \Phi '$ 和$a$,$word$,$a$,$\sqrt{2}  + \left ( \lim_{x \to 0}  \right )$, $A \to B$,$U_0, U_1, U_2, \ldots$ 这样的只用单美元符包裹就够了。
比如下面这样的
$$
\begin{aligned}
\text{pr}_1:A\times B \to A \\
\text{pr}_2:A\times B \to B
\end{aligned}
$$

$$
a^2 + b^2 &= c^2 \\ %使用\\换行
e^{i\pi} + 1 &= 0
$$

$$
\int_{a}^{b} f(x) \, dx = F(b) - F(a)
$$
需要单独占用一行或者多行而不是嵌入到段落中的公式用双美元符$$包裹。

-----
还有：
请注意，每个公式在开始的时候都应该存在一个推导横线。
然后
多层推导树的话，每一层都要像这样分隔开：
$$
\frac{}{\text{empty tree}} \quad \frac{}{\text{empty tree}} 
$$
$$
\quad \frac{\frac{}{\text{empty tree}} \quad \frac{}{\text{empty tree}}}{\text{node(empty; empty) tree}} 
$$
$$
\quad \frac{\frac{\frac{}{\text{empty tree}} \quad \frac{}{\text{empty tree}}}{\text{node(empty; empty) tree}} \quad \frac{}{\text{empty tree}}}{\text{node(node(empty; empty); empty) tree}}
$$
----


涉及的的代码程序段需要添加注释并且详细讲解代码。
---

我会逐步提供给我内容，然后请给我讲解，关于讲解的时候，请不要省略任何内容。
```








```

我的需求可以总结为以下几点：

1. **阅读背景**：  
   - 我正在阅读《Practical Foundations for Programming Languages》这本书，内容涉及多个学科领域，如：计算机科学(Computer Science)、类型论(Type Theory)、范畴论(Category Theory)、代数(Algebra)、逻辑学(Logic)、群论(Group Theory)、拓扑学(Topology)等。
   - 主要聚焦在**编程语言设计原理**(Programming Language Design Principles)。

2. **理解需求**：  
   - 我希望系统性、条理性地理解书中的内容，并要求对内容、概念的**历史背景**、**原因**和**详细解释**等进行全方位解析。
   - 我不仅希望理解书中的内容，还希望通过学习这本书，拓宽视野，**不局限于书本**，帮助我全面理解**编程语言设计原理**和相关学科领域的知识。

3. **解释要求**：  
   - **我可能会提供给我英语，但是使用中文进行解释**，但是所有**关键概念**必须提供**中英双语**: 中文(English)，以方便记忆和学习。
   - 解释应当**详尽**，不省略任何重要细节。
   
4. **公式要求**：  
   - 对于涉及公式的内容，**需要使用公式**进行解释，并**详细解析公式**中的符号、意义以及作用。
   - 公式可能会比较抽象，使用符号较多，所以我要求提供详细的公式解释。
   - 不只是解释公式，段落等内容也需要一起讲解。
   
5. **Markdown 语法要求**：  
   - **行内公式和特殊字符**需要使用**单美元符** $ 包裹，适用于嵌入到段落中的符号和公式。例如：$a:A$、$f(a)$、$A \to B$、$U_0, U_1, U_2, \ldots$。
   - **单独占用一行或多行的公式**需要用**双美元符** $$ 包裹。例如：
     $$
     \int_{a}^{b} f(x) \, dx = F(b) - F(a)
     $$
   - 公式应当符合标准 Markdown 语法，行内和多行公式的区别需要严格遵守。

请注意，列出原文的公式并讲解。
请注意，每个公式在开始的时候都应该存在一个推导横线。
然后
多层推导树的话，每一层都要像这样分隔开：
$$
\frac{}{\text{empty tree}} \quad \frac{}{\text{empty tree}} 
$$
$$
\quad \frac{\frac{}{\text{empty tree}} \quad \frac{}{\text{empty tree}}}{\text{node(empty; empty) tree}} 
$$
$$
\quad \frac{\frac{\frac{}{\text{empty tree}} \quad \frac{}{\text{empty tree}}}{\text{node(empty; empty) tree}} \quad \frac{}{\text{empty tree}}}{\text{node(node(empty; empty); empty) tree}}
$$

6. **代码要求**：  
   - 涉及代码段时，需**添加注释**并且提供**详细讲解**，逐步分析代码的每一个步骤和功能。

7. **逐步提供内容**：  
   - 我会逐步提供书中的内容（可能是英文），并希望我逐步进行详细讲解。

8. **不省略任何内容**：  
   - 我要求解释时**不省略任何内容**，包括内容中的每一个细节，确保完整性。

9. **目标**：  
   - 我希望通过这本书的学习，**拓宽自己的视野**，不仅局限于书本内容，而是从全方位视角理解**编程语言设计原理**以及相关领域的知识，达到更深层次的学习效果。
   
10. 开头和结尾不要说废话，直接生成答案。

我会逐步提供给我内容，然后请给我讲解，关于讲解的时候，请不要省略任何内容。
```



```
不够详细，重新生成

不够详细，我是让我讲解这些内容，而不是让我原封不动的翻译它们。重新生成
不只是解释公式，段落等内容也需要一起讲解。
**公式要求**：  
   - 对于涉及公式的内容，**需要使用公式**进行解释，并**详细解析公式**中的符号、意义以及作用。
   - 公式可能会比较抽象，使用符号较多，所以我要求提供详细的公式解释。
   
我要有对公式的讲解，而不只是列出公式。
注意递归公式是由横线分割的多行公式的样子


详解详解，还不够详细，我是让我讲解这些内容，而不是让我原封不动的翻译它们：

```



```


请注意，列出原文的公式并讲解。
**公式要求**：  
   - 对于涉及公式的内容，**需要使用公式**进行解释，并**详细解析公式**中的符号、意义以及作用。
   - 公式可能会比较抽象，使用符号较多，所以我要求提供详细的公式解释。

每个推导类型的公式在开始的时候都应该存在一个推导横线。
然后
多层推导树的话，每一层都要像这样用推导横线分隔开：
$$
\frac{}{\text{empty tree}} \quad \frac{}{\text{empty tree}} 
$$
$$
\quad \frac{\frac{}{\text{empty tree}} \quad \frac{}{\text{empty tree}}}{\text{node(empty; empty) tree}} 
$$
$$
\quad \frac{\frac{\frac{}{\text{empty tree}} \quad \frac{}{\text{empty tree}}}{\text{node(empty; empty) tree}} \quad \frac{}{\text{empty tree}}}{\text{node(node(empty; empty); empty) tree}}
$$
```















```
这是我推讲给你的一种参考的答案格式，你如果能生成类似风格的答案答案的话就最好了。请先理解这种风格，然后接下来我会在后面的提问中给你提供具体要你讲解的内容。
------------
这是具体的风格：**12.2 有限和 (Finite Sums)**

在本节中，我们将深入探讨**有限和类型 (Finite Sum Types)** 的概念。有限和类型将零元和和二元和推广到任意有限数量的选项，允许我们定义具有多个替代可能性的类型。这在编程语言中非常有用，例如表示枚举类型、变体类型等。

---

### **语法定义 (Syntax Definition)**

有限和类型的语法由以下文法定义：

- **类型 (Typ τ)：**

  $$
  \tau ::= \text{sum}(\{ i \mapsto \tau_i \}_{i \in I}) \quad [\tau_i]_{i \in I} \quad \text{（和类型）}
  $$

- **表达式 (Exp e)：**

  $$
  e ::= \text{in}[\tilde{\tau}][i](e) \quad i \cdot e \quad \text{（注入）}
  $$

  $$
  e ::= \text{case}(e; \{ i \mapsto x_i.e_i \}_{i \in I}) \quad \text{case } e\ \{ i \cdot x_i \Rightarrow e_i \}_{i \in I} \quad \text{（案例分析）}
  $$

**符号解释：**

- **$I$**：一个有限的索引集，用于标识和类型的不同选项。
- **$\tilde{\tau}$**：表示一个有限的类型函数，形式为 $\{ i \mapsto \tau_i \}_{i \in I}$，即每个索引 $i$ 映射到一个类型 $\tau_i$。
- **$\text{sum}(\{ i \mapsto \tau_i \}_{i \in I})$**：和类型，表示可能的多种类型选项。
- **$\text{in}[\tilde{\tau}][i](e)$ 或 $i \cdot e$**：将表达式 $e$ 注入到索引为 $i$ 的选项中，构造一个和类型的值。
- **$\text{case}(e; \{ i \mapsto x_i.e_i \}_{i \in I})$**：对表达式 $e$ 进行案例分析，根据 $e$ 的注入索引 $i$，执行对应的分支 $e_i$。

---

### **有限和类型的表示**

当索引集 $I = \{ i_1, i_2, \dots, i_n \}$ 时，和类型和案例分析可以表示为：

- **类型表示：**

  $$
  [i_1 \mapsto \tau_1,\ i_2 \mapsto \tau_2,\ \dots,\ i_n \mapsto \tau_n]
  $$

  **解释：**这表示一个和类型，包含 $n$ 个选项，每个选项由索引 $i_k$ 和对应的类型 $\tau_k$ 组成。

- **案例分析表示：**

  $$
  \text{case } e\ \{ i_1 \cdot x_1 \Rightarrow e_1\ |\ \dots\ |\ i_n \cdot x_n \Rightarrow e_n \}
  $$

  **解释：**对表达式 $e$ 进行案例分析，根据 $e$ 是哪一个索引的注入，执行对应的分支。

---

### **静态语义 (Statics)**

有限和类型的类型规则如下，我们将详细解析每个规则的含义和推导过程。

#### **规则 (12.3a)：注入的类型判断**

推导规则：

$$
\frac{
  \Gamma \vdash e : \tau_k \quad (1 \leq k \leq n)
}{
  \Gamma \vdash i_k \cdot e : [i_1 \mapsto \tau_1,\ \dots,\ i_n \mapsto \tau_n]
}
\quad (12.3a)
$$

**公式解析：**

- **推导横线**：将前提与结论分隔开。

- **前提部分**：

  - $\Gamma \vdash e : \tau_k$：在类型环境 $\Gamma$ 下，表达式 $e$ 的类型是 $\tau_k$。
  - $1 \leq k \leq n$：$k$ 是索引的编号，表示在第 $k$ 个选项中。

- **结论部分**：

  - $\Gamma \vdash i_k \cdot e : [i_1 \mapsto \tau_1,\ \dots,\ i_n \mapsto \tau_n]$：将 $e$ 注入到索引为 $i_k$ 的选项中，结果的类型是和类型 $[i_1 \mapsto \tau_1,\ \dots,\ i_n \mapsto \tau_n]$。

**解释：**

- **含义**：如果表达式 $e$ 的类型是 $\tau_k$，那么将其注入到索引 $i_k$，得到的表达式 $i_k \cdot e$ 的类型是和类型 $[i_1 \mapsto \tau_1,\ \dots,\ i_n \mapsto \tau_n]$。

#### **规则 (12.3b)：案例分析的类型判断**

推导规则：

$$
\frac{
  \Gamma \vdash e : [i_1 \mapsto \tau_1,\ \dots,\ i_n \mapsto \tau_n] \quad
  \Gamma, x_1 : \tau_1 \vdash e_1 : \tau \quad \dots \quad \Gamma, x_n : \tau_n \vdash e_n : \tau
}{
  \Gamma \vdash \text{case } e\ \{ i_1 \cdot x_1 \Rightarrow e_1\ |\ \dots\ |\ i_n \cdot x_n \Rightarrow e_n \} : \tau
}
\quad (12.3b)
$$

**公式解析：**

- **前提部分**：

  1. $\Gamma \vdash e : [i_1 \mapsto \tau_1,\ \dots,\ i_n \mapsto \tau_n]$：表达式 $e$ 的类型是和类型 $[i_1 \mapsto \tau_1,\ \dots,\ i_n \mapsto \tau_n]$。

  2. 对于每个 $k$（$1 \leq k \leq n$）：

     - $\Gamma, x_k : \tau_k \vdash e_k : \tau$：在环境 $\Gamma$ 中，添加变量 $x_k$ 的类型为 $\tau_k$，则表达式 $e_k$ 的类型是 $\tau$。

- **结论部分**：

  - $\Gamma \vdash \text{case } e\ \{ i_1 \cdot x_1 \Rightarrow e_1\ |\ \dots\ |\ i_n \cdot x_n \Rightarrow e_n \} : \tau$：案例分析表达式的类型是 $\tau$。

**解释：**

- **含义**：对类型为和类型的表达式 $e$ 进行案例分析，对于每个可能的注入索引 $i_k$，如果 $e$ 是注入到 $i_k$ 的，那么将其对应的值绑定到 $x_k$，并计算表达式 $e_k$。所有的分支结果类型都必须是相同的类型 $\tau$。

---

### **动态语义 (Dynamics)**

有限和类型的计算规则如下，我们将详细解析每个规则的含义。

#### **规则 (12.4a)：注入的值判断**

推导规则：

$$
\frac{
  [e\ \text{val}]
}{
  i \cdot e\ \text{val}
}
\quad (12.4a)
$$

**公式解析：**

- **前提部分**（方括号中的内容在惰性求值中可省略，在急切求值中需要）：

  - $[e\ \text{val}]$：表达式 $e$ 是一个值。

- **结论部分**：

  - $i \cdot e\ \text{val}$：注入表达式 $i \cdot e$ 是一个值。

**解释：**

- **含义**：

  - **惰性求值**：注入表达式始终被视为值，无论 $e$ 是否为值。
  - **急切求值**：只有当 $e$ 是值时，注入表达式才是值。

#### **规则 (12.4b)：注入的计算**

推导规则：

$$
\frac{
  e \rightarrow e'
}{
  i \cdot e \rightarrow i \cdot e'
}
\quad (12.4b)
$$

**公式解析：**

- **前提部分**：

  - $e \rightarrow e'$：表达式 $e$ 经过一步计算变为 $e'$。

- **结论部分**：

  - $i \cdot e \rightarrow i \cdot e'$：注入表达式 $i \cdot e$ 经过一步计算变为 $i \cdot e'$。

**解释：**

- **含义**：注入表达式将计算传递给其参数 $e$，即如果 $e$ 可以进一步计算，那么 $i \cdot e$ 也可以相应地计算。

#### **规则 (12.4c)：案例分析的计算（表达式部分）**

推导规则：

$$
\frac{
  e \rightarrow e'
}{
  \text{case } e\ \{ i \cdot x_i \Rightarrow e_i \}_{i \in I} \rightarrow \text{case } e'\ \{ i \cdot x_i \Rightarrow e_i \}_{i \in I}
}
\quad (12.4c)
$$

**公式解析：**

- **前提部分**：

  - $e \rightarrow e'$：表达式 $e$ 经过一步计算变为 $e'$。

- **结论部分**：

  - 案例分析表达式变为 $\text{case } e'\ \{ i \cdot x_i \Rightarrow e_i \}_{i \in I}$，其他部分保持不变。

**解释：**

- **含义**：在案例分析中，首先计算表达式 $e$，然后根据计算结果进行模式匹配。

#### **规则 (12.4d)：案例分析的计算（匹配分支）**

推导规则：

$$
\frac{
  i \cdot e\ \text{val}
}{
  \text{case } i \cdot e\ \{ i \cdot x_i \Rightarrow e_i \}_{i \in I} \rightarrow [e / x_i] e_i
}
\quad (12.4d)
$$

**公式解析：**

- **前提部分**：

  - $i \cdot e\ \text{val}$：注入表达式 $i \cdot e$ 是一个值。

- **结论部分**：

  - $\text{case } i \cdot e\ \{ i \cdot x_i \Rightarrow e_i \}_{i \in I} \rightarrow [e / x_i] e_i$：将 $e$ 替换 $x_i$ 后的 $e_i$。

**解释：**

- **含义**：当案例分析的表达式是注入到索引 $i$ 的值时，匹配到对应的分支，将 $e$ 绑定到 $x_i$，然后计算表达式 $e_i$。

---

### **安全性定理 (Safety Theorem)**

**定理 12.2（安全性）**

- **陈述**：如果 $e : \tau$，那么要么 $e$ 是一个值，要么存在 $e'$，使得 $e \rightarrow e'$ 且 $e' : \tau$。

#### **证明概述**

- **保持性 (Preservation)**：如果 $e : \tau$ 且 $e \rightarrow e'$，那么 $e' : \tau$。

- **进展性 (Progress)**：如果 $e : \tau$，那么 $e$ 要么是一个值，要么存在 $e'$ 使得 $e \rightarrow e'$。

**证明思路：**

- **保持性**：通过对动态语义规则 (12.4) 进行归纳，证明在每个计算步骤中，表达式的类型保持不变。

- **进展性**：通过对静态语义规则 (12.3) 进行归纳，分析表达式的可能形式，证明要么是值，要么可以进行计算。

---

### **推导树示例**

为了更好地理解推导过程，我们构建一个具体的推导树示例。

**假设：**

- 类型环境 $\Gamma$ 下，有表达式 $e : [i_1 \mapsto \tau_1,\ i_2 \mapsto \tau_2,\ i_3 \mapsto \tau_3]$。

- 我们希望推导案例分析 $\Gamma \vdash \text{case } e\ \{ i_1 \cdot x_1 \Rightarrow e_1\ |\ i_2 \cdot x_2 \Rightarrow e_2\ |\ i_3 \cdot x_3 \Rightarrow e_3 \} : \tau$。

#### **第一层：判断 $e$ 的类型**

$$
\frac{\quad}{\Gamma \vdash e : [i_1 \mapsto \tau_1,\ i_2 \mapsto \tau_2,\ i_3 \mapsto \tau_3]}
$$

**解释：**

- 假设已知 $e$ 的类型是给定的和类型。

#### **第二层：判断每个分支的类型**

$$
\begin{aligned}
&\frac{\quad}{\Gamma, x_1 : \tau_1 \vdash e_1 : \tau} \\
&\frac{\quad}{\Gamma, x_2 : \tau_2 \vdash e_2 : \tau} \\
&\frac{\quad}{\Gamma, x_3 : \tau_3 \vdash e_3 : \tau}
\end{aligned}
$$

**解释：**

- 对于每个分支，添加对应的变量和类型，然后推导表达式的类型为 $\tau$。

#### **第三层：组合推导**

$$
\frac{
  \frac{\quad}{\Gamma \vdash e : [i_1 \mapsto \tau_1,\ i_2 \mapsto \tau_2,\ i_3 \mapsto \tau_3]} \quad
  \frac{\quad}{\Gamma, x_1 : \tau_1 \vdash e_1 : \tau} \quad
  \frac{\quad}{\Gamma, x_2 : \tau_2 \vdash e_2 : \tau} \quad
  \frac{\quad}{\Gamma, x_3 : \tau_3 \vdash e_3 : \tau}
}{
  \Gamma \vdash \text{case } e\ \{ i_1 \cdot x_1 \Rightarrow e_1\ |\ i_2 \cdot x_2 \Rightarrow e_2\ |\ i_3 \cdot x_3 \Rightarrow e_3 \} : \tau
}
$$

**解释：**

- 利用规则 (12.3b)，结合前面的推导，得出案例分析的类型为 $\tau$。

---

### **公式符号详解**

- **$\Gamma$**：类型环境，记录变量及其对应的类型信息。

- **$\vdash$**：类型判断符号，表示在环境下某表达式具有某类型。

- **$e : \tau$**：表达式 $e$ 的类型是 $\tau$。

- **$\rightarrow$**：计算步骤，表示表达式经过一步计算得到另一个表达式。

- **$e\ \text{val}$**：表示表达式 $e$ 是一个值，不能再进行计算。

- **$[i_k \mapsto \tau_k]$**：和类型，索引 $i_k$ 对应的类型为 $\tau_k$。

- **$i_k \cdot e$**：将表达式 $e$ 注入到索引为 $i_k$ 的选项中，构造和类型的值。

- **$\text{case } e\ \{ i_k \cdot x_k \Rightarrow e_k \}$**：对表达式 $e$ 进行案例分析，匹配索引为 $i_k$ 的情况。

- **$[e / x_k] e_k$**：表示在表达式 $e_k$ 中，用 $e$ 替换变量 $x_k$。

---

### **总结**

- **有限和类型**允许我们定义具有任意数量替代可能性的类型，通过索引集 $I$ 管理不同的选项。

- **静态语义**确保注入和案例分析在类型上是正确的，特别是所有分支的结果类型必须一致。

- **动态语义**描述了表达式的计算规则，确保在计算过程中类型安全。

- **安全性定理**保证了类型系统的可靠性，类型正确的程序在执行过程中不会出现类型错误。
-----------
稍后提供给你内容：
```



---













---

```
35.3 Typed Commands and Typed Assignables
So far we have restricted the type of the returned value of a command, and
the contents of an assignable, to be nat. Can this restriction be relaxed,
while adhering to the stack discipline?
The key to admitting returned and assignable values of other types lies
in the details of the proof of Theorem 35.1. The proof of this theorem relies
on an eager interpretation of the successor to ensure that the value is welltyped even in the absence of the locally declared assignable, a. The proof
breaks down, and indeed the preservation theorem is false, when the return
type of a command or the contents type of an assignable is unrestricted.
For example, if we may return values of procedure type, then the following command violates safety:
dcl a := z in {ret (proc (x:nat) {a := x})}.
This command, when executed, allocates a new assignable, a, and returns
a procedure that, when called, assigns its argument to a. But this makes
no sense, because the assignable, a, is deallocated when the body of the
declaration returns, but the returned value still refers to it. If the returned
procedure is called, execution will get stuck in the attempt to assign to a.
VERSION 1.32 REVISED 05.15.2012
35.3 Typed Commands and Typed Assignables 349
A similar example shows that admitting assignables of arbitrary type is
also unsound. For example, suppose that b is an assignable whose contents
are of type nat → unit, and consider the command
dcl a := z in {b := proc (x:nat) {a := x} ; ret z}.
We assign to b a procedure that uses a locally declared assignable, a, and
then leaves the scope of the declaration. If we then call the procedure
stored in b, execution will get stuck attempting to assign to the non-existent
assignable, a.
To admit declarations to return values and to admit assignables of types
other than nat, we must rework the statics of L{nat cmd *} to record the
returned type of a command and to record the type of the contents of each
assignable. First, we generalize the finite set, Σ, of active assignables to
assign a type to each active assignable so that Σ has the form of a finite
set of assumptions of the form a ∼ τ, where a is an assignable. Second,
we replace the judgment Γ `Σ m ok by the more general form Γ `Σ m ∼ τ,
stating that m is a well-formed command returning a value of type τ. Third,
the type cmd must be generalized to cmd(τ), which is written in examples
as τ cmd, to specify the return type of the encapsulated command.
The statics given in Section 35.1.1 may be generalized to admit typed
commands and typed assignables, as follows:
Γ `Σ m ∼ τ
Γ `Σ cmd(m) : cmd(τ)
(35.6a)
Γ `Σ e : τ τ mobile
Γ `Σ ret(e) ∼ τ
(35.6b)
Γ `Σ e : cmd(τ) Γ, x : τ `Σ m ∼ τ
0
Γ `Σ bnd(e; x.m) ∼ τ
0
(35.6c)
Γ `Σ e : τ τ mobile Γ `Σ,a∼τ m ∼ τ
0
Γ `Σ dcl(e; a.m) ∼ τ
0
(35.6d)
Γ `Σ,a∼τ get[a] ∼ τ
(35.6e)
Γ `Σ,a∼τ e : τ
Γ `Σ,a∼τ set[a](e) ∼ τ
(35.6f)
Apart from the generalization to track returned types and content types,
the most important change is to require that the types of assignables and of
returned values must be mobile.
REVISED 05.15.2012 VERSION 1.32
350 35.3 Typed Commands and Typed Assignables
As in Chapter 32, these rules make use of the judgment τ mobile, which
states that the type τ is mobile. The definition of this judgment is guided by
the following mobility condition:
if τ mobile, `Σ e : τ and e valΣ, then `∅ e : τ and e val∅. (35.7)
That is, a value of mobile type does not depend on any active assignables.
Because the successor is evaluated eagerly, the type nat may be deemed
mobile:
nat mobile
(35.8)
Because the body of a procedure may involve an assignable, no procedure
type may be considered mobile, nor may the type of commands returning
a given type, for similar reasons. On the other hand, a product of mobile
types may safely be deemed mobile, provided that pairing is evaluated
eagerly:
τ1 mobile τ2 mobile
τ1 × τ2 mobile (35.9)
Similarly, sums may be deemed mobile so long as the injections are evaluated eagerly:
τ1 mobile τ2 mobile
τ1 + τ2 mobile (35.10)
Laziness defeats mobility, because values may contain suspended computations that depend on an assignable. For example, if the successor operation for the natural numbers were evaluated lazily, then s(e) would be a
value for any expression, e, including one that refers to an assignable, a.
Similarly, if pairing were lazy, then products may not be deemed mobile,
and if injections were evaluated lazily, then sums may not either.
What about function types other than procedure types? We may think
they are mobile, because a pure expression cannot depend on an assignable.
Although this is indeed the case, the mobility condition need not hold. For
example, consider the following value of type nat * nat:
λ (x:nat) (λ ( :cmd) z)(cmd {@ a}).
Although the assignable a is not actually needed to compute the result, it
nevertheless occurs in the value, in violation of the safety condition.
The mobility restriction on the statics of assignable declaration ensures
that the type associated to an assignable is always mobile. We may therefore assume, without loss of generality, that the types associated to the
assignables in the signature Σ are mobile.
VERSION 1.32 REVISED 05.15.2012
35.4 Notes 351
Theorem 35.3 (Preservation for Typed Commands).
1. If e 7−→
Σ
e
0
and `Σ e : τ, then `Σ e
0
: τ.
2. If m k µ 7−→
Σ
m0 k µ
0
, with `Σ m ∼ τ and µ : Σ, then `Σ m0 ∼ τ and
µ
0
: Σ.
Theorem 35.4 (Progress for Typed Commands).
1. If `Σ e : τ, then either e valΣ, or there exists e0
such that e 7−→
Σ
e
0
.
2. If `Σ m ∼ τ and µ : Σ, then either m k µ finalΣ or m k µ 7−→
Σ
m0 k µ
0
for
some µ
0
and m0
.
The proofs of Theorems 35.3 and 35.4 follows very closely the proof
of Theorems 35.1 and 35.2. The main difference is that we appeal to the
mobility condition to ensure that returned values and stored values are
independent of the active assignables.
35.4 Notes
Modernized Algol is essentially a reformulation of Idealized Algol (Reynolds,
1981) in which we have maintained a clearer separation between computations that depend on the store and those that do not. The modal distinction
between expressions and commands was present in the original formulation of Algol 60. The same separation has been popularized by Haskell,
under the rubric “the IO monad.”
What are called here assignables are regrettably called variables in the
programming language literature. This clash of terminology is the source
of considerable confusion and misunderstanding. It is preferable to retain
the well-established meaning of a variable as standing for an unspecified
object of a specified type, but to do so requires that we invent a new word
for the name of a piece of mutable storage. The word assignable seems apt,
and equally as convenient as the misappropriated word variable.
In Idealized Algol, as in the original, an assignable may be used as a
form of expression standing for its current contents. Although syntactically convenient, this convention introduces an unfortunate dependency
of expression evaluation on the store that we avoid here.
The concept of mobility of a type was introduced in the ML5 language
for distributed computing (Murphy et al., 2004), with the similar meaning
that a value of a mobile type cannot depend on local resources. Here the
mobility restriction is used to ensure that the language adheres to the stack
discipline.
```




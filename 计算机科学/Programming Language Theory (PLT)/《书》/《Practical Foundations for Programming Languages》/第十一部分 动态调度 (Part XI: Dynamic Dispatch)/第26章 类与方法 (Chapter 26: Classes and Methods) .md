[toc]



### **Part IX: Classes and Methods**

在 **第九部分** 中，讨论了 **面向对象编程** 中的核心概念：类 (Class)、方法 (Method)、以及继承 (Inheritance) 等。面向对象编程是一种通过将数据和行为封装到对象中的编程范式，它通过类和方法组织代码，允许程序灵活地定义对象之间的关系和行为。在本部分中，详细探讨了以下关键概念：

---

### **Dynamic Dispatch (动态分派)**
**动态分派** 是面向对象编程中的一个核心概念。它允许在程序运行时根据对象的类型来选择调用的方法，而不是在编译时决定具体调用哪个方法。通过动态分派，可以实现 **多态 (polymorphism)**，即同一接口可以有多种实现方式，具体调用的实现则依赖于对象的实际类型。

#### 动态分派的关键规则：
1. **运行时决策**：根据对象的实际类型选择调用方法。
2. **抽象类和接口**：动态分派允许通过抽象类或接口定义统一的操作，然后由不同的子类提供具体的实现。
   

例如，当一个对象的类型可以是其父类或接口时，程序在运行时会根据实际的子类或实现来选择调用对应的方法。

---

### **The Dispatch Matrix (分派矩阵)**
**分派矩阵** 是一种用来管理类和方法调用的组织形式。它构建了一张二维表，其中：
- **行** 代表对象的类。
- **列** 代表类中的方法。
  

通过这张矩阵，可以快速确定对象在运行时该调用哪一个具体的方法实现。

#### 作用：
1. **效率**：通过矩阵，编译器可以快速查找要调用的方法。
2. **扩展性**：当增加新的类或方法时，可以简单地在矩阵中增加行或列，从而支持继承和多态。

---

### **Class-Based Organization (基于类的组织)**
在面向对象的设计中，**类** 是组织程序的基本单元。每个类定义了一组数据和操作 (方法)，它们可以通过继承和组合形成复杂的对象结构。

#### 特点：
1. **封装**：类封装了数据和方法，提供了清晰的接口。
2. **继承**：类之间可以通过继承关系进行复用和扩展。
3. **多态性**：通过类的继承和方法的重载，可以实现动态多态。

---

### **Method-Based Organization (基于方法的组织)**
与基于类的组织不同，**基于方法的组织** 更加关注方法的分布和执行。每个方法都可以根据上下文执行，具有独立性。

#### 特点：
1. **方法重载 (Overloading)**：同一个方法名可以有不同的参数类型，从而实现不同的功能。
2. **方法重写 (Overriding)**：子类可以重写父类中的方法，提供自己的实现。
3. **方法组合**：通过组合和链式调用，可以构建灵活的行为。

---

### **Self-Reference (自引用)**
**自引用** 是类和对象中的一个重要机制，它允许对象在方法内部引用自己。这通常通过 **self** 或 **this** 关键字实现，使得对象可以访问自己的属性和方法。

#### 作用：
1. **动态方法调用**：通过自引用，类中的方法可以在内部调用其他方法，甚至是动态调用子类的方法。
2. **递归操作**：对象可以通过自引用实现递归结构或操作，例如树形结构中的递归遍历。

---

### **Inheritance (继承)**
**继承** 是面向对象编程中的关键概念。它允许一个类 (子类) 从另一个类 (父类) 继承属性和方法，从而实现代码的复用和扩展。

#### 继承的主要类型：
1. **Class-Based Inheritance (基于类的继承)**：子类继承父类的所有属性和方法，并可以对其进行扩展和修改。
2. **Method-Based Inheritance (基于方法的继承)**：子类可以继承父类的方法，并可以选择性地重写或增强父类的方法。

#### 继承的主要优点：
- **代码复用**：通过继承，子类可以重用父类的功能，而无需重复编写相同的代码。
- **扩展性**：继承机制允许子类扩展和重写父类的行为，从而支持灵活的系统设计。

---

### **Class and Method Extension (类与方法的扩展)**
在继承的基础上，子类可以通过 **扩展 (extension)** 来增加或修改父类的行为。类扩展可以引入新的属性和方法，而方法扩展则允许修改父类方法的实现。

---

### **Notes (注解)**

- **动态分派和多态**：通过动态分派机制，面向对象编程实现了灵活的多态行为，使得程序可以根据对象的类型选择合适的操作。
- **类和方法的组织**：类的组织形式提供了封装和复用的能力，而方法的组织则支持了行为的灵活性和扩展性。
- **继承的灵活性**：继承不仅允许代码的复用，还通过方法的重载和重写支持了系统的灵活扩展。

---

这个章节讨论了 **面向对象编程** 中的核心概念，如 **动态分派**、**继承** 和 **方法扩展**，这些概念为程序设计中的模块化、可扩展性和代码复用提供了有力支持。

### ---------------------------------

### 第25章 动态调度 (Dynamic Dispatch)

动态调度是编程语言中的一个核心概念，它涉及根据对象所属的类（Class）在运行时动态确定方法的行为。在阅读此章节时，我们会探索动态调度的核心思想、不同组织方式之间的对比，以及如何通过**派发矩阵（Dispatch Matrix）**来揭示类（Class-Based）和方法（Method-Based）组织之间的对偶性。

#### 1. 动态调度的基本概念
动态调度的核心思想是：**根据对象所属的类动态选择方法的具体实现**。也就是说，方法的行为是基于对象的“类”（或类型）的不同而变化的。以下是基本定义：

- **对象（Object）**：属于特定类的实例（Instance），其包含内部结构。
- **类（Class）**：决定对象的实例数据类型（Instance Type），即对象的内部结构如何组织。
- **实例数据（Instance Data）**：对象的数据内容，具体的字段和方法。

例如，考虑一个平面上的点。我们可以根据点的不同表示法将其分为不同的类，比如笛卡尔坐标系（Cartesian Coordinates）中的点和极坐标系（Polar Coordinates）中的点。对于笛卡尔坐标，点是通过 $$(x, y)$$ 来表示，而在极坐标中，点通过 $$(r, \theta)$$ 表示。

方法的行为根据点的表示法（类）而有所不同。例如，计算到原点的距离时：

- 对于笛卡尔坐标点，距离为：  
  $$ \text{distance} = \sqrt{x^2 + y^2} $$
- 对于极坐标点，距离为：  
  $$ \text{distance} = r $$

#### 2. 动态调度与类 (Dynamic Dispatch and Class)
每个类定义了一组**方法**（Method），这些方法根据对象的类在运行时选择不同的行为。方法的调度发生在运行时，因此称为**动态调度**。例如，确定一个点位于哪个象限时：

- 对于笛卡尔坐标点，需要检查 $x$ 和 $y$ 的符号来确定象限。
- 对于极坐标点，通过 $$ \theta $$ 角度来确定象限，公式为：  
  $$ \text{quadrant} = \left\lfloor \frac{\theta}{\pi/2} \right\rfloor $$

#### 3. 类组织与方法组织 (Class-Based vs. Method-Based Organization)
- **类组织**（Class-Based Organization）：每个对象通过一个**方法向量（Method Vector）**表示，该向量包含该类特化的方法。对象根据其类找到对应的方法。
- **方法组织**（Method-Based Organization）：每个方法包含针对不同类的**分支逻辑**，在执行时，根据对象所属的类来分配正确的实现。

无论采用哪种组织方式，核心思想是不变的——**对象的类**决定了方法的行为。

#### 4. 派发矩阵 (Dispatch Matrix)
为了更清楚地说明类组织和方法组织之间的对偶性，书中引入了**派发矩阵（Dispatch Matrix）**的概念。派发矩阵展示了每个对象与每个方法之间的对应关系：

| 类   | 方法1 | 方法2 | 方法3 |
| ---- | ----- | ----- | ----- |
| 类A  | 实现1 | 实现2 | 实现3 |
| 类B  | 实现4 | 实现5 | 实现6 |
| 类C  | 实现7 | 实现8 | 实现9 |

通过派发矩阵，可以明确看到，对于某个类的对象，系统在运行时根据对象所属的类动态分配合适的方法实现。基于此，我们可以得出类组织与方法组织的对偶性：

- **类组织**：通过对象找到方法的实现。
- **方法组织**：通过方法找到针对对象所属类的实现。

#### 5. 具体实现示例
我们以一个例子来展示动态调度的工作方式：

```python
class Point:
    def distance_from_origin(self):
        pass

class CartesianPoint(Point):
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def distance_from_origin(self):
        return (self.x ** 2 + self.y ** 2) ** 0.5

class PolarPoint(Point):
    def __init__(self, r, theta):
        self.r = r
        self.theta = theta
    
    def distance_from_origin(self):
        return self.r
```

在这个例子中：
- **CartesianPoint** 类中的 `distance_from_origin` 方法计算笛卡尔坐标的距离。
- **PolarPoint** 类中的 `distance_from_origin` 方法计算极坐标的距离。

在运行时，Python 通过对象的类来动态决定调用哪个方法，即实现了**动态调度**。

#### 总结
动态调度是编程语言中通过对象所属的类在运行时动态选择方法的机制。无论采用类组织还是方法组织，核心思想都是方法的行为根据对象所属类的不同而动态变化。

### ---------------------------------

### 25.1 派发矩阵 (The Dispatch Matrix)

派发矩阵是动态调度系统的核心概念，它通过将类与方法的行为组合起来，生成一个矩阵结构，描述每个类上方法的具体行为。这个矩阵的每一行对应一个类，每一列对应一个方法，矩阵中的元素则表示某个方法在特定类上的行为实现。

#### 1. 派发矩阵的类型
我们可以将派发矩阵的类型定义为：
$$
\prod_{c \in C} \prod_{d \in D} (\tau_c \to \rho_d),
$$
其中：
- $$C$$ 是类名的集合。
- $$D$$ 是方法名的集合。
- $$\tau_c$$ 表示与类 $$c$$ 相关的**实例类型**（instance type），即该类的实例数据结构。
- $$\rho_d$$ 表示方法 $$d$$ 的**返回类型**（result type），即该方法的结果类型。

因此，派发矩阵的每个元素描述了方法 $$d$$ 在类 $$c$$ 上的行为，表达为对该类的实例数据类型 $$\tau_c$$ 的函数，返回值类型为 $$\rho_d$$。

#### 2. 平面点分类示例
让我们通过平面上的点分类为笛卡尔坐标系点（cartesian points）和极坐标系点（polar points）来说明派发矩阵的具体应用。

- 笛卡尔坐标系点的实例数据类型为：
  $$
  \tau_{\text{cart}} = \langle x \mapsto \text{real}, y \mapsto \text{real} \rangle
  $$
  也就是说，笛卡尔点由两个实数 $$x$$ 和 $$y$$ 组成，表示它的 $$x$$ 和 $$y$$ 坐标。

- 极坐标系点的实例数据类型为：
  $$
  \tau_{\text{pol}} = \langle r \mapsto \text{real}, \theta \mapsto \text{real} \rangle
  $$
  这里 $$r$$ 表示点到原点的距离，$$\theta$$ 表示点与极轴的夹角。

#### 3. 方法实现与派发
考虑两个作用于这些点的方法：
- **`dist`** 方法：计算点到原点的平方距离。
- **`quad`** 方法：计算点所在的象限。

首先来看 **`dist`** 方法，它的派发矩阵可以表示为一个包含两个元素的元组：
$$
\text{edist} = \langle \text{cart} \mapsto \text{e}^{\text{cart}}_{\text{dist}}, \text{pol} \mapsto \text{e}^{\text{pol}}_{\text{dist}} \rangle
$$
其中：
- $$\rho_{\text{dist}} = \text{real}$$ 为方法 `dist` 的返回类型。
- 对于笛卡尔坐标点，平方距离的计算为：
  $$
  \text{e}^{\text{cart}}_{\text{dist}} = \lambda (u:\tau_{\text{cart}}) \, (u \cdot x)^2 + (u \cdot y)^2
  $$
- 对于极坐标点，平方距离的计算为：
  $$
  \text{e}^{\text{pol}}_{\text{dist}} = \lambda (v:\tau_{\text{pol}}) \, (v \cdot r)^2
  $$

接着来看 **`quad`** 方法，它的派发矩阵同样可以表示为元组：
$$
\text{equad} = \langle \text{cart} \mapsto \text{e}^{\text{cart}}_{\text{quad}}, \text{pol} \mapsto \text{e}^{\text{pol}}_{\text{quad}} \rangle
$$
其中：
- $$\rho_{\text{quad}} = [\text{I}, \text{II}, \text{III}, \text{IV}]$$ 为方法 `quad` 的返回类型。
- 对于笛卡尔坐标点，象限的计算方法可以根据 $$x$$ 和 $$y$$ 的符号判断：
  $$
  \text{e}^{\text{cart}}_{\text{quad}} = \lambda (u:\tau_{\text{cart}}) \, \text{determine quadrant based on } u \cdot x \text{ and } u \cdot y
  $$
- 对于极坐标点，可以根据 $$\theta$$ 的值来确定象限：
  $$
  \text{e}^{\text{pol}}_{\text{quad}} = \lambda (v:\tau_{\text{pol}}) \, \left\lfloor \frac{v \cdot \theta}{\pi / 2} \right\rfloor
  $$

#### 4. 派发矩阵的图示
我们可以通过一个派发矩阵来直观地展示不同类上不同方法的行为：

| 类/Class     | 方法/Method: `dist`                                          | 方法/Method: `quad`                                          |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 笛卡尔/Cart  | $ \lambda (u:\tau_{\text{cart}}) (u \cdot x)^2 + (u \cdot y)^2 $ | $ \lambda (u:\tau_{\text{cart}}) \text{determine quadrant based on } u \cdot x \text{ and } u \cdot y $ |
| 极坐标/Polar | $ \lambda (v:\tau_{\text{pol}}) (v \cdot r)^2 $              | $ \lambda (v:\tau_{\text{pol}}) \left\lfloor \frac{v \cdot \theta}{\pi / 2} \right\rfloor $ |

这个矩阵清晰地展示了不同类与方法之间的映射关系。

### 结论
派发矩阵是动态调度的核心概念，能够统一描述类和方法之间的行为关系。通过这个矩阵，我们可以清楚地定义每个类上每个方法的具体实现，无论该方法的行为是如何根据类的不同而变化的。这种矩阵结构为我们理解类组织与方法组织提供了对称性的视角。

### ---------------------------------

在这一节中，我们定义了一个用于动态派发的矩阵 `edm`，并介绍了动态派发的抽象和两种实现方式：**基于类的组织**(Class-Based Organization) 和 **基于方法的组织**(Method-Based Organization)。这两种方式是等价的，可以根据具体需求互换使用。接下来我们详细解释这些概念。

### 1. 派发矩阵的定义

我们定义集合：
- $$C = \{\text{cart}, \text{pol}\}$$，表示类集合，包括笛卡尔类 (cart) 和极坐标类 (pol)。
- $$D = \{\text{dist}, \text{quad}\}$$，表示方法集合，包括计算平方距离的方法 (`dist`) 和计算象限的方法 (`quad`)。

派发矩阵 `edm` 是一个值，它的类型为：
$$
\prod_{c \in C} \prod_{d \in D} (\tau_c \to \rho_d),
$$
这个类型意味着，对于每个类 $$c \in C$$ 和每个方法 $$d \in D$$，矩阵中存储了一个函数，该函数从类 $$c$$ 的实例数据类型 $$\tau_c$$ 映射到方法 $$d$$ 的返回类型 $$\rho_d$$。

具体来说，派发矩阵 `edm` 中对于类 $$c$$ 和方法 $$d$$ 的条目定义了方法 $$d$$ 作用于类 $$c$$ 的实例数据时的行为：
$$
\text{edm} \cdot c \cdot d \longrightarrow e^c_d,
$$
这里的 $$e^c_d$$ 是矩阵中对应条目（类 $$c$$ 上方法 $$d$$ 的具体实现）。

### 2. 动态派发的抽象 (Dynamic Dispatch Abstraction)

动态派发提供了以下组件：
- **`obj` 类型**：对象的类型，这些对象被类分类，方法会作用于这些对象。
- **`new[c](e)` 操作**：这是一个类型为 `obj` 的操作，用于创建一个类为 $$c$$ 的对象，其中实例数据是表达式 $$e$$，类型为 $$\tau_c$$。
- **`e ⇐ d` 操作**：这是一个类型为 $$\rho_d$$ 的操作，用于在类型为 `obj` 的对象上调用方法 $$d$$。

这些操作需要满足动态派发的基本特性：
$$
(\text{new}[c](e)) \Longleftarrow d \longrightarrow e^c_d(e),
$$
意思是，如果我们在类为 $$c$$ 的对象上调用方法 $$d$$，并且该对象的实例数据为 $$e$$，那么实际上执行的操作是将实例数据 $$e$$ 传递给派发矩阵中类 $$c$$ 上方法 $$d$$ 的实现 $$e^c_d$$。

### 3. 动态派发的两种实现方式

#### 3.1 基于类的组织 (Class-Based Organization)
在基于类的组织中，对象被表示为一个**方法的元组**，创建对象时，会将这些方法具体化为与对象的实例数据相关联的实现。这种方式下，类定义了对象的结构，每个对象包含专门用于它自身实例数据的特定方法。

这种实现的步骤为：
- 创建类时，定义所有该类的对象需要的方法。
- 当创建一个对象时，使用该对象的实例数据专门化这些方法。

例如，对于一个笛卡尔坐标点，`new[cart](hx = 1, y = 2i)` 创建了一个对象，该对象内部存储了针对实例数据 `x=1` 和 `y=2` 专门化的方法（如 `dist` 和 `quad` 方法）。

#### 3.2 基于方法的组织 (Method-Based Organization)
在基于方法的组织中，创建对象时，会将实例数据与类名一起打包，然后方法的定义会通过对象的类来决定行为。这意味着每次调用方法时，首先需要根据对象的类进行**派发**，然后再执行相应的代码。

这种实现的步骤为：
- 创建对象时，将实例数据打包并附加类信息。
- 方法的行为通过查找对象的类来确定，然后调用相应的方法实现。

例如，在基于方法的组织中，`new[cart](hx = 1, y = 2i)` 创建了一个包含实例数据和类名 `cart` 的对象，当我们调用 `dist` 方法时，首先检查类名，然后执行与笛卡尔点相关的 `dist` 方法。

### 4. 对称性
基于类的组织和基于方法的组织之间存在一种自然的**对称性**。两者在实现上是等价的，可以根据需求互换使用。在某些编程语言中，可能会偏好某一种方式，尽管它们从理论上是对称的。

### 结论
派发矩阵的抽象定义了类和方法的具体行为，并通过动态派发机制允许我们在运行时根据对象的类来选择合适的方法实现。派发的两种主要实现方式（基于类和基于方法的组织）是对称且可互换的，虽然它们在实践中的实现可能有所不同。

### ---------------------------------

在这一节中，我们讨论了**基于类的组织** (Class-Based Organization) 实现动态派发的机制。该组织方式通过将每个类的实例数据与其相应的方法行为联系起来，来实现动态方法派发。

### 1. 类向量 (Class Vector)

基于类的组织方法从**派发矩阵** (Dispatch Matrix) 开始，我们将矩阵重组，按类进行划分，得到**类向量** $ecv$，其类型为：
$$
\tau_{cv} = \prod_{c \in C} \left(\tau_c \to \left(\prod_{d \in D} \rho_d\right)\right),
$$
- $C$：表示类的集合，如 $C = \{\text{cart}, \text{pol}\}$。
- $D$：表示方法的集合，如 $D = \{\text{dist}, \text{quad}\}$。
- $\tau_c$：表示类 $c$ 的实例数据类型。
- $\rho_d$：表示方法 $d$ 的返回类型。

类向量的每一行都包含一个构造器，它决定了针对给定的实例数据时，每个方法的行为。

### 2. 对象的类型

在这种组织方式中，对象的类型为：
$$
\rho = \prod_{d \in D} \rho_d
$$
它表示对象的方法的结果类型的乘积。例如，对于平面中的点，类型 $\rho$ 是以下乘积类型：
$$
\langle \text{dist} \to \rho_{\text{dist}}, \text{quad} \to \rho_{\text{quad}} \rangle,
$$
这意味着对象的每个组件都对应于其上每个方法的结果类型。

### 3. 消息发送操作

消息发送操作的形式为：
$$
e \Longleftarrow d
$$
这是一个对方法的投影操作。例如，在平面点的情境下，$e \Longleftarrow \text{dist}$ 实际上是 $e \cdot \text{dist}$ 的投影，而 $e \Longleftarrow \text{quad}$ 是 $e \cdot \text{quad}$ 的投影。

### 4. 类向量的构造

类向量的定义如下：
$$
ecv = \langle e_c \rangle_{c \in C},
$$
对于每个 $c \in C$，$e_c$ 是一个构造器，它的表达式形式为：
$$
\lambda (u: \tau_c) \langle d \to edm \cdot c \cdot d(u) \rangle_{d \in D}.
$$
例如，类 `cart` 的构造器 $e_{\text{cart}}$ 的表达式为：
$$
\lambda (u: \tau_{\text{cart}}) \langle \text{dist} \to edm \cdot \text{cart} \cdot \text{dist}(u), \text{quad} \to edm \cdot \text{cart} \cdot \text{quad}(u) \rangle.
$$
类似地，类 `pol` 的构造器 $e_{\text{pol}}$ 为：
$$
\lambda (u: \tau_{\text{pol}}) \langle \text{dist} \to edm \cdot \text{pol} \cdot \text{dist}(u), \text{quad} \to edm \cdot \text{pol} \cdot \text{quad}(u) \rangle.
$$

### 5. 创建对象

我们通过类向量 $ecv$ 和实例数据来创建一个类的对象。对象的创建方式如下：
$$
\text{new}[c](e) = ecv \cdot c(e),
$$
这意味着，我们从类 $c$ 的构造器 $e_c$ 中生成对象。以平面点为例：

- 对于一个笛卡尔坐标点，创建的表达式为：
  $$
  \text{new}[\text{cart}](\langle x \to x_0, y \to y_0 \rangle) = ecv \cdot \text{cart}(\langle x \to x_0, y \to y_0 \rangle),
  $$

- 对于一个极坐标点，创建的表达式为：
  $$
  \text{new}[\text{pol}](\langle r \to r_0, \theta \to \theta_0 \rangle) = ecv \cdot \text{pol}(\langle r \to r_0, \theta \to \theta_0 \rangle).
  $$

### 6. 消息发送的验证

验证这一组织方式时，我们可以推导出：
$$
(\text{new}[c](e)) \Longleftarrow d \longrightarrow^* (ecv \cdot c(e)) \cdot d \longrightarrow^* edm \cdot c \cdot d(e),
$$
这表明消息发送的确触发了该方法在给定类的实例数据上的行为。具体来说，对于类 $c$ 和方法 $d$，消息发送操作最终会调用派发矩阵中的条目 `edm · c · d` 来作用于实例数据 $e$。

### 总结

**基于类的组织**通过类向量 $ecv$ 将每个类的实例数据和方法的行为组合在一起，实现了动态派发。这种方式强调类的结构，方法对实例数据进行专门化处理。在这种组织方式下，创建对象时，方法的行为已经与实例数据紧密绑定，而消息发送则通过简单的投影来获取方法的结果。这种组织方式特别适用于类与方法之间的关系清晰明确的场景。

### ---------------------------------

在**基于方法的组织**（Method-Based Organization）中，动态派发机制通过方法向量来处理方法调用，而不是像类向量那样专注于类。方法向量的每一行代表一个方法，每个方法根据对象的类来决定其行为。

### 1. 方法向量 (Method Vector)

基于方法的组织通过转置派发矩阵，得到方法向量 $emv$，其类型为：
$$
\tau_{mv} = \prod_{d \in D} \left(\sum_{c \in C} \tau_c \right) \to \rho_d,
$$
其中：
- $D$：表示方法的集合，如 $D = \{\text{dist}, \text{quad}\}$。
- $C$：表示类的集合，如 $C = \{\text{cart}, \text{pol}\}$。
- $\tau_c$：表示类 $c$ 的实例数据类型。
- $\rho_d$：表示方法 $d$ 的返回类型。

每个方法向量的条目是一个调度器 (dispatcher)，该调度器决定方法在给定实例数据上的行为。

### 2. 对象的类型

在基于方法的组织中，对象的类型是一个求和类型：
$$
\tau = \sum_{c \in C} \tau_c
$$
这意味着每个对象都由其类的实例数据和对应的类标签组成。例如，平面中点的类型是以下求和类型：
$$
[\text{cart} \to \tau_{\text{cart}}, \text{pol} \to \tau_{\text{pol}}],
$$
每个点都带有其类标签，指定其是笛卡尔坐标形式还是极坐标形式。

### 3. 创建对象

通过将实例数据与类标签组合，可以创建类的对象。对象的创建方式如下：
$$
\text{new}[c](e) = c \cdot e,
$$
其中 $c$ 是类标签，$e$ 是实例数据。例如：

- 对于笛卡尔坐标点，创建表达式为：
  $$
  \text{new}[\text{cart}](\langle x \to x_0, y \to y_0 \rangle) = \text{cart} \cdot \langle x \to x_0, y \to y_0 \rangle,
  $$
- 对于极坐标点，创建表达式为：
  $$
  \text{new}[\text{pol}](\langle r \to r_0, \theta \to \theta_0 \rangle) = \text{pol} \cdot \langle r \to r_0, \theta \to \theta_0 \rangle.
  $$

### 4. 方法向量的定义

方法向量的类型为 $ \tau_{mv}$，定义如下：
$$
emv = \langle e_d \rangle_{d \in D},
$$
对于每个 $d \in D$，表达式 $e_d : \tau \to \rho_d$ 为：
$$
\lambda (\text{this}: \tau) \ \text{case} \ \text{this} \ \{ c \cdot u \Rightarrow edm \cdot c \cdot d(u) \}_{c \in C},
$$
其中，`this` 是对象的标签和实例数据，`case` 用于根据类标签 $c$ 选择适当的方法实现。例如：

- 对于方法 `dist`，调度器的形式为：
  $$
  \lambda (\text{this}: \tau) \ \text{case} \ \text{this} \ \{ \text{cart} \cdot u \Rightarrow edm \cdot \text{cart} \cdot \text{dist}(u) \ | \ \text{pol} \cdot v \Rightarrow edm \cdot \text{pol} \cdot \text{dist}(v) \},
  $$
- 对于方法 `quad`，调度器的形式为：
  $$
  \lambda (\text{this}: \tau) \ \text{case} \ \text{this} \ \{ \text{cart} \cdot u \Rightarrow edm \cdot \text{cart} \cdot \text{quad}(u) \ | \ \text{pol} \cdot v \Rightarrow edm \cdot \text{pol} \cdot \text{quad}(v) \}.
  $$

### 5. 消息发送操作

消息发送的操作形式为：
$$
e \Longleftarrow d = emv \cdot d(e),
$$
即应用方法向量中的相应调度函数来处理对象。例如，对于类 $c$ 和方法 $d$，我们可以推导出：
$$
(\text{new}[c](e)) \Longleftarrow d \longrightarrow^* emv \cdot d(c \cdot e) \longrightarrow^* edm \cdot c \cdot d(e),
$$
这意味着对于每个类 $c$ 和方法 $d$，消息发送最终会触发派发矩阵中的相应方法实现。

### 6. 总结

**基于方法的组织**通过方法向量将每个方法的实现集中在一起，并在运行时基于对象的类标签来确定方法的行为。与基于类的组织相比，基于方法的组织强调方法的结构，而不是类的结构。消息发送操作通过调用方法向量中的相应调度函数，根据类标签来执行正确的方法实现。这两种组织方式本质上是对称的，可以相互替换，但不同的编程语言可能会偏向于其中一种组织方式。

### ---------------------------------

我们现在来详细讲解**动态派发**机制中**自引用**(self-reference) 的实现。自引用指的是方法可以通过引用自己或其他对象中的方法来实现递归或对象之间的交互。为了支持这一点，我们必须修改派发矩阵的类型，以允许创建对象并发送消息。

### 1. 派发矩阵的类型修改

原先的派发矩阵类型为：
$$
\prod_{c \in C} \prod_{d \in D} (\tau_c \to \rho_d)
$$
其中：
- $c \in C$ 表示类的集合。
- $d \in D$ 表示方法的集合。
- $\tau_c$ 是类 $c$ 的实例数据类型。
- $\rho_d$ 是方法 $d$ 的返回类型。

为了支持自引用，我们引入了类型变量 $t$，代表对象类型。同时，类向量 $\tau_{cv}$ 和方法向量 $\tau_{mv}$ 的类型也需要修改。修改后的派发矩阵类型为：
$$
\prod_{c \in C} \prod_{d \in D} \forall t. (\tau_{cv} \to \tau_{mv} \to \tau_c \to \rho_d)
$$
其中：
- $\tau_{cv}$ 是类向量的类型。
- $\tau_{mv}$ 是方法向量的类型。
- $\tau_c$ 是类 $c$ 的实例数据类型。
- $\rho_d$ 是方法 $d$ 的返回类型。

### 2. 类向量 $\tau_{cv}$ 和方法向量 $\tau_{mv}$ 的定义

为了理解这个修改，我们先定义类向量和方法向量：
- 类向量的类型是：
  $$
  \tau_{cv} = \prod_{c \in C} (\tau_c \to t)
  $$
  这里，$\tau_c \to t$ 是从类 $c$ 的实例数据映射到对象类型 $t$ 的构造器函数。

- 方法向量的类型是：
  $$
  \tau_{mv} = \prod_{d \in D} (t \to \rho_d)
  $$
  这里，$t \to \rho_d$ 是一个从对象类型 $t$ 映射到方法 $d$ 返回类型 $\rho_d$ 的调度器函数。

### 3. 自引用的派发行为

每个类和方法的行为通过派发矩阵中的具体函数实现。行为的形式为：
$$
\Lambda t. \lambda (cv: \tau_{cv}) \lambda (mv: \tau_{mv}) \lambda (u: \tau_c) \, e^c_d
$$
其中：
- $\Lambda t$ 表示对于对象类型 $t$ 的泛型抽象。
- $cv$ 和 $mv$ 分别是类向量和方法向量，用于创建对象和发送消息。
- $u$ 是类 $c$ 的实例数据。
- $e^c_d$ 是在类 $c$ 上调用方法 $d$ 的行为。

在表达式 $e^c_d$ 中，可以通过 `cv · c'(e')` 创建一个类 $c'$ 的对象，这个对象的实例数据为 $e'$。类 $c'$ 可以是 $c$ 本身，这是自引用的一种形式。同样的，在 $e^c_d$ 中，通过 `mv · d'(e')` 可以在对象 $e'$ 上调用方法 $d'$，方法 $d'$ 可以是 $d$ 本身，这是自引用的另一种形式。

### 4. 方法向量的定义

为了处理自引用，方法向量的类型需要自引用类型 `self([τ/t]\tau_{mv})`。对象类型 $\tau$ 是所有类的实例类型的求和类型：
$$
\tau = \sum_{c \in C} \tau_c
$$

方法向量的具体定义为：
$$
\text{self mv is } \langle d \mapsto \lambda (\text{this} : \tau) \, \text{case this } \{ c \cdot u \Rightarrow edm \cdot c \cdot d[\tau](e^0_{cv})(e^0_{mv})(u) \}_{c \in C} \rangle_{d \in D}
$$
其中：
- $e^0_{cv}$ 是类向量，定义为 $\langle c \mapsto \lambda (u: \tau_c) \, c \cdot u \rangle_{c \in C}$。
- $e^0_{mv}$ 是方法向量，通过 $unroll(mv)$ 来展开。

对象的创建通过表达式：
$$
\text{new}[c](e) = c \cdot e
$$

消息发送的定义为：
$$
e \Longleftarrow d = \text{unroll}(emv) \cdot d(e)
$$

### 5. 类向量的自引用

在类向量中，自引用类型为 `self([ρ/t]τ_{cv})`，其中对象类型 $\rho$ 是所有方法返回类型的乘积：
$$
\rho = \prod_{d \in D} \rho_d
$$

类向量的定义如下：
$$
\text{self cv is } \langle c \mapsto \lambda (u: \tau_c) \, \langle d \mapsto edm \cdot c \cdot d[\rho](e^{00}_{cv})(e^{00}_{mv})(u) \rangle_{d \in D} \rangle_{c \in C}
$$
其中：
- $e^{00}_{cv}$ 是类向量，通过 $unroll(cv)$ 展开。
- $e^{00}_{mv}$ 是方法向量，定义为 $\langle d \mapsto \lambda (\text{this} : \rho) \, this \cdot d \rangle_{d \in D}$。

对象创建的定义为：
$$
\text{new}[c](e) = \text{unroll}(ecv) \cdot c(e)
$$

消息发送的定义为：
$$
e \Longleftarrow d = e \cdot d
$$

### 6. 对称性

类向量和方法向量的定义展示了派发机制的对称性：基于类的派发和基于方法的派发可以互换。这种对称性是集合类型（求和类型）和乘积类型（笛卡尔积）之间对偶性的反映。

### 结论

**自引用**引入了对象内部的递归和对象之间的交互。通过扩展派发矩阵的类型，使得类向量和方法向量可以处理自引用，允许在方法中创建新对象并发送消息。

### ---------------------------------

第 25 章的**笔记部分**总结了**面向对象**(Object-Oriented) 编程中一个核心概念，即**动态派发**(Dynamic Dispatch)，并强调了这种特性与更广泛的编程语言类型系统中的和类型相关概念的关系。以下是详细的讲解与背景分析：

### 1. 面向对象中的动态派发

**动态派发**是指方法的行为在运行时根据对象的类（Class）来确定。每个对象都属于某个类，而类决定了对象的数据结构以及可操作的方法。例如，给定一个类 `Point`，它可以有不同的子类 `CartesianPoint`（笛卡尔坐标系中的点）和 `PolarPoint`（极坐标系中的点）。根据对象的类型，调用某个方法时，系统会选择不同的实现，这就是动态派发的作用。

- **方法** (Method)：在面向对象的上下文中，方法是一种函数，其行为根据对象所属的类来决定。
- **类** (Class)：类定义了对象的结构和行为。不同的类可以实现不同的方法行为，即使方法名称相同（如 `dist` 方法计算点到原点的距离，但不同坐标系的计算方式不同）。

### 2. 面向对象与类型系统的关系

书中将动态派发与更一般的类型概念（如**和类型**、**积类型**和**函数类型**）联系起来。这种做法表明，面向对象编程的动态派发可以看作是类型系统的具体应用：

- **和类型 (Sum Type)**：用于描述对象可以属于多种类的情况。例如，一个 `Point` 对象可以是 `CartesianPoint` 或 `PolarPoint`。这类似于和类型中的选择。
  
- **积类型 (Product Type)**：用于描述一个类的多个方法组合在一起的情况。例如，一个 `Point` 对象可能有多个方法（如 `dist` 和 `quad`），这些方法的结果可以被看作积类型的多个分量。

- **函数类型 (Function Type)**：每个方法的实现可以看作从对象的数据结构到方法返回类型的映射。例如，`dist` 方法可以被建模为从点的实例数据（如 x, y 坐标）到距离值的函数。

通过和类型、积类型和函数类型的组合，可以构建出非常丰富的面向对象行为模型。这种建模不仅限于类和方法的组织，还包括**递归类型**和**自引用**，这些在之前的章节中已经详细介绍。

### 3. 类与方法的组织对称性

书中提到，动态派发机制中无论是**基于类**（class-based）的组织，还是**基于方法**（method-based）的组织，本质上都是对称的。我们可以通过两种方式来组织对象的行为：

- **基于类的组织**：方法被封装在对象内部，每个对象都包含其对应类的方法集合。每次消息发送时，只需从对象中选择相应的方法。

- **基于方法的组织**：所有方法都独立存在，并通过查询对象的类型来选择适当的实现。这样，方法成为一个外部的“调度器”，根据对象的类型来决定调用哪个实现。

这两种组织方式本质上是对称的，反映了**和类型**和**积类型**之间的对偶性。无论使用哪种组织方式，都可以结合递归类型和自引用来实现复杂的对象行为模型。

### 4. 动态派发与递归类型

动态派发不仅仅是静态的类和方法的调度，还可以结合**递归类型**来处理更复杂的情况，例如方法返回的结果可以是另一个对象。这种情况下，方法可以递归地调用其他对象或自身的方法，形成复杂的自引用结构。

例如，在定义一个 `Tree` 类时，树的节点可能包含子节点，这些子节点本身也是 `Tree` 对象。通过递归类型，方法可以操作整个树结构，而动态派发机制确保不同类型的节点调用适当的方法实现。

### 5. 面向对象编程的理论基础

本节最后提到了一些关于面向对象编程理论的相关文献，例如 Abadi 和 Cardelli（1996），以及 Pierce（2002）对该领域的详尽讨论。这些书籍提供了有关动态派发、类和方法的详细理论基础，进一步深入探讨了面向对象编程的数学模型和形式化表示。

### 公式解析

动态派发通过类型系统中的函数类型和和类型来实现。我们在派发矩阵的条目中看到公式：
$$
\prod_{c \in C} \prod_{d \in D} (\tau_c \to \rho_d)
$$
其中：
- $\prod_{c \in C}$ 表示类的集合 $C$ 上的笛卡尔积，意味着每个类都可以定义其方法行为。
- $\prod_{d \in D}$ 表示方法的集合 $D$ 上的笛卡尔积，意味着每个方法都可以定义其返回类型。
- $\tau_c$ 是类 $c$ 的实例数据类型，$\rho_d$ 是方法 $d$ 的返回类型。

通过这个派发矩阵，可以看到系统中类和方法的双重映射关系：每个类定义了一组方法，每个方法针对类的数据类型进行处理。这种方式确保了面向对象系统的灵活性和动态性。

动态派发的基本行为可以表示为公式：
$$
(new[c](e)) \Longleftarrow d \longrightarrow edm \cdot c \cdot d(e)
$$
这表示对于类 $c$ 的实例对象 $e$，调用方法 $d$ 时，会根据派发矩阵的定义，选择相应的方法实现并应用到对象的实例数据上。

### 结论

面向对象编程中的动态派发不仅是语言设计中的一个技巧，还是深刻反映了类型系统中和类型、积类型和函数类型的理论基础。


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------
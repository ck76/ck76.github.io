[toc]



### 26.1 继承 (Inheritance)

**继承** 是一种构建**派发矩阵**的策略，允许我们在已有的类或方法的基础上，定义新的类或方法。这种策略被称为**增量式构建**，即通过**添加新的类或方法**来逐步扩展现有的派发矩阵。这种扩展方式体现在两个方面：

1. **添加新类**：我们需要为新类定义每个方法的行为。
2. **定义新方法**：我们需要为现有类中的每个对象定义该方法的行为。

继承允许**复用现有的行为**，通过**继承超类**的某些行为并**覆盖**其他行为，形成新类的行为集合。类似地，新的方法可以继承其他方法的行为，并在某些情况下进行覆盖。这样的方式允许我们灵活地**重用代码**，并为新类或方法提供定制化的行为。

**超类** (superclass) 和 **子类** (subclass) 的关系反映了层次结构，子类从超类中继承部分或全部行为。同样，**超方法** (supermethod) 和 **子方法** (submethod) 的关系也通过类似的方式进行定义。

### 26.2 派发矩阵的扩展

在考虑继承时，我们主要关心如何扩展派发矩阵。派发矩阵描述了每个类上的每个方法的行为。在引入继承时，扩展派发矩阵可以通过以下方式进行：

1. **扩展类**：添加一个新类时，派发矩阵的行数会增加。新类的每个方法行为可以从超类中继承或重写。
2. **扩展方法**：添加一个新方法时，派发矩阵的列数会增加。新方法在现有类上的行为可以从其他方法中继承或重写。

继承的核心在于通过派发矩阵的这些扩展来实现行为的复用和灵活修改。

### 公式解析

派发矩阵的基本形式可以表示为：
$$
\prod_{c \in C} \prod_{d \in D} (\tau_c \to \rho_d)
$$
其中：
- $C$ 是类的集合，表示派发矩阵中的行。
- $D$ 是方法的集合，表示派发矩阵中的列。
- $\tau_c$ 是类 $c$ 的实例数据类型，$\rho_d$ 是方法 $d$ 的返回类型。

在进行类继承时，派发矩阵的行会扩展。例如，如果有一个新类 $c'$ 继承自类 $c$，并且继承了部分方法的行为，那么派发矩阵中新的行可以表示为：
$$
\prod_{d \in D} (\tau_{c'} \to \rho_d)
$$
其中 $\tau_{c'}$ 是新类 $c'$ 的实例数据类型。如果某个方法 $d$ 的行为被覆盖了，那么相应的条目会进行重写。

在进行方法继承时，派发矩阵的列会扩展。例如，如果有一个新方法 $d'$ 继承自方法 $d$，则新的列可以表示为：
$$
\prod_{c \in C} (\tau_c \to \rho_{d'})
$$
其中 $\rho_{d'}$ 是新方法 $d'$ 的返回类型。

### 26.3 类继承的实现方式

类继承通常有两种常见的实现方式：

1. **基于类的继承** (Class-Based Inheritance)：子类继承超类的部分或全部方法，并在某些情况下重写方法的行为。在派发矩阵中，这反映为新类继承了部分方法的实现。
2. **基于方法的继承** (Method-Based Inheritance)：新方法继承旧方法在某些类上的行为，并在其他类上重写方法的实现。

这两种方式都依赖于派发矩阵的扩展，并且可以灵活选择需要继承或重写的部分。

### ---------------------------------

### 类继承的两种常见实现方式

类继承是面向对象编程中的核心概念，用于表达类之间的层次关系以及代码复用。常见的类继承实现方式主要有两种：**基于类的继承**和**基于方法的继承**。它们在如何继承和重用代码上略有不同，但都依赖于派发矩阵（dispatch matrix）的概念，用来组织和查找方法。

#### 1. **基于类的继承** (Class-Based Inheritance)

在**基于类的继承**中，子类继承父类的属性和方法，并且可以在子类中重写（override）父类的方法。这种继承方式主要是从**类的角度**组织行为，即一个类继承了另一个类的部分或全部实现。子类可以直接调用父类的方法，或者通过重写来改变方法的实现。

##### 工作机制：
- **继承方法**：子类自动拥有父类的所有方法。
- **重写方法**：子类可以重写父类中的某些方法，以提供不同的实现。
- **派发矩阵**：派发矩阵用于决定哪个类的方法应该在运行时被调用。通过类继承的机制，派发矩阵中的方法会从父类“传递”到子类中。

##### 示例：
```java
class Animal {
    void speak() {
        System.out.println("Animal speaks");
    }
}

class Dog extends Animal {
    @Override
    void speak() {
        System.out.println("Dog barks");
    }
}

Animal a = new Dog();
a.speak(); // 调用 Dog 的 speak 方法，输出 "Dog barks"
```

在这个例子中，`Dog` 类继承了 `Animal` 类，但通过重写 `speak` 方法，改变了其行为。派发矩阵决定在运行时调用 `Dog` 的方法。

##### 特点：
- **代码复用**：子类可以继承父类的代码，不需要重复实现相同的逻辑。
- **多态性**：通过继承和方法重写，子类可以以父类的形式被使用，从而实现多态行为。

#### 2. **基于方法的继承** (Method-Based Inheritance)

**基于方法的继承**关注的是方法本身的行为。在这种模式下，新的方法可以继承旧方法在某些类上的行为，而在其他类上对方法进行重写。这种方式更加灵活，允许方法在不同类型的对象上表现不同。

##### 工作机制：
- **继承行为**：新的方法可以继承之前方法在某些类上的行为，而不需要完全重写整个方法。
- **方法分派**：派发矩阵在运行时基于方法来确定行为，新的方法可以对不同类上的行为进行选择性继承或重写。

##### 示例：
```lisp
(defmethod speak ((a animal))
  (print "Animal speaks"))

(defmethod speak ((d dog))
  (print "Dog barks"))

(speak (make-instance 'dog)) ;; 输出 "Dog barks"
```

在这个例子中，`speak` 方法的实现针对 `animal` 和 `dog` 类型的对象进行了不同的处理。这反映了基于方法的继承，即方法可以在不同的对象上继承或重新定义。

##### 特点：
- **更灵活的行为**：基于方法的继承允许方法在不同的类上具有不同的实现，不需要遵循类继承的层次结构。
- **多方法**：多个方法可以基于不同的参数类型进行分派，提供更复杂的行为模式。

#### 3. **派发矩阵的作用**

无论是基于类的继承还是基于方法的继承，**派发矩阵**（dispatch matrix）都是决定继承机制如何工作的核心部分。派发矩阵在运行时基于对象的类型和调用的方法，决定该调用哪个类或方法的实现。

- **基于类的继承**：派发矩阵首先检查对象的类型，然后在类的层次结构中查找最合适的实现。如果子类重写了父类的方法，矩阵会优先选择子类的实现。
- **基于方法的继承**：派发矩阵基于方法进行查找。即便同一方法可以应用于多个类，矩阵会根据方法的具体定义选择最合适的实现。

#### 4. **类继承 vs 方法继承**

- **类继承**更注重类的层次结构。子类自动继承父类的行为，可以通过重写来修改特定行为。
- **方法继承**更关注行为的灵活性，方法可以在不同的类上表现出不同的行为，不必遵循严格的类层次。

#### 总结

- **基于类的继承**依赖于类之间的层次关系，允许子类继承父类的实现并重写特定方法，主要用于代码复用和多态性。
- **基于方法的继承**提供了更灵活的行为，允许方法在不同类型的对象上实现不同的行为，并且无需遵循严格的类层次结构。

这两种继承方式本质上都是派发矩阵的扩展，通过不同的组织方式实现类和方法的复用和重用。

### ------------------------------------

### 26.4 继承的类型

继承可以分为多种类型：

1. **单继承**：每个子类只从一个超类继承行为，这在派发矩阵的构建中相对简单。
2. **多继承**：每个子类可以从多个超类继承行为，这使得派发矩阵的结构更加复杂，因为需要处理多个超类的行为冲突和优先级问题。

为了简化分析，书中只考虑了单继承的情况。单继承的派发矩阵扩展相对直观，直接从超类的行进行复制和覆盖。而多继承则可能涉及更多复杂的行为合并和冲突解决机制。

### 26.5 结论

继承作为面向对象编程中的核心机制，通过复用现有的类和方法行为，实现了代码的模块化和灵活性。在派发矩阵的扩展中，继承为类和方法的定义提供了一种自然的增量式构建方式。通过继承，新的类或方法可以在保持代码简洁的同时，定制化其行为，从而实现更为灵活和可维护的程序设计。

这种机制广泛应用于面向对象编程语言中，如 Java、C++ 和 Python，它们都提供了不同形式的类继承机制，使得程序设计更加模块化和易扩展。

### ---------------------------------

### 26.1 类与方法的扩展 (Class and Method Extension)

在这一节中，我们讨论如何通过**扩展派发矩阵** (dispatch matrix) 来引入新的类或方法。我们从已有的派发矩阵开始，其类型为：
$$
\prod_{c \in C} \prod_{d \in D} (\tau_c \to \rho_d)
$$
其中：
- $C$ 是类的集合。
- $D$ 是方法的集合。
- $\tau_c$ 是类 $c$ 的实例类型 (instance type)。
- $\rho_d$ 是方法 $d$ 的返回类型 (result type)。

### 新类的引入

要将一个新类 $c^* \notin C$ 添加到派发矩阵中，我们需要提供以下信息：
1. **新类的实例类型 $\tau_{c^*}$**：该新类所关联的实例数据类型。
2. **每个现有方法在新类上的行为 $e_{c^* d}$**：对于每个现有的方法 $d \in D$，我们需要定义它在新类 $c^*$ 上的行为，即一个从新类实例类型 $\tau_{c^*}$ 到方法结果类型 $\rho_d$ 的函数：
   $$
   e_{c^* d}: \tau_{c^*} \to \rho_d
   $$

引入新类后，新的派发矩阵 $e^*_{\text{dm}}$ 的定义遵循以下规则：
1. 对于每个现有类 $c \in C$ 和每个现有方法 $d \in D$，新的派发矩阵中的行为保持不变：
   $$
   e^*_{\text{dm}} \cdot c \cdot d = e_{\text{dm}} \cdot c \cdot d
   $$
   也就是说，现有类和方法的行为不会受到新类的引入而改变。
2. 对于每个方法 $d \in D$，新类 $c^*$ 的行为由我们定义的 $e_{c^* d}$ 决定：
   $$
   e^*_{\text{dm}} \cdot c^* \cdot d = e_{c^* d}
   $$

#### 子类的定义

定义 $c^*$ 为某个类 $c \in C$ 的子类 (subclass)，意味着对于某些或全部方法 $d \in D$，我们继承超类 $c$ 上的方法行为 $e_{c d}$。要继承这些方法，必须满足子类型关系：
$$
\tau_c \to \rho_d <: \tau_{c^*} \to \rho_d
$$
即，新类 $c^*$ 的实例类型 $\tau_{c^*}$ 必须是超类 $c$ 的实例类型 $\tau_c$ 的子类型：
$$
\tau_{c^*} <: \tau_c
$$
这确保了新类 $c^*$ 可以安全地继承超类的方法行为。

### 新方法的引入

要将一个新方法 $d^* \notin D$ 添加到派发矩阵中，我们需要提供以下信息：
1. **新方法的返回类型 $\rho_{d^*}$**。
2. **新方法在每个现有类上的行为 $e_{c d^*}$**：对于每个现有类 $c \in C$，我们需要定义新方法在该类上的行为，即一个从该类的实例类型 $\tau_c$ 到新方法的返回类型 $\rho_{d^*}$ 的函数：
   $$
   e_{c d^*}: \tau_c \to \rho_{d^*}
   $$

引入新方法后，新的派发矩阵 $e^*_{\text{dm}}$ 的定义如下：
1. 对于每个现有类 $c \in C$ 和每个现有方法 $d \in D$，新的派发矩阵中的行为保持不变：
   $$
   e^*_{\text{dm}} \cdot c \cdot d = e_{\text{dm}} \cdot c \cdot d
   $$
2. 新方法 $d^*$ 在每个类 $c \in C$ 上的行为由我们定义的 $e_{c d^*}$ 决定：
   $$
   e^*_{\text{dm}} \cdot c \cdot d^* = e_{c d^*}
   $$

#### 子方法的定义

定义 $d^*$ 为某个方法 $d \in D$ 的子方法 (submethod)，意味着对于某些或全部类 $c \in C$，我们继承旧方法 $d$ 在该类上的行为。为了确保这种继承关系是合理的，必须满足以下子类型关系：
$$
\tau_c \to \rho_d <: \tau_c \to \rho_{d^*}
$$
即，旧方法的返回类型 $\rho_d$ 必须是新方法返回类型 $\rho_{d^*}$ 的子类型：
$$
\rho_d <: \rho_{d^*}
$$
这确保了旧方法的结果足够用于新方法的行为。

### 公式详细解析

对于新类的继承规则，我们的子类型关系 $\tau_c \to \rho_d <: \tau_{c^*} \to \rho_d$ 确保了新类可以继承现有方法的行为。这意味着新类的实例类型必须是旧类实例类型的子类型，从而保证了新类可以正确使用旧类的方法。同样，对于新方法的继承规则 $\tau_c \to \rho_d <: \tau_c \to \rho_{d^*}$ 确保了新方法的返回类型是旧方法返回类型的超类型，从而保证新方法可以在现有类上正常使用。

总结一下，继承机制通过在派发矩阵中逐行或逐列扩展，确保类和方法可以在新的环境下继承已有的行为，并在必要时对其进行重写。这一机制提供了灵活性，同时确保了类型系统的安全性。

### ---------------------------------

### 26.2 基于类的继承 (Class-Based Inheritance)

在**基于类的组织** (Class-Based Organization) 中，类向量 (class vector) 被定义为一个**类构造器的元组**，这些构造器用于为每个类的对象指定该类方法的行为。类向量的类型为：
$$
\tau_{\text{cv}} = \prod_{c \in C} (\tau_c \to \rho)
$$
其中：
- $C$ 是类的集合。
- $\tau_c$ 是类 $c$ 的实例类型 (instance type)。
- $\rho = \prod_{d \in D} \rho_d$ 是**对象类型** (object type)，即所有方法的结果类型的有限积类型。

### 添加新类

当我们向现有派发矩阵中添加一个新类 $c^*$ 时，新的类向量 $e^*_{\text{cv}}$ 的类型为：
$$
\tau^*_{\text{cv}} = \prod_{c \in C^*} (\tau_c \to \rho)
$$
其中 $C^* = C \cup \{ c^* \}$ 是类集合的扩展。我们可以将这个类型看作是以下类型的**同构**：
$$
\tau_{\text{cv}} \times (\tau_{c^*} \to \rho)
$$
这意味着新的类向量实际上是在旧的类向量的基础上进行扩展，并加入了新类 $c^*$ 的构造器。

#### 新类向量的定义

新的类向量 $e^*_{\text{cv}}$ 可以写成：
$$
\langle e_{\text{cv}}, \lambda (u:\tau_{c^*}) \langle d \mapsto e_{c^* d}(u) \rangle_{d \in D} \rangle^\dagger
$$
- $e_{\text{cv}}$ 是旧的类向量，它在新的类向量中被保留。
- $\lambda (u:\tau_{c^*}) \langle d \mapsto e_{c^* d}(u) \rangle_{d \in D}$ 是新类 $c^*$ 的构造器，定义了新类在每个方法 $d \in D$ 上的行为 $e_{c^* d}$。

通过这个定义可以看出，新类向量 $e^*_{\text{cv}}$ 仅仅是在旧的类向量基础上扩展的结果。旧的类向量保持不变，而新类的构造器则是新加的部分。

#### 继承机制

在添加新类时，即使新类 $c^*$ 继承自某个现有类 $c$，我们只能保证其定义上的继承关系，而不能推断任何关于其行为的具体信息。换句话说，继承记录的是类的**定义历史**，而不是行为的语义。因此，虽然 $c^*$ 可以通过继承 $c$ 的行为定义，但它的对象行为可能与 $c$ 的对象行为有很大差异。

### 添加新方法

当我们向派发矩阵中添加一个新方法 $d^*$ 时，新的类向量 $e^*_{\text{cv}}$ 的类型变为：
$$
\tau^*_{\text{cv}} = \prod_{c \in C} (\tau_c \to \rho^*)
$$
其中 $\rho^* = \prod_{d \in D^*} \rho_d$，而 $D^* = D \cup \{ d^* \}$ 是方法集合的扩展。此时，$\rho^*$ 可以视为类型 $\rho \times \rho_{d^*}$ 的**同构**，其中 $\rho$ 是旧的对象类型，$\rho_{d^*}$ 是新方法 $d^*$ 的返回类型。

#### 新方法的类向量定义

新的类向量可以写成：
$$
\langle c \mapsto \lambda (u:\tau_c) \langle \langle d \mapsto ((e_{\text{cv}} \cdot c)(u)) \cdot d \rangle_{d \in D}, e_{c d^*}(u) \rangle^\ddagger \rangle_{c \in C}
$$
- 对于每个类 $c \in C$，我们为新方法 $d^*$ 重新定义了类的构造器。
- 旧的方法行为保留在类向量 $e_{\text{cv}}$ 中，但新方法的行为 $e_{c d^*}(u)$ 被添加到新类向量中。

### 对象类型的子类型关系

通过这个构造，新对象类型 $\rho^*$ 是旧对象类型 $\rho$ 的**子类型**。这意味着含有新方法的对象可以在要求旧方法行为的上下文中使用。这种设计确保了新类和新方法的向后兼容性。通过限制继承机制，仅允许在新子类中添加新方法，可以避免重新定义旧类，同时保证子类具有更多的方法。

#### 公式详细解析

对于公式 $\tau_{\text{cv}} \times (\tau_{c^*} \to \rho)$，我们可以解释为：我们在现有类向量 $\tau_{\text{cv}}$ 基础上添加了一个新的函数类型 $(\tau_{c^*} \to \rho)$，表示新类 $c^*$ 的构造器。新方法的类向量公式 $\rho \times \rho_{d^*}$ 表示添加了一个新的返回类型 $\rho_{d^*}$，而新的类向量中每个构造器都需要处理这个扩展。

公式：
$$
\tau^*_{\text{cv}} = \prod_{c \in C} (\tau_c \to \rho^*)
$$
意味着新的类向量处理扩展后的类集合和方法集合，保持旧的行为定义并扩展新的行为。

### ---------------------------------

### 26.3 基于方法的继承 (Method-Based Inheritance)

在**基于方法的组织** (Method-Based Organization) 中，方法向量 (method vector) 定义了每个方法在所有类上的行为。方法向量的类型是：
$$
\tau_{\text{mv}} = \prod_{d \in D} (\tau \to \rho_d)
$$
其中：
- $D$ 是方法的集合。
- $\tau$ 是对象的类型，它是类实例类型的**和类型** (sum type)，即 $\tau = \sum_{c \in C} \tau_c$。
- $\rho_d$ 是方法 $d$ 的返回类型。

方法向量是一个函数元组，每个函数根据对象的类派发其行为。

### 添加新方法

当我们向派发矩阵中添加一个新方法 $d^*$ 时，新的方法向量 $e^*_{\text{mv}}$ 的类型变为：
$$
\tau^*_{\text{mv}} = \prod_{d \in D^*} (\tau \to \rho_d)
$$
为了简化理解，这里引入了类型的**同构**：
$$
\tau^*_{\text{mv}} \cong \tau_{\text{mv}} \times (\tau \to \rho_{d^*})
$$
这意味着新方法向量是对旧方法向量的扩展，新增加的部分是新方法 $d^*$ 对应的派发函数。

#### 新方法向量的定义

新方法向量可以写成：
$$
\langle e_{\text{mv}}, \lambda (this:\tau) \ \text{case this} \ \{c \cdot u \Rightarrow e_{c d^*}(u)\}_{c \in C} \rangle^\ddagger
$$
- $e_{\text{mv}}$ 是旧的方法向量，保留了对旧方法的定义。
- $\lambda (this:\tau) \ \text{case this} \ \{c \cdot u \Rightarrow e_{c d^*}(u)\}$ 是新方法 $d^*$ 的派发函数，定义了新方法 $d^*$ 在类 $c$ 上的行为 $e_{c d^*}$。

由于对象类型 $\tau$ 没有改变，因此新对象可以在需要旧对象的上下文中正常使用，新添加的方法在这种情况下会被忽略。这是因为新方法的返回类型 $\rho^*$ 是旧返回类型 $\rho$ 的**超类型** (supertype)，因此对象类型之间的子类型关系 $\rho^* <: \rho$ 保持了兼容性。

### 添加新类

当我们向派发矩阵中添加一个新类 $c^*$ 时，新的方法向量 $e^*_{\text{mv}}$ 的类型变为：
$$
\tau^*_{\text{mv}} = \prod_{d \in D} (\tau^* \to \rho_d)
$$
其中 $\tau^*$ 是新对象类型 $\sum_{c \in C^*} \tau_c$，它是旧对象类型 $\tau = \sum_{c \in C} \tau_c$ 的超类型。

通过类型的同构关系：
$$
\tau^* \cong \tau + \tau_{c^*}
$$
我们可以定义新的方法向量为：
$$
\langle d \mapsto \lambda (this:\tau^*) \ \text{case this}^\dagger \ \{l \cdot u \Rightarrow (e_{\text{mv}} \cdot d)(u) \ |\ r \cdot u \Rightarrow e_{c^* d}(u)\} \rangle_{d \in D}
$$
- 对于旧类 $c$，我们保持旧的派发行为 $(e_{\text{mv}} \cdot d)(u)$。
- 对于新类 $c^*$，我们定义新的行为 $e_{c^* d}(u)$，它根据新类 $c^*$ 的实例类型 $\tau_{c^*}$ 执行方法 $d$。

这个定义确保了我们可以在方法向量中重新利用旧的派发矩阵，只需要为新类 $c^*$ 重新定义每个方法的行为。

### 公式解析

#### 添加新方法

公式：
$$
\tau^*_{\text{mv}} \cong \tau_{\text{mv}} \times (\tau \to \rho_{d^*})
$$
表示新方法向量是对旧方法向量 $\tau_{\text{mv}}$ 的扩展，加入了一个新的函数 $(\tau \to \rho_{d^*})$ 来处理新方法 $d^*$ 的行为。

新的派发函数公式：
$$
\lambda (this:\tau) \ \text{case this} \ \{c \cdot u \Rightarrow e_{c d^*}(u)\}_{c \in C}
$$
表示对于每个类 $c$，新方法 $d^*$ 的行为 $e_{c d^*}(u)$ 被定义为根据类实例 $u$ 执行的函数。

#### 添加新类

公式：
$$
\tau^* \cong \tau + \tau_{c^*}
$$
表示新对象类型 $\tau^*$ 是旧对象类型 $\tau$ 和新类类型 $\tau_{c^*}$ 的和类型。同样的，我们在新方法向量中处理新类时，使用了和类型的派发机制：
$$
\lambda (this:\tau^*) \ \text{case this}^\dagger \ \{l \cdot u \Rightarrow (e_{\text{mv}} \cdot d)(u) \ |\ r \cdot u \Rightarrow e_{c^* d}(u)\}
$$
表示对于旧类，我们保持旧行为，对于新类，我们定义新的行为。

这种方式通过重新利用旧向量，保证了新的类和方法继承的有效性。

### ---------------------------------

### 26.4 Notes

在**面向对象编程** (Object-Oriented Programming, OOP) 的讨论中，关于**继承** (inheritance) 的重要性存在不同的观点：

- **哲学家** (philosophers) 强调继承的重要性，认为继承是面向对象编程的核心特征之一。它通过类之间的层次结构，支持代码重用和概念上的组织。
  
- **实际开发者** (practitioners) 则往往避免大量使用继承，或者将其简化为形式上的存在。在实践中，过度使用继承可能会带来复杂的类层次结构，导致难以维护和扩展。开发者更倾向于使用其他模块化机制来组织代码，减少对继承的依赖。

这些模块化机制将在第45章和第46章中详细讨论。这些章节将探讨如何通过更灵活和现代的方式来实现代码的复用和组织，避免继承带来的缺点。

---

#### 关于继承与子类型的讨论

- **Abadi 和 Cardelli** 在 1996 年的研究中提供了详细的继承与**子类型** (subtyping) 交互机制的解释。他们探讨了继承如何在类型系统中表现为子类型关系，进一步阐述了如何确保子类能够在需要父类的上下文中安全地使用。

- **Pierce (2002)** 同样给出了详细的讨论，重点在于继承如何与类型理论结合，特别是在类型系统的框架下，如何通过继承扩展类的行为，同时保持类型的安全性。

#### 行为角度的继承要求

- **Liskov 和 Wing (1994)** 提出了一个关于继承的**行为一致性** (behavioral consistency) 方法论要求，即：
  - 当使用继承时，**子类** (subclass) 必须尊重**超类** (superclass) 的行为。这意味着子类的行为必须与父类的行为保持一致，不能违反父类的行为规范。
  

这一要求被称为**Liskov 替换原则** (Liskov Substitution Principle, LSP)，它确保了面向对象系统的健壮性，避免了子类在违反父类合同的情况下破坏系统行为。

LSP 的核心是子类在任何父类可用的地方也应该能安全地使用，这种一致性是保证类型安全和系统稳定性的关键。这也是继承和子类型之间相互作用的一个重要方面。

---

通过这些讨论可以看出，继承虽然在哲学上被认为是面向对象编程的核心，但在实际开发中，它往往被简化或者用其他更灵活的模块化机制替代。无论是从行为角度还是类型系统的角度，继承和子类型的交互需要严格的规则，以保证系统的正确性和安全性。


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------
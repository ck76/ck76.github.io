[toc]



### 第三章 假设和一般判断 (Chapter 3: Hypothetical and General Judgments)

在这一章中，主要讨论了两种形式的判断：**假设判断**(Hypothetical Judgments) 和 **一般判断**(General Judgments)。这些概念在逻辑、类型论和编程语言理论中起到了重要作用，帮助我们处理带有前提或变量的推理。

#### 3.1 假设判断 (Hypothetical Judgments)

**假设判断**表示一种从一个或多个假设到结论的**蕴涵关系**(entailment)。它的一般形式是：

$$
\Gamma \vdash J
$$

这里 $\Gamma$ 表示假设，$J$ 表示结论。这意味着在假设 $\Gamma$ 为真的条件下，结论 $J$ 也是成立的。

在这一章中，讨论了两种不同的蕴涵形式：**可导性**(Derivability) 和 **可容性**(Admissibility)。

##### 3.1.1 可导性 (Derivability)

**可导性**是一种结构性判断，表示在给定的规则系统下，从假设可以**推导**出结论。可导性的一个关键特性是它在规则扩展下是**稳定的**(stable under extension with new rules)。即使引入新的推导规则，已有的推导仍然有效。

例如，在自然数系统中，我们可以通过规则：
1. $zero\ \text{nat}$ 表示 $0$ 是自然数；
2. $succ(a)\ \text{nat}$ 表示如果 $a$ 是自然数，则 $succ(a)$ 也是自然数。

假设我们有新的规则定义一个新的操作 $f$，可导性表明，即使有了新的规则，之前关于自然数的推导结果仍然有效。

##### 3.1.2 可容性 (Admissibility)

**可容性**与可导性类似，但不同之处在于它在规则扩展下**不一定稳定**。换句话说，新的规则可能会使得某些先前被认为可容的推导不再有效。

可容性用于描述那些基于现有规则系统内可能成立的推导。虽然它没有可导性那么强的稳定性，但它在实际推导中也起到了重要作用。

#### 3.2 假设归纳定义 (Hypothetical Inductive Definitions)

在归纳定义中，假设判断可以引入额外的前提。例如，归纳定义可以以假设的形式进行扩展，使用规则来表明如何从假设中推导出结论。

例如，对于自然数的归纳定义，可以引入一个假设 $a\ \text{nat}$，并定义归纳规则来描述自然数的性质：
- $zero\ \text{nat}$：$0$ 是自然数。
- $succ(a)\ \text{nat}$：如果 $a$ 是自然数，那么 $succ(a)$ 也是自然数。

我们可以用归纳法来处理假设，并推导出关于自然数的一般性质。

#### 3.3 一般判断 (General Judgments)

**一般判断**用于表达某个判断的**普遍性**(universality) 或**泛化性**(genericity)。在一般判断中，判断形式可以涉及变量的所有替换或符号的重命名。

有两种形式的**一般判断**：
1. **泛化判断**(Generic Judgment)：表达一个判断在所有变量替换下的普遍性。例如，给定一个表达式 $e$，泛化判断表示 $e$ 在所有变量替换的实例下仍然成立。
2. **参数化判断**(Parametric Judgment)：表达一个判断在符号重命名下的普遍性。参数化判断强调，在符号被重命名时，推导结构不变。

##### 3.3.1 泛化归纳定义 (Generic Inductive Definitions)

**泛化归纳定义**通过在归纳过程中引入变量替换来表示判断的普遍性。例如，在类型系统中，我们可能会定义一个带有类型变量的泛化类型推导规则。这样的推导规则对所有可能的类型替换都是成立的。

#### 3.4 总结 (Summary)

在这一章中，**假设判断**和**一般判断**是推理系统中的核心概念。它们帮助我们处理推导中前提条件的假设和变量替换的泛化。通过引入可导性、可容性和归纳定义，进一步扩展了这些概念在逻辑和编程语言中的应用。

### 进一步说明

- **可导性和可容性**：可导性在规则扩展时是稳定的，而可容性可能会受到新规则的影响。这两者的区别在于系统的可扩展性。
- **假设判断的广泛应用**：假设判断在函数定义、递归推导以及类型系统的定义中有广泛的应用。它为处理复杂推理提供了坚实的逻辑框架。

### ---------------------------------

### 3.1 假设判断 (Hypothetical Judgments)

**假设判断**(Hypothetical Judgments) 用于表达在某些前提下结论的有效性。这种判断形式非常重要，因为它可以在推理中引入临时前提，基于这些前提推导出结论。假设判断的两个关键形式分别为**可导性**(Derivability) 和**可容性**(Admissibility)，它们的主要区别在于对于新增规则的稳定性。

#### 3.1.1 可导性 (Derivability)

**可导性**是一种基于规则系统 $R$ 的推导判断。形式上，**可导性判断**写作：

$$
J_1, J_2, \dots, J_k \vdash_R K
$$

这表示我们可以在规则集 $R$ 的基础上，扩展新的临时公理 $J_1, J_2, \dots, J_k$，然后从这些前提推导出结论 $K$。这个推导可以看作是将假设 $J_1, J_2, \dots, J_k$ 作为“临时公理”，并通过组合 $R$ 中的规则来推导结论 $K$。

##### 推导的记号

在表达可导性时，我们通常使用希腊字母（例如 $\Gamma$ 或 $\Delta$）表示一组有限的基本判断。记号 $\Gamma \vdash_R K$ 表示可以从规则集 $R$ 扩展 $\Gamma$ 这些假设公理推导出 $K$。

例如，假设我们定义了自然数的规则集 $R$，包含以下规则：
1. $zero\ \text{nat}$ 表示 $0$ 是自然数；
2. $succ(a)\ \text{nat}$ 表示如果 $a$ 是自然数，那么 $succ(a)$ 也是自然数。

在这个规则系统下，假设判断 $a\ \text{nat} \vdash_R \text{succ(succ}(a))\ \text{nat}$ 就表示，如果我们假设 $a$ 是自然数，我们可以通过规则推导出 $succ(succ(a))$ 也是自然数。

##### 可导性例子

考虑下面的推导例子：

$$
a\ \text{nat} \vdash_{\text{(2.2)}} \text{succ(succ}(a))\ \text{nat}
$$

这是基于规则 (2.2) 的一个推导判断。该推导的有效性可以通过如下推理树表示：

$$
\frac{a\ \text{nat}}{\text{succ}(a)\ \text{nat}} \quad \frac{\text{succ}(a)\ \text{nat}}{\text{succ(succ}(a))\ \text{nat}}
$$

这个推导表明：如果我们假设 $a$ 是自然数，通过规则 (2.2)，我们可以推导出 $succ(succ(a))$ 也是自然数。这种推导形式可以概括为以下规则形式：

$$
\frac{a\ \text{nat}}{\text{succ(succ}(a))\ \text{nat}}
$$

##### 可导性的稳定性 (Stability of Derivability)

**定理 3.1（稳定性）**：如果 $\Gamma \vdash_R J$，那么对于扩展的规则集 $R \cup R_0$，我们依然有 $\Gamma \vdash_{R \cup R_0} J$。

这个定理的证明是直接的：任何从 $R[\Gamma]$ 推导 $J$ 的推导方式，同样适用于扩展的规则集 $(R \cup R_0)[\Gamma]$，因为 $R$ 中的规则也包含在 $R \cup R_0$ 中。

##### 可导性的结构性质 (Structural Properties of Derivability)

**可导性**具有一些重要的**结构性质**，这些性质与所使用的具体规则无关，而是由可导性的定义本身决定的：

1. **自反性**(Reflexivity)：每个判断都是自身的结论，即 $\Gamma, J \vdash_R J$。这是因为假设本身可以用来推导出自身的有效性。
   
2. **削弱性**(Weakening)：如果 $\Gamma \vdash_R J$，那么加入新的假设 $K$ 也不影响结论的推导，即 $\Gamma, K \vdash_R J$。这意味着没有使用的假设不会影响推导结果。

3. **传递性**(Transitivity)：如果 $\Gamma, K \vdash_R J$ 且 $\Gamma \vdash_R K$，那么 $\Gamma \vdash_R J$。这表示可以通过替换一个假设为其推导的结论，来实现更复杂的推导。

这些性质为假设推导提供了灵活性和一致性，确保了推导系统的逻辑健全性。

### 详细解释 (Detailed Explanation)

#### 假设判断的推导与结构性质

**假设判断**的推导可以理解为一种临时推理机制，它允许我们在推导过程中引入假设，推导结束后，假设可以被撤销。这种灵活性特别适用于函数定义、递归推导以及类型系统的设计。

**自反性**保证了每个判断都可以由自身推导，这为证明推导规则的有效性提供了基础。**削弱性**确保了我们可以在推导中加入额外的假设，而不影响结论，这使得推导过程更加通用。**传递性**则允许我们通过中间推导一步步推向最终结论，形成复杂推导结构。

#### 可导性的稳定性

可导性的一个关键特性是**稳定性**，即新增规则不会影响已有推导的正确性。这种稳定性确保了推导系统可以扩展和发展，而不破坏已有的推导。这对于设计可扩展的逻辑系统和编程语言非常重要，因为我们通常希望能够通过引入新规则来增强系统，而不影响现有的推导结果。

#### 可导性在编程语言中的应用

在编程语言理论中，可导性广泛用于描述**类型系统**和**操作语义**。例如，在类型推导中，我们可以通过引入类型规则来推导出表达式的类型，并确保这些推导在扩展系统时仍然有效。在操作语义中，假设推导允许我们描述程序在不同状态下的执行行为，并推导出程序的最终状态。

通过可导性，我们可以设计健全且灵活的编程语言推导系统，确保程序的正确性和行为的一致性。

### ---------------------------------

### 3.1.2 可容性 (Admissibility)

**可容性**(Admissibility) 是一种相对较弱的假设判断形式，写作 $\Gamma \models_R J$，它表示：如果可以从规则集 $R$ 中推导出假设 $\Gamma$，那么结论 $J$ 也是可以推导出来的。与可导性不同的是，如果任何假设在 $R$ 中不可推导，则判断是**平凡成立**(vacuously true)。

#### 可容性的定义

形式上，$\Gamma \models_R J$ 表示 $\vdash_R \Gamma$ 隐含 $\vdash_R J$。换句话说，假设 $J_1, J_2, \dots, J_n$ 是一组推导出来的假设，那么如果 $J_1, J_2, \dots, J_n$ 可以从规则集 $R$ 中推导出来，则 $J$ 也可以从 $R$ 推导出来。

可容性判断的另一种等价表示是：假设推导规则
$$
\frac{J_1, \dots, J_n}{J}
$$
相对于规则集 $R$ 是**可容的**(admissible)。这意味着，如果我们有从规则集 $R$ 推导出 $J_1, J_2, \dots, J_n$ 的推导方式，那么就可以使用 $R$ 的规则推导出 $J$。

#### 可容性例子

考虑以下可容性判断：
$$
\text{succ}(a)\ \text{nat} \models_{(2.2)} a\ \text{nat}
$$
这个判断表示，假设我们可以从规则 (2.2) 中推导出 $\text{succ}(a)\ \text{nat}$，那么我们也可以推导出 $a\ \text{nat}$。

这个可容性判断是有效的，因为任何 $\text{succ}(a)\ \text{nat}$ 的推导必须包含一个关于 $a\ \text{nat}$ 的子推导。所以我们可以推导出结论 $a\ \text{nat}$。

我们可以用以下规则表示这一推导的可容性：
$$
\frac{\text{succ}(a)\ \text{nat}}{a\ \text{nat}}
$$
这个推导规则表明：如果 $\text{succ}(a)\ \text{nat}$ 可以被推导出，那么 $a\ \text{nat}$ 也是可以被推导出来的。

#### 可容性的稳定性

与可导性不同，**可容性**在扩展规则集时不是稳定的。也就是说，新增规则可能会使之前的可容性判断变得无效。一个典型的例子是，如果我们在规则 (2.2) 中加入以下公理：
$$
\text{succ(junk)}\ \text{nat}
$$
其中 $junk$ 是某个对象，但 $junk\ \text{nat}$ 是不可推导的，那么我们就无法从 $\text{succ}(junk)\ \text{nat}$ 推导出 $junk\ \text{nat}$。这使得可容性判断：
$$
\text{succ}(a)\ \text{nat} \models_{(2.2)} a\ \text{nat}
$$
不再有效。这是因为新引入的规则没有前提条件，无法通过组合其他规则推导出 $junk\ \text{nat}$，因此原有的可容性被破坏。

#### 可导性与可容性的关系

**可导性**比**可容性**更强，因为它在规则集的扩展下是稳定的，而可容性则对规则集中的规则是否存在非常敏感。换句话说，如果某个推导在可导性下是成立的，那么它一定在可容性下也是成立的。但反之则不一定成立。

### 详细讲解 (Detailed Explanation)

#### 可容性的本质

**可容性**强调在给定的规则系统中，只要假设都可以推导出，那么结论也是可以推导出来的。然而，如果某些假设是不可推导的，那么整个判断的可容性就是平凡成立的。这在逻辑推理中是一个非常常见的现象，当前提不成立时，结论无论如何都是成立的。这也是可容性与可导性不同的一个重要方面。

#### 可容性和系统的扩展

可容性在系统扩展时不具有稳定性，意味着当我们加入新的规则时，之前的某些可容推导可能会被破坏。就像在上面的例子中，如果我们引入了一个新的规则，使得 $succ(junk)\ \text{nat}$ 成立，但没有规则推导出 $junk\ \text{nat}$，这就破坏了可容性判断 $\text{succ}(a)\ \text{nat} \models a\ \text{nat}$。这说明**可容性在规则集的定义上是非常敏感的。**

#### 可容性在编程语言中的应用

在编程语言设计中，**可容性**经常用于表达某些操作的有效性。特别是在类型系统或操作语义的设计中，我们可能会依赖可容性来验证某些操作的正确性。然而，由于它对规则系统的变化非常敏感，因此可容性通常在更加严格的系统扩展时需要重新验证。

可导性和可容性的这种关系，帮助我们理解系统扩展时的推导稳定性，并在设计健壮的推理系统时起到了重要作用。

### ---------------------------------

### 定理 3.2：假设 $\Gamma \vdash_R J$，那么 $\Gamma \models_R J$
**证明**：可导性的传递性表明，如果 $\Gamma \vdash_R J$ 并且 $\vdash_R \Gamma$，那么 $\vdash_R J$。换句话说，只要假设 $\Gamma$ 在规则 $R$ 下是可导的，那么结论 $J$ 也是可导的。

然而，反过来则不成立。我们可以举反例证明：没有任何规则的组合可以使得 
$$
\text{succ(junk)}\ \text{nat} \vdash_{(2.2)} \text{junk}\ \text{nat},
$$
但可容性判断
$$
\text{succ(junk)}\ \text{nat} \models_{(2.2)} \text{junk}\ \text{nat}
$$
依然平凡成立。这表明即使假设是不可导的，可容性判断仍然可以成立。

### 可容性与可导性的关系

**可容性** 可以看作是一种函数，它将假设的推导 $\nabla_1, \dots, \nabla_n$ 转换为结论 $J$ 的推导 $\nabla$。因此，可容性享有与可导性相同的结构性质，属于假设判断的一种形式。

#### 可容性的结构性质

1. **自反性**(Reflexivity)：如果 $J$ 可以从原始规则导出，那么 $J$ 也可以从原始规则导出，即 $J \models_R J$。
2. **削弱性**(Weakening)：如果 $J$ 在假设 $\Gamma$ 可导的条件下可导，那么在假设 $\Gamma$ 和 $K$ 可导的条件下，$J$ 依然可导。即如果 $\Gamma \models_R J$，那么 $\Gamma, K \models_R J$。
3. **传递性**(Transitivity)：如果 $\Gamma, K \models_R J$ 并且 $\Gamma \models_R K$，那么 $\Gamma \models_R J$。这意味着，如果 $\Gamma$ 可导，那么 $K$ 也是可导的，进而 $J$ 也是可导的。

### 定理 3.3：可容性判断 $\Gamma \models_R J$ 享有结构性质
**证明**：可容性的定义表明，如果假设相对于规则集 $R$ 是可导的，那么结论也是可导的。因此，可容性判断享有与可导性类似的结构性质，如自反性、削弱性和传递性。

### 可容性与规则集的关系

如果某条规则 $r$ 相对于规则集 $R$ 是可容的，那么 $\vdash_{R, r} J$ 等价于 $\vdash_R J$。这是因为：
- 如果 $\vdash_R J$，那么显然 $\vdash_{R, r} J$；
- 反过来，如果 $\vdash_{R, r} J$，那么我们可以将任何 $r$ 的使用替换为在 $R$ 中的推导规则。

因此，通过 $R, r$ 的规则推导得到的结论 $J$，可以通过 $R$ 本身的规则推导得到。由此可见，如果我们希望证明对于 $\vdash_{R, r} J$，命题 $P(J)$ 成立，那么只需要验证 $P$ 对规则 $R$ 封闭即可。

### 详细解释

#### 可容性与传递性

**可容性**的传递性保证了我们可以通过一步步的推导，将假设中的推导替换为结论。比如，如果我们知道 $K$ 在 $\Gamma$ 假设下是可导的，同时 $\Gamma$ 本身也可以推导出 $K$，那么整个系统就可以通过组合推导出结论 $J$。

#### 可容性与可导性的关系

虽然**可容性**和**可导性**在推理结构上有相似之处，但两者的本质区别在于：

- 可容性允许平凡成立的判断，而可导性则要求从假设推导出结论的实际步骤。

### ---------------------------------

### 3.2 假设归纳定义 (Hypothetical Inductive Definitions)

在编程语言和逻辑的推导系统中，**归纳定义**(inductive definition) 是非常重要的，它用于逐步构建推导规则。假设归纳定义通过引入假设推导的方式，使我们能够在规则中使用局部假设来推导特定的前提，同时也可以通过全局假设约束推导。

#### 假设归纳定义的形式

假设归纳定义的规则有如下形式：

$$
\frac{\Gamma \ \Gamma_1 \vdash J_1 \quad \cdots \quad \Gamma \ \Gamma_n \vdash J_n}{\Gamma \vdash J}
$$

这个形式中的 $\Gamma$ 是规则的**全局假设**(global hypotheses)，而 $\Gamma_i$ 是第 $i$ 个前提的**局部假设**(local hypotheses)。该规则的含义是：当在全局假设 $\Gamma$ 和局部假设 $\Gamma_i$ 下，可以推导出 $J_1, J_2, \dots, J_n$ 时，那么我们可以推导出结论 $J$。

#### 局部和全局假设的关系

在推导过程中，每个前提的推导涉及到“**上下文切换**”(context switch)，即我们在推导前提时，将全局假设 $\Gamma$ 与当前前提的局部假设 $\Gamma_i$ 结合，形成新的推导上下文。在该上下文中，推导出当前的前提 $J_i$，然后将这种推导方式逐步应用于每个前提，最终推导出结论 $J$。

#### 统一规则 (Uniform Rules)

在大多数情况下，规则是对所有全局上下文的选择进行统一陈述的，这称为**统一规则**(uniform rule)。统一规则的形式是：

$$
\frac{\Gamma_1 \vdash J_1 \quad \dots \quad \Gamma_n \vdash J_n}{J}
$$

这种形式省略了全局假设 $\Gamma$，表示该规则对于所有全局上下文都是通用的。

#### 结构性 (Structurality)

假设归纳定义可以看作是形式推导判断 $\Gamma \vdash J$ 的一种普通归纳定义。这里的 $\Gamma$ 是一组有限的基本判断，$J$ 是一个基本判断。假设归纳定义的规则集 $R$ 用于定义一个形式推导判断，这个判断需要满足两个关键性质：

1. **结构性**(Structurality)：形式推导判断必须在以下规则下封闭：
   - **自反性**：
     $$
     \frac{\Gamma \vdash J}{\Gamma, J \vdash J}
     $$
   - **削弱性**：
     $$
     \frac{\Gamma \vdash J}{\Gamma, K \vdash J}
     $$
   - **传递性**：
     $$
     \frac{\Gamma \vdash K \quad \Gamma, K \vdash J}{\Gamma \vdash J}
     $$
     这些规则确保了推导判断在假设下能够保持一致性。

2. **规则归纳原理**(Principle of Rule Induction)：为了证明某个性质 $P$ 对于任何推导判断 $\Gamma \vdash_R J$ 成立，必须证明 $P$ 在 $R$ 和结构规则下是封闭的。也就是说，对于每个推导规则，无论是结构规则还是归纳定义中的规则，都要验证以下性质：
   - 如果 $P(\Gamma \ \Gamma_1 \vdash J_1), \dots, P(\Gamma \ \Gamma_n \vdash J_n)$ 成立，那么 $P(\Gamma \vdash J)$ 也成立。

这是第 2 章中规则归纳原理的特例，专门应用于形式推导判断。

### 假设归纳定义的实际应用

在实践中，我们可以通过证明结构规则是**可容的**(admissible) 来简化推导。可容性意味着在推导过程中，我们可以忽略这些结构规则，专注于规则集 $R$ 中的规则。如果所有假设归纳定义的规则都是**统一的**(uniform)，那么结构规则的削弱性和传递性都是可容的，只需要明确地引入自反性规则即可。

### 详细解释 (Detailed Explanation)

#### 假设归纳定义的核心概念

**假设归纳定义**通过引入局部假设和全局假设的概念，允许我们在推导过程中更加灵活。局部假设提供了对特定推导步骤的约束，而全局假设则确保了推导的一致性和上下文的稳定性。

#### 上下文切换 (Context Switch)

在实际推导中，**上下文切换**是非常关键的概念。每当我们推导某个前提时，必须结合当前前提的局部假设，这实际上是创建了一个新的推导环境。这个过程类似于在程序执行时临时创建一个局部变量环境，局部变量在这个环境中生效，但不会影响全局变量的状态。

#### 结构性规则的作用

**结构性规则**确保了推导系统的健壮性。自反性规则保证每个判断都可以作为自身的结论，削弱性规则允许我们在推导过程中添加新的假设，而不会影响最终的结论，传递性则确保了我们可以组合推导链条，从而得出复杂推导。

#### 规则归纳原理的应用

在推导系统中，**规则归纳原理**(rule induction) 是一种常用的证明技术，用于证明某个推导系统的性质。例如，如果我们想证明某个推导系统的完备性或一致性，可以通过证明规则系统在每个推导规则下都保持该性质，从而证明整个系统的正确性。

#### 形式推导判断与编程语言

假设归纳定义和推导规则在编程语言的**类型系统**和**操作语义**设计中至关重要。通过定义局部和全局假设，类型系统可以确保类型推导过程的健全性。例如，当我们定义一个函数的类型时，函数的参数和返回值的类型是局部假设，而全局类型规则是确保推导一致性的基础。

总的来说，假设归纳定义为复杂的推导系统提供了灵活且强大的工具，能够处理局部约束和全局推导需求。

### ---------------------------------

### 3.3 通用判断 (General Judgments)

**通用判断**是一类用于处理判断中变量的规则。就像数学中对变量的处理一样，变量被看作是从某个指定对象集中的未知数。通用判断有两种主要形式：

1. **泛型判断** (Generic Judgment)：表示某个判断对于所有可能替代指定变量的对象都成立。
2. **参数化判断** (Parametric Judgment)：表示某个判断对于任何指定参数的重命名都成立。

#### 泛型判断 (Generic Judgment)

泛型判断的目的是处理那些在不同上下文中使用的变量。例如，数学中的变量通常表示任意数，类似地，泛型判断中涉及的变量可以是某个范围内的任意对象。为了表达这种变量的通用性，泛型推导判断的形式化定义如下：

$$
\tilde{x} \mid \Gamma \vdash_X^R J \iff \forall \pi : \tilde{x} \leftrightarrow \tilde{x}^\prime \ \pi \cdot \Gamma \vdash_{X,\tilde{x}^\prime}^R \pi \cdot J
$$

其中 $\tilde{x}$ 表示一组变量，$\Gamma$ 是假设，$J$ 是推导结论，$\pi$ 是对变量的重命名操作。**关键点**在于，$\pi$ 表示对这些变量进行重命名的一个映射，并且新的变量 $\tilde{x}^\prime$ 必须是 "新鲜的"（即不在 $X$ 中已有的变量集合中）。**证据**是泛型推导过程中的推导树 $\nabla$，表示每一个新的重命名都可以得到相应的推导结果。

例如，考虑以下推导树：

$$
x \ \text{nat} \\
\frac{}{\text{succ}(x) \ \text{nat}} \\
\frac{}{\text{succ(succ}(x)) \ \text{nat}}
$$

它是判断 $x \ \text{nat} \vdash \text{succ(succ}(x)) \ \text{nat}$ 的**证据**。不论将 $x$ 重命名为什么（例如 $y$），这个推导仍然成立。重命名确保了判断的泛型性，不依赖于特定的变量名。

#### 泛型推导判断的结构性质

泛型推导判断享有几个重要的结构性质，这些性质帮助我们处理推导中的变量行为：

1. **增殖性 (Proliferation)**：如果 $\tilde{x} \mid \Gamma \vdash_X^R J$，那么 $\tilde{x}, x \mid \Gamma \vdash_X^R J$ 也成立。这意味着我们可以在推导中添加额外的变量，而不影响结论的有效性。
   
2. **重命名 (Renaming)**：如果 $\tilde{x}, x \mid \Gamma \vdash_X^R J$，那么对于任意不在 $X, \tilde{x}$ 中的变量 $x^\prime$，$[x \leftrightarrow x^\prime] \cdot \Gamma \vdash_X^R [x \leftrightarrow x^\prime] \cdot J$ 也成立。也就是说，我们可以任意重命名变量，推导的正确性仍然保持。

3. **替换 (Substitution)**：如果 $\tilde{x}, x \mid \Gamma \vdash_X^R J$ 并且 $a \in B[X, \tilde{x}]$，那么 $[a/x] \Gamma \vdash_X^R [a/x] J$ 也成立。替换操作要求被替换的对象和变量具有相同的类型或排序。

这些结构性质确保了泛型判断在处理变量时的健壮性和一致性。

#### 参数化推导判断 (Parametric Derivability)

参数化推导判断与泛型推导判断类似，只不过它处理的是**参数**，而非普通变量。参数化推导判断的形式化定义为：

$$
\tilde{u}; \tilde{x} \mid \Gamma \vdash_{U;X}^R J \iff \forall \rho : \tilde{u} \leftrightarrow \tilde{u}^\prime \ \forall \pi : \tilde{x} \leftrightarrow \tilde{x}^\prime \ \rho \cdot \pi \cdot \Gamma \vdash_{U, \tilde{u}^\prime; X, \tilde{x}^\prime}^R \rho \cdot \pi \cdot J
$$

在这个定义中，$\rho$ 是对参数的重命名映射，$\pi$ 是对变量的重命名映射。参数化推导的**证据**是一个推导 $\nabla$，它涉及参数 $\tilde{u}$ 和变量 $\tilde{x}$，并且对于每一个新的重命名，推导 $\nabla$ 依然有效。

需要注意的是，参数和变量不同，**参数不支持替换操作**。因为参数的作用仅限于标记和区分，而不会被实际的对象替代。参数允许的操作主要是**重命名**和**增殖**。

#### 例子：泛型推导的应用

例如，推导 $x \ \text{nat}$ 和 $succ(succ(x)) \ \text{nat}$ 的泛型推导可以通过变量 $x$ 的重命名进行处理。不论我们如何重命名 $x$，例如将其重命名为 $y$，推导仍然成立。这展示了泛型推导中的**不依赖变量名的普遍性**。

#### 参数化推导与泛型推导的对比

泛型推导处理普通变量的通用性，而参数化推导则处理参数的通用性。两者的主要区别在于：
- 泛型推导允许变量被替换为其他对象，但参数化推导中的参数不允许被替换，只能重命名。
- 两者都支持变量或参数的重命名，并且推导保持有效。

### 结论

**通用判断**在逻辑推导和编程语言语义中是非常重要的工具，它使得推导过程中的变量处理更加灵活。通过定义泛型和参数化推导判断，我们可以确保推导结果对于变量名和参数的选择是无关的，确保了推导系统的健壮性。这些结构性质不仅在理论推导中至关重要，也在编程语言的类型推导和程序验证中有广泛应用。

### ---------------------------------

### 3.4 泛型归纳定义 (Generic Inductive Definitions)

泛型归纳定义是一种允许在规则的前提中引入**泛型假设判断**的扩展形式。它不仅扩展了规则，还允许在这些前提中使用变量。泛型规则的形式是：

$$
\tilde{x} \ \tilde{x}_1 \mid \Gamma \ \Gamma_1 \vdash J_1 \quad \dots \quad \tilde{x} \ \tilde{x}_n \mid \Gamma \ \Gamma_n \vdash J_n \\
\frac{\tilde{x} \ \tilde{x}_1 \mid \Gamma \ \Gamma_1 \vdash J_1 \quad \dots \quad \tilde{x} \ \tilde{x}_n \mid \Gamma \ \Gamma_n \vdash J_n}{\tilde{x} \mid \Gamma \vdash J}
$$

#### 规则中变量的作用域

在这个规则中，$\tilde{x}$ 是**全局变量**，它们适用于整个推导树中的每一个推导步骤。对于每一个 $1 \leq i \leq n$，$\tilde{x}_i$ 是第 $i$ 个前提中的**局部变量**。泛型规则允许在推导过程中灵活引入局部变量，这对于表达复杂的推导非常有用。

#### 泛型规则的隐式形式

在大多数情况下，我们不会显式写出所有全局变量和假设，而是使用一种简化形式。这种形式可以表示为：

$$
\frac{\tilde{x}_1 \mid \Gamma_1 \vdash J_1 \quad \dots \quad \tilde{x}_n \mid \Gamma_n \vdash J_n}{\vdash J}
$$

这表示泛型归纳定义实际上是对一系列形式化泛型判断的普通归纳定义。形式化的泛型判断被认为是同质的，这意味着它们在变量重命名时不会发生变化。对于任意重命名 $\pi : \tilde{x} \leftrightarrow \tilde{x}^\prime$，判断 $\tilde{x} \mid \Gamma \vdash J$ 被视为等同于 $\tilde{x}^\prime \mid \pi \cdot \Gamma \vdash \pi \cdot J$。

#### 泛型归纳定义的推导过程

推导的过程仍然遵循**归纳规则**的原则。对于给定的泛型归纳规则集 $R$，如果我们希望证明某个性质 $P(\tilde{x} \mid \Gamma \vdash J)$ 对每个泛型判断 $\tilde{x} \mid \Gamma \vdash J$ 都成立，我们需要展示该性质在每一个泛型规则 $R$ 下都是成立的。具体来说，如果对于每一个规则：

$$
\frac{\tilde{x} \ \tilde{x}_1 \mid \Gamma \ \Gamma_1 \vdash J_1 \quad \dots \quad \tilde{x} \ \tilde{x}_n \mid \Gamma \ \Gamma_n \vdash J_n}{\tilde{x} \mid \Gamma \vdash J}
$$

我们必须证明：

$$
P(\tilde{x} \ \tilde{x}_1 \mid \Gamma \ \Gamma_1 \vdash J_1) \quad \dots \quad P(\tilde{x} \ \tilde{x}_n \mid \Gamma \ \Gamma_n \vdash J_n) \quad \Rightarrow \quad P(\tilde{x} \mid \Gamma \vdash J)
$$

#### 泛型归纳定义的结构规则

为了确保形式化的泛型判断像泛型判断一样工作，我们需要确保以下**结构规则**是可接受的（admissible）：

1. **反身性** (Reflexivity)：
   $$
   \frac{}{\tilde{x} \mid \Gamma, J \vdash J}
   $$

2. **弱化** (Weakening)：
   $$
   \frac{\tilde{x} \mid \Gamma \vdash J}{\tilde{x} \mid \Gamma, J^\prime \vdash J}
   $$

3. **变量增殖** (Proliferation)：
   $$
   \frac{\tilde{x} \mid \Gamma \vdash J}{\tilde{x}, x \mid \Gamma \vdash J}
   $$

4. **重命名** (Renaming)：
   $$
   \frac{\tilde{x}, x^\prime \mid [x \leftrightarrow x^\prime] \cdot \Gamma \vdash [x \leftrightarrow x^\prime] \cdot J}{\tilde{x}, x \mid \Gamma \vdash J}
   $$

5. **替换** (Substitution)：
   $$
   \frac{\tilde{x}, x \mid \Gamma \vdash J \quad a \in B[\tilde{x}]}{\tilde{x} \mid [a/x] \Gamma \vdash [a/x] J}
   $$

这些规则确保了在推导过程中，无论是增殖、重命名还是替换操作，推导结果都不会受到变量名的影响，保证了推导的**泛化性**和一致性。

#### 参数化归纳定义 (Parametric Inductive Definitions)

**参数化归纳定义**类似于泛型归纳定义，但它处理的是**参数**，而不是普通的变量。参数化判断的形式为：

$$
\tilde{u}; \tilde{x} \mid \Gamma \vdash J
$$

其中，$\tilde{u}$ 表示参数，$\tilde{x}$ 表示变量。参数化判断也需要支持变量和参数的重命名，以确保推导的正确性不依赖于具体的变量和参数名。

#### 小结

泛型和参数化归纳定义使得推导规则可以灵活地处理变量和参数的通用性。这种扩展不仅增强了推导的表达能力，也确保了在推导过程中变量和参数的处理是健壮和一致的。

### ---------------------------------

### 3.5 注释 (Notes)

在逻辑学和编程语言中，**蕴涵**(entailment) 和 **泛化**(generality) 的概念是非常基础的。这里提出的推理方法主要建立在 Martin-Löf (1983, 1987) 和 Avron (1991) 的工作基础上。

#### 假设与泛化推理的历史背景

在语言设计中，假设推理 (hypothetical reasoning) 和泛化推理 (general reasoning) 是非常重要的概念。在早期的系统如 **AUTOMATH** 语言 (Nederpelt 等, 1994) 和 **LF 逻辑框架**(Harper 等, 1993) 中，这两者被整合为一个单一的推理模式。这些系统允许将假设与泛化推理进行任意嵌套组合，以构建更复杂的推理结构。

然而，在本章的讨论中，我们仅考虑了基础判断形式下的**泛化假设推理** (general hypothetical judgments)，这与这些早期系统相比略有简化。

#### 参数与变量的区别

在语言设计中，**参数**(parameters) 与 **变量**(variables) 的区分至关重要。如果没有严格区分两者，容易导致很多设计上的错误。**参数**之间可以通过它们是否相同或不同来区分，这是有意义的，而对于**变量**则不然。因为变量通过替换后，不再能区分出相等或不等的情况（即**变量的不等式**并不在替换后保留）。

例如，当我们在进行变量替换时，变量 $x$ 和 $y$ 如果被相同的值替换，则替换后的表达式中 $x$ 和 $y$ 就失去了区分性。但对于参数 $p$ 和 $q$，即使它们在某些推导中作为绑定变量出现，依然保持区分性。这是因为参数并不会因为替换而失去它们之间的**异性**。

#### 语言设计中的混淆

在语言设计过程中，如果没有明确区分参数和变量，会造成很多**混乱**(confusion) 和**复杂性**(complication)。尤其是在设计复杂类型系统时，这种混淆会带来很多不必要的设计错误和推导问题。为了避免这些问题，语言设计中必须严格遵守参数和变量的区别。

本章中提到的概念为后续的编程语言逻辑和类型系统设计奠定了基础，而参数和变量的明确区分将是构建健壮系统的关键。

### ---------------------------------

在类型论 (Type Theory) 中，**归纳定义** 是定义数据结构或逻辑断言的基本方式。我们可以通过归纳定义来定义自然数、列表、树等数据结构，也可以用于定义逻辑中的归纳类型。归纳定义的形式可以是**泛型归纳定义** (Generic Inductive Definitions) 和**参数归纳定义** (Parameterized Inductive Definitions)，它们在处理类型参数和归纳过程上有所区别。

### 1. **泛型归纳定义** (Generic Inductive Definitions)

**泛型归纳定义** 是一种对任意类型或类型族进行归纳定义的方法。它允许我们定义那些不仅适用于特定类型，而是适用于一大类类型或类型族的归纳结构。

#### 例子：泛型列表 (Generic List)

泛型列表是一种典型的泛型归纳定义，它可以接受任意的类型作为列表元素的类型。例如，在 Haskell 或 Coq 中，列表的定义可以如下：

```haskell
data List a = Nil | Cons a (List a)
```

在这里，`List a` 表示对于任意类型 `a`，我们都可以定义一个列表。这个定义有两个构造子：
- `Nil` 是空列表。
- `Cons` 构造一个由元素和另一个列表组成的非空列表。

#### 泛型归纳定义的特点
1. **类型参数**：它们接受一个或多个类型参数，并对这些类型参数进行归纳。例如，`List a` 对任意类型 `a` 进行归纳定义。
2. **灵活性**：泛型归纳定义具有较高的灵活性，能够处理各种类型，而不仅仅是具体的某种类型。它们适用于编写可重用、适应性强的归纳数据类型或逻辑定义。

### 2. **参数归纳定义** (Parameterized Inductive Definitions)

**参数归纳定义** 是一种在定义归纳结构时传递固定参数的方式，这些参数在定义过程中保持不变。与泛型归纳定义不同，参数归纳定义并不适用于任意类型，而是定义时固定的类型或值。

#### 例子：带固定长度的向量 (Vector)

带固定长度的向量是一种参数归纳定义，它接受一个固定的自然数作为参数。向量是固定长度的列表，在 Coq 中的定义如下：

```coq
Inductive Vector (A : Type) : nat -> Type :=
  | VNil : Vector A 0
  | VCons : forall (n : nat), A -> Vector A n -> Vector A (S n).
```

在这个例子中：
- `Vector A n` 表示类型为 `A` 的长度为 `n` 的向量。
- `VNil` 是长度为 0 的向量。
- `VCons` 构造一个长度为 `n+1` 的向量，它由一个元素和一个长度为 `n` 的向量组成。

#### 参数归纳定义的特点
1. **固定参数**：参数归纳定义中，参数在定义过程中是固定的。例如，在向量的定义中，`n` 是长度参数，一旦传入，在整个归纳过程中保持不变。
2. **限定性**：相对于泛型归纳定义，参数归纳定义更具限定性，因为它的参数在定义时就已经固定，无法像泛型归纳定义那样接受任意类型。

### 3. **泛型归纳定义与参数归纳定义的区别**

| 特点             | 泛型归纳定义 (Generic Inductive Definitions) | 参数归纳定义 (Parameterized Inductive Definitions) |
| ---------------- | -------------------------------------------- | -------------------------------------------------- |
| 类型参数的处理   | 适用于任意类型或类型族                       | 固定参数，参数在归纳定义过程中保持不变             |
| 适用范围         | 灵活，适用于各种类型                         | 更具限制性，适用于定义时传入的特定参数             |
| 例子             | 泛型列表 (List a)                            | 固定长度向量 (Vector A n)                          |
| 定义结构的灵活性 | 定义时允许接受各种类型作为参数，适应性强     | 参数一旦固定，在整个定义过程中不能变化             |

### 4. **泛型归纳定义和参数归纳定义的应用场景**

- **泛型归纳定义**：适用于那些需要在多种类型上定义通用结构的数据类型。例如，定义泛型数据结构（如列表、树），或者定义适用于任意类型的逻辑规则。
- **参数归纳定义**：适用于那些需要传递具体的、固定的参数的场景。例如，带有固定长度的向量，或者需要对某一具体类型或值进行推导时使用的归纳结构。

### 总结

- **泛型归纳定义** 是定义在任意类型或类型族上的归纳结构，具有较高的灵活性，适用于定义通用数据结构或逻辑断言。
- **参数归纳定义** 是带有固定参数的归纳定义，在定义时传入的参数在整个归纳过程中保持不变，适用于需要处理具体参数的场景。

通过理解这两种归纳定义的差异，我们可以更好地选择适合自己问题场景的归纳定义方式，编写更加灵活和严谨的类型结构。

### ---------------------------------

### 泛型归纳定义 (Generic Inductive Definitions)

**泛型归纳定义** 是一种扩展形式的归纳定义，它允许在规则的前提中引入**泛型假设判断**，并且使用全局和局部变量在归纳推导中保持推理的灵活性。这种定义在处理复杂的推导规则时，尤其是在类型系统、逻辑推导中的应用非常重要。下面详细说明其各个部分：

#### 1. 规则中的符号解释

在泛型归纳规则中，推导的形式如下：

$$
\tilde{x} \ \tilde{x}_1 \mid \Gamma \ \Gamma_1 \vdash J_1 \quad \dots \quad \tilde{x} \ \tilde{x}_n \mid \Gamma \ \Gamma_n \vdash J_n \\
\frac{\tilde{x} \ \tilde{x}_1 \mid \Gamma \ \Gamma_1 \vdash J_1 \quad \dots \quad \tilde{x} \ \tilde{x}_n \mid \Gamma \ \Gamma_n \vdash J_n}{\tilde{x} \mid \Gamma \vdash J}
$$

- **全局变量 $\tilde{x}$**：全局变量适用于推导树中的所有步骤和所有前提，它们在推导过程中不会被局部推理所改变。
- **局部变量 $\tilde{x}_i$**：第 $i$ 个前提中的局部变量 $\tilde{x}_i$ 仅在该前提内有效。局部变量使得每一个推导步骤可以根据特定上下文变化进行独立处理。

#### 2. 规则的简化形式

泛型规则有时可以以简化的隐式形式表示为：

$$
\frac{\tilde{x}_1 \mid \Gamma_1 \vdash J_1 \quad \dots \quad \tilde{x}_n \mid \Gamma_n \vdash J_n}{\vdash J}
$$

这种简化形式隐藏了全局变量的显示表示，并且默认假设所有前提共享同一组全局变量。在这种情况下，推导过程会根据上下文的变化自动进行变量的调整和推理。

#### 3. 变量作用域和重命名

在泛型归纳定义中，变量重命名是一种非常重要的性质。当推导中的变量进行重命名时，推导结果仍然是等价的。形式上，假设 $\pi$ 是一种变量的重命名映射 $\tilde{x} \leftrightarrow \tilde{x}^\prime$，则以下推导是等价的：

$$
\tilde{x} \mid \Gamma \vdash J \quad \text{等同于} \quad \tilde{x}^\prime \mid \pi \cdot \Gamma \vdash \pi \cdot J
$$

这意味着重命名不会改变推导的正确性。

#### 4. 泛型归纳定义的推导过程

泛型归纳定义的推导过程与普通的归纳推导类似。为了证明某个性质 $P(\tilde{x} \mid \Gamma \vdash J)$ 对每一个泛型判断都成立，需要依次验证每个泛型规则。即：

$$
P(\tilde{x} \ \tilde{x}_1 \mid \Gamma \ \Gamma_1 \vdash J_1) \quad \dots \quad P(\tilde{x} \ \tilde{x}_n \mid \Gamma \ \Gamma_n \vdash J_n) \quad \Rightarrow \quad P(\tilde{x} \mid \Gamma \vdash J)
$$

#### 5. 泛型归纳定义的结构规则

为了保证推导的正确性和一致性，以下**结构规则**是泛型归纳定义中必须满足的：

- **反身性** (Reflexivity)：在上下文中，如果我们假设了 $J$，那么我们可以直接推导出 $J$。

  $$
  \frac{}{\tilde{x} \mid \Gamma, J \vdash J}
  $$

- **弱化** (Weakening)：在推导过程中，添加额外的假设不会影响已有推导的正确性。

  $$
  \frac{\tilde{x} \mid \Gamma \vdash J}{\tilde{x} \mid \Gamma, J^\prime \vdash J}
  $$

- **变量增殖** (Proliferation)：可以引入新的变量，不影响推导结果。

  $$
  \frac{\tilde{x} \mid \Gamma \vdash J}{\tilde{x}, x \mid \Gamma \vdash J}
  $$

- **重命名** (Renaming)：可以对变量进行重命名，推导结果仍然成立。

  $$
  \frac{\tilde{x}, x^\prime \mid [x \leftrightarrow x^\prime] \cdot \Gamma \vdash [x \leftrightarrow x^\prime] \cdot J}{\tilde{x}, x \mid \Gamma \vdash J}
  $$

- **替换** (Substitution)：可以将变量替换为符合条件的值或表达式，推导结果保持不变。

  $$
  \frac{\tilde{x}, x \mid \Gamma \vdash J \quad a \in B[\tilde{x}]}{\tilde{x} \mid [a/x] \Gamma \vdash [a/x] J}
  $$

这些结构规则确保了推导过程的健全性，无论是重命名、替换还是弱化，都不会影响推导的正确性和结果。

### 参数化归纳定义 (Parametric Inductive Definitions)

与泛型归纳定义不同，**参数化归纳定义** 允许我们在定义归纳结构时引入一些固定的参数。这些参数在整个归纳过程中保持不变。

#### 参数化归纳定义的特点

1. **固定参数**：在参数化归纳定义中，参数在定义时就被固定，不随推导过程改变。这些参数通常用于描述数据结构的特定性质，例如长度、维度等。

2. **限制性**：由于参数固定，参数化归纳定义不具有泛型归纳定义的灵活性。每个推导都与给定的参数紧密相关。

#### 例子：带固定维度的矩阵 (Fixed-Dimension Matrices)

矩阵的一个参数化归纳定义如下：

```coq
Inductive Matrix (A : Type) : nat -> nat -> Type :=
  | MEmpty : Matrix A 0 0
  | MCons : forall (n m : nat), A -> Matrix A n m -> Matrix A (n+1) (m+1).
```

这个定义中，矩阵的维度（行数和列数）作为固定的参数，在整个归纳过程中不发生改变。

#### 参数化归纳定义的应用场景

参数化归纳定义常用于那些需要处理特定属性的场景，如：
- 固定维度的矩阵
- 固定长度的向量
- 固定形状的几何结构

这些定义在科学计算和几何建模等领域中非常常见。

### 总结

- **泛型归纳定义** 允许在推导规则中引入泛型假设，具有较大的灵活性和泛用性，适用于各种数据结构或逻辑推理。
- **参数化归纳定义** 固定了推导过程中的参数，适用于那些参数在归纳过程中不会变化的场景，例如处理固定长度或维度的结构。

通过理解这两种归纳定义的差异和应用场景，可以更好地选择适当的工具进行形式化推导或数据结构的定义。

### ---------------------------------

你提出的这个问题很关键。为了更好地解释**参数化归纳定义**，我将在此补充公式，并详细描述如何使用参数化归纳定义。

### 参数化归纳定义的公式补充

在参数化归纳定义中，参数是固定的，因此在归纳定义和推导规则中，参数的值不会随推导步骤变化。这些参数在定义时就传入并保持不变。这种定义结构的形式可以描述如下：

$$
\frac{\Gamma_1 \vdash J_1(n_1, m_1) \quad \dots \quad \Gamma_n \vdash J_n(n_1, m_1)}{\Gamma \vdash J(n_1, m_1)}
$$

在这个推导规则中，$n_1, m_1$ 是参数，它们在归纳定义的前提和结论中都保持不变。

#### 示例：固定长度的向量

为了展示公式的具体应用，以下是定义固定长度向量的参数化归纳定义的例子（此处使用 Coq 风格的形式化）：

```coq
Inductive Vector (A : Type) : nat -> Type :=
  | VNil : Vector A 0
  | VCons : forall (n : nat), A -> Vector A n -> Vector A (S n).
```

在这个定义中，`Vector` 类型接收一个自然数 `n` 作为参数。我们可以将其公式化表示如下：

1. **空向量 (VNil)**：表示一个长度为 $0$ 的向量。
   $$
   \frac{}{\Gamma \vdash VNil : Vector(A, 0)}
   $$

2. **构造非空向量 (VCons)**：表示通过将一个元素添加到长度为 $n$ 的向量前端来构造一个长度为 $n+1$ 的向量。
   $$
   \frac{\Gamma \vdash a : A \quad \Gamma \vdash v : Vector(A, n)}{\Gamma \vdash VCons(a, v) : Vector(A, S(n))}
   $$

其中，`VNil` 和 `VCons` 都是带有参数 `n` 的归纳构造子。在整个推导过程中，参数 `n` 的值是固定的。对于 $VNil$，$n$ 的值为 $0$；对于 $VCons$，$n$ 的值从 $n$ 增加到 $n+1$。

### 参数化归纳定义的推导规则

如上所示，参数化归纳定义的推导规则是基于参数的固定性展开的。通过这些规则，我们可以对不同的参数进行递归推导，最终得到我们所需要的结果。以下是一些常见的推导规则形式：

1. **反身性 (Reflexivity)**：
   如果我们假设了某个结论 $J$，那么在上下文中直接可以推出 $J$。
   $$
   \frac{}{\Gamma, J(n_1) \vdash J(n_1)}
   $$

2. **弱化 (Weakening)**：
   在推导过程中，增加额外的假设（假设与推导无关）不会影响推导结果。
   $$
   \frac{\Gamma \vdash J(n_1)}{\Gamma, J^\prime(n_1) \vdash J(n_1)}
   $$

3. **替换 (Substitution)**：
   可以将上下文中的变量替换为与之相同类型的值，并保证推导结果不变。
   $$
   \frac{\Gamma \vdash J(n_1) \quad a \in A}{\Gamma[a/x] \vdash J(n_1)}
   $$

这些规则确保了参数化定义中的固定参数在推导过程中的一致性，并确保了归纳定义的完整性。

### 示例推导：向量的拼接

我们来推导一个关于固定长度向量的例子：**向量拼接**。假设我们有两个向量，一个长度为 $n$，另一个长度为 $m$，现在我们希望将这两个向量拼接起来，结果应该是一个长度为 $n+m$ 的向量。

可以定义一个拼接向量的函数 `append`，其推导规则可以如下表示：

- 空向量拼接任何向量结果就是那个向量：
  $$
  \frac{\Gamma \vdash v : Vector(A, m)}{\Gamma \vdash append(VNil, v) : Vector(A, m)}
  $$

- 将非空向量与另一个向量拼接时，我们将第一个向量的头部元素保留，并递归拼接剩余部分：
  $$
  \frac{\Gamma \vdash a : A \quad \Gamma \vdash v_1 : Vector(A, n) \quad \Gamma \vdash v_2 : Vector(A, m) \quad \Gamma \vdash append(v_1, v_2) : Vector(A, n+m)}{\Gamma \vdash append(VCons(a, v_1), v_2) : Vector(A, S(n+m))}
  $$

### 总结

- **参数化归纳定义** 的核心是固定参数在归纳过程中不发生变化。这种结构允许定义特定的归纳类型，如固定长度的向量、矩阵等。
- 参数化定义中的推导规则同样遵循归纳推导的基本原则，常见的结构规则包括**反身性**、**弱化**、**替换**等。
- 使用公式表示的推导过程可以帮助我们更清晰地理解这些定义的结构，并应用到实际的编程或数学证明中。

通过补充这些公式，参数化归纳定义的推导过程会更加清晰，特别是在处理涉及固定参数的场景时，如我们在向量拼接中的推导示例。


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------
[toc]



### 第2章 归纳定义 (Chapter 2: Inductive Definitions)

**归纳定义**(Inductive Definitions) 是编程语言研究中的重要工具。在本章中，我们将介绍归纳定义的基本框架，并提供一些使用示例。

#### 归纳定义的基本结构 (Basic Structure of Inductive Definitions)

归纳定义的核心是**推导规则**(rules for deriving judgments)，这些规则用于生成各种形式的**判断**(judgments)或**断言**(assertions)。判断是关于一个或多个特定类型的**语法对象**(syntactic objects)的陈述，推导规则则为判断的有效性提供了必要和充分的条件，从而完全确定了判断的含义。

#### 判断的定义 (Definition of Judgments)

在归纳定义中，**判断**是对程序语言元素的一种形式化声明。它可以包括诸如“表达式 $e$ 是类型 $T$”的声明，或者“命令 $c$ 能够终止”等。每个判断涉及特定类型的语法对象，并通过推导规则来确定其**有效性**(validity)。

#### 规则的作用 (Role of Rules)

每个推导规则提供了判断有效的条件。推导规则通常分为两个部分：
1. **前提**(premises)：判断成立的条件，即判断的前提。
2. **结论**(conclusion)：在前提条件满足的情况下，得出的判断。

一个典型的推导规则形式如下：
$$
\frac{\text{前提 1} \quad \text{前提 2} \quad \dots}{\text{结论}}
$$
这表示：如果前提 1、前提 2、等都成立，那么结论也成立。

#### 归纳定义的意义 (Significance of Inductive Definitions)

归纳定义不仅用于形式化推理，还用于**递归结构**(recursive structures)的定义。例如，编程语言的语法可以用归纳定义来描述，通过一系列规则定义了表达式的生成方式。在这种情况下，归纳定义不仅告诉我们如何构建合法的表达式，还为这些表达式的推理提供了基础。

例如，可以用归纳定义来构建**自然数**(natural numbers)，通过以下两条规则：
1. $0$ 是自然数。
2. 如果 $n$ 是自然数，那么 $n+1$ 也是自然数。

这个定义实际上就是对自然数的构建过程：从 $0$ 开始，通过规则不断生成新的自然数。

#### 归纳定义在编程语言中的应用 (Application in Programming Languages)

在编程语言研究中，归纳定义用于描述诸如**类型系统**(type systems)、**操作语义**(operational semantics)等领域。通过归纳定义，我们可以精确地定义程序中的有效表达式、类型以及它们的相互关系，并为编译器或解释器的实现提供理论依据。

例如，定义一个表达式的类型规则可以通过归纳定义来描述。假设我们有两种基本类型，布尔类型 $T_{\text{bool}}$ 和整数类型 $T_{\text{int}}$，我们可以定义类型判断规则：
1. 如果 $n$ 是一个整数常量，那么 $n$ 的类型是 $T_{\text{int}}$。
2. 如果 $e_1$ 和 $e_2$ 都是布尔表达式，那么 $e_1 \land e_2$ 的类型是 $T_{\text{bool}}$。

通过这些规则，可以确定给定表达式的类型，这就是归纳定义的具体应用。

#### 归纳定义的推导原则 (Principle of Inductive Derivation)

归纳定义的推导方式依赖于**最小性原则**(principle of minimality)，即每个判断的有效性都基于一系列**基本规则**(base rules)和**归纳规则**(inductive rules)。在最小性原则下，所有可能的判断都是通过已定义的推导规则生成的，而不存在其他方式生成的判断。这确保了归纳定义的封闭性和一致性。

---

通过归纳定义的框架，我们可以系统地定义编程语言中的各种形式系统和推理规则。在后续内容中，我们将继续深入讨论如何利用归纳定义处理具体编程语言元素的推导和验证。

### -----------------------------------------

### 2.1 判断 (Judgments)

**判断**(Judgments) 是对一个**语法对象**(syntactic object)的断言。我们将使用多种形式的判断，例如：

1. $n\ \text{nat}$ 表示 $n$ 是自然数。
2. $n = n_1 + n_2$ 表示 $n$ 是 $n_1$ 和 $n_2$ 的和。
3. $\tau\ \text{type}$ 表示 $\tau$ 是一种类型。
4. $e : \tau$ 表示表达式 $e$ 的类型是 $\tau$。
5. $e \Downarrow v$ 表示表达式 $e$ 的值是 $v$。

#### 判断的定义 (Definition of Judgments)

一个判断表明一个或多个语法对象具有某种**性质**(property)，或在某种关系中**相关联**(stand in relation to one another)。判断中的**性质**或**关系**称为**判断形式**(judgment form)。如果某个对象（或多个对象）具有该性质或关系，我们称此判断是该判断形式的一个实例。例如，表达式 $e$ 的类型是 $\tau$ 的判断形式 $e : \tau$ 就是一个判断形式，而 $e : \tau$ 作为某个具体表达式的实例就是一个实际的判断。

#### 判断形式和实例 (Judgment Forms and Instances)

- **判断形式**(Judgment Form)：也可以称为**谓词**(predicate)，是表示语法对象之间某种关系或性质的概念。
- **实例**(Instance)：当某些具体的语法对象满足一个判断形式时，我们称这些对象构成了该判断形式的实例。

例如，判断 $e : \tau$ 说明某个表达式 $e$ 具有类型 $\tau$，它是 "表达式具有类型" 这一判断形式的一个实例。

我们通常用 $a \ J$ 表示断言 $J$ 对于 $a$ 成立的判断。当判断的具体对象不重要时，我们可以简化为 $J$ 来表示一个未指定的判断。

#### 判断形式的符号表示 (Notation for Judgment Forms)

为了提高可读性，对于具体的判断形式，我们可以使用前缀、**中缀**(infix) 或**混合**(mixfix) 符号表示法。例如：
- 前缀：$n\ \text{nat}$（自然数判断形式）。
- 中缀：$n = n_1 + n_2$（加法的关系判断）。
- 混合：$e : \tau$（类型判断形式）。

这些符号表示法灵活地表达了语法对象之间的关系，使判断的含义更加直观。

#### 小结 (Summary)

判断是一种对语法对象的断言，通常用来说明某些对象的性质或它们之间的关系。每个判断形式（或谓词）对应一类语法对象的性质或关系，不同的符号表示法用于不同的判断形式，以增强可读性和清晰度。

### -----------------------

### 2.2 推导规则 (Inference Rules)

**推导规则**(Inference Rules) 是归纳定义中用于定义判断形式的基本工具。它们由一组形式化的规则组成，这些规则定义了如何根据前提推导出结论。

#### 推导规则的基本形式 (Basic Structure of Inference Rules)

一个推导规则通常写作：
$$
\frac{J_1 \quad J_2 \quad \dots \quad J_k}{J}
$$
其中，$J_1, \dots, J_k$ 是该规则的**前提**(premises)，而 $J$ 是该规则的**结论**(conclusion)。规则的前提在水平线之上，结论在水平线之下。

- **公理**(Axioms)：如果一个规则没有前提（即 $k = 0$），该规则称为**公理**。公理的结论**无条件成立**，即不依赖其他判断。
- **一般推导规则**(Proper Rules)：如果一个规则有前提，那么该规则称为一般推导规则。它说明：**前提成立是结论成立的充分条件**，即如果所有前提 $J_1, \dots, J_k$ 成立，那么结论 $J$ 也成立。

#### 推导规则的含义 (Meaning of Inference Rules)

推导规则可以理解为：**前提的成立足以推导出结论**。例如，如果有某条规则的前提 $J_1, \dots, J_k$ 都成立，则可以得出结论 $J$。需要注意的是，推导同一个结论 $J$ 可能有多条不同的规则，因此即使结论 $J$ 成立，也不意味着特定的前提必须成立，因为可能存在其他规则推导出相同的结论。

#### 示例 (Examples)

##### 自然数的归纳定义 (Inductive Definition of Natural Numbers)

以下规则定义了判断 $a\ \text{nat}$（$a$ 是自然数）的归纳定义：
1. $0\ \text{nat}$ 表示 $0$ 是自然数。（规则 (2.2a)）
2. 如果 $a\ \text{nat}$，则 $succ(a)\ \text{nat}$，表示 $a$ 的后继也是自然数。（规则 (2.2b)）

这些规则指定了 $a\ \text{nat}$ 成立的条件：$a$ 要么是 $0$，要么是某个自然数的后继。这些规则可以认为是**穷尽性的**，即 $a\ \text{nat}$ 当且仅当 $a$ 是自然数。

##### 二叉树的归纳定义 (Inductive Definition of Binary Trees)

类似地，以下规则定义了判断 $a\ \text{tree}$（$a$ 是二叉树）：
1. $empty\ \text{tree}$ 表示空树是二叉树。（规则 (2.3a)）
2. 如果 $a_1\ \text{tree}$ 且 $a_2\ \text{tree}$，则 $node(a_1; a_2)\ \text{tree}$，表示一个包含左右子树的节点是二叉树。（规则 (2.3b)）

这些规则说明了 $a\ \text{tree}$ 成立的条件：$a$ 要么是空树，要么是包含两个子树的节点。通过这些规则，二叉树的结构被递归定义为树节点和空树的组合。

##### 自然数相等的归纳定义 (Inductive Definition of Equality of Natural Numbers)

自然数相等的判断 $a = b\ \text{nat}$ 通过以下规则递归定义：
1. $0 = 0\ \text{nat}$ 表示 $0$ 等于 $0$。（规则 (2.4a)）
2. 如果 $a = b\ \text{nat}$，则 $succ(a) = succ(b)\ \text{nat}$，表示如果 $a$ 和 $b$ 相等，则它们的后继也相等。（规则 (2.4b)）

这些规则定义了自然数相等的递归条件，表示相等的自然数可以通过 $0$ 和后继的比较来推导。

#### 规则方案 (Rule Schemes)

在上面的例子中，我们使用了一种**记号约定**(notational convention)，即通过有限的模式或规则方案表示一个无限的规则族。例如，规则 (2.2b) 是一个规则方案，它为每个对象 $a$ 定义了一个具体的规则实例。我们可以通过上下文来判断规则是针对特定对象 $a$ 还是定义了一组规则方案。

#### 闭包与最强判断 (Closure and Strongest Judgment)

一组规则被认为定义了**最强判断**(strongest judgment)，即这些规则既是**充分**(sufficient)的，也是**必要**(necessary)的：
- **充分性**(Sufficiency)：如果有一种方式可以通过给定的规则推导出判断 $J$，那么 $J$ 就成立。换句话说，规则足以推导出 $J$ 的有效性。
- **必要性**(Necessity)：$J$ 仅当可以通过规则推导出时才成立。这意味着我们可以通过**规则归纳法**(rule induction)推导 $J$ 的有效性。

闭包意味着判断必须尊重推导规则，也就是说，只有通过这些规则推导出的判断才是有效的。

---

推导规则在归纳定义中起着核心作用，它们不仅提供了如何根据前提推导结论的方法，还定义了判断形式的充分和必要条件。在后续章节中，这些推导规则将用于处理编程语言的语法、类型系统和操作语义等方面的推理。

### -------------------

### 2.3 推导 (Derivations)

要证明一个归纳定义的判断是成立的，展示它的**推导**(derivation) 就足够了。推导是规则的有限组合，**从公理开始**，最终导出我们要证明的判断。推导可以看作是一棵树，树中的每个节点代表一个规则，该节点的子节点对应于该规则前提的推导。

我们可以将推导理解为对某个归纳定义判断 $J$ 的**有效性证明**(evidence for the validity)，即通过规则逐步推导出 $J$。

#### 推导树的表示 (Representation of Derivation Trees)

推导通常用树的形式表示，**结论**(conclusion) 在树的底部，树的子节点表示推导该结论所需的前提。

例如，推导规则如下：
$$
\frac{J_1 \quad J_2 \quad \dots \quad J_k}{J}
$$
假设 $\nabla_1, \nabla_2, \dots, \nabla_k$ 分别是前提 $J_1, J_2, \dots, J_k$ 的推导，则推导树表示为：
$$
\frac{\nabla_1 \quad \dots \quad \nabla_k}{J}
$$
如果 $k = 0$，表示该节点没有子节点，意味着该结论是公理。

#### 示例 1：自然数的推导 (Example: Derivation of Natural Numbers)

例如，推导 $succ(succ(succ(zero)))\ \text{nat}$ 的推导树如下：
$$
\frac{}{\text{zero nat}} \quad \frac{\frac{}{\text{zero nat}}}{\text{succ(zero) nat}} \quad \frac{\frac{\frac{}{\text{zero nat}}}{\text{succ(zero) nat}}}{\text{succ(succ(zero)) nat}} \quad \frac{\frac{\frac{\frac{}{\text{zero nat}}}{\text{succ(zero) nat}}}{\text{succ(succ(zero)) nat}}}{\text{succ(succ(succ(zero))) nat}}
$$
这个推导表明：从公理 $zero\ \text{nat}$ 开始，通过应用 $succ$ 的递归规则，最终推导出 $succ(succ(succ(zero)))\ \text{nat}$。

#### 示例 2：二叉树的推导 (Example: Derivation of Binary Trees)

推导 $node(node(empty; empty); empty)\ \text{tree}$ 的推导树如下：
$$
\frac{}{\text{empty tree}} \quad \frac{}{\text{empty tree}} \quad \frac{\frac{}{\text{empty tree}} \quad \frac{}{\text{empty tree}}}{\text{node(empty; empty) tree}} \quad \frac{\frac{\frac{}{\text{empty tree}} \quad \frac{}{\text{empty tree}}}{\text{node(empty; empty) tree}} \quad \frac{}{\text{empty tree}}}{\text{node(node(empty; empty); empty) tree}}
$$
这个推导说明：从公理 $empty\ \text{tree}$ 开始，依次递归应用 $node$ 的规则，最终推导出 $node(node(empty; empty); empty)\ \text{tree}$。

#### 推导方法 (Methods of Derivation)

推导的构造可以通过两种主要方法完成：
1. **正向链式推导**(Forward Chaining)：从公理出发，逐步推导出所需的结论。
2. **逆向链式推导**(Backward Chaining)：从目标结论出发，逐步推回到公理。

##### 1. 正向链式推导 (Forward Chaining)

**正向链式推导**也称为**自底向上构造**(bottom-up construction)，它通过保持一个可以推导出的判断集合，然后不断向其中添加满足所有前提的规则的结论。该过程从空集开始，当目标判断出现在集合中时结束。

虽然正向链式推导总是能够找到任何可推导判断的推导，但一般来说，无法通过算法决定何时停止扩展集合并得出目标判断无法推导的结论。该方法可能会不断增加推导集，而无法实现目标。

##### 2. 逆向链式推导 (Backward Chaining)

**逆向链式推导**也称为**自顶向下构造**(top-down construction)，它从目标结论开始推导，保持一个目标队列，在每个步骤中移除一个判断并将与该判断结论对应的所有前提加入队列。

逆向链式推导更具目标导向，但和正向链式推导一样，它不能保证算法性地决定目标判断是否可推导。

---

通过正向或逆向推导，我们可以在给定的规则体系下构造推导树，验证判断的有效性。

### ---------------------

### 2.3 推导 (Derivations)

要证明一个归纳定义的判断是成立的，展示它的**推导**(derivation)就足够了。推导是规则的有限组合，**从公理开始**，最终导出我们要证明的判断。推导可以看作是一棵树，树中的每个节点代表一个规则，该节点的子节点对应于该规则前提的推导。

推导可以理解为对某个归纳定义判断 $J$ 的**有效性证明**，即通过规则逐步推导出 $J$。

#### 推导树的表示 (Representation of Derivation Trees)

推导通常用树的形式表示，**结论**在树的底部，树的子节点表示推导该结论所需的前提。

例如，推导规则如下：
$$
\frac{J_1 \quad J_2 \quad \dots \quad J_k}{J}
$$
假设 $\nabla_1, \nabla_2, \dots, \nabla_k$ 分别是前提 $J_1, J_2, \dots, J_k$ 的推导，则推导树表示为：
$$
\frac{\nabla_1 \quad \dots \quad \nabla_k}{J}
$$
如果 $k = 0$，表示该节点没有子节点，意味着该结论是公理。

#### 示例 1：自然数的推导 (Example: Derivation of Natural Numbers)

推导 $succ(succ(succ(zero)))\ \text{nat}$ 的推导树如下：

$$
\frac{}{\text{zero nat}}
$$
$$
\frac{\frac{}{\text{zero nat}}}{\text{succ(zero) nat}}
$$
$$
\frac{\frac{\frac{}{\text{zero nat}}}{\text{succ(zero) nat}}}{\text{succ(succ(zero)) nat}}
$$
$$
\frac{\frac{\frac{\frac{}{\text{zero nat}}}{\text{succ(zero) nat}}}{\text{succ(succ(zero)) nat}}}{\text{succ(succ(succ(zero))) nat}}
$$

这个推导表明：从公理 $zero\ \text{nat}$ 开始，通过应用 $succ$ 的递归规则，最终推导出 $succ(succ(succ(zero)))\ \text{nat}$。

#### 示例 2：二叉树的推导 (Example: Derivation of Binary Trees)

推导 $node(node(empty; empty); empty)\ \text{tree}$ 的推导树如下：

$$
\frac{}{\text{empty tree}} \quad \frac{}{\text{empty tree}} 
$$
$$
\frac{\frac{}{\text{empty tree}} \quad \frac{}{\text{empty tree}}}{\text{node(empty; empty) tree}} 
$$
$$
\frac{\frac{\frac{}{\text{empty tree}} \quad \frac{}{\text{empty tree}}}{\text{node(empty; empty) tree}} \quad \frac{}{\text{empty tree}}}{\text{node(node(empty; empty); empty) tree}}
$$

这个推导说明：从公理 $empty\ \text{tree}$ 开始，依次递归应用 $node$ 的规则，最终推导出 $node(node(empty; empty); empty)\ \text{tree}$。

#### 推导方法 (Methods of Derivation)

推导的构造可以通过两种主要方法完成：
1. **正向链式推导**(Forward Chaining)：从公理出发，逐步推导出所需的结论。
2. **逆向链式推导**(Backward Chaining)：从目标结论出发，逐步推回到公理。

##### 1. 正向链式推导 (Forward Chaining)

**正向链式推导**也称为**自底向上构造**(bottom-up construction)，它通过保持一个可以推导出的判断集合，然后不断向其中添加满足所有前提的规则的结论。该过程从空集开始，当目标判断出现在集合中时结束。

虽然正向链式推导总是能够找到任何可推导判断的推导，但一般来说，无法通过算法决定何时停止扩展集合并得出目标判断无法推导的结论。该方法可能会不断增加推导集，而无法实现目标。

##### 2. 逆向链式推导 (Backward Chaining)

**逆向链式推导**也称为**自顶向下构造**(top-down construction)，它从目标结论开始推导，保持一个目标队列，在每个步骤中移除一个判断并将与该判断结论对应的所有前提加入队列。

逆向链式推导更具目标导向，但和正向链式推导一样，它不能保证算法性地决定目标判断是否可推导。

---

通过正向或逆向推导，我们可以在给定的规则体系下构造推导树，验证判断的有效性。

### ------------------------------------------
### 2.4 规则归纳 (Rule Induction)

**规则归纳**(Rule Induction) 是一种推理方法，用于基于归纳定义的判断进行推理。因为归纳定义指定了一组规则下的**最强判断**(strongest judgment closed under a collection of rules)，我们可以通过规则归纳来对这些判断进行推理。

#### 规则归纳的原理 (Principle of Rule Induction)

**规则归纳原理**表明，若要证明某个性质 $P$ 对每个可推导的判断 $J$ 成立，只需证明 $P$ 对定义 $J$ 的规则是**闭合的**(closed under)或**符合**(respects)这些规则。换句话说，若 $P(J_1), \dots, P(J_k)$ 对推导规则的前提成立，那么 $P(J)$ 也对结论成立。

推导规则通常表示为：
$$
\frac{J_1 \quad \dots \quad J_k}{J}
$$
如果 $P(J_1), \dots, P(J_k)$ 都成立，则我们说 $P$ 对该规则是闭合的，即 $P(J)$ 也成立。这里，$P(J_1), \dots, P(J_k)$ 被称为**归纳假设**(inductive hypotheses)，而 $P(J)$ 则是**归纳结论**(inductive conclusion)。

#### 规则归纳的本质 (Nature of Rule Induction)

规则归纳的本质是归纳定义为最强判断形式，该判断形式在规则下是闭合的，同时对于任何符合这些规则的性质，规则也是充分的。换句话说，归纳定义既确保了推导出的判断是有效的（闭合性），又为推理提供了依据（规则归纳）。

#### 例子 1：自然数的规则归纳 (Example 1: Rule Induction for Natural Numbers)

对于自然数的规则 (2.2)，规则归纳原理指出：
- 若要证明 $P(a\ \text{nat})$ 对每个自然数 $a$ 成立，只需证明以下两点：
  1. $P(0\ \text{nat})$：性质 $P$ 对 $0$ 成立。
  2. 对于任意 $a$，若 $a\ \text{nat}$ 且 $P(a\ \text{nat})$，则 $P(\text{succ}(a)\ \text{nat})$ 也成立。

这实际上就是**数学归纳法**(mathematical induction)的规则归纳实例。

#### 例子 2：树的规则归纳 (Example 2: Rule Induction for Trees)

类似地，对于二叉树的规则 (2.3)，规则归纳原理指出：
- 若要证明 $P(a\ \text{tree})$ 对每棵二叉树 $a$ 成立，只需证明以下两点：
  1. $P(\text{empty}\ \text{tree})$：性质 $P$ 对空树成立。
  2. 对于任意 $a_1$ 和 $a_2$，若 $a_1\ \text{tree}$ 且 $P(a_1\ \text{tree})$，$a_2\ \text{tree}$ 且 $P(a_2\ \text{tree})$，则 $P(\text{node}(a_1; a_2)\ \text{tree})$ 成立。

这称为**树归纳法**(tree induction)，也是规则归纳的一个实例。

#### 例子 3：前驱的规则归纳 (Example 3: Rule Induction for Predecessor of Natural Numbers)

我们还可以通过规则归纳证明自然数的前驱也是自然数。虽然这一点似乎显而易见，但这个例子展示了如何从基本原理推导出这一结论。

通过规则归纳，我们可以推导出自然数的前驱也是自然数，因为对于 $0$ 和 $succ(a)$，每个自然数的前驱都满足自然数的定义。

---

**总结**：规则归纳提供了一种系统化的推理工具，用来证明某个性质 $P$ 对所有归纳定义的判断都成立。通过验证 $P$ 对每个推导规则的前提和结论成立，我们可以确保 $P$ 对所有可推导的判断都是有效的。

### ---------------------------------------------------

### 引理 2.1：如果 $succ(a)\ \text{nat}$，则 $a\ \text{nat}$ (Lemma 2.1: If $succ(a)\ \text{nat}$, then $a\ \text{nat}$)

这个引理旨在证明：如果 $succ(a)$ 是自然数，那么 $a$ 也是自然数。证明采用归纳法，并且使用了自然数的推导规则 (2.2)。

#### 证明 (Proof)

我们要证明的性质是：对于自然数 $a$，如果 $succ(a)\ \text{nat}$，那么 $a\ \text{nat}$。具体来说，要证明这个性质对规则 (2.2) 是**闭合的**。

1. **规则 (2.2a)**：该规则表明 $0$ 是自然数。显然，$0$ 不是任何 $succ(b)$ 的形式，因此引理的第二个条件（即 $a = succ(b)$ 推导出 $b\ \text{nat}$）在这里是**空的**(vacuous)，因为 $0$ 无法通过 $succ$ 操作生成。因此，$0$ 是自然数，并且条件自动满足。

2. **规则 (2.2b)**：假设归纳假设成立，即 $a\ \text{nat}$ 且如果 $a = succ(b)$，那么 $b\ \text{nat}$。现在我们要证明 $succ(a)\ \text{nat}$，这显然是立即成立的，因为 $succ(a)$ 的定义就表明它是自然数。此外，如果 $succ(a) = succ(b)$，那么根据归纳假设 $b\ \text{nat}$ 也成立。因此，我们得出 $b\ \text{nat}$，满足引理的条件。

通过对规则 (2.2) 的逐条分析，我们完成了证明。

---

### 引理 2.2：自然数的自反性 (Lemma 2.2: Reflexivity of Equality for Natural Numbers)

这个引理旨在证明：如果 $a$ 是自然数，那么 $a = a\ \text{nat}$，即自然数的等式关系是自反的。这是通过规则归纳法来证明的，归纳在自然数的推导规则 (2.2) 上进行。

#### 证明 (Proof)

我们采用规则归纳法对规则 (2.2) 进行推理：

1. **规则 (2.2a)**：该规则表示 $0\ \text{nat}$。应用等式定义的规则 (2.4a)，我们可以直接得到 $0 = 0\ \text{nat}$。因此，自反性在此成立。

2. **规则 (2.2b)**：假设归纳假设成立，即 $a = a\ \text{nat}$。现在我们要证明 $succ(a) = succ(a)\ \text{nat}$。根据等式定义的规则 (2.4b)，我们可以直接推导出 $succ(a) = succ(a)\ \text{nat}$。因此，自反性在此成立。

通过对规则 (2.2) 的归纳，我们证明了自然数等式关系的自反性。

---

### 引理 2.3：后继函数的单射性 (Lemma 2.3: Injectivity of the Successor Function)

这个引理旨在证明：如果 $succ(a_1) = succ(a_2)\ \text{nat}$，那么 $a_1 = a_2\ \text{nat}$，即后继操作是**单射的**(injective)。换句话说，如果两个自然数的后继相等，那么这两个自然数本身也相等。

#### 证明 (Proof)

该证明与引理 2.1 的证明类似。假设我们有 $succ(a_1) = succ(a_2)\ \text{nat}$，我们可以通过与引理 2.1 相同的归纳方法，利用规则 (2.2) 来推导 $a_1 = a_2\ \text{nat}$。

具体来说，归纳假设告诉我们，如果 $a_1 = a_2$，则 $succ(a_1) = succ(a_2)$ 成立。通过反向推导（即从 $succ(a_1) = succ(a_2)$ 推回到 $a_1 = a_2$），我们可以完成证明。

---

### 详细讲解 (Explanation)

#### 规则归纳法的应用

在所有这些引理中，我们都应用了**规则归纳法**(rule induction)。规则归纳法的核心思想是，通过验证某个性质对所有推导规则成立，我们就可以确保该性质对所有可推导的判断成立。具体来说，规则归纳法表明：如果一个判断可以通过规则推导出来，并且该判断的前提对某个性质 $P$ 成立，那么该判断的结论也对该性质成立。

#### 引理 2.1 的解释

引理 2.1 证明了后继操作的**逆向推导**：如果我们知道 $succ(a)\ \text{nat}$，我们就可以推导出 $a\ \text{nat}$。这为后续证明（如引理 2.3 中的单射性证明）奠定了基础，因为后继操作的逆向推导为进一步的推理提供了工具。

#### 引理 2.2 的解释

引理 2.2 证明了自然数的等式关系是**自反的**。这意味着每个自然数都等于它自身。自反性是等式的一个基本性质，也是进一步推理（如对称性和传递性）中的重要基础。

#### 引理 2.3 的解释

引理 2.3 证明了后继操作是**单射的**，即如果两个自然数的后继相等，那么这两个自然数本身也必须相等。这一性质在许多自然数的推理中都至关重要，因为它保证了每个自然数都有唯一的后继，不会发生混淆。

#### 规则的作用

在所有这些证明中，推导规则 (2.2) 和 (2.4) 是关键。规则 (2.2) 定义了自然数及其递归结构，而规则 (2.4) 定义了自然数的等式。这些规则构成了我们进行归纳证明的基础，并确保了我们能够以递归方式推导出自然数的性质。

### ----------------------------



### 2.5 迭代与同时归纳定义 (Iterated and Simultaneous Inductive Definitions)

#### 迭代归纳定义 (Iterated Inductive Definitions)

**迭代归纳定义**(Iterated Inductive Definitions) 是指一个归纳定义在另一个归纳定义的基础上进行构建。在迭代归纳定义中，推导规则的前提可以是先前定义的判断形式，也可以是正在定义的判断形式。

例如，考虑以下定义判断 $a\ \text{list}$，其表示 $a$ 是一个自然数列表：
- $nil\ \text{list}$：空列表是一个自然数列表。（规则 (2.7a)）
- 如果 $a\ \text{nat}$ 且 $b\ \text{list}$，那么 $cons(a; b)\ \text{list}$：即由自然数 $a$ 和列表 $b$ 组成的 $cons$ 也是一个自然数列表。（规则 (2.7b)）

在规则 (2.7b) 中，前提 $a\ \text{nat}$ 是之前定义的判断形式，而 $b\ \text{list}$ 则是正在定义的判断形式。因此，这种定义方式就是典型的迭代归纳定义。

#### 同时归纳定义 (Simultaneous Inductive Definitions)

**同时归纳定义**(Simultaneous Inductive Definitions) 是指通过一组规则同时定义多个不同的判断形式。在同时归纳定义中，任何一个判断形式的推导规则的前提可以涉及其他正在定义的判断形式。

由于这些规则中的每个判断形式可能都依赖于其他判断形式，因此在这种情况下，没有一个判断形式比其他形式优先定义。相反，所有判断形式都是通过完整的规则集合一起定义的。

同时归纳定义中，定义的判断形式仍然是规则下的**最强判断形式**(strongest judgment forms closed under the rules)，因此可以继续使用**规则归纳法**(rule induction)，只是这种归纳法要求我们对每个定义的判断形式同时证明某个性质。

#### 示例：偶数与奇数的同时归纳定义 (Example: Simultaneous Inductive Definition of Even and Odd Numbers)

考虑以下同时归纳定义的规则，它们定义了两个判断：
- $a\ \text{even}$ 表示 $a$ 是偶数。
- $a\ \text{odd}$ 表示 $a$ 是奇数。

归纳规则如下：
1. $zero\ \text{even}$：$0$ 是偶数。（规则 (2.8a)）
2. 如果 $a\ \text{odd}$，则 $succ(a)\ \text{even}$：即奇数的后继是偶数。（规则 (2.8b)）
3. 如果 $a\ \text{even}$，则 $succ(a)\ \text{odd}$：即偶数的后继是奇数。（规则 (2.8c)）

#### 规则归纳法在同时归纳定义中的应用 (Rule Induction in Simultaneous Inductive Definitions)

在这些规则下，规则归纳法表明：要证明对于每个偶数 $a$，$P(a\ \text{even})$ 成立，并且对于每个奇数 $a$，$P(a\ \text{odd})$ 成立，只需证明以下几点：
1. $P(zero\ \text{even})$，即 $P(0\ \text{even})$。
2. 如果 $P(a\ \text{odd})$ 成立，那么 $P(succ(a)\ \text{even})$ 也成立。
3. 如果 $P(a\ \text{even})$ 成立，那么 $P(succ(a)\ \text{odd})$ 也成立。

#### 示例：偶数与奇数是自然数 (Example: Even and Odd Numbers Are Natural Numbers)

作为一个简单的应用，我们可以通过同时规则归纳法证明以下两点：
1. 如果 $a\ \text{even}$，则 $a\ \text{nat}$。
2. 如果 $a\ \text{odd}$，则 $a\ \text{nat}$。

我们通过定义性质 $P$ 来表示这个性质：
- (1) 当且仅当 $a$ 是自然数时，$P(a\ \text{even})$ 成立。
- (2) 当且仅当 $a$ 是自然数时，$P(a\ \text{odd})$ 成立。

根据规则归纳法的原理，我们只需证明以下几点：
1. $zero\ \text{nat}$，即 $0$ 是自然数，这是通过规则 (2.2a) 推导出来的。
2. 如果 $a\ \text{nat}$，则 $succ(a)\ \text{nat}$，这是通过规则 (2.2b) 推导出来的。
3. 如果 $a\ \text{nat}$，则 $succ(a)\ \text{nat}$，这同样是通过规则 (2.2b) 推导出来的。

通过这些步骤，我们可以证明偶数和奇数都是自然数。

---

#### 详细讲解 (Detailed Explanation)

**迭代归纳定义**构建在已有定义的基础上，用于递归地定义新的判断形式。例如，自然数列表的定义依赖于自然数的定义，而列表本身的结构又是通过递归构建的。

**同时归纳定义**允许我们同时定义多个相互依赖的判断形式，这在处理互相关联的结构时非常有用。例如，偶数和奇数的定义相互依赖，通过同时归纳法可以递归定义它们的关系。

**规则归纳法**在这种情况下扩展为同时对多个判断形式进行推理。通过验证每个判断形式的前提和结论，我们可以确保这些定义是闭合的，并且符合归纳定义的原理。

这一机制在编程语言研究中尤为重要，特别是在处理复杂类型系统、操作语义和证明技术时。





### ---------------------------------

### 2.6 用规则定义函数 (Defining Functions by Rules)

在编程语言和数学中，归纳定义常用于通过关系来定义函数。具体方法是：给出函数图的归纳定义，即函数输入与输出的关系，并证明这个关系唯一地决定了给定输入的输出。下面，我会详细讲解这部分内容。

#### 用归纳定义加法函数 (Defining Addition Using Inductive Definitions)

以自然数的加法函数为例，定义的关系为 $sum(a; b; c)$，其含义是：$c$ 是 $a$ 和 $b$ 的和。该关系的规则如下：

1. **基础情况**(Base case)：
   $$
   \frac{b\ \text{nat}}{sum(zero; b; b)}
   $$
   这表示当第一个自然数 $a = zero$ 时，加法结果 $c$ 就是第二个数 $b$。

2. **递归情况**(Recursive case)：
   $$
   \frac{sum(a; b; c)}{sum(succ(a); b; succ(c))}
   $$
   这表示当 $a = succ(a')$（即 $a$ 是某个数 $a'$ 的后继）时，$sum(succ(a); b; succ(c))$ 表示递归地应用加法规则，结果是 $succ(c)$。

这两条规则定义了一个三元关系 $sum(a; b; c)$，它将自然数 $a$、$b$ 和 $c$ 关联起来，表示 $c$ 是 $a$ 和 $b$ 的和。

#### 定理 2.4：唯一性和存在性 (Theorem 2.4: Existence and Uniqueness)

为了证明加法的有效性，我们需要证明两个性质：
1. **存在性**(Existence)：对于每个 $a\ \text{nat}$ 和 $b\ \text{nat}$，存在唯一的 $c\ \text{nat}$，使得 $sum(a; b; c)$ 成立。
2. **唯一性**(Uniqueness)：如果 $sum(a; b; c_1)$ 和 $sum(a; b; c_2)$ 都成立，那么 $c_1 = c_2\ \text{nat}$。

##### 存在性的证明 (Proof of Existence)

证明存在性的思路是归纳证明，即证明每个自然数 $a$ 和 $b$ 都存在一个对应的 $c$，使得 $sum(a; b; c)$ 成立。

- **基础情况**(Base case)：当 $a = zero$ 时，我们需要证明 $P(zero\ \text{nat})$，即如果 $b\ \text{nat}$，那么存在 $c$ 使得 $sum(zero; b; c)$。根据规则 (2.9a)，我们可以直接取 $c = b$，因为 $sum(zero; b; b)$ 是有效的。

- **递归情况**(Recursive case)：假设 $P(a\ \text{nat})$ 成立，即对于每个 $b\ \text{nat}$，存在 $c$ 使得 $sum(a; b; c)$ 成立。现在，我们需要证明 $P(succ(a)\ \text{nat})$，即对于每个 $b'\ \text{nat}$，存在 $c'$ 使得 $sum(succ(a); b'; c')$ 成立。根据归纳假设，存在 $c$ 使得 $sum(a; b'; c)$。我们可以取 $c' = succ(c)$，根据规则 (2.9b)，我们可以推导出 $sum(succ(a); b'; succ(c))$ 成立，因此证明了存在性。

##### 唯一性的证明 (Proof of Uniqueness)

为了证明唯一性，我们要证明：如果 $sum(a; b; c_1)$ 和 $sum(a; b; c_2)$ 成立，那么 $c_1 = c_2\ \text{nat}$。同样，我们使用规则归纳法来证明：

- **基础情况**(Base case)：当 $a = zero$ 时，规则 (2.9a) 表明 $c_1 = b$ 且 $c_2 = b$。根据引理 2.2 的自然数自反性，$b = b$ 成立，因此 $c_1 = c_2\ \text{nat}$。

- **递归情况**(Recursive case)：假设 $sum(a; b; c_1)$ 和 $sum(a; b; c_2)$ 成立，且 $a = succ(a_0)$。根据规则 (2.9b)，$c_1 = succ(c_0)$ 且 $c_2 = succ(c_0')$，并且我们已经知道 $sum(a_0; b; c_0)$ 和 $sum(a_0; b; c_0')$。根据归纳假设，$c_0 = c_0'$ 成立，因此 $c_1 = succ(c_0) = succ(c_0') = c_2\ \text{nat}$。

通过这种方式，我们证明了加法函数的唯一性。

---

### 详细讲解 (Detailed Explanation)

#### 加法函数的归纳定义 (Inductive Definition of Addition Function)

加法函数的定义是通过一个**三元关系**(ternary relation) $sum(a; b; c)$ 实现的，表示 $a$ 和 $b$ 的和为 $c$。该定义使用了两个规则，一个处理基础情况 $a = zero$，另一个处理递归情况 $a = succ(a')$。这个递归规则表明，我们可以通过递归调用加法来计算后继的加法。

#### 定理 2.4 的存在性和唯一性 (Existence and Uniqueness in Theorem 2.4)

存在性部分使用归纳法证明：对于每个自然数 $a$ 和 $b$，总能找到唯一的 $c$ 满足加法关系。基础情况很直观，而递归情况依赖于对 $a$ 的归纳。

唯一性部分的证明展示了加法关系的确定性：对于给定的 $a$ 和 $b$，结果 $c$ 是唯一的，这也通过归纳法来证明。唯一性确保了函数的确定性，即加法在每个输入对上只产生一个输出。

#### 归纳法在函数定义中的作用 (Role of Induction in Function Definitions)

通过归纳定义，我们可以从关系中逐步构建函数，并证明该函数在每个输入上都有唯一的输出。这样的归纳结构为函数定义提供了强有力的理论基础，特别是在编程语言中处理递归函数和操作语义时非常重要。

这种方法不仅适用于加法函数，还可以扩展到其他递归函数的定义，例如乘法、阶乘等，都是通过类似的规则递归定义的。这种方法为函数的数学定义和验证提供了清晰的框架。

### ---------------------------------

### 2.7 模式 (Modes)

**模式**(Mode) 是指一个判断的某些参数可以由其他参数唯一（或部分唯一）确定的陈述。模式指定哪些参数是输入，哪些参数是输出，这在定义递归函数时非常重要。通过模式，我们可以更清晰地表达判断和参数之间的关系。

#### 模式的形式 (Form of Modes)

例如，在加法的归纳定义中，我们已经通过规则 (2.9) 证明了每两个自然数都有一个和。这个事实可以通过模式规范重新表述，即判断 $sum(a; b; c)$ 的模式是 $(\forall, \forall, \exists)$，意思是：对于所有自然数 $a$ 和 $b$，存在一个自然数 $c$ 使得 $sum(a; b; c)$ 成立。具体来说，这表示 $a$ 和 $b$ 是输入，$c$ 是输出。

模式的形式为 $(\forall, \forall, \exists)$，其中：
- $\forall$ 表示该参数是输入（对所有 $a$ 和 $b$，它们是给定的）。
- $\exists$ 表示该参数是输出（存在一个 $c$，由前面的参数确定）。

#### 唯一性和部分唯一性 (Uniqueness and Partial Uniqueness)

如果我们希望进一步指定 $c$ 由 $a$ 和 $b$ 唯一确定，我们可以用 $(\forall, \forall, \exists!)$ 来表示模式。这表明，对于所有自然数 $a$ 和 $b$，存在一个**唯一的**自然数 $c$ 使得 $sum(a; b; c)$ 成立。

如果我们只希望指定 $c$ 在存在的情况下是唯一的，那么模式为 $(\forall, \forall, \exists \leq 1)$，表示：对于所有 $a\ \text{nat}$ 和 $b\ \text{nat}$，最多存在一个 $c\ \text{nat}$ 使得 $sum(a; b; c)$ 成立。

#### 模式的多样性 (Variety of Modes)

一个给定的判断可能满足多个不同的模式。例如，除了 $(\forall, \forall, \exists!)$ 之外，加法还可以有模式 $(\forall, \exists \leq 1, \forall)$，这表示：加法的和 $c$ 和第一个加数 $a$ 唯一确定了第二个加数 $b$。换句话说，加法是有**逆操作**的，即减法。

类似地，加法也可以有模式 $(\exists \leq 1, \forall, \forall)$，这意味着：加法有部分逆操作。换句话说，如果我们知道和 $c$ 和一个加数 $a$，我们就可以唯一地确定另一个加数 $b$，当然这个操作可能不总是可行（比如，当 $a > c$ 时，减法没有意义）。

#### 主模式 (Principal Mode)

在很多情况下，一个判断的某个模式是我们**预期的模式**(intended or principal mode)，通常可以通过符号表示法来暗示。例如，使用等式定义函数时，左侧表示输入，右侧表示输出。考虑加法的归纳定义：

1. 基础情况：
   $$
   \frac{a\ \text{nat}}{a + zero = a\ \text{nat}} 
   $$
   这表示对于所有自然数 $a$，$a + 0 = a$，这是加法的基础情况。

2. 递归情况：
   $$
   \frac{a + b = c\ \text{nat}}{a + succ(b) = succ(c)\ \text{nat}}
   $$
   这表示如果我们已经知道 $a + b = c$，那么 $a + \text{succ}(b) = \text{succ}(c)$。

通过这样的符号表示法，我们可以清楚地看出输入和输出的关系。这种表达暗示了我们对函数输入输出关系的预期。我们通常假设右侧的输出（例如 $c$）由左侧的输入（例如 $a$ 和 $b$）唯一确定。

#### 模式规范的证明义务 (Obligation to Prove Mode Specification)

当我们使用等式形式定义函数时，实际上就承担了证明该模式的义务。我们需要证明，给定等式左边的输入，等式右边的输出是唯一确定的。完成这个证明后，我们可以滥用符号，简单地写 $a + b$ 来表示唯一的 $c$，而不是写完整的关系 $a + b = c\ \text{nat}$。

### 详细讲解 (Detailed Explanation)

#### 模式的定义与应用 (Definition and Application of Modes)

模式是用来描述判断参数之间关系的重要工具。模式规范中使用的量词 $\forall$ 和 $\exists$ 表示参数是输入还是输出。通过模式，我们可以清楚地表明一个判断的某些参数是否完全由其他参数决定，以及这种决定性是否唯一。

例如，模式 $(\forall, \forall, \exists!)$ 意味着给定前两个参数，第三个参数是唯一确定的。这种模式非常适合用来描述函数定义，因为在函数中，我们通常期望给定输入有唯一的输出。

#### 模式的多样性与逆操作 (Variety of Modes and Inverses)

模式不仅限于正向的输入输出关系，还可以表达**逆操作**。例如，加法的模式 $(\forall, \exists \leq 1, \forall)$ 表示给定和 $c$ 和一个加数 $a$，我们可以唯一地确定另一个加数 $b$。这说明加法有部分逆操作，即减法。虽然这种逆操作不总是定义的（例如 $a > c$ 时，减法不可行），但模式清楚地表明了逆操作的可能性。

#### 预期模式与符号的关系 (Relationship Between Principal Mode and Notation)

在使用符号定义函数时，我们常常假设输出是由输入唯一确定的。这样的符号表达，比如加法的递归定义，不仅展示了函数的实现方式，还隐含了输入和输出的关系。这要求我们证明加法的输出是唯一确定的，即证明加法函数的模式是 $(\forall, \forall, \exists!)$。

模式的这些概念在编程语言的语义学中非常重要，特别是当我们处理递归函数和复杂的类型系统时，模式有助于明确变量之间的依赖关系，确保函数和操作的唯一性和一致性。

### ---------------------------------

### 2.8 注释 (Notes)

这一节提供了归纳定义理论的背景知识，并引用了一些关键的学术贡献。归纳定义是编程语言和逻辑研究中的核心工具，它们为判断和函数的定义提供了坚实的基础。以下是一些详细的背景信息和重要参考文献。

#### Aczel 对归纳定义理论的贡献

Aczel 在 1977 年的工作中详细讨论了**归纳定义理论**(Theory of Inductive Definitions)，这是**现代逻辑学和类型论**的重要组成部分。Aczel 的理论提供了关于如何使用归纳规则定义复杂对象的数学框架。这种理论在编程语言和逻辑推理中被广泛应用，用于构建递归结构和定义递归函数。

具体来说，Aczel 的工作涉及通过一组规则定义对象集合，并利用这些规则来推导新的对象或判断。这一框架不仅适用于自然数等简单对象，也适用于复杂的数学和计算结构。

#### Martin-Löf 的判断逻辑发展

Martin-Löf 在 1983 年和 1987 年的研究中，提出并发展了**判断逻辑**(Logic of Judgments) 的理论。Martin-Löf 的工作对现代类型论和构造性数学影响深远，尤其是他的**构造类型论**(Constructive Type Theory) 和判断逻辑的发展。

在他的理论中，判断 (Judgments) 是所有逻辑推理的基础。判断表明某个陈述是有效的（例如，一个数是自然数）。通过规则，我们可以推导新的判断。例如，自然数的定义是通过一组递归规则推导出来的，即 $zero\ \text{nat}$ 和 $succ(a)\ \text{nat}$。

Martin-Löf 的判断逻辑强调了如何通过归纳规则定义判断，并确保判断的一致性和正确性。这为类型系统、程序语义以及逻辑推理的形式化提供了框架。

#### 归纳定义的应用

在编程语言中，归纳定义被广泛用于描述语言的语法和语义。例如，在函数式编程语言中，函数的定义常常是递归的，而这些递归定义的结构正是通过归纳定义来表述的。使用归纳定义的关键是保证这些定义是**闭合的**(closed under rules)，即根据定义推导出的所有判断都是一致的。

#### 总结

通过参考 Aczel 和 Martin-Löf 的工作，本章的归纳定义构建在坚实的理论基础上。这些理论为现代编程语言中的递归定义、函数定义以及类型系统提供了基本框架，确保了函数、数据结构和判断的形式化和一致性。这种理论方法在编程语言的设计、验证和推理中起到了至关重要的作用。

### 进一步阅读
- Aczel, P. (1977). *An Introduction to the Theory of Inductive Definitions*.
- Martin-Löf, P. (1983, 1987). *Constructive Type Theory and the Logic of Judgments*.


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


[toc]



### Chapter 7: Evaluation Dynamics 详解

在第5章中，我们讨论了使用**结构动态**(structural dynamics)来定义L{num str}表达式的求值过程。这种方法通过逐步转移表达式状态的方式，提供了对语言性质进行证明的基础。然而，除了结构动态外，还有一些其他的求值方法在实际应用中更加合适，尤其是在为用户编写手册或指导文档时。

#### **Evaluation Dynamics (求值动态)**

1. **简化的求值方式**:
   - **求值动态**是将表达式和其值之间的关系作为焦点，而不详细说明如何逐步确定这个值。这种方法在描述语言的基本行为时较为直观，例如，它更适合用于用户手册中，只展示表达式最终得到的值，而不涉及复杂的中间步骤。
   - 与**结构动态**不同，**求值动态**不提供逐步计算的细节。这意味着它无法揭示程序的时间复杂度等信息。

2. **优势与局限性**:
   - **优势**: 这种简化方法使得理解语言的行为更加直接，特别是在不关心内部求值过程细节的场景中（如编写文档或解释性材料时）。
   - **局限性**: 由于求值动态不关注中间步骤，它无法帮助我们分析程序的性能或时间复杂度。这在需要进行**优化**或**性能分析**时变得不足。

#### **Relating Structural and Evaluation Dynamics (结构动态与求值动态的关系)**

- 结构动态通过逐步描述程序的求值过程，展现了程序从初始状态到最终值的完整转变过程。相比之下，**求值动态**仅关注最终结果，忽略了中间的转换。
- 尽管它们的侧重点不同，结构动态和求值动态之间依然存在内在联系：**结构动态的每一步转移规则**其实都可以归结为求值动态中的一个映射关系，即**从一个表达式到其值的映射**。
- 可以认为，求值动态是对结构动态的抽象化，忽略了具体的执行步骤，直接展示了表达式和最终值之间的联系。

#### **Type Safety, Revisited (重新审视类型安全)**

- 在第6章中，我们已经讨论了类型安全，确保**良好类型的程序不会卡住**。当我们从求值动态的角度重新审视类型安全时，类型安全可以更加简明地解释为：对于任何表达式，如果它是良好类型的，那么在求值动态中，它将总能映射到一个值，而不会进入一个不合法的状态。
- **求值动态与类型安全**：在求值动态的上下文中，类型安全保证了每个表达式都能映射到正确的值类型。这种简化的视角更容易让用户理解“为什么一个良好类型的程序不会出错”。

#### **Cost Dynamics (成本动态)**

- 为了解决求值动态中缺乏**时间复杂度**分析的问题，我们可以引入**成本动态**(cost dynamics)。**成本动态**在求值动态的基础上，增加了一个**成本度量**，用于表示计算表达式的时间成本。
   - 例如，我们可以定义成本为**结构动态**中一个表达式达到其最终值所需的步骤数。
   - **不同的成本度量**: 除了步骤数，成本还可以通过其他指标来度量，比如计算的内存消耗、递归深度等。这使得成本动态在分析程序性能时变得非常有用。

#### **小结**

- **求值动态**提供了一种更加简化的方式来理解语言的行为，省略了中间的执行步骤，只关注表达式和其最终值。
- **结构动态**与**求值动态**是密切相关的，前者提供了逐步的转移规则，而后者是对这些规则的抽象。
- **成本动态**通过引入成本度量，解决了求值动态中无法分析时间复杂度的问题，使得我们能够衡量程序的执行效率。

这种不同的求值视角在不同的上下文中各有其用，**结构动态**更适合于精确分析和推导，而**求值动态**则更适合用于简明的说明或文档编写，**成本动态**则可以帮助分析程序性能。

### ---------------------------------

### 详解：7.1 Evaluation Dynamics (求值动态)

#### 概述
**求值动态**（Evaluation Dynamics）是一种通过归纳定义来描述表达式的求值方式，其核心概念是**求值判断**，通常形式为 $e \Downarrow v$，表示**闭合表达式** $e$ 能够求值为**值** $v$。在 L{num str} 语言的上下文中，求值动态使用一系列规则来定义如何从一个表达式 $e$ 导出其最终值 $v$。

求值动态相对于**结构动态**而言，简化了执行步骤，只关心最终结果。这种定义方法在简化表达式求值的同时，仍能提供足够的结构化框架来进行程序分析。

#### 具体规则解析
在 L{num str} 的求值动态中，规则 (7.1a) 到 (7.1f) 定义了语言中不同构造的求值方式。我们逐一分析每个规则的含义：

#### 1. **数值求值**:
$$
\text{num}[n] \Downarrow \text{num}[n]
$$
**解释**: 这个规则 (7.1a) 指出，任何数值字面量 $\text{num}[n]$ 的求值结果就是其自身，即数值表达式 $e$ 在其求值过程中不会发生任何改变。比如：
$$
\text{num}[5] \Downarrow \text{num}[5]
$$

#### 2. **字符串求值**:
$$
\text{str}[s] \Downarrow \text{str}[s]
$$
**解释**: 类似地，字符串字面量 $\text{str}[s]$ 也直接求值为其自身，不会有进一步的计算 (规则 7.1b)。例如：
$$
\text{str}["hello"] \Downarrow \text{str}["hello"]
$$

#### 3. **加法求值**:
$$
e_1 \Downarrow \text{num}[n_1] \quad e_2 \Downarrow \text{num}[n_2] \quad n_1 + n_2 = n \quad \text{nat}
$$
$$
\frac{}{plus(e_1; e_2) \Downarrow \text{num}[n]}
$$
**解释**: 规则 (7.1c) 描述了加法运算的求值过程。首先，对两个子表达式 $e_1$ 和 $e_2$ 分别进行求值，得到数值 $n_1$ 和 $n_2$，然后计算它们的和 $n$。例如：
$$
plus(\text{num}[2]; \text{num}[3]) \Downarrow \text{num}[5]
$$

#### 4. **字符串拼接求值**:
$$
e_1 \Downarrow \text{str}[s_1] \quad e_2 \Downarrow \text{str}[s_2] \quad s_1 \hat{s_2} = s \quad \text{str}
$$
$$
\frac{}{cat(e_1; e_2) \Downarrow \text{str}[s]}
$$
**解释**: 规则 (7.1d) 处理字符串的拼接运算。首先对两个子表达式 $e_1$ 和 $e_2$ 求值为字符串 $s_1$ 和 $s_2$，然后进行字符串拼接，结果是 $s$。例如：
$$
cat(\text{str}["hello"]; \text{str}["world"]) \Downarrow \text{str}["helloworld"]
$$

#### 5. **字符串长度求值**:
$$
e \Downarrow \text{str}[s] \quad |s| = n \quad \text{nat}
$$
$$
\frac{}{len(e) \Downarrow \text{num}[n]}
$$
**解释**: 规则 (7.1e) 处理字符串的长度运算。首先对字符串表达式 $e$ 求值，得到字符串 $s$，然后计算该字符串的长度 $n$，结果是一个数值。例如：
$$
len(\text{str}["hello"]) \Downarrow \text{num}[5]
$$

#### 6. **let 绑定的求值**:
$$
[e_1/x]e_2 \Downarrow v_2
$$
$$
\frac{}{let(e_1; x.e_2) \Downarrow v_2}
$$
**解释**: 规则 (7.1f) 描述了 `let` 绑定的求值过程。求值 $let$ 表达式时，首先对 $e_1$ 求值，然后将结果代入到 $e_2$ 中，得到最终的值 $v_2$。例如：
$$
let(\text{num}[5]; x.plus(x; \text{num}[3])) \Downarrow \text{num}[8]
$$
在这个例子中，首先 $e_1$ 被求值为 $\text{num}[5]$，接着将 $5$ 代入 $e_2$ 得到 $plus(\text{num}[5]; \text{num}[3])$，最终计算结果是 $8$。

#### **非语法导向性 (Non-syntax-directed nature)**

需要注意的是，像 (7.1f) 这样的规则并不是**语法导向**(syntax-directed)的。这是因为规则的前提部分（例如 $[e_1/x]e_2$ 的求值）并不直接对应于结论部分中的某个子表达式。这意味着不能通过简单的分解表达式直接找到前提，而需要进行更复杂的推理（例如变量替换）。

#### 总结

**求值动态**提供了一种简化的、一步到位的表达式求值方式。相比结构动态，它不关心表达式是如何一步一步被简化的，而是关注最终结果。求值规则可以帮助我们直接推导出闭合表达式的最终值，并且能够捕捉到语言中的主要构造（如加法、字符串拼接、长度计算等）是如何求值的。

**关键点**：
- 每个构造的求值由相应的规则定义。
- 求值动态是通过归纳定义来表述的。
- 不同于结构动态，求值动态忽略了中间的转换步骤，直接展示了表达式的最终求值。

这种方法在需要快速理解程序行为时非常有用，尤其是当我们只关心表达式的结果而不是其计算细节时。

### ---------------------------------

**结构动态**（Structural Dynamics）和**求值动态**（Evaluation Dynamics）是两种在编程语言语义学中描述程序行为的不同视角。**结构动态**关注程序的语法结构如何一步步被简化或重写，而**求值动态**则聚焦于程序执行过程中表达式的求值过程。这两者紧密相关，共同描述了编程语言的执行过程。理解它们之间的关系可以帮助我们更好地理解程序的语义、类型系统和执行方式。

### 1. **结构动态** (Structural Dynamics)

**结构动态**，通常也称为**结构操作语义** (Structural Operational Semantics, SOS)，是一种通过一组推导规则来描述程序的演化步骤的方式。这种方式主要从**程序的语法结构**入手，描述程序如何一步步通过语法规则转换成另一个更简单的形式，直到它到达一个值或停止状态。

#### 结构动态的特点：
- **推导规则**：定义程序结构的转换步骤，例如如何处理控制流（如条件分支、循环）和函数调用。
- **逐步简化**：通过一系列语法重写规则，表达式会逐步简化。
- **与语法结构紧密相关**：重点在于程序的语法如何演化。
  
#### 示例：
对于一个简单的加法表达式 `2 + 3`，结构动态可能描述如下转换过程：

$$
(2 + 3) \rightarrow 5
$$

在这种情况下，结构动态的规则描述了如何通过将表达式 `2 + 3` 计算为 `5` 来简化表达式。

### 2. **求值动态** (Evaluation Dynamics)

**求值动态**，也可以称为**计算语义**（Evaluation Semantics），着眼于表达式在求值过程中的行为，即程序在执行过程中如何对表达式进行计算。它强调**值**的生成以及表达式是如何通过求值过程来演化的。

#### 求值动态的特点：
- **求值顺序**：描述程序在执行时如何计算表达式的值，通常通过定义求值策略（如值调用、名调用、惰性求值）。
- **侧重结果**：求值动态的核心在于得到表达式的值，而不是程序结构的简化。
- **关注执行时的行为**：与运行时的计算过程密切相关。

#### 示例：
对于表达式 `2 + 3`，求值动态描述如何得到最终的结果值 `5`。求值动态关注的是 `2` 和 `3` 的加法计算，并返回最终的值 `5`。

### 3. **结构动态与求值动态的关系**

**结构动态**和**求值动态**本质上是编程语言语义学的两种描述方式，它们通过不同的角度来处理程序的执行过程：

- **结构动态**：关注的是**表达式的重写规则**，如何一步步通过语法规则简化表达式的结构。
- **求值动态**：关注的是**求值的过程**，描述了如何通过计算表达式生成值。

它们之间的关系可以通过以下几个方面来理解：

#### 1. **表达式简化与求值**
- **结构动态**可以看作是描述表达式如何在语法层面逐步**简化**。通过语法重写规则，表达式的结构被逐渐替换为更简单的形式。
- **求值动态**描述的是程序的表达式如何通过实际**计算**得出结果值，尤其关注表达式的求值顺序和执行方式。

例如：
```haskell
let x = 2 + 3
```
- 在**结构动态**中，`2 + 3` 的语法被简化为 `5`。
- 在**求值动态**中，`2 + 3` 被计算为 `5`，并赋值给 `x`。

#### 2. **演化过程与计算结果**
- **结构动态**侧重于表达式的**演化过程**，即表达式通过哪些语法规则被转换成了什么样的形式。
- **求值动态**关心的是程序最终**计算出什么值**，并关注计算过程中是否发生了副作用。

例如，对于以下表达式：
```haskell
if (True) then 1 else 2
```
- 在**结构动态**中，表达式 `if (True) then 1 else 2` 可以通过语法规则简化为 `1`，因为 `True` 满足条件分支。
- 在**求值动态**中，`1` 是通过 `True` 分支选择的结果，最终计算出值 `1`。

#### 3. **类型安全性**
在类型系统中，**结构动态**与**求值动态**都与**类型安全性**紧密相关。通过**进展性**（Progress）和**保持性**（Preservation）两个性质，我们可以证明程序在**结构演化**和**求值过程**中的类型保持不变。这两个性质表明：

- **进展性**：如果一个表达式类型正确，那么它要么是一个值，要么可以通过某个规则进一步演化。
- **保持性**：在程序的演化过程中，如果一个表达式类型正确，那么它演化后的表达式仍然保持相同的类型。

#### 示例：
考虑以下表达式：
```haskell
let x = 2 in x + 3
```
- **结构动态**可以描述这个表达式的语法如何一步步被简化为 `5`。
- **求值动态**描述了如何通过对 `x` 进行求值，再进行加法运算得到最终的值 `5`。

通过这两种方式的结合，可以证明该程序在演化和求值过程中不会出现类型错误。

#### 4. **从结构动态到求值动态的过渡**
结构动态为求值动态提供了基础。结构动态通过描述语法上的转换，定义了程序如何**逐步简化**，并确保每一步都是合法的。这为求值动态提供了一个框架，确保每个简化步骤都能够**计算出值**。

例如，对于一个递归函数：
```haskell
factorial(n) = if (n == 0) then 1 else n * factorial(n - 1)
```
- **结构动态**描述递归如何展开，直到遇到基准情况 `n == 0`。
- **求值动态**则描述每一步乘法运算的求值过程，直到计算出结果。

### 4. **结构动态与求值动态的综合分析**

| **维度**             | **结构动态** (Structural Dynamics)                | **求值动态** (Evaluation Dynamics)         |
| -------------------- | ------------------------------------------------- | ------------------------------------------ |
| **侧重点**           | 程序的语法结构如何一步步简化                      | 表达式在运行时如何计算出值                 |
| **主要描述**         | 描述语法层面的演化规则，如重写规则和语法推导      | 关注程序在求值过程中的计算顺序和结果       |
| **典型应用场景**     | 操作语义（Structural Operational Semantics, SOS） | 程序求值、解释器设计、运行时求值           |
| **类型安全性**       | 通过结构规则确保程序语法正确性                    | 通过求值规则确保类型在执行过程中保持一致   |
| **与语法的关系**     | 紧密相关，通过语法推导来演化表达式                | 较少依赖语法结构，更多关注求值行为         |
| **与执行顺序的关系** | 描述程序在语法上的逐步简化过程                    | 描述程序在运行时的实际计算过程             |
| **副作用的处理**     | 通常忽略副作用，关注语法的转换                    | 可能涉及副作用处理，如函数调用时的状态变化 |

### 5. **总结：结构动态与求值动态的互补性**

- **结构动态**侧重于程序的**语法演化**，提供了一种形式化的方式来描述程序的逐步简化过程。
- **求值动态**则更多关注**计算过程**，强调程序的求值顺序和最终结果。

这两者在编程语言设计和解释器构建中具有互补性：**结构动态**提供了一种描述程序如何通过规则逐步演化的框架，而**求值动态**则基于这个框架提供了计算值的方式。两者结合，能够确保编程语言的正确性、类型安全性以及执行效率。

### ---------------------------------

### 详解：By-Value Interpretation of Definitions in Evaluation Dynamics

在这里，我们通过介绍规则 (7.2) 来说明 **by-value** 定义的求值方式与之前的 **by-name** 定义的区别。首先，回顾一下之前规则 (7.1f) 是通过对绑定变量进行替换来执行 `let` 表达式的，这是一种**by-name** 的求值策略。

然而，在 **by-value** 策略中，我们首先要对绑定表达式求值，获得它的结果，然后再将这个结果绑定到变量上，这就像对变量进行“值替换”。新的求值规则如下：

$$
e1 \Downarrow v1 \quad [v1/x]e2 \Downarrow v2
$$
$$
\frac{}{let(e1; x.e2) \Downarrow v2}
$$

### 解释：By-Value 求值规则 (7.2)

在 **by-value** 解释中：
1. 首先对 $e1$ 进行求值，得到一个值 $v1$。
2. 然后用该值 $v1$ 替换掉 $e2$ 中的变量 $x$，并对替换后的表达式继续求值，得到最终结果 $v2$。

相比之下，**by-name** 解释是直接将表达式 $e1$ 代入 $e2$，而不是先求值。这两种求值方式在性能和行为上可能会有显著差异，具体取决于 $e1$ 和 $x$ 在 $e2$ 中的使用频率。

### 归纳证明性质

求值判断是通过归纳定义的，所以要证明某个性质 $P(e \Downarrow v)$ 对所有表达式和求值都成立，我们需要进行**规则归纳**。具体来说，按照规则 (7.1) 的形式，我们可以逐条验证 $P$ 对所有求值规则是否封闭：

1. **数值求值**：我们需要证明 $P(\text{num}[n] \Downarrow \text{num}[n])$ 成立。
2. **字符串求值**：我们需要证明 $P(\text{str}[s] \Downarrow \text{str}[s])$ 成立。
3. **加法求值**：假设 $P(e_1 \Downarrow \text{num}[n_1])$ 和 $P(e_2 \Downarrow \text{num}[n_2])$ 均成立，并且 $n_1 + n_2 = n$，那么我们需要证明 $P(\text{plus}(e_1; e_2) \Downarrow \text{num}[n])$ 成立。
4. **字符串拼接求值**：假设 $P(e_1 \Downarrow \text{str}[s_1])$ 和 $P(e_2 \Downarrow \text{str}[s_2])$ 均成立，并且 $s_1 \hat s_2 = s$，那么我们需要证明 $P(\text{cat}(e_1; e_2) \Downarrow \text{str}[s])$ 成立。
5. **let 表达式求值 (By-Name)**：假设 $P([e_1/x]e_2 \Downarrow v_2)$，我们需要证明 $P(\text{let}(e_1; x.e_2) \Downarrow v_2)$ 成立。

### 规则归纳原理和结构归纳的区别

这种归纳方式不同于直接对表达式 $e$ 进行结构归纳。求值规则并不是单纯依赖于表达式的结构（即**非语法导向性**），因此直接对表达式结构进行归纳往往无法覆盖所有情况。例如，`let` 表达式的求值过程涉及变量替换，因此它无法简单地通过对表达式进行分解来归纳证明，而必须通过规则的前提（即对子表达式的求值）来逐步推导。

### **引理 7.1**：值的最终性 (Finality of Values)

引理 7.1 的证明表明，任何能够成功求值的表达式，其结果一定是一个值 $v$。即：
$$
\text{若 } e \Downarrow v, \text{则 } v \text{ 一定是一个值}.
$$

#### **证明**:

我们通过对规则 (7.1) 的归纳证明这个引理。除了规则 (7.1f) 之外，其他情况都能直接从规则本身得出结论。对于规则 (7.1f)，由于其前提要求 $[e_1/x]e_2 \Downarrow v_2$，可以通过归纳假设得到结论。因此，我们可以推断出 $v_2$ 必定是一个值。

### 结论

通过规则归纳和引理证明，我们确保了求值过程的一致性：如果表达式能够求值，其结果必然是一个有效的值。这是求值动态中非常关键的一步，它确保了语言中的求值是正确且完备的。

**关键点总结**：
- **by-value** 与 **by-name** 的求值方式不同，**by-value** 先求值再替换变量，**by-name** 直接替换。
- 通过规则归纳证明性质时，要逐条验证每个规则对假设性质的封闭性。
- **引理 7.1** 保证了每个能够求值的表达式其结果必然是一个有效的值。

### ---------------------------------

在编程语言的语义学中，**语法导向** (Syntax-Directed) 和 **非语法导向性** (Non-Syntax-Directed) 是两种描述程序结构和推导规则的重要方式。它们涉及如何定义和解释语言的语义，尤其是在类型系统、编译器设计和解释器中起着关键作用。下面我们详细分析这两者的含义、区别及应用场景。

### 1. **语法导向性** (Syntax-Directed Nature)

**语法导向性**指的是根据程序的**语法结构**来定义程序的语义或类型推导规则。也就是说，语法的每一个部分或构造子都有对应的语义规则或类型规则。这种方式通常是基于上下文无关文法 (Context-Free Grammar) 的语法规则来构建的，并且推导过程直接与语法结构相关联。

#### 特点：
- **规则与语法结构直接对应**：每个语法构造子（如算术表达式、条件表达式、函数调用等）都有明确的语义规则。
- **逐步构造语义或类型**：基于语法树的节点，推导每个部分的语义或类型。
- **可预测性强**：程序的每一部分都有固定的推导规则，方便推导和解析。
  
#### 例子：
考虑一个简单的加法表达式的语法导向类型系统：

```c
e ::= e + e | n
```

对于加法表达式 `e1 + e2`，语法导向的类型规则可以定义为：

$$
\frac{\Gamma \vdash e_1 : int \quad \Gamma \vdash e_2 : int}{\Gamma \vdash e_1 + e_2 : int}
$$

这表示：如果 `e1` 和 `e2` 都是 `int` 类型，则 `e1 + e2` 的类型也是 `int`。推导规则直接与表达式的语法结构相关。

#### 应用场景：
- **编译器设计**：编译器通过语法导向的推导规则生成语法树，然后根据树的结构进行类型检查和代码生成。
- **解释器**：解释器通常使用语法导向规则来解释程序的执行。
- **类型系统**：语法导向的类型推导是大多数静态类型系统的基础，确保程序的类型与其语法结构一致。

### 2. **非语法导向性** (Non-Syntax-Directed Nature)

**非语法导向性**指的是语义或类型推导规则**不完全依赖于程序的语法结构**。在这种情况下，推导规则不仅仅根据语法结构来确定，而是可能依赖于更全局的上下文、计算状态或其他辅助信息。例如，某些语义规则可能会跳过某些语法结构，或者规则的应用需要依赖于更复杂的约束或全局信息。

#### 特点：
- **不直接依赖语法树的结构**：推导规则可能不会严格按照语法树的节点一一对应。
- **更灵活的推导规则**：可以基于全局上下文或动态信息进行推导，而不受限于语法构造的逐步推导。
- **更复杂的推导逻辑**：推导过程中可能涉及全局信息或动态计算，而不仅仅依赖于局部的语法规则。

#### 例子：
考虑函数多态的类型推导，在一些语言中，函数的类型推导规则不严格依赖于语法结构。假设有一个函数：

```haskell
f :: a -> a
```

对于不同的上下文，这个函数的类型 `a` 可以推导为 `int`，`bool` 或其他类型。这种推导不是严格基于语法结构，而是依赖于函数在不同上下文中的使用方式，这就是非语法导向性的一种体现。

另一个例子是**类型推断**，例如在 Haskell 中的 Hindley-Milner 类型推导系统中，类型推断通过一系列统一的过程，而不是仅通过语法直接推导出类型。

#### 应用场景：
- **类型推断**：某些语言的类型系统，特别是支持多态和类型推断的系统（如 Haskell、OCaml），其类型推导通常是不完全依赖于语法结构的。
- **高级编程语言特性**：在处理如闭包、类型擦除、泛型推导等复杂特性时，推导规则可能会依赖更多的上下文信息而非直接基于语法。
- **优化器设计**：某些编译器优化器可能不会完全依赖语法结构，而是基于更高层次的程序分析来进行优化。

### 3. **语法导向性与非语法导向性的区别**

| **维度**         | **语法导向性** (Syntax-Directed)                   | **非语法导向性** (Non-Syntax-Directed)                       |
| ---------------- | -------------------------------------------------- | ------------------------------------------------------------ |
| **推导规则**     | 每个语法构造都有直接对应的推导规则                 | 推导规则不严格依赖于语法结构，可能依赖于全局信息或上下文     |
| **推导过程**     | 基于语法树逐步构建推导                             | 推导过程更加灵活，可能涉及复杂的全局分析                     |
| **语义的构建**   | 逐步通过语法树的节点生成语义或类型推导             | 语义构建过程中可能依赖于动态信息、上下文或更复杂的约束       |
| **灵活性**       | 规则固定，推导过程较为刚性                         | 更灵活，可处理复杂的语言特性或多态性问题                     |
| **复杂度**       | 通常较为简单，语法和语义规则一一对应               | 更复杂，推导过程中可能涉及全局分析或动态计算                 |
| **应用场景**     | 编译器前端，解释器，静态类型系统                   | 类型推断系统，动态类型语言，编译器优化                       |
| **可扩展性**     | 扩展较为困难，因为每个语法构造都需要定义相应的规则 | 可扩展性较强，推导规则可以根据需要灵活调整                   |
| **典型应用语言** | C、Java 等命令式语言的编译器，语法树和类型推导一致 | Haskell 的类型推断系统、动态类型语言、Hindley-Milner 类型推导系统 |

### 4. **语法导向性和非语法导向性的实例分析**

#### 实例1：简单表达式语言中的语法导向性
```c
e ::= e1 + e2 | n | (e)
```
在语法导向规则中，我们可以为每一个表达式定义明确的推导规则。例如，对于 `e1 + e2`：

$$
\frac{\Gamma \vdash e_1 : int \quad \Gamma \vdash e_2 : int}{\Gamma \vdash e_1 + e_2 : int}
$$

这里的推导规则完全依赖于表达式的语法结构，每个语法构造子都严格对应一个类型推导规则。

#### 实例2：多态函数中的非语法导向性
```haskell
f x = x
```
在 Haskell 中，`f` 的类型是 `f :: a -> a`，并且 `a` 可以是任何类型（`int`、`bool` 等）。这种推导不仅依赖于函数的语法结构，还依赖于 `f` 在不同上下文中的使用方式。例如，在不同上下文中，`f` 可以具有不同的实例化类型：

- 在 `f 3` 中，`f` 的类型推导为 `int -> int`。
- 在 `f True` 中，`f` 的类型推导为 `bool -> bool`。

这种类型推导不仅依赖语法结构，还需要结合上下文信息进行推断，这就是非语法导向的表现。

### 5. **总结**

- **语法导向性**通过程序的语法结构定义推导规则，每个语法构造子都有明确的规则，通常用于编译器前端、解释器和静态类型系统。它的规则刚性强、推导过程清晰，但在处理复杂特性时可能缺乏灵活性。
  
- **非语法导向性**推导不依赖于程序的语法结构，而是可能基于全局的上下文或动态信息，具有更高的灵活性。它适用于需要处理复杂语言特性（如类型推断、多态、闭包等）的系统。

在实际应用中，两者常常结合使用。例如，在编译器的前端阶段可以采用语法导向规则进行基础的类型推导，而在处理多态、泛型等复杂语言特性时，则会采用非语法导向的推导规则来处理更复杂的推导逻辑。

### ---------------------------------

### 详解：7.2 Relating Structural and Evaluation Dynamics

在本节中，我们讨论 **结构动态（structural dynamics）** 和 **求值动态（evaluation dynamics）** 之间的关系。两者都是描述编程语言求值过程的方式，但它们有不同的侧重点：
- **结构动态** 通过逐步的状态转换来定义程序的执行过程，记录每个中间状态。
- **求值动态** 则跳过中间状态，仅关注初始状态和最终的结果。

因此，在讨论两者的等价性时，我们需要仔细考虑两种动态的求值过程之间的联系。一个自然的问题是：**结构动态中的完整执行序列** 是否对应于 **求值动态中的求值判断**。

### 定理 7.2：**结构动态与求值动态的等价性**

我们需要证明对于所有的闭合表达式 $e$ 和结果值 $v$，如果 $e$ 根据结构动态可以通过多步转换成为值 $v$，那么根据求值动态，$e$ 也可以直接求值为 $v$，反之亦然。即：
$$
e \xrightarrow{*} v \iff e \Downarrow v
$$
其中，$\xrightarrow{*}$ 表示多步转换，而 $\Downarrow$ 表示求值到一个值。

### **证明的思路**

证明这个定理的过程分为两个方向：首先证明如果 $e \Downarrow v$，则 $e \xrightarrow{*} v$，然后证明如果 $e \xrightarrow{*} v$，则 $e \Downarrow v$。

#### 引理 7.3：如果 $e \Downarrow v$，那么 $e \xrightarrow{*} v$。

**证明**：

我们对求值判断进行归纳，逐步展示从表达式 $e$ 到值 $v$ 的多步转换过程。例如，假设有以下求值判断：
$$
plus(e_1; e_2) \Downarrow \text{num}[n]
$$
根据求值规则，我们知道 $e_1 \Downarrow \text{num}[n_1]$ 且 $e_2 \Downarrow \text{num}[n_2]$，并且 $n_1 + n_2 = n$。因此，我们可以推导出以下转换序列：

$$
plus(e_1; e_2) \xrightarrow{*} plus(\text{num}[n_1]; e_2)
$$
$$
\xrightarrow{*} plus(\text{num}[n_1]; \text{num}[n_2])
$$
$$
\xrightarrow{} \text{num}[n_1 + n_2]
$$

这证明了 $plus(e_1; e_2) \xrightarrow{*} \text{num}[n_1 + n_2]$，因此满足 $e \xrightarrow{*} v$。

**其他情况** 的处理与此类似，例如字符串拼接和 `let` 表达式的求值规则。

#### 引理 7.4：如果 $e \xrightarrow{} e_0$ 且 $e_0 \Downarrow v$，那么 $e \Downarrow v$。

**证明**：

我们对转换判断进行归纳，证明如果 $e$ 能转换为 $e_0$，且 $e_0 \Downarrow v$，那么 $e$ 也可以直接求值为 $v$。例如，考虑以下转换规则：

$$
plus(e_1; e_2) \xrightarrow{} plus(e'_1; e_2)
$$
其中 $e_1 \xrightarrow{} e'_1$。假设 $plus(e'_1; e_2) \Downarrow v$，即 $e'_1 \Downarrow \text{num}[n_1]$ 且 $e_2 \Downarrow \text{num}[n_2]$，并且 $n_1 + n_2 = n$ 且 $v = \text{num}[n]$。

根据归纳假设，$e_1 \Downarrow \text{num}[n_1]$，因此可以推导出 $plus(e_1; e_2) \Downarrow \text{num}[n]$，满足所需的条件。

**其他情况** 的处理也是通过类似的归纳步骤进行。

### 总结

通过上述证明，我们建立了 **结构动态** 和 **求值动态** 之间的等价性：
- **从求值动态到结构动态**：每个求值动态中的表达式 $e$ 的求值判断可以转化为结构动态中的多步转换过程。
- **从结构动态到求值动态**：如果 $e$ 能通过结构动态多步转换得到一个值 $v$，那么在求值动态中，$e$ 也能直接求值为 $v$。

### 关键点总结
- **结构动态** 详细记录了表达式的逐步执行过程，而**求值动态** 仅关注初始状态和最终状态。
- 两者在理论上是等价的，结构动态的多步转换可以通过求值动态的归纳证明其正确性，反之亦然。
- 这种等价性在编程语言的设计和实现中具有重要意义，确保了不同求值方式之间的一致性。

### ---------------------------------

### 详解：7.3 Type Safety, Revisited

在本节中，我们重新审视了 **类型安全性** 的概念。之前的 **定理 6.1** 表明：如果语言同时满足 **保存性（preservation）** 和 **进展性（progress）**，则该语言是安全的。然而，这种类型安全性的定义依赖于 **结构动态（structural dynamics）**。现在的问题是：如果我们使用的是 **求值动态（evaluation dynamics）**，而不是结构动态，是否还可以定义和证明类型安全性？

### **类型安全与求值动态**

在使用 **求值动态** 时，证明 **类型安全性** 遇到了一些挑战。虽然我们可以证明类似于 **保存性** 的性质，但对于 **进展性**，求值动态并没有明确的对应。

#### **保存性与求值动态**

在求值动态下，保存性可以被重新表述为：**如果表达式 $e$ 能够求值为值 $v$ 且 $e : \tau$，那么 $v : \tau$**。这可以通过对求值规则的归纳证明。但是，对于进展性，问题就更加复杂。

#### **进展性问题**

进展性的核心思想是：**一个良类型的表达式不会“卡住”**，即每个良类型的表达式要么是值，要么可以进一步执行。然而，如果我们尝试在求值动态的框架下表达进展性，我们可能会被诱导去认为 **每个良类型的表达式都可以求值为某个值**，即 $e : \tau \implies e ⇓ v$。虽然这种性质对 $L\{num\ str\}$ 是成立的，但它要求所有表达式最终都会得到一个值，这实际上是更强的要求，而不仅仅是进展性。

例如，如果我们扩展 $L\{num\ str\}$，允许表达式产生错误（如 **除以零** 的情况），或者允许非终止的表达式，那么这种强求值的性质将不再成立。尽管如此，**进展性** 依然有效，因为进展性只要求表达式要么是值，要么可以进一步执行，而不要求它最终一定能求值为某个具体值。

### **动态类型错误检查**

一种可能的解决方案是通过动态检查显式地捕捉 **运行时类型错误**，从而保证良类型的程序不会出现这些错误。我们可以通过定义一个判断 **$e⇑$**，表示表达式 $e$ 在执行时会出现问题（go wrong）。“go wrong” 表示类型错误的所有可能情况，且这些错误通过一组规则来明确规定。

#### **规则示例**
以下是一些典型的 **go wrong** 判断规则：
- 如果尝试将字符串作为加法操作的一个操作数，则表示错误：
  $$
  \text{plus}(\text{str}[s]; e_2) ⇑
  $$
- 如果第一个操作数是值，但第二个操作数是字符串，加法操作也会出错：
  $$
  e_1 \ \text{val} \quad \text{plus}(e_1; \text{str}[s]) ⇑
  $$

这些规则确保了我们明确捕捉了在运行时可能出现的所有类型错误。

### **定理 7.5**

为了证明这个概念，我们可以提出以下定理：

**定理 7.5**：**如果 $e⇑$，则不存在 $\tau$ 使得 $e : \tau$**。

这意味着，如果某个表达式在运行时出错，那么它必定是非良类型的。这个证明可以通过对规则 $7.3$ 的归纳进行。比如，**规则 (7.3a)** 中，$str[s] : str$，因此 $\text{plus}(\text{str}[s]; e_2)$ 是不类型正确的。

**推论 7.6**：如果 $e : \tau$，那么 $e ⇑$ 是不成立的。

这个推论表明，良类型的表达式永远不会在运行时产生类型错误（即 go wrong）。

### **方法论上的弱点**

虽然我们可以通过定义 $e⇑$ 来证明良类型的程序不会出现动态类型错误，但这种方法存在一些明显的弱点：
- 我们必须显式定义哪些表达式会产生动态错误，虽然这些错误实际上在良类型的程序中不会出现。这增加了不必要的复杂性。
- 更重要的是，如果我们在定义 $e⇑$ 的过程中遗漏了一些错误检查，定理仍然可能是有效的，但并不能保证所有的类型错误都得到了适当处理。

相比之下，使用 **结构动态** 的好处在于，它并没有为非良类型的表达式规定任何行为。因此，任何不良类型的表达式都会自动“卡住”，不需要显式的错误处理。**进展定理** 则确保了所有这种不良类型的情况都被排除在外。

### **结论**

虽然我们可以在求值动态的框架下探讨类型安全性，但这种方式需要额外的错误处理规则，显得更加复杂和冗长。而使用 **结构动态** 则能够更自然地处理类型错误问题，并且更加简洁有效。因此，类型安全性的定义在结构动态中显得更为直观和强大。

### ---------------------------------

### 详解：Theorem 7.5 and Corollary 7.6

**定理 7.5** 试图通过证明 **e ⇑**（表达式执行时发生错误）与 **e : τ**（表达式有某种类型）是互斥的，来说明类型系统与运行时错误之间的关系。具体来说：

**定理 7.5**：**如果 $e ⇑$，那么不存在 $\tau$ 使得 $e : \tau$**。这意味着，如果一个表达式在执行时会产生错误，那么该表达式就不可能是类型正确的。

证明：该定理的证明是基于对 **规则 (7.3)** 的规则归纳进行的。我们考察每条规则，例如，在 **规则 (7.3a)** 中，字符串 $str[s]$ 的类型为 $str$，但是 $plus(str[s]; e2)$ 却是错误的，因为加法运算不能应用于字符串，因此这个表达式是 **类型不正确** 的。类似的分析适用于其他 **规则 (7.3)**。

### **推论 7.6**：如果 $e : τ$，则 $e ⇑$ 不成立。这意味着：**良类型的表达式不会出现运行时错误**。

### **方法论上的问题**

尽管 **定理 7.5** 和 **推论 7.6** 成立，但这种方法依赖于定义 **$e ⇑$** 来捕捉所有可能的运行时错误。这带来了两个主要问题：

1. **定义繁琐**：为了证明良类型程序不会出错，我们不得不定义哪些表达式会出错。这增加了系统的复杂性，尽管这些错误在良类型程序中根本不会出现。
   
2. **遗漏检查的风险**：如果我们在定义 **$e ⇑$** 时遗漏了一些错误检查，定理 7.5 仍然有效，但我们无法确保涵盖了所有可能的错误。换句话说，这种方法无法保证我们处理了每一种类型错误。

与此相比，**结构动态（structural dynamics）** 有一个显著的优势：它不为 **类型错误** 的表达式定义任何行为。这意味着，任何 **不良类型的表达式** 都会“卡住”（stuck），无需显式定义错误检查。通过 **进展定理**，我们可以排除所有这些类型错误的情况。这使得结构动态能够更自然地捕捉类型错误，并且证明过程也更加简洁和直接。

### **总结**

- **定理 7.5** 和 **推论 7.6** 提供了一种通过定义 **运行时错误** 来说明类型安全性的方法，但这种方法冗长且复杂。
- **结构动态** 提供了一个更为简洁的方法，它不为不良类型的表达式规定行为，而是通过 **进展定理** 保证良类型程序不会卡住。

### ---------------------------------

在讨论**类型安全性**时，**保存性**（preservation）和**进展性**（progress）是两个核心性质。根据**定理 6.1**，如果某种编程语言同时满足这两种性质，它就被认为是类型安全的。而这个定理的证明通常依赖于**结构动态**（structural dynamics）的语义描述方式。然而，问题是：如果我们采用**求值动态**（evaluation dynamics）而不是结构动态，是否仍然可以定义和证明类型安全性？

答案是**可以的**，但我们需要重新理解求值动态如何与类型安全性相关联。下面我将详细解释如何在**求值动态**下定义和证明类型安全性。

### 1. **结构动态与类型安全性**

在结构动态中，程序的执行通过一组明确的推导规则逐步描述。这些推导规则构成了语言的操作语义，通过定义如何从一个程序状态演化到下一个状态来描述程序的行为。

**类型安全性**的证明依赖于两条核心性质：

- **进展性** (Progress)：如果一个表达式类型正确，那么它要么是一个值，要么可以进一步演化。
- **保持性** (Preservation)：如果一个表达式类型正确，并且它可以演化为另一个表达式，那么新表达式的类型也必须保持一致。

在结构动态的语义中，这些性质是通过分析表达式的结构，基于语法规则来证明的。每个语法构造子都有对应的推导规则，因此可以依次证明表达式的演化过程和类型的保持。

### 2. **求值动态与类型安全性**

**求值动态**（evaluation dynamics）描述的是程序如何在执行过程中**计算出值**。它的侧重点不同于结构动态：它更关心表达式的计算顺序和实际求值的过程，而不是表达式结构如何被简化。因此，求值动态更直接与**运行时**的计算和求值过程相关。

尽管求值动态的焦点不同，但我们仍然可以在求值动态下定义和证明类型安全性。核心思路在于：

1. **进展性**：在求值动态下，进展性意味着一个**类型正确的程序**要么是一个已经求得的值（即已经完成求值），要么可以通过求值规则继续计算，而不会陷入无法继续的状态。
2. **保持性**：保持性在求值动态中的含义没有变化，它仍然要求一个类型正确的表达式在求值后其类型保持不变。

### 3. **求值动态下的类型安全性证明**

在求值动态下，我们同样可以通过证明进展性和保持性来证明类型安全性。下面逐步分析这两个性质在求值动态中的表现：

#### 3.1 **进展性**在求值动态中的表现

**进展性**保证程序不会卡住。如果一个表达式类型正确，则该表达式要么是一个值（即求值完成），要么它可以继续进行求值。进展性可以描述为：

- 如果 $e$ 是一个类型正确的表达式，则：
  - 要么 $e$ 是一个值；
  - 要么存在 $e'$，使得 $e \rightarrow e'$，即 $e$ 可以通过求值动态规则进一步求值。

在求值动态中，这表示每个类型正确的表达式在计算过程中要么能继续演化为另一个表达式（直到得到最终值），要么已经是一个值。

#### 3.2 **保持性**在求值动态中的表现

**保持性**要求类型在程序执行过程中保持一致。即如果一个表达式 $e$ 类型为 $T$，并且 $e$ 能够演化为 $e'$，则 $e'$ 也必须具有类型 $T$。这可以用以下公式表示：

- 如果 $e : T$ 并且 $e \rightarrow e'$，那么 $e' : T$。

在求值动态下，保持性要求程序在求值的每一步中，类型必须保持一致。这一点与结构动态中的保持性定义是一致的，求值动态下的保持性仍然是保证程序在执行过程中不会出现类型错误的关键。

### 4. **类型安全性在求值动态下的证明方法**

为了证明某种语言在求值动态下是类型安全的，我们可以按以下步骤进行：

1. **证明进展性**：我们需要逐步验证，在求值过程中，所有类型正确的表达式要么是值，要么能够继续通过求值规则进行演化。
2. **证明保持性**：我们需要逐步验证，在每一步求值过程中，表达式的类型保持不变。

通过这两种性质的证明，尽管我们使用了求值动态而不是结构动态，但依然可以确保程序的类型安全性。

#### 4.1 **进展性证明示例**：

假设我们有一个简单的整数加法运算，在求值动态下，我们需要证明类型正确的加法表达式能够继续求值。例如，对于表达式 `2 + 3`：

- 该表达式类型正确，因为 `2` 和 `3` 都是整数。
- 根据求值规则，`2 + 3` 可以进一步计算为 `5`，这表明求值能够继续进行，进展性成立。

#### 4.2 **保持性证明示例**：

在求值动态下的保持性证明，我们要确保在每一步求值过程中，表达式的类型保持一致。例如，对于表达式 `2 + 3`：

- 在初始状态下，`2 + 3` 是一个 `int` 类型的表达式。
- 通过求值规则，`2 + 3` 求值为 `5`，而 `5` 的类型仍然是 `int`，保持性成立。

### 5. **结构动态与求值动态的关系**

尽管**结构动态**和**求值动态**的角度不同，二者仍然是相辅相成的。在类型安全性的证明中：
- **结构动态**侧重于描述程序的**语法结构**如何演化，并通过分析结构规则来证明类型安全性。
- **求值动态**则更侧重于描述**运行时的计算过程**，通过分析求值规则来证明类型安全性。

二者的核心目标都是保证类型正确的程序在执行时不会出现类型错误。换句话说，不论采用结构动态还是求值动态，只要能证明**进展性**和**保持性**，就能证明程序是类型安全的。

### 6. **总结**

- **类型安全性**可以通过证明两大核心性质：**进展性**和**保持性**来保障。
- **结构动态**和**求值动态**是两种描述程序行为的方式，尽管角度不同，但都可以用于证明类型安全性。
- **求值动态**下的类型安全性同样可以通过证明进展性（程序能够继续执行或返回值）和保持性（类型在每步求值过程中保持一致）来保障。
- 最终，不论使用结构动态还是求值动态，只要能够证明进展性和保持性，编程语言的类型安全性就可以得到保证。

因此，尽管类型安全性定理通常依赖于**结构动态**，但使用**求值动态**同样可以定义和证明类型安全性。

### ---------------------------------

要在**求值动态**（evaluation dynamics）下证明**类型安全性**，我们仍然需要通过**进展性**（progress）和**保持性**（preservation）这两个核心性质来证明。在**结构动态**下，这些性质是通过语法结构的推导来证明的，而在求值动态下，我们则需要基于**程序的运行时行为**来进行证明。

接下来，我将详细说明如何通过**求值动态**来定义和证明类型安全性，并给出具体的方法。

### 1. **概述**

我们知道，**类型安全性**依赖于两个性质：
- **进展性**：如果表达式是类型正确的，则该表达式要么是一个值，要么可以进一步演化（求值）。
- **保持性**：如果表达式是类型正确的，并且它可以进行一步求值，那么求值后的表达式仍然是类型正确的。

在求值动态下，我们的任务是定义如何基于**运行时求值**过程来证明这两个性质。我们会基于**运行时的计算规则**而不是单纯的语法结构来推导程序的类型行为。

### 2. **求值动态下的类型安全性证明框架**

#### 2.1 **定义进展性**

在求值动态中，**进展性**意味着如果一个表达式是类型正确的，那么它要么是一个**值**，要么可以通过**运行时的求值规则**进一步求值。这是一个动态的性质，表示程序在执行过程中不会“卡住”。

具体形式化定义如下：
- **进展性**：如果表达式 $e$ 是类型正确的，即 $\Gamma \vdash e : T$，那么要么：
  1. $e$ 是一个**值**（求值已完成），
  2. 或者存在 $e'$，使得 $e \rightarrow e'$（通过运行时求值规则，$e$ 可以演化为 $e'$）。

#### 2.2 **定义保持性**

**保持性**（preservation）表明，如果一个表达式 $e$ 是类型正确的，并且可以演化为另一个表达式 $e'$（即 $e \rightarrow e'$），那么 $e'$ 仍然是类型正确的，并且它的类型保持不变。这一性质确保在程序运行时，类型不会发生变化。

具体形式化定义如下：
- **保持性**：如果表达式 $e$ 类型正确，即 $\Gamma \vdash e : T$，并且 $e$ 可以通过运行时的求值规则演化为 $e'$（即 $e \rightarrow e'$），那么 $e'$ 也是类型正确的，即 $\Gamma \vdash e' : T$。

### 3. **具体的证明步骤**

为了在求值动态下证明类型安全性，我们需要遵循以下步骤：

#### 步骤 1：**定义语言的求值规则**

首先，我们需要明确语言的求值规则。这包括定义**运行时环境**（evaluation environment）以及表达式的**求值顺序**。常见的求值规则包括以下几种：

- **值**（Value）：程序中的值是已经计算完成的表达式，不需要进一步求值。
  例如，整数常量、布尔值或函数值。
  
- **应用规则**（Application Rule）：如果我们有一个函数应用或操作符应用，需要明确它们的求值方式。
  例如，对于加法表达式 $e1 + e2$，我们可以定义求值顺序：
  - 首先求值 $e1$，然后求值 $e2$，最后进行加法运算。

  ```haskell
  e1 + e2 \rightarrow e1' + e2  （如果 e1 可以求值为 e1'）
  ```

- **函数应用**：对于函数应用 $f(e)$，首先需要对 $e$ 求值，再对函数体进行应用。

  ```haskell
  (fun x => e1) e2 \rightarrow [e2 / x] e1  （将参数替换为实际的值）
  ```

这些求值规则定义了表达式如何从一个状态演化到下一个状态。

#### 步骤 2：**证明进展性**

为了证明进展性，我们需要对每个类型正确的表达式逐一证明，要么它已经是一个值，要么它可以通过求值规则进一步演化。进展性的证明通常基于表达式的结构进行归纳推理。

##### 示例：整数加法的进展性证明

假设我们有一个简单的语言，包含整数和加法。我们需要证明：

- 如果表达式 $e1 + e2$ 类型正确，则该表达式可以进一步求值，或者它已经是一个值。

证明步骤：

1. 假设表达式 $e1 + e2$ 是类型正确的，即 $\Gamma \vdash e1 + e2 : int$。
2. 根据类型推导规则，$e1$ 和 $e2$ 都必须是类型为 `int` 的表达式。
3. 如果 $e1$ 和 $e2$ 都是整数常量，则 $e1 + e2$ 可以立即进行计算，进而得到一个整数值（值的形式 $n$）。
4. 如果 $e1$ 或 $e2$ 不是常量，则根据求值规则，它们可以继续演化为更简单的表达式 $e1'$ 和 $e2'$，然后 $e1' + e2'$ 可以进一步求值。

通过以上分析，我们证明了整数加法表达式的进展性：要么它是一个值，要么它可以继续进行求值。

#### 步骤 3：**证明保持性**

保持性证明表明，程序在求值过程中类型不会发生变化。即，如果一个类型正确的表达式 $e$ 求值为 $e'$，则 $e'$ 也是类型正确的。

##### 示例：整数加法的保持性证明

我们继续使用整数加法作为例子。假设表达式 $e1 + e2$ 是类型正确的，并且通过求值演化为 $e1' + e2'$，我们需要证明：

- 如果 $e1 + e2$ 是类型为 `int` 的表达式，则 $e1' + e2'$ 也是类型为 `int`。

证明步骤：

1. 假设 $\Gamma \vdash e1 + e2 : int$，这意味着 $e1$ 和 $e2$ 的类型都是 `int`。
2. 假设 $e1$ 可以演化为 $e1'$，并且根据保持性，$e1'$ 的类型仍然是 `int$。
3. 同理，$e2$ 可以演化为 $e2'$，并且 $e2'$ 的类型仍然是 `int`。
4. 因此，根据类型推导规则，$e1' + e2'$ 的类型仍然是 `int`。

这表明在每一步求值过程中，类型始终保持不变，从而证明了保持性。

### 4. **求值动态下的类型安全性定理**

通过对**进展性**和**保持性**的证明，我们可以得到求值动态下的**类型安全性定理**：

- **定理（类型安全性）**：如果表达式 $e$ 在上下文 $\Gamma$ 中是类型正确的（即 $\Gamma \vdash e : T$），并且 $e$ 可以通过求值动态规则进一步演化（即 $e \rightarrow e'$），那么：
  1. 要么 $e$ 是一个值；
  2. 要么存在 $e'$，使得 $e \rightarrow e'$，并且 $\Gamma \vdash e' : T$。

### 5. **总结**

1. **求值动态下的类型安全性证明**依然基于两个核心性质：**进展性**和**保持性**。
2. **进展性**在求值动态下表明类型正确的表达式要么是一个值，要么可以进一步求值。
3. **保持性**在求值动态下表明类型在求值过程中不会改变。
4. 我们通过定义语言的求值规则，对每个表达式逐步证明其类型行为，最终确保程序在执行时不会发生类型错误。

这种求值动态下的证明方法与结构动态相辅相成，确保了程序执行过程中的类型安全性。



>  感觉废话较多

### ---------------------------------

### 详解：7.4 **Cost Dynamics**

**成本动态（Cost Dynamics）** 是在 **评价动态（Evaluation Dynamics）** 基础上增加了对计算步骤的度量，用来描述程序执行过程中所需的步骤数。具体来说，评价判断的形式是：

$$
e ⇓_k v
$$

其中 $e$ 是一个表达式，$v$ 是 $e$ 评价的结果，而 $k$ 表示从表达式 $e$ 评价到结果 $v$ 所需要的步数。

### 公式解析

#### 1. **规则 (7.4a):**
$$
\frac{}{\text{num[n]} ⇓_0 \text{num[n]}}
$$

该规则表示，当一个表达式是一个数值 $num[n]$ 时，它在 $0$ 步内直接评价为它自身 $num[n]$。**$k = 0$** 表示不需要任何额外的计算步骤，这是因为数值已经是最终值。

#### 2. **规则 (7.4b):**
$$
\frac{\text{e1 ⇓}_{k1} \text{num[n1]} \quad \text{e2 ⇓}_{k2} \text{num[n2]}}{\text{plus(e1;e2)} ⇓_{k1+k2+1} \text{num[n1 + n2]}}
$$

该规则处理加法运算。解释如下：

- $e1$ 和 $e2$ 是两个表达式，分别在 $k_1$ 和 $k_2$ 步后评价为数值 $num[n1]$ 和 $num[n2]$。
- 加法操作需要额外的一步，因此总的计算步数为 **$k1 + k2 + 1$**。
- 结果是 $num[n1 + n2]$，即这两个数的和。

#### 3. **规则 (7.4c):**
$$
\frac{}{\text{str[s]} ⇓_0 \text{str[s]}}
$$

此规则与 **(7.4a)** 类似，但它适用于字符串。字符串 $str[s]$ 在 $0$ 步内评价为自身。

#### 4. **规则 (7.4d):**
$$
\frac{\text{e1 ⇓}_{k1} \text{str[s1]} \quad \text{e2 ⇓}_{k2} \text{str[s2]}}{\text{cat(e1;e2)} ⇓_{k1+k2+1} \text{str[s1 ˆ s2]}}
$$

该规则描述字符串的连接操作。解释如下：

- $e1$ 和 $e2$ 是两个字符串表达式，分别在 $k1$ 和 $k2$ 步后评价为字符串 $str[s1]$ 和 $str[s2]$。
- 字符串连接操作需要额外的一步，因此总的计算步数为 **$k1 + k2 + 1$**。
- 结果是连接后的字符串 $str[s1 ˆ s2]$。

#### 5. **规则 (7.4e):**
$$
\frac{[e1/x]e2 ⇓_{k2} v2}{\text{let(e1; x.e2)} ⇓_{k2+1} v2}
$$

这个规则描述了 `let` 表达式的求值，**按名求值（by-name evaluation）**：

- 在 `let` 表达式中，将 $e1$ 绑定到 $x$ 并替换到 $e2$ 中。
- 表达式 $[e1/x]e2$ 需要 $k2$ 步计算，结果为 $v2$。
- 绑定操作需要额外的一步，所以总步数为 **$k2 + 1$**。

#### 6. **规则 (7.5) (按值求值)**
$$
\frac{e1 ⇓_{k1} v1 \quad [v1/x]e2 ⇓_{k2} v2}{\text{let(e1; x.e2)} ⇓_{k1+k2+1} v2}
$$

该规则描述了 `let` 表达式的 **按值求值（by-value evaluation）**：

- 先将 $e1$ 计算得到值 $v1$，需要 $k1$ 步。
- 然后将 $v1$ 替换进 $e2$，并进行 $k2$ 步的计算。
- 这个过程总共需要 **$k1 + k2 + 1$** 步，最后结果为 $v2$。

### **定理 7.7：**
$$
e ⇓_k v \iff e 7→_k v
$$

定理 7.7 声明了 **评价动态** 和 **结构动态** 在步数 $k$ 上的等价性，表示表达式 $e$ 在 $k$ 步内通过两种方式（评价动态和结构动态）都可以得到相同的结果。

#### 证明步骤：
1. **从左到右**：通过对 **成本动态** 的规则归纳，逐步推导每一个计算步骤的等价性。
2. **从右到左**：对步数 $k$ 进行归纳，结合结构动态的定义证明其等价性。

### ---------------------------------

在 7.5 节的 **Notes** 中，讨论了评价动态（evaluation dynamics）与类型规则之间的结构相似性，以及引入成本动态（cost dynamics）的背景。

### 详解：

#### 1. **评价动态与类型规则的相似性**
- **背景**：评价动态和类型规则在结构上有相似之处，这种相似性最早是在 **Standard ML** 定义中引入的。
- **评价动态的优势**：评价动态直接定义了程序与其结果之间的关系。也就是说，它描述了程序如何从输入逐步执行，最终得到输出。
- **劣势**：虽然评价动态能直观地描述程序的执行结果，但它忽略了执行过程的详细步骤，这使得它不如结构动态适合用于元理论（metatheory）的证明。元理论往往需要深入了解计算的每一步细节，而评价动态略过了这些细节。

#### 2. **成本动态**
- **引入成本动态的原因**：成本动态是为了解决评价动态不能直接推导复杂度的缺陷。通过引入成本动态，我们可以在评价过程中加上一个步数计量（例如计算花费的步骤数），从而能够分析程序的时间复杂度。
- **Blelloch 和 Greiner 的贡献**：成本动态这一概念由 **Blelloch 和 Greiner** 于 1996 年引入，最初是为了研究并行性问题。通过这种方法，他们能够衡量并行程序的执行成本，这在并行计算的研究中非常重要。

总结来说，评价动态在描述程序结果方面非常直观，但为了深入研究程序的执行过程和复杂度，尤其是在并行计算领域，成本动态提供了更为精细的工具。


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------
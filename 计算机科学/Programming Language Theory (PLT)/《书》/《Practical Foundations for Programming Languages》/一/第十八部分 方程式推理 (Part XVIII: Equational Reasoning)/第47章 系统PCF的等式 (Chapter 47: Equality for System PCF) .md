[toc]



### 47. **PCF 系统的等价性 (Equality for System PCF)**

本章主要探讨了 **PCF 系统 (Programming Computable Functions, 可编程计算函数)** 的**观察等价 (Observational Equivalence)** 理论。PCF 是一种简单的、带有递归和自然数的函数式语言。本章讨论的焦点在于自然数类型的**急切求值 (Eager Evaluation)**，与第 46 章类似的方式发展了观察等价的理论，但由于存在**一般递归 (General Recursion)**，证明变得更加复杂。

证明的核心依赖于**可接受关系 (Admissible Relation)** 的概念，它允许使用**不动点归纳 (Fixed Point Induction)** 进行证明。

---

### 47.1 **观察等价 (Observational Equivalence)**

**观察等价 (Observational Equivalence)** 是指两个程序在所有上下文中表现一致，即对于任意输入，它们的输出都相同。在 PCF 系统中，观察等价用于判断两个程序是否可替代。

#### 解释：
- **上下文 (Context)**：表示程序运行的环境，包含变量、函数和其他表达式。我们通过将程序放入不同的上下文中，观察其行为是否一致。
- 如果两个程序在所有上下文下都表现一致，即它们的输出在每个输入下都相同，那么它们是观察等价的。

---

### 47.2 **逻辑等价 (Logical Equivalence)**

**逻辑等价 (Logical Equivalence)** 是一种更形式化的等价方式。两个程序在同样的逻辑推理框架下，通过相同的逻辑规则可以证明是等价的。

#### 解释：
- **逻辑推理框架**：使用类型系统和逻辑规则来判断程序的等价性。
- 逻辑等价通常是通过证明两个表达式在相同输入下具有相同的输出，并且遵循相同的推理步骤。

---

### 47.3 **逻辑等价与观察等价的统一 (Logical and Observational Equivalence Coincide)**

在本节中，我们证明了在 PCF 系统中，**逻辑等价**和**观察等价**是等价的。这意味着，如果两个程序在逻辑上是等价的，那么它们在所有上下文中也是观察等价的；反之亦然。

#### 解释：
- 逻辑等价和观察等价的统一性表明了这两种等价的概念在 PCF 系统中是相互一致的。即逻辑上可证明等价的程序，在实际执行中也是等价的。
- 该定理的证明依赖于不动点归纳法，因为 PCF 系统包含了递归函数。

---

### 47.4 **紧致性 (Compactness)**

**紧致性 (Compactness)** 是指系统中的每个表达式都可以通过有限的步骤进行推理和证明。

#### 解释：
- 在递归程序的上下文中，紧致性确保了即使程序可能具有无限的递归结构，我们仍然可以通过有限的推导来证明它们的等价性。
- 紧致性允许我们只考虑有限的上下文来验证观察等价，而不需要对所有可能的递归进行穷尽验证。

---

### 47.5 **惰性自然数 (Lazy Natural Numbers)**

在本节中，讨论了 **惰性求值 (Lazy Evaluation)** 的自然数。惰性求值意味着程序的执行将推迟，直到结果被真正需要时才进行计算。与急切求值不同，惰性求值的程序可以表示无穷结构。

#### 解释：
- **惰性求值**：函数调用时不立即计算，而是当结果被真正需要时才进行求值。这种技术常用于处理无穷数据结构，例如无穷序列。
- 在惰性自然数的上下文中，表达式可能不会立即计算，而是会生成一个惰性的计算链条，直到需要时才被展开。

---

### 47.6 **备注 (Notes)**

本节主要补充了关于 PCF 系统等价性的额外讨论，特别是关于不动点归纳、紧致性以及惰性求值的进一步解释。PCF 系统作为一种递归函数式语言，其等价性证明依赖于递归和不动点理论，这些概念在本章进行了详细讨论。

---

### **总结**：

本章通过对 **PCF 系统** 的观察等价和逻辑等价进行了详细分析，证明了这两种等价性的统一性。特别是由于递归函数的存在，证明需要使用不动点归纳法。紧致性保证了我们可以通过有限步骤推导出等价性，而惰性求值提供了处理无穷数据结构的机制。

### ---------------------------------

### 47.1 **观察等价 (Observational Equivalence)**

**观察等价** (Observational Equivalence) 是一种判断两个程序在所有上下文中表现是否一致的等价性。在 PCF 系统中，观察等价的定义与第 46 章类似，但需要考虑到 **非终止** (non-termination) 的可能性。

#### **定义 (Definition)**：
**Kleene 等价 (Kleene Equivalence)** 和 **观察等价** 都与第 46 章相似，只是针对 PCF 系统的递归性和可能的非终止性做了一些修改。

---

#### **Kleene 等价的定义 (Definition 47.1):**
**Kleene 等价** 判断两个程序在执行时是否具有相同的行为（包括终止和非终止情况）。具体定义如下：

- **Kleene 等价**，记作 $e \sim_2 e'$，当且仅当对于任意的 $n \geq 0$，程序 $e$ 和 $e'$ 同时能终止并计算出结果 $n$，或者两者都无法终止。
- 用符号表示，如果 $e \longrightarrow^* n$ 当且仅当 $e' \longrightarrow^* n$，则称 $e \sim_2 e'$。

#### **解释**：
- 这里的 $e \longrightarrow^* n$ 表示程序 $e$ 经过若干步执行后最终计算出结果 $n$。
- 如果 $e$ 和 $e'$ 都无法终止（即都**发散**），则它们仍然被视为 Kleene 等价。

#### **性质**：
- **Kleene 等价** 是一个 **等价关系** (equivalence relation)，即它是自反的、对称的和传递的。
- 它在**逆向求值** (converse evaluation) 下是封闭的，即如果 $e \sim_2 e'$ 并且 $d \longrightarrow e$，则 $d \sim_2 e'$。

---

#### **观察等价的定义 (Definition 47.2)**：
我们说 $\Gamma \vdash e : \tau$ 和 $\Gamma \vdash e' : \tau$ 是 **观察等价 (Observational Equivalence)**，或**上下文等价 (Contextual Equivalence)**，当且仅当对于任意的程序上下文 $C : (\Gamma * \tau) \to (\emptyset * \text{nat})$，有 $C\{e\} \sim_2 C\{e'\}$。

#### **解释**：
- **程序上下文** $C$ 是一种将表达式插入到特定位置（称为“洞”）的框架，它可以观察表达式的行为。上下文可以用于检查表达式在特定环境下的输出。
- 如果 $e$ 和 $e'$ 在所有上下文中都表现一致，那么它们是观察等价的。

---

### **定理 (Theorem 47.3):** 观察等价是最粗的、一致的全等关系 (Observational equivalence is the coarsest consistent congruence)

#### **解释**：
- 该定理说明观察等价是一致的全等关系，这意味着：
  1. **一致性**：如果两个程序在某个上下文中是等价的，那么它们在所有上下文中也是等价的。
  2. **最粗等价**：观察等价是确保程序行为一致的最弱条件。

- 定理的证明与定理 46.6 的证明类似，主要是通过递归定义来证明观察等价满足一致性和传递性。

---

### **引理 (Lemma 47.4): 替换与功能性 (Substitution and Functionality)**

**引理 47.4** 指出，在进行变量替换后，等价性仍然保持稳定。

$$
\frac{
\Gamma \vdash e \sim= e' : \tau \quad \gamma : \Gamma
}{
\gamma^{\hat{}}(e) \sim_\tau \gamma^{\hat{}}(e')
}
$$

此外，如果 $\gamma \sim_\Gamma \gamma'$，那么：

$$
\gamma^{\hat{}}(e) \sim_\tau \gamma'^{\hat{}}(e) \quad \text{且} \quad \gamma^{\hat{}}(e') \sim_\tau \gamma'^{\hat{}}(e')
$$

#### **符号解释**：
- $\gamma$ 表示上下文 $\Gamma$ 的替换映射。
- $\gamma^{\hat{}}(e)$ 表示在表达式 $e$ 中使用 $\gamma$ 替换其中的变量。

#### **解释**：
- **替换的等价性保持**：如果 $e$ 和 $e'$ 在上下文 $\Gamma$ 下是等价的，并且 $\gamma$ 是 $\Gamma$ 的替换映射，那么将 $e$ 和 $e'$ 中的变量替换为 $\gamma$ 中相应的值，结果仍然是等价的。
- **功能性**：如果两个替换 $\gamma$ 和 $\gamma'$ 在 $\Gamma$ 上是等价的，那么使用它们替换表达式 $e$ 和 $e'$ 后，结果仍然是等价的。

#### **证明**：
该引理的证明与第 46 章的 **引理 46.7** 类似，使用递归定义和不动点归纳来处理递归结构的替换问题。

---

### **总结**：
- **Kleene 等价** 是 PCF 系统中处理非终止行为的一种方法，它确保了即使程序可能发散，等价性仍然可以定义。
- **观察等价** 进一步扩展了这种等价性，将程序在所有上下文中的行为作为判断等价的依据。
- **替换的稳定性** 和 **功能性** 确保了在进行变量替换和递归定义时，等价性仍然能够保持。

### ---------------------------------

### 47.2 **逻辑等价 (Logical Equivalence)**

**逻辑等价 (Logical Equivalence)** 是一种形式化的方式，用于判断两个程序是否在给定的类型系统下表现一致。它通过递归定义，确保两个程序在所有类型下的行为是一致的。逻辑等价的定义类似于第 46 章中的定义，但在 PCF 系统中，**Kleene 等价 (Kleene Equivalence)** 的定义考虑了程序的**非终止 (Non-termination)** 情况。

---

#### **定义 (Definition 47.5):**

**逻辑等价 (Logical Equivalence)** 对于闭合表达式的定义如下：
- 对于自然数类型 $\text{nat}$，如果 $e \sim_2 e'$（即 Kleene 等价），那么 $e \sim_{\text{nat}} e'$。
  
  $$ e \sim_{\text{nat}} e' \text{ 当且仅当 } e \sim_2 e' $$

- 对于函数类型 $\tau_1 \to \tau_2$，如果对于所有 $e_1 \sim_{\tau_1} e'_1$，都有 $e(e_1) \sim_{\tau_2} e'(e'_1)$，则 $e \sim_{\tau_1 \to \tau_2} e'$。
  
  $$ e \sim_{\tau_1 \to \tau_2} e' \text{ 当且仅当 } e_1 \sim_{\tau_1} e'_1 \Rightarrow e(e_1) \sim_{\tau_2} e'(e'_1) $$

#### **解释**：
- **自然数类型 (nat)**：两个自然数表达式如果 Kleene 等价（即它们能产生相同的数值，或者都无法终止），则它们在自然数类型下是逻辑等价的。
- **函数类型 (Function Types)**：如果两个函数在所有输入下都产生相同的输出（或都无法终止），则它们在函数类型下是逻辑等价的。

---

#### **逻辑等价在开放表达式上的扩展 (Extension to Open Terms)**

逻辑等价可以扩展到**开放表达式**，即那些包含自由变量的表达式。具体来说，定义 $\Gamma \vdash e \sim e' : \tau$ 的逻辑等价性如下：
- 若对于任意的替换 $\gamma$ 和 $\gamma'$，只要 $\gamma \sim_{\Gamma} \gamma'$，则有 $\hat{\gamma}(e) \sim_{\tau} \hat{\gamma}'(e')$。

#### **符号解释**：
- $\hat{\gamma}(e)$ 表示在表达式 $e$ 中使用替换 $\gamma$ 替换其自由变量。
- $\gamma \sim_{\Gamma} \gamma'$ 表示在上下文 $\Gamma$ 中，$\gamma$ 和 $\gamma'$ 是等价的。

#### **性质**：
- 通过类似于 **引理 46.9** 的证明，可以推导出逻辑等价是**对称的 (Symmetric)** 和**传递的 (Transitive)**，这意味着如果 $e \sim_{\tau} e'$，则 $e' \sim_{\tau} e$，并且如果 $e \sim_{\tau} e'$ 且 $e' \sim_{\tau} e''$，则 $e \sim_{\tau} e''$。

---

### **引理 47.6 (严格性 Strictness)**

如果 $e : \tau$ 和 $e' : \tau$ 都是**发散的 (Divergent)**，即它们都无法终止，那么它们在类型 $\tau$ 下是逻辑等价的。

#### **证明**：
使用对 $\tau$ 结构的归纳法证明：
- 如果 $\tau = \text{nat}$，则结论直接从 **Kleene 等价** 的定义得出，因为两个发散的表达式在 Kleene 等价下是等价的。
- 如果 $\tau = \tau_1 \to \tau_2$，则 $e(e_1)$ 和 $e'(e'_1)$ 都发散，因此根据归纳假设，$e(e_1) \sim_{\tau_2} e'(e'_1)$，这满足逻辑等价的要求。

---

### **引理 47.7 (逆向求值 Converse Evaluation)**

假设 $e \sim_{\tau} e'$，则：
- 如果 $d \longrightarrow e$，则 $d \sim_{\tau} e'$。
- 如果 $d' \longrightarrow e'$，则 $e \sim_{\tau} d'$。

#### **解释**：
- 这个引理表明，如果一个表达式 $d$ 通过若干步计算得到了 $e$，那么 $d$ 与 $e'$ 是逻辑等价的。反过来，如果 $d'$ 通过若干步计算得到了 $e'$，则 $e$ 与 $d'$ 是逻辑等价的。

#### **证明**：
这个引理的证明使用对类型 $\tau$ 的结构归纳法。如果 $\tau = \text{nat}$，则该结论直接来自 **Kleene 等价** 的定义。如果 $\tau = \tau_1 \to \tau_2$，则证明需要假设 $e \sim_{\tau} e'$，并且使用归纳法证明两个函数在同样的输入下产生相同的输出。

---

### **总结**：
- **逻辑等价** 为我们提供了一种通过递归定义和推理来证明两个程序等价的方式。它依赖于类型系统来判断程序是否表现一致。
- **Kleene 等价** 是 PCF 系统中判断程序发散或终止行为的基础，而 **逻辑等价** 则扩展了这种等价性，以涵盖函数类型和开放表达式。
- **严格性** 和 **逆向求值** 是证明递归程序和发散程序等价的重要工具。

### ---------------------------------

### 47.3 逻辑等价和观察等价的一致性 (Logical and Observational Equivalence Coincide)

在这一节中，讨论了 **逻辑等价** (Logical Equivalence) 和 **观察等价** (Observational Equivalence) 之间的一致性证明。这一证明依赖于**有界递归** (Bounded Recursion) 的概念。

---

### **有界递归 (Bounded Recursion)**

有界递归通过对 $m \geq 0$ 的归纳定义如下：
- 当 $m = 0$ 时，有界递归定义为一个发散的表达式：
  $$
  \text{fix}_0 x : \tau \text{ is } e = \text{fix } x : \tau \text{ is } x
  $$
  即，递归为发散时，类型 $\tau$ 的表达式只是递归到自身。

- 当 $m > 0$ 时，有界递归通过迭代替换展开递归 $m$ 次：
  $$
  \text{fix}_{m+1} x : \tau \text{ is } e = [\text{fix}_m x : \tau \text{ is } e / x] e
  $$
  这意味着对递归表达式展开 $m$ 次，随后发散。

**解释**：
- **有界递归** 模拟了递归函数的行为，递归次数受限于 $m$ 次。当 $m$ 增加时，递归展开更多次。$m = 0$ 时，表示表达式未递归而直接发散。随着 $m$ 增加，表达式递归展开越来越多，直到发散。

---

### **定理 47.8: 不动点归纳 (Fixed Point Induction)**

不动点归纳定理是有界递归的一个关键性质，它允许通过递归展开的次数来进行归纳推理：

#### **定理**：
假设 $x : \tau \vdash e : \tau$，如果对于所有 $m \geq 0$ 都有：
$$
\text{fix}_m x : \tau \text{ is } e \sim_{\tau} \text{fix}_m x : \tau \text{ is } e'
$$
那么可以得出：
$$
\text{fix } x : \tau \text{ is } e \sim_{\tau} \text{fix } x : \tau \text{ is } e'
$$

#### **解释**：
- 这个定理的核心思想是：如果在每一个递归展开层级上，$e$ 和 $e'$ 是等价的，那么它们的递归表达式也是等价的。
- 这需要用到**不动点归纳**，即通过递归展开次数逐步归纳，直到得出全局的等价性。

---

### **应用上下文 (Applicative Context)**

为了证明上述定理，需要引入**应用上下文 (Applicative Context)** 的概念：
- **应用上下文**可以是一个空洞 $\circ$ 或者是一个形如 $A(e)$ 的表达式，其中 $A$ 是应用上下文。

应用上下文的类型判断 $\Gamma \vdash A : \tau_0 \to \tau$ 是一般上下文类型判断的特例。定义应用上下文的**逻辑等价**：
1. $\circ \sim \circ : \tau_0 \to \tau_0$;
2. 如果 $A \sim A' : \tau_0 \to (\tau_2 \to \tau)$ 且 $e_2 \sim_{\tau_2} e'_2$，则有 $A(e_2) \sim A'(e'_2) : \tau_0 \to \tau$。

### **证明**：

通过对 $\tau$ 的结构进行归纳，如果 $A \sim A' : \tau_0 \to \tau$ 且对于所有 $m \geq 0$，$A\{ \text{fix}_m x : \tau_0 \text{ is } e \} \sim_{\tau} A'\{ \text{fix}_m x : \tau_0 \text{ is } e' \}$，则有：
$$
A\{ \text{fix } x : \tau_0 \text{ is } e \} \sim_{\tau} A'\{ \text{fix } x : \tau_0 \text{ is } e' \}
$$

#### **证明步骤**：

1. **自然数类型 (nat)**：
   - 假设 $A \sim A' : \tau_0 \to \text{nat}$ 且有上述等式成立。
   - 根据定义 47.5，我们需要证明：
     $$
     A\{ \text{fix } x : \tau_0 \text{ is } e \} \sim_2 A'\{ \text{fix } x : \tau_0 \text{ is } e' \}
     $$
   - 使用 Kleene 等价的推论和上下文推理，可以证明它们的等价性。

2. **函数类型 $\tau_1 \to \tau_2$**：
   - 假设 $e_1 \sim_{\tau_1} e'_1$，我们需要证明：
     $$
     A\{ \text{fix } x : \tau_0 \text{ is } e \}(e_1) \sim_{\tau_2} A'\{ \text{fix } x : \tau_0 \text{ is } e' \}(e'_1)
     $$
   - 通过将 $A(e_1)$ 和 $A'(e'_1)$ 代入，可以递归地证明它们在函数类型上的等价性。

### **总结**：
- **有界递归** 通过限制递归的展开次数，使得我们能够通过归纳法推导出递归表达式的等价性。
- **不动点归纳** 提供了一种推理递归计算的方式，允许我们在每个递归展开层级上证明递归表达式的等价性。
- **应用上下文** 用来处理上下文中的递归表达式，使得逻辑等价可以在不同的上下文中传递。

### ---------------------------------

### Lemma 47.9 (Reflexivity)

#### **引理内容：**
如果 $\Gamma \vdash e : \tau$，则 $\Gamma \vdash e \sim e : \tau$。  
这个引理证明了**反身性**(Reflexivity)，即任意表达式 $e$ 都和自身等价。

#### **证明思路：**
证明的核心思想是利用不动点递归 (Fixed-Point Induction) 以及有界递归 (Bounded Recursion) 来处理递归表达式的等价性。其方法与之前定理 46.13 的证明类似，但需要处理通用递归问题。

#### **证明过程：**

1. **问题陈述**：
   我们假设 $\Gamma \vdash \gamma \sim_{\Gamma} \gamma'$，需要证明：
   $$
   \text{fix } x : \tau \text{ is } \gamma(e) \sim_{\tau} \text{fix } x : \tau \text{ is } \gamma'(e)
   $$

2. **应用定理 47.8 (不动点归纳)**：
   根据定理 47.8，不动点归纳的关键在于对于所有 $m \geq 0$，证明以下等式：
   $$
   \text{fix}_m x : \tau \text{ is } \gamma(e) \sim_{\tau} \text{fix}_m x : \tau \text{ is } \gamma'(e)
   $$

3. **内层归纳：**
   我们对 $m$ 进行内层归纳：
   
   - 当 $m = 0$ 时，结果显然成立，因为两边的表达式都会发散，发散的表达式自反等价。
   - 假设对于 $m$ 成立，即：
     $$
     \text{fix}_m x : \tau \text{ is } \gamma(e) \sim_{\tau} \text{fix}_m x : \tau \text{ is } \gamma'(e)
     $$

4. **展开下一步递归**：
   我们需要证明 $m + 1$ 的情况。通过应用引理 47.7（逆向求值引理），我们只需要证明：
   $$
   \gamma(e_1) \sim_{\tau} \gamma'(e_1)
   $$
   其中，$e_1$ 和 $e'_1$ 分别定义为：
   $$
   e_1 = [\text{fix}_m x : \tau \text{ is } \gamma(e) / x] \gamma(e)
   $$
   $$
   e'_1 = [\text{fix}_m x : \tau \text{ is } \gamma'(e) / x] \gamma'(e)
   $$

5. **应用内层和外层归纳假设**：
   - 由外层归纳假设，已知 $\text{fix}_m x : \tau \text{ is } \gamma(e) \sim_{\tau} \text{fix}_m x : \tau \text{ is } \gamma'(e)$，因此有：
     $$
     [\text{fix}_m x : \tau \text{ is } \gamma(e) / x] \gamma(e) \sim_{\tau} [\text{fix}_m x : \tau \text{ is } \gamma'(e) / x] \gamma'(e)
     $$

6. **证明成立**：
   通过归纳假设，这一结果成立，从而完成整个递归的证明。

---

#### **条件表达式的处理**：
当处理条件表达式 $\text{ifz } e \{z \to e_0 \mid s(x) \to e_1\}$ 时，采用分类讨论的方法：

1. 如果 $e$ 发散，则整个条件表达式发散，因此根据引理 47.6，条件表达式是自反等价的。
2. 如果 $e$ 收敛，则可以对其值进行内层数学归纳，并使用条件分支的归纳假设来证明等价性。

---

### **总结**：

- **有界递归** 和 **不动点归纳** 是处理递归表达式等价性的重要工具。通过对递归表达式的展开次数进行归纳，能够证明递归表达式的全局等价性。
- **条件表达式** 通过分类讨论发散和收敛的情况，分别应用不同的归纳假设，确保条件表达式的等价性。

这一证明展示了如何通过递归和发散的性质，来证明表达式的自反等价性。

### ---------------------------------

### Lemma 47.10 (Congruence)

#### **引理内容：**
如果 $C_0 : (\Gamma \vdash \tau) \longrightarrow (\Gamma_0 \vdash \tau_0)$，并且 $\Gamma \vdash e \sim e' : \tau$，则 $\Gamma_0 \vdash C_0\{e\} \sim C_0\{e'\} : \tau_0$。

#### **证明思路：**
证明通过对 $C_0$ 的类型派生进行归纳，类似于引理 47.9 的证明。

#### **证明过程：**
1. **归纳假设：** 假设对于所有的派生规则，类型推导满足条件，并且我们已经证明了 $e$ 和 $e'$ 在上下文中是等价的。
2. **归纳步骤：** 在每一步推导中，继续应用归纳假设，逐步推导出 $C_0\{e\}$ 和 $C_0\{e'\}$ 的等价性。

#### **逻辑等价性的一致性：**
由于逻辑等价性在定义上是**一致的**（consistent），因此可以得出结论，逻辑等价性包含在观察等价性中。

---

### Theorem 47.11

#### **定理内容：**
如果 $\Gamma \vdash e \sim e' : \tau$，那么 $\Gamma \vdash e \sim= e' : \tau$。

#### **证明思路：**
通过逻辑等价性的一致性和**逻辑等价性是合流的**(congruence)，可以得出结论。

#### **证明过程：**
1. **一致性：** 逻辑等价性是一致的。
2. **合流性：** 通过逻辑等价性的合流性可以证明，如果 $\Gamma \vdash e \sim e' : \tau$，则 $e$ 和 $e'$ 在所有上下文中是观察等价的。
3. **结论：** 根据一致性和合流性，推导出 $\Gamma \vdash e \sim= e' : \tau$。

---

### Lemma 47.12

#### **引理内容：**
如果 $e \sim=_{\tau} e'$，那么 $e \sim_{\tau} e'$。

#### **证明思路：**
通过对类型结构的归纳证明该引理。

#### **证明过程：**
1. **基准情况：** 如果 $\tau = \text{nat}$，由于空表达式上下文是程序上下文，因此结果立即成立。
2. **递归情况：** 如果 $\tau = \tau_1 \to \tau_2$，假设 $e_1 \sim_{\tau_1} e'_1$，需要证明 $e(e_1) \sim_{\tau_2} e'(e'_1)$。
3. **应用定理 47.11：** 由于 $e_1 \sim=_{\tau_1} e'_1$，根据定理 47.11 和引理 47.4，可以证明 $e(e_1) \sim=_{\tau_2} e'(e'_1)$，由此结果成立。

---

### Theorem 47.13

#### **定理内容：**
如果 $\Gamma \vdash e \sim= e' : \tau$，那么 $\Gamma \vdash e \sim e' : \tau$。

#### **证明思路：**
假设 $\Gamma \vdash e \sim= e' : \tau$，然后通过对替换的等价性进行推导，最终证明两者是观察等价的。

#### **证明过程：**
1. **假设：** 假设 $\Gamma \vdash e \sim= e' : \tau$，并且假设 $\gamma \sim_{\Gamma} \gamma'$。
2. **应用定理 47.11：** 根据定理 47.11，得到 $\gamma \sim=_{\Gamma} \gamma'$。
3. **应用引理 47.4：** 根据引理 47.4，我们有 $\hat{\gamma}(e) \sim=_{\tau} \hat{\gamma}'(e')$。
4. **应用引理 47.12：** 最后通过引理 47.12，我们可以得出 $\hat{\gamma}(e) \sim_{\tau} \hat{\gamma}'(e')$。

---

### Corollary 47.14

#### **推论内容：**
$\Gamma \vdash e \sim= e' : \tau$ 当且仅当 $\Gamma \vdash e \sim e' : \tau$。

#### **推论解释：**
这个推论表明**逻辑等价性**和**观察等价性**在 PCF 系统中是等价的。这意味着我们可以在逻辑等价性和观察等价性之间自由转换，从而在程序推导和证明过程中简化推理步骤。

### ---------------------------------

### **47.4 Compactness (紧致性)**

#### **固定点归纳 (Fixed Point Induction) 的原理**
固定点归纳的原理源自于 PCF 系统中的一个关键性质，称为**紧致性 (compactness)**。这个性质表明，计算过程中一个固定点表达式的完全展开只需要有限次解开递归。这意味着，在有限时间的计算中不可能完成无限多次的递归调用。

虽然从直觉上看，紧致性似乎是显而易见的（因为在有限次计算中不可能进行无限次递归调用），但要严格地描述和证明这一性质并不简单。

#### **紧致性证明概述**
为了证明紧致性（即定理 47.16），我们需要借助在第 28 章中定义的 PCF 的**堆栈机器 (stack machine)**，并对有界递归表达式添加以下转换规则：

$$
k * \text{fix}_0\ x : \tau\ \text{is}\ e \longrightarrow k * \text{fix}_0\ x : \tau\ \text{is}\ e \tag{47.6a}
$$

$$
k * \text{fix}_{m+1}\ x : \tau\ \text{is}\ e \longrightarrow k * [\text{fix}_m\ x : \tau\ \text{is}\ e / x] e \tag{47.6b}
$$

这些转换规则为有界递归的定义提供了操作步骤。第一个规则（47.6a）表明当递归深度为 0 时，表达式保持不变。第二个规则（47.6b）表示递归深度大于 0 时，会将表达式 $e$ 中的递归调用展开一次。

#### **紧致性原理的直觉示例：阶乘函数**

考虑 PCF 中的**阶乘函数** $f$：

$$
\text{fix}\ f : \text{nat} \to \text{nat}\ \text{is}\ \lambda (x : \text{nat})\ \text{ifz}\ x\ \{ z \rightarrow s(z)\ |\ s(x') \rightarrow x \cdot f(x') \}
$$

计算 $f(n)$ 需要 $n$ 次递归调用。对于给定的输入 $n$，我们可以设定一个递归深度的界限 $m$，并确保该界限足以终止计算。

有界递归形式的表达式为：

$$
\text{fix}_m\ f : \text{nat} \to \text{nat}\ \text{is}\ \lambda (x : \text{nat})\ \text{ifz}\ x\ \{ z \rightarrow s(z)\ |\ s(x') \rightarrow x \cdot f(x') \}
$$

我们称该表达式为 $f^{(m)}$。可以证明，对于某个 $m \geq 0$，如果 $f(n)$ 终止并产生结果 $p$，则 $f^{(m)}(n)$ 也会终止并生成相同的结果。

#### **高阶类型上的递归**

在处理高阶类型时，情况变得更加复杂。例如，考虑**加法函数** $a$，其类型为 $\tau = \text{nat} \to (\text{nat} \to \text{nat})$，定义如下：

$$
\text{fix}\ p : \tau\ \text{is}\ \lambda (x : \text{nat})\ \text{ifz}\ x\ \{ z \rightarrow \text{id}\ |\ s(x') \rightarrow s \circ p(x') \}
$$

其中，$\text{id} = \lambda (y : \text{nat}) y$ 是恒等函数，$\circ$ 表示函数组合，$s = \lambda (x : \text{nat}) s(x)$ 是后继函数。

当 $a(n)$ 被应用时，即使 $n$ 很大，递归调用只需要三次转换即可生成一个 $\lambda$ 抽象。然而在结果中，残留的递归部分依旧会包含 $a$ 自身。对于有界版本的递归 $a^{(m)}$，类似的递归计算也只需要三次转换，但结果将包含 $a^{(m-1)}$，而不是 $a$ 本身。

#### **紧致性证明中的符号和技术引理**

假设 $x : \tau \vdash e_x : \tau$ 是某个抽象函数的定义。设 $f(\omega) = \text{fix}\ x : \tau\ \text{is}\ e_x$，并且 $f^{(m)} = \text{fix}_m\ x : \tau\ \text{is}\ e_x$。我们可以观察到，对于任意 $m \geq 0$，$f(\omega) : \tau$ 并且 $f^{(m)} : \tau$。

一个关键的技术引理允许我们在不影响计算结果的情况下，增加递归表达式的递归深度。这使得证明过程中的递归展开次数可以被有限化，从而实现紧致性。

#### **总结**
- 紧致性说明了即使在递归的情况下，也只需要有限次展开即可完成程序计算。
- 通过引入堆栈机器的有界递归规则和递归技术引理，紧致性得以严格证明。

这一性质对于 PCF 系统中的固定点归纳证明非常重要。

### ---------------------------------

### 详解：Lemma 47.15 和 Theorem 47.16 (紧致性)

#### **引理 47.15**
对于每个 $m \geq 0$，如果 $[f^{(m)}/y] k * [f^{(m)}/y] e \longrightarrow^*   , n$，那么 $[f^{(m+1)}/y] k * [f^{(m+1)}/y] e \longrightarrow^*   , n$。

**证明**：  
引理 47.15 的证明通过对 $m \geq 0$ 进行归纳，然后对转换进行归纳。证明的主要目的是说明在有界递归的情况下，增加递归深度不会改变结果。也就是说，假设我们有一个 $m$ 次展开的递归调用，它可以在某个有限状态下收敛，那么在 $m+1$ 次展开时，依然会收敛到同样的结果。

#### **定理 47.16（紧致性）**
**定理内容**：  
假设 $y : \tau \vdash e : \text{nat}$ 且 $y \notin f^{(\omega)}$，如果 $[f^{(\omega)}/y] e \longrightarrow^* n$，那么存在某个 $m \geq 0$ 使得 $[f^{(m)}/y] e \longrightarrow^* n$。

**紧致性的直觉**：
在递归表达式的展开过程中，虽然递归可能是无限的，但计算过程中总是只需要有限次的递归展开。该定理的要点在于，即使某个表达式需要无限次递归调用（即 $f^{(\omega)}$），我们仍然可以找到一个有限的展开次数 $m$，使得在 $m$ 次递归之后结果将会和 $f^{(\omega)}$ 一样。

**证明**：
1. **引理的强扩展**：  
   我们同时证明一个更强的命题：如果 $[f^{(\omega)}/y] k * [f^{(\omega)}/y] e \longrightarrow^*   , n$，那么对于某个 $m \geq 0$，有 $[f^{(m)}/y] k * [f^{(m)}/y] e \longrightarrow^*   , n$。
   
   另外，还证明 $[f^{(\omega)}/y] k , [f^{(\omega)}/y] e \longrightarrow^*   , n$ 时，对于某个 $m \geq 0$，同样有 $[f^{(m)}/y] k , [f^{(m)}/y] e \longrightarrow^*   , n$。

   **递归展开**：  
   由于堆栈机器的正确性（见 Corollary 28.4），该结果成立。证明首先假设初始状态为 $[f^{(\omega)}/y] k * f^{(\omega)}$，当 $e = y$ 时，递归展开为：

   $$
   [f^{(\omega)}/y] k * f^{(\omega)} \longrightarrow [f^{(\omega)}/y] k * [f^{(\omega)}/x] e_x \longrightarrow^*   , n
   $$

   由归纳假设，我们可以得到某个 $m \geq 0$，使得：

   $$
   [f^{(m)}/y] k * [f^{(m)}/x] e_x \longrightarrow^*   , n
   $$

   然后根据引理 47.15，可以得到：

   $$
   [f^{(m+1)}/y] k * [f^{(m)}/x] e_x \longrightarrow^*   , n
   $$

   最后，由于 $[f^{(m+1)}/y] k * f^{(m+1)} = [f^{(m+1)}/y] k * [f^{(m)}/x] e_x$，我们完成了证明。

2. **递归展开非初始步骤**：  
   如果初始步骤是递归展开但 $e \neq y$，则对某个 $z \notin f^{(\omega)}$ 且 $z \neq y$，可以得到：

   $$
   [f^{(\omega)}/y] k * \text{fix}\ z : \tau\ \text{is}\ d^{(\omega)} \longrightarrow [f^{(\omega)}/y] k * [\text{fix}\ z : \tau\ \text{is}\ d^{(\omega)} / z] d^{(\omega)} \longrightarrow^*   , n
   $$

   通过归纳，我们可以得到某个 $m \geq 0$，使得：

   $$
   [f^{(m)}/y] k * [\text{fix}\ z : \tau\ \text{is}\ d^{(m)} / z] d^{(m)} \longrightarrow^*   , n
   $$

   根据引理 47.15，再次得到：

   $$
   [f^{(m+1)}/y] k * [\text{fix}\ z : \tau\ \text{is}\ d^{(m+1)} / z] d^{(m+1)} \longrightarrow^*   , n
   $$

   该结果直接推导出来。

#### **推论 47.17**
存在某个 $m \geq 0$，使得 $[f^{(\omega)}/y] e 2 [f^{(m)}/y] e$。

**证明**：  
如果 $[f^{(\omega)}/y] e$ 发散，取 $m = 0$ 即可。否则，应用定理 47.16 得到 $m$，并根据 Kleene 等价性证明要求成立。

---

通过紧致性，我们可以证明 PCF 中递归调用的有限性和可终止性，尽管递归定义本身是无限的。这为递归计算的合理性提供了理论支持。

### ---------------------------------

### 详解：Lazy Natural Numbers (惰性自然数)

在 **PCF** 中，惰性自然数 (lazy natural numbers) 的类型被称为 **$lnat$**，与普通的自然数类型 **$nat$** 相对。惰性自然数的引入带来了一种新的无限值 **$ω$**，其表示形式为一个“无穷的继承者栈”（endless stack of successors）。这是通过延迟求值 (lazy evaluation) 来实现的。

#### **惰性自然数中的 $ω$**

通常，自然数是通过构造器 **$z$**（表示零）和继承者函数 **$s$**（表示后继）构造的。例如，数字 **$3$** 可以表示为 **$s(s(s(z)))$**。然而，当我们引入惰性自然数时，类型 **$lnat$** 可以包含一个无穷的继承者序列 **$ω$**，它是通过无限次应用继承者 **$s$** 生成的。

- **$ω$**: 表示一个无限的后继序列，表示为 **$s(s(s(\dots)))$**，因此 **$ω$** 是一个无穷大的值。

#### **逻辑等价的共归纳定义**

在处理惰性自然数时，逻辑等价 (logical equivalence) 的定义不能像处理普通自然数那样通过归纳方式定义，因为惰性自然数可能是无限的。因此，必须通过**共归纳** (coinduction) 来定义等价性，即定义最弱的一种关系，使得其在特定条件下保持一致。

##### **逻辑等价的定义：**

我们定义 **$e \sim_{lnat} e'$**（两个闭合的惰性自然数表达式是等价的），并要求其满足以下两个条件：

1. 如果 **$e \longrightarrow^* z$**，那么 **$e' \longrightarrow^* z$**（即两个表达式都可以归约为零），反之亦然。
2. 如果 **$e \longrightarrow^* s(e_1)$**，那么 **$e' \longrightarrow^* s(e'_1)$**，并且 **$e_1 \sim_{lnat} e'_1$**（即两个表达式都可以归约为某个后继函数，并且其内部值也满足逻辑等价），反之亦然。

##### **Kleene 等价的定义：**

Kleene 等价需要修改以处理惰性求值。两个表达式的比较只基于它们的外层结构，具体如下：

- **条件 (a)**: 如果 **$e \longrightarrow^* z$**，则 **$e' \longrightarrow^* z$**，反之亦然。
- **条件 (b)**: 如果 **$e \longrightarrow^* s(e_1)$**，则 **$e' \longrightarrow^* s(e'_1)$**，并且 **$e_1 \sim_{lnat} e'_1$**，反之亦然。

#### **定理与推论**

**推论 47.17** 表明，对于共自然数（co-natural numbers，$lnat$），我们可以用与处理普通自然数相似的方式证明 Kleene 等价性。即使引入了惰性继承者操作，也可以应用与之前类似的论证方法。

#### **共归纳证明原理**

**共归纳原理** (proof by coinduction) 允许我们证明两个表达式在惰性自然数上的等价性。具体来说，为了证明 **$e \sim_{lnat} e'$**，我们只需找到一个满足一致性条件的关系 **$E$**，使得：

1. **$e E e'$**：两个表达式在 **$lnat$** 类型上满足关系 **$E$**。
2. **$E$** 满足上述的一致性条件（即如果 **$e \longrightarrow^* z$**，那么 **$e' \longrightarrow^* z$**，等等）。

#### **小结**

在惰性自然数的类型 **$lnat$** 中，继承者的延迟求值使得我们可以表示无限自然数 **$ω$**。为了处理这种惰性求值，逻辑等价性需要通过**共归纳**方式来定义，即定义最弱的一种等价关系，并通过 **共归纳原理** 来进行证明。这种方法与普通自然数的处理不同，但通过修改 Kleene 等价的定义和引入共归纳，可以处理无限递归和延迟求值。

### ---------------------------------

### 详解：Theorem 47.8 的应用 - Coinduction 证明

在本段中，使用共归纳 (coinduction) 证明定理 **47.8**，该定理的证明是基于 PCF（带有递归的纯函数式计算）语言中惰性自然数类型 **$lnat$**。在这个证明中，我们主要使用共归纳原理来处理**惰性自然数**，这是因为惰性自然数的定义具有无限的递归结构，因此需要通过共归纳的方法进行处理。

#### **问题描述**

我们假设两个上下文 **$A$** 和 **$A' : \tau_0 \Rightarrow lnat$** 是逻辑等价的（$A \sim A'$），并且我们定义以下表达式：

- **$a = A\{fix \, x : \tau_0 \, is \, e\}$**：表示在上下文 $A$ 中用递归表达式 $fix$ 替代变量 $x$ 的结果。
- **$a' = A'\{fix \, x : \tau_0 \, is \, e'\}$**：表示在上下文 $A'$ 中替代变量 $x$ 的递归表达式。

为了处理递归，我们引入了一个有限展开的递归形式 **$a(m)$** 和 **$a'(m)$**：

- **$a(m) = A\{fix^m \, x : \tau_0 \, is \, e\}$**：表示递归展开 $m$ 次后的表达式。
- **$a'(m) = A'\{fix^m \, x : \tau_0 \, is \, e'\}$**：类似地，递归展开 $m$ 次后的表达式。

假设对于所有的 $m \geq 0$，**$a(m) \sim_{lnat} a'(m)$**，现在我们需要证明 **$a \sim_{lnat} a'$**（即经过无限次递归的表达式也是等价的）。

#### **定义函数 $p_n$**

为了解决这个问题，我们定义了一组处理惰性自然数的函数 **$p_n$**，这些函数能够逐步从惰性自然数中抽取出有用的信息：

- **$p_0(d) = d$**：初始值为表达式 $d$。
- **$p_{n+1}(d) = \begin{cases} d' & \text{如果} \, p_n(d) \, \rightarrow^* \, s(d') \\ \text{未定义} & \text{否则} \end{cases}$**：如果 $p_n(d)$ 可以被规约为后继形式 $s(d')$，则返回 $d'$，否则未定义。

这些函数帮助我们逐层解析出惰性自然数中的信息（例如从 $s(s(\dots))$ 中抽取出每一个后继）。

#### **构造关系 $E$**

我们定义关系 **$E$** 来表示从 $a$ 和 $a'$ 中提取出来的值：

- **$a_n = p_n(a)$** 和 **$a'_n = p_n(a')$** 表示通过函数 $p_n$ 从 $a$ 和 $a'$ 中提取出来的第 $n$ 层值。
- **$E$** 是最强的关系，满足 **$a_n E a'_n : lnat$** 对所有 $n \geq 0$。

#### **证明 E 的一致性**

为了证明 **$E$** 的一致性（consistency），我们需要验证以下两点：

1. 如果 **$a_n E a'_n : lnat$** 对某个 **$n \geq 0$** 成立，根据推论 **47.17**，存在一个 **$m \geq 0$**，使得 **$a_n \sim_{Kleene} a_n^{(m)}$**，这意味着递归展开 $m$ 次后的值与 **$a_n$** 等价。进一步，通过假设，**$a_n \sim_{Kleene} a'_n^{(m)}$**，因此有 **$a'_n^{(m)} \sim_{Kleene} a'_n$**。这证明了 $E$ 的递归等价性。
   
2. 如果 **$a_n \rightarrow^* s(b_n)$**，则我们可以推导出 **$a_n^{(m)} \rightarrow^* s(b_n^{(m)})$**。由此推导出存在 **$b'_n^{(m)}$**，使得 **$a'_n^{(m)} \rightarrow^* s(b'_n)$**。通过递归定义，我们可以证明 **$b_n \sim_{lnat} b'_n$**。

#### **结论**

由于关系 **$E$** 满足一致性条件，因此它包含在逻辑等价关系中。因此，我们得出结论 **$a \sim_{lnat} a'$**。

### **小结**

在处理带有递归和惰性求值的自然数时，证明等价性需要通过**共归纳**来处理，因为惰性自然数的类型可能包含无穷的继承者。通过引入 **$p_n$** 函数逐层解析惰性自然数，并构造关系 **$E$**，我们可以使用共归纳原理证明表达式 **$a$** 和 **$a'$** 是逻辑等价的。这展示了共归纳在处理无限结构中的强大作用。


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------
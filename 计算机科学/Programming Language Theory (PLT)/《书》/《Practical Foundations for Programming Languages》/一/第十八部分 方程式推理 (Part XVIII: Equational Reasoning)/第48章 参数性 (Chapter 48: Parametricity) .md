[toc]



### 详解：Parametricity（参数化）

**参数化多态性（Parametricity）** 是理解多态编程（polymorphic programming）中的核心概念，它允许编写适用于多种类型的通用程序。在多态函数式语言中，程序员可以编写不依赖于具体类型的函数，这使得程序既灵活又安全。

#### **主要动机**

多态性的主要动机在于编写能够适用于多种类型的**通用函数**。例如，在第16章中给出的**组合函数（composition function）**，可以适用于任意类型的输入与输出。通过多态性，我们可以对程序的泛型行为进行编码。

- **多态性（Polymorphism）**：允许程序不依赖于特定类型的选择。例如，函数可以对任意类型的列表进行操作，而不需要指定列表中的元素类型。
- **限制性**：多态性还可以用于限制程序的行为，确保某个程序不依赖于特定的类型选择。在某些情况下，我们希望强制要求程序不涉及类型的具体选择，因此会使用多态性来达到这一目的。

多态类型系统的**限制性**使得在多态函数式语言中，如果类型正确，那么程序很有可能也是正确的。这是因为具有多态类型的函数往往只能执行有限的操作，这减少了错误的可能性。

#### **参数化的技术基础**

这种经验背后的技术基础被称为**参数化多态性（parametricity）**。参数化多态性限制了可以与多态类型匹配的程序集合，确保这些程序的行为是类型无关的。参数化多态性保证了多态函数不能根据传入的具体类型改变其行为，它只能对**结构性**信息进行操作。

例如，一个具有类型 $ \forall \alpha . \alpha \to \alpha $ 的函数必须对任意类型 $\alpha$ 保持相同的行为。这种限制显著减少了可能的程序行为集合，从而增加了程序的正确性。

#### **48.1 Overview（概述）**

本章的目标是通过**按需求值（call-by-name）**解释，讨论F系统（System F）中的**参数化多态性**。参数化多态性的重要性在于，它不仅扩展了可以编写的程序集合，还限制了某些情况下可以编写的程序集合。

#### **48.2 Observational Equivalence（观察等价性）**

观察等价性是衡量两个程序在所有上下文中是否产生相同行为的标准。在多态编程中，如果两个程序在所有类型上都具有相同的表现，那么它们就是观察等价的。

#### **48.3 Logical Equivalence（逻辑等价性）**

逻辑等价性是基于程序的逻辑结构进行的等价判断。通过类型系统的严格限制，我们可以保证具有相同类型的程序在逻辑上是等价的。

#### **48.4 Parametricity Properties（参数化性质）**

**参数化性质**是指程序中多态性的行为受限于类型无关的操作。也就是说，多态函数不能基于其输入的具体类型执行不同的操作，而必须保持对所有类型的一致性。

例如，一个具有类型 $ \forall \alpha . \alpha \to \alpha $ 的函数只能返回其输入参数本身，而不能执行与输入类型相关的其他操作。因为这种多态性限制了程序的可能行为，所以具有多态类型的程序比普通类型的程序更容易推理和验证。

#### **48.5 Representation Independence, Revisited（表示独立性，再访）**

**表示独立性（Representation Independence）** 是参数化多态性的重要应用之一。它指出，程序的行为不应依赖于具体数据表示的选择。如果一个程序的类型是多态的，那么它的行为就不应该因为具体的类型实现或数据结构的不同而改变。表示独立性保证了程序在处理不同类型的具体实现时，能够保持一致的行为。

#### **48.6 Notes（注释）**

最后，讨论了参数化多态性在编程语言设计中的重要作用。它不仅使得程序更具灵活性，还通过类型系统的限制保证了程序的安全性和正确性。

### **参数化多态性的关键性质**

- **类型无关性**：多态函数不能依赖于输入的具体类型，而必须在所有类型上表现一致。
- **逻辑限制**：多态函数只能执行与其类型一致的操作，因此减少了错误的可能性。
- **表示独立性**：程序的行为不依赖于数据的具体表示形式，而是基于数据的结构性信息。

通过参数化多态性，程序员不仅可以编写更通用的程序，还能利用类型系统来确保程序的正确性。

### ---------------------------------

### 48.1 Overview（概述）

在本节中，我们通过非正式的讨论来理解**参数化多态性（parametricity）**，并基于类型的**良构程序集合（well-formed programs）**来推导出一些直观的结论。

#### **类型 ∀(t.t → t) 的解释**

假设一个函数 $f$ 的类型是 $ \forall (t.t \to t)$，即这个函数是多态的，对于任何类型 $t$，它都能接受一个类型为 $t \to t$ 的函数，并返回同样类型的值。

- 当 $f$ 被实例化为某个具体类型 $ \tau$ 时，它应该计算为一个类型为 $ \tau \to \tau $ 的函数 $g$，而当进一步应用于某个值 $v$（类型为 $ \tau$）时，$g$ 必须返回另一个值 $v'$（类型也为 $ \tau$）。
- 由于 $f$ 是多态的，并且 $g$ 不能依赖于具体的值 $v$，因此 $v'$ 必须等于 $v$。换句话说，$g$ 必须是**恒等函数（identity function）**，即 $g(v) = v$。
- 因此，$f$ 必须是**多态恒等函数（polymorphic identity function）**。

#### **类型 ∀(t.t) 的解释**

现在，假设 $f$ 是一个类型为 $ \forall (t.t)$ 的函数。直观上，什么样的函数可以具有这个类型呢？

- 当 $f$ 被实例化为某个类型 $ \tau $ 时，它应该返回一个该类型的值。但是，并不是所有类型都有对应的值（例如，对于某些类型来说没有值存在）。
- 这意味着没有任何函数可以符合这个类型 $ \forall (t.t)$ 的要求。这是因为该类型要求为任何类型返回一个值，而这在很多情况下是不可能的。

结论是：$ \forall (t.t)$ 是一个**空类型（empty type）**，即没有任何函数可以具有这个类型。

#### **Church 数字类型 N 的解释**

让 $N$ 表示第16章中介绍的**多态 Church 数字类型**，即 $ \forall (t.t \to (t \to t) \to t)$。

- $N$ 的值是什么？假设有任意类型 $ \tau$ 以及两个值 $ z : \tau$ 和 $ s : \tau \to \tau $，表达式 $f[\tau](z)(s)$ 应该生成一个类型为 $ \tau $ 的值。
- 由于 $f$ 是多态的，因此它必须对类型 $ \tau$ 的选择表现一致（即，函数 $f$ 的行为不能依赖于 $ \tau$ 的具体值）。
- 那么，$f$ 生成的值可能是什么？唯一的方法是使用传递给它的值 $z$ 和函数 $s$。稍加思考可以得出，$f[\tau](z)(s)$ 生成的值是 $s$ 函数的 $n$ 次迭代应用，即：

$$
s(s(...s(z)...))
$$

也就是说，$N$ 的元素与**自然数**一一对应。

### 关键概念（Key Concepts）：

1. **多态恒等函数（Polymorphic Identity Function）**：类型为 $ \forall (t.t \to t)$ 的函数是多态的，它在任何类型上都必须表现为恒等函数。

2. **空类型（Empty Type）**：类型 $ \forall (t.t)$ 是空的，因为它要求为所有类型生成一个值，而这在许多类型下是不可能的。

3. **多态 Church 数字（Polymorphic Church Numerals）**：类型 $ \forall (t.t \to (t \to t) \to t)$ 的值与自然数一一对应，因为它表示一个函数的多次应用（类似于自然数的递归定义）。

通过这些例子，可以直观地理解**参数化多态性**如何限制程序的行为，使得多态程序不能依赖于具体的类型选择。

### ---------------------------------

### 48.2 观察等价（Observational Equivalence）

在第46章和第47章中，**观察等价（observational equivalence）** 的定义基于识别可观察的完整程序结果。观察等价关注的是程序的输入输出行为，而不是其内部结构。**函数类型的值（function type values）** 不被视为结果，因为它们的行为被看作一个“黑盒子（black box）”，我们无法看到其内部结构，只能通过它的输入输出来判断其行为。

#### **F 系统中的挑战**

在系统 $F$ 中，没有闭合的基础类型（base types）。每种类型要么是**函数类型（function type）**，要么是**多态类型（polymorphic type）**，因此没有合适的类型可以作为可观察的答案。所有的类型都是通过函数或多态构建的，缺乏基础类型。

#### **解决方案：引入基础类型**

为了应对这一问题，我们可以通过给 $F$ 增加一个基础类型 $2$ 来解决问题。该基础类型包含两个常量，$tt$ 和 $ff$，分别代表计算的可能答案。这意味着通过计算得到的结果可以被立即区分出来。

- $tt$ 和 $ff$ 是类型 $2$ 中的两个常量，它们表示两个明确的可区分的答案。
- 完整程序是一个类型为 $2$ 的闭合表达式。

#### **Kleene 等价（Kleene Equality）**

对于完整程序，我们定义 Kleene 等价关系。给定两个表达式 $e$ 和 $e'$，如果它们在计算中都到达 $tt$ 或都到达 $ff$，则称 $e$ 与 $e'$ 在 Kleene 等价意义下相等，记作 $e \, 2 \, e'$。

- 如果 $e \rightarrow^* tt$ 并且 $e' \rightarrow^* tt$，则 $e \, 2 \, e'$。
- 如果 $e \rightarrow^* ff$ 并且 $e' \rightarrow^* ff$，则 $e \, 2 \, e'$。
- Kleene 等价是一个等价关系，并且显然有 $tt \neq ff$，因为它们是两个不同的常量。

#### **观察等价的定义**

为了定义**观察等价（observational equivalence）**，我们首先要定义表达式上下文（expression context）。上下文是带有“空洞（hole）”的表达式，可以用另一个表达式填充该空洞。

- 我们通过推导规则定义上下文的判断形式：
  
  $$
  C : (\Delta; \Gamma \vdash \tau) \longrightarrow (\Delta'; \Gamma' \vdash \tau')
  $$

  这表示一个上下文 $C$，当它被填充一个表达式 $\Delta; \Gamma \vdash e : \tau$ 时，会生成一个表达式 $\Delta'; \Gamma' \vdash C{e} : \tau'$。

#### **定义 48.1：观察等价**

两种相同类型的表达式 $e$ 和 $e'$ 被称为**观察等价**的，记作

$$
\Delta; \Gamma \vdash e \sim= e' : \tau
$$

当且仅当对于任意表达式上下文 $C$（满足 $C : (\Delta; \Gamma \vdash \tau) \longrightarrow (\emptyset; \emptyset \vdash 2)$），都有

$$
C{e} \, 2 \, C{e'}
$$

即在任意上下文中，将 $e$ 和 $e'$ 填入后，其结果在 Kleene 等价意义下是相同的。

### 关键概念总结

1. **观察等价（Observational Equivalence）**：如果两个表达式在任意程序上下文中得出相同的结果（即 Kleene 等价），它们就是观察等价的。
   
2. **Kleene 等价（Kleene Equality）**：用于完整程序结果比较的等价关系，如果两个表达式最终都计算到相同的结果（$tt$ 或 $ff$），它们就是 Kleene 等价的。

3. **表达式上下文（Expression Context）**：带有“空洞”的表达式，可以填充其他表达式并生成新表达式。在上下文中填充两个表达式后，如果它们产生的结果是 Kleene 等价的，则这两个表达式是观察等价的。

这部分为我们提供了一种通过上下文进行表达式比较的方式，帮助我们理解如何在多态系统中定义和应用观察等价。

### ---------------------------------

### 引理 48.2：观察等价是最粗的、一致的同余关系

**Lemma 48.2** 提到，观察等价（observational equivalence）是**最粗的、一致的同余关系（the coarsest consistent congruence）**，它表明观察等价允许我们在表达式之间替换等价的部分，并确保这种替换不会影响程序的正确性。

### 证明

这条引理的证明本质上与定理 46.6 的证明类似，即通过上下文推理来保证表达式之间的等价关系成立。在表达式中任意等价的子表达式可以被相互替换，且结果仍然保持一致。

---

### 引理 48.3

**Lemma 48.3** 包含两个部分：

1. **如果 $\Delta,t;\Gamma \vdash e \sim= e' : \tau$ 且 $\tau_0$ 是类型，则有 $\Delta;[\tau_0/t]\Gamma \vdash [\tau_0/t]e \sim= [\tau_0/t]e' : [\tau_0/t]\tau$。**

   换句话说，假设在多态系统中，表达式 $e$ 和 $e'$ 对某个类型 $t$ 是观察等价的。如果我们将 $t$ 实例化为具体的类型 $\tau_0$，则替换后的表达式 $[τ_0/t]e$ 和 $[τ_0/t]e'$ 也是观察等价的。

2. **如果 $\emptyset; \Gamma, x : \tau_0 \vdash e \sim= e' : \tau$ 且 $d : \tau_0$，那么 $\emptyset; \Gamma \vdash [d/x]e \sim= [d/x]e' : \tau$。此外，如果 $d \sim=_{\tau_0} d'$，那么 $\emptyset; \Gamma \vdash [d/x]e \sim= [d'/x]e : \tau$ 且 $\emptyset; \Gamma \vdash [d/x]e' \sim= [d'/x]e' : \tau$。**

   这意味着，如果表达式 $e$ 和 $e'$ 是在某个变量 $x : \tau_0$ 下的观察等价表达式，并且我们有一个具体的值 $d : \tau_0$，那么将 $x$ 替换为 $d$ 后，两个表达式依然是观察等价的。更进一步，如果 $d$ 和 $d'$ 之间也是观察等价的，则用 $d$ 和 $d'$ 替换后，表达式仍然保持观察等价。

---

### 证明 1

假设有一个程序上下文 $C : (\Delta; [\tau_0/t] \Gamma * [\tau_0/t] \tau) \longrightarrow (\emptyset * 2)$。我们要证明：

$$
C\{[\tau_0/t]e\} 2 C\{[\tau_0/t]e'\}
$$

由于 $C$ 是闭合的，这等价于：

$$
[\tau_0/t]C\{e\} 2 [\tau_0/t]C\{e'\}
$$

定义新的上下文 $C' = (t)C\{\circ\}[\tau_0]$，可以观察到：

$$
C' : (\Delta,t; \Gamma * \tau) \longrightarrow (\emptyset * 2)
$$

根据假设，$C'\{e\} 2 C'\{e'\}$。

同时，$C'\{e\}$ 可以简化为 $[\tau_0/t]C\{e\}$，而 $C'\{e'\}$ 可以简化为 $[\tau_0/t]C\{e'\}$，从而得到结论。

---

### 证明 2

证明的过程与引理 46.7 的证明类似。通过替换和上下文推理，我们可以保证替换后的表达式保持观察等价性。

---

### 总结

**引理 48.3** 强调了在多态类型系统中的替换和观察等价性。无论是类型变量的实例化，还是具体值的替换，都不会改变表达式的观察等价性，这为多态系统中的代码可靠性提供了坚实的理论基础。

### ---------------------------------

### 48.3 逻辑等价 (Logical Equivalence)

在这一节中，我们引入了一种形式的逻辑等价，它捕捉了**参数化多态性 (parametricity)** 的非正式概念，并且为观察等价提供了一个刻画。这种刻画可以让我们推导出多态程序观察等价的性质，正如前面所提到的那样。

#### 逻辑等价的定义

对于 $F$ 体系中的逻辑等价，定义比 $T$ 体系中复杂得多。这里的核心思想是要定义多态类型 $\forall(t.\tau)$ 的逻辑等价，使其满足一个非常严格的条件，这个条件体现了参数化多态性的本质。

- 我们可以初步设想，如果两个表达式 $e$ 和 $e'$ 拥有多态类型 $\forall(t.\tau)$，那么它们应该是逻辑等价的，前提是它们在“所有可能的”类型解释 $t$ 的情况下也是逻辑等价的。
- 更精确地说，我们可能要求，对于任意类型 $\rho$，表达式 $e[\rho]$ 和 $e'[\rho]$ 在类型 $[\rho/t]\tau$ 上是逻辑等价的。

然而，这样的定义会遇到两个问题，一个是技术问题，另一个是概念性问题。

#### 技术问题：**不可预测性 (Impredicativity)**

在第 46 章中，我们通过对类型结构的归纳定义了逻辑等价。但是，当多态性具有不可预测性时，类型 $[\rho/t]\tau$ 可能会比 $\forall(t.\tau)$ 大。至少我们必须基于某些其他标准来证明逻辑等价的定义，但是似乎并没有合适的标准。

#### 概念问题：**限制性过大**

即便我们可以对逻辑等价的定义进行合理解释，它可能会过于严格。因为这样的定义等同于说，未知类型 $t$ 被解释为它在实例化时的逻辑等价。为了获得有用的参数化结果，我们需要比这更多的要求。

#### 解决方案：**关系解释 (Relational Interpretation)**

为了解决这两个问题，我们将考虑一种逻辑等价的推广，这种等价依赖于对其自由类型变量进行**关系解释**。这些参数决定了等式两边的每个自由类型变量的单独绑定，并通过指定的关系来调和它们之间的差异。因此，相关的表达式不必具有相同的类型，类型之间的差异通过给定的关系来调和。

#### 可疑之处：**逻辑等价可能是空关系**

最初我们可能怀疑，这样的定义要求过高，甚至可能导致逻辑等价是空关系。然而，出乎意料的是，情况并非如此，实际上正是这种定义的特性让我们可以推导出关于语言的参数化多态性结果。

#### 逻辑等价的推广

在推广逻辑等价时，我们会限制在某些“可接受的”二元关系的集合上，这些关系定义在封闭表达式之间。这些条件的引入是为了确保逻辑等价和观察等价可以一致。

### 解释的详细分析

1. **逻辑等价 (Logical Equivalence)** 的引入，是为了形式化多态类型系统中的程序等价问题，特别是参数化多态性。通过逻辑等价，我们能够证明程序在任意类型下的行为是否保持一致。
   
2. 在引入逻辑等价时，面临的两个挑战分别是：
   - **不可预测性**：无法直接用类型结构归纳定义逻辑等价。
   - **定义过于严格**：如果仅以逻辑等价来解释多态，可能会限制我们推导参数化的能力。

3. **关系解释 (Relational Interpretation)** 是解决这些问题的关键。它允许我们使用类型变量之间的关系来调和不同表达式间的差异，从而使逻辑等价具备足够的灵活性。

4. 尽管最初我们怀疑这样严格的定义可能过于严苛，但它实际上提供了足够的推理能力，特别是在推导出多态程序的参数化性质时。

5. **可接受的二元关系 (Admissible Binary Relations)** 的引入确保了逻辑等价和观察等价的一致性。这意味着在多态语言中，如果程序在所有类型下表现相同，那么它们在观察层面也是等价的。

通过这些分析，我们可以得出逻辑等价在多态类型系统中的重要性，并且它为我们提供了推导程序等价性的重要工具。这不仅帮助我们理解参数化多态的本质，还能保证多态程序在不同上下文中的一致性。

### ---------------------------------

### 定义 48.4: **可接受性 (Admissibility)**

可接受关系 $R$ 是定义在两个表达式之间的关系，记作 $R : \rho \leftrightarrow \rho'$，需要满足两个要求：

1. **尊重观察等价 (Respect for Observational Equivalence)**：如果 $R(e, e')$ 且 $d \sim_{\rho} e$ 且 $d' \sim_{\rho'} e'$，那么 $R(d, d')$。
2. **在反向求值下的闭合性 (Closure under Converse Evaluation)**：如果 $R(e, e')$ 成立，并且 $d \rightarrow e$，那么 $R(d, e')$ 成立；同样地，如果 $d' \rightarrow e'$，那么 $R(e, d')$ 成立。

虽然反向求值闭合性是尊重观察等价的一个推论，但目前我们还没有足够条件证明这一事实。

#### 解释：
- **尊重观察等价**要求，当两个表达式是等价的，并且通过关系 $R$ 关联时，即使它们的实例替换成等价表达式，关系 $R$ 也必须保持成立。
- **反向求值闭合性**则确保关系在求值过程中不被破坏。当一个表达式 $e$ 被求值为 $d$ 时，$R$ 必须能处理这个变化。

#### 公式推导：
给定 $\delta : \Phi$ 表示 $\delta$ 是一个类型替换，它为 $\Phi$ 中的每个类型变量 $t \in \Phi$ 分配了一个封闭的类型。类型替换 $\delta$ 导致类型上的替换函数 $\delta^\wedge$，由下式给出：
$$
\delta^\wedge(\tau) = [\delta(t_1), ..., \delta(t_n) / t_1, ..., t_n]\tau
$$
同样适用于表达式。替换操作可以扩展到上下文中，定义为对上下文 $\Gamma$ 中的每个变量 $x \in \text{dom}(\Gamma)$ 进行逐点替换：
$$
\delta^\wedge(\Gamma)(x) = \delta^\wedge(\Gamma(x))
$$

### 逻辑等价的定义
定义了参数化逻辑等价（parametric logical equivalence），写作 $e \sim_\tau e' [\eta : \delta \leftrightarrow \delta']$，并根据类型的结构进行归纳定义。

#### 定义 48.5: **参数化逻辑等价 (Parametric Logical Equivalence)**
- **基本类型 $t$ 的逻辑等价**：如果 $\eta(t)(e, e')$ 成立，那么 $e \sim_t e' [\eta : \delta \leftrightarrow \delta']$ 成立。
- **观察等价类型 $2$ 的逻辑等价**：如果 $e \sim_2 e'$，即 $e \sim_2 e'$ 的 Kleene 等价成立。
- **函数类型 $\tau_1 \to \tau_2$ 的逻辑等价**：如果 $e_1 \sim_{\tau_1} e'_1$，那么 $e(e_1) \sim_{\tau_2} e'(e'_1)$。
- **多态类型 $\forall(t.\tau)$ 的逻辑等价**：对于任意类型 $\rho$ 和 $\rho'$，以及任意可接受关系 $R : \rho \leftrightarrow \rho'$，如果 $e[\rho] \sim_\tau e'[\rho']$，则 $e \sim_{\forall(t.\tau)} e'$。

#### 解释：
- 参数化逻辑等价将每个类型变量 $t$ 关联到一个关系 $\eta(t)$。对于基本类型，使用这个关系来决定等价性。
- 对于函数类型，要求函数应用在每个可能的输入上保持等价。
- 对于多态类型，我们通过在任意类型下实例化表达式，并检查在这些类型下的等价性，来定义多态等价。

#### 替换和逻辑等价
表达式替换 $\gamma$ 对上下文 $\Gamma$ 的每个变量进行替换，记作 $\gamma : \Gamma$。替换操作 $\gamma$ 诱导出一个替换函数 $\gamma^\wedge$，定义为：
$$
\gamma^\wedge(e) = [\gamma(x_1), ..., \gamma(x_n) / x_1, ..., x_n]e
$$
其中 $\Gamma$ 的定义域包含 $x_1, ..., x_n$。

我们定义两个替换 $\gamma \sim_\Gamma \gamma' [\eta : \delta \leftrightarrow \delta']$ 的关系，要求它们的定义域相同，且对每个变量 $x$，$\gamma(x) \sim_{\Gamma(x)} \gamma'(x)$ 在给定的 $\eta$ 下成立。

#### 总结：
- **逻辑等价** 的定义不仅仅是检查相同类型下的等价性，还涉及处理多态性和函数应用等更复杂的情况。
- **参数化逻辑等价** 通过引入可接受的关系，保证了即使表达式实例化为不同的类型，它们仍然可以保持等价性。
- 替换规则的引入使得我们可以在复杂表达式中灵活地处理变量和类型的替换操作，同时保持逻辑等价的定义。

### ---------------------------------

### 定义 48.6：**逻辑等价 (Logical Equivalence)**

给定 $\Phi; \Gamma \vdash e : \tau$ 和 $\Phi; \Gamma \vdash e' : \tau$，我们说它们是逻辑等价的，记作 $\Phi; \Gamma \vdash e \sim e' : \tau$，当且仅当对于每个封闭类型的赋值 $\delta$ 和 $\delta'$，以及每个可接受的关系分配 $\eta : \delta \leftrightarrow \delta'$，如果 $\gamma \sim_{\Gamma} \gamma' [\eta : \delta \leftrightarrow \delta']$，则 $\gamma^\wedge(\delta^\wedge(e)) \sim_\tau \gamma'^\wedge(\delta'^\wedge(e')) [\eta : \delta \leftrightarrow \delta']$。

对于封闭的表达式 $e$，$e'$ 和封闭类型 $\tau$，该定义意味着 $e \sim_\tau e'$ 当且仅当 $e \sim_\tau e' [\emptyset : \emptyset \leftrightarrow \emptyset]$，这表明逻辑等价确实是其泛化的一个特例。

#### 解释：
- **逻辑等价** 是一种更广泛的等价定义，适用于类型和表达式的任意赋值。它确保了即使在不同类型赋值下，表达式依然保持等价性。
- $\eta : \delta \leftrightarrow \delta'$ 是一种关系，它处理封闭类型的替换和观察等价。
- 当表达式、类型都是封闭时，这种逻辑等价可以简化为更基本的情况，即它们在空的类型上下文中保持等价。

### 引理 48.7：**在反向求值下的闭合性 (Closure under Converse Evaluation)**

假设 $e \sim_\tau e' [\eta : \delta \leftrightarrow \delta']$。如果 $d \rightarrow e$，那么 $d \sim_\tau e'$，如果 $d' \rightarrow e'$，那么 $e \sim_\tau d'$。

#### 证明：
通过对 $\tau$ 结构的归纳证明。当 $\tau = t$ 时，结果直接由可接受性定义得出。否则，使用对应用和类型应用的转换关系定义，进行归纳证明。

#### 解释：
- **反向求值的闭合性** 保证了在表达式的逐步求值过程中，逻辑等价关系不会被破坏。如果 $d$ 求值为 $e$，那么 $d$ 和 $e'$ 保持等价，反之亦然。

### 引理 48.8：**尊重观察等价 (Respect for Observational Equivalence)**

假设 $e \sim_\tau e' [\eta : \delta \leftrightarrow \delta']$。如果 $d \sim=_{\delta^\wedge(\tau)} e$ 且 $d' \sim=_{\delta'(\tau)} e'$，则 $d \sim_\tau d' [\eta : \delta \leftrightarrow \delta']$。

#### 证明：
通过 $\tau$ 结构的归纳证明，依赖于可接受性定义和观察等价的同构性。例如，如果 $\tau = \forall(t.\tau_2)$，我们需要证明对于任意可接受关系 $R : \rho \leftrightarrow \rho'$，$d[\rho] \sim_{\tau_2} d'[\rho']$。利用观察等价的同构性，我们可以推导出 $e[\rho] \sim_{\tau_2} e'[\rho']$。

#### 解释：
- **尊重观察等价** 表示，如果两个表达式在某个上下文中是等价的，那么即使替换了它们的部分，依然可以保证替换后的表达式保持等价。
- 这一性质确保了逻辑等价与观察等价之间的强关联性。

### 推论 48.9：**逻辑等价是可接受关系 (Admissibility)**

关系 $e \sim_\tau e' [\eta : \delta \leftrightarrow \delta']$ 是封闭类型 $\delta^\wedge(\tau)$ 和 $\delta'(\tau)$ 之间的可接受关系。

#### 证明：
根据引理 48.7 和 48.8。

#### 解释：
- 这个推论保证了逻辑等价在任意封闭类型赋值下都能保持可接受性，这意味着它不仅能够处理多态表达式，还能处理带有自由类型变量的表达式。

### 推论 48.10：**保持观察等价 (Preservation of Observational Equivalence)**

如果 $\Phi; \Gamma \vdash e \sim e' : \tau$ 且 $\Phi; \Gamma \vdash d \sim= e : \tau$ 且 $\Phi; \Gamma \vdash d' \sim= e' : \tau$，那么 $\Phi; \Gamma \vdash d \sim d' : \tau$。

#### 证明：
根据引理 48.3 和推论 48.9。

#### 解释：
- 这个推论确保了如果两个表达式与某个等价表达式 $e$ 保持观察等价，那么它们彼此之间也是等价的。这进一步证明了逻辑等价和观察等价之间的紧密联系。

### 总结：
通过定义和推论，我们引入了 **逻辑等价** 这一更强的等价关系，并证明了它在各种转换、替换和求值操作下的闭合性。

### ---------------------------------

### 引理 48.11（**组合性** Compositionality）

**陈述**：设 $R : \delta^\wedge(\rho) \leftrightarrow \delta'(\rho)$ 为某种类型 $\rho$ 的关系解释，这意味着 $R(d,d')$ 成立当且仅当 $d \sim_\rho d' [\eta : \delta \leftrightarrow \delta']$。则 $e \sim_{[\rho/t]\tau} e' [\eta : \delta \leftrightarrow \delta']$ 当且仅当
$$
e \sim_\tau e' [\eta \otimes t \rightarrow R : \delta \otimes t \rightarrow \delta^\wedge(\rho) \leftrightarrow \delta' \otimes t \rightarrow \delta'(\rho)]。
$$

**证明**：通过对 $\tau$ 结构的归纳证明。当 $\tau = t$ 时，结果直接由关系 $R$ 的选择得出。当 $\tau = t'$ 且 $t' \neq t$ 时，结果根据定义 48.5 得出。当 $\tau = \tau_1 \rightarrow \tau_2$ 时，结果通过归纳和定义 48.5 推导得出。同样地，当 $\tau = \forall(u.\tau_1)$ 时，结果通过归纳推导，并假设 $u \neq t$ 且 $u \notin \rho$。

#### 解释：
- **组合性**确保了如果我们对某个类型 $\rho$ 施加了某种关系，那么可以将该关系反映在逻辑等价的表达式上。这种构造允许在多态系统中处理复杂的类型关系。
- 当涉及到多态类型（$\forall(t.\tau)$）时，我们通过对不同类型解释的统一处理，确保逻辑等价可以推广。

---

### 定理 48.12（**参数化性** Parametricity）

**陈述**：如果 $\Phi; \Gamma \vdash e : \tau$，则 $\Phi; \Gamma \vdash e \sim e : \tau$。

**证明**：通过对 $F$ 的静态规则（16.2）的规则归纳进行证明。

我们在此考虑两个代表性案例。

- **规则 (16.2d)**：
  假设 $\delta : \Phi, \delta' : \Phi, \eta : \delta \leftrightarrow \delta'$ 且 $\gamma \sim_\Gamma \gamma' [\eta : \delta \leftrightarrow \delta']$。根据归纳假设，对于所有的 $\rho, \rho'$ 和可接受的 $R : \rho \leftrightarrow \rho'$，我们有
  $$
  [\rho/t] \hat{\gamma}(\delta^\wedge(e)) \sim_\tau [\rho'/t]\gamma'(\delta'(e)) [\eta^* : \delta^* \leftrightarrow \delta'^*]
  $$
  其中 $\eta^* = \eta \otimes t \rightarrow R, \delta^* = \delta \otimes t \rightarrow \rho, \delta'^* = \delta' \otimes t \rightarrow \rho'$。
  由于 $t$ 的替换保持逻辑等价，因此结果根据引理 48.7 推导得出。

- **规则 (16.2e)**：
  假设 $\delta : \Phi, \delta' : \Phi, \eta : \delta \leftrightarrow \delta'$ 且 $\gamma \sim_\Gamma \gamma' [\eta : \delta \leftrightarrow \delta']$。根据归纳假设，我们有
  $$
  \hat{\gamma}(\delta^\wedge(e)) \sim_{\forall(t.\tau)} \gamma'(\delta'(e)) [\eta : \delta \leftrightarrow \delta']。
  $$
  令 $\hat{\rho} = \delta^\wedge(\rho)$ 和 $\hat{\rho}' = \delta'(\rho)$，定义关系 $R : \hat{\rho} \leftrightarrow \hat{\rho}'$，使得 $R(d, d')$ 成立当且仅当 $d \sim_\rho d' [\eta : \delta \leftrightarrow \delta']$。根据推论 48.9，该关系是可接受的。通过对多态类型的逻辑等价定义，我们得到
  $$
  \hat{\gamma}(\delta^\wedge(e))[\hat{\rho}] \sim_\tau \gamma'(\delta'(e))[\hat{\rho}'] [\eta \otimes t \rightarrow R : \delta \otimes t \rightarrow \hat{\rho} \leftrightarrow \delta' \otimes t \rightarrow \hat{\rho}']。
  $$
  根据引理 48.11，结果可以推导得出。

#### 解释：
- **参数化性定理**确保了每个表达式在其类型上下文中与自身逻辑等价。这一结果证明了多态系统的强约束条件下，表达式的一致性。
- 在证明中，通过归纳处理 $\forall$ 类型，并且通过构造关系 $R$ 解决了 $\rho$ 类型的解释问题。

---

### 推论 48.9 和 48.10 的解释：
- **推论 48.9**：表明当我们使用参数化逻辑等价时，关系 $e \sim_\tau e' [\eta : \delta \leftrightarrow \delta']$ 是封闭类型 $\delta^\wedge(\tau)$ 和 $\delta'(\tau)$ 之间的可接受关系。这一推论为参数化系统的构建提供了基础。
- **推论 48.10**：进一步说明了逻辑等价如何保持观察等价的性质。如果两个表达式在逻辑等价下保持一致，那么它们在观察等价的上下文中也会保持等价。

通过这些引理和定理的证明，参数化性为我们提供了多态系统中逻辑等价和观察等价的强大框架，确保在不同类型替换和求值过程中，表达式的一致性。

### ---------------------------------

### 推论 48.13 （**等价推论**）

**陈述**：如果 $ \Phi; \Gamma \vdash e \sim= e' : \tau $，那么 $ \Phi; \Gamma \vdash e \sim e' : \tau $。

**证明**：根据定理 48.12，$ \Phi; \Gamma \vdash e \sim e : \tau $，因此根据推论 48.10，我们有 $ \Phi; \Gamma \vdash e \sim e' : \tau $。

#### 解释：
- **推论**表明，观察等价（observational equivalence）是逻辑等价（logical equivalence）的直接后果。通过定理 48.12 的推导，我们首先知道每个表达式在其类型下与自身等价，而推论 48.10 确保了这种等价可以延伸到与另一个表达式的等价上。

---

### 引理 48.14 （**一致性引理**）

**陈述**：如果 $ \Phi; \Gamma \vdash e \sim e' : \tau $ 且 $ C : (\Phi; \Gamma * \tau) \vdash (\Phi'; \Gamma' * \tau') $，则 $ \Phi'; \Gamma' \vdash C{e} \sim C{e'} : \tau' $。

**证明**：通过对 $C$ 的结构进行归纳证明，沿用定理 48.12 的证明思路。

#### 解释：
- **组合性**表明，当我们将等价表达式代入到上下文（context）中时，它们仍然保持等价。这意味着等价关系在表达式的组合中是保持一致的，这是许多编程语言优化的基础。

---

### 引理 48.15 （**一致性引理**）

**陈述**：逻辑等价是一致的。

**证明**：直接根据逻辑等价的定义推导得出。

#### 解释：
- **一致性**确保逻辑等价不会引入任何矛盾，这使得它能够被安全地应用于不同的上下文中。

---

### 推论 48.16 （**等价推论**）

**陈述**：如果 $ \Phi; \Gamma \vdash e \sim e' : \tau $，那么 $ \Phi; \Gamma \vdash e \sim= e' : \tau $。

**证明**：根据引理 48.15，逻辑等价是一致的，并且根据引理 48.14，它是一个同构，因此它包含在观察等价中。

#### 解释：
- **推论**建立了逻辑等价与观察等价之间的紧密联系。如果两个表达式在逻辑等价下是等价的，它们在观察等价下也是等价的。

---

### 推论 48.17 （**逻辑等价和观察等价一致性**）

**陈述**：逻辑等价和观察等价是相同的。

**证明**：通过推论 48.13 和推论 48.16。

#### 解释：
- **推论**说明了逻辑等价与观察等价最终是相同的，这确保了两种等价关系在表达式的行为和求值上都是一致的。

---

### 推论 48.18 （**扩展性**）

1. $e \sim=_{\tau_1 \to \tau_2} e'$ 当且仅当对所有 $e_1 : \tau_1$，$e(e_1) \sim=_{\tau_2} e'(e_1)$。
2. $e \sim=_{\forall(t.\tau)} e'$ 当且仅当对于所有类型 $\rho$，$e[\rho] \sim=_{[\rho/t]\tau} e'[\rho]$。

**证明**：
- **正向证明**：这在两种情况下都是直接的，因为根据定义，观察等价是同构的。
- **反向证明**：通过对定理 48.12 的引用。在第一种情况下，根据推论 48.17，只需证明 $e \sim_{\tau_1 \to \tau_2} e'$。假设 $e_1 \sim_{\tau_1} e_1'$，我们要证明 $e(e_1) \sim_{\tau_2} e'(e_1')$。根据假设，我们有 $e(e_1') \sim=_{\tau_2} e'(e_1')$。根据参数化性，我们有 $e \sim_{\tau_1 \to \tau_2} e$，因此 $e(e_1) \sim_{\tau_2} e(e_1')$。结果根据引理 48.8 得出。

#### 解释：
- **扩展性**确保函数和多态表达式的等价可以通过其参数的等价来推导。这为处理高阶函数和多态类型提供了强有力的工具。

---

### 引理 48.19 （**身份扩展引理**）

**陈述**：设 $\eta : \delta \leftrightarrow \delta$ 是一个观察等价的关系，在 $\delta(t)$ 类型下每个 $t \in \text{dom}(\delta)$。则 $e \sim_\tau e' [\eta : \delta \leftrightarrow \delta]$ 当且仅当 $e \sim=\delta^\wedge(\tau) e'$。

**证明**：
- **反向方向**：通过定理 48.12 和对观察等价的尊重。
- **正向方向**：通过对 $\tau$ 结构的归纳证明，并通过推论 48.18 来建立函数和多态类型的观察等价。

#### 解释：
- **身份扩展**确保当我们在类型替代过程中保持观察等价时，表达式的等价性也会保持一致。这在处理复杂类型转换时是至关重要的。

### ---------------------------------

### 48.4 参数化性质（**Parametricity Properties**）

#### 定理 48.20

**陈述**：任意表达式 $e : \forall(t. t \to t)$，以及定义的身份函数 $id = \Lambda (t) \lambda (x : t) x$，则有 $e \sim=_{\forall(t. t \to t)} id$。

**证明**：
根据推论 48.17，我们只需证明 $e \sim_{\forall(t.t \to t)} id$。令 $\rho$ 和 $\rho'$ 为任意闭合类型，令 $R : \rho \leftrightarrow \rho'$ 为一个可接受的关系，并假设 $e_0 R e'_0$。我们需要证明
$$
e[\rho](e_0) R id[\rho](e'_0),
$$
给定 $id$ 的定义和逆向求值封闭性，这意味着
$$
e[\rho](e_0) R e'_0。
$$
我们只需证明 $e[\rho](e_0) \sim=_{\rho} e_0$，因为这样的话，结果可以通过 $R$ 的可接受性以及假设 $e_0 R e'_0$ 来得出。

根据定理 48.12，我们知道 $e \sim_{\forall(t.t \to t)} e$。令关系 $S : \rho \leftrightarrow \rho$ 定义为 $d S d' \iff d \sim=_{\rho} e_0$ 且 $d' \sim=_{\rho} e_0$。显然，$S$ 是可接受的关系，并且我们有 $e_0 S e_0$。因此，
$$
e[\rho](e_0) S e[\rho](e_0),
$$
由关系 $S$ 的定义可知，$e[\rho](e_0) \sim=_{\rho} e_0$。

#### 解释：
- **定理 48.20** 证明了类型 $\forall(t. t \to t)$ 下的任何表达式实际上等同于身份函数。这反映了参数化性的力量，因为多态性类型对行为施加了严格的约束。
  
---

#### 单位类型的强定义性

我们在第 16 章中定义了单位类型 $unit$：
$$
unit = \forall(r. r \to r)
$$
$$
\Lambda = \Lambda(r) \lambda(x : r) x
$$
由此定义可知，$\Lambda : unit$。这意味着单位类型是可居住的（即它至少有一个元素）。但我们还希望知道，**观察等价**下，表达式 $\Lambda$ 是该类型的唯一元素。这正是定理 48.20 的内容。我们说，单位类型在 $F$ 中是**强定义的**（**strongly definable**）。

#### 解释：
- **单位类型的强定义性**意味着，虽然多态函数可以有多个定义形式，但实际上只有一个函数符合这种类型的严格约束（即身份函数）。这种定义不仅正确，还在观察等价下唯一。

---

#### 二元积类型的强定义性

在第 16 章中，我们还定义了二元积类型 $ \tau_1 \times \tau_2 $：
$$
\tau_1 \times \tau_2 = \forall(r. (\tau_1 \to \tau_2 \to r) \to r)
$$
$$
\langle e_1, e_2 \rangle = \Lambda(r) \lambda (x : \tau_1 \to \tau_2 \to r) x(e_1)(e_2)
$$
$$
e \cdot l = e[\tau_1](\lambda (x : \tau_1) \lambda (y : \tau_2) x)
$$
$$
e \cdot r = e[\tau_2](\lambda (x : \tau_1) \lambda (y : \tau_2) y)
$$
通过直接计算，可以很容易验证：
$$
\langle e_1, e_2 \rangle \cdot l \sim=_{\tau_1} e_1
$$
$$
\langle e_1, e_2 \rangle \cdot r \sim=_{\tau_2} e_2
$$
我们希望证明如上定义的有序对是唯一的表达式，因此笛卡尔积在 $F$ 中是**强定义的**。

#### 解释：
- **二元积类型的强定义性**表明，在 $F$ 系统中，二元积不仅可以定义，而且对于给定的元素对，其表达方式是唯一的。这确保了多态系统中的稳定性和一致性。

接下来将利用定理 48.12 来推导出一个引理，说明积类型元素的行为。

### ---------------------------------

### 引理 48.21

**陈述**：如果 $e : \tau_1 \times \tau_2$，则存在某个 $e_1 : \tau_1$ 和 $e_2 : \tau_2$，使得 $e \sim=_{\tau_1 \times \tau_2} \langle e_1, e_2 \rangle$。

**证明**：

展开对偶与积类型的定义，应用推论 48.17，令 $\rho$ 和 $\rho'$ 为任意闭合类型，且 $R : \rho \leftrightarrow \rho'$ 为它们之间的一个可接受关系。进一步假设
$$
h \sim_{\tau_1 \to \tau_2 \to t} h' [\eta : \delta \leftrightarrow \delta'],
$$
其中 $\eta(t) = R, \delta(t) = \rho, \delta'(t) = \rho'$（每个定义均未对 $t \neq t$ 进行修改）。我们需要证明，存在某个 $e_1 : \tau_1$ 和 $e_2 : \tau_2$ 使得：
$$
e[\rho](h) \sim_t h'(e_1)(e_2) [\eta : \delta \leftrightarrow \delta'],
$$
即
$$
e[\rho](h) R h'(e_1)(e_2)。
$$

根据定理 48.12，我们有 $e \sim_{\tau_1 \times \tau_2} e$。定义关系 $S : \rho \leftrightarrow \rho'$，使得 $d S d'$ 当且仅当满足以下条件：
1. $d \sim=\rho h(d_1)(d_2)$ 对于某些 $d_1 : \tau_1$ 和 $d_2 : \tau_2$；
2. $d' \sim=\rho' h'(d'_1)(d'_2)$ 对于某些 $d'_1 : \tau_1$ 和 $d'_2 : \tau_2$；
3. $d R d'$。

显然，$S$ 是一个可接受的关系。注意到
$$
h \sim_{\tau_1 \to \tau_2 \to t} h' [\eta' : \delta \leftrightarrow \delta'],
$$
其中 $\eta'(t) = S$ 且 $\eta'(t')$ 未对 $t' \neq t$ 定义。我们可以得出 $e[\rho](h) S e[\rho'](h')$，因此有：
$$
e[\rho](h) R h'(d'_1)(d'_2)。
$$

假设 $e : \tau_1 \times \tau_2$ 且 $e \cdot l \sim=\tau_1 e_1$ 和 $e \cdot r \sim=\tau_2 e_2$。我们希望证明 $e \sim=\tau_1 \times \tau_2 \langle e_1, e_2 \rangle$。由引理 48.21 推导出 $e \sim=\tau_1 \times \tau_2 \langle e \cdot l, e \cdot r \rangle$，通过同余和直接计算得出。因此，通过同余我们得到 $e \sim=\tau_1 \times \tau_2 \langle e_1, e_2 \rangle$。

**解释**：
- **引理 48.21** 证明了对于积类型的任意表达式 $e$，都可以找到一对元素 $e_1$ 和 $e_2$ 使得 $e$ 可以表达为有序对 $\langle e_1, e_2 \rangle$。这是多态系统中积类型强定义性的证明，表明积类型的表达具有唯一性。

---

#### 自然数的教堂编码

接着我们利用类似的推理展示第 16 章中的自然数教堂编码（Church Encoding）如何强定义自然数，满足以下性质：

1. $iter \ z \{z \to e_0 \mid s(x) \to e_1\} \sim=\rho e_0$。
2. $iter \ s(e) \{z \to e_0 \mid s(x) \to e_1\} \sim=\rho [iter \ e \{z \to e_0 \mid s(x) \to e_1\}/x]e_1$。
3. 假设 $x : nat \vdash r(x) : \rho$。若：
   - $r(z) \sim=\rho e_0$，且
   - $r(s(e)) \sim=\rho [r(e)/x]e_1$，

   则对于任意 $e : nat$，我们有 $r(e) \sim=\rho iter \ e \{z \to e_0 \mid s(x) \to e_1\}$。

前两个等式可以通过直接计算使用第 16 章的定义轻松推导。第三个性质，即迭代器的唯一性（**unicity of the iterator**），可以通过参数化性证明，证明每个闭合的自然数表达式都与某个数字 $n$ 观察等价。接下来我们通过数学归纳法证明迭代器的唯一性。

---

### 引理 48.22

**陈述**：如果 $e : nat$，那么 $e \sim=_{nat} z$，或者存在 $e' : nat$ 使得 $e \sim=_{nat} s(e')$。因此，存在某个 $n \geq 0$ 使得 $e \sim=_{nat} n$。

**证明**：
根据定理 48.12，我们有 $e \sim_{nat} e$。定义关系 $R : nat \leftrightarrow nat$ 为最强的关系，使得 $d R d'$ 当且仅当以下条件成立：
- $d \sim=_{nat} z$ 且 $d' \sim=_{nat} z$；或者
- $d \sim=_{nat} s(d_1)$ 且 $d' \sim=_{nat} s(d'_1)$ 且 $d_1 R d'_1$。

显然，$z R z$，并且如果 $e R e'$，则 $s(e) R s(e')$。令 $zero = z$ 且 $succ = \lambda(x : nat) s(x)$，我们有
$$
e[nat](zero)(succ) R e[nat](zero)(succ)。
$$

结果通过由 $R$ 定义的关系的归纳原则推导而来。

**解释**：
- **引理 48.22** 证明了对于自然数类型的任意表达式 $e$，它要么是 $z$，要么可以表示为某个前一个自然数的后继 $s(e')$。通过这种推理，最终可以确定 $e$ 与某个具体的数字 $n$ 等价。

### ---------------------------------

### 第 48.5 节 表示独立性(Representation Independence)

本节回顾了**表示独立性 (Representation Independence)**的概念，这是在第 17.4 节讨论的抽象类型 (abstract types) 的属性。如果两种抽象类型的实现是“相似的”，那么客户端的行为不会因为将一种实现替换为另一种实现而受到影响。关键在于如何定义两种实现的**相似性 (similarity)**。

**定义 (Definition)**：  
对于抽象类型的两个实现，如果存在一个关系 $R$ 将它们的表示类型 (representation types) 联系起来，并且这个关系 $R$ 能够被类型的操作所保持，那么它们是相似的。这个关系 $R$ 表示两种表示的“等价性 (equivalence)”，验证每个操作是否保持 $R$ 相当于验证在等价表示上执行操作后得到的结果是否也是等价的。

#### 示例（Queues 例子）

在第 17.4 节中，我们以队列 (queue) 的抽象为例，论证了两种队列实现是相似的。两种队列表示的关系 $R$ 定义为 $q \ R \ (b, f)$，当且仅当 $q$ 是由 $b$ 组成的队列，紧接着是 $f$ 的反转（reversal）。然后我们证明了队列操作保持了这种关系，并提出结论：将一种实现替换为另一种实现不会影响客户端行为。

这一结论的证明依赖于**参数化性 (parametricity)**，如在 F 语言中定义存在类型 (existential types) 时所示。根据该定义，抽象类型 $\exists(t. \tau)$ 的客户端 $e$ 是类型为 $\forall(t. \tau \to \tau_2)$ 的多态函数，其中 $\tau_2$ 是不涉及类型变量 $t$ 的结果类型。

因为客户端是多态的，它具备定理 48.12 给出的**参数化性属性**。具体来说，假设 $\rho_1$ 和 $\rho_2$ 是两种闭合的表示类型，$R : \rho_1 \leftrightarrow \rho_2$ 是它们之间的可接受关系。例如，在队列的例子中，$\rho_1$ 是队列元素的列表类型，$\rho_2$ 是两个列表元素的对偶类型，$R$ 则是上述的关系。

进一步假设 $e_1 : [\rho_1/t] \tau$ 和 $e_2 : [\rho_2/t] \tau$ 是操作的两个实现，并且它们满足关系：
$$
e_1 \sim_{\tau} e_2 [\eta : \delta_1 \leftrightarrow \delta_2], \tag{48.5}
$$
其中 $\eta(t) = R, \delta_1(t) = \rho_1, \delta_2(t) = \rho_2$。

在队列例子中，表达式 $e_1$ 是基于列表实现的队列操作，而 $e_2$ 是基于成对列表的队列操作实现。条件 (48.5) 表示这两种实现是相似的，因为它们保持了表示类型之间的关系 $R$。

根据定理 48.12，我们可以推导出客户端 $e$ 满足：
$$
e \sim_{\tau_2} e [\eta : \delta_1 \leftrightarrow \delta_2]。
$$
由于 $\tau_2$ 是一个闭合类型（特别是不涉及 $t$），这等价于：
$$
e \sim_{\tau_2} e [\emptyset : \emptyset \leftrightarrow \emptyset]。
$$
由引理 48.19，我们有：
$$
e[\rho_1](e_1) \sim=_{\tau_2} e[\rho_2](e_2)。
$$
这表明客户端的行为不会因为表示的改变而受到影响。

### 详细解析：

1. **表示独立性 (Representation Independence)**: 表示独立性意味着，在抽象类型的实现中，如果两个不同的实现方式在一定关系下相似，那么从外部看来（即从客户端的角度），替换其中一个实现不会影响客户端的行为。这种独立性是通过验证实现之间的操作是否保持了某个等价关系来实现的。

2. **队列抽象 (Queue Abstraction)**: 以队列为例，队列可以有两种不同的表示方式，比如一种是简单的列表表示，另一种是由两个列表组成的表示（一个保存队列的前半部分，另一个保存后半部分）。两者之间的关系是，前者的队列等价于后者中两个列表的组合，后半部分列表是反转的。

3. **参数化性 (Parametricity)**: 参数化性是多态系统的一个核心性质，指的是程序的行为只依赖于它的类型，而不依赖于具体的类型实例。该性质确保了在多态类型系统中，不同的表示方式在某种等价关系下会表现一致。

4. **定理 48.12 的应用**: 定理 48.12 说明了多态类型系统中的参数化性，它确保了不同类型表示下的等价性能够通过逻辑等价 (logical equivalence) 和观察等价 (observational equivalence) 保持一致性。

5. **引理 48.19 的应用**: 引理 48.19 进一步保证了当类型系统中的关系满足一定条件时，逻辑等价也可以推导出观察等价，表明表示独立性得到了保障。

**总结**：这一节的结论表明，通过参数化性理论和存在类型的逻辑结构，我们可以证明抽象类型的实现可以在表示类型之间自由切换，而不会影响客户端的行为。这对于证明软件模块的表示独立性至关重要。

### ---------------------------------

### 第 48.6 节 备注 (Notes)

**参数化性 (Parametricity)** 的概念在 Girard (1972) 对**System F**的**归约 (Normalization)** 证明中隐含地体现出来。尽管 Reynolds (1983) 的研究由于依赖于一个**集合论模型 (set-theoretic model)**（该模型实际上并不存在）而在技术上有缺陷，他的研究突出了**逻辑等价 (logical equivalence)** 在刻画多态程序的等价性中的核心作用。

**参数化性**的应用不仅限于归纳证明，还扩展到了**表示独立性 (representation independence)**的问题。这一思想首先由 Reynolds 提出，并在**存在类型 (existential types)**的背景下由 Mitchell (1986) 和 Pitts (1998) 发展完善。表示独立性表明不同实现方式的抽象类型可以在保持一致的情况下相互替换，且不会影响程序的行为。

进一步地，将**System F** 扩展为具有“正的 (positive)”（即通过归纳定义的）**可观测类型 (observable types)** 似乎是定义**观察等价 (observational equivalence)** 所必需的。尽管这一点在其他文献中没有明确指出，但它显得十分重要。也就是说，为了能有效地描述多态类型程序的等价性，必须引入某种类型来允许对程序行为进行可观测的判定。

### 详细解析

1. **归约 (Normalization) 与 System F**: 
   - **归约** 是指一个程序可以通过一系列步骤归结到一个正常形式，意味着程序会终止或简化到最基本的形式。Girard 在 1972 年的研究中证明了 System F 中的类型系统是归约的，这意味着所有合法的程序在这个类型系统中都有一个正常形式，程序不会进入无限循环。
   - **System F** 是一种包含多态性 (polymorphism) 的类型系统，其核心是处理如何将类型作为参数传递给函数。参数化性是该系统中重要的理论基础。

2. **Reynolds 1983**: 
   - **Reynolds** 在 1983 年的研究中探讨了多态程序的等价性，他通过**逻辑等价**理论为刻画这些程序的行为奠定了基础。然而，他的工作依赖于一个假设，即存在一个可以容纳多态性的集合论模型，后来被证明是不存在的。但即便如此，Reynolds 强调了参数化性在多态系统中的重要性。

3. **表示独立性 (Representation Independence)**:
   - **表示独立性** 的概念确保了在不同表示（不同实现方式）下，抽象数据类型的操作是等价的。Mitchell 和 Pitts 在存在类型的背景下发展了这一理论。通过引入**参数化性**，他们能够证明，不同的实现只要保持等价关系，客户端程序的行为不会受到影响。这一思想对于软件模块化设计以及抽象数据类型的封装非常重要。

4. **观察等价 (Observational Equivalence)** 和正的可观测类型:
   - **观察等价** 表示两个程序在所有上下文中都表现一致。为了定义观察等价，系统需要能够通过某种方式观察到程序的行为结果。在多态系统中，往往没有直接的基本类型，因此为了定义观察等价，系统必须引入某种**正的 (positive)** 可观测类型，这些类型允许程序的行为结果能够被区分和观察。
   - 在 System F 的背景下，引入这些可观测类型是定义观察等价的必要步骤。

**总结**：本节回顾了参数化性和表示独立性的历史发展，并讨论了多态系统中定义等价性所需的技术。它强调了在多态程序中，参数化性对于确保程序行为一致性和定义观察等价至关重要。


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------
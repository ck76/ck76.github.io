[toc]



在 **Part III** 中，讨论了函数类型 (Function Types) 以及相关的编程语言概念，如函数定义、函数值以及更复杂的高阶函数 (Higher-Order Functions)。这一部分内容深入探讨了函数的静态语义 (statics) 和动态语义 (dynamics)，以及如何通过这些语义确保函数的定义性 (definability) 和不可定义性 (undefinability)。此外，还探讨了著名的**Gödel's T**和**Plotkin's PCF**语言的相关理论。

### **详解各章节内容**

#### **Function Types**
- **函数类型**主要讨论函数的类型系统，这包括如何对函数进行类型标注，如何从类型系统的角度分析函数的行为。类型系统不仅规定了函数的输入输出类型，还为函数调用时的行为提供了结构化的约束。
  
#### **Function Definitions and Values**
- **函数定义与函数值**：在编程语言中，函数是程序的基本构建块之一。讨论了如何定义函数，以及函数在程序执行过程中如何被看作值（即可以被传递、赋值或返回的对象）。
  
#### **First-Order Functions**
- **一阶函数**：指那些只接受值作为参数，并返回值作为结果的函数。在静态语言或类型安全语言中，一阶函数通常用于描述不涉及函数作为输入或输出的简单函数。

#### **Higher-Order Functions**
- **高阶函数**：高阶函数可以接受函数作为参数或返回函数作为结果。这是函数式编程的核心概念，允许程序更加灵活地处理代码和数据。高阶函数的定义、类型推导及其对编译器和解释器的要求会更复杂。

#### **Evaluation Dynamics and Definitional Equality**
- **评价动态与定义性等价**：评价动态描述了函数的执行过程。而定义性等价则指在函数式编程中，如何确定两个表达式是否在意义上等价（例如，通过简化、归纳等手段证明两个表达式最终计算出的值相同）。

#### **Dynamic Scope**
- **动态作用域**：在动态作用域下，函数的自由变量的绑定是在函数执行时确定的，而不是在函数定义时确定的。**动态作用域与词法作用域相对，后者是在函数定义时确定自由变量的绑定。**

#### **Gödel's T**
- **Gödel's T** 是一个形式化系统，旨在提供函数的可定义性和递归计算的模型。它的静态和动态语义分别描述了在这个系统中如何构建和执行函数。

#### **Plotkin's PCF**
- **Plotkin's PCF (Programming Computable Functions)** 是一种理论语言，用于研究计算和函数的形式化模型。其静态和动态语义在研究编程语言的功能性方面起到了关键作用。PCF 强调了可定义性和不可定义性的概念，即在某些情况下我们可以证明某个函数可以通过基础操作来定义，而在其他情况下则不能。

#### **Notes**
- 每一章的注释通常涉及该领域中的重要历史背景以及前人的工作。这些注释可能引用了早期的计算机科学家如**Gödel**、**Plotkin** 等人的贡献，这些都是函数理论及其在编程语言中应用的重要理论基础。

### **总结**
这一部分深入讨论了函数的概念，尤其是如何通过静态和动态语义分析函数的定义性和行为。这些理论对于理解现代编程语言，尤其是函数式编程语言的结构和设计非常重要。

### ---------------------------------

**静态语义**（statics）和**动态语义**（dynamics）是编程语言语义学中的两个核心概念，分别用于描述程序在**编译时**和**运行时**的行为。通过这两种语义，可以确保函数的**定义性**（definability）和**不可定义性**（undefinability）。在这方面，静态语义主要负责在编译时对程序的正确性进行检查，而动态语义则描述了程序在执行时的实际行为。

下面我们详细讨论函数的静态语义和动态语义，以及如何通过这些语义确保函数的定义性和不可定义性。

### 1. **静态语义（Statics）**

**静态语义**主要处理程序在**编译时**的语法和语义检查。它确保函数和表达式在**编译时**具有一致的类型和结构，并符合语言的类型规则。静态语义在语言的**类型系统**中尤为重要，保证了程序在执行前没有类型错误。

#### 静态语义的特点：
- **类型检查**：确保函数参数和返回值的类型一致，并遵守类型推导规则。
- **作用域管理**：确定变量和函数的作用域，避免变量未定义或重复定义。
- **类型安全**：在编译时确保程序的类型行为正确，防止运行时发生类型错误。

#### 示例：
考虑一个简单的函数定义：
```haskell
f :: Int -> Int
f x = x + 1
```

静态语义确保：
- 函数 `f` 的输入参数 `x` 是类型 `Int`，并且返回类型也是 `Int`。
- 表达式 `x + 1` 中，`x` 和 `1` 都是 `Int` 类型，因此相加操作合法。

#### 静态语义如何确保函数的**定义性**：
- **定义性**：在静态语义中，**定义性**意味着函数具有明确的类型，并且该函数在所有合法输入上都可以通过类型推导被成功定义。在静态语义层面，通过类型系统可以确保函数的参数类型和返回值类型一致，从而保证该函数在特定类型的输入下是**定义的**。

#### 静态语义下的**不可定义性**：
- **不可定义性**：如果函数的参数类型和返回值类型不匹配，或者函数中的某些表达式不能被类型系统推导出正确的类型，那么该函数在静态语义中是**不可定义的**。这种不可定义性通常表现为编译时的类型错误。

例如：
```haskell
f :: Int -> Int
f x = x + True
```
在这个例子中，`True` 是布尔类型，而 `x` 是 `Int` 类型，它们不能相加，因此编译器会在静态语义检查时给出类型错误，这表明函数 `f` 是不可定义的。

### 2. **动态语义（Dynamics）**

**动态语义**描述了程序在**运行时**的行为，解释了程序执行过程中如何对表达式进行求值，以及函数如何被调用和返回结果。动态语义通常通过**求值规则**来定义，说明了程序如何从一个状态演化到下一个状态。

#### 动态语义的特点：
- **求值规则**：描述表达式在运行时如何进行求值，例如函数调用如何展开，参数如何传递。
- **执行语义**：定义程序的运行行为，解释如何根据程序的语法和上下文进行逐步执行。
- **内存管理**：描述运行时如何处理变量绑定、内存分配和函数调用栈等。

#### 示例：
考虑以下函数：
```haskell
f x = x + 1
```
如果我们调用 `f 2`，动态语义将描述以下过程：
1. **求值 `f 2`**：将 `2` 传递给函数 `f` 的参数 `x`。
2. **展开 `x + 1`**：将 `x` 的值 `2` 代入到表达式 `x + 1` 中，得到 `2 + 1`。
3. **求值 `2 + 1`**：执行加法操作，结果为 `3`。

#### 动态语义如何确保函数的**定义性**：
- **定义性**：在动态语义中，函数的定义性意味着函数在运行时可以为每个合法输入计算出一个结果。动态语义的求值规则确保函数在执行过程中遵循求值策略，最终计算出结果。如果求值过程能正常结束并返回值，则该函数是**定义的**。

#### 动态语义下的**不可定义性**：
- **不可定义性**：如果一个函数在运行时遇到了无法处理的错误或无限递归等问题，导致程序无法计算出结果，则该函数是**不可定义的**。这类错误通常表现为运行时错误，如死循环、空指针异常或非法操作。

例如：
```haskell
f x = f x
```
在这个例子中，`f` 是一个递归函数，但没有基准情况来终止递归。根据动态语义，`f x` 将无限递归下去，导致程序进入死循环。这表明函数 `f` 是不可定义的，因为它没有为输入 `x` 计算出结果。

### 3. **通过静态和动态语义确保定义性和不可定义性**

#### 3.1 **通过静态语义确保定义性**

静态语义通过类型系统和语法规则，在编译时确保函数定义的正确性。例如：
- **类型一致性**：静态语义通过类型检查，确保函数的输入参数类型与返回值类型一致，防止类型不匹配的问题。
- **作用域检查**：静态语义会检查变量和函数的作用域，确保它们在正确的范围内被定义和使用。

静态语义的主要目标是在程序运行前通过类型检查等手段，尽早发现可能的错误，从而确保程序的**定义性**。

#### 3.2 **通过动态语义确保定义性**

动态语义通过描述函数的运行行为，确保在执行时函数能够为合法的输入产生结果。例如：
- **求值规则**：动态语义通过求值规则描述函数的执行步骤，从参数绑定到表达式求值，确保程序能够执行完毕并返回值。
- **错误处理**：动态语义还可以定义错误处理机制，确保在出现运行时错误时，程序能够正确终止或给出有意义的错误信息。

#### 3.3 **不可定义性在静态和动态语义中的表现**

- **静态语义中的不可定义性**：如果函数在编译时未通过类型检查（例如类型不匹配），则该函数在静态语义中是不可定义的。此时，编译器会报告类型错误，阻止程序继续编译和运行。
- **动态语义中的不可定义性**：如果函数在运行时遇到了未定义的行为（例如无限递归、运行时类型错误等），则该函数在动态语义中是不可定义的。此时，程序会崩溃或进入死循环。

### 4. **静态与动态语义的互补性**

- **静态语义**在编译时尽早发现函数的错误，确保函数在定义时满足类型约束和语法规则。这是一种预防性机制。
- **动态语义**在运行时确保函数按照定义的求值规则执行，返回正确的结果。动态语义描述了程序的实际行为。

通过结合静态语义和动态语义，我们可以在编译时尽早检测错误，并在运行时确保程序的正确性，从而保证函数的定义性。

### 5. **总结**

- **静态语义**在编译时通过类型系统和作用域规则确保函数的**定义性**，防止函数出现类型错误或语法不一致的问题。函数的**不可定义性**在静态语义中表现为类型不匹配、变量未定义等编译时错误。
- **动态语义**描述了函数在运行时的行为，确保函数能够为合法输入计算出结果。函数的**不可定义性**在动态语义中表现为运行时错误、无限递归或未定义行为。

通过静态和动态语义的结合，可以有效确保编程语言中函数的正确性，确保其定义性，同时避免不可定义的情况出现。

### ------------------------------------

下面是从多个角度详细比较**函数的静态语义**和**动态语义**，以及它们如何确保函数的**定义性**和**不可定义性**的对比表格：

| **对比维度**         | **静态语义 (Statics)**                                       | **动态语义 (Dynamics)**                                      |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **定义**             | 编译时通过类型检查、作用域规则确保程序的正确性               | 运行时通过求值规则描述程序的实际执行过程                     |
| **主要任务**         | 在**编译时**确保程序的语法和类型正确                         | 在**运行时**定义程序的行为，描述如何计算和求值               |
| **作用阶段**         | **编译阶段**，在程序运行之前进行静态分析和检查               | **运行阶段**，在程序执行时进行实际计算                       |
| **检查内容**         | - 类型检查<br> - 作用域检查<br> - 语法规则检查               | - 表达式求值<br> - 函数调用<br> - 运行时内存管理             |
| **主要工具**         | - 类型系统<br> - 上下文无关文法                              | - 求值规则<br> - 状态转移规则<br> - 内存模型                 |
| **定义性**           | **定义性**由类型系统保证，确保函数在编译时通过类型检查       | **定义性**由求值规则保证，确保程序运行时产生一个合法结果     |
| **不可定义性**       | 如果类型不一致或变量未定义，编译时会报错，导致**不可定义性** | 如果在运行时遇到死循环、未处理的错误，程序将进入**不可定义性**状态 |
| **典型错误**         | - 类型不匹配<br> - 变量未定义<br> - 函数签名与实现不符       | - 运行时异常<br> - 无限递归<br> - 空指针或分配错误           |
| **静态/动态的优点**  | - 在编译时发现错误，减少运行时错误的发生                     | - 描述程序的运行行为，确保程序执行产生合法结果               |
| **静态/动态的缺点**  | - 某些错误可能无法在编译时被捕获，需要运行时进一步检查       | - 程序可能在运行时发生错误，某些问题只能在运行时发现         |
| **确保定义性的机制** | - 通过类型检查和作用域管理，确保函数的参数和返回值一致       | - 通过求值策略和函数调用规则，确保函数能在运行时计算结果     |
| **处理无限递归**     | 静态语义中难以检测无限递归，依赖于动态语义处理               | 运行时会导致程序进入无限循环，函数无法完成求值               |
| **多态函数的处理**   | 静态语义可以通过类型推导和类型检查确保多态函数的正确性       | 动态语义通过求值规则确保多态函数在运行时处理不同的类型输入   |
| **类型安全性**       | 编译时保证类型安全性，防止类型错误                           | 运行时类型错误导致程序崩溃或异常                             |
| **不可定义性举例**   | - 类型不匹配：`f :: Int -> Int; f x = x + True`              | - 无限递归：`f x = f x`                                      |
| **处理函数调用**     | 在静态语义中确保函数签名、参数类型和返回值的正确性           | 动态语义中通过求值策略执行函数调用，处理参数传递和求值       |
| **处理内存管理**     | 静态语义不直接处理内存分配，依赖于运行时动态语义             | 动态语义负责处理内存分配、函数调用栈管理以及垃圾回收         |
| **错误检测机制**     | **编译时**通过类型检查、语法检查捕获大部分错误               | **运行时**通过异常机制、求值规则捕获错误                     |
| **语言设计中的作用** | - 强类型语言中通过静态语义保证程序的类型安全性               | - 解释器和虚拟机通过动态语义描述程序的运行行为               |
| **典型语言示例**     | Haskell、OCaml、Java 等具有**静态类型检查**的语言            | Python、Ruby 等**动态类型语言，运行时解释和执行**            |
| **优化的支持**       | 静态语义支持编译器优化，通过类型信息做静态分析优化           | 动态语义通过实际运行时的行为分析进行优化，例如 JIT 编译      |

### 关键点详细解释：

1. **定义性（Definability）**：
   - **静态语义**确保函数的定义性通过类型检查来保证，即在编译时确保函数的参数和返回类型一致，并且语法正确。静态语义通过编译器的类型系统，在程序运行之前捕获大多数错误。
   - **动态语义**在程序运行时确保函数的定义性，即通过求值规则来解释程序的执行步骤，确保函数能够为合法输入产生结果。如果在运行时能够正常计算出结果，则函数是定义的。

2. **不可定义性（Undefinability）**：
   - **静态语义下的不可定义性**表现为类型检查失败，函数签名不匹配，或未定义的变量使用。例如，在 Haskell 中如果函数参数类型与实现不一致，编译时会产生错误，表明该函数在编译时是不可定义的。
   - **动态语义下的不可定义性**表现为运行时无法计算出结果，如出现无限递归、空指针异常等。运行时未定义的行为将导致程序崩溃或进入死循环。

3. **类型安全性**：
   - **静态语义**的一个重要目标是保证**类型安全性**，防止运行时出现类型错误。例如，在强类型语言中，编译器通过类型检查确保每个表达式的类型与上下文一致。
   - **动态语义**关注运行时的类型错误检测，例如在动态类型语言（如 Python）中，类型错误会在运行时抛出异常。

4. **多态函数的处理**：
   - **静态语义**支持通过类型推导和类型检查来处理多态函数。例如，在 Haskell 中，可以使用类型变量来表示多态函数，并在编译时推导出具体的类型。
   - **动态语义**则在运行时处理多态性，通过运行时的求值规则为不同类型的输入生成对应的结果。

5. **无限递归与不可定义性**：
   - **静态语义**通常无法检测无限递归的情况，因为递归函数的基准情况可能需要在运行时才能确定。
   - **动态语义**在处理无限递归时，程序将进入死循环，导致函数不可定义，程序无法终止。

6. **优化支持**：
   - **静态语义**通过编译时的类型信息，可以进行静态优化，例如常量折叠、死代码消除等。
   - **动态语义**则通过运行时分析进行优化，例如 JIT 编译，可以根据程序的实际运行情况进行动态优化。

### 总结：

通过结合**静态语义**和**动态语义**，编程语言能够有效地确保函数的定义性。**静态语义**在编译阶段通过类型检查、作用域规则和语法检查来预防错误，而**动态语义**在程序运行时描述函数的求值过程和运行时行为。两者结合能够为编程语言提供强大的类型安全性和运行时行为的保证，防止函数的不可定义性问题出现。

### ------------------------------

在 **Chapter 8** 中，重点讨论了函数定义 (Function Definitions) 和函数作为值 (Function Values) 的概念。这一章的内容主要涉及编程语言中的函数式抽象以及如何在程序中使用变量和函数来进行运算，特别是对于语言 **L{num str}** 的扩展。这里的讨论分为几部分，分别介绍了**一阶函数 (First-Order Functions)** 和**高阶函数 (Higher-Order Functions)**，以及函数在不同上下文中的行为，如**动态作用域 (Dynamic Scope)**。

### **详解：Function Definitions and Values**

#### **变量抽象与函数定义**
最开始讨论的是如何在语言 **L{num str}** 中通过引入变量来进行抽象。比如，**“加倍”运算**可以被抽象为对任意数字的加倍，而不需要针对特定数字进行运算。这种抽象通过引入一个变量来代替具体的数字，该变量代表了一个未指定的数字。

- **变量 (Variables)**：在表达式中使用变量来抽象掉某个具体的值，以便通过替换该变量来生成不同的实例。比如，可以用变量 $x$ 表示任意数字，从而可以定义一个加倍函数 $f(x) = 2 \times x$。
- **替换 (Substitution)**：函数的关键在于通过将变量替换为具体的值来获得不同的函数结果。比如，$f(3) = 2 \times 3 = 6$。

#### **函数定义与应用**
- **函数定义 (Function Definition)**：通过绑定一个名字到一个函数体来定义函数，该函数体是一个以变量为参数的抽象语法树 (abstract binding tree, abt)。例如，定义一个加倍函数可以表示为 $f(x) = 2 \times x$。
- **函数应用 (Function Application)**：通过为函数的变量传递具体的表达式来应用函数。例如，应用 $f(3)$ 这个函数时，将变量 $x$ 替换为 $3$，最终计算出 $2 \times 3 = 6$。

#### **一阶函数 (First-Order Functions)**
- **一阶函数**是指接受数字或字符串作为输入并返回数字或字符串的函数。在 **L{num str}** 语言中，一阶函数的输入和输出仅限于基本类型 (如 $num$ 和 $str$)。一阶函数的特征在于它们不接受其他函数作为参数，也不返回函数作为结果。
  
  示例：
  - 加倍函数：$f(x) = 2 \times x$
  - 字符串连接函数：$g(s_1, s_2) = s_1 \texttt{ concat } s_2$

#### **高阶函数 (Higher-Order Functions)**
- **高阶函数**可以接受函数作为参数，或者返回一个函数。高阶函数的引入大大增强了语言的表达能力，使得函数可以被视为一等公民 (first-class citizens)。高阶函数允许更高层次的抽象，可以方便地表示诸如映射、过滤等操作。

  示例：
  - 映射函数：$map(f, [x_1, x_2, \dots, x_n]) = [f(x_1), f(x_2), \dots, f(x_n)]$。该函数接受一个函数 $f$ 和一个列表作为参数，并对列表中的每个元素应用 $f$。
  
#### **函数类型 (Function Types)**
函数的输入和输出类型都是通过**函数类型**来表达的。比如，一个接受数字并返回数字的函数类型可以表示为：
$$
\tau = num \to num
$$
这种类型表达了一个从 $num$ 类型映射到 $num$ 类型的函数。同理，高阶函数的类型可以是函数到函数的映射，比如：
$$
\tau = (num \to num) \to num
$$

#### **动态绑定 (Dynamic Binding)**
历史上，高阶函数的引入还导致了一个设计错误，这个错误后来被重新解释为一个特性，称为**动态绑定 (Dynamic Binding)**。这个错误来源于替换的定义错误，没有避免**变量捕获 (Capture)**，使得绑定变量的名字变得重要，而这违反了**绑定变量名称不重要的基本原则**。

- **变量捕获**：在替换过程中，若不小心将某个变量的作用域引入到了错误的上下文中，可能导致绑定的变量名称被“捕获”，引发意外的行为。为了避免这种情况，编程语言设计中需要特别小心地处理变量作用域和替换。

### **小结**
本章介绍了**L{num str}** 语言中的函数定义和使用，特别是如何通过变量抽象来定义一阶和高阶函数。此外，讨论了**动态绑定**问题以及如何正确地处理函数中的变量替换问题。这些概念是理解函数式编程的基础，尤其是在处理变量作用域和高阶函数时。

### ---------------------------------

### 8.1 一阶函数（First-Order Functions）

本节介绍了语言 **L{num str fun}**，这是在 **L{num str}** 的基础上扩展了**函数定义**（function definitions）和**函数应用**（function applications）的语言。通过以下的语法描述，我们可以了解新增的语法构造：

#### **扩展的语法规则**

表达式（Exp）定义：

$$
e ::= \text{call}[\, f\, ](e) \quad \text{函数调用 (call)} \\
\quad\quad\quad \text{fun}[\tau_1; \tau_2](x_1.e_2; f.e) \quad \text{函数定义 (definition)}
$$

其中：

- **函数调用**形式：$\text{call}[\, f\, ](e)$ 或者简写为 $f(e)$。
- **函数定义**形式：$\text{fun}[\tau_1; \tau_2](x_1.e_2; f.e)$，表示在表达式 $e$ 中定义了函数 $f$，其参数为 $x_1$，函数体为 $e_2$，参数类型为 $\tau_1$，返回类型为 $\tau_2$。

#### **函数定义中的符号解释**

- $\text{fun}[\tau_1; \tau_2](x_1.e_2; f.e)$：

  - **$\tau_1$**：函数的参数类型（domain type）。
  - **$\tau_2$**：函数的返回类型（range type）。
  - **$x_1$**：函数的参数变量。
  - **$e_2$**：函数的定义，即函数体。
  - **$f$**：函数名称，在表达式 $e$ 中绑定。
  - **$e$**：函数 $f$ 在其中有效的表达式。

- **函数调用** $\text{call}[\, f\, ](e)$：

  - **$f$**：被调用的函数名称。
  - **$e$**：传递给函数的实参表达式。

#### **静态语义（Statics）**

**L{num str fun}** 的静态语义定义了两种判断形式：

1. **表达式类型判断**：$e : \tau$，表示表达式 $e$ 的类型为 $\tau$。
2. **函数类型判断**：$f (\tau_1) : \tau_2$，表示函数 $f$ 的参数类型为 $\tau_1$，返回类型为 $\tau_2$。

函数类型判断 $f (\tau_1) : \tau_2$ 被称为函数的**函数头**（function header），它明确了函数的定义域类型（domain type）和值域类型（range type）。

#### **静态语义的推导规则**

**规则 (8.1a)：函数定义的类型推导**

$$
\frac{\Gamma, x_1 : \tau_1 \vdash e_2 : \tau_2 \quad \Gamma, f (\tau_1) : \tau_2 \vdash e : \tau}{\Gamma \vdash \text{fun}[\tau_1; \tau_2](x_1.e_2; f.e) : \tau} \quad (8.1a)
$$

**解释**：

- **前提条件**：

  - $\Gamma, x_1 : \tau_1 \vdash e_2 : \tau_2$：在上下文 $\Gamma$ 中，加上参数 $x_1$ 类型为 $\tau_1$，可以推导出函数体 $e_2$ 的类型为 $\tau_2$。
  - $\Gamma, f (\tau_1) : \tau_2 \vdash e : \tau$：在上下文 $\Gamma$ 中，加上函数 $f$ 的类型（参数类型为 $\tau_1$，返回类型为 $\tau_2$），可以推导出表达式 $e$ 的类型为 $\tau$。

- **结论**：

  - $\Gamma \vdash \text{fun}[\tau_1; \tau_2](x_1.e_2; f.e) : \tau$：因此，可以在上下文 $\Gamma$ 中推导出整个函数定义表达式的类型为 $\tau$。

**规则 (8.1b)：函数调用的类型推导**

$$
\frac{\Gamma \vdash f (\tau_1) : \tau_2 \quad \Gamma \vdash e : \tau_1}{\Gamma \vdash \text{call}[\, f\, ](e) : \tau_2} \quad (8.1b)
$$

**解释**：

- **前提条件**：

  - $\Gamma \vdash f (\tau_1) : \tau_2$：在上下文 $\Gamma$ 中，函数 $f$ 的类型已知（参数类型为 $\tau_1$，返回类型为 $\tau_2$）。
  - $\Gamma \vdash e : \tau_1$：表达式 $e$ 的类型为 $\tau_1$，与函数 $f$ 的参数类型匹配。

- **结论**：

  - $\Gamma \vdash \text{call}[\, f\, ](e) : \tau_2$：因此，函数调用表达式的类型为 $\tau_2$，即函数的返回类型。

#### **函数替换（Function Substitution）**

函数替换的记号为 $[[x.e/f]]e_0$，表示在表达式 $e_0$ 中，用 $x.e$ 替换函数名 $f$。它的定义类似于普通的替换，但需要注意的是，函数名 $f$ 并不是一种表达式形式，它只能出现在形如 $\text{call}[\, f\, ](e)$ 的函数调用中。

**函数调用的替换规则**：

$$
[[x.e/f]]\text{call}[\, f\, ](e_0) = \text{let}([[x.e/f]]e_0; x.e) \quad (8.2)
$$

**解释**：

- 在函数调用 $\text{call}[\, f\, ](e_0)$ 中，使用函数替换后，得到一个 $\text{let}$ 表达式：
  - 先对参数表达式 $e_0$ 进行函数替换，得到 $[[x.e/f]]e_0$。
  - 然后，将结果绑定到变量 $x$，并在表达式 $x.e$ 中使用。

- 这意味着，在函数调用的地方，将函数替换为一个 $\text{let}$ 表达式，便于展开函数体，并替换参数。

#### **引理 8.1**

**陈述**：

如果 $\Gamma, f (\tau_1) : \tau_2 \vdash e : \tau$ 且 $\Gamma, x_1 : \tau_1 \vdash e_2 : \tau_2$，那么 $\Gamma \vdash [[x_1.e_2/f]]e : \tau$。

**证明**：

- **方法**：对表达式 $e$ 的结构进行归纳（induction on the structure of $e$）。
- **结论**：通过归纳，可以证明在上下文 $\Gamma$ 中，替换后的表达式 $[[x_1.e_2/f]]e$ 的类型仍然为 $\tau$。

#### **动态语义（Dynamics）**

**L{num str fun}** 的动态语义通过函数替换来定义。

**规则 (8.3)：函数定义的求值**

$$
\text{fun}[\tau_1; \tau_2](x_1.e_2; f.e) \rightarrow [[x_1.e_2/f]]e \quad (8.3)
$$

**解释**：

- 该规则表示，在对函数定义进行求值时，直接用函数替换 $[[x_1.e_2/f]]e$ 来替换原始表达式。
- 因为函数替换会将所有对 $f$ 的调用替换为适当的 $\text{let}$ 表达式，所以不需要单独为函数调用给出求值规则。

#### **安全性（Safety）**

**L{num str fun}** 的安全性可以（虽然需要一些工作）从高阶函数的安全性定理中推导出来，我们将在下一节讨论高阶函数的安全性。

### **小结**

本节介绍了 **L{num str fun}** 语言的扩展，增加了函数定义和函数调用的能力。通过定义函数的静态语义（类型规则）和动态语义（求值规则），以及函数替换的机制，我们能够在语言中使用一阶函数，对程序进行更加抽象和模块化的设计。

---

**关键概念总结**：

- **一阶函数（First-Order Function）**：只接受基本类型（如数字、字符串）作为参数，返回基本类型的函数。
- **函数定义（Function Definition）**：使用 $\text{fun}[\tau_1; \tau_2](x_1.e_2; f.e)$ 的形式，在表达式 $e$ 中定义了一个函数 $f$。
- **函数调用（Function Call）**：使用 $\text{call}[\, f\, ](e)$ 的形式，调用函数 $f$，传入参数表达式 $e$。
- **函数替换（Function Substitution）**：用 $[[x.e/f]]e_0$ 表示在 $e_0$ 中用 $x.e$ 替换函数名 $f$。
- **静态语义（Statics）**：通过类型推导规则，确定表达式和函数的类型。
- **动态语义（Dynamics）**：通过求值规则，定义表达式的计算过程。

### ---------------------------------

### 8.2 高阶函数（Higher-Order Functions）

在 **L{num str fun}** 中，变量定义和函数定义的语法和语义具有非常相似的结构。这个观察提示我们，可能可以将这两者整合为一个统一的定义机制。要做到这一点，我们需要打破函数和表达式之间的隔离，将函数抽象器（abstractor）转化为一种表达式形式，这种表达式形式被称为**$\lambda$-抽象**（lambda-abstraction），记作 $\text{lam}[\tau_1](x.e)$。相应地，我们还要将函数应用推广为形式 $\text{ap}(e_1; e_2)$，其中 $e_1$ 可以是任意表达式，而不仅仅是函数名。这分别对应了**函数类型**的引入形式（introduction form）和消除形式（elimination form），即 $\text{arr}(\tau_1; \tau_2)$，表示类型 $\tau_1 \to \tau_2$ 的函数。

#### **扩展语法**

我们通过以下文法对 **L{num str →}** 语言进行扩展，这个语言支持函数类型：

$$
\text{Typ} \ \tau ::= \text{arr}(\tau_1; \tau_2) \quad \tau_1 \to \tau_2 \quad \text{(函数类型)}
$$

$$
\text{Exp} \ e ::= \text{lam}[\tau](x.e) \quad \lambda (x: \tau) e \quad \text{(抽象)}
$$

$$
\text{ap}(e_1; e_2) \quad e_1(e_2) \quad \text{(应用)}
$$

#### **函数作为一等公民**

在 **L{num str →}** 语言中，函数成为了**一等公民**（first class），意味着函数本身是函数类型的表达式。这为我们构建更高阶的抽象提供了基础，函数不仅可以作为参数传递，还可以作为返回值。

#### **静态语义（Statics）**

**L{num str →}** 的静态语义通过扩展之前的规则来定义。这些规则定义了如何为 $\lambda$-抽象和函数应用进行类型推导。

##### **规则 (8.4a)：$\lambda$-抽象的类型推导**

$$
\frac{\Gamma, x : \tau_1 \vdash e : \tau_2}{\Gamma \vdash \text{lam}[\tau_1](x.e) : \text{arr}(\tau_1; \tau_2)} \quad (8.4a)
$$

**解释**：

- **前提条件**：在上下文 $\Gamma$ 中，给定 $x$ 的类型为 $\tau_1$，可以推导出表达式 $e$ 的类型为 $\tau_2$。
- **结论**：因此，$\lambda$-抽象 $\text{lam}[\tau_1](x.e)$ 的类型是 $\text{arr}(\tau_1; \tau_2)$，即从 $\tau_1$ 到 $\tau_2$ 的函数类型。

##### **规则 (8.4b)：函数应用的类型推导**

$$
\frac{\Gamma \vdash e_1 : \text{arr}(\tau_2; \tau) \quad \Gamma \vdash e_2 : \tau_2}{\Gamma \vdash \text{ap}(e_1; e_2) : \tau} \quad (8.4b)
$$

**解释**：

- **前提条件**：
  - 在上下文 $\Gamma$ 中，$e_1$ 的类型为 $\text{arr}(\tau_2; \tau)$，即从 $\tau_2$ 到 $\tau$ 的函数。
  - $e_2$ 的类型为 $\tau_2$，与函数 $e_1$ 的参数类型匹配。
- **结论**：因此，函数应用 $\text{ap}(e_1; e_2)$ 的类型为 $\tau$，即函数的返回类型。

#### **引理 8.2：类型推导的逆转性（Inversion）**

该引理说明了如何通过类型推导的规则来逆推出表达式的结构。

##### **结论**：

1. 如果 $\Gamma \vdash e : \tau$，且 $e = \text{lam}[\tau_1](x.e_2)$，那么 $\tau = \text{arr}(\tau_1; \tau_2)$，且 $\Gamma, x : \tau_1 \vdash e_2 : \tau_2$。
2. 如果 $\Gamma \vdash e = \text{ap}(e_1; e_2)$，那么存在某个 $\tau_2$，使得 $\Gamma \vdash e_1 : \text{arr}(\tau_2; \tau)$，且 $\Gamma \vdash e_2 : \tau_2$。

##### **证明**：

通过对类型推导规则的归纳证明。对于每条规则，只有一个情况适用，规则的前提提供了我们需要的结果。

#### **引理 8.3：替换（Substitution）**

**陈述**：

如果 $\Gamma, x : \tau \vdash e_0 : \tau_0$ 且 $\Gamma \vdash e : \tau$，那么 $\Gamma \vdash [e/x]e_0 : \tau_0$。

##### **证明**：

通过对第一个判断的推导进行规则归纳（rule induction）证明。

#### **动态语义（Dynamics）**

**L{num str →}** 的动态语义在 **L{num str}** 的基础上增加了几条规则，处理 $\lambda$-抽象和函数应用的求值。

##### **规则 (8.5a)：$\lambda$-抽象的值**

$$
\text{lam}[\tau](x.e) \ \text{val} \quad (8.5a)
$$

- **解释**：$\lambda$-抽象是一个值，这意味着在没有应用的情况下，$\lambda$ 表达式不再继续求值。

##### **规则 (8.5b)：函数应用的左部求值**

$$
\frac{e_1 \to e_1'}{\text{ap}(e_1; e_2) \to \text{ap}(e_1'; e_2)} \quad (8.5b)
$$

- **解释**：如果函数 $e_1$ 可以求值为 $e_1'$，则函数应用 $\text{ap}(e_1; e_2)$ 可以求值为 $\text{ap}(e_1'; e_2)$。

##### **规则 (8.5c)：函数应用的右部求值**

$$
\frac{e_2 \to e_2'}{\text{ap}(e_1; e_2) \to \text{ap}(e_1; e_2')} \quad (8.5c)
$$

- **解释**：如果参数 $e_2$ 可以求值为 $e_2'$，则函数应用 $\text{ap}(e_1; e_2)$ 可以求值为 $\text{ap}(e_1; e_2')$，前提是 $e_1$ 是一个值。

##### **规则 (8.5d)：函数应用的求值（实参替换）**

$$
\frac{e_2 \ \text{val}}{\text{ap}(\text{lam}[\tau_2](x.e_1); e_2) \to [e_2/x]e_1} \quad (8.5d)
$$

- **解释**：如果 $e_2$ 是一个值，则函数应用 $\text{ap}(\text{lam}[\tau_2](x.e_1); e_2)$ 可以通过将实参 $e_2$ 替换到函数体 $e_1$ 中来求值。

#### **安全性定理**

##### **定理 8.4：保持性（Preservation）**

**陈述**：如果 $e : \tau$ 且 $e \to e_0$，那么 $e_0 : \tau$。

**证明**：通过对规则 (8.5) 进行归纳证明。特别是对于规则 (8.5d)，假设 $\text{ap}(\text{lam}[\tau_2](x.e_1); e_2) : \tau_1$，根据引理 8.2 可以推导出 $e_2 : \tau_2$ 且 $x : \tau_2 \vdash e_1 : \tau_1$，因此根据引理 8.3，有 $[e_2/x]e_1 : \tau_1$。

##### **引理 8.5：规范形式（Canonical Forms）**

**陈述**：如果 $e : \text{arr}(\tau_1; \tau_2)$ 且 $e \ \text{val}$，

那么 $e = \lambda (x : \tau_1) e_2$，其中 $x$ 是某个变量，$e_2$ 是某个表达式，且 $x : \tau_1 \vdash e_2 : \tau_2$。

**证明**：通过对类型推导规则进行归纳，并利用 $e \ \text{val}$ 的假设。

##### **定理 8.6：进展性（Progress）**

**陈述**：如果 $e : \tau$，那么要么 $e \ \text{val}$，要么存在 $e_0$ 使得 $e \to e_0$。

**证明**：通过对规则 (8.4) 进行归纳证明。特别是对于规则 (8.4b)，根据归纳假设，要么 $e_1 \ \text{val}$，要么存在 $e_1' \to e_1$。在前一种情况下，利用引理 8.5，可以得出 $e_1 = \lambda (x : \tau_2) e$，因此 $\text{ap}(e_1; e_2) \to [e_2/x]e$。

### ---------------------------------

### 定理 8.4：保持性（Preservation）

**陈述**：如果 $e : \tau$ 且 $e \to e_0$，那么 $e_0 : \tau$。

**证明**：证明通过对规则 **(8.5)** 进行归纳，这些规则定义了语言的动态语义。

让我们特别关注规则 **(8.5d)**，即函数应用的求值规则：

$$
\text{ap}(\text{lam}[\tau_2](x.e_1); e_2) \to [e_2/x]e_1 \quad (8.5d)
$$

假设 $\text{ap}(\text{lam}[\tau_2](x.e_1); e_2) : \tau_1$。根据 **引理 8.2**，我们可以得出 $e_2 : \tau_2$，并且 $x : \tau_2 \vdash e_1 : \tau_1$。这意味着 $e_2$ 的类型与 $\lambda$-抽象的参数类型匹配，且在上下文 $x : \tau_2$ 下，$e_1$ 的类型为 $\tau_1$。接着，根据 **引理 8.3**，我们知道替换 $[e_2/x]e_1 : \tau_1$，因此 $e_0 : \tau_1$。

其他涉及函数应用的规则（例如 (8.5b) 和 (8.5c)）通过类似的方式处理。

---

### 引理 8.5：规范形式（Canonical Forms）

**陈述**：如果 $e : \text{arr}(\tau_1; \tau_2)$ 且 $e$ 是一个值（$e \ \text{val}$），那么 $e = \lambda (x : \tau_1) e_2$，其中 $x$ 是某个变量，$e_2$ 是某个表达式，且 $x : \tau_1 \vdash e_2 : \tau_2$。

**证明**：通过对类型推导规则进行归纳，并结合 $e \ \text{val}$ 的假设，我们可以推导出 $e$ 必须是一个 $\lambda$-抽象。这是因为对于函数类型 $\text{arr}(\tau_1; \tau_2)$ 的值，唯一可能的形式是 $\lambda$-抽象，表示一个从类型 $\tau_1$ 到类型 $\tau_2$ 的函数。

---

### 定理 8.6：进展性（Progress）

**陈述**：如果 $e : \tau$，那么要么 $e \ \text{val}$，要么存在 $e_0$ 使得 $e \to e_0$。

**证明**：通过对规则 **(8.4)** 进行归纳证明。在这个过程中，我们考虑的是闭合项（closed terms），因此在推导过程中没有附加假设。

特别地，考虑规则 **(8.4b)**（在按名称求值的解释下）。根据归纳假设，要么 $e_1 \ \text{val}$，要么存在 $e_1' \to e_1$。如果是后者，那么我们可以推导出 $\text{ap}(e_1; e_2) \to \text{ap}(e_1'; e_2)$。

如果是前者，我们根据 **引理 8.5** 知道 $e_1 = \lambda (x : \tau_2) e$，因此 $\text{ap}(e_1; e_2) \to [e_2/x]e$。

---

### 公式讲解：

对于定理中的规则推导，我们可以通过推导树的形式表示这些推导关系。

- 规则 **(8.5d)** 中的推导可以表示为：
  $$
  \frac{e_2 \ \text{val}}{\text{ap}(\text{lam}[\tau_2](x.e_1); e_2) \to [e_2/x]e_1} \quad (8.5d)
  $$

- 规则 **(8.4a)** 中 $\lambda$-抽象的类型推导可以表示为：
  $$
  \frac{\Gamma, x : \tau_1 \vdash e : \tau_2}{\Gamma \vdash \text{lam}[\tau_1](x.e) : \text{arr}(\tau_1; \tau_2)} \quad (8.4a)
  $$

通过这些推导规则，我们可以确保函数应用和 $\lambda$-抽象的类型一致性，并且在动态求值过程中保持类型正确性。

### 结论：

通过保持性定理（Preservation）和进展性定理（Progress），我们可以确保 **L{num str →}** 语言的类型安全性。这意味着在这种语言中，任何类型正确的表达式要么是一个值，要么可以通过动态求值得到一个新的表达式，并且这种表达式的类型始终保持不变。

### ---------------------------------

### 8.3 评价动态（Evaluation Dynamics）和定义等价（Definitional Equality）

#### 评价判断的归纳定义

**L{num str →}** 语言的评价判断 $e \Downarrow v$ 通过以下规则进行归纳定义：

1. **规则 (8.6a)**：函数抽象本身就是值，且直接归结为自身：
   $$
   \frac{}{\text{lam}[\tau](x.e) \Downarrow \text{lam}[\tau](x.e)} \quad (8.6a)
   $$

2. **规则 (8.6b)**：函数应用的评价，当 $e_1$ 归结为 $\lambda$ 抽象时，将 $e_2$ 替换进 $\lambda$ 抽象的主体 $e$，继续进行评价：
   $$
   \frac{e_1 \Downarrow \text{lam}[\tau](x.e) \quad [e_2/x]e \Downarrow v}{\text{ap}(e_1; e_2) \Downarrow v} \quad (8.6b)
   $$

通过这些规则可以容易地验证：

- 如果 $e \Downarrow v$，那么 $v$ 是一个值 $v \ \text{val}$。
- 如果 $e$ 是一个值 $e \ \text{val}$，那么 $e \Downarrow e$。

---

#### 定理 8.7：$e \Downarrow v$ 当且仅当 $e \to^* v$ 且 $v$ 是一个值。

**证明**：

1. **正向证明**：通过对规则 **(8.6)** 的归纳证明，类似于定理 7.2 的证明。对于每个评价规则（例如规则 (8.6b)），根据归纳假设，我们可以推导出 $e_1 \to^* \text{lam}[\tau](x.e)$，并且 $[e_2/x]e \to^* v$，所以最终 $e$ 会归结为 $v$。

2. **反向证明**：通过对规则 **(5.1)** 进行归纳，证明如果 $e \to^* v$ 且 $v \ \text{val}$，那么 $e \Downarrow v$。这依赖于 **引理 7.4** 的类似结论，即评价在反向执行时是闭合的（即评价结果不会“跑偏”），这可以通过对规则 **(8.5)** 的归纳证明。

---

#### 定义等价（Definitional Equality）

在按名称调用（call-by-name）动态语义的 **L{num str →}** 中，定义等价由以下扩展规则定义：

1. **规则 (8.7a)**：函数应用时的定义等价，表示应用后的表达式等价于将参数替换进函数体的表达式：
   $$
   \Gamma \vdash \text{ap}(\text{lam}[\tau](x.e_2); e_1) \equiv [e_1/x]e_2 : \tau_2 \quad (8.7a)
   $$

2. **规则 (8.7b)**：两个函数应用表达式等价，需分别证明函数和参数等价：
   $$
   \Gamma \vdash e_1 \equiv e_1' : \tau_2 \to \tau \quad \Gamma \vdash e_2 \equiv e_2' : \tau_2 \quad \Gamma \vdash \text{ap}(e_1; e_2) \equiv \text{ap}(e_1'; e_2') : \tau \quad (8.7b)
   $$

3. **规则 (8.7c)**：两个 $\lambda$ 抽象等价，当且仅当它们的函数体等价：
   $$
   \Gamma, x : \tau_1 \vdash e_2 \equiv e_2' : \tau_2 \quad \Gamma \vdash \text{lam}[\tau_1](x.e_2) \equiv \text{lam}[\tau_1](x.e_2') : \tau_1 \to \tau_2 \quad (8.7c)
   $$

#### 按值调用的定义等价

按值调用（call-by-value）需要额外的规则来确保参数是值：

- **规则 (8.7a)** 在按值调用时需要限制函数参数必须是一个值。因此，参数 $e_1$ 必须在调用时已经计算为值 $v_1$。

为了实现更强的表达能力，按值调用的定义等价还需拓展“值”的概念，包含所有在作用域内的变量。这样可以保证即使参数是变量，也能适用 **规则 (8.7a)**。

定义等价判断形式为：

$$
\Gamma \vdash e_1 \equiv e_2 : \tau
$$

其中 $\Gamma$ 包含了变量的类型和它们是值的假设 $x : \tau, x \ \text{val}$。例如，当 $x : \tau, x \ \text{val} \vdash x \ \text{val}$ 时，表示变量 $x$ 是一个值。

---

### 总结

1. **评价动态（Evaluation Dynamics）** 给出的是一个简化的归纳系统，关注表达式与值之间的关系。
2. **定义等价（Definitional Equality）** 是通过逐步扩展归纳规则来确保在不同场景下表达式的等价性。

通过这两种系统，我们可以在 **L{num str →}** 语言中有效地表达和处理高阶函数，并确保不同求值策略（如按名称调用或按值调用）的正确性。

### ---------------------------------

这两个概念，**评价动态**（Evaluation Dynamics）和**定义等价**（Definitional Equality），在编程语言和类型理论中起着非常重要的作用。它们分别从**程序的求值过程**和**表达式等价性**的角度，描述了程序行为的不同方面。我们分别从多个角度来详细解释它们。

### 1. **评价动态** (Evaluation Dynamics)

**评价动态**是关于程序**求值过程**的简化归纳系统。它定义了程序如何从一个表达式通过一系列求值步骤**演化**为一个值。这种演化过程通常通过一组归纳规则来描述，并且这些规则通常遵循程序语义的特定求值策略，如**值调用**（call-by-value）、**名调用**（call-by-name）或**惰性求值**（lazy evaluation）。

#### 核心特性：
- **表达式到值的关系**：评价动态的目标是描述如何通过归纳步骤，将一个表达式演化为一个值。
- **归纳规则**：每一步求值都是通过归纳规则定义的，例如算术操作、函数应用、条件判断等。
- **求值策略**：求值动态根据不同的策略，如值调用或惰性求值，决定表达式的求值顺序和方式。
  
#### 示例：
以一个简单的加法表达式 `2 + 3` 为例，评价动态会描述它如何一步一步求值成一个具体的值：
- **规则 1**：`2 + 3` 是一个二元算术表达式。
- **规则 2**：根据加法规则，`2 + 3` 可以直接简化为 `5`。

如果涉及函数调用，例如 `f(2)`，评价动态会描述如何调用函数 `f` 并返回值：
1. **函数调用**：首先对参数求值。
2. **应用函数**：将参数绑定到函数体中的变量，然后对函数体求值。

#### 评价动态的作用：
- **简化表达式**：通过一组求值规则，将复杂的表达式逐步简化为值。
- **求值顺序**：通过不同的策略（如惰性求值或值调用）来控制表达式的求值顺序，确保程序在适当的地方执行。

### 2. **定义等价** (Definitional Equality)

**定义等价**（Definitional Equality）是一种在类型理论和形式化系统中非常重要的概念。它用于描述在不同上下文中，**两个表达式如何被认为是等价的**。这种等价性通常通过一组扩展的归纳规则来定义，确保在不同场景下表达式能够被互相替代。

#### 核心特性：
- **等价规则的扩展**：定义等价是通过逐步扩展归纳规则来描述的。例如，通过归纳推导规则，可以证明不同形式的表达式在特定条件下是等价的。
- **表达式的可替代性**：如果两个表达式是定义等价的，那么在程序中它们可以相互替换，而不会影响程序的行为。
- **语法等价和语义等价**：定义等价可以表现为语法上的等价性（表达式形式相同），也可以通过归纳证明其语义等价。

#### 示例：
考虑一个函数定义 `f(x) = x + 1`，我们可以认为表达式 `f(2)` 与 `2 + 1` 是等价的，因为通过函数展开，`f(2)` 可以被替换为 `2 + 1`，并且它们计算结果相同。

类似地，在某些类型系统中，诸如以下的规则也描述了定义等价：
1. **$\beta$-化简**（Beta Reduction）：`(λx. e1) e2 = e1[e2/x]`，函数应用后，参数被替换到函数体中。
2. **$\eta$-扩展**（Eta Expansion）：`λx. f x = f`，如果函数 `f` 对所有参数 `x` 的行为都与应用 `f x` 相同，那么它们是等价的。

#### 定义等价的作用：
- **形式化推理**：定义等价帮助我们在推理过程中证明不同形式的表达式在某些上下文中是等价的。
- **类型系统中的一致性**：通过定义等价，确保不同表示形式的类型具有相同的语义，保持系统的一致性。

### 3. **评价动态与定义等价的关系**

**评价动态**和**定义等价**是紧密相关的，因为它们都处理程序中表达式的转换与等价性。具体来说：

- **评价动态**关注的是**如何通过求值规则将表达式转化为值**，是表达式演化过程的一部分。
- **定义等价**则描述了**表达式在不同上下文中等价的条件**，并且在求值过程中，某些表达式可以通过等价规则进行替换，从而保持程序行为一致。

#### 互补性：
- **评价动态**通过归纳系统简化和求值表达式，定义了程序如何执行以及返回值。
- **定义等价**确保在不同阶段中，表达式在语义上是等价的，允许我们对表达式进行替换而不改变程序的结果。

例如，在一个递归函数中，求值动态会描述递归函数的调用过程，而定义等价则确保某些形式的递归调用能够通过归纳等价简化为基本形式。

### 4. **从求值动态和定义等价角度确保定义性和不可定义性**

#### 4.1 **通过评价动态确保定义性**
- **定义性**：在求值动态中，定义性意味着表达式能够通过一系列规则逐步简化为值。如果表达式能够演化为值，程序就是**定义的**。
  - 示例：对于表达式 `2 + 3`，求值动态明确了如何通过加法规则简化为 `5`，确保该表达式是定义的。
  
- **不可定义性**：如果求值过程出现死循环或无法终止，那么该表达式是**不可定义的**。这类情况通常通过**递归求值规则**来描述。
  - 示例：对于表达式 `f x = f x`（无基准条件的递归），求值过程将陷入无限递归，导致表达式不可定义。

#### 4.2 **通过定义等价确保定义性**
- **定义性**：通过定义等价规则，我们可以确保不同表达式在某些场景下是可互换的，从而可以扩展表达式的表示形式，简化推导。
  - 示例：`f(2)` 和 `2 + 1` 可以被认为是等价的，这意味着无论使用哪个表达式，程序的行为保持一致，因此它们都是定义的。

- **不可定义性**：如果无法通过归纳推导证明两个表达式是等价的，或者表达式本身违反了等价规则（如不满足归纳的基本条件），那么表达式可能是不可定义的。
  - 示例：如果一个表达式中使用了未定义的符号或不合规的递归形式，那么在归纳推导中无法证明其等价性，表达式会被视为不可定义的。

### 5. **总结**

| **维度**           | **评价动态（Evaluation Dynamics）**                | **定义等价（Definitional Equality）**                    |
| ------------------ | -------------------------------------------------- | -------------------------------------------------------- |
| **核心目标**       | 描述表达式如何通过求值演化为值                     | 确保在不同上下文中表达式的等价性                         |
| **主要机制**       | 通过一组归纳规则定义求值过程                       | 通过扩展归纳规则确保不同形式的表达式是等价的             |
| **关注点**         | 从表达式到值的演化                                 | 不同表达式之间的语义等价性                               |
| **求值顺序**       | 取决于求值策略，如值调用、名调用、惰性求值         | 与求值策略无关，主要关注表达式的语义等价                 |
| **确保定义性**     | 通过求值规则确保表达式能演化为值，表达式是定义的   | 通过等价规则证明表达式的等价性，从而确保其行为一致       |
| **处理不可定义性** | 如果求值过程陷入无限递归或死循环，则表达式不可定义 | 如果表达式不能通过等价推导证明其正确性，可能是不可定义的 |
| **典型规则**       | 函数调用、算术求值、条件判断等                     | $\beta$-化简、$\eta$-扩展、递归函数展开等                |
| **实例**           | `f(2)` 演化为 `2 + 1`，最终演化为 `3`              | `f(2)` 定义为 `2 + 1` 是通过函数展开定义等价的             |
| **在程序中的作用**      | 描述程序如何通过求值逐步计算结果                       | 确保在不同表达式中可以使用等价替换，不影响程序结果         |

### 结论

- **评价动态**是一个**简化的归纳系统**，关注表达式与值之间的演化过程，描述了程序如何在运行时计算出结果。
- **定义等价**通过逐步扩展归纳规则来确保表达式的等价性，允许我们在不同上下文中进行表达式的替换，而不影响程序的行为。
- 评价动态和定义等价共同确保程序的**定义性**和**不可定义性**，前者通过求值过程来确保程序能够计算结果，后者通过语义等价性确保程序在不同表示形式下的一致性。

### ---------------------------------

### 8.4 动态作用域 (Dynamic Scope)

#### 静态绑定和静态作用域

在 **规则 (8.5)** 中，函数应用的动态定义仅适用于**没有自由变量的表达式**。当函数调用时，参数会被替换为函数的参数，确保结果是**闭合的表达式**。由于闭合表达式的替换不会产生**捕获** (capture)，所以变量的作用域不会受到动态过程的影响，这就保证了第 1 章中所讨论的绑定 (binding) 和作用域 (scope) 原则。

这一处理方法被称为**静态作用域** (static scoping) 或 **静态绑定** (static binding)，其目的是避免在函数应用时产生变量捕获问题。静态作用域确保了变量名的绑定在编译时就已确定，函数体内部的自由变量依赖于其定义时的上下文。

#### 动态作用域和动态绑定

**动态作用域** (dynamic scoping) 或 **动态绑定** (dynamic binding) 是另一种变量处理方式。动态作用域允许表达式中**包含自由变量**，在这种作用域下，自由变量的值是在运行时根据调用环境来确定的，而不是静态的定义上下文。这种情况下，当一个函数被调用时，参数会替换函数体中的形式参数，而不是进行**替换** (substitution)，这可能会导致自由变量捕获。

- **自由变量的捕获**：在动态作用域中，自由变量可能会被调用时的上下文捕获，而这种行为被认为是一种特性 (feature)，而不是错误 (bug)。

#### 例子：替换与捕获的差异

举一个例子来说明**替换**和**捕获**之间的区别：

假设有表达式 $e$：$\lambda (x:\text{str}) \ y + |x|$，其中变量 $y$ 是自由变量，再假设 $e_0$ 是表达式 $\lambda (y:\text{str}) \ f(y)$，其中 $f$ 是自由变量。

- **替换 (Substitution)**：将 $e$ 替换为 $f$，得到的结果是：
  $$
  \lambda (y_0:\text{str}) \ (\lambda (x:\text{str}) \ y + |x|)(y_0)
  $$
  这里，原表达式中自由的 $y$ 被替换为了新的变量 $y_0$，从而避免了捕获。

- **替换为 (Replacement)**：将 $e$ 直接替换为 $f$，结果是：
  $$
  \lambda (y:\text{str}) \ (\lambda (x:\text{str}) \ y + |x|)(y)
  $$
  在这种情况下，原本自由的 $y$ 被捕获了。

#### 动态作用域的影响

动态作用域的这种处理方式有广泛的影响，其中最明显的是，**语言不再类型安全**。在上述例子中，$y:\text{nat} \vdash e : \text{str} \to \text{nat}$，并且 $f : \text{str} \to \text{nat} \vdash e_0 : \text{str} \to \text{nat}$。虽然根据动态作用域规则，$y:\text{nat} \vdash [e/f]e_0 : \text{str} \to \text{nat}$，但通过替换 $f$，我们得到的结果不再类型安全，因为 $y$ 需要同时是 $\text{nat}$ 类型和 $\text{str}$ 类型。

#### 动态作用域下的类型问题

为了绕开这些类型问题，有一种做法是**完全忽略类型系统**，而依赖于运行时的检查来确保不发生不良行为。这种方法的安全性显然是有问题的，因为它放弃了类型检查对程序行为的预测能力，转而依赖运行时来发现错误。

更糟糕的是，在动态作用域下，**绑定变量的名称变得重要**，这违反了编程语言设计中的一个基本原则：绑定变量的名称应该是不重要的 (name irrelevance)。因此，在使用动态作用域时，必须确保函数体中的所有变量绑定关系不会改变，如果表达式 $e_0$ 改变绑定的变量名称，例如将 $y$ 改为 $z$，那么相应的函数体也需要更新。这就导致了 $e$ 和 $e_0$ 之间必须紧密协作开发，违反了**模块化设计**的原则。

#### 结论

动态作用域使得自由变量在调用时的上下文中被捕获，这可能导致意料之外的行为和类型不安全。尽管在某些场景下，动态作用域作为一种语言特性被引入，但它通常会带来许多不安全和复杂性问题。

### ---------------------------------

在**动态作用域**下，类型问题和绑定变量名称的重要性带来了诸多挑战，尤其在编写类型安全的程序时。动态作用域的特点是变量的绑定依赖于程序的调用栈，而不是像静态作用域那样依赖于程序的结构。这会导致类型检查难以在编译时保证安全性，因为变量绑定的上下文在运行时才会确定。因此，开发者通常选择依赖**运行时检查**来确保程序的安全性。

### 动态作用域下的类型问题

#### 1. **动态作用域的基本问题**
在**动态作用域**中，变量绑定依赖于程序的调用顺序，而不是基于静态作用域中通常的代码结构。这意味着当函数执行时，它的变量绑定取决于函数调用栈中之前的绑定环境。因此，变量的值和类型可能在不同的调用上下文中发生变化，这给类型系统带来了以下问题：

- **运行时绑定确定性**：在编译时，编译器无法准确地预测变量的绑定，因为它们是在运行时根据调用栈的状态动态确定的。因此，静态类型检查难以捕捉类型错误。
- **类型不安全**：由于绑定依赖于调用栈，可能会出现类型不匹配的情况。例如，一个函数在不同调用环境中绑定同名变量，但这些变量的类型不同。类型系统无法在编译时检测这种问题。

#### 2. **运行时类型检查的局限性**
绕开这些问题的一种做法是**忽略类型系统**，转而依赖运行时检查。然而，这种方法存在以下局限：

- **安全性问题**：放弃类型系统意味着编译时不能进行类型检查，程序错误只能在运行时暴露，这大大降低了程序的可靠性。未经过编译时验证的代码可能在运行时遇到严重的类型错误，导致程序崩溃或产生未定义行为。
- **效率问题**：运行时类型检查增加了性能开销，因为每次变量使用时都需要进行类型检查。相较于静态类型检查，它会使程序的执行速度变慢，尤其是在需要大量检查的复杂系统中。
- **错误发现延迟**：由于类型错误只能在运行时被发现，开发者必须等待程序运行，才能检测到错误。对于大型系统，这种调试过程可能非常耗时。

#### 3. **名称绑定的重要性**
在动态作用域下，**绑定变量的名称变得重要**，这与编程语言设计中的一个基本原则**绑定变量的名称应该不重要**（Name Irrelevance）相冲突。这个原则意味着变量的名称在语义上应该无关紧要，只要变量的作用范围和绑定关系保持不变，名称的改变不应该影响程序的行为。

然而，在动态作用域下：

- **变量名决定绑定**：变量名决定了它在运行时绑定的值，而不仅仅是作为占位符。如果函数体中的变量绑定发生变化，例如将一个变量的名称从 `y` 改为 `z`，这会改变变量的动态绑定，从而影响程序的行为。这种现象称为**名称绑定敏感**。
- **影响模块化设计**：动态作用域破坏了**模块化设计**。在模块化设计中，函数和模块应当相互独立开发和维护，而不依赖于具体的实现细节。然而，在动态作用域下，函数体和绑定环境之间的关系变得紧密，导致模块之间的依赖性增加。例如，某个模块可能依赖于某个变量的绑定名称，如果另一个模块修改了该名称，整个系统的行为可能会发生不可预测的变化。

#### 4. **与静态作用域的对比**
为了更好地理解动态作用域的类型问题，我们可以将其与**静态作用域**进行对比：

- **静态作用域**：在静态作用域中，变量的绑定根据代码结构在编译时确定。类型系统可以在编译时通过解析程序的静态结构来检查所有变量的类型，因此可以在编译时捕获类型错误，确保类型安全性。
- **动态作用域**：在动态作用域中，变量的绑定依赖于程序的调用栈，这使得变量的绑定关系在运行时才会确定。类型系统在编译时无法推导出变量的类型信息，必须依赖运行时类型检查，存在类型错误的风险。

### 5. **动态作用域下的解决方案**

为了减少动态作用域下的类型问题和名称绑定问题，有一些潜在的解决方案：

#### 5.1 **依赖静态作用域**
动态作用域的这些问题促使大多数现代编程语言采用**静态作用域**，因为静态作用域可以在编译时准确进行类型检查和变量绑定的分析。通过静态作用域，编译器可以确保变量在特定的范围内具有唯一的绑定关系，并且不会因为调用顺序而发生变化。这提高了程序的可预测性和安全性。

#### 5.2 **引入类型推断和类型检查**
在动态作用域的系统中，可以引入类型推断和类型检查机制，帮助在编译时尽可能地推断出变量的类型。例如，某些动态类型语言（如 Python）可以引入类型标注（type annotations）和工具（如 MyPy），从而部分引入静态类型检查，减少运行时错误。

#### 5.3 **静态作用域模拟**
在动态作用域下，使用某些手段可以模拟静态作用域的行为。比如使用**词法闭包**（lexical closures）保存函数调用时的环境，这样在函数体执行时，它依赖于定义时的环境，而不是调用时的环境。这可以有效避免动态作用域下绑定关系不可预测的问题。

#### 5.4 **模块化设计原则**
在动态作用域中，开发者必须格外注意模块化设计原则，确保模块之间的相互独立。特别是在动态作用域下，变量绑定关系容易受到其他模块的影响，因此必须明确变量的作用范围，避免全局变量过多的使用，同时应当尽量减少依赖其他模块的命名约定。

### 6. **总结**

在**动态作用域**下，由于变量绑定依赖于调用栈，类型检查面临较大的挑战：
- 编译时无法确定变量的绑定环境和类型信息，导致类型系统失去其预测能力，程序行为难以在编译时进行验证。
- 运行时类型检查带来安全性和效率问题，使得错误只能在运行时发现，严重影响程序的健壮性。
- **绑定变量名称的敏感性**引发了额外的复杂性，尤其是在模块化设计中，动态作用域下的变量名变得不可忽略，这破坏了编程语言设计中的“绑定名称不重要”的原则。

为了缓解这些问题，现代语言更倾向于采用**静态作用域**，并结合静态类型系统进行编译时检查，同时在动态类型语言中也可以通过类型推断和类型标注等机制减少运行时错误。此外，模块化设计中的封装和作用域管理也非常关键，特别是在动态作用域环境中开发大型系统时。

### ---------------------------------

### 8.5 注释 (Notes)

几乎所有的编程语言都提供了某种形式的函数定义机制，如本章所展示的。然而，当前内容的主要目的是展示一种更自然、更强大的方法：**将定义的通用概念与函数的具体概念分离**。

#### 函数定义和类型系统的自然分离

函数类型 (function types) 通过系统化的方式编码了这一通用概念，将函数定义作为特例来处理。此外，它允许我们**将函数作为参数传递**或**将函数作为结果返回**，而无需额外的处理。这种方法比传统的函数定义机制更灵活、更强大，特别是在处理**高阶函数** (higher-order functions) 时表现突出。

#### 教会 λ-演算的贡献 hh

教会 (Alonzo Church) 在 1941 年提出的**λ-演算** (λ-calculus) 为函数的处理奠定了理论基础。他的主要贡献在于将**函数**作为编程语言的**核心概念**，并且证明了在此基础上就可以构建一个**完全表达能力的编程语言**。也就是说，函数及其应用的概念足以表示所有的计算，无需再添加其他语言结构。这一理论成为了现代编程语言设计中**高阶函数**和**函数式编程** (functional programming) 的理论基础。

通过将函数视为一种基础的**一等公民** (first-class citizen)，即函数可以像其他类型的值一样被传递、返回或存储，λ-演算不仅极大简化了编程语言的设计，还使得函数式编程变得极其强大和灵活。

#### 小结

本节通过展示函数类型的普遍性，以及通过 λ-演算表明函数是构建完整编程语言的唯一必需概念，进一步深化了对函数定义的理解。函数类型不仅使函数定义更加通用，也为高阶函数的处理提供了强有力的支持，同时将编程语言设计提升到更高的抽象层次。

### ---------------------------------




### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------
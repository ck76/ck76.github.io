[toc]





**结构子类型（Structural Subtyping）**和**行为子类型（Behavioral Subtyping）**是面向对象编程和类型理论中的两种不同的子类型关系定义方式。它们在类型继承、接口实现、以及类之间的关系处理中具有不同的意义和作用。下面详细解释这两种子类型的概念、区别以及它们在类型系统中的作用。

### 1. **结构子类型（Structural Subtyping）**

**结构子类型**是一种基于类型的**结构**来定义子类型关系的系统。一个类型 $A$ 可以被视为另一个类型 $B$ 的子类型，**只要 $A$ 具有 $B$ 的所有结构（方法和属性），并且它们的类型兼容**，而无需明确声明继承关系。

#### 1.1 **定义**

在结构子类型系统中，类型之间的关系仅仅取决于它们的**结构相似性**。具体来说，$A$ 是 $B$ 的子类型（记作 $A <: B$），当且仅当：

- $A$ 的每个属性或方法都与 $B$ 的对应属性或方法兼容（或者 $A$ 具有更多的属性和方法）。
- 这些属性和方法的类型匹配，即 $A$ 中的方法签名必须与 $B$ 中的方法签名一致。

### **例子**

假设有两个类型 $Person$ 和 $Employee$，它们的结构如下：

- **Person**：
  - name: String
  - age: Int

- **Employee**：
  - name: String
  - age: Int
  - salary: Double

在结构子类型系统中，由于 **Employee** 包含了所有 **Person** 的属性，因此 **Employee** 是 **Person** 的子类型，即 $Employee <: Person$。即使没有显式地声明继承关系，**Employee** 也可以用在需要 **Person** 类型的地方。

#### 1.2 **特性**

- **松耦合**：类型之间没有必要的继承关系，两个类型只要有兼容的结构，就可以建立子类型关系。
- **灵活性**：允许类型系统更灵活地处理类型扩展。开发者不需要为了继承关系而人为地引入父类，而只要确保类型结构匹配即可。
- **接口兼容性**：这种子类型允许对象的接口自由扩展，只要对象有相应的方法或属性，就可以被认为是该类型的子类型。

### 2. **行为子类型（Behavioral Subtyping）**

**行为子类型**是一种更为严格的子类型定义方式，它不仅要求子类型在**结构**上与父类型兼容，还要求子类型在**行为**上与父类型一致。这意味着子类型的对象不仅要有父类型的方法，还必须**遵循父类型的行为规范**。

#### 2.1 **定义**

行为子类型基于 **Liskov 替换原则（Liskov Substitution Principle, LSP）**，即：

> 如果 $B$ 是 $A$ 的子类型，那么在程序的任何地方都可以用 $B$ 类型的对象替换 $A$ 类型的对象，并且程序的行为不会发生改变。

具体地说，行为子类型要求子类型必须满足以下条件：

- 子类型的**前置条件**不能比父类型更严格。
- 子类型的**后置条件**不能比父类型更弱。
- 子类型的方法必须维持父类型的方法行为一致性。

### **例子**

假设有以下两个类：

- **Rectangle（矩形）**：
  - 属性：宽度（width）、高度（height）
  - 方法：设置宽度（setWidth）、设置高度（setHeight）

- **Square（正方形）**继承了**Rectangle**，并添加了限制：宽度和高度必须相等。

虽然在结构上，**Square** 似乎是 **Rectangle** 的子类型，但在行为上，它违反了 LSP。因为如果我们替换一个 **Rectangle** 对象为 **Square**，并分别调用 `setWidth(5)` 和 `setHeight(10)`，会导致正方形对象的行为不符合矩形的预期。这样行为不一致的情况意味着 **Square** 不能被视为 **Rectangle** 的行为子类型。

#### 2.2 **特性**

- **行为一致性**：子类型不仅需要有父类型的方法和属性，还需要确保行为上与父类型一致。
- **LSP 原则**：满足 Liskov 替换原则，即在使用子类型时，程序的逻辑和行为不能受到任何影响。
- **更严格的约束**：相比结构子类型，行为子类型要求不仅是结构上的兼容，还要满足行为上的要求。

### 3. **结构子类型与行为子类型的区别**

- **子类型判断依据不同**：
  - 结构子类型的依据是类型的**结构**，只要类型结构兼容，子类型关系就成立。
  - 行为子类型不仅要求结构兼容，还要求**行为一致**，即满足 Liskov 替换原则。
  
- **灵活性 vs. 安全性**：
  - 结构子类型系统更加灵活，允许对象扩展自己的结构，而不需要显式地声明继承关系。
  - 行为子类型更加严格，保证了使用子类型时程序行为的一致性，但灵活性有所降低。

- **应用场景**：
  - 结构子类型适用于松耦合、动态扩展场景，如面向接口编程中的接口实现、鸭子类型。
  - 行为子类型适用于严格的类型系统，尤其是在继承和多态性中，它确保了对象可以替代其父类型而不改变程序行为。

### 4. **实际应用**

- 在静态类型语言（如 Scala 和 TypeScript）中，结构子类型可以自然地实现无继承关系的类型兼容性。
- 在行为上，需要开发者在设计子类型时注意保持父类行为的一致性，避免引入违反 LSP 的设计，从而保证系统的健壮性和一致性。

### 5. **总结**

- **结构子类型**：基于类型的结构，两个类型之间的关系只要在结构上兼容即可形成子类型关系，应用灵活。
- **行为子类型**：基于行为一致性，要求子类型不仅要在结构上与父类型兼容，还要在行为上保持一致，以保证替换性。

这两种子类型各有其应用场景，结构子类型更加灵活，而行为子类型提供了更强的行为保证。

### -----------------------------------

第八部分主要讲解了**子类型**（Subtyping）及其相关的各种概念。这是编程语言理论中的一个关键主题，特别是在类型系统设计中，子类型关系允许一种类型被另一种类型的值替代，从而实现更灵活和安全的程序设计。

### 概述
- **子类型（Subtyping）**：这是指一种类型可以被另一种类型兼容替代的关系。如果类型 $A$ 是类型 $B$ 的子类型（记为 $A <: B$），那么在期望类型 $B$ 的任何地方，我们都可以安全地使用类型 $A$ 的值。子类型关系能够增强类型系统的灵活性，支持多态和继承等编程概念。

### 1. **Subsumption（吸收规则）**
吸收规则是子类型系统的一个基本规则，它规定如果 $A <: B$，并且 $e : A$，那么 $e$ 也可以被看作是类型 $B$ 的值。形式化表示如下：
$$
\frac{e : A \quad A <: B}{e : B}
$$
这意味着程序中如果有一个表达式 $e$，它属于类型 $A$，并且 $A$ 是 $B$ 的子类型，那么我们可以安全地在期望 $B$ 类型的地方使用 $e$。

### 2. **Varieties of Subtyping（子类型的多样性）**
子类型的多样性体现在不同的类型构造器和结构中。例如：

- **Numeric Types（数值类型）**：整数可以视为浮点数的子类型。这允许我们在期望浮点数的地方使用整数，而不会影响计算的正确性。
  $$
  \text{int} <: \text{float}
  $$

- **Product Types（乘积类型）**：对于乘积类型 $A \times B$ 和 $C \times D$，若 $A <: C$ 且 $B <: D$，那么可以得出：
  $$
  A \times B <: C \times D
  $$
  这意味着一个由 $A$ 和 $B$ 构成的类型可以兼容替代 $C \times D$，前提是 $A$ 和 $B$ 各自是 $C$ 和 $D$ 的子类型。

- **Sum Types（和类型）**：对于和类型 $A + B$ 和 $C + D$，如果 $A <: C$ 且 $B <: D$，我们也可以得出：
  $$
  A + B <: C + D
  $$
  和类型的子类型关系表明，包含 $A$ 和 $B$ 的值集合可以兼容地替代包含 $C$ 和 $D$ 的集合。

### 3. **Variance（变异性）**
变异性描述了在类型构造器中，类型参数如何影响子类型关系。常见的变异性有三种：

- **协变（Covariant）**：如果类型构造器对于其参数是协变的，则当类型参数 $A <: B$ 时，构造器 $F(A)$ 也会是 $F(B)$ 的子类型。即：
  $$
  A <: B \quad \Rightarrow \quad F(A) <: F(B)
  $$

- **逆变（Contravariant）**：如果类型构造器对于其参数是逆变的，则当 $A <: B$ 时，$F(B)$ 是 $F(A)$ 的子类型：
  $$
  A <: B \quad \Rightarrow \quad F(B) <: F(A)
  $$

- **不变（Invariant）**：如果类型构造器是不可变的，则无论 $A$ 和 $B$ 之间的关系如何，$F(A)$ 和 $F(B)$ 之间都不存在子类型关系。

### 4. **Function Types（函数类型）**
在函数类型的子类型规则中，参数类型是逆变的，而返回类型是协变的。对于函数类型 $A \to B$ 和 $C \to D$，若满足以下条件：
$$
C <: A \quad \text{且} \quad B <: D
$$
那么有：
$$
A \to B <: C \to D
$$
这意味着如果 $A$ 可以接受 $C$ 的输入，而 $D$ 是 $B$ 的子类型，那么函数类型 $A \to B$ 可以视为 $C \to D$ 的子类型。

### 5. **Quantified Types（量化类型）**
量化类型的子类型关系涉及类型变量的范围约束。一个典型的例子是泛型类型中的子类型规则。在类型系统中，这些规则确保了泛型代码的灵活性和类型安全。

### 6. **Recursive Types（递归类型）**
递归类型的子类型关系较为复杂，涉及到递归定义的类型如何进行比较。为了确保递归类型的子类型关系是可判定的，通常采用**固定点理论**来处理。

### 7. **Safety（安全性）**
子类型系统确保了程序的类型安全性，即类型正确的程序在执行时不会产生类型错误。这一性质通过**保留性定理**（Preservation Theorem）和**进展性定理**（Progress Theorem）来证明。这两个定理共同保证了子类型系统的正确性和健壮性。

### 总结
这一章讨论了编程语言设计中至关重要的子类型概念及其相关理论，帮助我们理解如何在更复杂的类型系统中应用子类型，并确保类型安全性。

### ---------------------------------

### 23.1 Subtyping

**子类型**（Subtyping）关系是类型系统中的一种**预序关系**（pre-order），即它是**自反的**（reflexive）和**传递的**（transitive）。子类型关系允许一个类型可以被视为另一个类型的替代，这遵循了**吸收原则**（Subsumption Principle）：
- 如果 $τ_0$ 是 $τ$ 的子类型，那么在期望 $τ$ 类型的地方，我们可以使用 $τ_0$ 的值。这意味着子类型的值可以在超类型上下文中使用。

### 吸收原则与类型系统
吸收原则放宽了类型系统的限制，使得一个类型的值可以被视为另一个相关类型的值。这种灵活性在程序设计中非常有用，特别是在面向对象编程和多态性（polymorphism）中。

然而，虽然吸收原则非常实用，但其应用并不总是直接和安全的。为了确保其正确性，必须依据**引入和消除原则**（Introduction and Elimination Principles）进行验证。即，确保子类型的引入形式（introductory form）能够被超类型的消除形式（eliminatory form）安全地操作。

### 23.2 引入与消除原则
为了验证一个子类型关系是否合理，必须考虑两个重要方面：

1. **引入形式**：每个子类型的值都是通过其引入形式生成的。
2. **消除形式**：超类型的值可以通过其消除形式进行操作。

子类型的合理性需要满足以下条件：
- 每一个子类型的引入形式都能被超类型的消除形式安全操作。子类型与超类型的关系不仅仅是集合的包含关系，更应反映两者在操作上的兼容性。

### 23.3 子类型的常见误解：集合包含的直觉

许多人错误地将子类型关系类比为数学中的**集合包含关系**。这种理解只考虑了类型的引入形式（即类型的值），而忽略了消除形式的重要性。在编程语言的类型系统中，子类型的核心问题在于行为的兼容性，而不仅仅是子类型值是否可以被视为超类型的值。

### 23.4 数值类型（Numeric Types）

在数值类型中，我们经常遇到子类型关系。一个典型的例子是，整数（int）可以被视为浮点数（float）的子类型：
$$
\text{int} <: \text{float}
$$
这意味着，整数可以在需要浮点数的地方使用。这种关系的合理性取决于浮点数的消除形式可以安全地操作整数值。比如，在数学计算中，整数可以无损地转换为浮点数进行运算，因此这种子类型关系是安全的。

### 23.5 乘积类型（Product Types）

对于乘积类型（Product Types）$A \times B$ 和 $C \times D$，如果 $A <: C$ 且 $B <: D$，则我们可以得出：
$$
A \times B <: C \times D
$$
这表明如果 $A$ 和 $B$ 是 $C$ 和 $D$ 的子类型，那么它们构成的乘积类型也具有相同的子类型关系。这种子类型关系的安全性同样依赖于引入和消除原则。例如，$A \times B$ 类型的值可以被安全地操作，并且操作结果与 $C \times D$ 类型的操作结果一致。

### 23.6 和类型（Sum Types）

对于和类型（Sum Types）$A + B$ 和 $C + D$，如果 $A <: C$ 且 $B <: D$，我们可以推导出：
$$
A + B <: C + D
$$
和类型表示一种选择性数据结构，其中的每个值要么属于 $A$，要么属于 $B$。若 $A$ 和 $B$ 都是 $C$ 和 $D$ 的子类型，那么和类型的值也可以被视为 $C + D$ 的值，这符合子类型关系的规则。

### 总结

子类型关系在类型系统设计中至关重要，但它不仅仅是关于类型之间的值包含关系，还包括子类型的行为与超类型的行为兼容性。通过引入与消除原则，我们可以确保子类型的设计是安全且合理的。

### ---------------------------------

### 23.1 Subsumption

**Subsumption**（吸收规则）是子类型系统中的一个重要概念，用于扩展程序类型检查的灵活性。一个**子类型判断**具有如下形式：

$$
\tau_0 <: \tau
$$

这表示 $\tau_0$ 是 $\tau$ 的子类型。

#### 子类型的基本规则

子类型关系至少要满足以下两个**结构性规则**（Structural Rules）：

1. **自反性**（Reflexivity）：
$$
\tau <: \tau
$$
自反性表明，每个类型都是自身的子类型。这是子类型关系中的基本性质。

2. **传递性**（Transitivity）：
$$
\tau'' <: \tau_0 \quad \text{and} \quad \tau_0 <: \tau \quad \Rightarrow \quad \tau'' <: \tau
$$
传递性表明，如果 $\tau''$ 是 $\tau_0$ 的子类型，且 $\tau_0$ 是 $\tau$ 的子类型，那么 $\tau''$ 也是 $\tau$ 的子类型。

在实际应用中，这两个规则通常会被隐式地纳入子类型系统的定义中，要么直接作为基本规则，要么通过其他规则推导出来。

#### 吸收规则

子类型关系的目的在于扩展程序中的**良类型程序**（well-typed programs）的集合，这是通过吸收规则实现的。吸收规则允许我们在上下文中用子类型替换超类型。这条规则的形式如下：

$$
\frac{\Gamma \vdash e : \tau_0 \quad \tau_0 <: \tau}{\Gamma \vdash e : \tau}
$$

这个规则的意思是，如果在某个上下文 $\Gamma$ 中，表达式 $e$ 的类型为 $\tau_0$，并且 $\tau_0$ 是 $\tau$ 的子类型，那么我们可以得出 $e$ 的类型为 $\tau$。

#### 吸收规则的特性

与其他类型规则不同，**吸收规则不是语法导向的**（syntax-directed），因为它并不对表达式 $e$ 的形式提出限制。换句话说，吸收规则可以应用于任意形式的表达式。

在类型检查过程中，我们通常有两种选择来证明某个表达式的类型：

1. **直接应用类型规则**：根据表达式 $e$ 的具体形式应用相应的类型规则，得出类型 $\tau$。
2. **应用吸收规则**：先证明 $e$ 的类型是某个子类型 $\tau_0$，然后通过子类型判断 $\tau_0 <: \tau$，得出 $e$ 的类型为 $\tau$。

这种灵活性允许类型系统通过子类型关系进行更广泛的程序类型检查，从而在不改变程序语义的情况下扩展可接受的程序集合。

### 公式解释

- $\Gamma \vdash e : \tau_0$：表示在上下文 $\Gamma$ 下，表达式 $e$ 的类型是 $\tau_0$。
- $\tau_0 <: \tau$：表示 $\tau_0$ 是 $\tau$ 的子类型。
- $\Gamma \vdash e : \tau$：通过应用吸收规则，表达式 $e$ 的类型可以被认为是 $\tau$。

通过吸收规则，类型系统不仅能够支持严格的类型匹配，还允许类型之间的子类型关系，从而增加了类型检查的灵活性。

### ---------------------------------

### 23.2 各种形式的子类型

在本节中，我们将非正式地探讨几种不同的子类型形式，涵盖对 L{*} 的各种扩展。具体来说，我们将关注**数值类型**（Numeric Types）、**乘积类型**（Product Types）和**和类型**（Sum Types）。这些扩展允许我们灵活地处理各种类型系统，并展示了不同类型的兼容性。后续在 **23.4** 节中，我们将从类型安全的角度更详细地讨论这些子类型规则。

---

### 1. **数值类型（Numeric Types）**

数值类型通常具有自然的子类型关系，因为不同数值类型之间存在大小关系。例如，在许多语言中，整数类型（`int`）可以看作是浮点类型（`float`）的子类型。因为浮点数的表示范围比整数更广泛，所以可以通过子类型规则将整数提升为浮点数。

#### 举例：
假设我们有以下两种数值类型：

- **整数类型**：$\text{int}$
- **浮点类型**：$\text{float}$

子类型关系可以表示为：

$$
\text{int} <: \text{float}
$$

这意味着，任何整数类型的值可以在需要浮点类型值的上下文中使用。例如：

$$
\frac{\Gamma \vdash e : \text{int} \quad \text{int} <: \text{float}}{\Gamma \vdash e : \text{float}}
$$

即，如果表达式 $e$ 的类型是 `int`，并且我们知道 `int` 是 `float` 的子类型，那么我们可以得出 $e$ 具有 `float` 类型。

这种提升的应用场景非常广泛，尤其在需要兼容不同数值类型的计算中，可以自动将低精度的数值类型提升到高精度的类型，而不需要显式转换。

---

### 2. **乘积类型（Product Types）**

乘积类型（通常表示为笛卡尔积）表示两个类型的组合，类型为 $\tau_1 \times \tau_2$。对于乘积类型的子类型关系，一般来说，如果 $\tau_1$ 和 $\tau_2$ 分别是其超类型的子类型，那么 $\tau_1 \times \tau_2$ 也是对应乘积类型的子类型。

#### 举例：
假设我们有两个类型 $\tau_1, \tau_2$，以及它们的超类型 $\tau'_1, \tau'_2$，满足：

$$
\tau_1 <: \tau'_1 \quad \text{and} \quad \tau_2 <: \tau'_2
$$

则它们的乘积类型之间也存在如下的子类型关系：

$$
\tau_1 \times \tau_2 <: \tau'_1 \times \tau'_2
$$

即，如果 $\tau_1$ 和 $\tau_2$ 是它们对应类型的子类型，那么乘积 $\tau_1 \times \tau_2$ 可以作为 $\tau'_1 \times \tau'_2$ 的子类型。

#### 子类型规则的应用：

$$
\frac{\Gamma \vdash e : \tau_1 \times \tau_2 \quad \tau_1 \times \tau_2 <: \tau'_1 \times \tau'_2}{\Gamma \vdash e : \tau'_1 \times \tau'_2}
$$

这意味着，如果 $e$ 是 $\tau_1 \times \tau_2$ 类型的值，并且 $\tau_1 \times \tau_2$ 是 $\tau'_1 \times \tau'_2$ 的子类型，那么我们可以推断 $e$ 的类型为 $\tau'_1 \times \tau'_2$。

---

### 3. **和类型（Sum Types）**

和类型（通常表示为 $\tau_1 + \tau_2$）表示两种类型的并集。在处理和类型时，子类型规则更为复杂，因为和类型的每个分支可能都有不同的子类型关系。

#### 举例：
假设我们有两个和类型 $\tau_1 + \tau_2$ 和 $\tau'_1 + \tau'_2$，如果：

$$
\tau_1 <: \tau'_1 \quad \text{and} \quad \tau_2 <: \tau'_2
$$

那么我们可以推断和类型之间的子类型关系为：

$$
\tau_1 + \tau_2 <: \tau'_1 + \tau'_2
$$

这意味着 $\tau_1$ 是 $\tau'_1$ 的子类型，$\tau_2$ 是 $\tau'_2$ 的子类型时，$\tau_1 + \tau_2$ 是 $\tau'_1 + \tau'_2$ 的子类型。

#### 子类型规则的应用：

$$
\frac{\Gamma \vdash e : \tau_1 + \tau_2 \quad \tau_1 + \tau_2 <: \tau'_1 + \tau'_2}{\Gamma \vdash e : \tau'_1 + \tau'_2}
$$

这个规则表明，如果 $e$ 是 $\tau_1 + \tau_2$ 类型，并且 $\tau_1 + \tau_2$ 是 $\tau'_1 + \tau'_2$ 的子类型，那么 $e$ 可以具有 $\tau'_1 + \tau'_2$ 的类型。

---

### 小结

通过引入子类型关系，我们可以将不同类型系统中的类型之间建立灵活的转换机制。**数值类型**、**乘积类型**和**和类型**的子类型规则分别展示了如何通过子类型关系在不同上下文中应用类型转换。这些规则的应用使得类型系统在处理复杂数据类型时更加灵活和安全。

接下来，在 **23.4** 节中，我们将深入探讨这些子类型系统的**类型安全**（type safety）问题。

### ---------------------------------

### 23.2.1 数值类型 (Numeric Types)

在具有数值类型的语言中，我们可以根据数学经验推测出它们之间的子类型关系。例如，假设我们有三种数值类型：`int`（整数）、`rat`（有理数）和 `real`（实数），我们可能会自然地提出以下的子类型关系：

$$
\text{int} <: \text{rat} <: \text{real}
$$

这与我们在数学中熟悉的集合包含关系类似：

$$
\mathbb{Z} \subseteq \mathbb{Q} \subseteq \mathbb{R}
$$

### 1. **子类型关系是否合理？**

子类型关系是否合理取决于这些类型的**表示**和**解释**。尽管在数学上，这种包含关系是可以接受的，但在计算机程序中，我们需要仔细考虑**表示的精度**和**操作的实现**。

#### 数学上的细微差别
即使在数学上，这些包含关系也并非严格成立，而是通常在广义上成立。例如：
- **有理数集合**可以通过一对形式为 $(m, n)$ 且 $n \neq 0$ 且 $\gcd(m, n) = 1$ 的数对来表示，表示为 $m/n$。
- **整数集合** $\mathbb{Z}$ 可以通过嵌入到有理数 $\mathbb{Q}$ 中，例如把整数 $n$ 作为有理数 $n/1$。

同样地，**实数集合** $\mathbb{R}$ 通常被表示为有理数的收敛序列，因此从严格意义上来说，有理数并不是实数的子集，而是通过选取每个有理数的**收敛序列**代表嵌入到实数中。

### 2. **计算中的细微差别**

虽然在数学中，我们可以忽略这些细微差别，但在编程中，我们不能如此轻率地处理。我们需要考虑：
- **算法效率**：处理整数和浮点数的算法在复杂度和性能上可能存在显著差异。
- **机器表示的有限性**：在计算机中，实数通常是**有限精度浮点数**，而不是无限精度的有理数或实数。浮点数只能表示有理数的一小部分，并且浮点运算不完全符合有理数的运算规则。

#### 例子：浮点数与有理数的差异

例如，即使我们将两个整数作为浮点数进行相加，其结果可能由于舍入误差而不再是整数。这种情况说明，在编程语言中，浮点数和有理数之间并不能简单地通过子类型关系处理。

### 3. **子类型规则的意义**

在数学上，$\mathbb{Z}$、$\mathbb{Q}$ 和 $\mathbb{R}$ 的关系可以通过子类型关系来解释。**整数**可以嵌入到**有理数**中，而**有理数**可以嵌入到**实数**中，因此在数学操作中，它们的子类型关系是合理的。

但是，在编程语言中，由于数值类型的**表示限制**，特别是**浮点运算**并不完全符合数学规则，因此简单的子类型提升（例如将整数自动转换为浮点数）在某些情况下会引入不可预见的错误。

因此，在设计数值类型的子类型规则时，需要谨慎处理这些类型的操作和表示之间的细微差别，以确保类型系统的安全性和程序的正确性。

### 小结

数值类型之间的子类型关系，在数学上可以通过集合包含来类比，但是在编程语言中，由于机器表示和算法的不同，这种子类型关系需要更加细致的考虑。

### ---------------------------------

### 23.2.2 笛卡尔积类型 (Product Types)

笛卡尔积类型 (Product Types) 可以通过**归约原则**(subsumption principle) 产生一种子类型的关系。对于笛卡尔积类型，唯一可以应用的消解形式是**投影** (projections)。在某些假设下，考虑到投影操作的动态行为，我们可以判断一个笛卡尔积类型是否是另一个类型的子类型。具体地，我们可以通过判断超类型 (supertype) 的投影操作是否能够有效地应用于子类型的值来确定其子类型关系。

#### 1. **基本原理**
假设我们有一个需要类型为 $\tau = \langle \tau_j \rangle_{j \in J}$ 的值的上下文。根据有限笛卡尔积的静态规则 (如**规则 11.3**)，除了将这个值绑定到变量之外，唯一可以对类型为 $\tau$ 的值进行的操作是，对某个 $j \in J$ 进行**投影**，从而得到一个类型为 $\tau_j$ 的值。

现在假设我们有一个表达式 $e$ 的类型为 $\tau'$。为了使 $e \cdot j$ 投影操作是良构的 (well-formed)，我们需要 $\tau'$ 是一个形式为 $\langle \tau'_i \rangle_{i \in I}$ 的有限笛卡尔积类型，且 $j \in I$。此外，为了使这个操作的结果是类型为 $\tau_j$ 的值，只需要求 $\tau'_j = \tau_j$。

因此，对于任意的 $j \in J$，我们可以推导出以下笛卡尔积类型的子类型规则：

$$
J \subseteq I \quad \Rightarrow \quad \prod_{i \in I} \tau_i <: \prod_{j \in J} \tau_j
$$

这意味着：**如果一个笛卡尔积的索引集合 $I$ 包含另一个笛卡尔积的索引集合 $J$，并且它们相应的投影类型相同，则前者是后者的子类型**。

#### 2. **解释规则 23.3**
规则 23.3 说明：只要表达式 $e$ 拥有一个字段，它的索引属于 $i \in I$，我们就可以对其执行投影操作 $e \cdot i$。这实际上表明了**子类型提升**的机制：如果一个较大的笛卡尔积类型的某些字段与较小的笛卡尔积类型一致，则该较大的笛卡尔积类型是较小类型的子类型。

例如，如果我们有两个笛卡尔积类型：

$$
\tau_1 = \prod_{i \in \{1, 2, 3\}} \tau_i
$$

和

$$
\tau_2 = \prod_{j \in \{1, 2\}} \tau_j
$$

则 $\tau_1$ 可以是 $\tau_2$ 的子类型，因为 $\{1, 2\} \subseteq \{1, 2, 3\}$ 并且相应的投影类型 $\tau_1$ 和 $\tau_2$ 匹配。这样，当程序需要 $\tau_2$ 类型的值时，我们可以传递 $\tau_1$ 类型的值，而程序可以正确地对其执行投影操作。

#### 3. **更宽松的子类型规则**
虽然规则 23.3 足以实现我们所需要的子类型关系，但并非必要的。在下一节（23.3）中，我们将讨论一种更为宽松的子类型规则，它能够覆盖更广泛的情况。

### 小结
笛卡尔积类型的子类型关系基于投影操作。通过确保子类型包含所有超类型所需要的投影字段，并且这些字段的类型一致，我们可以将一个类型视为另一个类型的子类型，从而实现类型系统中的子类型提升。

### ---------------------------------

### 23.2.3 **和类型 (Sum Types)**

类似于笛卡尔积类型 (Product Types)，我们可以通过对偶的逻辑推导出有限和类型 (Finite Sum Types) 的子类型规则。

#### 1. **基本原理**

假设我们需要一个类型为 $\Sigma_{j \in J} \tau_j$ 的值。根据和类型的静态规则 (**规则 12.3**)，对类型 $\Sigma_{j \in J} \tau_j$ 的值，我们唯一可以进行的操作是**对 $J$ 索引的** `case` **分析**。也就是说，当我们有一个类型 $\Sigma_{j \in J} \tau_j$ 的值时，唯一有意义的操作是对 $J$ 集合中的每个元素进行分支处理。

现在，假设我们有一个表达式 $e$ 的类型是 $\Sigma_{i \in I} \tau'_i$。为了确保 `case` 分析操作的安全性，$I$ 必须是 $J$ 的子集 ($I \subseteq J$)，并且对于 $i \in I$，必须有 $\tau'_i = \tau_i$。如果 $I$ 是 $J$ 的严格子集，那么某些 `case` 分支可能永远不会发生（因为它们不在 $I$ 中），但这不会影响程序的安全性。这是因为即便某些情况无法发生，程序依然可以处理这些可能的分支。

#### 2. **子类型规则 23.4**

根据这个逻辑，我们得到以下和类型的子类型规则：

$$
I \subseteq J \quad \Rightarrow \quad \sum_{i \in I} \tau_i <: \sum_{j \in J} \tau_j
$$

该规则表示：**如果类型 $\Sigma_{i \in I} \tau_i$ 中的所有分支都存在于类型 $\Sigma_{j \in J} \tau_j$ 中，并且它们的类型匹配，那么前者是后者的子类型**。即使某些分支在子类型中缺失（因为 $I$ 是 $J$ 的子集），这也不会影响安全性。

#### 3. **对比笛卡尔积类型**

请注意，与笛卡尔积类型 (Product Types) 的子类型规则相比，此处的子集关系方向**相反**。在笛卡尔积类型中，子类型必须包含所有超类型的字段，因此我们有 $J \subseteq I$。而在和类型中，子类型的分支是超类型分支的一个子集，因此我们有 $I \subseteq J$。这对应了产品类型和和类型的对偶性质。

#### 4. **示例**

假设我们有以下两个和类型：

$$
\tau_1 = \sum_{i \in \{1, 2, 3\}} \tau_i
$$

和

$$
\tau_2 = \sum_{j \in \{1, 2\}} \tau_j
$$

根据子类型规则 23.4，因为 $\{1, 2\} \subseteq \{1, 2, 3\}$ 并且相应的分支类型匹配，$\tau_2$ 是 $\tau_1$ 的子类型。这意味着，如果程序需要 $\tau_1$ 类型的值，我们可以传递一个 $\tau_2$ 类型的值，程序可以安全地执行相应的 `case` 分析。

### 小结

和类型的子类型规则基于 `case` 分析操作。如果子类型的所有分支都是超类型的子集，并且类型匹配，那么子类型可以安全地作为超类型使用。这种子类型规则与笛卡尔积类型的规则在逻辑上是对偶的，因此方向相反。

### ---------------------------------

### 23.3 Variance

在子类型关系中，**型构造器**（type constructor）的行为非常重要。型构造器可以根据其参数的子类型关系表现为**协变**（covariant）、**逆变**（contravariant）、或**不变**（invariant）。这些概念帮助我们理解和构造复杂类型的子类型关系。

#### 1. **协变 (Covariance)**

型构造器在一个参数上是协变的，当该构造器保持该参数的子类型关系时。也就是说，如果 $\tau_1 <: \tau_2$，并且构造器 $F$ 是协变的，那么 $F(\tau_1) <: F(\tau_2)$。

#### 2. **逆变 (Contravariance)**

型构造器在一个参数上是逆变的，当该构造器反转该参数的子类型关系时。即如果 $\tau_1 <: \tau_2$，并且构造器 $F$ 是逆变的，那么 $F(\tau_2) <: F(\tau_1)$。

#### 3. **不变 (Invariant)**

如果子类型关系在型构造器的参数上没有任何作用，那么该构造器就是不变的。这意味着，即使 $\tau_1 <: \tau_2$，$F(\tau_1)$ 和 $F(\tau_2)$ 之间也没有明确的子类型关系。

### **Product 和 Sum Types 的协变性**

**笛卡尔积类型**和**和类型**的协变性是直观的：

1. **Product Types (笛卡尔积类型)**

笛卡尔积类型（例如 $\tau_1 \times \tau_2$）在其参数上是**协变的**。如果 $\tau'_1 <: \tau_1$ 且 $\tau'_2 <: \tau_2$，那么：
$$
\tau'_1 \times \tau'_2 <: \tau_1 \times \tau_2
$$
换句话说，积类型的子类型关系基于其每个成分的子类型关系。如果你可以将 $\tau'_1$ 和 $\tau'_2$ 视为 $\tau_1$ 和 $\tau_2$ 的子类型，那么积类型的整体也是协变的。

2. **Sum Types (和类型)**

和类型（例如 $\tau_1 + \tau_2$）也具有协变性。如果 $\tau'_1 <: \tau_1$ 且 $\tau'_2 <: \tau_2$，则：
$$
\tau'_1 + \tau'_2 <: \tau_1 + \tau_2
$$
这意味着和类型的子类型关系也基于其各成分的子类型关系。

### **函数类型的协变与逆变**

函数类型的协变性和逆变性有些复杂。考虑函数类型 $\tau_1 \to \tau_2$：

1. **参数类型的逆变性 (Contravariant Argument)**

在函数的参数上，子类型关系是**逆变的**。如果 $\tau'_1 <: \tau_1$，则：
$$
\tau_1 \to \tau_2 <: \tau'_1 \to \tau_2
$$
这是因为在调用函数时，我们可以提供的参数类型应该更广泛，而不是更具体。

2. **返回类型的协变性 (Covariant Result)**

在函数的返回类型上，子类型关系是**协变的**。如果 $\tau'_2 <: \tau_2$，则：
$$
\tau_1 \to \tau'_2 <: \tau_1 \to \tau_2
$$
这是因为函数的返回值可以是超类型，确保返回值可以被接受。

#### **总结：函数类型的逆变与协变**

总结起来，🥑函数类型 $\tau_1 \to \tau_2$ 对参数是逆变的，对返回值是协变的：
$$
(\tau'_1 <: \tau_1) \land (\tau_2 <: \tau'_2) \Rightarrow (\tau_1 \to \tau_2 <: \tau'_1 \to \tau'_2)
$$

### -------------------------------------------

### **函数类型的逆变与协变**

函数类型在参数和返回值之间存在不同的变异性。总结如下：

- **函数参数是逆变的（Contravariant）**: 如果$\tau'_1<:\tau_1$（即$\tau'_1$是$\tau_1$的子类型），那么在函数类型中，$\tau_1 \to \tau_2$中的参数类型$\tau_1$和$\tau'_1$的关系是逆变的。因此，子类型关系的方向相反，意味着如果$\tau'_1$是$\tau_1$的子类型，那么$\tau_1 \to \tau_2$和$\tau'_1 \to \tau_2$之间会保持相反的子类型关系。
  
- **函数返回值是协变的（Covariant）**: 如果$\tau_2<:\tau'_2$（即$\tau_2$是$\tau'_2$的子类型），则在函数类型中，$\tau_1 \to \tau_2$中的返回类型$\tau_2$和$\tau'_2$的关系是协变的。也就是说，返回类型的子类型关系和函数类型的子类型关系方向相同。

### **公式表示**

$$
(\tau'_1 <:\tau_1) \land (\tau_2 <:\tau'_2) \Rightarrow (\tau_1 \to \tau_2 <:\tau'_1 \to \tau'_2)
$$

- **解释**: 对于两个函数类型$\tau_1 \to \tau_2$和$\tau'_1 \to \tau'_2$，如果$\tau'_1$是$\tau_1$的子类型，且$\tau_2$是$\tau'_2$的子类型，那么函数类型$\tau_1 \to \tau_2$就是$\tau'_1 \to \tau'_2$的子类型。换句话说，函数的参数类型遵循逆变原则，而返回值类型遵循协变原则。

### **例子**

假设有以下类型关系：

- `Cat<:Animal`
- `String<:AnyRef`

我们可以定义函数类型：

1. **协变返回值**: 假设有函数$f_1:Animal \to String$，返回值类型是协变的。因为$String<:AnyRef$，所以我们可以推导出$f_1:Animal \to String$是$f_2:Animal \to AnyRef$的子类型。
   
2. **❌逆变参数**: 假设有函数$f_3:Animal \to String$和$f_4:Cat \to String$。因为$Cat<:Animal$，参数类型逆变，因此$f_4$是$f_3$的子类型。

### **总结**

在函数类型中：

- 参数类型 **逆变**：子类型关系相反。
- 返回值类型 **协变**：子类型关系相同。

这一规则保证了类型系统的安全性，确保函数调用时传入的参数和返回的结果都是类型兼容的。

> 笨蛋ChatGPT，必须仔细检查生成结果

这句话不正确。

**正确的解释应该是：**

根据**逆变的定义**，当一个类型构造器对参数是逆变时，**子类型关系的方向是反的**。在函数类型中，**参数类型是逆变的**，这意味着如果$Cat<:Animal$，那么**$Animal \to String$是$Cat \to String$的子类型**，而不是反过来。

### 正确的例子：

- 假设有两个函数类型：
  - $f_1: Animal \to String$
  - $f_2: Cat \to String$

根据逆变的规则，**$f_1$（$Animal \to String$）是$f_2$（$Cat \to String$）的子类型**，因为在函数类型中，参数的子类型关系是逆变的：**参数类型越具体，函数越灵活**。

### 正确的解释：

- **逆变参数**: 假设有函数$f_1:Animal \to String$和$f_2:Cat \to String$。因为$Cat<:Animal$，**参数类型逆变**，因此**$f_1$是$f_2$的子类型**。

### -------------------------------------------



### 详解：
### **Variance（变异性）**

变异性（Variance）是类型系统中的一个重要概念，它描述了在类型构造器中，类型参数如何影响子类型关系。它常见于面向对象编程语言和函数式编程语言的类型系统中，用来控制泛型（Generics）或多态（Polymorphism）的行为。在理解泛型系统中的类型安全性时，变异性非常关键。

#### **三种常见的变异性**

1. **协变（Covariant）**
   - **定义**: 当类型构造器 $F$ 对其参数是协变的，如果有 $A <: B$，即类型 $A$ 是 $B$ 的子类型，那么构造器 $F(A)$ 也是 $F(B)$ 的子类型。协变性反映了类型构造器在子类型关系中保持相同的方向。
   - **公式表示**:
     $$
     A <: B \quad \Rightarrow \quad F(A) <: F(B)
     $$
   - **例子**: 在函数式编程语言中，`List[A]` 是一个协变的类型构造器。如果我们有类型关系 `Cat <: Animal`，那么我们可以推导出 `List[Cat] <: List[Animal]`。这意味着我们可以将 `List[Cat]` 赋值给需要 `List[Animal]` 的位置。

   **示例**:
   ```scala
   trait Animal
   class Cat extends Animal
   class Dog extends Animal
   
   val cats: List[Cat] = List(new Cat, new Cat)
   val animals: List[Animal] = cats  // 协变允许这种赋值
   ```

2. **逆变（Contravariant）**
   - **定义**: 当类型构造器 $F$ 对其参数是逆变的，如果 $A <: B$，则 $F(B)$ 是 $F(A)$ 的子类型。逆变性描述了类型构造器在子类型关系中方向相反。
   - **公式表示**:
     $$
     A <: B \quad \Rightarrow \quad F(B) <: F(A)
     $$
   - **例子**: 在函数参数类型中经常使用逆变性。例如，假设 `Printer[A]` 是一种用于打印对象的类型构造器。如果 `Animal` 是 `Cat` 的超类型，则 `Printer[Animal]` 可以赋值给 `Printer[Cat]`，因为 `Printer[Animal]` 可以打印任何 `Cat`。

   **示例**:
   ```scala
   trait Printer[-A] {
     def print(a: A): Unit
   }
   
   val animalPrinter: Printer[Animal] = new Printer[Animal] {
     def print(a: Animal): Unit = println("Animal: " + a)
   }
   
   val catPrinter: Printer[Cat] = animalPrinter  // 逆变允许这种赋值
   ```

3. **不变（Invariant）**
   - **定义**: 如果类型构造器 $F$ 是不变的，无论 $A$ 和 $B$ 之间的关系如何，$F(A)$ 和 $F(B)$ 之间都不存在子类型关系。不变性意味着类型构造器既不是协变的也不是逆变的。
   - **公式表示**:
     $$
     A <: B \quad \Rightarrow \quad F(A) \not<: F(B) \quad 且 \quad F(B) \not<: F(A)
     $$
   - **例子**: 数组通常是不变的。例如，在某些编程语言中，如 Java 中的数组，如果 `Cat[]` 和 `Animal[]` 是不变的类型构造器，那么即使 `Cat <: Animal`，我们也不能将 `Cat[]` 赋值给 `Animal[]`。

   **示例**:
   ```java
   class Animal {}
   class Cat extends Animal {}
   
   Animal[] animals = new Animal[10];
   Cat[] cats = new Cat[10];
   animals = cats;  // 编译错误，因为数组是不变的
   ```

#### **变异性的实际应用**

变异性在函数式编程、面向对象编程和类型系统中非常重要，特别是在使用泛型和多态的场景下。不同的变异性帮助我们更好地管理类型安全性，尤其是在函数参数传递、返回值和集合处理等情境中。

### ---------------------------------------

函数类型的**协变和逆变**设计背后的原因与**类型安全性**紧密相关。它确保我们在进行子类型转换时，不会发生违反类型规则的错误。

### 函数类型的协变与逆变设计：

- **参数类型的逆变**：这意味着如果$A<:B$（$A$是$B$的子类型），那么函数类型$B \to C$应该是$A \to C$的子类型。原因是，如果我们允许使用一个更具体的类型（如$A$）作为参数，那么更广泛的类型（如$B$）也可以接受这个参数。

- **返回类型的协变**：这意味着如果$C<:D$，那么函数类型$A \to C$应该是$A \to D$的子类型。原因是，函数返回的类型应该是更宽泛的子类型，以便调用者可以接受所有可能的返回值。

#### 举例说明：

- **逆变参数**：假设有一个函数$f_1:Animal \to String$，它可以接受任何类型为$Animal$的输入并返回一个字符串。如果$Cat<:Animal$，那么我们应该可以使用$f_1$的类型，而不必担心输入的参数。如果允许将函数的参数类型变得更具体，意味着我们可以接受“更广泛的”参数类型，这就是逆变的理由。

- **协变返回值**：假设我们有一个函数$f_2:Animal \to Animal$，返回一个`Animal`实例。我们也可以将它看作返回`Cat`实例的函数，因为`Cat<:Animal`。这就是

### 如果违反这种设计的类型系统会导致哪些不安全问题？

#### 1. **参数类型的安全性问题**（违反逆变）：

假设你允许参数类型是协变的。也就是说，如果$Cat<:Animal$，你允许$Cat \to String$成为$Animal \to String$的子类型。这会导致严重的类型安全问题。

- 举例：如果你有一个函数$f:Cat \to String$，但将它赋值给一个接受`Animal`类型的函数（假设这是允许的），那么这个函数可能会被调用，传入一个`Dog`（`Dog<:Animal`），但由于$f$只能接受`Cat`，会导致运行时错误。

#### 2. **返回类型的安全性问题**（违反协变）：

假设你允许返回值类型是逆变的。这意味着如果$Animal<:Cat$，你允许$A \to Animal$成为$A \to Cat$的子类型。这样设计也会破坏类型安全。

- 举例：你有一个函数$f:A \to Cat$，但被视为返回类型为`Animal`的函数。如果代码期望一个`Cat`实例，并调用了与`Cat`相关的特定方法，而实际返回的是`Animal`，这会导致错误，因为`Animal`不一定具备所有`Cat`的方法和属性。

### 违反协变和逆变会导致以下两类错误：

1. **参数类型问题（违反逆变）**：将一个更具体的函数应用到更广泛的参数类型时，导致不匹配，破坏了安全性。
2. **返回类型问题（违反协变）**：返回一个不符合期望类型的值，破坏了接收方的类型安全。

### 总结：

协变与逆变的设计确保了在类型系统中函数的安全性：

- **逆变参数**确保了函数能够安全地接受更广泛的输入，而不会引发类型错误。
- **协变返回**确保了调用方可以处理更具体的返回值，而不会因为返回的值类型太宽泛而出现问题。

如果违反这些规则，会导致类型系统无法确保在函数调用时的类型一致性，从而导致类型错误，破坏了代码的安全性。

### -----------------------------------------

### 函数类型的逆变与协变中的“更具体”和“更广泛”解释

在类型系统中，**更具体**和**更广泛**描述了子类型和父类型的关系，通常用于定义类型间的约束。

- **更具体**（more specific）：指一个类型是另一个类型的**子类型**。子类型提供了更多的约束和特性。例如，$Cat$ 是 $Animal$ 的子类型，因此 $Cat$ 是“更具体”的类型。它包含 $Animal$ 所有的属性，但有额外的特性。
  
- **更广泛**（more general）：指一个类型是另一个类型的**父类型**。父类型定义较宽泛的约束，能涵盖更多种类的对象。例如，$Animal$ 是 $Cat$ 的父类型，因此 $Animal$ 是“更广泛”的类型。

### 协变与逆变中的“更具体”和“更广泛”

#### 1. **参数类型的逆变**

假设有一个函数 $f_1 : Animal \to String$，它接受 $Animal$ 类型的参数。你可以传入 $Dog$ 或 $Cat$，因为它们都是 $Animal$ 的子类型。如果我们允许将函数参数的类型从更广泛的 $Animal$ 变为更具体的 $Cat$，会带来不安全性。

考虑另一个函数 $f_2 : Cat \to String$，它只能接受 $Cat$ 类型的参数。如果我们将 $f_2$ 的类型视为 $f_1$ 的子类型，这会导致不安全。因为 $f_2$ 无法接受 $Dog$ 类型的参数，而 $f_1$ 是可以的。为了避免这种不安全性，参数类型遵循**逆变**的设计：

$$
A <: B \quad \Rightarrow \quad (B \to C) <: (A \to C)
$$

这意味着函数的参数类型可以变得更**广泛**，即接受更通用的输入类型（如 $Animal$），但不能变得更具体（如 $Cat$），否则会破坏类型安全性。

#### 2. **返回值类型的协变**

返回值类型遵循**协变**的设计。假设有函数 $f_3 : Animal \to Animal$，它返回 $Animal$ 类型的对象。如果允许将它的返回值类型变为 $Cat$，即函数 $f_4 : Animal \to Cat$，这是安全的，因为 $Cat$ 是 $Animal$ 的子类型。

协变允许返回值变得**更具体**，这是安全的。因为调用者期望得到的类型是 $Animal$，而返回一个更具体的 $Cat$ 不会引发错误。例如：

$$
A <: B \quad \Rightarrow \quad (C \to A) <: (C \to B)
$$

### 总结

- **更具体**：子类型，表示更加细化和精确的类型。
- **更广泛**：父类型，表示更宽泛和通用的类型。
- **逆变**：函数参数类型必须变得更**广泛**，这样函数可以处理更通用的输入。
- **协变**：函数返回值类型可以变得更**具体**，确保调用方能够正确处理更精确的返回类型。

这种设计保证了类型系统的**安全性**，在函数调用时避免了潜在的类型错误。

### -------------------------------------------

### **量化类型 (Quantified Types)**

量化类型（例如 $\forall t. \tau$ 和 $\exists t. \tau$）的协变性和逆变性取决于具体的量化方式。**全称量化类型**（$\forall$ 类型）通常是协变的，因为对于所有可能的类型参数，该类型都必须成立。而**存在量化类型**（$\exists$ 类型）则要求能够抽象出特定的实现，因此在某些情形下可能表现为逆变或不变。

### **递归类型 (Recursive Types)**

递归类型的子类型关系相对复杂，因为这些类型在定义时涉及自身。通常，递归类型的协变性可以通过基于类型展开的递归定义来分析。具体的子类型关系要依赖于递归展开的具体情况，以及对每个展开步骤的子类型检验。

### **总结**

型构造器的**协变性**、**逆变性**和**不变性**为子类型关系提供了更丰富的推理机制。对类型构造器的变性分析能够帮助我们理解和定义更复杂的子类型关系，特别是在涉及函数、产品、和、量化以及递归类型时。这些分析为构建强健的静态类型系统提供了理论基础。

### ---------------------------------

### 23.3.1 Product and Sum Types

#### 1. **Product Types (笛卡尔积类型)**

笛卡尔积类型是**协变的**，即在每个字段上都保持子类型关系。协变的意思是，如果产品类型 $\tau_i'$ 的每个成分 $\tau_i'$ 都是 $\tau_i$ 的子类型（即 $\tau_i' <: \tau_i$），那么整个产品类型也是相应产品类型的子类型。

这一规则可以形式化为：
$$
(∀i ∈ I) \, \tau_i' <: \tau_i \quad \Rightarrow \quad \prod_{i \in I} \tau_i' <: \prod_{i \in I} \tau_i
$$

在这条规则中，$\prod_{i \in I} \tau_i'$ 和 $\prod_{i \in I} \tau_i$ 表示有限个类型的笛卡尔积。换句话说，只要每个字段满足子类型关系，那么整体的产品类型也会满足子类型关系。

这种类型的子类型规则体现在投影操作中。例如，对于一个类型为 $\prod_{i \in I} \tau_i'$ 的表达式 $e$，我们对它的 $j$ 维度进行投影 $e \cdot j$，该操作预期返回 $\tau_j$ 类型的值。如果 $e$ 是 $\prod_{i \in I} \tau_i'$ 的子类型，并且 $j$ 是一个有效的维度，那么只需要 $\tau_j'$ 是 $\tau_j$ 的子类型即可。

#### 2. **Sum Types (和类型)**

和类型（即有限和类型）也是**协变的**。对于和类型 $\sum_{i \in I} \tau_i$，如果每个分支类型 $\tau_i'$ 都是相应的 $\tau_i$ 的子类型，则整个和类型也是对应的和类型的子类型。

这一规则形式化为：
$$
(∀i ∈ I) \, \tau_i' <: \tau_i \quad \Rightarrow \quad \sum_{i \in I} \tau_i' <: \sum_{i \in I} \tau_i
$$

在这种情况下，如果我们在一个超级类型上执行 case 分析操作，那么每个分支都需要处理对应的 summand 类型。如果我们能够提供一个子类型的 summand，整个 case 分析也能够正常工作。

### 公式解析

#### **Product Type Subtyping (产品类型子类型关系)**
公式 $(23.5)$ 表示有限产品类型的协变性：
$$
(∀i ∈ I) \, \tau_i' <: \tau_i \quad \Rightarrow \quad \prod_{i \in I} \tau_i' <: \prod_{i \in I} \tau_i
$$

- **左侧条件**：对所有 $i \in I$，每个 $\tau_i'$ 是 $\tau_i$ 的子类型，即每个成分 $\tau_i'$ 都可以替代 $\tau_i$。
- **右侧结论**：整个产品类型 $\prod_{i \in I} \tau_i'$ 是 $\prod_{i \in I} \tau_i$ 的子类型。

这是基于产品类型的性质推导出的：如果每个成分都是子类型，那么整个产品类型也可以被看作是超类型的子类型。

#### **Sum Type Subtyping (和类型子类型关系)**
公式 $(23.6)$ 表示有限和类型的协变性：
$$
(∀i ∈ I) \, \tau_i' <: \tau_i \quad \Rightarrow \quad \sum_{i \in I} \tau_i' <: \sum_{i \in I} \tau_i
$$

- **左侧条件**：对所有 $i \in I$，每个 $\tau_i'$ 是 $\tau_i$ 的子类型。
- **右侧结论**：整个和类型 $\sum_{i \in I} \tau_i'$ 是 $\sum_{i \in I} \tau_i$ 的子类型。

这种推导基于和类型的性质：如果每个分支中的 summand 都是超类型的 summand，那么整个和类型可以认为是超类型的子类型。

这些规则确保了产品和和类型的子类型关系基于各个成分的子类型关系，并且在投影和 case 分析等操作中能够正确保持类型安全性。

### ---------------------------------

### 23.3.2 Function Types (函数类型的变异性)

函数类型的变异性（variance）有些复杂，需要分别讨论其在**参数类型**（domain）和**返回类型**（range）上的行为。

#### **1. Covariance in the Range (返回类型上的协变性)**

我们先来看返回类型上的协变性。如果我们有一个函数 $e$，它的类型是 $\tau_1 \to \tau_2'$，这意味着 $e$ 可以接受类型为 $\tau_1$ 的参数并返回类型为 $\tau_2'$ 的结果。

如果 $\tau_2' <: \tau_2$（即 $\tau_2'$ 是 $\tau_2$ 的子类型），那么当我们将类型为 $\tau_1$ 的值应用到 $e$ 时，返回的值不仅是 $\tau_2'$ 类型的，也是 $\tau_2$ 类型的。这意味着**函数类型在返回类型上是协变的**。可以总结为以下规则：
$$
\tau_2' <: \tau_2 \quad \Rightarrow \quad \tau_1 \to \tau_2' <: \tau_1 \to \tau_2
$$
这个规则表明：如果一个函数返回类型 $\tau_2'$ 是 $\tau_2$ 的子类型，那么整个函数类型也是协变的。

#### **2. Contravariance in the Domain (参数类型上的逆变性)**

接下来讨论参数类型。假设我们有一个函数 $e : \tau_1 \to \tau_2$，这意味着 $e$ 可以接受任何类型为 $\tau_1$ 的参数，并返回类型为 $\tau_2$ 的值。根据**子类型替代原则**，如果我们可以将 $e$ 应用到类型为 $\tau_1$ 的值，那么也可以应用到类型为 $\tau_1$ 的**子类型** $\tau_1'$ 的值，并且仍然会返回 $\tau_2$ 类型的值。

因此，我们可以认为 $e$ 的类型是 $\tau_1' \to \tau_2$，只要 $\tau_1' <: \tau_1$。这种现象称为**逆变性**，即函数类型在参数类型上是逆变的。该原则可以形式化为：
$$
\tau_1' <: \tau_1 \quad \Rightarrow \quad \tau_1 \to \tau_2 <: \tau_1' \to \tau_2
$$

注意这个规则中子类型关系在参数位置被**逆转了**。这意味着，虽然在返回类型上是协变的，但在参数类型上是逆变的。

#### **3. General Rule for Function Types (函数类型的一般规则)**

结合上面的两条规则，我们得到一个完整的函数类型的变异性原则。函数类型在**参数类型**上是**逆变的**，在**返回类型**上是**协变的**：
$$
\tau_1' <: \tau_1 \quad \text{and} \quad \tau_2' <: \tau_2 \quad \Rightarrow \quad \tau_1 \to \tau_2' <: \tau_1' \to \tau_2
$$

#### **公式解析**

##### 1. **返回类型上的协变性公式 (公式 23.7)**:
$$
\tau_2' <: \tau_2 \quad \Rightarrow \quad \tau_1 \to \tau_2' <: \tau_1 \to \tau_2
$$
解释：如果一个函数的返回类型 $\tau_2'$ 是 $\tau_2$ 的子类型，则整个函数类型是协变的。换句话说，任何能够返回类型为 $\tau_2'$ 的函数也能返回类型为 $\tau_2$。

##### 2. **参数类型上的逆变性公式 (公式 23.8)**:
$$
\tau_1' <: \tau_1 \quad \Rightarrow \quad \tau_1 \to \tau_2 <: \tau_1' \to \tau_2
$$
解释：如果一个函数的参数类型 $\tau_1'$ 是 $\tau_1$ 的子类型，则整个函数类型是逆变的。也就是说，任何接受类型为 $\tau_1$ 参数的函数也能接受类型为 $\tau_1'$ 的参数。

##### 3. **函数类型的一般变异性规则 (公式 23.9)**:
$$
\tau_1' <: \tau_1 \quad \text{and} \quad \tau_2' <: \tau_2 \quad \Rightarrow \quad \tau_1 \to \tau_2' <: \tau_1' \to \tau_2
$$
解释：当返回类型是协变的，参数类型是逆变的时，整个函数类型的子类型关系成立。

通过这些规则，函数类型的子类型关系在编程语言中得到了严格的定义，使得类型系统能够正确地推断和检查复杂函数的类型安全性。

### ---------------------------------

### 23.3.3 Quantified Types (量化类型的变异性)

在扩展到量化类型时，我们需要处理形如 $\Delta \vdash \tau_0 <: \tau$ 的子类型判断，其中 $\Delta \vdash \tau_0$ 和 $\Delta \vdash \tau$ 是类型。对于量化类型的子类型，主要关注其**协变性**。我们将在以下内容中详细解释。

#### **1. Universal Quantification (全称量化的协变性)**

全称量化表示形式为 $\forall(t.\tau)$，即对某个类型 $t$ 量化的类型表达式。要确保全称量化类型是协变的，我们需要证明如果 $\tau_0 <: \tau$ 成立，那么 $\forall(t.\tau_0)$ 也是 $\forall(t.\tau)$ 的子类型。正式的规则如下：
$$
\Delta, t \ \text{type} \vdash \tau_0 <: \tau \quad \Rightarrow \quad \Delta \vdash \forall(t.\tau_0) <: \forall(t.\tau)
$$
这意味着，如果在上下文 $\Delta$ 下 $t$ 类型的所有实例中 $\tau_0 <: \tau$，那么我们可以推导出 $\forall(t.\tau_0) <: \forall(t.\tau)$。换句话说，全称量化是协变的。

公式 (23.10a) 形式化了这一点：
$$
\Delta, t \ \text{type} \vdash \tau_0 <: \tau \quad \Rightarrow \quad \Delta \vdash \forall(t.\tau_0) <: \forall(t.\tau)
$$

#### **2. Existential Quantification (存在量化的协变性)**

存在量化类型表示形式为 $\exists(t.\tau)$，即存在某个类型 $t$ 使得类型表达式 $\tau$ 成立。对于存在量化，我们也期望其是协变的，类似于全称量化。如果 $\tau_0 <: \tau$，那么 $\exists(t.\tau_0)$ 也是 $\exists(t.\tau)$ 的子类型。形式化的规则如下：
$$
\Delta, t \ \text{type} \vdash \tau_0 <: \tau \quad \Rightarrow \quad \Delta \vdash \exists(t.\tau_0) <: \exists(t.\tau)
$$
这意味着存在量化类型也是协变的。

公式 (23.10b) 表述了存在量化的协变性：
$$
\Delta, t \ \text{type} \vdash \tau_0 <: \tau \quad \Rightarrow \quad \Delta \vdash \exists(t.\tau_0) <: \exists(t.\tau)
$$

#### **3. Substitution and Subtyping (替换与子类型)**

在处理量化类型时，替换也是至关重要的。假设 $\Delta, t \ \text{type} \vdash \tau_0 <: \tau$，并且 $\Delta \vdash \rho \ \text{type}$，那么我们可以推导出 $\Delta \vdash [\rho/t]\tau_0 <: [\rho/t]\tau$。这意味着在对类型变量 $t$ 替换成具体类型 $\rho$ 后，子类型关系仍然成立。

**替换引理** (Lemma 23.1) 可以表示为：
$$
\text{如果} \ \Delta, t \ \text{type} \vdash \tau_0 <: \tau \ \text{并且} \ \Delta \vdash \rho \ \text{type}, \ \text{那么} \ \Delta \vdash [\rho/t]\tau_0 <: [\rho/t]\tau
$$
这个引理可以通过对子类型推导的归纳证明。

#### **4. Bounded Quantification (有界量化)**

在一些情况下，我们希望允许对**子类型**进行量化，这被称为**有界量化**。有界量化允许我们对某个指定类型的所有子类型进行量化。为了表达有界量化，我们引入了形如 $t <: \rho$ 的额外假设，表示类型变量 $t$ 只能实例化为 $\rho$ 的子类型。

规则 (23.11d) 表示全称量化在其**界限**上是逆变的，即对于边界类型 $t$，全称量化会逆变：
$$
\Delta \vdash \rho_0 <: \rho \quad \Delta, t \ \text{type}, t <: \rho_0 \vdash \tau_0 <: \tau \quad \Rightarrow \quad \Delta \vdash \forall t <: \rho. \tau_0 <: \forall t <: \rho_0. \tau_0
$$

规则 (23.11e) 表示存在量化在其**界限**上是协变的：
$$
\Delta \vdash \rho_0 <: \rho \quad \Delta, t \ \text{type}, t <: \rho_0 \vdash \tau_0 <: \tau \quad \Rightarrow \quad \Delta \vdash \exists t <: \rho_0. \tau_0 <: \exists t <: \rho. \tau
$$

#### **公式解析**

1. **全称量化的协变性 (公式 23.10a)**:
$$
\Delta, t \ \text{type} \vdash \tau_0 <: \tau \quad \Rightarrow \quad \Delta \vdash \forall(t.\tau_0) <: \forall(t.\tau)
$$
解释：如果在类型 $t$ 的上下文中 $\tau_0$ 是 $\tau$ 的子类型，则全称量化类型 $\forall(t.\tau_0)$ 也是 $\forall(t.\tau)$ 的子类型。

2. **存在量化的协变性 (公式 23.10b)**:
$$
\Delta, t \ \text{type} \vdash \tau_0 <: \tau \quad \Rightarrow \quad \Delta \vdash \exists(t.\tau_0) <: \exists(t.\tau)
$$
解释：类似于全称量化，如果 $\tau_0$ 是 $\tau$ 的子类型，那么存在量化类型 $\exists(t.\tau_0)$ 也是 $\exists(t.\tau)$ 的子类型。

3. **有界量化的逆变性和协变性 (公式 23.11d 和 23.11e)**:
$$
\text{全称量化逆变:} \quad \Delta \vdash \forall t <: \rho. \tau_0 <: \forall t <: \rho_0. \tau_0
$$
$$
\text{存在量化协变:} \quad \Delta \vdash \exists t <: \rho_0. \tau_0 <: \exists t <: \rho. \tau
$$
解释：全称量化在界限上逆变，而存在量化在界限上协变。

这些规则明确了量化类型的子类型关系如何根据上下文和量化范围进行调整。

### ---------------------------------

### 存在类型 (Existential Types) 和全称类型 (Universal Types) 详解

在类型论和编程语言理论中，**存在类型**和**全称类型**是两种关键的多态性类型，它们表达了不同的抽象方式。

---

### 1. **全称类型 (Universal Types)**

**全称类型**用于表达**多态性**，即我们可以编写对多种类型都适用的程序。在全称类型中，某个类型可以被任意替换为其他类型，只要满足约束条件即可。这种类型通常用 **$∀$** (forall) 记号表示。

#### 1.1 定义

全称类型的形式为：

$$
\forall t. \tau
$$

这表示类型 $\tau$ 在所有类型 $t$ 下都成立。我们可以将全称类型理解为“**对所有类型变量** $t$，类型 $\tau$ 都是成立的”。

#### 1.2 示例

例如，考虑一个多态的恒等函数：

$$
id: \forall t. t \to t
$$

这里，函数 $id$ 可以作用于任意类型 $t$，即它对每一个类型 $t$ 都能将一个 $t$ 类型的值映射回 $t$ 类型。

- 当我们使用 `id` 函数时，我们可以实例化这个全称类型，例如 `id[int]` 将会是一个从 `int` 类型映射到 `int` 类型的函数。

#### 1.3 理解

全称类型中的 **$∀$** 可以理解为一种通配符，意味着在所有可能的类型上都可以工作。它在程序设计中常用于表示**通用函数**，例如泛型函数。

- **协变性**：全称类型通常是协变的，可以对类型参数进行替换。
- **用途**：全称类型适用于那些在不同类型上下文中都能通用的函数，特别是在泛型编程中非常常见。

---

### 2. **存在类型 (Existential Types)**

与全称类型不同，**存在类型**用于表达“**存在某种类型**”，即该类型可以是某个未知的具体类型。存在类型常常用于隐藏某些具体实现细节，允许程序处理不同的实现。

#### 2.1 定义

存在类型的形式为：

$$
\exists t. \tau
$$

这表示存在一个类型 $t$，使得类型 $\tau$ 对该类型 $t$ 成立。

#### 2.2 示例

考虑一个容器类型的接口，它存储一个元素，但不需要暴露元素的具体类型：

$$
Container = \exists t. (t, t \to string)
$$

这里的 `Container` 表示我们有一个包含类型 $t$ 的容器，并且 $t$ 具有一个从 $t$ 到 `string` 的函数。程序只关心容器的接口，而不关心 $t$ 是什么类型。

#### 2.3 理解

存在类型中的 **$∃$** 意味着“**有某个类型** $t$，它符合给定的条件”。它表示我们在某些上下文中可以隐藏具体的实现，从而使得代码能够处理不同的具体实现。

- **不透明性**：存在类型具有不透明性，意味着用户不知道这个类型的具体是什么，只知道它满足某些条件。
- **用途**：存在类型多用于抽象数据类型 (ADT)，当我们需要隐藏实现细节，或者当我们希望程序与实现无关时，会使用存在类型。

---

### 3. **全称类型 vs. 存在类型**

**全称类型**和**存在类型**表达的是**多态性**的两个方面：

- **全称类型 (Universal Types)**：允许函数或类型在任意类型上工作，强调的是“对所有类型都有效”。
- **存在类型 (Existential Types)**：隐藏某个具体的类型，强调的是“某个类型存在，但我不告诉你它是什么”。

#### 3.1 形式对比

- **全称类型**表示“**对于所有类型** $t$，$\tau$ 成立”：$\forall t. \tau$
- **存在类型**表示“**存在某种类型** $t$，$\tau$ 成立”：$\exists t. \tau$

#### 3.2 使用场景

- **全称类型**通常用于泛型编程，可以应用于任何类型，例如泛型函数、数据结构等。
- **存在类型**用于隐藏实现细节，通常用于抽象数据类型或模块化编程，使得程序可以与具体实现解耦。

#### 3.3 类型推理

- 在处理全称类型时，编译器通常需要**推导出具体的类型实例**。
- 在处理存在类型时，编译器会将类型视为**不透明的**，只允许在接口中使用该类型，但不能操作其具体实现。

---

### 4. **不安全性**

如果我们在使用全称类型或存在类型时违反了相应的多态性规则，会导致类型系统失去其安全性。

- **全称类型的违例**：假设允许全称类型不受限制地适用于特定类型，将导致类型不安全。比如，在泛型函数中错误地将某一类型参数应用到另一个不相关的类型上。
- **存在类型的违例**：如果允许访问存在类型的具体实现或在未知类型上进行操作，也会导致类型不安全。例如，强制将一个抽象类型实例转换为具体类型。

### 总结

- **全称类型**通过泛型编程实现多态性，使得函数和数据结构可以适用于任意类型。
- **存在类型**通过隐藏实现细节来实现抽象性，允许程序员创建与具体实现无关的接口。

### --------------------------------

### 23.3.3 Quantified Types (量化类型)

#### **全称量化 (Universal Quantification)**

首先，考虑全称量化 $\forall(t.\tau)$，其变异性规则可以通过下面的公式表示：

$$
\Delta, t \ \text{type} \vdash \tau_0 <: \tau \quad \Rightarrow \quad \Delta \vdash \forall(t.\tau_0) <: \forall(t.\tau)
$$

这个公式表明，在上下文 $\Delta$ 中，如果对于类型变量 $t$，类型 $\tau_0$ 是 $\tau$ 的子类型，那么可以推导出 $\forall(t.\tau_0)$ 也是 $\forall(t.\tau)$ 的子类型。

#### **公式解析**

1. $\Delta, t \ \text{type} \vdash \tau_0 <: \tau$ 表示：在上下文 $\Delta$ 中，类型 $\tau_0$ 是 $\tau$ 的子类型。这是一个子类型关系的假设。

2. $\forall(t.\tau_0)$ 和 $\forall(t.\tau)$ 是全称量化类型，表示对某个类型 $t$ 进行量化。在 $\forall(t.\tau_0)$ 中，$t$ 可以被任何类型实例化。

3. 子类型关系 $\forall(t.\tau_0) <: \forall(t.\tau)$ 表明：如果 $\tau_0 <: \tau$ 成立，则对 $t$ 进行全称量化的两个类型也保持这种子类型关系。这意味着对量化类型的变异性来说，全称量化是协变的。

在这个规则中，$t$ 是类型变量，$\tau_0$ 和 $\tau$ 是类型，$\forall(t.\tau_0)$ 和 $\forall(t.\tau)$ 是基于 $t$ 的全称量化类型。

#### **存在量化 (Existential Quantification)**

对于存在量化 $\exists(t.\tau)$，类似的规则如下：

$$
\Delta, t \ \text{type} \vdash \tau_0 <: \tau \quad \Rightarrow \quad \Delta \vdash \exists(t.\tau_0) <: \exists(t.\tau)
$$

这个公式表明，如果对于某个类型变量 $t$，$\tau_0$ 是 $\tau$ 的子类型，则存在量化类型 $\exists(t.\tau_0)$ 也是 $\exists(t.\tau)$ 的子类型。

#### **公式解析**

1. $\exists(t.\tau_0)$ 和 $\exists(t.\tau)$ 是存在量化类型，表示存在某种类型 $t$ 使得 $\tau_0$ 和 $\tau$ 成立。

2. 子类型关系 $\exists(t.\tau_0) <: \exists(t.\tau)$ 表示：如果 $\tau_0 <: \tau$ 成立，则存在量化类型也保持这种子类型关系。因此，存在量化也是协变的。

### 替换引理 (Substitution Lemma)

量化类型中，替换操作也是非常重要的。当我们对类型变量 $t$ 替换为某个具体类型 $ρ$ 时，子类型关系应当保持。这个替换引理可以通过以下公式表示：

$$
\text{如果} \ \Delta, t \ \text{type} \vdash \tau_0 <: \tau \ \text{且} \ \Delta \vdash \rho \ \text{type}, \ \text{那么} \ \Delta \vdash [\rho/t]\tau_0 <: [\rho/t]\tau
$$

#### **公式解析**

1. $\Delta, t \ \text{type} \vdash \tau_0 <: \tau$ 表示在上下文 $\Delta$ 中，$\tau_0$ 是 $\tau$ 的子类型。

2. $\Delta \vdash \rho \ \text{type}$ 表示 $\rho$ 是上下文 $\Delta$ 中的一个有效类型。

3. $[\rho/t]\tau_0$ 表示将类型变量 $t$ 替换为具体类型 $\rho$ 后的 $\tau_0$。类似地，$[\rho/t]\tau$ 是将 $t$ 替换为 $\rho$ 后的 $\tau$。

4. 子类型关系 $[\rho/t]\tau_0 <: [\rho/t]\tau$ 表示：替换后，子类型关系仍然成立。这个引理通过归纳证明。

### 有界量化 (Bounded Quantification)

在量化类型中，有时我们希望只对某个指定类型的**子类型**进行量化，这就是有界量化。为了表达有界量化，我们使用形如 $t <: ρ$ 的额外假设，表示 $t$ 只能实例化为 $ρ$ 的子类型。

有界量化的规则可以通过以下公式表示：

#### **全称量化的逆变性 (Contravariance of Universal Quantification)**

$$
\Delta \vdash \rho_0 <: \rho \quad \Delta, t \ \text{type}, t <: \rho_0 \vdash \tau_0 <: \tau \quad \Rightarrow \quad \Delta \vdash \forall t <: \rho. \tau_0 <: \forall t <: \rho_0. \tau
$$

#### **公式解析**

1. $\Delta \vdash \rho_0 <: \rho$ 表示 $\rho_0$ 是 $\rho$ 的子类型。

2. $\Delta, t \ \text{type}, t <: \rho_0 \vdash \tau_0 <: \tau$ 表示在 $\rho_0$ 的上下文中，$\tau_0$ 是 $\tau$ 的子类型。

3. 全称量化的子类型关系 $\forall t <: \rho. \tau_0 <: \forall t <: \rho_0. \tau$ 表示全称量化在其边界上是**逆变**的。

#### **存在量化的协变性 (Covariance of Existential Quantification)**

$$
\Delta \vdash \rho_0 <: \rho \quad \Delta, t \ \text{type}, t <: \rho_0 \vdash \tau_0 <: \tau \quad \Rightarrow \quad \Delta \vdash \exists t <: \rho_0. \tau_0 <: \exists t <: \rho. \tau
$$

#### **公式解析**

1. 存在量化的子类型关系 $\exists t <: \rho_0. \tau_0 <: \exists t <: \rho. \tau$ 表示存在量化在其边界上是**协变**的。

### 结论

通过以上规则，可以总结出量化类型的协变性和逆变性规则，特别是在有界量化的情况下。

### ---------------------------------

### 23.3.4 Recursive Types (递归类型)

递归类型的变异性规则非常微妙，在编程语言设计中，递归类型的子类型关系往往是错误的根源。为了直观理解这一点，考虑以下两个递归类型的例子：

1. **带标签的二叉树**：节点上带有自然数标签的二叉树类型，可以表示为：
   $$
   \mu t.[\text{empty} , \to \text{unit}, \text{binode} , \to \langle \text{data} , \to \text{nat}, \text{lft} , \to t, \text{rht} , \to t \rangle]
   $$

2. **裸二叉树**：不带标签的二叉树类型，可以表示为：
   $$
   \mu t.[\text{empty} , \to \text{unit}, \text{binode} , \to \langle \text{lft} , \to t, \text{rht} , \to t \rangle]
   $$

现在我们要问：**是否存在子类型关系？** 从直觉上看，带标签的二叉树类型应该是裸二叉树的子类型，因为使用裸二叉树的地方可以忽略节点上的标签。

### 递归类型的复杂性

让我们再来看另一个例子，这次是带有两种节点类型的 “二三树”：

$$
\mu t.[\text{empty} , \to \text{unit}, \text{binode} , \to \tau_2, \text{trinode} , \to \tau_3]
$$
其中，
$$
\tau_2 = \langle \text{lft} , \to t, \text{rht} , \to t \rangle, \quad \tau_3 = \langle \text{lft} , \to t, \text{mid} , \to t, \text{rht} , \to t \rangle.
$$

我们需要问的问题是：**这个类型和上面的二叉树类型之间应该存在怎样的子类型关系？** 直觉上，裸二三树类型应该是裸二叉树类型的超类型，因为二三树包含的结构比二叉树多，且在使用二三树时必须进行三路的 case 分析，这种分析也覆盖了二叉树的情况。

### 子类型规则的尝试

为了捕捉这些例子中的模式，我们需要为递归类型制定一个子类型规则。一个看似合理的规则是：

$$
t \ \text{type} \vdash \tau_0 <: \tau \quad \Rightarrow \quad \mu t.\tau_0 <: \mu t.\tau
$$
$$
\frac{t \ \text{type} \vdash \tau_0 <: \tau}{\mu t.\tau_0 <: \mu t.\tau}
$$

这意味着要判断一个递归类型是否是另一个递归类型的子类型，我们只需比较它们的主体，并将绑定的类型变量视为参数。通过子类型关系的反身性 (reflexivity)，我们有 $t <: t$，因此可以在推导 $\tau_0 <: \tau$ 时使用这一事实。

#### **公式解析**

1. **$\mu t.\tau$**：这是一个递归类型，它表示某种由 $\tau$ 定义的递归结构，$t$ 是递归变量。
2. **$t \ \text{type} \vdash \tau_0 <: \tau$**：表示对于类型变量 $t$，类型 $\tau_0$ 是 $\tau$ 的子类型。
3. **$\mu t.\tau_0 <: \mu t.\tau$**：表示递归类型 $\mu t.\tau_0$ 是递归类型 $\mu t.\tau$ 的子类型。

通过这一规则，我们可以验证带标签的二叉树和裸二叉树之间的子类型关系。要推导出 $\mu t.[\text{data} , \to \text{nat}, \text{lft} , \to t, \text{rht} , \to t]$ 是 $\mu t.[\text{lft} , \to t, \text{rht} , \to t]$ 的子类型，我们只需验证类型

$$
\langle \text{data} , \to \text{nat}, \text{lft} , \to t, \text{rht} , \to t \rangle <: \langle \text{lft} , \to t, \text{rht} , \to t \rangle
$$

显然成立，因为可以忽略 $\text{data}$ 字段。

### 递归类型的更多示例

考虑前面例子中的二三树，其子类型关系的推导过程类似。通过这个规则，可以推导出：

$$
\langle \text{lft} , \to t, \text{rht} , \to t \rangle <: \langle \text{lft} , \to t, \text{rht} , \to t \rangle
$$

递归类型的子类型规则保证了每一层的递归都维持同样的结构。

### 递归类型中的子类型关系挑战

尽管规则 (23.12) 在大多数情况下有效，但它的应用需要特别小心，尤其在递归结构比较复杂的情况下。

### ---------------------------------

在这一节中，我们将探讨递归类型（recursive types）的子类型规则，并分析递归类型子类型推导中的潜在问题。递归类型在编程语言中引入了自引用的结构，因此子类型关系的建立变得更加复杂。

### 错误的递归类型子类型推导规则（Rule 23.12）
首先，我们来看规则 (23.12) 的推导问题。假设我们有两个递归类型：

$$
\tau_0 = \mu t.\{a \mapsto t \to \text{nat}, b \mapsto t \to \text{int}\}
$$

$$
\tau = \mu t.\{a \mapsto t \to \text{int}, b \mapsto t \to \text{int}\}
$$

这里，$\mu t$ 表示递归类型构造符，而 $\{a \mapsto \dots, b \mapsto \dots\}$ 表示一个包含两个字段的类型结构。我们假设 $\text{nat} <: \text{int}$，这意味着自然数类型 $\text{nat}$ 是整数类型 $\text{int}$ 的子类型。

根据规则 (23.12)，我们可以推导出：

$$
\tau_0 <: \tau
$$

然而，这个推导实际上是错误的，接下来我们通过构造反例来证明这一点。

### 反例：不安全的程序
假设有一个表达式 $e : \tau_0$，表示为：

$$
e = \text{fold}(\{a \mapsto \lambda (x:\tau_0). 4, b \mapsto \lambda (x:\tau_0). q((\text{unfold}(x) \cdot a)(x))\})
$$

其中，$q : \text{nat} \to \text{nat}$ 是离散平方根函数。根据规则 $\tau_0 <: \tau$，我们可以推导出 $e : \tau$，因此：

$$
\text{unfold}(e) : \{a \mapsto \tau \to \text{int}, b \mapsto \tau \to \text{int}\}
$$

现在再考虑一个表达式 $e_0 : \tau$，定义为：

$$
e_0 = \text{fold}(\{a \mapsto \lambda (x:\tau). -4, b \mapsto \lambda (x:\tau). 0\})
$$

此时，$e_0$ 中 $a$ 方法返回负数，而 $b$ 方法没有特别的意义。接下来我们计算：

$$
(\text{unfold}(e) \cdot b)(e_0) \quad \rightarrow^* \quad q(-4)
$$

由于 $q$ 是一个作用在自然数上的函数，因此 $q(-4)$ 是一个无法处理的状态（stuck state）。我们得到了一个合法类型的程序却进入了无法继续计算的状态，这说明我们构造了一个不安全的程序。

### 错误的根源
规则 (23.12) 的错误在于我们将递归类型中的自引用关系混淆了。在推导过程中，我们错误地使用了相同的参数来代表两个递归类型，这未能正确处理递归类型中的自引用结构。递归类型的左边变量代表子类型，而右边变量代表父类型，混淆它们导致了不安全的推导。

### 修正的递归类型子类型规则（Rule 23.13）
为了修正这个问题，我们使用**有界量化**（bounded quantification）来正确处理递归类型的自引用。修正后的规则为：

$$
\frac{
  \Delta, t \ \text{type}, t' \ \text{type}, t' <: t \ \vdash \ \tau' <: \tau \quad \Delta, t' \ \text{type} \ \vdash \ \tau' \ \text{type} \quad \Delta, t \ \text{type} \ \vdash \ \tau \ \text{type}
}{
  \Delta \ \vdash \ \mu t'.\tau' <: \mu t.\tau
}
$$

这意味着在判断递归类型 $\mu t'.\tau'$ 是否为 $\mu t.\tau$ 的子类型时，我们假设 $t' <: t$，然后在这个假设下检查 $\tau' <: \tau$ 是否成立。

通过这个修正规则，可以避免不安全的递归类型子类型推导。特别是，反例中由于函数类型的**逆变性**（contravariance）导致的错误推导将不再成立。

---

### 总结
递归类型的子类型推导需要特别小心处理自引用结构。规则 (23.12) 的错误在于混淆了递归类型中的子类型与父类型，而使用有界量化的规则 (23.13) 解决了这一问题，确保了递归类型推导的安全性。

### ---------------------------------

在这一节中，我们将证明带有子类型的语言的**安全性**（safety），这比在没有子类型的语言中更为复杂。**安全性**指的是程序不会进入不良状态，即类型正确的程序不会“卡住”（stuck），也就是说，每个步骤要么是一个合法的值，要么可以进一步计算。带有子类型的语言引入了**子类型约简**（subsumption）的规则，这对我们如何证明**保持性**（preservation）和**进展性**（progress）定理产生了影响。

### 安全性证明的主要步骤

#### 1. 子类型关系的结构性（Structurality）

首先，我们来证明子类型关系和类型判断在递归和替换下的结构性。这为后面的保持性和进展性定理提供基础支持。

**引理 23.2（结构性）**：
1. **子类型的自反性和传递性**：$\tau <: \tau$，并且如果 $\tau_{00} <: \tau_0$ 且 $\tau_0 <: \tau$，则 $\tau_{00} <: \tau$。
2. **类型判断的封闭性**：如果 $\Gamma \vdash e : \tau$ 成立，那么它在**弱化**（weakening）和**替换**（substitution）操作下依然成立。

**证明**：
1. **自反性**：通过对类型结构的归纳（induction on structure of types）可以证明。**传递性**则通过对 $\tau_{00} <: \tau_0$ 和 $\tau_0 <: \tau$ 的推导归纳证明。
2. **封闭性**：通过对第 (11.3) 规则的归纳，并增加第 (23.2) 规则来证明。

#### 2. 反演引理（Inversion Lemma）

接下来，我们证明了一些用于类型判断的**反演引理**，即从特定类型的表达式推导出其更细粒度的结构和条件。

**引理 23.3（反演）**：
1. 如果 $e \cdot j : \tau$，则 $e$ 必须是一个有限积类型 $\prod_{i \in I} \tau_i$，且 $j \in I$，并且 $\tau_j <: \tau$。
2. 如果 $he_i \mid i \in I : \tau$，则 $\prod_{i \in I} \tau'_i <: \tau$，其中 $e_i : \tau'_i$ 对每个 $i \in I$ 成立。
3. 如果 $\tau_0 <: \prod_{j \in J} \tau_j$，则 $\tau_0 = \prod_{i \in I} \tau'_i$，对于某些 $I$ 和某些类型 $\tau'_i$。
4. 如果 $\prod_{i \in I} \tau'_i <: \prod_{j \in J} \tau_j$，则 $J \subseteq I$ 并且 $\tau'_j <: \tau_j$ 对每个 $j \in J$ 成立。

**证明**：通过对子类型和类型规则的归纳，尤其注意第 (23.2) 规则。

#### 3. 保持性定理（Preservation Theorem）

**定理 23.4（保持性）**：如果 $e : \tau$ 并且 $e \to e'$，则 $e' : \tau$。

**证明**：通过对规则 (11.4) 的归纳。例如，考虑规则 (11.4d)，此时 $e = he_i \mid i \in I \cdot k$，且 $e' = e_k$。根据引理 23.3，我们有 $he_i \mid i \in I : \prod_{j \in J} \tau_j$，$k \in J$，且 $\tau_k <: \tau$。通过再次应用引理 23.3，对于每个 $i \in I$，存在 $\tau'_i$ 使得 $e_i : \tau'_i$ 并且 $\prod_{i \in I} \tau'_i <: \prod_{j \in J} \tau_j$。根据引理 23.3，再次推导出 $J \subseteq I$ 并且 $\tau'_j <: \tau_j$ 对每个 $j \in J$ 成立，因此 $e_k : \tau_k$。其他情况与此类似。

#### 4. 规范形式引理（Canonical Forms Lemma）

**引理 23.5（规范形式）**：如果 $e$ 是一个值且 $e : \prod_{j \in J} \tau_j$，那么 $e$ 必须是形如 $he_i \mid i \in I$，其中 $J \subseteq I$，且 $e_j : \tau_j$ 对每个 $j \in J$ 成立。

**证明**：通过对规则 (11.3) 的归纳，增加规则 (23.2) 的应用。

#### 5. 进展性定理（Progress Theorem）

**定理 23.6（进展性）**：如果 $e : \tau$，则 $e$ 要么是一个值，要么存在 $e'$ 使得 $e \to e'$。

**证明**：通过对规则 (11.3) 的归纳，增加规则 (23.2) 的应用。对于规则 (11.4d)，依据引理 23.5 可以得到结论。

---

### 总结

子类型的引入增加了语言的复杂性，特别是在证明安全性时，需要小心处理子类型规则的应用。通过结构性引理、反演引理、保持性定理和进展性定理，我们能够证明子类型系统中的类型正确性仍然保持不变，并且类型正确的程序不会进入无法继续执行的“卡住”状态。这确保了程序在具有子类型的系统中依然是安全的。

### ---------------------------------

### 23.5 备注 (Notes)

**子类型 (Subtyping)** 是编程语言中最被广泛误解的概念之一。子类型主要作为一种便利机制，类似于**类型推导 (Type Inference)**，使得编写某些程序变得更加简单。然而，**子类型约简规则 (Subsumption Rule)** 是一把双刃剑。它允许我们在 $\tau_0$ 是 $\tau$ 的子类型时，将类型 $\tau_0$ 的表达式隐式转换为类型 $\tau$ 的表达式。这一机制虽然简化了编程，但也削弱了类型断言的表达能力。当我们说 $e : \tau$ 时，这不再意味着 $e$ 的类型正好是 $\tau$，而是意味着 $e$ 的类型包含在 $\tau$ 之内。

这种弱化使得难以表达诸如“$e$ 的类型必须精确等于 $\tau$”或“两个表达式必须具有相同的类型”这样的需求。而正是这种表达能力的削弱，导致了子类型机制中许多问题的产生。

### 子类型的研究
关于子类型的研究非常丰富。**Standard ML** (Milner 等, 1997) 是最早在大型语言中广泛使用子类型的例子之一。在 ML 的模块系统中，使用了两种子类型关系，分别叫做**增强 (Enrichment)** 和**实现 (Realization)**，这两者分别对应于**积类型 (Product Subtyping)** 和**类型定义 (Type Definitions)**。

关于子类型的系统性研究始于以下几位学者：
- **Mitchell** (1984)
- **Reynolds** (1980)
- **Cardelli** (1988)

Pierce (2002) 对子类型，特别是**递归类型 (Recursive Types)** 和**多态类型 (Polymorphic Types)** 进行了详细的研究，并且证明了对于**有界不可预期的全称量化 (Bounded Impredicative Universal Quantification)** 的子类型判定问题是**不可判定的 (Undecidable)**。

### 关键概念

- **类型推导 (Type Inference)**: 通过编译器自动推断出表达式的类型，而不需要显式地写出类型。
- **子类型约简 (Subsumption Rule)**: 如果 $\tau_0 <: \tau$，那么类型 $\tau_0$ 的表达式也可以被看作是类型 $\tau$ 的表达式。
- **递归类型 (Recursive Types)**: 定义中包含自身的类型，例如树或链表的数据结构。
- **多态类型 (Polymorphic Types)**: 允许类型参数化，即一个类型可以根据上下文决定其具体的类型。

这些概念构成了编程语言类型系统中子类型机制的理论基础，也为后续的编程语言设计提供了重要参考。


### ---------------------------------

### ---------------------------------

### 24. Singleton Kinds

在类型系统中，**单例种类 (Singleton Kinds)** 是一种特别的机制，主要用于处理**类型缩写 (Type Abbreviations)** 和与模块系统相关的概念。我们从基础的**类型定义 (Type Definition)** 开始，逐步构建出这种机制的背景和重要性。

#### **类型定义 (Type Definition)**

首先，考虑一个表达式：
$$
\text{let } e_1: \tau \text{ be } x \text{ in } e_2
$$

这个表达式用于将 $e_1$ 绑定到变量 $x$，然后在 $e_2$ 中使用。在具有函数类型的上下文中，这种表达式可以通过以下 λ 抽象来定义：
$$
(\lambda (x:\tau). e_2)(e_1)
$$

这相当于将 $e_1$ 作为 $e_2$ 中的变量 $x$ 使用，并确保 $x$ 的类型是 $\tau$。

#### **类型缩写 (Type Abbreviation)**

类似于表达式级别的 `let`，我们可以扩展这种机制，使其作用于**类型表达式**。假设我们希望在表达式中引入一个类型缩写，我们可以使用如下形式：
$$
\text{def } t \text{ is } \tau \text{ in } e
$$

这相当于将类型变量 $t$ 绑定为类型 $\tau$，然后在表达式 $e$ 中使用。一个例子是：
$$
\text{def } t \text{ is } \text{nat} \times \text{nat} \text{ in } \lambda (x:t). s(x \cdot l)
$$

在这个例子中，我们定义了一个类型缩写 $t$ 为 $\text{nat} \times \text{nat}$，然后在 λ 抽象中使用 $t$ 作为参数的类型。

为了确保这个表达式类型正确，类型变量 $t$ 必须与 $\text{nat} \times \text{nat}$ 同义，否则 $\lambda (x:t). s(x \cdot l)$ 中的操作可能无法通过类型检查。

#### **问题的初步解决：类型抽象与应用**

我们可以猜测，类型定义的动态行为可以通过**多态实例化**来实现：
$$
\text{def } t \text{ is } \tau \text{ in } e \quad \equiv \quad \Lambda (t.e)[\tau]
$$

这相当于在表达式 $e$ 中使用类型抽象 $\Lambda(t.e)$，并将类型变量 $t$ 绑定为 $\tau$。然而，尽管这种解释捕捉了类型缩写的动态行为，但它在**静态类型检查**方面失败了。按照这种解释，表达式 $e$ 在**没有** $t$ 的任何类型信息的情况下进行类型检查，而不是在知道 $t$ 与 $\tau$ 同义的前提下进行检查。

因此，上述例子中的表达式 $s(x \cdot l)$ 可能无法通过类型检查，除非 $t$ 的绑定被明确暴露出来。

#### **问题的解决：引入单例种类 (Singleton Kinds)**

为了克服上述问题，我们可能会认为类型缩写应该被视为一种**原始概念 (Primitive Concept)**，而不是通过其他机制派生出来。我们可以定义如下的类型规则来支持类型缩写：
$$
\frac{\Gamma \vdash [\tau/t]e : \tau'}{\Gamma \vdash \text{def } t \text{ is } \tau \text{ in } e : \tau'}
$$
这条规则表明，我们在类型系统中直接将 $t$ 视为 $\tau$ 的缩写，并且在表达式 $e$ 中以此为前提进行类型检查。

尽管这种方式能解决问题，但它显得有些**随意 (ad hoc)**，缺乏理论上的优雅性。因此，我们需要一种**更加系统化**的解决方案。这种解决方案的核心在于，通过识别语言结构与类型结构之间的联系，我们能够得到类型缩写的一个自然起源。

#### **单例种类的引入**

为了从类型结构中自然地引入类型缩写，我们考虑一种新的类型结构，称为**单例种类 (Singleton Kinds)**。这种机制不仅可以解释类型缩写，还在后续的模块系统设计中起到关键作用。

**单例种类 (Singleton Kind)** 的概念来源于以下问题：在给定范围内如何确保类型变量 $t$ 与特定类型 $\tau$ 同义。通过引入单例种类，我们能够为每一个类型缩写提供唯一的语义解释，并确保在类型检查中它们的使用是严格一致的。

### 总结

引入单例种类提供了一种**自然的**和**系统化的**方式来处理类型缩写的问题。这种方式不仅解决了局部的类型缩写问题，还为语言设计中的模块化系统提供了坚实的理论基础。在后续章节中，单例种类将被进一步探讨，尤其是它们在模块系统中的作用。

### ---------------------------------

### 24.1 总览 (Overview)

**类型理论的核心原则**是**组合性 (compositionality)**。为了确保程序能够分解成独立的部分，我们要求程序的组成由各部分的类型来中介。换句话说，一个程序的某部分对于另一部分的唯一“了解”就是它的类型。

例如，自然数相加的规则只依赖于其参数的类型（两个参数都必须是 $nat$），而不是它们的具体形式或值。然而，在类型缩写的场景中，如：
$$
\text{def } t \text{ is } \tau \text{ in } e
$$
组合性原则要求 $e$ 对类型变量 $t$ 的唯一“了解”应该是它的种类 (kind)，即 $T$，而不是它的绑定 $\tau$。这与我们在前面提到的用类型抽象和类型应用的方式来解释类型缩写相吻合，但这种解释无法满足类型缩写的初衷。

### **单例种类的引入**

在上面的讨论中，我们可以放弃类型理论的核心原则，直接引入类型缩写作为一种原始概念。但实际上并不需要这样做。我们只需要考虑让类型变量 $t$ 的种类捕捉其**身份 (identity)**，这就是**单例种类 (Singleton Kinds)** 的意义所在。

#### **单例种类的基本概念**

**单例种类** $S(\tau)$ 是一种种类，它表示那些与类型 $\tau$ 具有**定义相等性 (definitional equality)** 的类型。也就是说，从定义上看，$S(\tau)$ 只有一个元素，那就是 $\tau$。

因此，如果 $u$ 是一种**单例种类**的变量，即 $u :: S(\tau)$，那么在其作用范围内，变量 $u$ 与 $\tau$ 同义。这使得我们可以将类型缩写表达为：
$$
\Lambda (t::S(\tau).e)[\tau]
$$
这种表示方式能够在类型检查中正确地将 $t$ 的身份 $\tau$ 传播到 $e$ 中。

### **单例种类需要的扩展**

为了正确处理**单例种类**，我们需要在构造器和种类层面进行一些扩展。主要涉及以下几个方面：

#### 1. **子种类关系 (Subkinding)**

首先，我们需要捕捉**单例种类**是类型种类 $T$ 的一种。换句话说，单例种类的构造器本质上也是类型。因此，$u$ 是单例种类的变量，它应该可以用作类型。然而，仅仅通过种类信息并不能保证这一点。因此，我们引入了**子种类关系** $κ_1 <: κ_2$，它类似于子类型关系，但作用于种类层面。

其中一个重要的子种类规则是：
$$
S(\tau) <: T
$$
表示任何单例种类的构造器都是一种类型。

#### 2. **依赖种类 (Dependent Kinds)**

单例种类引入了**依赖种类 (dependent kinds)**，因为它在种类中混合了构造器和种类的概念。$S(\tau)$ 表示一个由类型构造器 $\tau$ 索引的种类族，这意味着种类可以依赖于构造器。这使得我们必须将产品种类和函数种类推广为**依赖产品** (dependent products) 和**依赖函数** (dependent functions)。

- **依赖产品种类** $\Sigma u::κ_1.κ_2$ 表示成对的构造器 $\langle c_1, c_2 \rangle$，其中 $c_1::κ_1$，并且 $c_2::[c_1/u]κ_2$。这种结构表明第二个成分的种类不仅依赖于第一个成分的种类，还依赖于第一个成分本身。
  
- **依赖函数种类** $\Pi u::κ_1.κ_2$ 表示一种函数，这种函数当应用于构造器 $c_1::κ_1$ 时，会返回一种构造器，其种类为 $[c_1/u]κ_2$。这表明结果的种类不仅依赖于输入构造器的种类，还依赖于它的具体值。

#### 3. **高阶单例种类 (Higher-Order Singleton Kinds)**

除了处理种类 $T$ 的单例种类之外，还可以进一步引入**高阶单例种类**，表示更高层次的种类结构。高阶单例种类的表示为 $S(c::κ)$，其中 $κ$ 是种类，$c$ 是种类 $κ$ 的构造器。这可以通过基本的单例种类和依赖函数、依赖产品种类来定义。

### **总结**

- **单例种类**的引入解决了类型缩写的静态类型检查问题，保持了类型系统的组合性。
- **子种类关系**和**依赖种类**扩展了类型系统的表达能力，允许在类型中捕捉构造器的更多细节。
- **高阶单例种类**进一步拓展了单例种类的应用范围，使其能够应用于更复杂的类型结构。

这种类型结构的扩展为后续更复杂的模块系统设计提供了理论基础，也为解决编程语言中的类型缩写问题提供了优雅的解决方案。

### ---------------------------------

### 24.2 单例种类 (Singletons)

单例种类的静态规则和推导形式通过一组推导规则定义，这些规则确保了单例种类在类型系统中的正确性和一致性。我们将依次解释这些公式及其推导规则。

#### **单例种类的语法** (Syntax of Singleton Kinds)

单例种类的语法如下：
$$
\text{Kind } κ ::= S(c)
$$

这里的 $S(c)$ 表示单例种类 (Singleton Kind)，它的含义是：所有与 $c$ **定义相等**的构造器 (constructor) 都属于该种类。

#### **推导公式解释**

公式的推导横线体现了推导的结构，例如：
$$
\frac{}{\text{推导结论}} \quad \frac{}{\text{推导结论}} 
$$

多个推导结果之间通过横线分隔，体现推导树的层次结构。

#### **关键推导规则的解释**

##### **(24.2a) 单例种类的构造**

当我们有一个构造器 $c$ 的种类是 $Type$ 时，即 $c :: Type$，可以推出 $S(c)$ 是一个种类。用公式表达为：
$$
\frac{\Delta \vdash c :: Type}{\Delta \vdash S(c) \text{ kind}} \quad (24.2a)
$$
解释：此规则说明，若某个构造器 $c$ 是类型种类 ($c :: Type$)，则 $S(c)$ 作为 $c$ 的单例种类也是一个合法的种类 (kind)。这意味着 $S(c)$ 的构造遵循 $c$ 是类型这一事实。

##### **(24.2b) 构造器的单例种类归属**

如果 $c$ 是 $Type$ 种类的构造器，那么它也可以归类为 $S(c)$，即：
$$
\frac{\Delta \vdash c :: Type}{\Delta \vdash c :: S(c)} \quad (24.2b)
$$
解释：这条规则表明构造器 $c$ 不仅属于类型种类，还属于其单例种类 $S(c)$，这意味着 $c$ 是 $S(c)$ 的唯一成员。

##### **(24.2c) 单例种类的等价**

如果构造器 $c$ 属于单例种类 $S(d)$，那么 $c$ 和 $d$ 在类型种类中定义相等，即：
$$
\frac{\Delta \vdash c :: S(d)}{\Delta \vdash c \equiv d :: Type} \quad (24.2c)
$$
解释：该规则说明，如果 $c$ 属于 $S(d)$，那么 $c$ 和 $d$ 是定义相等的。单例种类中的所有构造器在类型种类中都是等价的。

##### **(24.2d) 子种类规则**

如果构造器 $c$ 属于种类 $κ_1$，并且 $κ_1$ 是 $κ_2$ 的子种类，则 $c$ 也属于 $κ_2$，即：
$$
\frac{\Delta \vdash c :: κ_1 \quad \Delta \vdash κ_1 :<: κ_2}{\Delta \vdash c :: κ_2} \quad (24.2d)
$$
解释：此规则描述了种类之间的**子种类关系**。如果 $κ_1$ 是 $κ_2$ 的子种类，那么 $κ_1$ 中的所有构造器也都可以看作是 $κ_2$ 的构造器。

##### **(24.2e) 单例种类的子种类关系**

所有单例种类 $S(c)$ 都是类型种类 $Type$ 的子种类，即：
$$
\frac{\Delta \vdash c :: Type}{\Delta \vdash S(c) :<: Type} \quad (24.2e)
$$
解释：此规则说明，单例种类 $S(c)$ 是 $Type$ 的子种类。也就是说，单例种类中的构造器可以被认为是类型的一部分。

##### **(24.2f) 单例种类的等价性**

如果两个构造器 $c$ 和 $d$ 在类型种类上是等价的，那么它们的单例种类也是等价的，即：
$$
\frac{\Delta \vdash c \equiv d :: Type}{\Delta \vdash S(c) \equiv S(d)} \quad (24.2f)
$$
解释：如果 $c$ 和 $d$ 在类型种类中等价，那么它们的单例种类 $S(c)$ 和 $S(d)$ 也是等价的。这确保了在类型种类上的等价性也传递到了单例种类上。

##### **(24.2g) 子种类的等价性**

如果两种类 $κ_1$ 和 $κ_2$ 是等价的，那么它们也是子种类关系，即：
$$
\frac{\Delta \vdash κ_1 \equiv κ_2}{\Delta \vdash κ_1 :<: κ_2} \quad (24.2g)
$$
解释：如果两种类 $κ_1$ 和 $κ_2$ 是等价的，那么 $κ_1$ 可以作为 $κ_2$ 的子种类。这保持了等价种类之间的一致性。

##### **(24.2h) 子种类的传递性**

如果 $κ_1$ 是 $κ_2$ 的子种类，$κ_2$ 是 $κ_3$ 的子种类，那么 $κ_1$ 也是 $κ_3$ 的子种类，即：
$$
\frac{\Delta \vdash κ_1 :<: κ_2 \quad \Delta \vdash κ_2 :<: κ_3}{\Delta \vdash κ_1 :<: κ_3} \quad (24.2h)
$$
解释：此规则描述了子种类关系的传递性。如果 $κ_1$ 是 $κ_2$ 的子种类，而 $κ_2$ 是 $κ_3$ 的子种类，那么 $κ_1$ 也是 $κ_3$ 的子种类。

#### **总结**

以上推导规则展示了单例种类 (Singleton Kinds) 的静态类型检查机制，通过这些规则，我们可以确保单例种类在类型系统中的定义和等价性。

### 详细解释：

在这一节中，我们介绍了**单例种类**(Singleton Kinds) 的规则，并通过这些规则，探讨了类型定义和子类型关系的处理方式。以下是每个推导规则以及示例的详细解释。

#### **规则 (24.2b)：自我识别** (Self-Recognition)

公式：
$$
\frac{\Delta \vdash c :: Type}{\Delta \vdash c :: S(c)} \quad (24.2b)
$$
解释：**自我识别**原则表明，每个属于种类 $Type$ 的构造器 $c$ 也属于其单例种类 $S(c)$。这反映了构造器的自反性：$c$ 不仅仅是一个类型，它也是自己单例种类的成员。

##### **等价性** (Equivalence)
通过 **规则 (24.2c)**，我们知道：
$$
\frac{\Delta \vdash c :: S(d)}{\Delta \vdash c \equiv d :: Type} \quad (24.2c)
$$
这表明，属于单例种类 $S(d)$ 的构造器 $c$ 与 $d$ 在定义上是等价的。因此，规则 (24.2b) 中的自我识别也可以看作是构造器等价的**自反性**。

#### **规则 (24.2e)：子种类关系** (Subsumption at the Kind Level)

公式：
$$
\frac{\Delta \vdash c :: Type}{\Delta \vdash S(c) :<: Type} \quad (24.2e)
$$
解释：**规则 (24.2e)** 是**子类型原则** (subsumption) 在构造器和种类层面的再表述。它表明，单例种类 $S(c)$ 是 $Type$ 的子种类，即所有 $S(c)$ 的成员可以被视为 $Type$ 的成员。

#### **规则 (24.2f)：单例种类尊重等价性** (Respecting Constructor Equivalence)

公式：
$$
\frac{\Delta \vdash c \equiv d :: Type}{\Delta \vdash S(c) \equiv S(d)} \quad (24.2f)
$$
解释：如果两个构造器 $c$ 和 $d$ 在类型种类上是等价的，那么它们的单例种类也是等价的。这确保了如果两个构造器在其种类中等价，则它们的单例种类也保持等价性。

#### **规则 (24.3) 和 (24.4)：单例种类与变体规则** (Variance Rules for Existentials and Universals)

1. **存在类型的变体规则** (Existential Types Variance):
$$
\frac{\Delta \vdash κ1 :<: κ2 \quad \Delta, u :: κ1 \vdash τ1 <: τ2}{\Delta \vdash \exists u :: κ1.τ1 <: \exists u :: κ2.τ2} \quad (24.3)
$$
解释：这表明，如果 $κ_1$ 是 $κ_2$ 的子种类，并且在 $u$ 被绑定时 $τ_1$ 是 $τ_2$ 的子类型，那么 $\exists u :: κ_1.τ_1$ 也是 $\exists u :: κ_2.τ_2$ 的子类型。通过这个规则，可以将具体类型 $c$ 的存在类型扩展为任意类型 $T$。

2. **全称量化类型的变体规则** (Universal Types Variance):
$$
\frac{\Delta \vdash κ2 :<: κ1 \quad \Delta, u :: κ2 \vdash τ1 <: τ2}{\Delta \vdash \forall u :: κ1.τ1 <: \forall u :: κ2.τ2} \quad (24.4)
$$
解释：对于全称量化类型，若 $κ_2$ 是 $κ_1$ 的子种类，并且 $τ_1$ 是 $τ_2$ 的子类型，那么我们可以推导 $\forall u :: κ1.τ_1 <: \forall u :: κ2.τ_2$。这意味着一个多态函数可以被应用于任意类型 $T$，因此它也可以仅应用于具体的类型 $c$。

#### **示例解析**

假设有一个变量 $u$，其种类为 $S(c)$：
$$
\Delta \vdash u :: S(c)
$$
根据 **规则 (24.2c)**，可以推出：
$$
\Delta \vdash u \equiv c :: T
$$
这表明，变量 $u$ 作为单例种类的成员，它等价于构造器 $c$，且 $u$ 在类型检查中可以直接被视为 $c$。这种等价性实际上表现了**类型定义**的机制，即通过单例种类为 $u$ 赋予 $c$ 的类型身份。

#### **存在类型和全称类型的子类型**

1. **存在类型的子类型关系**：
   - 类型 $\exists u :: S(c).τ$ 表示一种抽象类型，其表示类型等价于 $c$。通过单例种类，存在类型 $\exists u :: S(c).τ$ 与 $\exists u :: T.τ$ 之间可以推导出子类型关系：
   $$
   \exists u :: S(c).τ <: \exists u :: T.τ
   $$
   通过 **规则 (24.3)**，这是因为 $S(c)$ 是 $T$ 的子种类。

2. **全称类型的子类型关系**：
   - 同样地，对于全称类型 $\forall u :: T.τ$，我们可以推导出以下子类型关系：
   $$
   \forall u :: T.τ <: \forall u :: S(c).τ
   $$
   这表示多态函数的应用场景可以从任意类型限制到某个具体的类型 $c$。

#### **总结**

通过这些规则和示例，单例种类提供了一种灵活的机制来定义和推导类型关系。通过单例种类 $S(c)$，我们可以捕获类型定义的概念，并利用这些规则来推导类型的等价性和子类型关系。这不仅保证了类型系统的健全性，还支持了更复杂的类型系统设计，特别是在模块管理和类型抽象的场景中。

### ---------------------------------

### 24.3 依赖种类 (Dependent Kinds)

依赖种类允许种类表达与构造器的参数相关的结果，这是一种更为灵活且表达能力强的类型系统特性。依赖种类通过允许在种类的定义中引用构造器，拓展了普通种类的表达范围。

#### **依赖种类的语法**
依赖种类的语法可以表达构造器对参数的依赖，具体为：
$$
\text{Kind } κ ::= S(c) \quad | \quad Σ(κ1; u.κ2) \quad | \quad Π(κ1; u.κ2)
$$
解释如下：

1. **单例种类** $S(c)$：和前面章节一样，$S(c)$ 表示所有与 $c$ 定义相等的构造器的集合。
2. **依赖积种类** $\Sigma(κ_1; u.κ_2)$：定义了依赖积 (dependent product)，表示种类 $κ_1$ 的构造器 $u$ 与种类 $κ_2$ 的构造器相关。
3. **依赖函数种类** $\Pi(κ_1; u.κ_2)$：定义了依赖函数 (dependent function)，表示种类 $κ_1$ 的构造器 $u$ 被应用到种类 $κ_2$，其中 $κ_2$ 的结果依赖于 $κ_1$ 的构造器。

### **例子：依赖函数和积种类的直观理解**

1. **依赖函数种类** $\Pi(u::κ_1.κ_2)$：
   - 该种类表示当我们传入构造器 $u$，它属于种类 $κ_1$，则产生的结果种类为 $κ_2$，且 $κ_2$ 可能依赖于 $u$。
   - 例如，如果 $κ_1 = T$ 并且 $κ_2 = S(u)$，表示函数结果的种类是 $u$ 的单例种类。

2. **依赖积种类** $\Sigma(u::κ_1.κ_2)$：
   - 该种类表示一对构造器 $hc_1, c_2i$，其中 $c_1$ 属于 $κ_1$，而 $c_2$ 属于种类 $[c_1/u]κ_2$，即 $κ_2$ 的定义依赖于第一个构造器 $c_1$。
   - 例如，如果 $κ_1$ 表示 $int$ 的种类，而 $κ_2$ 表示与 $u$ 相等的构造器种类，$Σ(int; u.S(u))$ 将定义一个对，其中第一个构造器是 $int$，第二个构造器是其单例种类。

### **语法规则**

这些依赖种类使用如下构造器语法：
$$
\text{Con } c ::= u \quad | \quad \text{pair}(c_1; c_2) \quad | \quad \text{proj[l]}(c) \quad | \quad \text{proj[r]}(c) \quad | \quad \text{lam[κ]}(u.c) \quad | \quad \text{app}(c_1; c_2)
$$

解释：
- **变量** $u$：构造器变量，用来表示依赖种类中的参数。
- **pair(c_1, c_2)**：构造一个对 $(c_1, c_2)$，表示积种类的两个构造器。
- **proj[l](c)** 和 **proj[r](c)**：分别从对 $(c_1, c_2)$ 中获取第一个和第二个构造器。
- **lam[κ](u.c)**：定义一个依赖于 $u$ 的构造器，类似函数抽象。
- **app(c_1, c_2)**：将构造器 $c_1$ 应用到构造器 $c_2$，类似于函数应用。

### **依赖种类的应用**

#### **表达依赖关系**

依赖种类允许构造器的结果取决于输入。例如，我们可以定义一个函数类型 $\Pi(u::T.u)$，表示一个函数，它接受类型 $u$ 并返回 $u$ 本身。这种表达在普通函数类型中无法实现。

#### **积种类中的依赖关系**

积种类 $\Sigma(u::κ_1.κ_2)$ 可以表达成对的构造器，其第二个构造器依赖于第一个。例如，$\Sigma(u::int. S(u))$ 表示一个对，其中第一个构造器是一个整数，第二个构造器是这个整数的单例种类。

#### **总结**

依赖种类 (Dependent Kinds) 增强了类型系统的表达能力，允许我们定义更加灵活的类型结构，尤其是在类型之间存在依赖关系的场景下。通过这种扩展，我们可以更加精准地描述类型及其之间的关联，从而提升语言的抽象能力。

### ---------------------------------

### 24.3.1 依赖积种类 (Dependent Product Kind)

依赖积种类 $\Sigma u::\kappa_1.\kappa_2$ 用于分类构造器对 $(c_1, c_2)$，其中 $c_1$ 具有种类 $\kappa_1$，$c_2$ 具有种类 $[c_1/u]\kappa_2$。这种依赖积允许第二个构造器 $c_2$ 的种类依赖于第一个构造器 $c_1$，这使得我们能够表达构造器之间更复杂的相互关系。

#### **例子：$\Sigma u::T.S(u)$**

这个例子表示所有构造器对 $(c, c)$，其中 $c$ 是一个具有种类 $T$ 的构造器。这里的 $S(u)$ 是单例种类，表示所有与 $u$ 相等的构造器。

### **24.3.2 依赖函数种类 (Dependent Function Kind)**

依赖函数种类 $\Pi u::\kappa_1.\kappa_2$ 用于分类构造器 $c$，它应用于种类 $\kappa_1$ 的构造器 $c_1$ 时，生成一个具有种类 $[c_1/u]\kappa_2$ 的构造器。也就是说，这种函数类型允许结果的种类依赖于输入构造器。

#### **例子：$\Pi u::T.S(u)$**

在这个例子中，$\Pi u::T.S(u)$ 表示所有函数，当将其应用于某个构造器 $c$ 时，结果是与 $c$ 相等的构造器。也就是说，这个函数类型基本上描述了恒等函数。

### **更复杂的例子：$\Pi u::T \times T.S(u \cdot r) \times S(u \cdot l)$**

这个例子表示一个函数，它将一对类型进行交换。$u$ 是一个类型对 $(T \times T)$，$S(u \cdot r)$ 和 $S(u \cdot l)$ 分别是取右边和左边分量的单例种类。这个函数交换类型对的左右分量。

### **公式推导与解释**

#### **规则 24.5a：依赖积种类的形成**

$$
\frac{\Delta \vdash \kappa_1 \ \text{kind} \quad \Delta, u::\kappa_1 \vdash \kappa_2 \ \text{kind}}{\Delta \vdash \Sigma u::\kappa_1.\kappa_2 \ \text{kind}}
$$

解释：在此规则中，首先我们要求 $\kappa_1$ 是一个合法的种类 (kind)，其次在上下文 $\Delta$ 下，假设 $u$ 是种类 $\kappa_1$ 的构造器，$\kappa_2$ 也必须是一个合法的种类。这样我们就可以形成依赖积种类 $\Sigma u::\kappa_1.\kappa_2$。

#### **规则 24.5b：依赖积种类的构造器形成**

$$
\frac{\Delta \vdash c_1::\kappa_1 \quad \Delta \vdash c_2::[c_1/u]\kappa_2}{\Delta \vdash \langle c_1, c_2 \rangle::\Sigma u::\kappa_1.\kappa_2}
$$

解释：这里的推导规则表示，如果我们有一个构造器 $c_1$ 具有种类 $\kappa_1$，并且另一个构造器 $c_2$ 具有种类 $[c_1/u]\kappa_2$，那么我们可以构造一个具有依赖积种类 $\Sigma u::\kappa_1.\kappa_2$ 的对 $(c_1, c_2)$。

#### **规则 24.5c：对的左投影**

$$
\frac{\Delta \vdash c::\Sigma u::\kappa_1.\kappa_2}{\Delta \vdash c \cdot l::\kappa_1}
$$

解释：这个规则表明，如果构造器 $c$ 具有依赖积种类 $\Sigma u::\kappa_1.\kappa_2$，那么我们可以通过左投影获取 $c$ 的第一个构造器 $c_1$，它具有种类 $\kappa_1$。

#### **规则 24.5d：对的右投影**

$$
\frac{\Delta \vdash c::\Sigma u::\kappa_1.\kappa_2}{\Delta \vdash c \cdot r::[c_1/u]\kappa_2}
$$

解释：类似地，这个规则表明我们可以通过右投影从构造器 $c$ 中获取第二个构造器 $c_2$，它具有种类 $[c_1/u]\kappa_2$，其中 $c_1$ 是通过左投影得到的。

### **总结**

依赖种类通过允许种类中的参数之间相互依赖，增强了类型系统的表达能力。通过这些规则，我们可以在构造器的种类定义中表达构造器参数之间的依赖关系，实现更灵活的类型和构造器组合。

### ---------------------------------

在本节中，我们将解释构造器等价和依赖积种类的相关规则。通过引入这些规则，类型系统能够支持更加灵活和精确的类型构造与推理。

### 1. 构造器等价 (Constructor Equivalence)

构造器等价定义为一种等价关系，它与构造器和种类 (kind) 的各种形式兼容，这意味着我们可以随时将构造器替换为等价构造器，且替换后的结果仍然保持等价。

### **等价公理 (Equivalence Axioms)**
构造器的等价规则由以下公理定义：

#### **规则 24.6a: 对构造器的左投影**

$$
\frac{\Delta \vdash c_1::\kappa_1 \quad \Delta \vdash c_2::\kappa_2}{\Delta \vdash \langle c_1, c_2 \rangle \cdot l \equiv c_1::\kappa_1}
$$

**解释**：
该规则表示，给定构造器对 $(c_1, c_2)$，其左投影 $\langle c_1, c_2 \rangle \cdot l$ 等价于构造器 $c_1$。这意味着在依赖积种类的上下文中，左投影操作总是返回对的第一个元素，并且该元素具有种类 $\kappa_1$。

#### **规则 24.6b: 对构造器的右投影**

$$
\frac{\Delta \vdash c_1::\kappa_1 \quad \Delta \vdash c_2::\kappa_2}{\Delta \vdash \langle c_1, c_2 \rangle \cdot r \equiv c_2::\kappa_2}
$$

**解释**：
类似地，右投影 $\langle c_1, c_2 \rangle \cdot r$ 等价于构造器 $c_2$，并且该构造器具有种类 $\kappa_2$。这意味着通过右投影，我们可以获取对的第二个元素。

### 2. 依赖积种类的协变性 (Covariance of Dependent Product Kind)

#### **规则 24.7: 协变性**

$$
\frac{\Delta \vdash \kappa_1 :<: \kappa_1' \quad \Delta, u::\kappa_1 \vdash \kappa_2 :<: \kappa_2'}{\Delta \vdash \Sigma u::\kappa_1.\kappa_2 :<: \Sigma u::\kappa_1'.\kappa_2'}
$$

**解释**：
依赖积种类在其两个位置上都是协变的，这意味着如果 $\kappa_1$ 是 $\kappa_1'$ 的子种类，并且 $\kappa_2$ 是 $\kappa_2'$ 的子种类，那么 $\Sigma u::\kappa_1.\kappa_2$ 是 $\Sigma u::\kappa_1'.\kappa_2'$ 的子种类。换句话说，依赖积种类允许类型的逐步“弱化”，即可以从一个更精确的类型推导出一个更一般的类型。

### 3. 依赖积种类的等价性 (Equivalence of Dependent Product Kind)

#### **规则 24.8: 等价性**

$$
\frac{\Delta \vdash \kappa_1 \equiv \kappa_1' \quad \Delta, u::\kappa_1 \vdash \kappa_2 \equiv \kappa_2'}{\Delta \vdash \Sigma u::\kappa_1.\kappa_2 \equiv \Sigma u::\kappa_1'.\kappa_2'}
$$

**解释**：
如果 $\kappa_1$ 和 $\kappa_1'$ 等价，且 $\kappa_2$ 和 $\kappa_2'$ 在上下文 $\Delta, u::\kappa_1$ 下等价，那么依赖积种类 $\Sigma u::\kappa_1.\kappa_2$ 和 $\Sigma u::\kappa_1'.\kappa_2'$ 也是等价的。这个规则表明了依赖积种类的等价性是通过其各个部分的等价性传递的。

### 4. 重要的推论 (Notable Consequences)

从这些规则中，我们可以得到以下重要的推论：

#### **子种类推论**

$$
\Sigma u::S(int).S(u) :<: \Sigma u::T.S(u)
$$

这个推论表明，单例种类 $S(int)$ 的依赖积可以作为一般类型 $T$ 的依赖积的子种类，表明了单例种类与更广泛类型之间的关系。

$$
\Sigma u::T.S(u) :<: T \times T
$$

此推论表明依赖积种类 $\Sigma u::T.S(u)$ 是普通积类型 $T \times T$ 的子种类。这意味着依赖积种类可以推广到更一般的非依赖积种类。

#### **等价推论**

$$
\Sigma u::S(int).S(u) \equiv S(int) \times S(int)
$$

此等价关系表明，单例种类 $S(int)$ 的依赖积等价于常规积类型 $S(int) \times S(int)$。这表明依赖积种类能够精确捕捉类型之间的等价关系。

### 5. 小结

这些规则为构造器等价和依赖积种类提供了一个强大的理论框架。通过这些规则，我们可以确保构造器在依赖积和函数类型中保持正确的协变性和等价性，并且能够正确地进行类型推理。

### ---------------------------------

在本节中，我们讨论依赖函数种类 (dependent function kinds) 的构造规则，包括形成 (formation)、引入 (introduction)、消去 (elimination) 以及它们的等价性和子种类关系。这些规则为类型推理和构造器之间的协变性和逆变性提供了精确的理论基础。

### 1. 依赖函数种类的形成规则 (Formation Rule)

**规则 24.9a：依赖函数种类的形成**

$$
\frac{\Delta \vdash \kappa_1 \, \text{kind} \quad \Delta, u :: \kappa_1 \vdash \kappa_2 \, \text{kind}}{\Delta \vdash \Pi u::\kappa_1. \kappa_2 \, \text{kind}}
$$

**解释**：
该规则表示，依赖函数种类 $\Pi u::\kappa_1. \kappa_2$ 是一种新的种类，它由一个参数类型 $\kappa_1$ 和一个返回类型 $\kappa_2$ 组成。该返回类型 $\kappa_2$ 可以依赖于参数 $u$，并且 $u$ 的种类为 $\kappa_1$。因此，该规则允许我们定义依赖于参数的函数类型。

### 2. 依赖函数种类的引入规则 (Introduction Rule)

**规则 24.9b：依赖函数种类的引入**

$$
\frac{\Delta, u::\kappa_1 \vdash c :: \kappa_2}{\Delta \vdash \lambda (u::\kappa_1) c :: \Pi u::\kappa_1. \kappa_2}
$$

**解释**：
这个引入规则说明了如何构造一个依赖函数：如果在上下文 $\Delta, u::\kappa_1$ 下，构造器 $c$ 具有种类 $\kappa_2$，那么可以定义一个依赖函数 $\lambda (u::\kappa_1) c$，它的种类是 $\Pi u::\kappa_1. \kappa_2$。这是一个典型的 $\lambda$ 抽象的扩展，其中返回类型可以依赖于输入类型。

### 3. 依赖函数种类的消去规则 (Elimination Rule)

**规则 24.9c：依赖函数种类的消去**

$$
\frac{\Delta \vdash c :: \Pi u::\kappa_1. \kappa_2 \quad \Delta \vdash c_1 :: \kappa_1}{\Delta \vdash c[c_1] :: [c_1/u] \kappa_2}
$$

**解释**：
该规则表明，当我们应用一个依赖函数 $c$ 于一个构造器 $c_1$ 时，结果的类型为 $[c_1/u] \kappa_2$，即将 $c_1$ 替换到 $\kappa_2$ 中。这表示函数的返回类型依赖于其输入参数。

### 4. 依赖函数种类的等价规则 (Equivalence Rule)

**规则 24.10：依赖函数种类的等价性**

$$
\frac{\Delta, u::\kappa_1 \vdash c::\kappa_2 \quad \Delta \vdash c_1::\kappa_1}{\Delta \vdash (\lambda (u::\kappa_1) c)[c_1] \equiv [c_1/u]c :: \kappa_2}
$$

**解释**：
这个等价规则表明，当我们应用依赖函数 $(\lambda (u::\kappa_1) c)$ 到一个构造器 $c_1$ 时，等价于将 $c_1$ 替换到 $c$ 中。这是函数应用的一个规范化步骤。

### 5. 依赖函数种类的协变性和逆变性 (Covariance and Contravariance)

**规则 24.11：协变性与逆变性**

$$
\frac{\Delta \vdash \kappa_0 <: \kappa_1 \quad \Delta, u::\kappa_0 \vdash \kappa_2 <: \kappa_3}{\Delta \vdash \Pi u::\kappa_1.\kappa_2 <: \Pi u::\kappa_0. \kappa_3}
$$

**解释**：
此规则表明，依赖函数种类在其参数位置上是逆变的 (contravariant)，而在其返回位置上是协变的 (covariant)。如果 $\kappa_0$ 是 $\kappa_1$ 的子种类，并且 $\kappa_2$ 是 $\kappa_3$ 的子种类，那么 $\Pi u::\kappa_1. \kappa_2$ 就是 $\Pi u::\kappa_0. \kappa_3$ 的子种类。

例如，依赖函数种类 $\Pi u::T.S(int)$ 是 $\Pi u::S(int).T$ 的子种类，这反映了函数在其输入参数上的逆变性与输出结果上的协变性。

### 6. 依赖函数种类的等价性规则 (Equivalence Rule)

**规则 24.12：等价性规则**

$$
\frac{\Delta \vdash \kappa_1 \equiv \kappa_0 \quad \Delta, u::\kappa_1 \vdash \kappa_2 \equiv \kappa_3}{\Delta \vdash \Pi u::\kappa_1. \kappa_2 \equiv \Pi u::\kappa_0. \kappa_3}
$$

**解释**：
这个等价性规则表明，如果 $\kappa_1$ 与 $\kappa_0$ 等价，并且 $\kappa_2$ 与 $\kappa_3$ 等价，那么依赖函数种类 $\Pi u::\kappa_1. \kappa_2$ 与 $\Pi u::\kappa_0. \kappa_3$ 也是等价的。这确保了在类型系统中构造函数保持等价性。

### 7. 推论和例子 (Inferences and Examples)

#### **子种类推论**

$$
\Pi u::T.S(int) <: \Pi u::S(int).T
$$

这表明，一个将任何类型映射到 $int$ 的函数，也可以被视为一个将 $int$ 映射到某个类型的函数。这是函数类型在参数上的逆变性和结果上的协变性。

#### **等价推论**

$$
\Pi u::S(int).S(u) \equiv S(int) \to S(int)
$$

这个等价推论表明，依赖函数种类 $\Pi u::S(int).S(u)$ 与普通函数类型 $S(int) \to S(int)$ 是等价的。换句话说，一个将类型 $int$ 映射到自身的函数，其行为可以通过单例种类准确地描述。

#### **综合推论**

通过结合协变性和逆变性规则，我们可以推导出以下子种类关系：

$$
\Pi u::T.S(u) <: S(int) \to S(int)
$$

该推论表明，一个将其输入类型返回的构造函数，实际上可以被视为一个只适用于 $int$ 的构造函数，并且返回 $int$。这是类型系统中通过逆变性和协变性传递信息的一个示例。

### 总结

通过这些规则，依赖函数种类的构造和推理得以实现，并且能够精确描述函数参数和返回值的依赖关系。这些规则进一步强化了类型系统的灵活性和表达能力，尤其是在处理更复杂的类型依赖和等价关系时。

### ---------------------------------

在本节中，**高阶单例种类 (Higher Singletons)** 的定义通过依赖于构造器 (constructor) 和种类 (kind) 的结构来扩展单例的概念，使得我们能够定义针对更高阶构造器的单例种类。这种扩展通过依赖积 (dependent product) 和依赖函数 (dependent function) 的种类来实现。

### 1. **基本思想**

单例种类 $S(c :: \kappa)$ 的核心目标是分类与构造器 $c$ 等价的构造器。这种扩展不仅限于基础种类 $T$，而且也可以推广到更高阶的种类，比如依赖积和依赖函数种类。

### 2. **单例种类的递归定义**

高阶单例种类的定义基于种类 $\kappa$ 的结构，并通过以下方式进行递归定义：

#### **规则 24.13a：单例种类的等价性**

$$
\Delta \vdash c :: S(c') \quad \Delta \vdash S(c :: S(c')) \equiv S(c)
$$

**解释**：  
这条规则确保了当 $c$ 属于某个单例种类时，$S(c :: S(c'))$ 与 $S(c)$ 等价。这是通过递归定义的方式确保构造器 $c$ 的单例种类的正确性。

#### **规则 24.13b：依赖积的单例种类**

$$
\Delta \vdash c :: \Sigma u::\kappa_1.\kappa_2 \quad \Delta \vdash S(c :: \Sigma u::\kappa_1.\kappa_2) \equiv \Sigma u::S(c \cdot l :: \kappa_1). S(c \cdot r :: \kappa_2)
$$

**解释**：  
对于构造器 $c$ 属于 $\Sigma u::\kappa_1.\kappa_2$ 的情况，单例种类 $S(c)$ 可以通过依赖积的左投影 $c \cdot l$ 和右投影 $c \cdot r$ 递归定义。左投影 $c \cdot l$ 的种类为 $\kappa_1$，而右投影 $c \cdot r$ 的种类为 $\kappa_2$，因此我们使用 $S(c \cdot l :: \kappa_1)$ 和 $S(c \cdot r :: \kappa_2)$ 来构造依赖积的单例种类。

#### **规则 24.13c：依赖函数的单例种类**

$$
\Delta \vdash c :: \Pi u::\kappa_1.\kappa_2 \quad \Delta \vdash S(c :: \Pi u::\kappa_1.\kappa_2) \equiv \Pi u::\kappa_1.S(c[u] :: \kappa_2)
$$

**解释**：  
对于依赖函数种类 $\Pi u::\kappa_1.\kappa_2$，我们使用 $\lambda$ 抽象来描述函数的行为。单例种类 $S(c)$ 是通过递归定义的，其中 $S(c[u] :: \kappa_2)$ 表示应用函数 $c$ 后的结果的单例种类。因此，$S(c :: \Pi u::\kappa_1.\kappa_2)$ 定义为一个函数，其返回的类型是应用 $u$ 后的结果种类。

### 3. **构造器等价的扩展性原理**

构造器等价是通过以下规则定义的，它确保了依赖积和依赖函数的行为遵循一定的等价性规则。

#### **规则 24.14a：依赖积的扩展性**

$$
\Delta \vdash c :: \Sigma u::\kappa_1.\kappa_2 \quad \Delta \vdash c \equiv \langle c \cdot l, c \cdot r \rangle :: \Sigma u::\kappa_1.\kappa_2
$$

**解释**：  
对于构造器 $c$ 属于依赖积 $\Sigma u::\kappa_1.\kappa_2$ 的情况，$c$ 等价于其左投影 $c \cdot l$ 和右投影 $c \cdot r$ 的元组。这种等价性确保了依赖积的构造器行为符合其定义。

#### **规则 24.14b：依赖函数的扩展性**

$$
\Delta \vdash c :: \Pi u::\kappa_1.\kappa_2 \quad \Delta \vdash c \equiv \lambda (u::\kappa_1) c[u] :: \Pi u::\kappa_1.\kappa_2
$$

**解释**：  
对于依赖函数 $\Pi u::\kappa_1.\kappa_2$，$c$ 等价于 $\lambda$ 抽象 $\lambda (u::\kappa_1) c[u]$。这确保了依赖函数的构造器符合 $\lambda$ 表达式的规则。

### 4. **推导示例：**

#### **依赖积种类的单例推导**

假设我们有构造器 $c :: \kappa_1 \times \kappa_2$，其单例种类 $S(c :: \kappa_1 \times \kappa_2)$ 可以被推导为：

$$
S(c :: \kappa_1 \times \kappa_2) \equiv S(c \cdot l :: \kappa_1) \times S(c \cdot r :: \kappa_2)
$$

这表明，$c$ 的单例种类等价于 $c$ 的左投影和右投影的单例种类的乘积。

#### **依赖函数种类的单例推导**

对于构造器 $c :: \kappa_1 \to \kappa_2$，我们可以推导出其单例种类为：

$$
S(c :: \kappa_1 \to \kappa_2) \equiv \Pi u::\kappa_1. S(c[u] :: \kappa_2)
$$

这意味着函数的单例种类是基于输入 $u$ 的类型推导出来的。

### 总结

通过这些规则，**高阶单例种类** 为类型系统中的构造器提供了更强的表达能力，使得我们能够在更高阶的依赖积和依赖函数的背景下处理构造器的等价性和单例性。

### ---------------------------------

在这里，我们来详细分析 **规则 (24.15a)** 和 **(24.15b)** 以及它们在类型系统中的作用。

### 1. **自识别规则 (Self-recognition rules)**

自识别规则用于扩展 **规则 (24.2b)**，以确保它可以应用于高阶种类 (higher kinds)。这两个规则的目的是允许对依赖积和依赖函数种类中的构造器进行进一步的推理，并确保构造器的每一部分可以根据它们的子结构推导出正确的种类。

#### **规则 (24.15a)**

$$
\Delta \vdash c \cdot l :: \kappa_1 \quad \Delta \vdash c \cdot r :: [c \cdot l/u] \kappa_2 \quad \Delta \vdash c :: \Sigma u::\kappa_1.\kappa_2
$$

**解释**：  
这条规则涉及依赖积 $\Sigma u::\kappa_1.\kappa_2$。构造器 $c$ 被视为一个依赖积种类的构造器，其左投影 $c \cdot l$ 的种类为 $\kappa_1$，而右投影 $c \cdot r$ 的种类为 $[c \cdot l / u] \kappa_2$。这意味着右投影的种类取决于左投影的构造器 $c \cdot l$。

#### **规则 (24.15b)**

$$
\Delta, u :: \kappa_1 \vdash c[u] :: \kappa_2 \quad \Delta \vdash c :: \Pi u::\kappa_1.\kappa_2
$$

**解释**：  
这条规则针对依赖函数 $\Pi u::\kappa_1.\kappa_2$，确保函数应用后所得结果的种类是通过将输入参数 $u$ 替换到结果种类 $\kappa_2$ 中得到的。这与我们在前面的依赖函数种类讨论中所看到的规则一致，即依赖函数的返回种类依赖于它的输入参数。

### 2. **规则的推导示例**

为了更好地理解这些规则，考虑以下情况：

#### **变量 $u$ 是 $\Sigma v::T.S(v)$ 的构造器变量**

- 首先，我们可以利用 **规则 (24.2b)** 推导出 $u \cdot l :: S(u \cdot l)$，这是因为 $S(v)$ 是单例种类 (singleton kind)，它分类与 $v$ 等价的构造器。
- 然后，通过 **规则 (24.5d)**，我们可以推导出 $u \cdot r :: S(u \cdot l)$，这表明右投影的种类与左投影相等。

因此，根据 **规则 (24.15a)**，我们可以推导出 $u :: \Sigma v::S(u \cdot l).S(u \cdot l)$，它是 $\Sigma v::T.S(v)$ 的一个子种类。这个推导意味着我们能够更加精确地确定 $u$ 的种类，因为 $u$ 的第一个部分确实是 $u \cdot l$，而第二部分等价于第一个部分，即也是 $u \cdot l$。

### 3. **引入高阶单例的目的**

引入高阶单例 (higher singletons) 的核心目的是确保每一个构造器都可以通过一个确定其定义等价的种类进行分类。通过这些规则，类型系统中的每个构造器都可以通过某种种类进行精确描述，确保它在定义等价的情况下具有一致的种类分类。

### 4. **定理 24.1**

**定理 24.1** 进一步说明了高阶单例的正确性：

$$
\text{如果} \Delta \vdash c :: \kappa, \text{那么} \Delta \vdash S(c :: \kappa) :<: \kappa \quad \text{且} \quad \Delta \vdash c :: S(c :: \kappa).
$$

**解释**：  
- $S(c :: \kappa) :<: \kappa$ 表示构造器 $c$ 的单例种类是 $\kappa$ 的子种类，这意味着 $S(c :: \kappa)$ 与 $\kappa$ 之间存在子种类关系。
- $c :: S(c :: \kappa)$ 表明 $c$ 本身是其单例种类 $S(c :: \kappa)$ 的一个成员。

这个定理证明了高阶单例的正确性，并确保每个构造器都可以通过一个单例种类进行分类，从而保持类型系统的安全性。

### 5. **总结**

- **规则 (24.15a)** 和 **(24.15b)** 确保了我们能够在依赖积和依赖函数种类中推导构造器的种类。
- **高阶单例的引入** 保证了每个构造器都可以通过精确的种类进行分类，并确保了类型系统的定义等价。
- **定理 24.1** 进一步证明了高阶单例的合理性，并展示了它们如何与类型系统中的其他种类关联。

这些规则和推导展示了类型系统中高阶构造器的复杂性以及如何确保它们的类型安全。

### ---------------------------------

**24.5 注解**

单例种类 (Singleton kinds) 的概念最早由 **Stone 和 Harper** 在 2006 年引入，目的是隔离在 **ML 模块系统** 中产生的类型共享概念。ML 模块系统是由 **Milner et al. (1997)**、**Harper 和 Lillibridge (1994)** 以及 **Leroy (1994)** 开发的，这一系统中的类型共享机制对于模块化编程至关重要。

单例种类的核心思想是能够通过一个构造器 $c$ 确定一个类型，使得在它的作用域内，该构造器的每个实例都等价于它本身。这种机制允许在类型系统中捕获类型的“同一性” (identity)，而不仅仅是类型的结构，从而实现了更强的类型抽象和共享机制。

Crary 在 2009 年将 **遗传替换 (hereditary substitution)** 的概念扩展到了单例种类。遗传替换最初在第 22 章中讨论过，它允许在替换过程中保持类型的结构，从而保证类型系统的决定性和一致性。在将遗传替换应用于单例种类时，Crary 的工作使得类型系统在处理类型共享和等价问题时更加精确和高效。

### **参考文献：**
- **Stone 和 Harper (2006)** 的工作通过引入单例种类，解决了模块系统中常见的类型共享问题。
- **Milner et al. (1997)** 和 **Harper 和 Lillibridge (1994)** 的研究奠定了 ML 模块系统的基础，这一系统对于编程语言中的模块化设计和类型安全性非常重要。
- **Crary (2009)** 通过扩展遗传替换，增强了类型系统的精确性，使得它能够更好地处理复杂的类型结构和共享问题。

这些研究的结合，使得现代编程语言设计中的类型系统在模块化、类型共享和类型抽象方面取得了重要进展。


### ---------------------------------


### ---------------------------------


### ---------------------------------

### ---------------------------------



### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------
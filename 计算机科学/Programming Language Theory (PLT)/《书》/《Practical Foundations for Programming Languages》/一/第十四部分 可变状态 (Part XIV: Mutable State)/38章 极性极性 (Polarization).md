[toc]



### 第38章 极性 (Polarization)

本章引入了**极性**（Polarization）的概念，它用于处理编程语言中不同构造之间的动态行为选择。在此前的内容中，我们经常会遇到在各种语言构造的动态求值规则中存在的任意选择。比如，在对**对偶类型**(pairs) 的动态求值进行规范时，往往存在多种选择：

1. **惰性动态求值**：所有对偶都被视为值，而不管其组件是否已计算。
2. **急切动态求值**：只有当对偶的两个组件都是值时，才将该对偶视为值。
3. **半惰性或半急切动态求值**：比如，规定只有当第一个组件是值时，才将对偶视为值，而不管第二个组件的状态。

### 1. **类似的问题在其他类型中也会出现**：

- **和类型**(sum types)：是所有注入(injections)都是值，还是只有注入的值是值？
- **递归类型**(recursive types)：是所有的折叠(folds)都是值，还是只有对值的折叠是值？
- **函数类型**(function types)：函数是否应该使用**按名称调用**(call-by-name)，还是**按值调用**(call-by-value)？

### 2. **不同编程语言的设计选择**：

不同的编程语言对这些问题采用了不同的解决方式。比如：

- **Haskell**：规定**对偶类型**、**和类型**和**递归类型**都是惰性的，函数调用则使用按名称调用。
- **ML**：采取了完全相反的策略，规定这些类型是急切的，函数调用则使用按值调用。

然而，这些选择并没有固定的理由，它们往往是任意的。而且，为什么这些选择要被语言设计者绑定在一起也是不明确的。我们完全可以想象一个语言中，对偶类型、和类型和递归类型是惰性的，但函数调用却是按值调用的。或者相反，急切的类型构造与按名称调用并存。这些不同的设计在实际的编程语言中都有其支持者和反对者。

### 3. **极性的引入：程序员的选择**

那么，我们是否被这些任意选择困住了呢？答案是否定的。**极性**的引入为我们提供了一种新的视角。我们可以认识到，这些动态行为的差异并不应当由语言设计者强加给用户，而应该交由程序员自己来选择。这可以通过明确语言中的类型区分来实现，避免对任意策略的强制要求。

通过在编程语言中区分不同的类型，我们可以同时在语言中引入**惰性**和**急切**的对偶类型，惰性和急切的和类型，按名称调用和按值调用的函数空间，让程序员在具体的程序中选择合适的策略。

### 4. **极性：正类型与负类型**

惰性类型与急切类型的区别可以通过它们的**极性**（polarity）来进行区分：

- **正类型**(Positive Types)：这些类型是急切的，或者说是归纳的(inductive)，它们由它们的值来定义。
- **负类型**(Negative Types)：这些类型是惰性的，或者说是余归纳的(coinductive)，它们由它们的行为来定义。

这种极性的区分为我们提供了一种理论框架，使得在同一语言中同时支持惰性和急切类型成为可能。

### 5. **极性在语言中的呈现：聚焦技术 (Focusing)**

极性在编程语言中通过一种称为**聚焦技术**(focusing)的方法来显式表达。在这种表达方式中，语言中的表达式被划分为三类：

- **正值与负值** (Positive and Negative Values)：它们分别对应急切与惰性的类型。
- **正续延与负续延** (Positive and Negative Continuations)：它们分别用于处理正极性和负极性的值。
- **中性计算** (Neutral Computations)：这些计算介于两者之间，用于处理一般的计算行为。

通过这种表达方式，程序员可以显式地指定某个构造是急切的还是惰性的，从而实现更灵活的程序设计。

---

### **总结**

极性提供了一种新的方式来区分急切和惰性类型。在传统语言设计中，惰性和急切行为通常是由语言设计者在全局范围内做出选择的。而通过引入**极性**，这些选择可以更加灵活地交由程序员决定。正类型对应急切行为，由其值定义；负类型对应惰性行为，由其计算的行为定义。通过**聚焦技术**，我们可以在同一语言中同时支持急切和惰性行为，提供给程序员更大的灵活性和控制力。

### ---------------------------------

### 38.1 正类型与负类型 (Positive and Negative Types)

极性的概念通过区分**正类型**(positive types) 和 **负类型**(negative types) 来进行表达，这种区分基于以下两条基本原则：

1. **正类型**由其**引入规则**(introduction rules) 定义，这些规则指定了正类型的值是由其他值构成的。正类型的**消除规则**(elimination rules) 是对这些引入规则的反向操作，它通过对这些值的**模式匹配**(pattern matching) 来定义计算。
   
2. **负类型**由其**消除规则**定义，这些规则规定了我们可以对负类型的元素执行哪些操作（观察）。负类型的**引入规则**则通过定义这些元素如何回应观察操作来指定其值。

### **正类型与负类型的区分**

根据上述原则，我们可以预见到一些常见类型的分类：

- **自然数类型**(natural numbers) 是**正类型**，因为它的定义是通过**零**(zero) 和**后继**(successor) 来完成的，也就是通过它的值来定义。
  
- **函数类型**(function types) 是**负类型**，因为它们的行为是通过**应用**(application) 操作来表征的，而不是通过它们的内部结构。这意味着我们关注的是函数如何在应用时产生行为，而不是函数本身的构造。

### **语言 $L^\pm\{nat^*\}$ 的极性形式**

接下来，介绍一种极性化的编程语言 **$L^\pm\{nat^*\}$**，它的语法规则展示了如何通过正类型和负类型的区分来构建复杂类型。

#### **类型语法**：

1. **正类型的语法**(PTyp $τ^+$):
   - **悬挂类型**(Suspension type)：$dn(τ^-)$，也可以写作 $↓τ^-$，表示从负极性类型到正极性类型的转换。
   - **自然数**(nat)：自然数被视为正类型。

2. **负类型的语法**(NTyp $τ^-$):
   - **包含类型**(Inclusion type)：$up(τ^+)$，也可以写作 $↑τ^+$，表示从正极性类型到负极性类型的转换。
   - **部分函数类型**(Partial function type)：$parr(τ^+_1; τ^-_2)$，也可以写作 $τ^+_1 * τ^-_2$，表示从正极性输入到负极性输出的部分函数。

### **极性转换：正负极性之间的转换**

极性转换是通过类型 $↓$ 和 $↑$ 来实现的：

- **$↓τ^-$**：表示从负极性类型转换为正极性类型，通常表示暂停的负类型计算。
- **$↑τ^+$**：表示从正极性类型转换为负极性类型，通常表示将正极性类型包含到负极性中。

通过这些转换，我们可以在同一个语言中实现正极性和负极性的交互。这种转换对于函数类型的构造尤为重要。

### **部分函数类型与极性要求**

对于**部分函数类型** $τ^+_1 * τ^-_2$，它的**定义域**(domain) 被要求是正极性类型，而它的**值域**(range) 则是负极性类型。这种约束使得我们能够直接定义**右迭代函数类型**，即：

$$
τ^+_1 * (τ^+_2 * (\ldots (τ^+_{n-1} * τ^-_n)))
$$

这个表达式表示一个从正极性输入依次映射到负极性输出的右迭代函数类型。

然而，定义**左迭代函数类型**时，我们需要借助**极性转换**，将负极性类型转换为正极性类型，例如：

$$
↓(τ^+_1 * τ^-_2) * τ^-
$$

这种转换将负极性函数类型 $τ^+_1 * τ^-_2$ 转换为正极性类型。

同样，如果我们想定义一个值域为正极性类型的函数，我们需要进行相反的转换，例如：

$$
τ^+_1 * ↑ τ^+_2
$$

这表示一个从正极性输入到正极性输出的函数类型。

### **深入解释**

1. **正类型与负类型的互补**：
   正类型通过其构造规则来定义，它的值由其他值构造出来，主要强调它们的结构和内部定义。例如，自然数类型就是通过构造零和后继来定义的。这种类型的操作往往是急切的，因为值已经存在。
   
   负类型则强调其消除规则，主要关注它们如何在操作中表现出来。函数类型的消除规则定义了它们如何被应用，而不关注其内部结构。负类型往往是惰性的，因为它们的行为是在需要时才表现出来。

2. **极性转换的重要性**：
   在复杂类型中，极性转换提供了灵活性，使得程序员能够在不同的极性规则之间进行切换。通过 $↑$ 和 $↓$ 的操作，我们可以将正极性类型和负极性类型混合使用，从而实现更丰富的类型结构。这种转换尤其在函数类型的构造中发挥关键作用。

3. **部分函数类型的极性约束**：
   在部分函数类型中，规定输入是正极性类型，输出是负极性类型。这种设计确保了输入值已经构造好，而输出则是通过函数的行为来计算的。这种设计允许我们处理复杂的函数迭代结构，但也限制了直接构造左迭代函数类型的能力，必须通过极性转换来实现。

---

### **总结**

在极性理论中，**正类型**通过其值定义，往往对应急切行为；而**负类型**通过其行为定义，往往对应惰性行为。极性转换提供了在正负类型之间进行灵活转换的机制，允许在同一语言中混合使用急切和惰性类型。通过这种方式，程序员可以根据具体的需求选择不同的求值策略，从而更灵活地设计程序。

### ---------------------------------

好的，让我重新生成并详细讲解内容，包括公式的解释。我们从**38.1 正类型与负类型**开始，逐步理解极性的概念，并对每个公式和相关段落进行详细分析。

---

### 38.1 正类型与负类型 (Positive and Negative Types)

极性的核心概念在于**正类型**(positive types) 和 **负类型**(negative types) 的区别。这个区别是基于如何定义类型以及如何操作这些类型。

#### **1. 正类型的定义**

**正类型**的定义依赖于它的**引入规则**(introduction rules)，这些规则规定了正类型的值是如何通过其他值来构造的。例如，自然数是通过**零**(zero) 和**后继**(successor) 来构造的。因此，自然数类型就是一个正类型。

**消除规则**(elimination rules) 则是正类型的反向操作，通过对正类型的值进行**模式匹配**(pattern matching) 来执行计算。举个例子，自然数的消除规则可能包括递归操作，比如递归地减少数字直到达到 0。

正类型的关键在于它们**通过值来定义**。我们定义这些类型的方式就是通过其构造方式（即引入规则），并在需要时通过模式匹配对其进行操作。

#### **2. 负类型的定义**

**负类型**的定义依赖于它的**消除规则**。这些规则规定了可以对负类型的元素执行的操作（**观察**）。也就是说，负类型不是通过它们的值来定义的，而是通过它们的**行为**来定义的。

例如，函数类型是负类型，因为函数的行为通过其被应用时的表现来定义，而不是通过它们的构造来定义。引入规则描述了负类型的元素如何响应外部的观察。

因此，负类型的关键在于它们**通过行为来定义**。而引入规则主要用于定义这些元素如何对外部的操作或观察做出反应。

#### **例子：自然数与函数类型**

- **自然数类型**($\text{nat}$)：自然数类型是正类型，因为它的构造规则非常明确：零和后继都是自然数类型的构造子。它的行为是通过递归或模式匹配来实现的。
- **函数类型**($\tau_1 \to \tau_2$)：函数类型是负类型，因为它的行为是通过应用（apply）操作来定义的。我们不关心函数的内部结构，而是通过观察函数的应用来理解它。

### **3. 极性转换：正类型与负类型之间的转换**

在编程语言中，我们可以通过引入**极性转换**来在正类型与负类型之间进行灵活转换。这种转换通过两种操作实现：

- **$↓\tau^-$**：从负极性类型转换为正极性类型。这通常表示的是**悬挂计算**(suspension)的类型。即我们可以延迟负类型的计算，然后在需要时再计算它的值。
- **$↑\tau^+$**：从正极性类型转换为负极性类型。表示正极性类型的值可以在负极性环境中使用。

这两种操作使得我们可以在同一语言中混合使用正类型和负类型，从而实现更灵活的求值策略。

#### **悬挂类型**(Suspension Type) 和 **包含类型**(Inclusion Type)

- **悬挂类型**($↓\tau^-$)：这是从负类型到正类型的转换。它表示暂停的计算，即延迟执行负类型的值。具体来说，$↓\tau^-$ 表示一种计算被延迟，直到真正需要其值时才计算。
- **包含类型**($↑\tau^+$)：这是从正类型到负类型的转换，表示正极性类型的值可以作为负极性类型的一部分。例如，我们可以将一个正类型的值作为一个负极性环境中的参数进行操作。

### **4. 语言 $L^\pm\{nat^*\}$ 的语法规则**

接下来，我们分析极性化语言 **$L^\pm\{nat^*\}$** 中的类型规则。这里展示了如何通过正负类型的区分来构建复杂的类型。

#### **正类型的语法** (PTyp $τ^+$):
- **$↓\tau^-$**：从负极性类型到正极性类型的转换，表示悬挂的负类型计算。
- **$\text{nat}$**：自然数类型，作为一个正类型。

#### **负类型的语法** (NTyp $τ^-$):
- **$↑\tau^+$**：从正极性类型到负极性类型的转换，表示正极性类型包含在负极性中。
- **$τ^+_1 * τ^-_2$**：部分函数类型(Partial Function Type)，表示从正极性输入到负极性输出的函数类型。这里，正极性类型 $τ^+_1$ 作为输入，而负极性类型 $τ^-_2$ 作为输出。

### **5. 部分函数类型的极性约束**

对于**部分函数类型** $τ^+_1 * τ^-_2$，定义如下：

- **输入**：输入 $τ^+_1$ 被要求是正极性类型，因为正极性类型通过其值定义，意味着在调用这个函数时，我们期望输入值已经构造完成。
  
- **输出**：输出 $τ^-_2$ 被要求是负极性类型，因为函数的结果是通过观察它的行为来决定的，而不是通过构造它的值。换句话说，输出的行为是由函数体内的计算所决定的，而不是在输入时就直接决定。

#### **右迭代函数类型**

通过正负极性的规则，我们可以构建**右迭代函数类型**，其形式为：

$$
τ^+_1 * (τ^+_2 * (\ldots (τ^+_{n-1} * τ^-_n)))
$$

这个公式表示多个正极性输入依次映射到一个负极性输出的函数链。换句话说，函数依次接受正极性的参数，最终返回负极性的结果。

#### **左迭代函数类型**

构建**左迭代函数类型**需要通过极性转换来实现。我们需要将部分函数类型的负极性结果转化为正极性，这可以通过 $↓$ 操作完成：

$$
↓(τ^+_1 * τ^-_2) * τ^-
$$

这里，$↓(τ^+_1 * τ^-_2)$ 将一个部分函数类型从负极性转换为正极性，使得我们可以将其用于其他正极性操作中。

#### **正极性输出的函数类型**

如果我们希望构造一个**输出为正极性**的函数类型，需要通过 $↑$ 操作将负极性结果转换为正极性。例如：

$$
τ^+_1 * ↑τ^+_2
$$

这个公式表示一个从正极性输入 $τ^+_1$ 映射到正极性输出 $↑τ^+_2$ 的函数类型。这里，通过 $↑$ 操作，我们将正极性输出包含在负极性环境中，使得该函数可以在负极性语境下运行，但仍返回正极性结果。

---

### **总结**

通过正负类型的极性区分，我们可以灵活地设计编程语言中的求值策略。正类型通过其值定义，适用于急切求值场景；负类型通过其行为定义，适用于惰性求值场景。**极性转换**使得我们可以在正负极性之间切换，从而支持更复杂的类型和函数构造。部分函数类型的极性约束确保了输入必须是正极性，而输出则可以是负极性。通过极性转换，程序员可以设计更加灵活的函数类型，支持不同的求值策略。

这种极性区分的理论模型不仅有助于理解编程语言中的求值行为，还为混合急切和惰性求值的语言设计提供了工具。

### ---------------------------------

### 38.2 聚焦 (Focusing)

**聚焦**(focusing) 是基于类型的极性（正类型和负类型）的一个核心概念。它通过区分**正值**(positive values)、**负值**(negative values) 和 **中性计算**(neutral computations)，为编程语言的表达式提供了更结构化的形式。这种方法让程序员能够更明确地控制程序的动态行为。

#### **L±{nat*} 的语法结构**

在语言 **L±{nat*}** 中，语法的设计是基于类型的极性划分的。对于每种极性，我们都有与之对应的值和续延（continuations），这些值和续延能够创建**中性计算**。

---

### **1. 正值 (Positive Values) - $PVal \, v^+$**

正值类型主要包括自然数及其相关操作。以下是正值的构成：

- **$z$**：自然数 0，表示自然数类型的基础值。
- **$s(v^+)$**：自然数的后继操作，$v^+$ 表示一个正值，$s(v^+)$ 则表示该正值的后继，类似于 $n+1$ 的构造。
- **$del^-(e)$**：延迟计算操作，表示延迟计算一个负值表达式 $e$，从而形成一个正值。

#### **公式解释**

**$s(v^+)$**:
- 这里，$v^+$ 是一个正值，$s(v^+)$ 是该正值的后继操作。这与自然数的定义相符：给定一个自然数，通过后继操作可以生成一个新的自然数。$s$ 类似于在递归定义中常见的构造器。

**$del^-(e)$**:
- 该表达式通过延迟负值计算形成一个正值。延迟计算的意义在于，它可以将负类型的计算推迟，直到正值需要的时候才进行求值。这是一种惰性求值策略的体现。

---

### **2. 正续延 (Positive Continuations) - $PCont \, k^+$**

正续延表示对正值进行的操作或计算，它们通常处理正极性类型。正续延包括：

- **$ifz(e_0; x.e_1)$**：条件分支操作，类似于在自然数上的模式匹配。$ifz$ 处理零值的情况，如果 $e_0$ 为零，则执行 $x.e_1$。
- **$force^-(k^-)$**：强制计算负值，即通过一个负续延 $k^-$ 来触发负值计算。

#### **公式解释**

**$ifz(e_0; x.e_1)$**:
- 这类似于在自然数上的模式匹配操作。它检查 $e_0$ 是否为零，如果是，则执行 $x.e_1$。这是典型的递归结构，尤其是在定义和处理自然数类型时。

**$force^-(k^-)$**:
- 该操作强制执行一个负续延 $k^-$，以计算一个负值。这体现了极性转换的机制，通过这个操作，负极性类型的值将被立即求值。

---

### **3. 负值 (Negative Values) - $NVal \, v^-$**

负值主要用于表示函数和递归定义。负值通常通过其行为（例如，应用或递归）来定义。负值包括：

- **$lam[\tau^+](x.e)$**：表示一个从正极性输入 $\tau^+$ 到负极性表达式 $e$ 的抽象，即一个函数。
- **$del^+(v^+)$**：将正值 $v^+$ 视为负值。
- **$fix(x.v^-)$**：递归定义，表示一个自引用的值 $v^-$。

#### **公式解释**

**$lam[\tau^+](x.e)$**:
- 这是函数抽象的表示法。函数从一个正极性类型 $\tau^+$ 输入，计算出负极性表达式 $e$。这里的 $lam[\tau^+]$ 表示函数输入的类型为正极性，而函数的主体 $e$ 计算出一个负极性结果。这是典型的负极性类型，因为函数通过它们的行为（应用）来定义，而不是通过其值。

**$fix(x.v^-)$**:
- 递归定义，这意味着 $x$ 是一个负极性表达式，并且它自引用 $v^-$。这种递归结构通常出现在定义递归函数或无限数据结构时。例如，可以用 $fix$ 来定义一个递归求解的过程。

---

### **4. 负续延 (Negative Continuations) - $NCont \, k^-$**

负续延处理负值的行为，通常涉及函数应用或对负极性值的计算。负续延包括：

- **$ap(v^+; k^-)$**：函数应用，应用一个正值 $v^+$ 到负续延 $k^-$。
- **$force^+(x.e)$**：强制执行正极性表达式 $e$ 的计算。

#### **公式解释**

**$ap(v^+; k^-)$**:
- 这是典型的函数应用操作。$v^+$ 是一个正值，应用到负续延 $k^-$。这里，正值 $v^+$ 作为函数的输入，负续延 $k^-$ 表示如何处理应用的结果。

**$force^+(x.e)$**:
- 强制计算一个正极性表达式 $e$。这个操作用于将正极性类型的值在负极性环境中进行计算。

---

### **5. 中性计算 (Neutral Computations) - $Comp \, e$**

中性计算用于描述在程序执行时的中间状态，既非正极性，也非负极性。它们主要有三种形式：

1. **返回负值**（$ret(v^-)$）：计算返回一个负值，表示这是一个终止状态。
   
2. **正值传递给正续延**（$cut^+(v^+; k^+)$）：计算一个正值，并将该正值传递给一个正续延 $k^+$ 继续处理。
   
3. **负值传递给负续延**（$cut^-(v^-; k^-)$）：计算一个负值，并将该负值传递给负续延 $k^-$ 继续处理。

#### **公式解释**

**$ret(v^-)$**:
- 返回一个负值，表示程序已经计算完成。这通常是递归计算的终止条件，表明不再需要进一步操作。

**$cut^+(v^+; k^+)$**:
- 将正极性值 $v^+$ 传递给正极性续延 $k^+$，用于后续的计算。这里的 $cut$ 操作可以理解为将一个值与续延进行“剪裁”，通过续延进一步推进计算。

**$cut^-(v^-; k^-)$**:
- 类似于正极性的 $cut$ 操作，只是这次处理的是负极性值和负续延。负极性值 $v^-$ 通过 $k^-$ 续延进一步计算，通常用于处理递归或者函数应用的结果。

---

### **总结**

**聚焦** (focusing) 为极性提供了一个系统化的语法结构，它将正极性和负极性的类型、值、续延和计算进行明确区分。在这种框架下：

- **正值**主要由其结构定义，典型的例子是自然数；
- **负值**主要通过其行为定义，如函数和递归；
- **正续延和负续延**分别处理正极性和负极性值的进一步操作；
- **中性计算**是程序执行中的中间状态，通过将正值或负值传递给续延继续处理计算。

通过这些机制，程序员可以在正负极性之间自由切换，灵活控制惰性求值和急切求值的行为。这种结构为编程语言提供了更细致的动态求值模型，同时使得计算的每个步骤都能更加明确。

### ---------------------------------

### 38.3 静态语义 (Statics)

**静态语义**描述了程序中表达式如何正确地类型化（typing），即如何为表达式分配类型。这一部分详细介绍了语言 **$L^\pm\{nat^*\}$** 的静态规则，它定义了正值、正续延、负值、负续延和计算的类型推导规则。

#### **推导的形式**

在 **$L^\pm\{nat^*\}$** 中，静态语义涉及以下形式的推导判断：

- **正值**：$\Gamma \vdash v^+ : \tau^+$，表示在上下文 $\Gamma$ 中，正值 $v^+$ 的类型为正极性类型 $\tau^+$。
- **正续延**：$\Gamma \vdash k^+ : \tau^+ \Rightarrow \gamma^-$，表示正续延 $k^+$ 作用于正极性类型 $\tau^+$，并返回负极性类型 $\gamma^-$。
- **负值**：$\Gamma \vdash v^- : \tau^-$，表示负值 $v^-$ 的类型为负极性类型 $\tau^-$。
- **负续延**：$\Gamma \vdash k^- : \tau^- \Rightarrow \gamma^-$，表示负续延 $k^-$ 作用于负极性类型 $\tau^-$，并返回负极性类型 $\gamma^-$。
- **计算**：$\Gamma \vdash e : \gamma^-$，表示计算 $e$ 的结果为负极性类型 $\gamma^-$。

上下文 $\Gamma$ 是一个有限的假设集，形式为 $x_1 : \tau^+_1, \dots, x_n : \tau^+_n$，即所有变量都绑定到正极性类型。$\gamma^-$ 是任意的负极性类型。

---

### **正值的静态语义规则**

正值的静态推导规则如下：

1. **规则 38.1a**：变量的类型推导规则
   $$
   \Gamma, x : \tau^+ \vdash x : \tau^+
   $$
   解释：如果变量 $x$ 在上下文 $\Gamma$ 中具有类型 $\tau^+$，那么我们可以推导出 $x$ 的类型就是 $\tau^+$。

2. **规则 38.1b**：零值的类型推导规则
   $$
   \Gamma \vdash z : \text{nat}
   $$
   解释：零 $z$ 是自然数类型的正值。该规则规定自然数类型的基础值为 $z$。

3. **规则 38.1c**：后继函数的类型推导规则
   $$
   \Gamma \vdash v^+ : \text{nat} \quad \Rightarrow \quad \Gamma \vdash s(v^+) : \text{nat}
   $$
   解释：如果 $v^+$ 是一个自然数类型的正值，那么它的后继 $s(v^+)$ 也是自然数类型的正值。该规则构建了自然数类型的递归定义。

4. **规则 38.1d**：延迟计算的类型推导规则
   $$
   \Gamma \vdash e : \tau^- \quad \Rightarrow \quad \Gamma \vdash \text{del}^-(e) : \downarrow \tau^-
   $$
   解释：延迟计算 $del^-(e)$ 的类型是 $↓\tau^-$，表示延迟的负极性类型被视为正极性类型。这意味着负类型的计算被延迟，并且该延迟计算被视为一个正值。

### **正续延的静态语义规则**

正续延的推导规则如下：

1. **规则 38.2a**：条件判断的类型推导规则
   $$
   \Gamma \vdash e_0 : \gamma^- \quad \Gamma, x : \text{nat} \vdash e_1 : \gamma^- \quad \Rightarrow \quad \Gamma \vdash \text{ifz}(e_0; x.e_1) : \text{nat} \Rightarrow \gamma^-
   $$
   解释：条件判断 `ifz` 用于检查自然数是否为零。如果 $e_0$ 为零，则执行 $e_1$，其结果是负极性类型 $\gamma^-$。

   - $e_0$ 是检查条件的自然数表达式，它的结果类型为 $\gamma^-$。
   - 如果 $e_0$ 为零，则执行 $x.e_1$，其中 $x$ 是自然数，$e_1$ 的类型也是 $\gamma^-$。
   - 该规则表明，`ifz` 的结果是一个将自然数转换为负极性类型 $\gamma^-$ 的正续延。

2. **规则 38.2b**：强制负续延的类型推导规则
   $$
   \Gamma \vdash k^- : \tau^- \Rightarrow \gamma^- \quad \Rightarrow \quad \Gamma \vdash \text{force}^-(k^-) : ↓\tau^- \Rightarrow \gamma^-
   $$
   解释：该规则描述了如何强制执行延迟计算。当我们有一个负续延 $k^-$，作用于负极性类型 $\tau^-$，并返回 $\gamma^-$ 时，延迟计算 $↓\tau^-$ 可以通过 $force^-$ 操作被强制执行，继续产生 $\gamma^-$。

---

### **公式详解与推导**

#### **规则 38.1a**：变量的类型推导
$$
\Gamma, x : \tau^+ \vdash x : \tau^+
$$

这里，$\Gamma$ 是上下文，表示我们在某种状态下，变量 $x$ 已经被赋予了正极性类型 $\tau^+$。根据静态规则，$x$ 的类型就是 $\tau^+$。该规则的直观意义是：变量的类型由上下文中它的声明决定。

#### **规则 38.1b**：零值类型推导
$$
\Gamma \vdash z : \text{nat}
$$

自然数的零值 $z$ 是一个基础的正极性值。根据这个规则，$z$ 的类型推导是固定的，即 $z$ 是自然数类型 $nat$。这体现了自然数类型的归纳定义。

#### **规则 38.1c**：后继函数的类型推导
$$
\Gamma \vdash v^+ : \text{nat} \quad \Rightarrow \quad \Gamma \vdash s(v^+) : \text{nat}
$$

后继函数 $s(v^+)$ 表示自然数的递增。如果我们已经知道某个正值 $v^+$ 是自然数类型，那么它的后继 $s(v^+)$ 也自然是一个自然数类型。这是自然数的递归定义基础，意味着我们可以从 $0$ 开始，通过后继构造出任意自然数。

#### **规则 38.1d**：延迟计算的类型推导
$$
\Gamma \vdash e : \tau^- \quad \Rightarrow \quad \Gamma \vdash \text{del}^-(e) : ↓\tau^-
$$

延迟计算的规则涉及从负极性类型转换为正极性类型。这里的 $e$ 是一个负极性类型 $\tau^-$ 的表达式。通过延迟计算操作 $del^-(e)$，我们将 $e$ 的计算推迟，并将其视为正极性类型 $↓\tau^-$。

- $↓\tau^-$：表示悬挂的负极性类型，这是一种惰性计算的表现形式。通过延迟负极性计算，我们可以在需要时再执行它。

---

### **正续延的规则详解**

#### **规则 38.2a**：条件判断的类型推导
$$
\Gamma \vdash e_0 : \gamma^- \quad \Gamma, x : \text{nat} \vdash e_1 : \gamma^- \quad \Rightarrow \quad \Gamma \vdash \text{ifz}(e_0; x.e_1) : \text{nat} \Rightarrow \gamma^-
$$

该规则处理条件表达式 `ifz`，用于对自然数进行模式匹配。如果 $e_0$ 为零，执行 $e_1$，返回负极性类型 $\gamma^-$。

- $e_0$：一个自然数类型的表达式，其结果类型是 $\gamma^-$。
- $x.e_1$：如果 $e_0$ 为零，则执行该表达式。$x$ 是自然数，$e_1$ 的结果类型也是 $\gamma^-$。

#### **规则 38.2b**：强制负续延的类型推导
$$
\Gamma \vdash k^- : \tau^- \Rightarrow \gamma^- \quad \Rightarrow \quad \Gamma \vdash \text

{force}^-(k^-) : ↓\tau^- \Rightarrow \gamma^-
$$

这个规则描述了如何强制执行延迟计算。$k^-$ 是一个负续延，作用于负极性类型 $\tau^-$，并返回 $\gamma^-$。通过强制操作 `force^-(k^-)$，我们可以将延迟的负极性计算 $↓\tau^-$ 转化为实际的计算，返回类型 $\gamma^-$。

---

### **总结**

**静态语义**为程序中的表达式提供了类型推导规则。通过区分正极性和负极性的类型推导，我们可以灵活地处理急切计算与惰性计算。正值的静态规则包括自然数和延迟计算，负值则主要包括函数和递归。通过这些规则，我们可以确保程序的类型正确性，并且合理地分配计算的时机。

### ---------------------------------

### 38.3 静态语义 - 负值、负续延和计算

在本节中，我们将详细探讨 **负值**、**负续延** 和 **计算** 的静态类型推导规则。这些规则确保程序的各个部分能够正确类型化，从而保持计算的一致性和正确性。每个规则都将逐步解释，并对公式中的符号进行详细解析。

---

### **1. 负值的静态语义规则**

负值通常与惰性求值和函数类型相关，它们通过行为来定义。负值的静态推导规则如下：

#### **规则 38.3a**：λ 抽象的类型推导规则
$$
\Gamma, x : \tau^+_1 \vdash e : \tau^-_2 \quad \Rightarrow \quad \Gamma \vdash \lambda (x:\tau^+_1) e : \tau^+_1 * \tau^-_2
$$

**解释**：该规则定义了一个函数（λ-抽象）的类型推导。函数的输入是正极性类型 $\tau^+_1$，输出是负极性类型 $\tau^-_2$ 的表达式 $e$。

- **$\lambda (x:\tau^+_1) e$**：表示一个函数，$x$ 是类型为 $\tau^+_1$ 的输入参数，而 $e$ 是类型为 $\tau^-_2$ 的输出表达式。
- **$\tau^+_1 * \tau^-_2$**：表示该函数的类型，它从正极性输入 $\tau^+_1$ 映射到负极性输出 $\tau^-_2$。

该规则明确了函数类型的推导：**函数的参数是正极性类型，而函数的结果是负极性类型**。这与函数的惰性求值有关，函数本身通过其行为（即应用到参数时的表现）来定义，而不是通过值来定义。

#### **规则 38.3b**：正值作为负值的类型推导规则
$$
\Gamma \vdash v^+ : \tau^+ \quad \Rightarrow \quad \Gamma \vdash \text{del}^+(v^+) : \uparrow \tau^+
$$

**解释**：该规则定义了正极性值如何转换为负极性值。通过操作 $\text{del}^+(v^+)$，正值 $v^+$ 可以被视为负值 $\uparrow \tau^+$。

- **$\uparrow \tau^+$**：表示正极性类型 $\tau^+$ 被提升为负极性类型。
- 这表明正值可以在负极性环境中使用。例如，正值自然数可以作为函数的参数传递到负极性函数中。

这条规则体现了**极性转换**的能力，通过 $del^+$ 操作，程序员可以将正值嵌入到负极性计算中。

#### **规则 38.3c**：递归定义的类型推导规则
$$
\Gamma, x : ↓ \tau^- \vdash v^- : \tau^- \quad \Rightarrow \quad \Gamma \vdash \text{fix } x \text{ is } v^- : \tau^-
$$

**解释**：这个规则描述了**递归定义**的类型推导。在递归定义中，$x$ 是一个延迟计算的负极性值，并且 $v^-$ 是对自身的引用。

- **$\text{fix } x \text{ is } v^-$**：表示一个递归定义，其中 $x$ 是负值 $v^-$ 的递归引用。
- **$\tau^-$**：表示递归定义的类型，整个递归定义的类型仍然是负极性类型。

递归定义允许程序员定义自引用的函数或数据结构，这对于处理无限数据结构或递归算法非常重要。

---

### **2. 负续延的静态语义规则**

负续延的推导规则描述了负极性类型如何与正值或其他负极性表达式进行交互。负续延的静态推导规则如下：

#### **规则 38.4a**：函数应用的类型推导规则
$$
\Gamma \vdash v^+_1 : \tau^+_1 \quad \Gamma \vdash k^-_2 : \tau^-_2 \Rightarrow \gamma^- \quad \Rightarrow \quad \Gamma \vdash \text{ap}(v^+_1; k^-_2) : \tau^+_1 * \tau^-_2 \Rightarrow \gamma^-
$$

**解释**：这个规则描述了如何将正值 $v^+_1$ 应用于一个负续延 $k^-_2$。函数应用的结果是从正极性类型 $\tau^+_1$ 映射到负极性类型 $\tau^-_2$ 的负续延。

- **$\text{ap}(v^+_1; k^-_2)$**：表示将正值 $v^+_1$ 应用于负续延 $k^-_2$。
- **$\tau^+_1 * \tau^-_2$**：表示函数从正极性输入到负极性输出的映射。

该规则定义了函数应用的行为：正值 $v^+_1$ 被作为输入传递给负续延 $k^-_2$，后者处理计算的负极性结果。

#### **规则 38.4b**：强制正值的类型推导规则
$$
\Gamma, x : \tau^+ \vdash e : \gamma^- \quad \Rightarrow \quad \Gamma \vdash \text{force}^+(x.e) : \uparrow \tau^+ \Rightarrow \gamma^-
$$

**解释**：该规则描述了强制计算一个正极性值 $x$，并将其传递给负极性计算 $e$。

- **$\text{force}^+(x.e)$**：表示将正极性值 $x$ 强制应用于负极性计算 $e$。
- **$\uparrow \tau^+$**：表示将正极性类型 $x$ 转换为负极性类型，并传递给 $e$。

这个规则允许将正极性值嵌入到负极性计算中，并强制对其进行计算。

---

### **3. 计算的静态语义规则**

计算的静态推导规则定义了不同类型的计算如何类型化，尤其是如何处理正负极性值之间的传递。计算的静态推导规则如下：

#### **规则 38.5a**：返回负值的类型推导规则
$$
\Gamma \vdash v^- : \tau^- \quad \Rightarrow \quad \Gamma \vdash \text{ret}(v^-) : \tau^-
$$

**解释**：该规则规定了返回负极性值的基本形式。如果我们有一个负极性值 $v^-$，那么 `ret(v^-)$ 就是返回该值的计算，类型为 $\tau^-$。

- **$\text{ret}(v^-)$**：表示返回负值 $v^-$。
- **$\tau^-$**：表示返回负值的类型。

该规则是递归或函数计算的终止条件，表示计算已经完成并返回一个负极性结果。

#### **规则 38.5b**：将正值传递给正续延的类型推导规则
$$
\Gamma \vdash v^+ : \tau^+ \quad \Gamma \vdash k^+ : \tau^+ \Rightarrow \gamma^- \quad \Rightarrow \quad \Gamma \vdash v^+ . k^+ : \gamma^-
$$

**解释**：这个规则描述了如何将正极性值 $v^+$ 传递给正极性续延 $k^+$，并继续计算负极性类型 $\gamma^-$。

- **$v^+ . k^+$**：表示正值 $v^+$ 被传递给正续延 $k^+$。
- **$\gamma^-$**：表示该计算最终返回负极性类型。

这个规则说明了正值如何通过正续延传递，并进行后续的计算。

#### **规则 38.5c**：将负值传递给负续延的类型推导规则
$$
\Gamma \vdash v^- : \tau^- \quad \Gamma \vdash k^- : \tau^- \Rightarrow \gamma^- \quad \Rightarrow \quad \Gamma \vdash v^- . k^- : \gamma^-
$$

**解释**：类似于规则 38.5b，这个规则描述了如何将负极性值 $v^-$ 传递给负极性续延 $k^-$，并继续计算负极性类型 $\gamma^-$。

- **$v^- . k^-$**：表示负值 $v^-$ 被传递给负续延 $k^-$。
- **$\gamma^-$**：表示该计算最终返回负极性

类型。

这条规则处理的是递归或惰性计算中负极性值的传递。

---

### **总结**

- **负值的静态语义规则**：包括 λ-抽象、正值作为负值的转换以及递归定义。函数抽象通过将正值作为参数，计算负极性结果；递归允许定义自引用的计算。
  
- **负续延的静态语义规则**：主要处理正值和负续延的交互，通过函数应用和强制计算来实现。

- **计算的静态语义规则**：包括返回负值、正值传递给正续延，以及负值传递给负续延的规则，确保不同极性之间的值传递能够正确进行。

这些规则构建了 $L^\pm\{nat^*\}$ 语言的静态类型推导框架，确保正负极性类型能够在计算中一致地进行。

### ---------------------------------

### 38.4 动态语义 (Dynamics)

**动态语义**描述了程序的计算过程，也就是程序在执行时如何从一个状态转换到另一个状态。在 **$L^\pm\{nat^*\}$** 语言中，动态语义由**转移系统** $e \rightarrow e'$ 定义，描述了计算的各个步骤。规则都是公理形式的，不需要前提，因为续延用于管理待处理的计算。

接下来我们将详细解释每一条动态规则，并对涉及的公式进行详细解析。

---

### **1. 自然数条件判断的动态规则**

#### **规则 38.6a**：
$$
z . \text{ifz}(e_0; x.e_1) \rightarrow e_0
$$

**解释**：当条件表达式 `ifz` 的判断值为零 $z$ 时，计算直接返回 $e_0$。

- **$z$**：表示自然数的零。
- **$\text{ifz}(e_0; x.e_1)$**：这是一个条件表达式，类似于 `if` 语句。如果 $z$ 为零，则计算结果为 $e_0$，否则执行 $e_1$。
- **$\rightarrow e_0$**：表示根据条件，计算返回 $e_0$。

#### **公式详解**：

该公式描述了在遇到零值时，条件判断的行为。`ifz` 是自然数上的模式匹配，零值触发分支 $e_0$，因此整个表达式立即转化为 $e_0$，不涉及任何进一步的计算。这是急切计算的典型例子。

---

#### **规则 38.6b**：
$$
s(v^+) . \text{ifz}(e_0; x.e_1) \rightarrow [v^+/x]e_1
$$

**解释**：当条件表达式 `ifz` 的判断值为非零（即后继值 $s(v^+)$）时，计算返回 $e_1$，并将 $v^+$ 代入 $x$。

- **$s(v^+)$**：表示一个自然数的后继，例如 $1$ 是 $0$ 的后继，$2$ 是 $1$ 的后继。
- **$[v^+/x]e_1$**：表示将后继值 $v^+$ 替换为 $x$ 并代入到表达式 $e_1$ 中。

#### **公式详解**：

在自然数递归结构中，后继值 $s(v^+)$ 表示非零值。因此，当我们遇到 `ifz` 表达式且输入为非零值时，计算结果为 $e_1$，并将 $v^+$ 绑定到 $x$。这种替换操作在递归过程中非常常见，它将计算的值绑定到对应的变量上，允许我们对自然数的递归结构进行进一步处理。

---

### **2. 延迟计算与强制计算的动态规则**

#### **规则 38.6c**：
$$
\text{del}^-(e) . \text{force}^-(k^-) \rightarrow e ; k^-
$$

**解释**：当我们对延迟计算 $del^-(e)$ 进行强制计算时，延迟的表达式 $e$ 被激活，并继续执行负续延 $k^-$。

- **$\text{del}^-(e)$**：表示一个延迟计算的表达式 $e$。
- **$\text{force}^-(k^-)$**：表示强制执行延迟计算的操作，触发计算 $e$ 并将结果传递给负续延 $k^-$。
- **$e ; k^-$**：表示表达式 $e$ 计算后，继续执行负续延 $k^-$。

#### **公式详解**：

延迟计算允许我们将某个表达式的计算推迟，直到我们明确要求通过 `force` 操作触发它。在这个规则中，延迟计算的表达式 $e$ 被立即执行，并将其结果传递给续延 $k^-$ 进行进一步处理。$e ; k^-$ 是计算与续延的组合，表示 $e$ 的结果被传递到 $k^-$。

---

### **3. 函数应用的动态规则**

#### **规则 38.6d**：
$$
\lambda (x:\tau^+) e . \text{ap}(v^+; k^-) \rightarrow [v^+/x]e ; k^-
$$

**解释**：当一个 λ 函数（抽象）应用到一个正极性值 $v^+$ 时，将 $v^+$ 代入函数体 $e$，并继续执行负续延 $k^-$。

- **$\lambda (x:\tau^+) e$**：表示一个函数，参数 $x$ 的类型为正极性类型 $\tau^+$，函数体为 $e$。
- **$\text{ap}(v^+; k^-)$**：表示将正极性值 $v^+$ 应用到负续延 $k^-$，即函数的参数是 $v^+$。
- **$[v^+/x]e$**：表示将 $v^+$ 代入到 $x$，然后在函数体 $e$ 中执行。
- **$e ; k^-$**：表示计算 $e$ 并将结果传递给负续延 $k^-$。

#### **公式详解**：

该规则描述了函数应用的行为。首先，正极性值 $v^+$ 被应用到函数的参数 $x$ 上，接着将其代入函数体 $e$ 中进行计算。计算完成后，结果传递给负续延 $k^-$。这种结构允许函数在接受参数后立即进行计算，并在计算结束后继续执行剩余的操作。

---

### **4. 延迟正值的强制计算规则**

#### **规则 38.6e**：
$$
\text{del}^+(v^+) . \text{force}^+(x.e) \rightarrow [v^+/x]e
$$

**解释**：当延迟的正值 $del^+(v^+)$ 被强制计算时，将正值 $v^+$ 代入 $x$ 并执行表达式 $e$。

- **$\text{del}^+(v^+)$**：表示一个延迟计算的正值 $v^+$。
- **$\text{force}^+(x.e)$**：表示强制执行正值计算，并将结果代入表达式 $e$。
- **$[v^+/x]e$**：表示将 $v^+$ 代入 $x$，然后在表达式 $e$ 中执行。

#### **公式详解**：

在这个规则中，延迟的正值 $v^+$ 被强制执行，其结果被代入到表达式 $e$ 中。这种操作确保了延迟计算的正值在需要时才被激活，并且能够参与后续的计算。通过这种方式，惰性计算可以与急切计算共存，并在需要时进行求值。

---

### **5. 递归定义的动态规则**

#### **规则 38.6f**：
$$
\text{fix } x \text{ is } v^- . k^- \rightarrow [\text{del}^-(\text{fix } x \text{ is } v^-)/x]v^- . k^-
$$

**解释**：当递归定义 $fix$ 被计算时，递归引用 $x$ 被替换为延迟计算的自身，并继续执行递归体 $v^-$ 和负续延 $k^-$。

- **$\text{fix } x \text{ is } v^-$**：表示一个递归定义，$x$ 自引用 $v^-$。
- **$[\text{del}^-(\text{fix } x \text{ is } v^-)/x]v^-$**：表示将 $x$ 替换为延迟计算 $del^-(\text{fix } x \text{ is } v^-)$，并继续执行递归体 $v^-$。
- **$v^- . k^-$**：表示递归体 $v^-$ 计算完成后，继续执行负续延 $k^-$。

#### **公式详解**：

递归定义允许自引用，在这个规则中，通过将递归定义自身延迟计算并替换到递归体中，保证了递归可以正确展开。`fix` 操作是一种处理无限数据结构或递归函数的常用方式，通过延迟计算确保递归的展开在需要时才进行，从而避免了无限循环的即时展开。

---

### **6. 续延组合**

除了上述规则之外，动态语义中还引入了一种新的组合形式 $e ; k^-$，表示将表达式 $e$ 和负续延 $k^-$ 进行组合。组合操作允许我们将计算和续延连接起来，形成一个**栈**（stack）结构，用于管理待执行的操作。

### ---------------------------------

### 38.4 动态规则 (续延的组合规则)

在编程语言中，**续延**(continuations) 是用来管理和追踪程序执行过程中尚未完成的计算的一种机制。在 **$L^\pm\{nat^*\}$** 语言的动态规则中，续延的组合操作 $e ; k^-$ 允许我们将计算与续延连接起来，形成一个**栈**(stack) 结构。以下是几条关键的续延组合规则，每条规则会解释其公式中的符号含义和具体作用。

---

### **1. 返回负值与续延的组合**

#### **规则 38.7a**：
$$
\text{ret}(v^-) ; k^-_0 = v^- . k^-_0
$$

**解释**：当返回一个负值 $v^-$ 时，续延组合操作将这个返回值与续延 $k^-_0$ 直接组合成 $v^- . k^-_0$。

- **$\text{ret}(v^-)$**：表示返回负极性值 $v^-$ 的计算。返回操作意味着当前计算已经结束，得到了一个负极性结果。
- **$v^- . k^-_0$**：表示负值 $v^-$ 被传递给续延 $k^-_0$，并继续执行。

#### **公式详解**：

这条规则简单地表示，返回负值之后，该负值将被立即传递给续延 $k^-_0$，以继续完成剩余的计算。这是递归或函数返回的常见形式，表示程序在计算出结果后，如何将结果传递给剩余的待处理部分。

---

### **2. 函数续延与续延的组合**

#### **规则 38.7b**：
$$
k^- ; k^-_0 = k^-_1 \quad \text{和} \quad (v^- . k^-) ; k^-_0 = v^- . k^-_1
$$

**解释**：当一个负续延 $k^-$ 与另一个负续延 $k^-_0$ 组合时，形成新的续延 $k^-_1$。当负值 $v^-$ 已经被传递给了第一个续延 $k^-$ 后，它与另一个续延 $k^-_0$ 组合，会形成新的组合 $v^- . k^-_1$。

- **$k^- ; k^-_0$**：表示两个负续延的组合，形成新的续延 $k^-_1$。
- **$(v^- . k^-) ; k^-_0$**：表示负值 $v^-$ 已经通过续延 $k^-$ 处理后，将继续传递给 $k^-_0$。

#### **公式详解**：

这个规则说明了负续延的组合操作。续延是执行流程的栈结构，当续延被组合时，新的续延 $k^-_1$ 会管理剩余的计算，确保负值能够依次被传递和处理。

---

### **3. 函数应用与正续延的组合**

#### **规则 38.7c**：
$$
k^+ ; k^-_0 = k^+_1 \quad \text{和} \quad (v^+ . k^+) ; k^-_0 = v^+ . k^+_1
$$

**解释**：当一个正续延 $k^+$ 与负续延 $k^-_0$ 组合时，形成新的续延 $k^+_1$。当正值 $v^+$ 已经被传递给了第一个续延 $k^+$ 后，它与负续延 $k^-_0$ 组合，形成新的组合 $v^+ . k^+_1$。

- **$k^+ ; k^-_0$**：表示正续延和负续延的组合，形成新的续延 $k^+_1$。
- **$(v^+ . k^+) ; k^-_0$**：表示正值 $v^+$ 已经通过续延 $k^+$ 处理后，继续传递给负续延 $k^-_0$。

#### **公式详解**：

这条规则与前一条类似，但涉及正值和正续延。它说明了正续延和负续延可以组合执行，当正值被处理完毕后，形成新的续延 $k^+_1$，用于进一步处理剩余的计算。

---

### **4. 条件判断与续延的组合**

#### **规则 38.7d**：
$$
e_0 ; k^- = e_0^0 \quad \text{和} \quad (x | e_1 ; k^-) = e_1^0 \quad \text{和} \quad \text{ifz}(e_0; x.e_1) ; k^- = \text{ifz}(e_0^0; x.e_1^0)
$$

**解释**：条件表达式 `ifz` 参与续延组合时，条件部分 $e_0$ 和分支 $e_1$ 都会与负续延 $k^-$ 组合，形成新的计算。

- **$e_0 ; k^-$**：表示条件判断的计算 $e_0$ 与续延 $k^-$ 组合，生成新的计算 $e_0^0$。
- **$x | e_1 ; k^-$**：表示分支计算 $e_1$ 与续延 $k^-$ 组合，生成新的计算 $e_1^0$。
- **$\text{ifz}(e_0; x.e_1) ; k^-$**：表示条件表达式与续延的组合，分别对条件部分和分支部分进行处理。

#### **公式详解**：

该规则描述了条件表达式的处理方式。当条件判断 `ifz` 被续延组合时，条件表达式和分支都会被应用续延。这种递归结构允许我们同时处理判断条件和执行分支，并确保结果能够继续传递到续延中进行后续处理。

---

### **5. 负续延的强制计算**

#### **规则 38.7e**：
$$
k^- ; k^-_0 = k^-_1 \quad \text{和} \quad \text{force}^-(k^-) ; k^-_0 = \text{force}^-(k^-_1)
$$

**解释**：当负续延 $k^-$ 与另一个负续延 $k^-_0$ 组合时，结果是新的续延 $k^-_1$。当强制计算操作 `force^-` 作用于 $k^-$ 时，续延组合结果会传递给新的续延 $k^-_1$。

- **$\text{force}^-(k^-)$**：表示对负极性值的强制计算。
- **$k^-_1$**：表示续延组合后的新续延。

#### **公式详解**：

这条规则说明了负极性计算的强制执行过程。负续延组合时，新的续延将继续管理计算。当 `force^-` 操作作用于负续延时，它会触发负值的计算，并且续延继续组合以确保处理流程的完整性。

---

### **6. 函数应用与续延的组合**

#### **规则 38.7f**：
$$
k^- ; k^-_0 = k_1 \quad \text{和} \quad \text{ap}(v^+; k^-) ; k^-_0 = \text{ap}(v^+; k^-_1)
$$

**解释**：当函数应用 `ap(v^+; k^-)$ 被续延组合时，正值 $v^+$ 继续传递到新的负续延 $k^-_1$。

- **$\text{ap}(v^+; k^-)$**：表示函数应用，$v^+$ 是函数的输入参数，$k^-$ 是函数的负续延。
- **$k^-_1$**：表示续延组合之后的新续延。

#### **公式详解**：

该规则处理了函数应用与续延的组合。函数应用是将正值 $v^+$ 传递给函数体，而组合续延确保函数的执行能够在整个栈结构上完成。新的续延 $k^-_1$ 继续处理函数的剩余部分。

---

### **7. 正续延强制计算的组合**

#### **规则 38.7g**：
$$
x | e ; k^-_0 = e^0 \quad \text{和} \quad \text{force}^+(x.e) ; k^-_0 = \text{force}^+(x.e^0)
$$

**解释**：当正极性表达式 `force^+(x.e)$ 被续延组合时，计算 $e$ 会与负续延 $k^-_0$ 组合，形成新的表达式 $e^0$。

- **$\text{force}^+(x.e)$**：表示强制计算正极性值，并将其代入

 $e$。
- **$e^0$**：表示 $e$ 与续延 $k^-_0$ 组合后的结果。

#### **公式详解**：

这条规则处理了正极性表达式的强制执行。通过 `force^+(x.e)$ 操作，正值被强制计算并传递给表达式 $e$，续延 $k^-_0$ 组合确保剩余计算能够正确进行。最终，新的表达式 $e^0$ 代表续延组合后的结果。

---

### **总结**

这些规则描述了续延的组合行为，特别是当续延与计算（或另一个续延）组合时，如何继续计算。续延组合操作通过构建**栈结构**，确保程序在每个步骤中可以递归执行剩余的操作。每条规则都详细解释了如何处理不同类型的续延组合，例如返回值、函数应用、强制计算和条件判断等。

### ---------------------------------

### 38.5 安全性 (Safety)

**安全性**是编程语言中重要的属性，它确保程序在执行过程中类型保持不变，并且不会发生类型错误。对于 **$L^\pm\{nat^*\}$**，安全性通过 **保持性**(preservation) 和 **进展性**(progress) 来证明。保持性证明确保程序在执行的每一步中，类型始终正确。对于 **$L^\pm\{nat^*\}$**，保持性证明依赖于替换和组合的类型属性。

---

### **引理 38.1：替换 (Substitution)**

这个引理描述了替换操作的类型属性。替换是动态计算中的重要操作，特别是当我们将某个值替换到表达式或续延中时，确保其类型不变是关键。

假设 $\Gamma \vdash v^+ : \rho^+$，我们有以下替换规则：

#### **1. 替换规则 (1) - 对表达式 $e$ 的替换**
$$
\text{如果 } \Gamma, x : \rho^+ \vdash e : \gamma^- \text{，那么 } \Gamma \vdash [v^+/x]e : \gamma^-
$$

**解释**：如果表达式 $e$ 在上下文 $\Gamma$ 中，且 $x$ 具有类型 $\rho^+$，替换 $x$ 为正值 $v^+$ 后，表达式 $e$ 仍然具有负极性类型 $\gamma^-$。

#### **公式详解**：
- **$[v^+/x]e$**：表示将正值 $v^+$ 替换为表达式 $e$ 中的变量 $x$。
- **$\Gamma \vdash e : \gamma^-$**：表示在上下文 $\Gamma$ 中，表达式 $e$ 的类型为负极性类型 $\gamma^-$。
- **替换后类型保持不变**：替换操作不改变表达式的类型，它仍然是 $\gamma^-$。

---

#### **2. 替换规则 (2) - 对负值 $v^-$ 的替换**
$$
\text{如果 } \Gamma, x : \rho^+ \vdash v^- : \tau^- \text{，那么 } \Gamma \vdash [v^+/x]v^- : \tau^-
$$

**解释**：如果负值 $v^-$ 在上下文 $\Gamma$ 中，且 $x$ 具有类型 $\rho^+$，替换 $x$ 为正值 $v^+$ 后，负值 $v^-$ 仍然具有负极性类型 $\tau^-$。

#### **公式详解**：
- **$[v^+/x]v^-$**：表示将正值 $v^+$ 替换为负值 $v^-$ 中的变量 $x$。
- **$\Gamma \vdash v^- : \tau^-$**：表示在上下文 $\Gamma$ 中，负值 $v^-$ 的类型为负极性类型 $\tau^-$。
- **替换后类型保持不变**：替换操作不会改变负值的类型，它仍然是负极性类型 $\tau^-$。

---

#### **3. 替换规则 (3) - 对正续延 $k^+$ 的替换**
$$
\text{如果 } \Gamma, x : \rho^+ \vdash k^+ : \tau^+ \Rightarrow \gamma^- \text{，那么 } \Gamma \vdash [v^+/x]k^+ : \tau^+ \Rightarrow \gamma^-
$$

**解释**：如果正续延 $k^+$ 在上下文 $\Gamma$ 中，且 $x$ 具有类型 $\rho^+$，替换 $x$ 为正值 $v^+$ 后，正续延 $k^+$ 仍然具有从正极性类型 $\tau^+$ 到负极性类型 $\gamma^-$ 的映射类型。

#### **公式详解**：
- **$[v^+/x]k^+$**：表示将正值 $v^+$ 替换为正续延 $k^+$ 中的变量 $x$。
- **$\Gamma \vdash k^+ : \tau^+ \Rightarrow \gamma^-$**：表示在上下文 $\Gamma$ 中，正续延 $k^+$ 的类型为从正极性类型 $\tau^+$ 映射到负极性类型 $\gamma^-$。
- **替换后类型保持不变**：替换操作不改变正续延的类型，它仍然是从 $\tau^+$ 到 $\gamma^-$ 的映射。

---

#### **4. 替换规则 (4) - 对正值 $v^+_1$ 的替换**
$$
\text{如果 } \Gamma, x : \rho^+ \vdash v^+_1 : \tau^+ \text{，那么 } \Gamma \vdash [v^+/x]v^+_1 : \tau^+
$$

**解释**：如果正值 $v^+_1$ 在上下文 $\Gamma$ 中，且 $x$ 具有类型 $\rho^+$，替换 $x$ 为正值 $v^+$ 后，正值 $v^+_1$ 仍然具有正极性类型 $\tau^+$。

#### **公式详解**：
- **$[v^+/x]v^+_1$**：表示将正值 $v^+$ 替换为正值 $v^+_1$ 中的变量 $x$。
- **$\Gamma \vdash v^+_1 : \tau^+$**：表示在上下文 $\Gamma$ 中，正值 $v^+_1$ 的类型为正极性类型 $\tau^+$。
- **替换后类型保持不变**：替换操作不会改变正值的类型，它仍然是正极性类型 $\tau^+$。

---

#### **5. 替换规则 (5) - 对负续延 $k^-$ 的替换**
$$
\text{如果 } \Gamma, x : \rho^+ \vdash k^- : \tau^- \Rightarrow \gamma^- \text{，那么 } \Gamma \vdash [v^+/x]k^- : \tau^- \Rightarrow \gamma^-
$$

**解释**：如果负续延 $k^-$ 在上下文 $\Gamma$ 中，且 $x$ 具有类型 $\rho^+$，替换 $x$ 为正值 $v^+$ 后，负续延 $k^-$ 仍然具有从负极性类型 $\tau^-$ 到负极性类型 $\gamma^-$ 的映射类型。

#### **公式详解**：
- **$[v^+/x]k^-$**：表示将正值 $v^+$ 替换为负续延 $k^-$ 中的变量 $x$。
- **$\Gamma \vdash k^- : \tau^- \Rightarrow \gamma^-$**：表示在上下文 $\Gamma$ 中，负续延 $k^-$ 的类型为从负极性类型 $\tau^-$ 映射到负极性类型 $\gamma^-$。
- **替换后类型保持不变**：替换操作不改变负续延的类型，它仍然是从 $\tau^-$ 到 $\gamma^-$ 的映射。

---

### **证明**

这些替换规则的正确性是通过对目标表达式的类型推导进行归纳证明的。归纳证明的关键在于，每一步替换操作都保持了类型的正确性，无论是对表达式、正值、负值，还是对正续延和负续延的替换操作。

---

### **总结**

引理 38.1 的五条替换规则确保了在 **$L^\pm\{nat^*\}$** 中，替换操作不会改变表达式、值和续延的类型。通过这些规则，程序的类型保持性得到保证，即在程序执行的每一步中，替换后的程序仍然符合其静态类型系统的要求。这是程序安全性的重要组成部分，它确保程序在执行过程中不会发生类型错误。

### ---------------------------------

### 38.5 安全性 (Safety) - 组合与保持性

在本节中，除了替换外，另一个关键证明是**组合**(composition) 和**保持性**(preservation)。组合性保证了表达式、值和续延在组合后能够保持其类型正确性，而保持性证明确保了程序的执行不会破坏其类型系统的正确性。以下是 **引理 38.2** 和 **定理 38.3** 与 38.4 的详细解释和公式解析。

---

### **引理 38.2：组合 (Composition)**

组合引理定义了不同类型的表达式和续延在组合时的类型推导规则。

#### **1. 表达式与负续延的组合**
$$
\text{如果 } \Gamma \vdash e : \tau^- \text{ 和 } \Gamma \vdash k^- : \tau^- \Rightarrow \gamma^- \text{，那么 } \Gamma \vdash e ; k^- : \tau^- \Rightarrow \gamma^-
$$

**解释**：当表达式 $e$ 的类型是负极性类型 $\tau^-$，且负续延 $k^-$ 能够将 $\tau^-$ 类型的结果转换为 $\gamma^-$，那么组合 $e ; k^-$ 也是一个从 $\tau^-$ 到 $\gamma^-$ 的负极性表达式。

#### **公式详解**：
- **$e$**：负极性表达式，其类型为 $\tau^-$。
- **$k^-$**：负续延，表示从负极性类型 $\tau^-$ 到负极性类型 $\gamma^-$ 的映射。
- **$e ; k^-$**：表示表达式 $e$ 执行完后，结果传递给续延 $k^-$，并继续计算，类型保持为 $\tau^- \Rightarrow \gamma^-$。

---

#### **2. 正续延与负续延的组合**
$$
\text{如果 } \Gamma \vdash k^+_0 : \tau^+ \Rightarrow \gamma^-_0 \text{ 和 } \Gamma \vdash k^-_1 : \gamma^-_0 \Rightarrow \gamma^-_1 \text{，那么 } \Gamma \vdash k^+_0 ; k^-_1 : \tau^+ \Rightarrow \gamma^-_1
$$

**解释**：当正续延 $k^+_0$ 将正极性类型 $\tau^+$ 映射到负极性类型 $\gamma^-_0$，且负续延 $k^-_1$ 将 $\gamma^-_0$ 映射到 $\gamma^-_1$，那么组合 $k^+_0 ; k^-_1$ 表示从正极性类型 $\tau^+$ 映射到负极性类型 $\gamma^-_1$。

#### **公式详解**：
- **$k^+_0$**：正续延，从正极性类型 $\tau^+$ 映射到负极性类型 $\gamma^-_0$。
- **$k^-_1$**：负续延，从负极性类型 $\gamma^-_0$ 映射到负极性类型 $\gamma^-_1$。
- **$k^+_0 ; k^-_1$**：续延组合表示从正极性输入到最终的负极性结果，保持了类型的转换。

---

#### **3. 两个负续延的组合**
$$
\text{如果 } \Gamma \vdash k^-_0 : \tau^- \Rightarrow \gamma^-_0 \text{ 和 } \Gamma \vdash k^-_1 : \gamma^-_0 \Rightarrow \gamma^-_1 \text{，那么 } \Gamma \vdash k^-_0 ; k^-_1 : \tau^- \Rightarrow \gamma^-_1
$$

**解释**：当负续延 $k^-_0$ 将 $\tau^-$ 类型映射到 $\gamma^-_0$，且负续延 $k^-_1$ 将 $\gamma^-_0$ 映射到 $\gamma^-_1$，组合 $k^-_0 ; k^-_1$ 表示从 $\tau^-$ 类型到 $\gamma^-_1$ 类型的映射。

#### **公式详解**：
- **$k^-_0$**：第一个负续延，从 $\tau^-$ 映射到 $\gamma^-_0$。
- **$k^-_1$**：第二个负续延，从 $\gamma^-_0$ 映射到 $\gamma^-_1$。
- **$k^-_0 ; k^-_1$**：表示两个负续延的组合，最终结果是从 $\tau^-$ 到 $\gamma^-_1$。

---

### **定理 38.3：保持性 (Preservation)**

**定理 38.3** 保持性定理表明，在程序执行过程中，类型保持不变。也就是说，如果表达式 $e$ 的类型是 $\gamma^-$，且 $e$ 可以转移到 $e'$ (即 $e \rightarrow e'$)，那么 $e'$ 也具有相同的类型 $\gamma^-$。

#### **保持性定理 (Preservation)**：
$$
\text{如果 } \Gamma \vdash e : \gamma^- \text{ 且 } e \rightarrow e' \text{，那么 } \Gamma \vdash e' : \gamma^-
$$

**解释**：保持性定理表明，在上下文 $\Gamma$ 中，如果表达式 $e$ 的类型为 $\gamma^-$，且 $e$ 可以转化为另一个表达式 $e'$，那么 $e'$ 仍然具有相同的类型 $\gamma^-$。这是类型安全性的一个核心定理，确保程序在执行过程中不会违反类型规则。

#### **证明方法**：
保持性的证明通常通过对转移规则的归纳进行。这意味着我们要证明每一个转移规则都保持类型的正确性。在此过程中，我们会引用 **引理 38.1**（替换）和 **引理 38.2**（组合）来辅助证明。

---

### **定理 38.4：进展性 (Progress)**

**定理 38.4** 进展性定理表明，如果表达式 $e$ 已经正确类型化，要么 $e$ 是一个返回某个负值的终止表达式，要么 $e$ 可以进一步转移到另一个表达式 $e'$。

#### **进展性定理 (Progress)**：
$$
\text{如果 } \Gamma \vdash e : \gamma^- \text{，那么 } e = \text{ret}(v^-) \text{ 对于某个负值 } v^- \text{，或者存在 } e' \text{ 使得 } e \rightarrow e'
$$

**解释**：进展性定理确保了程序执行的每一步要么是终止状态（返回某个负值），要么可以继续计算（有一个新的表达式 $e'$ 作为下一个计算步骤）。这保证了程序不会卡在某个状态而无法继续。

#### **证明方法**：
进展性的证明依赖于对值的分类，以及每种类型的值如何表现。通过 **聚焦**（focusing），我们可以直接定义每种类型的值，并明确表达式在何种情况下会继续计算或终止。

---

### **总结**

- **引理 38.2** 定义了组合的类型推导规则，确保了表达式与续延在组合后仍然具有正确的类型。
- **定理 38.3** 保持性定理证明了程序在执行过程中类型不变，确保了类型安全性。
- **定理 38.4** 进展性定理确保程序在执行时要么终止要么继续计算，避免程序陷入无法继续的状态。

这两大定理（保持性和进展性）是编程语言中类型安全的核心，它们共同保证了程序在执行过程中类型不会出错，且计算能够顺利进行。

### ---------------------------------

### 38.6 备注 (Notes)

**极性化** (Polarization) 的概念最早由 **Andreoli** 在 1992 年提出，目的是在 **线性逻辑** (linear logic) 的证明搜索中引入**聚焦**(focusing) 这一技术。聚焦的基本思想是通过将逻辑公式的某些部分“聚焦”到当前推理步骤中，从而减少需要考虑的选择数量，使证明搜索更加高效。

- **Andreoli (1992)**: 提出的**聚焦**(focusing) 技术是为了在逻辑推理中限制那些与推理无关的步骤，从而简化推理过程，特别是在 **线性逻辑** 中。通过将推理限制在某些“聚焦”的部分，可以提高证明搜索的效率。
  

在本文的 **$L^\pm\{nat^*\}$** 的语法和语义规则中，极性化（正负类型的区分）是基于对计算的求值顺序进行控制的。程序语言中的极性化通过区分正类型（以构造为基础）和负类型（以观察为基础），提供了对计算模式（如急切求值与惰性求值）的结构化控制。

- **Zeilberger (2008)**: 将聚焦与编程语言中的**求值顺序**(evaluation order) 联系了起来。在这种语境下，聚焦可以用来区分编程语言中的不同求值策略（如**急切**与**惰性求值**），为编程语言的语义提供一种结构化的方式。

---

### **总结**

- **极性化**的概念最初源于 **线性逻辑** 中的**聚焦**技术，它是为减少证明搜索中的冗余步骤而提出的。
- 在编程语言中，极性化被用于控制**求值顺序**，通过区分正类型（急切）和负类型（惰性），为程序的计算行为提供了更精确的结构化方式。


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------
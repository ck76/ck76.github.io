[toc]



### 37.1 Lazy Evaluation 懒惰求值

**懒惰求值**（Lazy Evaluation）是一种将表达式的求值推迟到真正需要的时候的技术。通过懒惰求值，我们可以确保某个计算最多只会被执行一次，并且其结果将被所有涉及该计算的实例共享。

#### 懒惰求值的几种形式：

1. **按需求值**（By-Need Evaluation）策略：  
   按需求值是函数应用的一种策略，它只会在参数被实际使用时才对其进行求值。与**按名求值**（By-Name Evaluation）不同，按名求值会在每次调用时都复制参数，从而可能导致重复求值。而按需求值通过共享已经求值的结果，确保每个函数参数最多被求值一次。

   **公式解释**：  
   按名求值的行为可以用如下公式表示：
   $$
   f(\lambda x.e) \to e[x := v]
   $$
   这里 $f(\lambda x.e)$ 表示传递一个未求值的参数 $x$ 给函数 $f$，但当参数 $x$ 在表达式中多次出现时，$x$ 可能被求值多次。

   而**按需求值**通过引入**悬延**（Suspension），避免了这种重复计算：
   $$
   \text{eval}(\text{susp}(e)) \to e \quad \text{(first time)}
   $$
   悬延即 $e$ 被延迟求值，并在第一次使用时求值，之后所有的引用都会共享同样的结果。

2. **懒惰数据结构**（Lazy Data Structures）：  
   懒惰数据结构中的元素只有在真正需要时才会被计算。如果某个数据结构的元素被多次访问，那么每次访问都可能引发相同的计算。为了避免重复计算，懒惰数据结构中的部分延迟计算也会共享其结果。举个例子，假设一个懒惰列表 $L = [f(1), f(2), \dots]$，在访问其中的第一个元素时 $f(1)$ 会被求值，如果再次访问该元素，则会复用之前的求值结果。

3. **懒惰递归**（Lazy Recursion）：  
   **普通递归**（General Recursion）的求值通过**展开**（Unrolling）来实现，在每次调用时都会重新计算递归部分。懒惰递归则通过共享展开的结果，避免每次递归调用时的重复计算。

### 37.2 按需动态语义（By-Need Dynamics）

在按需动态语义中，表达式的求值是延迟的，只有在需要时才进行。每个表达式的计算结果会被保存并共享给其他所有需要该计算结果的地方。具体的操作如下：

1. **创建悬延**：  
   在懒惰求值中，表达式不会立即被计算，而是被转换为一个悬延：
   $$
   \text{susp}(e) \quad \text{(suspension)}
   $$

2. **首次求值**：  
   当悬延第一次被访问时，它被计算：
   $$
   \text{eval}(\text{susp}(e)) \to e \quad \text{(first time)}
   $$

3. **共享计算结果**：  
   在之后的每次访问中，计算结果会被共享：
   $$
   \text{eval}(\text{susp}(e)) \to v \quad \text{(subsequent accesses)}
   $$

通过这种机制，按需求值保证了表达式最多被计算一次。

### 37.3 安全性（Safety）

为了保证按需求值的安全性，我们需要确保：

1. **类型安全**：懒惰求值和按值求值一样，需要确保类型系统的安全性，即一个表达式在某种上下文中永远不会产生类型错误。

2. **共享结果的正确性**：共享的结果必须与按值求值产生的结果一致，以确保程序的语义一致性。

### 37.4 懒惰数据结构（Lazy Data Structures）

懒惰数据结构是一种延迟求值的数据结构，它的元素在实际使用时才会被计算。懒惰数据结构的主要特点是**共享延迟计算的结果**，从而避免每次访问时重复计算。

#### 例子：懒惰列表

假设我们有一个懒惰列表 $L = [f(1), f(2), \dots]$。当我们第一次访问 $L[1]$ 时，$f(1)$ 会被求值并存储起来。如果再次访问 $L[1]$，将直接返回之前计算的结果，而不会重新求值。

### 37.5 悬延（Suspensions）

**悬延**是懒惰求值的核心概念。它将表达式的求值推迟到真正需要时才进行。悬延通过以下几步实现：

1. **创建悬延**：  
   当我们需要延迟一个表达式 $e$ 的求值时，会将其转化为一个悬延：
   $$
   \text{susp}(e)
   $$

2. **求值与共享**：  
   当悬延首次被访问时，表达式 $e$ 会被求值，其结果会被缓存：
   $$
   \text{eval}(\text{susp}(e)) \to v
   $$
   在接下来的访问中，缓存的结果 $v$ 会被共享。

### 37.6 笔记（Notes）

懒惰求值和按需求值在许多编程语言中得到了广泛的应用。例如，Haskell 是一个典型的懒惰语言，而其他语言则更倾向于急切求值。然而，无论语言的默认策略如何，能够在类型层面上区分懒惰与急切的求值方式，允许开发者根据实际需求来选择，是非常有用的。

### ---------------------------------

### 37.1 按需求动态语义 (By-Need Dynamics)

按需求求值（By-Need Evaluation）使用**记忆化**（Memoization）技术来记录计算结果，这样未来对相同计算的使用可以直接返回之前计算的结果（如果之前没有计算过，则会从头计算）。通过为每个延迟计算分配一个符号（symbol），我们能够追踪其值，这个符号用于在需要时获取延迟计算的结果。**记忆表**（Memo Table）记录了与每个符号相关联的延迟计算，直到该计算被执行为止。在计算结束后，记忆表将存储计算的结果。因此，通过为延迟计算命名和使用记忆表，实现了共享机制，并确保计算的结果不会被重复计算。

#### 记忆表与符号共享机制

按需求值的实现通过**符号**和**记忆表**来实现共享与避免冗余计算。符号关联着计算过程，而记忆表用于记录延迟计算或已经完成的计算结果。

#### 动态语义 (By-Need Dynamics) 的形式：

按需求求值的动态语义基于以下几种状态表示：
$$
\nu \Sigma \{ e \; k \; \mu \}
$$
其中：
- $\Sigma$ 是有限的假设集合，表示符号和它们关联的类型 $a_1 \sim \tau_1, \dots, a_n \sim \tau_n$。
- $e$ 是一个可能涉及 $\Sigma$ 中符号的表达式。
- $\mu$ 是一个映射，每个在 $\Sigma$ 中声明的符号 $a$ 都映射到一个表达式或者特殊符号 $\bullet$，这个特殊符号被称为**黑洞**（black hole）。
- $\nu$ 代表延续的上下文，它维持求值的动态演进。

这种表示形式中的**黑洞**（black hole）$\bullet$是防止递归调用中的无限递归或循环求值的一种手段。

#### 按需求求值的语法规则

按需求求值系统通过以下两种形式来进行判断：
1. **值判断**：$e \; \text{val}_\Sigma$ 表示 $e$ 是一个可能包含符号的值（也就是不需要再进一步求值的表达式）。
2. **求值转移判断**：$\nu \Sigma \{ e \; k \; \mu \} \to \nu \Sigma' \{ e' \; k \; \mu' \}$ 表示表达式 $e$ 相对于记忆表 $\mu$ 和符号集合 $\Sigma$ 进行了一步求值，结果为新的表达式 $e'$，新的记忆表 $\mu'$ 和符号集合 $\Sigma'$。

在按需求求值中，活动符号的集合 $\Sigma$ 随着求值过程而单调增加，并且符号的类型在求值过程中不会改变。记忆表 $\mu$ 在执行过程中可能会被破坏性修改，以反映与符号关联的表达式的进展。

#### 值判断规则

值判断 $e \; \text{val}_\Sigma$ 用以下规则定义：

- $z \; \text{val}_\Sigma$：常量 $z$ 是一个值。
  $$
  z \; \text{val}_\Sigma \tag{37.1a}
  $$
- $s(a) \; \text{val}_\Sigma, a \sim \text{nat}$：当符号 $a$ 关联到自然数时，表达式 $s(a)$ 是一个值。
  $$
  s(a) \; \text{val}_\Sigma, a \sim \text{nat} \tag{37.1b}
  $$
- $\lambda(x:\tau) e \; \text{val}_\Sigma$：任何涉及 $\lambda$ 抽象的表达式（即函数）是一个值，即使它可能包含符号。
  $$
  \lambda(x:\tau) e \; \text{val}_\Sigma \tag{37.1c}
  $$

#### 初始状态与终止状态

- 初始状态表示式：
  $$
  \nu \emptyset \{ e \; k \; \emptyset \} \quad \text{initial} \tag{37.2a}
  $$
  表示求值开始时，表达式 $e$ 被相对于空记忆表 $\emptyset$ 进行求值。
  
- 终止状态表示式：
  $$
  e \; \text{val}_\Sigma \quad \nu \Sigma \{ e \; k \; \mu \} \quad \text{final} \tag{37.2b}
  $$
  终止状态是形如 $\nu \Sigma \{ e \; k \; \mu \}$ 的表达式，其中 $e$ 是 $\Sigma$ 中符号集上的值。

通过这些规则，可以确保按需求求值的过程能够安全有效地完成，并且每个延迟的计算只会执行一次并被共享。

### ---------------------------------

好的，让我们详细解释其中涉及的公式，并对符号和公式的作用做具体说明。

### 公式 37.1a 到 37.1c: **值判断规则**

这些规则定义了按需动态语义中的值（$\text{val}$），通过以下三个公式表述：

#### 公式 37.1a:
$$
z \; \text{val}_\Sigma \tag{37.1a}
$$
**解释**: 这个公式表示常量 $z$ 是 $\Sigma$ 下的值（val），即它不需要进一步计算。$z$ 可以是任何常量类型的表达式，例如数字或者基本数据类型，它不依赖于符号 $\Sigma$ 中的其他表达式。

- **符号**: 
  - $z$: 一个常量，代表数字、布尔值或其他不可进一步化简的基本数据。
  - $\Sigma$: 当前环境，表示符号与其类型的映射关系，但此处 $z$ 不依赖于任何符号。
  
#### 公式 37.1b:
$$
s(a) \; \text{val}_\Sigma, a \sim \text{nat} \tag{37.1b}
$$
**解释**: 公式表示当符号 $a$ 代表自然数类型时，表达式 $s(a)$ 是 $\Sigma$ 下的值。符号 $a$ 被解析为某种自然数，而 $s(a)$ 代表对 $a$ 进行的某种操作，它也被视为一个值。

- **符号**:
  - $s(a)$: 代表由符号 $a$ 定义的某种操作或表达式。
  - $a$: 代表一个符号（symbol），此符号与自然数类型（$\text{nat}$）相关联。
  - $\sim$: 表示符号 $a$ 被推断为某种类型，这里是 $\text{nat}$，即自然数类型。
  - $\Sigma$: 当前符号上下文，包含符号 $a$ 及其类型映射。

#### 公式 37.1c:
$$
\lambda(x:\tau) e \; \text{val}_\Sigma \tag{37.1c}
$$
**解释**: 公式表示任何 $\lambda$ 抽象（函数表达式），即便它包含符号 $\Sigma$，也是一个值。$\lambda(x:\tau) e$ 表示一个从 $x$ 到 $e$ 的函数，其中 $x$ 的类型为 $\tau$。

- **符号**:
  - $\lambda(x:\tau) e$: $\lambda$ 抽象表达式，表示一个从 $x$ 映射到表达式 $e$ 的函数，其中 $x$ 的类型是 $\tau$。
  - $\Sigma$: 当前符号上下文，符号可能出现在 $e$ 中。

这些规则共同定义了如何判断一个表达式是否是一个值。常量、符号和 $\lambda$ 抽象都可以被认为是值。

---

### 公式 37.2a 和 37.2b: **初始状态与终止状态**

#### 公式 37.2a:
$$
\nu \emptyset \{ e \; k \; \emptyset \} \quad \text{initial} \tag{37.2a}
$$
**解释**: 这个公式定义了初始状态，即在一个空的记忆表 $\emptyset$ 下，表达式 $e$ 在上下文 $\nu$ 和空符号集 $\emptyset$ 中开始执行。$k$ 表示控制堆栈，用来追踪表达式的求值过程。

- **符号**:
  - $\nu$: 表示执行过程中的上下文。
  - $\emptyset$: 表示初始的符号和记忆表为空。
  - $e$: 待执行的表达式。
  - $k$: 控制堆栈，记录表达式执行的状态。

#### 公式 37.2b:
$$
e \; \text{val}_\Sigma \quad \nu \Sigma \{ e \; k \; \mu \} \quad \text{final} \tag{37.2b}
$$
**解释**: 终止状态定义了当表达式 $e$ 在符号集 $\Sigma$ 中是一个值时，整个求值过程达到终止。记忆表 $\mu$ 包含了所有符号的求值状态，而上下文 $\nu$ 保持不变。

- **符号**:
  - $e \; \text{val}_\Sigma$: 表示表达式 $e$ 已经是 $\Sigma$ 中的一个值，不需要进一步求值。
  - $\mu$: 当前的记忆表，记录了符号和它们的求值结果。
  - $\nu$: 上下文，保持整个求值的动态。

### 总结

这些公式定义了按需求值的基础结构。通过为延迟计算创建符号并使用记忆表共享结果，按需求值确保每个延迟的计算只执行一次并共享其结果，从而避免重复计算。

### ---------------------------------

### 详解 37.1 By-Need Dynamics （按需动态语义）

#### 概述

**按需评估**是一种延迟求值的策略。它通过 **记忆化** (memoization) 记录计算的结果，这样未来再次使用相同计算时，就可以直接返回之前的计算值，而不必重新计算。如果尚未计算，则从头开始执行。这种方法通过使用符号来表示推迟的计算，确保每个推迟计算的结果只被计算一次，并且结果在整个程序中共享。

在按需动态语义中，每个推迟计算都被分配一个 **符号**（symbol），这代表它尚未计算的状态。然后通过 **记忆表** (memo table) 记录每个符号的状态，如果计算已经完成，表中会存储该计算的结果。这样就实现了计算的共享，并避免了冗余的重复计算。

#### 记忆表与状态转换系统

在 L{nat *} 的按需动态语义中，使用一个转换系统来描述程序的执行状态。每个状态由如下形式表示：
$$
\nu \Sigma \{ e \, k \, \mu \}
$$

- **$\nu$**: 这是执行上下文，包含当前符号的活动状态。
- **$\Sigma$**: 是符号与类型的集合，形式为 $a_1 \sim \tau_1, a_2 \sim \tau_2, \dots, a_n \sim \tau_n$，每个符号都被关联到一个类型。
- **$e$**: 是当前正在评估的表达式，可能包含符号 $\Sigma$ 中的符号。
- **$k$**: 是控制堆栈，记录计算的进程。
- **$\mu$**: 是记忆表，记录符号的当前绑定状态。如果符号已经被评估，它就会被绑定到一个具体的值；如果尚未评估，它就会被绑定到一个特殊符号 **黑洞 (black hole)**，标记它处于计算过程中。

#### 按需动态的两种判断

1. **$e \, \text{val}_\Sigma$**: 表示表达式 $e$ 是一个值，并且可能包含符号 $\Sigma$ 中的符号。值是指那些不再需要进一步评估的表达式。
2. **$\nu \Sigma \{ e \, k \, \mu \} \longrightarrow \nu \Sigma' \{ e' \, k \, \mu' \}$**: 表示在符号 $\Sigma$ 和记忆表 $\mu$ 的上下文中，表达式 $e$ 经一步求值后，变为 $e'$，同时符号集变为 $\Sigma'$，记忆表更新为 $\mu'$。

#### 动态语义规则

按需动态的定义确保符号集合 $\Sigma$ 是单调增长的，并且符号的类型在整个执行过程中不会改变。通过记忆表 $\mu$，我们可以在执行过程中逐步更新符号的状态。

#### 公式推导

1. **值判断规则 (Value Judgments)**

   这些规则定义了如何判断一个表达式是否是一个值：
   
   - 公式 37.1a:  
     $$
     z \, \text{val}_\Sigma \tag{37.1a}
     $$
     **解释**: 这是最简单的情况，$z$ 是一个常量值，通常是自然数、布尔值等基本类型。它在上下文 $\Sigma$ 中已经是一个值，无需进一步评估。

   - 公式 37.1b:  
     $$
     s(a) \, \text{val}_\Sigma, a \sim \text{nat} \tag{37.1b}
     $$
     **解释**: 如果符号 $a$ 关联到自然数类型 $nat$，那么表达式 $s(a)$ 也是 $\Sigma$ 中的值。这意味着 $a$ 是一个符号，表示某个尚未评估的自然数，$s(a)$ 是对这个符号的操作。

   - 公式 37.1c:  
     $$
     \lambda(x:\tau) e \, \text{val}_\Sigma \tag{37.1c}
     $$
     **解释**: 一个 $\lambda$ 抽象（函数）是一个值，即使它包含符号 $\Sigma$。函数 $\lambda(x:\tau) e$ 表示从 $x$ 到 $e$ 的映射，其中 $x$ 的类型为 $\tau$。这种抽象本身是一个值，不需要进一步求值。

2. **初始状态与终止状态 (Initial and Final States)**

   - 公式 37.2a:  
     $$
     \nu \emptyset \{ e \, k \, \emptyset \} \quad \text{initial} \tag{37.2a}
     $$
     **解释**: 这个公式定义了初始状态，表示在一个空的记忆表 $\emptyset$ 下，表达式 $e$ 开始在上下文 $\nu$ 中执行，堆栈 $k$ 也是初始状态。

   - 公式 37.2b:  
     $$
     e \, \text{val}_\Sigma \quad \nu \Sigma \{ e \, k \, \mu \} \quad \text{final} \tag{37.2b}
     $$
     **解释**: 终止状态定义了当表达式 $e$ 在符号上下文 $\Sigma$ 下成为一个值时，计算过程结束。记忆表 $\mu$ 包含符号的最终值，并且上下文 $\nu$ 保持不变。

### 共享与黑洞 (Sharing and Black Holes)

在按需评估过程中，如果某个符号正在被评估，它会被绑定到一个特殊符号 **黑洞 (•)**。黑洞的作用是防止递归计算中的无限循环。当一个符号被标记为黑洞时，它表示该符号正在评估中，如果在评估过程中再次访问这个符号，则意味着递归循环错误。这一机制保证了共享与惰性计算的正确性。

### 总结

按需动态语义通过 **符号化** 延迟计算和 **记忆化** 确保每个符号的计算只进行一次，并在后续所有访问中共享这个计算结果。通过这种方式，按需评估避免了不必要的冗余计算，提高了程序的效率。

### ---------------------------------

**详解 37.1 按需动态语义 (By-Need Dynamics)**

在编程语言中，按需求值（Lazy Evaluation）是一种常见的优化策略，旨在推迟对表达式的求值，直到它的值确实被需要。并且，当该表达式首次求值后，所有对该表达式的后续调用都将共享这个结果，避免冗余计算。

在 L{nat *} 语言的按需求值中，通过记忆化（memoization）来记录计算的结果，并使用符号命名延迟计算以共享其结果。具体而言，这种动态语义通过引入符号表和记忆表来跟踪这些推迟的计算。以下我们对每个公式和规则进行详细解释。

### 按需动态的核心思想

按需动态语义的核心思想是引入符号（symbols）来表示延迟的计算，并使用记忆表来记录每个符号的值或其尚未计算的状态。我们通过符号命名每个延迟计算，并且每当再次使用相同的计算时，直接返回之前的计算结果。

**记忆表（Memo Table）**：记忆表 $\mu$ 记录了每个符号的当前状态。符号可以被映射到未计算的表达式，也可以映射到一个特殊符号 **黑洞 (•)**，这表示该符号当前正处于评估过程中。如果遇到递归，黑洞可以防止无限递归导致的计算爆炸。

### 状态的形式

每个状态的形式为：
$$
\nu \Sigma \{ e \, k \, \mu \}
$$

- **$\nu$**：上下文或执行环境。
- **$\Sigma$**：符号和类型的集合，形式为 $a_1 \sim \tau_1, a_2 \sim \tau_2, \dots, a_n \sim \tau_n$。
- **$e$**：正在求值的表达式。
- **$k$**：控制堆栈。
- **$\mu$**：记忆表，跟踪符号的当前绑定状态。

### 动态规则的详解

按需动态语义通过一组推导规则（transition rules）来定义计算过程。我们逐步解释这些规则的意义及其作用。

#### 1. **规则 37.3a：符号初次求值**

$$
\nu \Sigma, a \sim \tau \{ a \, k \, \mu \otimes a \rightarrow e \} \longrightarrow \nu \Sigma, a \sim \tau \{ e \, k \, \mu \otimes a \rightarrow e \}
$$

**解释**：当我们遇到符号 $a$ 时，如果记忆表 $\mu$ 中记录了它与某个未求值的表达式 $e$ 相关联，则进行一次求值，并将 $a$ 替换为 $e$。该规则的目的是为了处理符号初次被求值的情况。

#### 2. **规则 37.3b：符号求值中断**

$$
\nu \Sigma, a \sim \tau \{ e \, k \, \mu \otimes a \rightarrow • \} \longrightarrow \nu \Sigma' , a \sim \tau \{ e' \, k \, \mu' \otimes a \rightarrow • \}
$$

**解释**：这里处理的是符号 $a$ 目前被标记为 **黑洞 (•)** 的情况，表示 $a$ 正在被评估。如果在求值过程中遇到这种情况，$a$ 的状态暂时被冻结（不进行进一步求值），并将新的状态 $e'$ 和更新的记忆表 $\mu'$ 传递下去。

#### 3. **规则 37.3c：延迟计算符号**

$$
\nu \Sigma \{ s(e) \, k \, \mu \} \longrightarrow \nu \Sigma, a \sim \text{nat} \{ s(a) \, k \, \mu \otimes a \rightarrow e \}
$$

**解释**：此规则处理延迟计算的符号 $s(e)$，其中 $e$ 是一个表达式。$s(e)$ 代表着延迟计算的过程，符号 $a$ 是与 $e$ 关联的延迟计算。通过这一步，将表达式 $s(a)$ 推迟到符号 $a$ 进行求值。

#### 4. **规则 37.3d: ifz 条件语句**

$$
\nu \Sigma \{ \text{ifz} \, e \, \{z \Rightarrow e_0 \mid s(x) \Rightarrow e_1\} \, k \, \mu \} \longrightarrow \nu \Sigma' \{ \text{ifz} \, e' \{z \Rightarrow e_0 \mid s(x) \Rightarrow e_1\} \, k \, \mu' \}
$$

**解释**：这是对 `ifz` 语句的延迟求值，其中 $e$ 是判断条件。如果 $e$ 尚未求值，先对 $e$ 进行求值，并将结果替换为新的表达式。

#### 5. **规则 37.3e: ifz 值为零的情况**

$$
\nu \Sigma \{ \text{ifz} \, z \{z \Rightarrow e_0 \mid s(x) \Rightarrow e_1\} \, k \, \mu \} \longrightarrow \nu \Sigma \{ e_0 \, k \, \mu \}
$$

**解释**：在 `ifz` 条件语句中，如果判断条件 $e$ 是零，那么直接跳转到分支 $e_0$，并将该分支作为当前的计算结果。

#### 6. **规则 37.3f: ifz 值为非零的情况**

$$
\nu \Sigma, a \sim \text{nat} \{ \text{ifz} \, s(a) \{z \Rightarrow e_0 \mid s(x) \Rightarrow e_1\} \, k \, \mu \otimes a \rightarrow e \} \longrightarrow \nu \Sigma, a \sim \text{nat} \{ [a/x]e_1 \, k \, \mu \otimes a \rightarrow e \}
$$

**解释**：在 `ifz` 条件语句中，如果判断条件 $e$ 是非零值 $s(a)$，则跳转到分支 $e_1$，并将 $a$ 绑定到 $x$ 上，将 $e_1$ 替换为新表达式。

#### 7. **规则 37.3g：函数调用**

$$
\nu \Sigma \{ e_1 \, k \, \mu \} \longrightarrow \nu \Sigma' \{ e_0 \, k \, \mu' \}
$$

$$
\nu \Sigma \{ e_1(e_2) \, k \, \mu \} \longrightarrow \nu \Sigma' \{ e_0(e_2) \, k \, \mu' \}
$$

**解释**：此规则处理函数调用，首先对函数表达式 $e_1$ 进行求值，然后对函数的参数 $e_2$ 进行延迟求值，直到得到具体值后再继续计算。

#### 8. **规则 37.3h：应用 $\lambda$ 抽象**

$$
\nu \Sigma \{ \lambda (x: \tau) e(e_2) \, k \, \mu \} \longrightarrow \nu \Sigma, a \sim \tau \{ [a/x]e \, k \, \mu \otimes a \rightarrow e_2 \}
$$

**解释**：当我们应用一个 $\lambda$ 表达式时，参数 $e_2$ 会替换到 $\lambda$ 抽象中对应的位置，并使用符号 $a$ 进行延迟计算。

#### 9. **规则 37.3i：修复点求值**

$$
\nu \Sigma \{ \text{fix} \, x: \tau \, \text{is} \, e \, k \, \mu \} \longrightarrow \nu \Sigma, a \sim \tau \{ a \, k \, \mu \otimes a \rightarrow [a/x]e \}
$$

**解释**：这是修复点（fixpoint）的延迟求值规则。修复点 $x$ 会绑定到符号 $a$ 上，并将表达式 $[a/x]e$ 延迟求值，避免递归求值中的无限展开。

### 总结

按需动态语义中的这些规则确保符号和记忆表的正确更新，并实现了惰性求值中的共享机制。通过符号化延迟计算和记忆化技术，计算结果可以在后续的使用中共享，避免了重复计算。这种方法特别适合函数式编程

语言中的惰性求值机制，有助于提高程序的效率。

### ---------------------------------

### 详解 37.1 按需动态规则 (By-Need Dynamics)

在编程语言中的按需求值是一个通过延迟计算提升程序效率的技术。按需动态通过记忆化（memoization）来记录表达式的求值结果，确保同一个表达式在不同的地方只被求值一次，避免重复计算。以下我们对各个规则进行详细的讲解，帮助更好地理解按需动态的机制。

#### 1. **规则 (37.3a)：符号关联的表达式为值**
$$
e \ val_\Sigma, a \sim \tau \\
\nu \ \Sigma, a \sim \tau \ \{ a \ k \ \mu \otimes a \rightarrow e \} \longrightarrow \nu \ \Sigma, a \sim \tau \ \{ e \ k \ \mu \otimes a \rightarrow e \}
$$

**解释**：该规则处理的是符号 $a$ 对应的表达式已经被求值的情况。此时，符号 $a$ 在记忆表 $\mu$ 中已经与一个值 $e$ 关联，直接返回该值 $e$ 作为计算结果。该规则是整个按需求值机制中的基础，它确保了记忆表中的符号能被正确地求值并返回其关联的值。

#### 2. **规则 (37.3b)：符号关联的表达式尚未求值**
$$
\nu \ \Sigma, a \sim \tau \ \{ e \ k \ \mu \otimes a \rightarrow \bullet \} \longrightarrow \nu \ \Sigma', a \sim \tau \ \{ e' \ k \ \mu' \otimes a \rightarrow \bullet \}
$$

**解释**：如果符号 $a$ 关联的表达式 $e$ 尚未被求值，那么我们将暂时把符号 $a$ 的值设置为 **黑洞 (•)**，表示这个符号当前正在求值，避免递归依赖。这个黑洞机制防止了无限递归的发生。如果在求值过程中，符号 $a$ 再次被访问，它将无法推进，从而检测到这种循环依赖。最终，如果表达式 $e$ 被成功求值，记忆表将会更新其对应的值。

#### 3. **规则 (37.3c)：延迟计算的符号**

$$
\nu \ \Sigma \ \{ s(e) \ k \ \mu \} \longrightarrow \nu \ \Sigma, a \sim \text{nat} \ \{ s(a) \ k \ \mu \otimes a \rightarrow e \}
$$

**解释**：该规则处理 `s(e)` 的求值。表达式 $s(e)$ 是一个带有延迟计算的符号，当我们遇到这样的表达式时，首先为表达式 $e$ 分配一个新的符号 $a$，并将 $s(a)$ 作为结果返回。这个过程实际上将对表达式 $e$ 的求值推迟，直到它的结果在后续的计算中真正需要时才进行求值。这种机制保证了 `s(e)` 的延迟计算是惰性的。

#### 4. **规则 (37.3d)：`ifz` 条件判断**

$$
\nu \ \Sigma \ \{ \text{ifz} \ e \ \{z \Rightarrow e_0 \mid s(x) \Rightarrow e_1 \} \ k \ \mu \} \longrightarrow \nu \ \Sigma' \ \{ \text{ifz} \ e' \ \{z \Rightarrow e_0 \mid s(x) \Rightarrow e_1 \} \ k \ \mu' \}
$$

**解释**：当我们遇到 `ifz` 条件语句时，首先对条件表达式 $e$ 进行求值。如果 $e$ 尚未被求值，则它被递归地求值，直到得到一个具体的结果。这一规则确保条件语句中的判断条件被正确求值，从而决定接下来执行哪个分支。

#### 5. **规则 (37.3e)：`ifz` 值为零的情况**

$$
\nu \ \Sigma \ \{ \text{ifz} \ z \ \{z \Rightarrow e_0 \mid s(x) \Rightarrow e_1 \} \ k \ \mu \} \longrightarrow \nu \ \Sigma \ \{ e_0 \ k \ \mu \}
$$

**解释**：在 `ifz` 条件语句中，如果判断条件是零，则直接执行 $e_0$ 分支。这个规则确保了在判断条件为零时，计算直接跳转到对应的分支。

#### 6. **规则 (37.3f)：`ifz` 值为非零的情况**

$$
\nu \ \Sigma, a \sim \text{nat} \ \{ \text{ifz} \ s(a) \ \{z \Rightarrow e_0 \mid s(x) \Rightarrow e_1 \} \ k \ \mu \otimes a \rightarrow e \} \longrightarrow \nu \ \Sigma, a \sim \text{nat} \ \{ [a/x] e_1 \ k \ \mu \otimes a \rightarrow e \}
$$

**解释**：如果 `ifz` 条件语句的判断条件是非零值（即 $s(a)$），那么跳转到 $e_1$ 分支，并且将符号 $a$ 替换为变量 $x$。这个规则确保在条件为非零时，正确地执行非零分支的逻辑。

#### 7. **规则 (37.3g)：函数调用**

$$
\nu \ \Sigma \ \{ e_1 \ k \ \mu \} \longrightarrow \nu \ \Sigma' \ \{ e_0 \ k \ \mu' \}
$$

$$
\nu \ \Sigma \ \{ e_1(e_2) \ k \ \mu \} \longrightarrow \nu \ \Sigma' \ \{ e_0(e_2) \ k \ \mu' \}
$$

**解释**：这是函数调用的求值规则。首先，对函数表达式 $e_1$ 进行求值。然后在函数求值完成后，再对参数 $e_2$ 进行延迟求值，直到需要它的具体值。该规则确保函数应用中的参数和函数主体被正确求值。

#### 8. **规则 (37.3h)：应用 $\lambda$ 抽象**

$$
\nu \ \Sigma \ \{ \lambda (x: \tau) e(e_2) \ k \ \mu \} \longrightarrow \nu \ \Sigma, a \sim \tau \ \{ [a/x] e \ k \ \mu \otimes a \rightarrow e_2 \}
$$

**解释**：当应用一个 $\lambda$ 抽象（即一个匿名函数）时，首先为参数 $e_2$ 分配一个新的符号 $a$，然后将这个符号替换为 $\lambda$ 表达式的参数。接着，该参数只有在需要时才会被求值，并且该值在函数体内所有地方共享。

#### 9. **规则 (37.3i)：修复点求值**

$$
\nu \ \Sigma \ \{ \text{fix} \ x: \tau \ \text{is} \ e \ k \ \mu \} \longrightarrow \nu \ \Sigma, a \sim \tau \ \{ a \ k \ \mu \otimes a \rightarrow [a/x] e \}
$$

**解释**：修复点（`fix`）表示递归求值。通过该规则，一个表达式 `fix x: τ is e` 实际上解决了递归方程 $x = e$。修复点的求值通过为 $e$ 分配一个新的符号 $a$，并将符号 $a$ 代入到 $x$ 的位置，从而允许表达式自引用。该机制支持递归函数的延迟求值。

### 总结

按需动态语义通过延迟计算符号的绑定和记忆表来实现共享计算结果的机制。这些规则为递归、条件判断和函数调用等编程语言中的基本概念提供了按需求值的框架。通过这些规则，我们能够高效地管理惰性求值，避免重复计算，提升程序的效率。

### ---------------------------------

### 详解 37.2 安全性 (Safety)

这一节讨论了按需求值的安全性问题。按需求值的计算在动态运行时会引入记忆化表（memoization table），并处理符号绑定（symbols）的问题。为了确保按需计算的正确性和安全性，定义了一些推导规则来验证计算状态的合法性。

### 类型推导规则 (Typing Judgment)

首先，我们有类型推导规则，表示表达式 $e$ 在环境 $\Gamma$ 和符号表 $\Sigma$ 下具有类型 $\tau$：

$$
\Gamma \vdash_{\Sigma} e : \tau
$$

这里的 $\Gamma$ 是类型环境，它为变量分配类型，$\Sigma$ 则为符号表，表示符号 $a_1 \sim \tau_1, a_2 \sim \tau_2, \dots, a_n \sim \tau_n$。这些符号是未求值的表达式，类型推导规则如下：

#### 1. **符号的推导规则 (Rule 37.4)**
$$
\Gamma \vdash_{\Sigma, a \sim \tau} a : \tau
$$

**解释**：当符号 $a$ 被声明为类型 $\tau$ 时，我们可以将其视为类型 $\tau$ 的表达式。这就相当于隐式地将符号 $a$ 转换为与它绑定的表达式类型。

#### 2. **状态合法性判断 (State Well-Formedness Judgment)**

接下来，我们定义判断一个计算状态的合法性的推导规则：

$$
\nu \Sigma \{ e \ k \ \mu \} \ \text{ok}
$$

这一推导意味着表达式 $e$ 在符号表 $\Sigma$ 和记忆表 $\mu$ 下是合法的。符号表 $\Sigma$ 包含了符号及其关联的类型，记忆表 $\mu$ 记录了符号到具体表达式或 **黑洞 (•)** 的映射。

合法性判断有以下两个规则：

#### 3. **规则 (Rule 37.5a)：状态合法性**
$$
\vdash_{\Sigma} e : \tau \quad \vdash_{\Sigma} \mu : \Sigma \\
\nu \Sigma \{ e \ k \ \mu \} \ \text{ok}
$$

**解释**：该规则表明，如果表达式 $e$ 具有类型 $\tau$ 且记忆表 $\mu$ 对应的符号表 $\Sigma$ 是合法的，则整个状态 $\nu \Sigma \{ e \ k \ \mu \}$ 是合法的。

#### 4. **规则 (Rule 37.5b)：记忆表中的自引用**
$$
\forall a \sim \tau \in \Sigma, \quad \mu(a) = e \neq • \Rightarrow \vdash_{\Sigma'} e : \tau \\
\vdash_{\Sigma'} \mu : \Sigma
$$

**解释**：该规则允许符号在记忆表中自引用。也就是说，符号 $a$ 关联的表达式可以包含 $a$，甚至是一个包含 $a$ 的其他符号。这种依赖关系可以是有限的链式依赖。此外，如果符号绑定的是 **黑洞 (•)**，则该符号可以被视为任意类型。

### 保持性定理 (Preservation Theorem)

保持性定理表明，在按需求值的过程中，如果一个状态是合法的，那么经过一步计算后得到的新状态也是合法的。

#### 5. **保持性定理 (Theorem 37.1)**
$$
\text{如果 } \nu \Sigma \{ e \ k \ \mu \} \to \nu \Sigma' \{ e' \ k \ \mu' \} \text{ 且 } \nu \Sigma \{ e \ k \ \mu \} \text{ 是合法的，那么 } \nu \Sigma' \{ e' \ k \ \mu' \} \text{ 也是合法的。}
$$

**证明概述**：我们通过对规则 (37.3) 的归纳来证明这个定理。如果 $\nu \Sigma \{ e \ k \ \mu \} \to \nu \Sigma' \{ e' \ k \ \mu' \}$ 且 $\vdash_{\Sigma} \mu : \Sigma$ 且 $\vdash_{\Sigma} e : \tau$，则新的符号表 $\Sigma'$ 是 $\Sigma$ 的扩展，并且新状态中的表达式 $e'$ 和记忆表 $\mu'$ 也是合法的。

#### 6. **证明规则 (37.3b)**

$$
e = e' = a, \quad \mu = \mu' \otimes a \mapsto e_0, \quad \mu' = \mu'_0 \otimes a \mapsto e'_0
$$

$$
\nu \Sigma, a \sim \tau \{ e_0 \ k \ \mu_0 \otimes a \mapsto • \} \to \nu \Sigma' , a \sim \tau \{ e'_0 \ k \ \mu'_0 \otimes a \mapsto • \}
$$

**解释**：在这一规则中，符号 $a$ 被绑定到了表达式 $e_0$，并且记忆表中 $a$ 的值暂时被设置为黑洞。在计算的下一步中，$e_0$ 被求值并得到 $e'_0$，更新了记忆表中的 $a$。归纳假设告诉我们，这种更新不会破坏状态的合法性。

### 总结

通过这些规则和定理，37.2 节详细解释了按需求值中的安全性问题。符号和记忆表的使用确保了计算的安全性，防止了无限递归或自引用问题。保持性定理则证明了，按需求值过程中的状态合法性在每一步计算后仍然得以保持，确保程序的正确执行。

### ---------------------------------

### 定理 37.1：保持性定理 (Preservation Theorem)

**定理 37.1 (保持性)**：
假设 $\nu \Sigma \{ e \ k \ \mu \} \to \nu \Sigma_0 \{ e_0 \ k \ \mu_0 \}$，且 $\nu \Sigma \{ e \ k \ \mu \}$ 是合法的，那么 $\nu \Sigma_0 \{ e_0 \ k \ \mu_0 \}$ 也是合法的。

**证明思路**：
我们通过对规则 (37.3) 的归纳来证明这一点。假设 $\nu \Sigma \{ e \ k \ \mu \} \to \nu \Sigma_0 \{ e_0 \ k \ \mu_0 \}$ 且 $\vdash_{\Sigma} \mu : \Sigma$ 和 $\vdash_{\Sigma} e : \tau$，我们需要证明 $\Sigma_0 \supseteq \Sigma$ 且 $\vdash_{\Sigma_0} \mu_0 : \Sigma_0$ 以及 $\vdash_{\Sigma_0} e_0 : \tau$。

接下来，我们对几个主要规则进行详细分析。

#### **规则 (37.3b) 的证明**：
考虑规则 (37.3b)，假设 $e = e_0 = a$，即符号 $a$ 的求值。记忆表 $\mu = \mu_0 \otimes a \mapsto e_0$，表示 $a$ 绑定了表达式 $e_0$，且 $\mu_0 = \mu'_0 \otimes a \mapsto e'_0$，表示在更新后 $a$ 绑定了新的表达式 $e'_0$。

我们知道：
$$
\nu \Sigma, a \sim \tau \{ e_0 \ k \ \mu_0 \otimes a \mapsto • \} \to \nu \Sigma_0, a \sim \tau \{ e'_0 \ k \ \mu'_0 \otimes a \mapsto • \}
$$

假设 $\vdash_{\Sigma, a \sim \tau} \mu : \Sigma, a \sim \tau$。这意味着 $\vdash_{\Sigma, a \sim \tau} e_0 : \tau$，且 $\vdash_{\Sigma, a \sim \tau} \mu_0 : \Sigma$。因此我们有：
$$
\vdash_{\Sigma, a \sim \tau} \mu_0 \otimes a \mapsto • : \Sigma, a \sim \tau
$$

根据归纳假设，得到 $\Sigma_0 \supseteq \Sigma$，且 $\vdash_{\Sigma_0, a \sim \tau} e'_0 : \tau'$，同时有：
$$
\vdash_{\Sigma_0, a \sim \tau} \mu'_0 \otimes a \mapsto • : \Sigma, a \sim \tau
$$

因此我们可以推出：
$$
\vdash_{\Sigma_0, a \sim \tau} \mu'_0 : \Sigma_0, a \sim \tau
$$

这足以证明结果。

#### **规则 (37.3g) 的证明**：
现在我们分析规则 (37.3g)，此时表达式 $e$ 是函数应用 $e_1(e_2)$，且：
$$
\nu \Sigma \{ e_1 \ k \ \mu \} \to \nu \Sigma_0 \{ e'_1 \ k \ \mu_0 \}
$$

假设 $\vdash_{\Sigma} \mu : \Sigma$ 且 $\vdash_{\Sigma} e : \tau$。通过类型反演，我们可以得到 $\vdash_{\Sigma} e_1 : \tau_2 \to \tau$，且 $\vdash_{\Sigma} e_2 : \tau_2$。根据归纳假设，得到 $\Sigma_0 \supseteq \Sigma$，且 $\vdash_{\Sigma_0} \mu_0 : \Sigma_0$，同时有 $\vdash_{\Sigma_0} e'_1 : \tau_2 \to \tau$。通过弱化规则，我们进一步得到 $\vdash_{\Sigma_0} e_2 : \tau_2$，因此可以推出 $\vdash_{\Sigma_0} e'_1(e_2) : \tau$，这足以证明结果。

#### **关于递归求值的特殊情况 (Black Hole)**：
定理的进展部分允许可能遇到黑洞，这代表了一种可检测的非终止形式。我们通过引入“loop”判断来处理黑洞情况。表达式 $e$ 若遇到黑洞则会进入“循环”状态（即发散）。

例如，以下规则定义了遇到黑洞的情形：
- 如果符号 $a$ 绑定的是黑洞 $•$，则 $a$ 的求值会进入循环状态。
- 如果表达式 $e$ 在符号表 $\Sigma$ 和记忆表 $\mu$ 下发散，则对 $e$ 的进一步求值也会发散。

#### **定理 37.2 (进展定理)**：
进展定理表明，若 $\nu \Sigma \{ e \ k \ \mu \}$ 是合法状态，则它要么是最终状态，要么进入循环状态（遇到黑洞），要么可以进行一步计算得到新的状态。

**证明**：
通过对 $\vdash_{\Sigma} e : \tau$ 和 $\vdash_{\Sigma} \mu : \Sigma$ 的推导进行归纳。考虑规则 (10.1a)，符号 $a$ 被声明在符号表 $\Sigma$ 中，因此 $\Sigma = \Sigma_0, a \sim \tau$ 且 $\vdash_{\Sigma} \mu : \Sigma$。记忆表 $\mu = \mu_0 \otimes a \mapsto e_0$，其中 $\vdash_{\Sigma} \mu_0 : \Sigma_0$，且 $\vdash_{\Sigma} e_0 : \tau$。根据这些条件，继续分析不同的情况：

1. **情况 1**：$\nu \Sigma \{ e_0 \ k \ \mu \otimes a \mapsto • \}$ 是最终状态。通过规则 (37.2b) 的反演，我们知道 $e_0$ 是一个值 $val_\Sigma$，因此根据规则 (37.3a) 可以推导 $\nu \Sigma \{ a \ k \ \mu \} \to \nu \Sigma \{ e_0 \ k \ \mu \}$。

2. **情况 2**：$\nu \Sigma \{ e_0 \ k \ \mu_0 \otimes a \mapsto • \}$ 进入循环。通过应用规则 (37.6b)，我们可以推出 $\nu \Sigma \{ a \ k \ \mu \}$ 进入循环状态。

3. **情况 3**：$\nu \Sigma \{ e_0 \ k \ \mu_0 \otimes a \mapsto • \} \to \nu \Sigma_0 \{ e'_0 \ k \ \mu'_0 \otimes a \mapsto • \}$。通过应用规则 (37.3b)，可以推出：
$$
\nu \Sigma \{ a \ k \ \mu \otimes a \mapsto e_0 \} \to \nu \Sigma_0 \{ a \ k \ \mu'_0 \otimes a \mapsto e'_0 \}
$$

这些分析足以证明进展定理的正确性。

### 总结

通过对不同规则的分析和归纳，我们证明了按需求值系统中的状态保持性和进展性。这些定理保证了按需计算过程中，系统可以保持其状态的合法性，避免无限递归和自引用问题，同时确保计算可以前进至终态或遇到可检测的非终止情况（如黑洞）。

### ---------------------------------

### 定理 37.2 (进展定理)

**定理 37.2 (Progress Theorem)**：
如果 $\nu \Sigma \{ e \ k \ \mu \}$ 是合法的状态 ($\text{ok}$)，则要么 $\nu \Sigma \{ e \ k \ \mu \}$ 是终态 (final)，要么 $\nu \Sigma \{ e \ k \ \mu \}$ 进入循环 (loops)，否则存在 $\mu_0$ 和 $e_0$ 使得 $\nu \Sigma \{ e \ k \ \mu \} \to \nu \Sigma_0 \{ e_0 \ k \ \mu_0 \}$。

### **证明**：
我们通过对 $\vdash_{\Sigma} e : \tau$ 和 $\vdash_{\Sigma} \mu : \Sigma$ 的推导进行归纳。在证明过程中，我们要分析不同情况下的推导规则，来确认系统的进展性。归纳的主要规则和推导步骤如下。

#### **规则分析 (10.1a)**：
考虑规则 (10.1a)，其中变量 $a$ 被声明在符号表 $\Sigma$ 中。因此 $\Sigma = \Sigma_0, a \sim \tau$ 且 $\vdash_{\Sigma} \mu : \Sigma$。这意味着记忆表 $\mu$ 可以表示为 $\mu = \mu_0 \otimes a \mapsto e_0$，其中 $\vdash_{\Sigma} \mu_0 : \Sigma_0$，且 $\vdash_{\Sigma} e_0 : \tau$。根据这些条件，接下来分析不同的情况：

#### **情况 1：$e_0$ 是终态 (final)**

如果 $\nu \Sigma \{ e_0 \ k \ \mu \otimes a \mapsto • \}$ 是终态，根据规则 (37.2b) 的反演，我们知道 $e_0$ 是值，即 $e_0 \ \text{val}_\Sigma$。因此根据规则 (37.3a)，我们可以推导出：
$$
\nu \Sigma \{ a \ k \ \mu \} \to \nu \Sigma \{ e_0 \ k \ \mu \}
$$
即符号 $a$ 对应的表达式 $e_0$ 被成功求值，系统可以继续前进。

#### **情况 2：$e_0$ 进入循环 (loops)**

如果 $\nu \Sigma \{ e_0 \ k \ \mu_0 \otimes a \mapsto • \}$ 进入循环，通过应用规则 (37.6b)，我们可以推出：
$$
\nu \Sigma \{ a \ k \ \mu \} \ \text{loops}
$$
这表示在符号 $a$ 被绑定到黑洞 ($•$) 的情况下，系统会进入循环状态。这种情况代表了一种可检测的非终止状态。

#### **情况 3：$e_0$ 继续求值**

如果 $\nu \Sigma \{ e_0 \ k \ \mu_0 \otimes a \mapsto • \} \to \nu \Sigma_0 \{ e'_0 \ k \ \mu'_0 \otimes a \mapsto • \}$，则根据规则 (37.3b) 的应用，我们可以推出：
$$
\nu \Sigma \{ a \ k \ \mu \otimes a \mapsto e_0 \} \to \nu \Sigma_0 \{ a \ k \ \mu'_0 \otimes a \mapsto e'_0 \}
$$
这表示符号 $a$ 绑定的表达式 $e_0$ 正在被逐步求值，系统可以继续前进。

### **黑洞 (Black Hole) 的处理**

进展定理中的关键一部分是处理黑洞。黑洞是一种符号暂时没有值的标记，避免出现无限递归或自引用问题。以下是遇到黑洞的几种情况的推导规则：

- **规则 (37.6a)**：如果符号 $a$ 绑定的是黑洞，则求值该符号会进入循环：
  $$
  \nu \Sigma, a \sim \tau \{ a \ k \ \mu \otimes a \mapsto • \} \ \text{loops}
  $$
- **规则 (37.6b)**：如果符号 $a$ 绑定的表达式 $e$ 也遇到黑洞，则对 $e$ 的进一步求值会进入循环：
  $$
  \nu \Sigma, a \sim \tau \{ e \ k \ \mu \otimes a \mapsto • \} \ \text{loops}
  $$

### **规则 (37.6c)**：条件分支中的循环

如果我们遇到条件表达式，例如 $ifz$，并且条件表达式的求值进入循环，那么整个表达式的求值也会进入循环。这意味着当表达式 $e$ 遇到黑洞时，分支表达式中的进一步求值会进入循环。

### **规则 (37.6d)**：函数应用中的循环

在函数应用的情况下，如果函数或参数的求值进入循环，则整个应用表达式的求值也会进入循环。例如：
$$
\nu \Sigma \{ e_1 \ k \ \mu \} \ \text{loops}
\implies \nu \Sigma \{ e_1(e_2) \ k \ \mu \} \ \text{loops}
$$
这说明如果函数位置的表达式 $e_1$ 遇到黑洞，则整个应用表达式也无法正常进行，进入循环状态。

### **总结**

通过上述规则和情况分析，定理 37.2 的进展性证明了系统中的每一步计算要么会成功完成，要么会进入循环状态，或者可以进行进一步的计算。黑洞的引入避免了无限递归问题，并为系统提供了一种处理自引用和非终止情况的机制。

### ---------------------------------

### 定理 37.2 (进展定理)

**定理 (Progress Theorem)**：
如果 $\nu \Sigma \{ e \ k \ \mu \}$ 是合法的状态，即满足 $\text{ok}$ 判断，那么有以下几种可能：
1. $\nu \Sigma \{ e \ k \ \mu \}$ 是终态 (final)。
2. $\nu \Sigma \{ e \ k \ \mu \}$ 进入循环 (loops)。
3. 存在新的 $\mu_0$ 和 $e_0$ 使得 $\nu \Sigma \{ e \ k \ \mu \} \rightarrow \nu \Sigma_0 \{ e_0 \ k \ \mu_0 \}$，即系统可以进一步演化。

### **证明**：

证明的过程使用对 $\vdash_\Sigma e : \tau$ 和 $\vdash_\Sigma \mu : \Sigma$ 的推导进行归纳。我们需要分析不同情况下的推导规则，并逐步确认系统的进展性。

#### **规则 (10.1a)**：
我们首先考虑规则 (10.1a)，其中变量 $a$ 被声明在符号表 $\Sigma$ 中。即 $\Sigma = \Sigma_0, a \sim \tau$ 且 $\vdash_\Sigma \mu : \Sigma$。此时，记忆表 $\mu$ 可以表示为：
$$
\mu = \mu_0 \otimes a \mapsto e_0
$$
其中，$\vdash_\Sigma \mu_0 : \Sigma_0$ 且 $\vdash_\Sigma e_0 : \tau$。基于这些前提，我们可以对接下来的几种情况进行分析。

#### **情况 1：$e_0$ 是终态 (final)**

如果 $\nu \Sigma \{ e_0 \ k \ \mu \otimes a \mapsto • \}$ 是终态，根据规则 (37.2b) 的反演可知 $e_0$ 是一个值，即 $e_0 \ \text{val}_\Sigma$。此时可以根据规则 (37.3a) 推导出：
$$
\nu \Sigma \{ a \ k \ \mu \} \rightarrow \nu \Sigma \{ e_0 \ k \ \mu \}
$$
即符号 $a$ 绑定的表达式 $e_0$ 被成功求值，系统可以继续前进。

#### **情况 2：$e_0$ 进入循环 (loops)**

如果 $\nu \Sigma \{ e_0 \ k \ \mu_0 \otimes a \mapsto • \}$ 进入循环，那么根据规则 (37.6b)，可以得到：
$$
\nu \Sigma \{ a \ k \ \mu \} \ \text{loops}
$$
这表示符号 $a$ 绑定的表达式中存在黑洞 ($•$)，从而导致系统进入不可终止的循环状态。

#### **情况 3：$e_0$ 继续求值**

如果 $\nu \Sigma \{ e_0 \ k \ \mu_0 \otimes a \mapsto • \} \rightarrow \nu \Sigma_0 \{ e'_0 \ k \ \mu'_0 \otimes a \mapsto • \}$，我们可以应用规则 (37.3b)，得到：
$$
\nu \Sigma \{ a \ k \ \mu \otimes a \mapsto e_0 \} \rightarrow \nu \Sigma_0 \{ a \ k \ \mu'_0 \otimes a \mapsto e'_0 \}
$$
这表明符号 $a$ 绑定的表达式 $e_0$ 正在逐步求值，系统可以进一步演化。

### **黑洞的处理**

在进展定理中，关键的一部分是处理黑洞的情形。黑洞作为标记符号，代表符号暂时没有值，从而避免无限递归和自引用问题。以下是遇到黑洞时的一些推导规则：

- **规则 (37.6a)**：如果符号 $a$ 绑定的是黑洞，则求值该符号会导致系统进入循环：
  $$
  \nu \Sigma, a \sim \tau \{ a \ k \ \mu \otimes a \mapsto • \} \ \text{loops}
  $$

- **规则 (37.6b)**：如果符号 $a$ 绑定的表达式 $e$ 也包含黑洞，则对 $e$ 的进一步求值会进入循环：
  $$
  \nu \Sigma, a \sim \tau \{ e \ k \ \mu \otimes a \mapsto • \} \ \text{loops}
  $$

### **条件表达式中的循环**

对于条件表达式（例如 $ifz$）中的循环情况，规则 (37.6c) 规定了当条件表达式的求值进入循环时，整个条件表达式的求值也会进入循环。这意味着当表达式 $e$ 遇到黑洞时，分支表达式的进一步求值同样会进入循环。

### **函数应用中的循环**

在函数应用的情况下，如果函数位置或参数的求值进入循环，那么整个应用表达式的求值也会进入循环。例如：
$$
\nu \Sigma \{ e_1 \ k \ \mu \} \ \text{loops}
\implies \nu \Sigma \{ e_1(e_2) \ k \ \mu \} \ \text{loops}
$$
这意味着当函数表达式 $e_1$ 遇到黑洞时，整个函数应用表达式也会进入循环状态。

### **总结**

通过以上规则的分析，进展定理 (Theorem 37.2) 的证明表明，对于合法的系统状态 $\nu \Sigma \{ e \ k \ \mu \}$，系统要么能够到达终态 (final)，要么会进入循环 (loops)，要么可以继续演化 (即存在新的状态)。通过引入黑洞的概念，系统能够有效避免无限递归或自引用的问题，从而确保系统的健壮性。

### ---------------------------------

我理解你的需求，现在我们来详细分析并逐步讲解你提供的内容，确保包括公式、推导、以及相关的历史背景和原因都被深入解析。

你提供的内容涉及“By-Need Dynamics”以及相关的规则和定理。接下来我们从逐步解释开始。

### 37.2 安全性 (Safety)

首先我们介绍**符号声明规则**，即如何判断表达式和符号之间的关系：

$$
\Gamma \vdash_{\Sigma, a \sim \tau} a : \tau
$$

这一规则（公式 37.4）表明，如果符号 $a$ 被声明为类型 $\tau$，那么我们可以直接将其当作类型为 $\tau$ 的表达式使用。这是通过将符号隐式转化为表达式来实现的。注意：$\Gamma$ 是当前的上下文环境，$\Sigma$ 是符号的集合。

接着，我们来看如何定义**系统状态的正确性**，用符号 $\nu \Sigma \{ e \, | \, \mu \}$ 来表示一个系统的状态：

$$
\vdash_{\Sigma} e : \tau \quad \vdash_{\Sigma} \mu : \Sigma
\quad \Rightarrow \quad \nu \Sigma \{ e \, | \, \mu \} \, ok
$$

这一规则（公式 37.5a）说明，如果表达式 $e$ 在环境 $\Sigma$ 下的类型为 $\tau$，并且 $\mu$ 是符号 $\Sigma$ 的正确映射，那么状态 $\nu \Sigma \{ e \, | \, \mu \}$ 是安全的。

接下来是允许自引用的规则（公式 37.5b），允许符号通过记忆表（memo table）相互引用，或者直接引用它自己。规则允许这种依赖的形成：

$$
\forall a \sim \tau \in \Sigma \quad \mu(a) = e \neq \bullet \quad \Rightarrow \quad \vdash_{\Sigma_0} e : \tau
$$

这里 $\bullet$ 表示黑洞（black hole），代表符号暂时没有值。允许的自引用意味着，一个符号可以依赖于自己或者通过一条有限的链依赖于其他符号。

### 定理 37.1 保持性 (Preservation)

保持性定理（Preservation）指出：如果状态 $\nu \Sigma \{ e \, | \, \mu \}$ 是安全的，且经过一步转换得到新状态 $\nu \Sigma_0 \{ e_0 \, | \, \mu_0 \}$，那么新状态也是安全的。

**定理：**

$$
\text{如果} \quad \nu \Sigma \{ e \, | \, \mu \} \, ok \quad \text{且} \quad \nu \Sigma \{ e \, | \, \mu \} \rightarrow \nu \Sigma_0 \{ e_0 \, | \, \mu_0 \} \quad \text{则} \quad \nu \Sigma_0 \{ e_0 \, | \, \mu_0 \} \, ok
$$

**证明思路：**  
我们通过归纳法（induction）证明这个定理。归纳的基础是规则 (37.3)，这些规则描述了状态转换的细节。

假设当前状态为 $\nu \Sigma \{ e \, | \, \mu \}$，我们逐条分析不同规则下的转换。

### 规则 (37.3b) 的推导：
规则 (37.3b) 涉及符号关联到的表达式不是值的情况。即，如果 $e$ 还未被完全求值，系统会将其状态从符号 $a$ 映射到“黑洞” $\bullet$，表示该符号暂时没有值。通过这种转换，系统可以防止死循环或无限递归。

#### 公式推导：

$$
\nu \Sigma, a \sim \tau \{ e \, | \, \mu \oplus (a \mapsto e) \} \quad \rightarrow \quad \nu \Sigma_0, a \sim \tau \{ e_0 \, | \, \mu_0 \oplus (a \mapsto e_0) \}
$$

假设 $\vdash_{\Sigma, a \sim \tau} \mu : \Sigma, a \sim \tau$，这意味着 $\mu$ 是符号表 $\Sigma$ 的有效映射，且 $a$ 关联的类型为 $\tau$。通过归纳，我们知道在新状态下，$\Sigma_0$ 必须包含原有的 $\Sigma$，且 $\mu_0$ 也是符号表 $\Sigma_0$ 的有效映射。

### 定理 37.2 进展性 (Progress)

这个定理讨论了进展性，即系统状态要么最终完成，要么进入无限循环，或者能够继续进行下一个状态转换。

**定理：**

$$
\text{如果} \quad \nu \Sigma \{ e \, | \, \mu \} \, ok \quad \text{则} \quad \text{要么系统达到终止状态，要么进入循环，或者可以继续转换到下一个状态}
$$

### 规则 (37.6a) - 遇到黑洞 (Black Hole)

当系统遇到符号映射为黑洞的情况时，我们称系统进入了一个“循环”状态。这种情况通常表明递归过程中出现了无限的自引用。公式如下：

$$
\nu \Sigma, a \sim \tau \{ a \, | \, \mu \oplus (a \mapsto \bullet) \} \quad loops
$$

当符号 $a$ 被映射到黑洞 $\bullet$ 时，系统无法继续正常的求值，因此认为进入了循环状态。

---

### 结论

通过上面的定理与推导，我们展示了在惰性求值（lazy evaluation）中的“安全性”和“进展性”问题。这些定理和规则确保了在符号表中的符号可以被安全地自引用，并防止死循环或无限递归的发生。

### ---------------------------------

### 37.3 Lazy 数据结构 (Lazy Data Structures)

本节讨论了如何将**惰性求值 (Lazy Evaluation)** 扩展到产品类型 (Product Types)、和类型 (Sum Types)、以及递归类型 (Recursive Types) 中。这一过程称为**按需动态 (By-Need Dynamics)**，我们将逐步讲解相关的规则和公式。

### 惰性求值产品类型的动态规则 (By-Need Dynamics for Product Types)

惰性求值可以通过**延迟计算**来提高计算效率。对于**产品类型 (Product Types)**，也即是包含多个元素的元组 (tuple)，惰性求值允许我们在需要时再计算各个元素，而不是一开始就计算。

#### 公式 37.7a：惰性产品的值规则

首先，如果产品类型的每一个元素都是符号 (symbol)，则这个产品类型本身被视为一个值。换句话说，产品类型中的每一个元素如果只是一个延迟计算的占位符，那么整个产品可以视为一个**值**。

$$
\langle a_1, a_2 \rangle \, val_\Sigma, a_1 \sim \tau_1, a_2 \sim \tau_2
$$

其中，$a_1$ 和 $a_2$ 是符号，它们分别具有类型 $\tau_1$ 和 $\tau_2$。这个规则意味着符号只在被实际使用时才被求值。

#### 公式 37.7b：创建惰性产品类型

当我们创建一个产品类型时，系统会为每个元素分配一个**新符号**，并记录这些符号与实际值之间的关联。这个关联通过**记忆表 (memo table)** 实现。

$$
\nu \Sigma \{ \langle e_1, e_2 \rangle \, k \, \mu \} \quad \longrightarrow \quad \nu \Sigma, a_1 \sim \tau_1, a_2 \sim \tau_2 \{ \langle a_1, a_2 \rangle \, k \, \mu \oplus a_1 \mapsto e_1 \oplus a_2 \mapsto e_2 \}
$$

解释：
- 当我们创建产品类型 $\langle e_1, e_2 \rangle$ 时，系统为 $e_1$ 和 $e_2$ 各生成一个新的符号 $a_1$ 和 $a_2$。
- 符号 $a_1$ 对应表达式 $e_1$，符号 $a_2$ 对应表达式 $e_2$，这对符号与表达式的映射存储在记忆表 $\mu$ 中。

#### 公式 37.7e 和 37.7h：投影操作

对于产品类型的投影操作，即获取产品类型的第一个或第二个元素，系统会访问符号 $a_1$ 或 $a_2$，并在需要时求值相应的符号。

公式 37.7e 处理**左投影**（即获取元组中的第一个元素）：

$$
\nu \Sigma, a_1 \sim \tau_1, a_2 \sim \tau_2 \{ \langle a_1, a_2 \rangle \cdot l \, k \, \mu \} \quad \longrightarrow \quad \nu \Sigma, a_1 \sim \tau_1, a_2 \sim \tau_2 \{ a_1 \, k \, \mu \}
$$

公式 37.7h 处理**右投影**（即获取元组中的第二个元素）：

$$
\nu \Sigma, a_1 \sim \tau_1, a_2 \sim \tau_2 \{ \langle a_1, a_2 \rangle \cdot r \, k \, \mu \} \quad \longrightarrow \quad \nu \Sigma, a_1 \sim \tau_1, a_2 \sim \tau_2 \{ a_2 \, k \, \mu \}
$$

解释：
- 当执行投影操作时，系统不立即计算该元素的值，而是直接返回相应的符号。直到符号真正被需要时，才会求值这个符号。

#### 公式 37.7d 和 37.7g：黑洞 (Black Hole) 情况下的循环

如果符号 $a_1$ 或 $a_2$ 对应的值在求值过程中出现了**黑洞 (Black Hole)**，也就是说符号进入了循环依赖，那么整个系统会进入无限循环。

例如，公式 37.7d 处理左投影的无限循环情况：

$$
\nu \Sigma \{ e \, k \, \mu \} \quad loops \quad \Rightarrow \quad \nu \Sigma \{ e \cdot l \, k \, \mu \} \quad loops
$$

右投影的情况类似，表现为规则 37.7g：

$$
\nu \Sigma \{ e \, k \, \mu \} \quad loops \quad \Rightarrow \quad \nu \Sigma \{ e \cdot r \, k \, \mu \} \quad loops
$$

### 小结

通过惰性求值，产品类型中的元素只有在需要时才会被求值。惰性求值的好处是可以**延迟计算**，避免不必要的计算工作。通过符号表和记忆表的引入，我们能够确保符号在被需要时能够访问其值，同时防止出现循环依赖。

### ---------------------------------

### 37.3 惰性数据结构 (Lazy Data Structures)

在惰性求值（lazy evaluation）机制中，通过按需（by-need）动态延伸到**乘积类型**(Product types)、**和类型**(Sum types)以及**递归类型**(Recursive types)是比较直接的。例如，惰性乘积类型的按需动态规则可以通过如下规则描述：

#### (37.7a)
$$
\langle a_1, a_2 \rangle \text{ 是一个值，如果 } a_1 \sim \tau_1, a_2 \sim \tau_2
$$
即，一个对偶 (pair) 仅当它的两个元素都是符号（symbols）时才被视为值。

#### (37.7b)
$$
\frac{
  \nu \Sigma \{ \langle e_1, e_2 \rangle \mid \mu \}
}{
  \nu \Sigma, a_1 \sim \tau_1, a_2 \sim \tau_2 \{ \langle a_1, a_2 \rangle \mid \mu \otimes a_1 \mapsto e_1 \otimes a_2 \mapsto e_2 \}
}
$$
这条规则意味着，当一个对偶被创建时，其元素 $e_1$ 和 $e_2$ 被绑定为符号 $a_1$ 和 $a_2$，并且这些符号和表达式的绑定关系存储在上下文 $\nu \Sigma$ 中。

#### (37.7c)
$$
\frac{
  \nu \Sigma \{ e \mid \mu \} \longrightarrow \nu \Sigma' \{ e' \mid \mu' \}
}{
  \nu \Sigma \{ e \cdot l \mid \mu \} \longrightarrow \nu \Sigma' \{ e' \cdot l \mid \mu' \}
}
$$
这表明对于任何表达式 $e$，它的左投影（projection）$e \cdot l$ 的执行规则与 $e$ 本身类似，只是在执行过程中它将左投影传递给下一个步骤。

#### (37.7d)
$$
\text{如果 } \nu \Sigma \{ e \mid \mu \} \text{ 死循环 (loops)} \\
\text{则 } \nu \Sigma \{ e \cdot l \mid \mu \} \text{ 也死循环 (loops)}
$$
即，如果对偶 $e$ 导致死循环，那么左投影 $e \cdot l$ 也会导致死循环。

#### (37.7e)
$$
\frac{
  \nu \Sigma, a_1 \sim \tau_1, a_2 \sim \tau_2 \{ \langle a_1, a_2 \rangle \cdot l \mid \mu \}
}{
  \nu \Sigma, a_1 \sim \tau_1, a_2 \sim \tau_2 \{ a_1 \mid \mu \}
}
$$
这个规则表示，当对偶 $\langle a_1, a_2 \rangle$ 的左投影被请求时，执行 $a_1$ 的值计算。

#### (37.7f)
$$
\frac{
  \nu \Sigma \{ e \mid \mu \} \longrightarrow \nu \Sigma' \{ e' \mid \mu' \}
}{
  \nu \Sigma \{ e \cdot r \mid \mu \} \longrightarrow \nu \Sigma' \{ e' \cdot r \mid \mu' \}
}
$$
这条规则类似于(37.7c)，只不过它应用于右投影（right projection）$e \cdot r$。

#### (37.7g)
$$
\text{如果 } \nu \Sigma \{ e \mid \mu \} \text{ 死循环 (loops)} \\
\text{则 } \nu \Sigma \{ e \cdot r \mid \mu \} \text{ 也死循环 (loops)}
$$
这表明，如果表达式 $e$ 导致死循环，那么右投影 $e \cdot r$ 也会导致死循环。

#### (37.7h)
$$
\frac{
  \nu \Sigma, a_1 \sim \tau_1, a_2 \sim \tau_2 \{ \langle a_1, a_2 \rangle \cdot r \mid \mu \}
}{
  \nu \Sigma, a_1 \sim \tau_1, a_2 \sim \tau_2 \{ a_2 \mid \mu \}
}
$$
这条规则对应右投影操作，当对偶 $\langle a_1, a_2 \rangle$ 的右投影被请求时，执行 $a_2$ 的值计算。

### 解释总结：

1. **对偶类型**：根据规则 (37.7a)，对偶 $\langle a_1, a_2 \rangle$ 是值当且仅当它的两个元素 $a_1$ 和 $a_2$ 都是符号。这意味着对偶类型的元素必须在创建时通过惰性绑定来获得符号值。
   
2. **惰性求值机制**：规则 (37.7b) 展示了对偶被创建时的惰性求值，它将 $e_1$ 和 $e_2$ 分别绑定到符号 $a_1$ 和 $a_2$，这些绑定会推迟到需要时才进行计算。

3. **投影操作**：规则 (37.7e) 和 (37.7h) 展示了当我们对对偶应用左投影和右投影时，只会执行相关部分的符号值计算。例如，左投影 $a_1$ 的求值会导致 $a_1$ 被求值，而不会影响 $a_2$。

4. **死循环处理**：规则 (37.7d) 和 (37.7g) 表示，如果一个表达式死循环，那么它的左投影或右投影操作也会死循环。

类似的技术可以应用于**和类型**和**递归类型**的按需动态求值。

这部分的内容描述了惰性求值在数据结构中的动态求值规则，特别是如何处理乘积类型和投影操作，并且包含了如何处理惰性求值过程中的死循环情形。

### ---------------------------------

理解了您的要求，以下我将详细解析公式和相关段落，逐步讲解惰性数据结构中的内容，包括公式中的符号解释、推导过程、以及每个部分的意义。请注意，我将从基础概念入手进行说明，并确保每个部分的解释都是清晰且完整的。

### 37.3 惰性数据结构 (Lazy Data Structures)

惰性求值（lazy evaluation）是指在需要时才计算表达式的值，而非立即计算。在惰性语言中，数据结构的求值同样是惰性的。这部分介绍了如何通过“按需”（by-need）的动态规则处理惰性乘积类型（product types）、和类型（sum types）以及递归类型（recursive types）。接下来，我将分步骤解释惰性乘积类型的求值规则。

### **规则 37.7a**
$$
\langle a_1, a_2 \rangle \text{ val}_{\Sigma}, a_1 \sim \tau_1, a_2 \sim \tau_2
$$

首先，$\langle a_1, a_2 \rangle$ 表示一个**对偶**(pair)，即包含两个元素的元组。这里，`val` 表示这个对偶被视为一个值（value）。对于一个对偶来说，只有当它的两个元素 $a_1$ 和 $a_2$ 都是符号（symbols），并且分别对应类型 $\tau_1$ 和 $\tau_2$ 时，这个对偶才可以被视为一个值。 

- $a_1 \sim \tau_1$ 和 $a_2 \sim \tau_2$ 表示 $a_1$ 和 $a_2$ 是类型 $\tau_1$ 和 $\tau_2$ 的符号，符号是惰性求值的一部分，它只是在需要时才被计算。因此，惰性乘积类型中的对偶如果两部分都是符号，它才算是完成了计算。
  

这一步建立了对偶何时可以被视为已计算的条件，即它的每个元素都必须是一个“被惰性求值”的符号。

### **规则 37.7b**
$$
\nu \Sigma \{ \langle e_1, e_2 \rangle \mid \mu \}
\longrightarrow
\nu \Sigma, a_1 \sim \tau_1, a_2 \sim \tau_2 \{ \langle a_1, a_2 \rangle \mid \mu \otimes a_1 \mapsto e_1 \otimes a_2 \mapsto e_2 \}
$$

这条规则展示了如何构建一个对偶。在表达式 $\langle e_1, e_2 \rangle$ 被求值时，会生成两个符号 $a_1$ 和 $a_2$，分别对应 $e_1$ 和 $e_2$。规则的右侧展示了 $a_1 \mapsto e_1$ 和 $a_2 \mapsto e_2$ 的绑定关系，这些绑定存储在上下文 $\nu \Sigma$ 中，这是一种延迟求值的表示。

这里的符号解释如下：

- $\nu \Sigma$：上下文环境，用于跟踪变量及其类型的绑定。
- $\mu$：状态环境，记录计算过程中上下文的变化。
- $\otimes$：表示组合操作，表示上下文和状态在延续计算时的扩展。

当 $e_1$ 和 $e_2$ 延迟求值时，它们分别与符号 $a_1$ 和 $a_2$ 绑定，并且对偶的求值将推迟到真正需要其值的时候。这是一种惰性求值策略，通过符号的引入来推迟表达式的计算。

### **规则 37.7c**
$$
\nu \Sigma \{ e \mid \mu \} \longrightarrow \nu \Sigma' \{ e' \mid \mu' \}
\quad
\nu \Sigma \{ e \cdot l \mid \mu \} \longrightarrow \nu \Sigma' \{ e' \cdot l \mid \mu' \}
$$

这条规则描述了如何通过惰性求值对偶的**左投影**（$e \cdot l$）。左投影的计算遵循和 $e$ 相同的计算方式，除了它仅处理对偶的左边部分。

符号解释：

- $e \cdot l$：表示对偶 $e$ 的左投影。
- $\longrightarrow$：表示一步推导，表明计算如何从一个状态变换到另一个状态。

这条规则的含义是，在对偶 $e$ 还没有完全求值时，只执行它的左投影部分，并且将结果应用于剩下的上下文 $\Sigma'$ 和状态 $\mu'$。

### **规则 37.7d**
$$
\nu \Sigma \{ e \mid \mu \} \text{ loops}
\quad
\nu \Sigma \{ e \cdot l \mid \mu \} \text{ loops}
$$

这条规则非常重要，它指出了**死循环**(loop) 的情况。如果表达式 $e$ 在求值过程中陷入了死循环，那么对偶的左投影 $e \cdot l$ 也将陷入死循环。

### **规则 37.7e**
$$
\nu \Sigma, a_1 \sim \tau_1, a_2 \sim \tau_2 \{ \langle a_1, a_2 \rangle \cdot l \mid \mu \}
\longrightarrow
\nu \Sigma, a_1 \sim \tau_1, a_2 \sim \tau_2 \{ a_1 \mid \mu \}
$$

这条规则描述了如何处理对偶的左投影操作。当对偶 $\langle a_1, a_2 \rangle$ 的左投影被请求时，只有 $a_1$ 的值会被计算，$a_2$ 的值保持不变。 

这是惰性求值的核心思想之一：只计算被请求的部分，而保持其余部分惰性化。

### **规则 37.7f**
$$
\nu \Sigma \{ e \mid \mu \} \longrightarrow \nu \Sigma' \{ e' \mid \mu' \}
\quad
\nu \Sigma \{ e \cdot r \mid \mu \} \longrightarrow \nu \Sigma' \{ e' \cdot r \mid \mu' \}
$$

这条规则类似于 37.7c，但它处理的是对偶的**右投影**（$e \cdot r$）。右投影的求值方式与左投影相同，只不过它处理的是对偶的右侧元素。

### **规则 37.7g**
$$
\nu \Sigma \{ e \mid \mu \} \text{ loops}
\quad
\nu \Sigma \{ e \cdot r \mid \mu \} \text{ loops}
$$

和 37.7d 类似，如果表达式 $e$ 导致死循环，那么它的右投影 $e \cdot r$ 也会死循环。

### **规则 37.7h**
$$
\nu \Sigma, a_1 \sim \tau_1, a_2 \sim \tau_2 \{ \langle a_1, a_2 \rangle \cdot r \mid \mu \}
\longrightarrow
\nu \Sigma, a_1 \sim \tau_1, a_2 \sim \tau_2 \{ a_2 \mid \mu \}
$$

与 37.7e 相似，这条规则描述了对偶的右投影。当右投影被请求时，计算 $a_2$ 的值，而 $a_1$ 保持不变。

---

### **总结**：

1. **对偶类型的值条件**：对偶的两个元素必须都是符号，并且只有在需要时才会求值，这就是惰性求值的核心思想。
  
2. **惰性求值机制**：通过符号 $a_1$ 和 $a_2$ 与表达式 $e_1$ 和 $e_2$ 的绑定，将表达式的求值推迟，直到需要这些符号的值。

3. **投影操作**：左投影和右投影分别处理对偶的左侧或右侧元素，只计算对应的部分，而保持其余部分的惰性。

4. **死循环处理**：如果表达式 $e$ 导致死循环，那么对偶的左投影或右投影也会陷入死循环。

---

这部分内容展示了如何通过按需动态规则处理惰性数据结构，特别是惰性乘积类型的规则。

### ---------------------------------

### 37.4 惰性求值的暂停机制 (Suspensions)

另一种引入惰性求值的方式是将“按需动态求值”整合到一种特定的类型中，这种类型的值可能是未计算的或已记忆化的计算结果。这种类型称为**暂停类型**(suspensions)，用于表示可能尚未计算的惰性值。

#### **暂停类型的定义**

暂停类型的定义如下：
- **τ susp**：表示类型 $ \tau $ 的暂停类型，表示一个可能是延迟计算的值。
- 介绍形式 (introductory form)：$ \text{``susp x : τ is e''} $，表示延迟计算的表达式 $ e $，该表达式的类型为 $ \tau $，并绑定 $ x $ 为惰性计算的名称。
- 消除形式 (eliminatory form)：操作 $ \text{``force(e)''} $，用于对暂停的计算 $ e $ 进行求值，将结果记录在记忆表（memo table）中，并返回计算结果。

暂停类型提供了一种统一的方式来表示惰性求值，并能够通过 $ \text{force} $ 操作显式地触发计算。

#### **暂停类型的构造与应用**

暂停类型不仅仅是对简单计算的延迟，它还可以用于构建其他惰性类型。例如：

- **惰性对偶类型**：类型 $ \tau_1 $ 和 $ \tau_2 $ 的惰性对偶可以表示为 $ \tau_1 \, susp \times \tau_2 \, susp $，即两个惰性计算值的对偶。

- **按需函数**：类型 $ \tau_1 $ 到 $ \tau_2 $ 的按需函数可以表示为 $ \tau_1 \, susp \rightarrow \tau_2 $，这意味着参数 $ \tau_1 $ 是惰性计算的，函数体基于 $ \tau_1 $ 的值计算出结果 $ \tau_2 $。

#### **复杂惰性结构**

暂停类型还可以用于构建更复杂的惰性结构。例如，“惰性列表”可以定义为：

$$ \mu t. (unit + (nat \times t)) \, susp $$

这表示一个当被强制计算时，要么得到一个空列表，要么得到一个非空列表，列表由一个自然数和另一个惰性列表组成。

我们还可以定义另一种类型：

$$ \mu t. (unit + (nat \times t \, susp)) $$

与前者不同，这种列表类型的值可能是空列表，或由一个自然数和另一个惰性列表计算组成。两种惰性列表类型之间的区别在于惰性计算应用的位置和结构。

#### **暂停类型的语法**

暂停类型的语法通过以下语法规则给出：

- **Typ τ ::= susp(τ)**：定义暂停类型。
- **Exp e ::= susp[τ](x.e)**：定义惰性计算（延迟计算）形式。
- **force(e)**：表示对暂停的计算进行强制求值。

暂停计算可以是自引用的，即它可以在自身的计算过程中引用自身。例如，$ \text{``susp[a]''} $ 表示对暂停计算 $ a $ 的引用。

#### **暂停类型的静态语义**

暂停类型的静态语义通过以下规则来定义，它使用的判定形式为 $ \Gamma \vdash_\Sigma e : \tau $，其中 $\Sigma$ 用于将类型分配给暂停计算的名称。

**规则 (37.8a)**:
$$
\frac{\Gamma, x : susp(\tau) \vdash_\Sigma e : \tau}{\Gamma \vdash_\Sigma susp[\tau](x.e) : susp(\tau)}
$$

这条规则的意思是：如果在上下文 $\Gamma$ 中，假设 $x$ 是一个类型为 $susp(\tau)$ 的暂停值，那么在这种假设下，表达式 $e$ 的类型为 $\tau$。因此，整个表达式 $susp[\tau](x.e)$ 的类型是 $susp(\tau)$。

- 这里，$x$ 绑定了暂停计算自身，因此表达式 $e$ 可以引用 $x$。这允许我们定义递归计算或延迟的计算。

**规则 (37.8b)**:
$$
\frac{\Gamma \vdash_\Sigma e : susp(\tau)}{\Gamma \vdash_\Sigma force(e) : \tau}
$$

这条规则定义了如何使用 $force$ 来强制计算一个暂停的表达式。如果表达式 $e$ 的类型是 $susp(\tau)$，那么对其强制求值后得到的结果类型为 $\tau$。

- 强制求值的作用是触发暂停计算，将其结果存储并返回。它实现了暂停类型的核心功能：惰性计算和按需求值。

**规则 (37.8c)**:
$$
\Gamma \vdash_\Sigma, a \sim \tau \, susp[a] : susp(\tau)
$$

这条规则表明 $susp[a]$ 表示对暂停计算 $a$ 的引用，并且其类型为 $susp(\tau)$。这允许对暂停的表达式进行引用，而不是直接触发求值。

---

### **深入解释与应用**

1. **惰性与记忆化计算**：
   惰性计算允许我们延迟对表达式的求值，直到我们真的需要它的结果时才计算。这种机制不仅节省了计算时间，也可以避免不必要的计算。通过暂停类型和 $force$ 操作，我们可以灵活地控制计算的时机，并通过记忆化将计算结果缓存起来，从而避免重复计算。

2. **表达式的自引用**：
   暂停类型的引入形式 $susp[x]$ 允许表达式在计算过程中引用自身。这个特性使得我们可以定义递归的或自引用的计算。例如，惰性列表的递归定义中，列表的下一个元素可以是当前列表本身的延迟计算结果，这种设计能够处理无限数据结构。

3. **不同惰性结构的比较**：
   惰性列表 $ \mu t. (unit + (nat \times t)) \, susp $ 与 $ \mu t. (unit + (nat \times t \, susp)) $ 的区别在于前者整体惰性，而后者只有列表的尾部是惰性。这种设计反映了不同的需求，前者适用于整个结构的延迟计算，而后者则适合部分延迟。

---

### **总结**

暂停类型为惰性求值提供了一种通用机制，它不仅能够延迟计算，还能够处理复杂的自引用结构。通过暂停类型，我们可以定义惰性对偶、按需函数以及惰性列表等复杂的惰性数据结构。这些规则使得我们能够灵活地设计程序的求值策略，显著提高程序的性能和灵活性。

### ---------------------------------

### 37.4.1 按需求值的暂停机制动态规则

暂停机制（Suspension）的按需求值动态规则允许延迟计算，并通过按需的方式强制计算被延迟的表达式。接下来，我将逐步讲解这些规则的含义以及它们如何在惰性求值中发挥作用。

#### **规则 (37.9a)**:
$$
\text{susp[a] val}_{\Sigma}, a \sim \tau
$$

这条规则定义了一个暂停的引用 $susp[a]$ 是一个**值**。也就是说，如果 $a$ 是与类型 $ \tau $ 相关的暂停，那么 $susp[a]$ 是有效的值。这意味着暂停本身不需要立即求值，它可以在后续需要时才进行求值。这里，$\Sigma$ 是上下文环境，跟踪符号 $a$ 的绑定类型。

- $susp[a]$ 是对暂停的引用，可以将其理解为惰性计算的一个标识符。
- $val_{\Sigma}$ 表示在上下文 $\Sigma$ 中这个表达式是一个值。

这条规则的核心是：**引用一个暂停值本身并不需要立即求值**，可以通过 $susp[a]$ 表示延迟计算的存在。

#### **规则 (37.9b)**:
$$
\frac{\nu \Sigma \{ \text{susp[}\tau](x.e) \mid \mu \} }{ \nu \Sigma, a \sim \tau \{ \text{susp[a]} \mid \mu \otimes a \mapsto [a/x]e \} }
$$

这条规则定义了如何**评估延迟计算**。当计算 $susp[\tau](x.e)$ 时，将为这个暂停分配一个新的符号 $a$，然后返回一个对该暂停的引用 $susp[a]$。与此同时，将 $x$ 替换为 $a$，并将这个计算存储在上下文中，表示计算 $[a/x]e$ 现在延迟绑定到符号 $a$ 上。

- $\nu \Sigma$：当前上下文，存储了符号与类型的绑定。
- $\mu$：当前状态，包含计算的执行信息。
- $\otimes a \mapsto [a/x]e$：表示上下文扩展，添加了符号 $a$，并且 $a$ 被绑定为表达式 $[a/x]e$。

这意味着延迟计算并不会立即执行，而是被包装成一个暂停引用，并将实际计算的表达式记录下来。当需要时，引用可以通过 $force$ 操作来执行。

#### **规则 (37.9c)**:
$$
\frac{\nu \Sigma \{ e \mid \mu \} \longrightarrow \nu \Sigma' \{ e' \mid \mu' \}}{\nu \Sigma \{ \text{force(}e\text{)} \mid \mu \} \longrightarrow \nu \Sigma' \{ \text{force(}e'\text{)} \mid \mu' \}}
$$

这条规则描述了**强制求值操作 $force(e)$** 的动态行为。如果表达式 $e$ 可以通过上下文 $\nu \Sigma$ 和状态 $\mu$ 进行推导并转化为 $e'$，那么 $force(e)$ 也可以按照相同的规则被强制求值为 $force(e')$。

- $force(e)$：表示强制对暂停 $e$ 进行求值的操作。
- $\longrightarrow$：表示一步推导，说明 $e$ 经过计算变为 $e'$。

这条规则保证了**延迟计算可以在需要时通过 $force$ 来触发求值**，并且与通常的表达式计算规则保持一致。

#### **规则 (37.9d)**:
$$
\frac{\nu \Sigma, a \sim \tau \{ \text{force(susp[a])} \mid \mu \otimes a \mapsto e \}}{\nu \Sigma, a \sim \tau \{ e \mid \mu \otimes a \mapsto e \}}
$$

这条规则具体描述了**如何强制执行暂停引用 $force(susp[a])$**。当强制求值 $force(susp[a])$ 时，它触发 $a$ 对应的延迟计算 $e$，然后将 $a$ 替换为 $e$，并返回 $e$ 作为计算结果。

- $a \mapsto e$：表示符号 $a$ 被绑定到延迟计算 $e$。
- $\otimes$：扩展当前的上下文和状态，将延迟计算的内容加入。

换句话说，**强制求值暂停会导致计算真正被执行**，并且计算的结果将被记忆化（缓存），以便在后续的计算中可以重复使用。

#### **规则 (37.9e)**:
$$
\frac{\nu \Sigma, a \sim \tau \{ \text{force(susp[a])} \mid \mu \otimes a \mapsto e \}}{\nu \Sigma' , a \sim \tau \{ \text{force(susp[a])} \mid \mu' \otimes a \mapsto e' \}}
$$

这条规则表明**暂停值的求值可以进行逐步推导**。如果在当前上下文 $\nu \Sigma$ 中，暂停 $a$ 的强制求值 $force(susp[a])$ 被部分计算为 $e$，则可以进一步推导至 $e'$，同时更新上下文 $\nu \Sigma'$ 和状态 $\mu'$。

- $e \longrightarrow e'$：表示表达式 $e$ 可以通过推导变为 $e'$。
- $\mu'$：更新后的状态，反映了计算的中间步骤。

这意味着如果暂停的计算本身是复杂的，则可以通过多步逐步强制求值，并且每一步的结果都将被更新在记忆表中。

---

### **深入解释**

1. **暂停类型的核心思想**：
   暂停类型的关键在于，它允许将计算延迟到实际需要时才执行，并且在第一次执行后缓存计算结果。通过引入一个符号 $a$ 来表示计算，并将计算表达式 $e$ 与符号绑定，程序只会在需要时使用 $force$ 操作触发求值。这种方式避免了重复计算，提高了计算效率。

2. **按需求值与记忆化**：
   通过规则 (37.9b) 和 (37.9d)，我们看到暂停机制是如何实现按需求值的。计算 $e$ 在被推迟后，符号 $a$ 作为其引用被存储。只有当 $force(susp[a])$ 被调用时，才会进行 $e$ 的求值，并将结果记忆化。这意味着暂停类型不仅延迟了计算，还缓存了结果，避免重复的求值。

3. **逐步推导与复杂计算**：
   规则 (37.9e) 允许我们对暂停的计算进行逐步求值。如果计算 $e$ 比较复杂，它可以通过多个步骤推导出结果 $e'$，而每一个中间结果都会存储在记忆表中，这样即使计算过程很长，程序仍然可以高效地处理复杂的暂停求值。

---

### **总结**

暂停机制通过按需求值的动态规则提供了灵活的惰性求值方式。暂停计算可以通过符号 $a$ 进行引用，并且只有在通过 $force$ 操作强制求值时，才会进行实际的计算。同时，计算结果会被记忆化，避免重复计算。这种机制特别适用于需要延迟执行、优化性能的场景，通过逐步推导和按需计算，程序可以高效处理复杂的表达式。

### ---------------------------------

### 37.5 笔记 (Notes)

这部分介绍了**按需求值动态求值**（by-need dynamics）的来源与其设计背后的关键思想，并讨论了与变量和可赋值单元之间的区别。

#### **按需求值动态求值的灵感**

按需求值的动态求值（by-need dynamics）在设计上受到了 **Ariola 和 Felleisen** （1997年）的启发。它们的工作研究了如何通过惰性求值机制避免不必要的计算。这种求值方式的主要目标是：**限制替换操作**，以避免冗余的计算。因此，按需求值动态求值的设计中不直接使用传统的变量概念，而是采用了**可赋值单元**（assignables）。

#### **可赋值单元与变量的区别**

在按需求值动态求值中，**可赋值单元**（assignables）与**变量**有着关键的区别。变量通过替换（substitution）来赋予其含义，而**可赋值单元**则表示可以在执行过程中对其进行一次赋值的存储单元。

- **变量**：变量的含义通过替换来实现，即在计算的不同阶段，可以将变量替换为某个值或表达式。替换是变量获取含义的主要机制。
- **可赋值单元**：可赋值单元的本质在于它只能被赋值一次，并且一旦赋值完成，它就不再允许进行其他赋值操作。相比于变量，这种设计更适合按需计算的场景，因为它避免了在计算过程中重复执行同样的计算。

按需求值动态求值的核心思想是：**避免重复计算**。通过限制对可赋值单元的赋值次数，程序可以确保一个计算只会被执行一次，而不会因为重复引用而导致不必要的计算。这种方式减少了替换操作的频繁执行，使得按需计算更高效。

#### **可赋值单元的引入**

在本书的**第35章**中，详细介绍了**可赋值单元**的概念。它的引入旨在处理类似按需求值动态求值这种场景。在按需求值中，通常计算被推迟到需要时才执行，并且执行后会缓存计算结果。可赋值单元在这个过程中扮演了重要的角色：它提供了一个在计算结果生成后存储该结果的机制，并且确保每个计算只执行一次，避免重复计算。

#### **按需求值动态求值与替换**

按需求值动态求值的目标是减少替换操作的频率，主要是为了避免计算中的冗余操作。如果直接使用传统变量，替换操作将不断发生，这会导致相同的计算被多次执行。因此，按需求值求值不使用传统的变量模型，而是依赖于可赋值单元模型，这样就可以确保计算结果只生成一次，并且通过记忆化（memoization）避免冗余计算。

### **总结**

按需求值动态求值的设计借鉴了 Ariola 和 Felleisen 的研究成果，但进行了关键的改进。最重要的区别在于，它使用**可赋值单元**来代替变量。可赋值单元在求值过程中最多只能进行一次赋值，这种设计使得按需求值动态求值能够有效地限制替换操作，从而避免冗余计算。通过这种机制，程序在按需计算时可以更加高效，并且确保每个计算只执行一次。

### ---------------------------------

在编程语言理论中，**静态规则**（Statics）和**动态规则**（Dynamics）起着不同的作用，它们对应了程序的两个重要方面：**编译阶段**和**运行时行为**。

### 静态规则的作用

静态规则是指在程序**编译阶段**适用的规则，主要作用是保证程序在**编译时**是**类型安全**的，即在不执行程序的情况下，通过检查源代码，确保程序不会在运行时触发某些类型错误。它们定义了程序的**语法结构**、**类型系统**以及**结构性属性**。

1. **类型检查（Type Checking）**：静态规则通过对程序中的类型进行推导和检查，确保所有的操作和表达式都符合类型系统的规则。例如，在一个静态类型语言中，静态规则可以防止将整数与字符串相加。

2. **编译时错误检测**：静态规则能够在程序执行之前捕获常见的逻辑错误。通过类型推导、语法检查等，编译器可以在程序出现运行时错误之前进行检测和反馈。

3. **代码优化**：因为静态规则在编译时生效，编译器可以基于这些规则进行代码优化，如消除不必要的计算、内存分配优化等，从而提高程序的执行效率。

4. **程序理解与验证**：通过静态规则，开发者可以在编译时获得更多的程序验证信息，这有助于提升程序的可理解性和可靠性。静态规则帮助确定程序的形式化属性，尤其在依赖类型系统中，它们能够在编译时验证程序的正确性。

例如，在第4章的**静态语法**部分，描述了如何定义程序的语法和类型系统，确保在程序执行之前，所有的表达式和操作符都具有一致的类型。

### 动态规则的作用

动态规则在程序的**运行时**生效，描述了程序的**执行行为**，即如何在程序运行时处理表达式、指令、数据结构等。它们定义了程序的**执行语义**，也称为程序的**动态语义**。

1. **程序执行的行为定义**：动态规则描述了程序在运行时如何执行。例如，赋值语句、函数调用、控制流（如条件分支、循环等）如何在实际执行过程中被处理。这些规则确定了程序的每一步执行是如何转化为计算步骤的。

2. **状态变化的定义**：程序在执行过程中，其内存、变量、对象的状态都会发生变化。动态规则定义了如何管理这些状态的变化。例如，在面向对象语言中，动态规则描述了对象的创建、方法调用以及状态变化。

3. **错误管理**：动态规则还负责定义程序运行时可能出现的错误，例如除零、空指针引用等。当程序违反了这些规则，动态系统将触发错误处理机制，报告或处理异常。

4. **程序执行的效率**：动态规则也与程序的执行效率密切相关。程序的运行时间、内存消耗、线程调度等都受到动态规则的影响。例如，第5章的**动态语法**部分中提到了不同的转换系统如何影响程序的执行效率。

5. **类型安全性在运行时的保障**：除了在编译时的类型安全性，动态规则也保障了程序在运行时不会违反类型安全。例如，在类型安全的语言中，运行时如果尝试执行无效的类型操作，程序会抛出类型错误，从而避免出现未定义行为。

在第6章和第7章中，进一步讨论了**动态规则与类型安全性**的关系，如何通过运行时规则保障程序不会出现类型错误，例如通过**保持性（Preservation）**和**进展性（Progress）**，即在程序执行的每一步都保持类型正确性并确保程序能够继续前进。

### 静态规则与动态规则的关系

静态规则和动态规则共同保证了程序的正确性和安全性。静态规则通过在编译时进行类型检查和语法验证，减少了运行时可能出现的错误，而动态规则则定义了程序在运行时的具体行为和状态变化，确保程序按预期执行。

- **静态规则**偏向于**编译时的检查和优化**，主要目的是提高程序的可靠性和效率。
- **动态规则**则关注程序**运行时的行为和状态**，确保程序在执行过程中按照语义正确地进行。

两者结合，可以实现强大的类型系统和高效的程序执行，在现代编程语言的设计中，静态和动态规则是相辅相成的。


### ---------------------------------


### ---------------------------------


### ---------------------------------
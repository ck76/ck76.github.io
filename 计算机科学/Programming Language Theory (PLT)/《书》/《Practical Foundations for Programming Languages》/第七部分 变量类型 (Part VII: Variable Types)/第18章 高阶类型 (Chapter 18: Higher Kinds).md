[toc]



### 第22章：构造器与种类 (Constructors and Kinds)

在这一章，我们讨论如何通过**类型构造器 (type constructor)** 生成复杂类型，如何通过**种类 (kind)** 来分类构造器，以及种类在编程语言设计中的重要性。

#### 22.1 类型构造器的概念
我们可以把一些类型，如 $nat \to nat$ 和 $nat \, list$，看作是通过应用**类型构造器 (type constructor)** 得到的。例如，$nat \to nat$ 是通过**函数类型构造器**从两个类型（$nat$ 和 $nat$）构造出来的，而 $nat \, list$ 则是通过**列表类型构造器**从 $nat$ 构造出来的。

不同的类型构造器可以接受不同数量的参数：
- **函数类型构造器**接受两个类型作为参数（$τ_1 \to τ_2$）。
- **列表类型构造器**接受一个类型作为参数（如 $list(nat)$）。

为了保证这些构造器使用得当（如列表构造器必须有一个参数，函数构造器必须有两个参数），我们需要一种机制来对构造器进行分类。**种类 (kind)** 就是对构造器的分类工具，帮助我们确保构造器的正确应用。

#### 22.2 构造器与种类 (Constructors and Kinds)
类型构造器可以是多参数的、高阶的。例如，量化类型 $∀(t.τ)$ 和 $∃(t.τ)$ 也可以被视作**高阶类型构造器**。因此，我们可以通过引入一种新的层次结构来统一对类型和类型构造器的描述。这种层次结构不仅涵盖了普通的类型构造器，还可以表达更复杂的类型系统。

为了确保构造器的使用是合理的，构造器需要被分配不同的**种类 (kinds)**。种类可以理解为构造器的类型，它们规定了构造器如何接受参数和返回类型。例如：
- $T$：表示基础类型的种类。
- $T \to T$：表示接受一个类型并返回一个类型的函数构造器的种类。
- $T \times T$：表示接受两个类型并生成一个类型的二元构造器。

#### 22.3 阶段区分 (Phase Distinction)
在编程语言设计中，存在一种**静态与动态阶段区分** (phase distinction)，即将编译时的静态操作与运行时的动态操作分开。**构造器 (constructors)** 处理的是编译时的静态数据，而**表达式 (expressions)** 处理的是运行时的动态数据。

构造器是在编译时使用的，它们帮助定义类型，并不会直接参与运行时的计算。但在运行时，只有在**静态检查 (type checking)** 通过后，我们才会执行程序。所以静态阶段是先于动态阶段发生的。

#### 22.4 构造器的简化与等价性 (Constructor Simplification and Equivalence)
引入种类结构后，另一个需要处理的问题是**构造器的等价性 (equivalence of constructors)**。例如，如果我们允许类型构造器之间的投影操作（如取函数的第一个参数类型），那么构造器可能会变得更加复杂。对于这种情况，我们需要引入**定义等价性 (definitional equality)**，即通过简化构造器来判定它们是否等价。

例如，如果我们形成一个由构造器 $nat$ 和 $str$ 组成的二元对，并对其进行第一投影，结果应该等价于 $nat$。但为了确保这类简化操作能够正确进行，我们需要一个可判定的等价性判断。

#### 22.5 两种处理方法
处理构造器简化和等价性问题的方法有两种：
1. **引入定义等价性 (Definitional Equality)**：我们可以通过定义等价性来简化构造器，并确保类型判断尊重这种等价性。要构建一个完整的语言实现，我们需要确保这种等价性是可判定的。
   
2. **禁止复杂的构造器 (Restrict Complex Constructors)**：我们也可以通过禁止某些复杂构造器（例如对构造器对进行投影）来简化构造器的结构。但这会使替换操作变得复杂，因为替换一个变量为一对时，可能会引入非法构造器。

这两种方法各有优缺点，但在这本书中，作者选择了第二种方法，即禁止复杂构造器的形式。

### 公式解释

接下来，我们来看公式和推导树的讲解。首先，如果我们允许类型构造器生成二元对，那么就可以定义如下等式：
$$
\frac{}{\text{构造器}(nat, str) = nat} 
$$

这个等式表示，对于构造器生成的二元对，我们可以通过投影操作简化为第一个参数，即 $nat$。如果允许二元投影，我们还可以定义更复杂的公式：
$$
\frac{}{\text{构造器对}(T1, T2) = \text{取第一投影}(T1)}
$$

这意味着我们可以使用构造器操作，类似于函数的参数传递规则，通过规范化（规范化是语言设计中的重要概念，保证了构造器操作的简化处理）。

#### 22.6 小结
本章的内容讨论了如何通过引入种类和构造器为编程语言增加表达力，同时也探讨了这些构造器如何被合理使用。引入种类可以帮助确保构造器的正确性，同时通过简化构造器或限制复杂构造器来处理它们的等价性问题。

这种结构化的语言设计有助于编写更复杂和强大的类型系统，同时避免在构造类型时的混乱和不一致问题。

如果你对这一章的某些内容或公式有进一步的疑问，欢迎继续提问！

### ---------------------------------

### 22.1 静态部分 (Statics)

在本节中，讨论了种类和构造器的语法以及它们的分类方式。种类和构造器是编程语言类型系统中的重要组成部分，帮助确保构造类型的正确性和一致性。

#### 1. 种类的语法 (The Syntax of Kinds)

种类 (Kind) 用来描述构造器的分类，确保构造器的使用是合理的。种类的语法如下：
- **Type**: 种类 $T$，用于表示类型。
- **Unit**: 种类 $1$，表示空元组 (nullary product)。
- **Prod(κ1; κ2)**: 种类的乘积 $κ_1 \times κ_2$，表示两个种类的二元积。
- **Arr(κ1; κ2)**: 种类的函数 $κ_1 \to κ_2$，表示一个从种类 $κ_1$ 到种类 $κ_2$ 的函数构造器。

我们通过这四种基本的种类，能够构造出多参数和高阶的类型构造器。例如，二元积类型 $T_1 \times T_2$ 或者函数类型 $T_1 \to T_2$ 都可以通过这些种类的语法构造出来。

#### 2. 构造器的语法 (The Syntax of Constructors)

构造器被分成两类：**中性构造器 (neutral constructors)** 和 **规范构造器 (canonical constructors)**。构造器的分类有助于确保我们不会将消去形式 (elimination forms) 应用于引入形式 (introduction forms)，从而避免不必要的等式推导。

##### 中性构造器 (Neutral Constructors)
中性构造器主要包括变量和投影操作，用于表示那些尚未被完全处理的构造器。语法如下：
- **$u$**: 变量，表示构造器的名称或标识符。
- **proj[l](a)**: 左投影，表示从二元积中提取第一个元素。
- **proj[r](a)**: 右投影，表示从二元积中提取第二个元素。
- **app(a1; c2)**: 应用，表示将构造器 $c_2$ 应用到中性构造器 $a_1$ 上。

##### 规范构造器 (Canonical Constructors)
规范构造器则用于表示那些完全构造好的构造器。语法如下：
- **atom(a)**: 原子构造器，它包含中性构造器 $a$。
- **unit**: 空元组构造器，表示无参数的构造器。
- **pair(c1; c2)**: 二元对构造器，表示两个构造器的组合。
- **lam(u.c)**: 构造器的抽象形式，表示一个构造器函数。

##### 区分中性和规范构造器的原因

将构造器分为中性和规范两种形式的原因，是为了避免将消去形式应用于引入形式。例如，考虑二元对的左投影 $hc_1, c_2i \cdot l$。这个表达式根据类型系统的规则应该等价于 $c_1$，但为了避免这些不必要的等式推导，我们通过语法约束来确保投影操作只能作用于中性构造器，而不是规范构造器（如对 $hc_1, c_2i$）。这种设计使得系统的推导规则更加清晰。

#### 3. 语法中的关键限制 (Crucial Restriction)

在构造器的语法中，尽管 $ba$ 形式允许将中性构造器包含到规范构造器中，但有一个重要的限制：只有种类 $T$ 的中性构造器才能被视为规范构造器。这是为了确保除了基础类型（种类 $T$）以外的构造器（如函数、乘积、单元类型）的使用不会变得过于复杂，导致推导中出现不合理的情况。

### 公式解析

在这一节中，公式的推导涉及种类的构造以及它们如何在类型系统中应用。我们可以使用推导树的形式展示构造器之间的操作：

1. **构造器的定义**：假设我们有一个函数类型构造器 $f$，其种类为 $T \to T$，我们可以表示为：
$$
\frac{}{\text{构造器 f}(T) = T}
$$
这个公式表示函数构造器 $f$ 应用于种类 $T$ 后，结果也是种类 $T$。

2. **二元积的投影**：我们可以定义二元积构造器的左投影操作为：
$$
\frac{\text{二元积}(T_1, T_2)}{\text{投影} \cdot l = T_1}
$$
这个公式展示了二元积的左投影规则。

3. **函数构造器应用**：如果我们有一个抽象函数构造器 $λ u.c$，它接受一个参数 $u$ 并返回构造器 $c$，则可以通过应用操作将参数应用于构造器：
$$
\frac{\text{函数}(λ u.c) \cdot u}{c[u]}
$$

通过这些公式，我们可以看到种类和构造器的静态规则如何保证类型构造的正确性。

#### 结论

通过种类和构造器的语法结构，我们为类型系统的构建提供了一个更高层次的抽象机制。种类帮助我们对构造器进行分类和约束，确保它们在构建类型时不会出错。而通过区分中性构造器和规范构造器，我们能够避免不必要的等式推导，保证系统的推导和替换过程是可控的。

如果对这些公式或概念有任何疑问，欢迎继续深入探讨！

### ---------------------------------

### 22.1.3 构造器与种类的静态规则详解

在这一部分，我们讨论构造器和种类的静态规则，通过具体的公式推导来解释各种构造器的形成过程。**推导类型的公式**会通过横线分隔的推导树形式逐步展开。让我们逐步解析这些规则。

#### 1. 构造器的形成规则

构造器的形成规则通过以下两种形式来描述：
- **∆ ` a ⇑ κ**: 中性构造器形成 (Neutral constructor formation)。
- **∆ ` c ⇓ κ**: 规范构造器形成 (Canonical constructor formation)。

其中，$\Delta$ 是一个假设集合，包含形如 $u_1 ⇑ \kappa_1, \dots, u_n ⇑ \kappa_n$ 的假设。这个形式反映了变量作为中性构造器的原则。接下来，针对公式中的每一个推导规则进行详细的解释。

#### 2. 推导规则解析

##### 规则 (22.1a): 中性构造器变量的形成
$$
\frac{}{\Delta, u ⇑ \kappa \vdash u ⇑ \kappa}
$$
这个规则表示，如果我们已经知道在上下文 $\Delta$ 中，变量 $u$ 属于种类 $\kappa$，那么我们可以直接推导出 $u ⇑ \kappa$。这是最基本的变量形成规则。

##### 规则 (22.1b): 二元积的左投影
$$
\frac{\Delta \vdash a ⇑ \kappa_1 \times \kappa_2}{\Delta \vdash a \cdot l ⇑ \kappa_1}
$$
此规则表示，如果我们知道构造器 $a$ 是 $\kappa_1 \times \kappa_2$ 这种二元积类型的中性构造器，那么我们可以通过左投影 $a \cdot l$ 得到一个 $\kappa_1$ 类型的中性构造器。

##### 规则 (22.1c): 二元积的右投影
$$
\frac{\Delta \vdash a ⇑ \kappa_1 \times \kappa_2}{\Delta \vdash a \cdot r ⇑ \kappa_2}
$$
这个规则与 (22.1b) 类似，只不过它描述的是从二元积类型中提取右侧元素的操作。

##### 规则 (22.1d): 应用规则
$$
\frac{\Delta \vdash a_1 ⇑ \kappa_2 \to \kappa \quad \Delta \vdash c_2 ⇓ \kappa_2}{\Delta \vdash a_1[c_2] ⇑ \kappa}
$$
这是应用规则，表示如果我们有一个从 $\kappa_2$ 到 $\kappa$ 的中性构造器 $a_1$，以及一个 $\kappa_2$ 类型的规范构造器 $c_2$，那么我们可以将 $c_2$ 应用到 $a_1$ 上，得到一个 $\kappa$ 类型的中性构造器。

##### 规则 (22.1e): 中性构造器的规范化
$$
\frac{\Delta \vdash a ⇑ T}{\Delta \vdash \text{ba} ⇓ T}
$$
这是一个关键规则，表示如果我们有一个类型 $T$ 的中性构造器 $a$，我们可以将它规范化为 $T$ 类型的规范构造器。

##### 规则 (22.1f): 空元组的形成
$$
\frac{}{\Delta \vdash hi ⇓ 1}
$$
此规则表示，空元组 $hi$ 是类型 $1$ 的规范构造器。这对应于空类型（nullary product）。

##### 规则 (22.1g): 二元积的规范构造器
$$
\frac{\Delta \vdash c_1 ⇓ \kappa_1 \quad \Delta \vdash c_2 ⇓ \kappa_2}{\Delta \vdash \langle c_1, c_2 \rangle ⇓ \kappa_1 \times \kappa_2}
$$
这个规则表示，如果 $c_1$ 和 $c_2$ 分别是 $\kappa_1$ 和 $\kappa_2$ 类型的规范构造器，那么它们的组合 $ \langle c_1, c_2 \rangle$ 就是一个 $\kappa_1 \times \kappa_2$ 类型的规范构造器。

##### 规则 (22.1h): 函数构造器的形成
$$
\frac{\Delta, u ⇑ \kappa_1 \vdash c_2 ⇓ \kappa_2}{\Delta \vdash \lambda u. c_2 ⇓ \kappa_1 \to \kappa_2}
$$
这个规则定义了函数类型的规范构造器。它表明，如果我们在上下文 $\Delta$ 和一个新的变量 $u$ 的假设下，能够推导出 $c_2$ 是 $\kappa_2$ 类型的规范构造器，那么函数 $\lambda u. c_2$ 就是一个从 $\kappa_1$ 到 $\kappa_2$ 的规范构造器。

#### 3. 证明：规范形式引理 (Canonical Forms Lemma)

我们通过上述推导规则，可以证明以下几个重要的规范形式性质 (Canonical Forms)：

1. **如果 $\kappa = 1$，那么 $c = hi$**。这意味着空元组是 $1$ 类型唯一的规范形式。
   $$
   \frac{}{\Delta \vdash hi ⇓ 1}
   $$

2. **如果 $\kappa = \kappa_1 \times \kappa_2$，那么 $c = \langle c_1, c_2 \rangle$，其中 $\Delta \vdash c_i ⇓ \kappa_i$**。这意味着对于二元积类型，其规范形式一定是两个规范构造器的组合。
   $$
   \frac{\Delta \vdash c_1 ⇓ \kappa_1 \quad \Delta \vdash c_2 ⇓ \kappa_2}{\Delta \vdash \langle c_1, c_2 \rangle ⇓ \kappa_1 \times \kappa_2}
   $$

3. **如果 $\kappa = \kappa_1 \to \kappa_2$，那么 $c = \lambda u. c_2$，其中 $\Delta, u ⇑ \kappa_1 \vdash c_2 ⇓ \kappa_2$**。这表明函数类型的规范形式是一个 lambda 抽象。
   $$
   \frac{\Delta, u ⇑ \kappa_1 \vdash c_2 ⇓ \kappa_2}{\Delta \vdash \lambda u. c_2 ⇓ \kappa_1 \to \kappa_2}
   $$

### 结论

通过这些推导规则，我们可以看到构造器的形成过程是如何确保类型构造的正确性和一致性的。每个规则都明确了如何从已有的构造器和类型假设中推导出新的构造器形式，确保了构造器使用的正确性。

如果对于这些推导公式或概念有任何问题，欢迎进一步讨论和探讨！

### ---------------------------------

在这一节中，我们讨论了更高阶的种类（Higher Kinds）如何在语言中进行建模，并解释了不同形式的量化类型系统（impredicative 和 predicative）如何处理这种构造。下面我们详细解析公式，逐步理解公式中每个符号的意义和作用，并展示如何通过推导来理解这些规则。

### 22.2 高阶种类 (Higher Kinds)

#### 构造器与种类的形式化

首先，语言 $L$ 的静态类型系统需要增加两种形式的推导：

1. **类型形成 (Type Formation)**：
   $$
   \Delta \vdash \tau \text{ type}
   $$
   这表示在上下文 $\Delta$ 下，$\tau$ 是一个类型。

2. **表达式形成 (Expression Formation)**：
   $$
   \Delta \Gamma \vdash e : \tau
   $$
   其中，$\Gamma$ 是一个形如 $x_1 : \tau_1, \dots, x_k : \tau_k$ 的有限假设集合，表示变量 $x_i$ 对应于类型 $\tau_i$，并且 $\Delta \vdash \tau_i$ 对每个 $1 \leq i \leq k$ 都成立。

#### 公式 (22.2)：构造器的分类
公式 (22.2) 给出了构造器和类型之间的关系。每个种类为 $T$ 的构造器都是一个分类器：
$$
\frac{}{\Delta \vdash \tau ⇑ T} \quad \frac{}{\Delta \vdash \tau \text{ type}}
$$
这意味着，所有构造器（构造 static data 的数据结构）都可以作为分类器（classifier），从而用于表示动态数据的类型。然而，并非所有分类器都必须通过构造器生成。

### 22.3 例子：两种量化扩展

让我们通过两个具体的扩展例子来解释构造器和分类器的不同表现：

1. **Impredicative Fragment**（非前述性片段）：允许量化类型作为构造器。
2. **Predicative Fragment**（前述性片段）：排除量化类型作为构造器，仅允许量化类型作为分类器。

#### Impredicative 片段的构造器常量

在 Impredicative 片段中，类型 $T$ 的构造器包括：
- 箭头类型构造器（函数类型构造器）：
  $$
  \frac{}{\Delta \vdash → ⇑ T → T → T}
  $$
  这里，箭头类型构造器表示从两个类型 $T$ 到另一个类型 $T$ 的映射。

- 泛型量化构造器：
  $$
  \frac{}{\Delta \vdash \forallκ ⇑ (κ → T) → T}
  $$
  这个构造器表示对于种类 $κ$ 的泛型量化类型。

通过这些构造器，我们可以将箭头类型 $\tau_1 \to \tau_2$ 表示为 $→[\tau_1][\tau_2]$，同样可以将量化类型 $\forall u :: κ. \tau$ 表示为 $\forallκ[\lambda u. \tau]$。

#### Predicative 片段的类型形成规则

在 Predicative 片段中，我们通过以下规则形成量化类型：
$$
\frac{\Delta, u ⇑ \kappa \vdash \tau \text{ type}}{\Delta \vdash \forall u :: \kappa. \tau \text{ type}}
$$
这里，$\forall u :: \kappa. \tau$ 是一个类型，但它不是构造器的一部分。

### 22.5 泛型量化类型的引入与消除规则

无论是 Impredicative 片段还是 Predicative 片段，它们的泛型量化类型的引入和消除规则都是相同的。

#### 引入规则 (22.5a)
$$
\frac{\Delta, u ⇑ \kappa \Gamma \vdash e : \tau}{\Delta \Gamma \vdash \Lambda(u::\kappa.e) : \forall u :: \kappa. \tau}
$$
这表示如果我们在上下文 $\Delta$ 和类型假设 $\Gamma$ 下，能够证明 $e$ 属于类型 $\tau$，那么通过泛型量化可以构造出类型 $\forall u :: \kappa. \tau$ 的表达式。

#### 消除规则 (22.5b)
$$
\frac{\Delta \Gamma \vdash e : \forall u :: \kappa. \tau \quad \Delta \vdash c ⇓ \kappa}{\Delta \Gamma \vdash e[c] : [c/u]\tau}
$$
这表示如果表达式 $e$ 属于泛型类型 $\forall u :: \kappa. \tau$，并且 $c$ 是种类 $\kappa$ 的规范构造器，那么我们可以通过替换将 $c$ 替换为 $u$，得到类型 $[c/u]\tau$。

#### 公式解释总结

这些公式的推导展示了不同构造器和分类器之间的关系，并展示了如何通过种类、构造器、类型形成来扩展语言的静态系统。公式 (22.5b) 中的替换操作需要特别注意，它将 $c$ 替换到表达式和类型中，这些细节将在后续部分进一步探讨。

如果有更多问题，欢迎继续提问！

### ---------------------------------

### 22.3 规范化替换（Canonizing Substitution）

这一节详细讨论了如何进行**规范化替换**（Canonizing Substitution），这是处理高阶类型系统中替换操作的关键技术点。不同于标准的替换操作，规范化替换需要保证在替换过程中不会打破“中性构造器”（neutral constructors）与“规范构造器”（canonical constructors）之间的区分。让我们通过公式解析以及它背后的推导规则，逐步理解这些概念。

#### 1. 标准替换与问题

我们在 (22.5b) 中看到，当我们进行替换操作时，面临的问题是，如果我们尝试将一个**规范构造器** $c$ 替换到一个类型族中，比如 $u ⇑ \kappa \vdash \tau \text{ type}$，传统的替换方法会导致一些不合法的组合。例如，考虑以下类型族：
$$
u ⇑ T → T \vdash u[d] ⇑ T
$$
其中 $d ⇑ T$ 是种类为 $T$ 的构造器。如果我们将 $c ⇓ T → T$ 替换为 $u$，根据 Lemma 22.1，$c$ 是一个抽象 $\lambda u_0.c_0$，那么替换会生成 $\lambda u_0.c_0[d]$，这是一个不合法的构造器形式，因为无法在这种结构中直接应用 $d$。

#### 2. 规范化替换的思路

为了解决这个问题，**规范化替换**引入了新的规则来处理这种情况，确保替换操作过程中不会生成非法的构造器组合。具体来说，在上述例子中，我们需要确保：
$$
[\lambda u_0.c_0/u]u[d] = [d/u_0]c_0
$$
换句话说，当我们将 $\lambda u_0.c_0$ 替换到类型族 $u[d]$ 中时，需要将 $d$ 代入到 $u_0$ 中的 $c_0$，而不是简单地进行无效的应用。

这背后的思想是，通过递归地减少替换操作中的类型大小和构造器的复杂度，可以保证替换过程会终止。虽然在某些情况下，目标构造器的大小可能增加，但目标变量的类型会减少。因此，基于变量类型和构造器结构的**字典序递归**，我们可以证明规范化替换是良定义的。

#### 3. 规范化替换的形式化定义

现在我们需要正式定义两种主要的替换形式，其中一种会进一步分为两种情况：

1. **将规范构造器替换为中性构造器，并生成中性构造器**：
   $$
   [c/u : \kappa]a = a'
   $$
   这里，$c$ 是种类 $\kappa$ 的构造器，$a$ 是中性构造器，替换生成新的中性构造器 $a'$。

2. **将规范构造器替换为中性构造器，并生成规范构造器**（同时生成新的种类 $\kappa'$）：
   $$
   [c/u : \kappa]a = c' ⇓ \kappa'
   $$

3. **将规范构造器替换为另一个规范构造器，并生成新的规范构造器**：
   $$
   [c/u : \kappa]c' = c''
   $$

#### 公式详细解释

在这里，我们通过这三种替换情况来处理构造器和类型系统中的复杂替换：

- **第一种替换形式**用于处理中性构造器的替换。中性构造器通常表示无法简化或展开的构造器，它们主要包括变量和投影操作。通过这种替换，我们将一个规范构造器替换为中性构造器，并保持中性构造器的形式不变。

- **第二种替换形式**涉及将规范构造器替换为中性构造器，但这次替换结果是一个新的规范构造器。它需要保证替换后的构造器形式是合法的，且能够保持规范性。

- **第三种替换形式**处理的是规范构造器之间的替换。在这种情况下，替换结果是另一个规范构造器，这个替换的过程需要保证新的构造器符合原来的语法规则，不会引入任何非法的构造器形式。

#### 规范化替换的推导树结构

在多层推导树中，规范化替换的推导可以通过递归地展开和替换构造器来进行。下面展示了一个简单的推导过程：

$$
\frac{}{\text{initial neutral constructor}} \quad \frac{}{\text{initial neutral constructor}} 
$$

$$
\frac{\frac{}{\text{neutral substitution}} \quad \frac{}{\text{neutral substitution}}}{\text{resulting neutral constructor}} 
$$

$$
\frac{\frac{\frac{}{\text{neutral substitution}} \quad \frac{}{\text{neutral substitution}}}{\text{resulting neutral constructor}} \quad \frac{}{\text{neutral substitution}}}{\text{final canonical constructor after substitution}}
$$

通过这个递归替换和推导过程，规范化替换可以逐步将变量和构造器的替换进行简化和展开，保证结果构造器始终符合规范。

#### 总结

规范化替换是处理高阶类型系统中的复杂替换操作的关键工具。通过对替换操作的递归展开和类型大小的控制，规范化替换确保了替换过程的合法性和终止性。

### ---------------------------------

在本节中，公式的替换过程分为两种主要情况，分别处理将**规范构造器**替换为**中性构造器**以及将规范构造器替换为**规范构造器**的情形。我们将通过对公式的详细解析，理解替换规则背后的逻辑。

### 1. 替换规则概述

首先，替换的形式化规则按照是否发生在关键位置（critical position）来区分。我们通过**递归定义**的方式同时定义两种替换类型的规则，并将这些规则分组，以便更清晰地理解。

### 2. 规范构造器替换的规则

#### 公式 $[c/u : \kappa]a_0 = a_{00}$ (22.6a)

$$[c/u : \kappa]ab_0 = ab_{00}$$

这条规则说明，如果我们将构造器 $c$ 替换到中性构造器 $a_0$ 中，结果 $a_{00}$ 也是中性的，并且我们将其应用到 $b_0$ 之后，得到 $ab_{00}$。

#### 公式 $[c/u : \kappa]a_0 = c_{00} ⇓ \kappa_{00}$ (22.6b)

$$[c/u : \kappa]ab_0 = c_{00}$$

这条规则处理替换后结果是一个规范构造器的情况。具体来说，如果将 $c$ 替换到 $a_0$ 中的结果是一个新的规范构造器 $c_{00}$，则替换 $ab_0$ 之后的结果也是 $c_{00}$。

#### 公式 $[u/hi : \kappa] = hi$ (22.6c)

这条规则表示，当我们将 $u$ 替换到一个空元组 $hi$ 中时，结果还是 $hi$，因为空元组不受替换的影响。

#### 公式 $[c/u : \kappa]hc_0_1,c_0_2i = hc_0_1,c_0_2i$ (22.6d)

$$[c/u : \kappa]hc_0_1,c_0_2i = hc_0_1,c_0_2i$$

此处，假如我们将 $c$ 替换到一个二元组中，那么我们分别对二元组中的两个构造器进行递归替换。假设替换后的结果为 $c_{00}$，那么我们会得到新的二元组 $hc_{00},c_{00}i$。

#### 公式 $[c/u : \kappa]λ u_0.c_0 = λ u_0.c_{00}$ (22.6e)

$$[c/u : \kappa]λ u_0.c_0 = λ u_0.c_{00} \text{ when } u_0 \neq u$$

在这里，假如我们需要将 $c$ 替换到一个抽象构造器 $λ u_0.c_0$ 中，并且 $u_0 \neq u$ 且 $u_0$ 不在 $c$ 中自由出现，那么替换的结果是保持原样，返回新的抽象构造器 $λ u_0.c_{00}$。如果条件不满足，通常可以通过重命名绑定变量 $u_0$ 来解决冲突。

### 3. 公式解释

#### 推导树的结构：

在递归替换的推导树中，每一步替换都会根据当前的构造器形式递归展开。例如：

- 如果构造器是应用形式 $ab_0$，则先替换 $a_0$，然后再应用 $b_0$，形成替换后的构造器 $ab_{00}$。
  
- 对于抽象构造器 $λ u_0.c_0$，如果替换的变量与绑定变量不冲突，则递归替换 $c_0$，保持抽象结构不变。

推导树可能具有以下形式：

$$
\frac{\frac{}{a_{00} \text{ is neutral}} \quad \frac{}{b_{00} \text{ is canonical}}}{ab_{00} \text{ is neutral}} 
$$

$$
\frac{\frac{}{c_{00} \text{ is canonical}}}{ab_0 \text{ after substitution}}
$$

### 4. 详细替换过程的解释

在替换过程中，关键点是要确保规范构造器与中性构造器的区分不会被破坏。这意味着，我们在进行替换时必须递归处理构造器的内部结构，并根据不同情况分别定义规则。

1. 对于 **函数抽象**（$\lambda u_0.c_0$）中的替换，我们必须确保 $u_0$ 不是当前要替换的变量。如果是，我们需要重命名 $u_0$，以避免变量绑定冲突。

2. 对于 **应用形式** $ab_0$，我们需要先递归替换 $a_0$，然后应用 $b_0$ 到替换结果上。这样做的目的是确保替换后构造器的语法结构不被破坏。

3. 对于 **二元组**（$hc_0_1,c_0_2i$），替换操作会分别递归地处理每个元素，确保最终的二元组仍然是规范构造器。

#### 结论

**规范化替换**的过程是通过递归定义来处理复杂的构造器替换问题。它不仅保持了替换结果的合法性，还避免了无效的构造器组合，确保替换后的结果依然符合类型系统的规范。

### ---------------------------------

这一组规则定义了将一个**规范构造器**替换为一个**中性构造器**的操作，结果仍然是另一个**中性构造器**。以下是各个规则的详细解释和推导：

### 规则 (22.7a): 非关键变量替换
$$
(c/u : \kappa) u_0 = u_0 \quad (u \neq u_0)
$$
这一规则表明，当 $u_0$ 不是目标变量 $u$ 时，替换操作不会影响 $u_0$。这意味着，如果替换的构造器 $u_0$ 与待替换的变量 $u$ 不相同，则 $u_0$ 保持不变。

#### 解释：
这是一种简单的情况，在递归替换中，如果遇到的变量 $u_0$ 与我们想要替换的变量 $u$ 不同，则该变量不受影响，替换操作将忽略它并返回它本身。 

### 规则 (22.7b): 中性构造器的左投影替换
$$
[c/u : \kappa]a_0 = a_{00} \quad \Rightarrow \quad [c/u : \kappa]a_0 \cdot l = a_{00} \cdot l
$$
这一规则描述了当我们将构造器 $c$ 替换到中性构造器 $a_0$ 中，并且结果为 $a_{00}$ 时，对 $a_0$ 的左投影 $a_0 \cdot l$ 进行替换，结果是 $a_{00} \cdot l$。

#### 解释：
在替换过程中，如果原构造器 $a_0$ 被替换为 $a_{00}$，那么它的左投影（也就是 $\cdot l$）将应用到替换后的构造器 $a_{00}$ 上。因此，替换后的结果依然是一个中性构造器 $a_{00} \cdot l$。

### 规则 (22.7c): 中性构造器的右投影替换
$$
[c/u : \kappa]a_0 = a_{00} \quad \Rightarrow \quad [c/u : \kappa]a_0 \cdot r = a_{00} \cdot r
$$
这一规则与规则 (22.7b) 类似，只是应用在右投影上。将构造器 $c$ 替换到 $a_0$ 中的结果为 $a_{00}$，则对右投影 $a_0 \cdot r$ 进行替换的结果是 $a_{00} \cdot r$。

#### 解释：
此规则表明，在对构造器 $a_0$ 进行右投影时，投影操作应该应用在替换后的构造器 $a_{00}$ 上，保持替换操作的连续性。

### 规则 (22.7d): 应用形式中的替换
$$
[c/u : \kappa]a_1 = a'_1 \quad [c/u : \kappa]c_2 = c'_2 \quad \Rightarrow \quad [c/u : \kappa]a_1[c_2] = a'_1[c'_2]
$$
这一规则说明，当我们将 $c$ 替换到 $a_1$ 和 $c_2$ 中，得到的替换结果分别为 $a'_1$ 和 $c'_2$，那么应用形式 $a_1[c_2]$ 的替换结果就是 $a'_1[c'_2]$。

#### 解释：
在替换过程中，对于应用构造器 $a_1[c_2]$，我们需要分别递归替换 $a_1$ 和 $c_2$。替换完成后，将得到新的构造器 $a'_1[c'_2]$，表示将替换后的 $a_1$ 应用于替换后的 $c_2$。

### 关键总结：

这些替换规则的主要思想是确保构造器替换后，结果依然是合法的中性构造器。这通过递归地应用替换操作来实现，其中：
1. **非目标变量保持不变** (22.7a)。
2. **对投影的递归替换** (22.7b, 22.7c) 保证了替换后的构造器能够在不同上下文中使用。
3. **应用形式中的替换** (22.7d) 允许我们替换复杂构造器的组合，并确保替换的顺序保持正确。

通过这些规则的定义，我们可以将替换操作应用于更复杂的构造器，同时保持替换结果的结构性完整。

### ---------------------------------

### 公式解释及推导：
#### 规则 (22.8a)：目标变量的替换
$$
[c/u : \kappa]u = c \Downarrow \kappa
$$
**解释：**  
此规则适用于**目标变量** $u$ 的替换，它是整个替换的关键部分。由于 $u$ 是替换的目标，因此 $u$ 被替换为构造器 $c$，并且得到了 $c$ 对应的种类 $\kappa$。这意味着，原先作为中性构造器的变量 $u$ 被转换为规范构造器 $c$。

#### 规则 (22.8b)：左投影替换
$$
[c/u : \kappa]a_0 = \langle c'_1, c'_2 \rangle \Downarrow \kappa'_1 \times \kappa'_2 \quad \Rightarrow \quad [c/u : \kappa]a_0 \cdot l = c'_1 \Downarrow \kappa'_1
$$
**解释：**  
该规则描述了对于中性构造器 $a_0$ 的替换结果为一个**对** $\langle c'_1, c'_2 \rangle$，这意味着 $a_0$ 本身是一个二元对。替换操作接着应用于其**左投影**（即 $\cdot l$），结果是二元对的第一个元素 $c'_1$，并且 $c'_1$ 的种类为 $\kappa'_1$。

#### 规则 (22.8c)：右投影替换
$$
[c/u : \kappa]a_0 = \langle c'_1, c'_2 \rangle \Downarrow \kappa'_1 \times \kappa'_2 \quad \Rightarrow \quad [c/u : \kappa]a_0 \cdot r = c'_2 \Downarrow \kappa'_2
$$
**解释：**  
此规则与 (22.8b) 类似，但应用在**右投影**上。对于中性构造器 $a_0$，替换结果是二元对 $\langle c'_1, c'_2 \rangle$，因此 $a_0$ 的右投影（即 $\cdot r$）被替换为 $c'_2$，且 $c'_2$ 的种类为 $\kappa'_2$。

#### 规则 (22.8d)：应用替换
$$
[c/u : \kappa]a_0 = \lambda u'.c_0 \Downarrow \kappa'_2 \to \kappa' \quad [c/u : \kappa]c'_2 = c''_2 \quad [c''_2/u': \kappa'_2]c_0 = c'' \quad \Rightarrow \quad [c/u : \kappa]a_0[c'_2] = c'' \Downarrow \kappa'
$$
**解释：**  
这是该组规则中最复杂的一条。该规则描述了应用形式中的替换过程。在这种情况下，$a_0$ 是一个函数 $\lambda u'.c_0$，并且我们替换它的参数 $u'$ 和其主体 $c_0$。

1. 我们首先替换了函数体 $\lambda u'.c_0$，得到了一个新的函数体 $c_0$，其种类为 $\kappa'_2 \to \kappa'$。
2. 然后，对应用的参数 $c'_2$ 进行替换，得到了 $c''_2$。
3. 最后，我们将替换后的参数 $c''_2$ 代入函数体中，进行进一步的替换，最终得到 $c''$，其种类为 $\kappa'$。

### 总结：
这些规则定义了将**规范构造器**替换为**中性构造器**时的行为。替换不仅涉及变量的直接替换，还涉及对结构的递归替换，例如对投影和应用形式的处理。这些替换过程严格遵循构造器的类型（种类）规则，确保替换后的结果仍然是一个合法的规范构造器或中性构造器。

#### 证明：定理 22.2
**陈述：**  
如果 $\Delta \vdash c \Downarrow \kappa$，且 $\Delta, u \Uparrow \kappa \vdash c_0 \Downarrow \kappa'$，并且 $\Delta, u \Uparrow \kappa \vdash a_0 \Uparrow \kappa'$，那么存在唯一的 $\Delta \vdash c'' \Downarrow \kappa'$ 使得 $[c/u : \kappa]c_0 = c''$。要么存在唯一的 $\Delta \vdash a'' \Uparrow \kappa'$ 使得 $[c/u : \kappa]a_0 = a''$，要么存在唯一的 $\Delta \vdash c'' \Downarrow \kappa'$ 使得 $[c/u : \kappa]a_0 = c''$，但不会同时出现两者。

**证明思路：**  
我们通过对 $\kappa$ 的结构进行字典序归纳来证明该定理。归纳的主索引是 $\kappa$ 的结构，次索引是 $c_0$ 和 $a_0$ 的构造规则。在 (22.8d) 规则中，我们使用了主归纳假设来处理 $\kappa'_2$，这是一种依赖于 $\kappa$ 的递归替换过程。

### ---------------------------------

### 22.4 Canonization: 构造器的规约

**Canonization** 是将非规范形式的构造器转换为规范形式的过程，这对确保构造器的等价性非常重要。为了理解这一过程，我们需要区分以下两种形式：

1. **Canonical Form (规范形式)**：满足特定条件下的构造器，例如函数 $\lambda u.c$ 的应用形式会被规约成某种标准结构。
2. **General Form (一般形式)**：在语法上是正确的构造器，但可能不符合规范形式，需要进行进一步转换。

#### 举例：
假设我们有构造器 $\left( \lambda u.c_2 \right)[c_1]$，它不符合规范形式的规则，因为应用的第一个参数（$\lambda u.c_2$）是一个 $\lambda$ 抽象，它本应是一个原子形式（即不可再被简化的形式）。为了使其成为规范形式，我们需要对其进行**替换**：将 $c_1$ 替换到 $c_2$ 的 $u$ 变量中，即 $\left[ c_1 / u \right]c_2$。

这一替换过程正是我们在第 22.3 节中介绍的**规约替换** (Canonizing Substitution)，确保我们能够将这样的复杂形式化简为标准的规范形式。

### 主要推导规则：
我们使用两个判断来定义构造器的规约过程：

1. **Canonization (规约)：**
   $$
   \Delta \vdash c :: \kappa \Downarrow c'
   $$
   **解释：** 该规则定义了如何将一般形式的构造器 $c$ 转换为其规范形式 $c'$。这里，$c$ 的种类为 $\kappa$，$c'$ 是其等价的规范形式。

2. **Atomization (原子化)：**
   $$
   \Delta \vdash c \Uparrow c' :: \kappa
   $$
   **解释：** 该规则定义了如何将一般形式的构造器 $c$ 变为原子形式 $c'$。这是为了确保 $c$ 符合应用、投影等操作的条件。

#### 例子：
假设我们有一个构造器 $\left\langle \text{int}, \text{bool} \right\rangle$，我们希望获取该对的左投影（即 $\cdot l$）。根据规约规则，我们期望这个投影能被转换为 $\text{int}$。这就是所谓的**等价性**，即：
$$
\Delta \vdash \left\langle \text{int}, \text{bool} \right\rangle \cdot l \equiv \text{int} :: \kappa
$$
通过规约，我们确保了此投影操作结果的规范化。

### 等价性的定义：
**构造器的等价性**意味着两个构造器可以规约为相同的规范形式。这种等价性通过以下公式定义：
$$
\Delta \vdash c_1 \equiv c_2 :: \kappa \quad \text{如果且仅如果} \quad \text{两者的规范形式相同（最多相差 $\alpha$ 替换）}
$$
即两个构造器 $c_1$ 和 $c_2$ 的规范形式是相同的，它们可以被视为等价。

### 总结：
Canonization 是将构造器从一般形式规约为标准规范形式的过程，而 Atomization 则确保构造器是原子形式。这些操作确保了我们在推导过程中处理构造器的正确性和等价性，最终实现动态和静态数据的一致性与准确性。

### ---------------------------------

在这一节中，我们要详细解释构造器的**Canonization**（规约）和**Atomization**（原子化）规则。这些规则定义了如何将一般形式的构造器转换为规范形式，并确保推导的正确性。在这里，我会结合每一个公式来解释其具体的符号和意义。

### Canonization Judgment (规约判断)

**规约判断**用于将一般形式的构造器转换为其规范形式，确保构造器符合最标准的形式，并与类型匹配。这个过程包含多层推导树，其关键规则如下：

#### 规则 (22.9a): 一般形式到规范形式的转换
$$
\frac{\Delta \vdash c \Uparrow c :: T}{\Delta \vdash c :: T \Downarrow \hat{c}}
$$
- **符号解释**：
  - $c$: 这是需要被规约的构造器。
  - $T$: 构造器的种类 (Kind)。
  - $\hat{c}$: 是构造器 $c$ 规约后的规范形式。
  - $\Uparrow$: 表示“原子化”，即将 $c$ 转换为原子形式的过程。
  - $\Downarrow$: 表示“规约”，即将 $c$ 转换为其规范形式。

这个规则表明，当我们有构造器 $c$ 且其种类为 $T$ 时，原子化过程 $\Uparrow$ 可以帮助我们得到规范的构造器 $\hat{c}$。

#### 规则 (22.9b): 处理 `unit` 类型
$$
\frac{}{\Delta \vdash c :: 1 \Downarrow \langle \rangle}
$$
- **符号解释**：
  - $c$ 的种类是 $1$（`unit` 类型），其唯一的规范形式是 $\langle \rangle$，表示空元组。

这个规则直接规定了当构造器的种类是 $1$ 时，它的规范形式只能是空元组 $\langle \rangle$。

#### 规则 (22.9c): 处理乘积类型
$$
\frac{\Delta \vdash c \cdot l :: \kappa_1 \Downarrow c_1 \quad \Delta \vdash c \cdot r :: \kappa_2 \Downarrow c_2}{\Delta \vdash c :: \kappa_1 \times \kappa_2 \Downarrow \langle c_1, c_2 \rangle}
$$
- **符号解释**：
  - $c$: 是乘积类型 $\kappa_1 \times \kappa_2$ 的构造器。
  - $c \cdot l$: 取构造器的左投影，得到 $c_1$，其种类为 $\kappa_1$。
  - $c \cdot r$: 取构造器的右投影，得到 $c_2$，其种类为 $\kappa_2$。
  - $\langle c_1, c_2 \rangle$: 表示乘积构造器的规范形式。

这个规则展示了如何规约乘积类型构造器。首先我们分别对构造器的左右部分进行规约，最终合并成一个规范的乘积构造器 $\langle c_1, c_2 \rangle$。

#### 规则 (22.9d): 处理函数类型
$$
\frac{\Delta, u \Uparrow \kappa_1 \vdash c[u] :: \kappa_2 \Downarrow c_2}{\Delta \vdash c :: \kappa_1 \to \kappa_2 \Downarrow \lambda u.c_2}
$$
- **符号解释**：
  - $c$: 是函数类型 $\kappa_1 \to \kappa_2$ 的构造器。
  - $u$: 是构造器 $c$ 的参数，其种类为 $\kappa_1$。
  - $\lambda u.c_2$: 表示规约后的函数构造器形式。

这个规则处理函数类型的构造器，将其规约为 $\lambda u.c_2$ 的形式。

### Atomization Judgment (原子化判断)

**原子化判断**用于将构造器转换为原子形式（最小化简形式），并且保持构造器的类型信息。这一过程包含几个重要的规则：

#### 规则 (22.9e): 处理变量
$$
\frac{}{\Delta, u \Uparrow \kappa \vdash u \Uparrow u :: \kappa}
$$
- **符号解释**：
  - $u$: 是一种类型变量。
  - $\Uparrow$: 表示原子化过程。

当 $u$ 是一个变量时，它的原子形式就是它自身。

#### 规则 (22.9f): 处理乘积类型的左投影
$$
\frac{\Delta \vdash c \Uparrow c :: \kappa_1 \times \kappa_2}{\Delta \vdash c \cdot l \Uparrow c \cdot l :: \kappa_1}
$$
- **符号解释**：
  - $c$: 是乘积类型 $\kappa_1 \times \kappa_2$ 的构造器。
  - $c \cdot l$: 左投影操作，返回构造器的左部分。

此规则表明，如果 $c$ 是一个乘积类型，那么 $c \cdot l$ 返回其左部分的原子化形式。

#### 规则 (22.9h): 处理应用
$$
\frac{\Delta \vdash c_1 \Uparrow c_1 :: \kappa_1 \to \kappa_2 \quad \Delta \vdash c_2 :: \kappa_1 \Downarrow c_2}{\Delta \vdash c_1[c_2] \Uparrow c_1[c_2] :: \kappa_2}
$$
- **符号解释**：
  - $c_1$: 是函数类型的构造器。
  - $c_2$: 是函数的参数，种类为 $\kappa_1$。
  - $c_1[c_2]$: 表示对 $c_1$ 应用 $c_2$。

此规则处理函数应用的原子化，确保 $c_1[c_2]$ 被正确规约。

### 结论

这些公式展示了如何通过**Canonization** 和 **Atomization** 处理构造器的规约与原子化。在实际操作中，这些规则确保构造器始终保持标准化，避免产生不必要的复杂性，并确保构造器的等价性

### ---------------------------------

在第 22.5 节的笔记中，讨论了两种处理构造器的方法，并详细解释了它们的区别和联系。这部分内容主要涉及经典方法与现代方法在处理构造器等价性方面的不同策略。

### 1. **经典方法（Classical Approach）**
经典方法直接从**一般形式构造器**（general-form constructors）入手，这些构造器没有在一开始限制其具体的结构和形式。因此在经典方法中，**替换**（substitution）操作是容易定义的，因为替换是在一般形式下进行的。接着，我们通过**化简**（reduction）将这些构造器归约到一个不可约的形式。

#### 关键步骤：
- **归约到不可约形式**：每个构造器在有限步归约后，最终会达到一个不可简化的形式，这个过程称为**规范化**（normalization）。
- **等价关系的传递性**：如果两个构造器可以归约到相同的不可约形式，那么它们是等价的。这种等价性必须是**传递的**，即如果 $A$ 等价于 $B$，且 $B$ 等价于 $C$，那么 $A$ 也必须等价于 $C$。这被称为**合流性**（confluence）。

总结来说，经典方法首先处理**一般形式构造器**，然后通过归约的方式判定它们是否等价。这种方法的两个核心性质是**规范化**和**合流性**。

### 2. **现代方法（Modern Approach）**
现代方法与经典方法的处理顺序相反。它首先只考虑**规范形式构造器**（canonical constructors），这些构造器已经具有良好的结构，不需要再归约。随后引入了 **Canonizing Substitution**（规约替换）这一工具，专门处理替换操作中的规约。

- **规约替换（Canonizing Substitution）**：由 Watkins 等人在 2008 年引入，规约替换确保了在替换过程中构造器始终保持规范形式。替换操作不会打破构造器的结构，从而避免了需要额外的化简步骤。
- **等价性的判断**：在这个框架下，判断两个构造器的等价性只需要将它们分别转换为规范形式（**Canonization**），然后比较两者是否相同。这种方法比经典方法更直接和高效。

### 3. **总结**
现代方法避免了经典方法中的繁琐步骤，如通过逐步化简归约构造器。通过直接操作在**规范形式**下的构造器，现代方法可以更容易地定义和处理替换操作，并且通过规范化操作来判断等价性。


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------
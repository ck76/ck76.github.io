[toc]



### Part VII: 变量类型（Variable Types）

**变量类型（Variable Types）** 这一部分主要探讨不同类型系统中的多态性（polymorphism）、抽象数据类型（abstract data types）、存在类型（existential types）等复杂的类型概念。特别地，讨论了 **Girard's System F**，以及如何通过这种系统实现多态性和数据抽象。我们来逐一解析各个章节的主要内容和概念：

#### 1. **Girard's System F**
- **系统F（System F）** 是由 Jean-Yves Girard 提出的一个重要的类型系统，它允许多态性（polymorphism），即一个函数可以接受不同类型的参数。
- **Girard's System F** 通过引入**类型变量（type variables）**，使得程序可以在不同类型间复用，并且具备更强的表达能力。
- **关键概念**：多态（Polymorphism）、类型变量（Type Variables）、通用量化（Universal Quantification）。

#### 2. **System F**
- **System F** 允许我们在类型系统中表达“类型的类型”，即通过类型抽象和类型应用，我们可以构造通用函数。
- **公式解释**：在System F中，通用类型使用 $\forall$ 来表示，例如：
  $$
  \forall \alpha. \, \alpha \to \alpha
  $$
  表示一个对于任意类型 $\alpha$，都可以将该类型映射到自身的函数。

#### 3. **多态性可定义性（Polymorphic Definability）**
- **多态性**表示程序可以定义接受不同类型的参数并返回相应类型的值的函数。在 System F 中，可以证明某些函数具有“可定义性”，即它们的行为不依赖于具体的类型，只依赖于函数的定义。

#### 4. **乘积类型与和类型（Products and Sums）**
- **乘积类型（Products）**表示将多个类型组合在一起，如元组 $(A, B)$。
- **和类型（Sums）**表示在两个或多个类型之间的选择，如 $A + B$，表示一个值可以是类型 $A$ 或类型 $B$ 的值。

#### 5. **自然数（Natural Numbers）**
- 系统F中的自然数可以通过 **Church Encoding** 来表示。自然数 0 和后继函数可以用函数定义的形式表示：
  $$
  0 \equiv \lambda f. \lambda x. x
  $$
  $$
  succ(n) \equiv \lambda f. \lambda x. f (n \, f \, x)
  $$

#### 6. **参数一致性（Parametricity Overview）**
- **参数一致性（Parametricity）**是多态函数的重要性质，它表明一个多态函数的行为必须与其输入类型的具体内容无关。
- **公式解释**：对于一个多态函数 $f : \forall \alpha. \alpha \to \alpha$，参数一致性表明 $f$ 无法访问或修改输入的具体值。

#### 7. **受限多态的形式（Restricted Forms of Polymorphism）**
- **受限多态性**指的是对多态函数施加一些限制。例如，在某些类型系统中，函数只能接受特定类型的参数。
- 常见的受限形式包括**层级限制**和**段首限制**。

#### 8. **存在类型（Existential Types）**
- **存在类型**允许我们表达数据的抽象形式，即只提供“存在性”的保证，而隐藏具体的实现。使用 $\exists$ 量词来表示。
- **公式解释**：$ \exists \alpha. F(\alpha)$ 表示存在某种类型 $\alpha$ 使得 $F(\alpha)$ 成立。可以用于数据封装和抽象。

#### 9. **数据抽象与存在类型（Data Abstraction Via Existentials）**
- 通过存在类型可以实现**数据抽象**，即隐藏实现细节，只提供外部接口。例如，抽象数据类型（ADT）可以通过存在类型来封装其内部结构。

#### 10. **表示独立性（Representation Independence）**
- **表示独立性**是一种保证，即不同的实现可以表现为相同的抽象类型。即使底层实现不同，只要接口一致，程序的行为就保持不变。

#### 11. **构造器与种类（Constructors and Kinds）**
- **种类（Kinds）**是类型的“类型”，即种类描述了类型如何构造。例如，种类 $* \to *$ 表示一个从一个类型到另一个类型的映射。
- **公式解释**：$ * $ 表示基本类型，$ * \to * $ 表示一个类型构造器。

#### 12. **静态与动态的对比（Static Versus Dynamic Typing）**
- **静态类型系统**在编译时检查类型，而**动态类型系统**在运行时检查类型。
- 本章探讨了静态类型和动态类型系统之间的关系，指出动态类型实际上可以看作是具有递归类型的静态类型系统。

---

### 结论
Part VII 主要探讨了**变量类型**的各个方面，特别是通过 **System F** 展示了多态性的力量。通过深入理解多态性、存在类型、抽象数据类型等概念，程序员可以设计更加灵活且健壮的程序。

### ---------------------------------

### 20. Girard's System F (Girard的F系统)

#### 背景概述
在我们之前讨论的语言中，每一个表达式都与其自由变量的类型绑定，这种类型系统称为**单态类型系统**(monomorphic type system)。然而，在很多情况下，我们希望实现的行为可以在多种类型上复用。例如，**恒等函数**(identity function)在不同的类型上都具有相同的行为形式：$$\lambda (x:τ) x$$。但在单态类型中，为每一个类型 $$τ$$ 都需要定义一个独立的恒等函数，类似地，对于**函数组合**(function composition)操作，我们也需要根据不同类型的三元组定义不同的组合函数，如下所示：

$$
◦_{τ1,τ2,τ3} = \lambda (f: τ2 \to τ3) \lambda (g: τ1 \to τ2) \lambda (x: τ1) f(g(x))
$$

尽管这些函数的行为是一致的，但在不同类型的场景中需要重复定义。这种重复显然可以通过**多态性**(polymorphism)来避免。

#### **多态性(Polymorphism)的定义**
**多态性**允许我们通过抽象的方式一次性定义类型无关的通用行为，并在需要时对其进行实例化，从而避免重复编码。**多态表达式**(polymorphic expressions)被用于定义这些通用模式。我们接下来要讨论的**Girard的F系统**(System F)，又称为**多态类型λ演算**(polymorphic typed λ-calculus)，就是为了解决这个问题而引入的。

#### **类型系统的多态性(Type Polymorphism)**

**多态性**不仅解决了编写冗余代码的问题，还与许多其他重要概念有联系，如**数据抽象**(data abstraction)，产品类型(product types)、和直积类型(coinductive types)的定义能力等。实际上，只有**一般递归类型**(general recursive types)才扩展了语言的表达能力，而多态性本身是类型系统的核心组成部分。

---

#### 公式解释

1. **恒等函数公式**：
   $$ \lambda (x:τ) x $$

   这个表达式表示对于任意类型 $$τ$$，都有一个相应的恒等函数，它接受一个类型为 $$τ$$ 的参数 $$x$$，并返回 $$x$$ 自身。在单态系统中，我们为每一个类型 $$τ$$ 都需要定义一个单独的恒等函数。

2. **函数组合公式**：
   $$ \circ_{τ1,τ2,τ3} = \lambda (f: τ2 \to τ3) \lambda (g: τ1 \to τ2) \lambda (x: τ1) f(g(x)) $$

   这个公式表示函数 $$f$$ 和 $$g$$ 的组合。函数 $$f$$ 将类型 $$τ2$$ 映射为 $$τ3$$，而 $$g$$ 将 $$τ1$$ 映射为 $$τ2$$。组合操作 $$\circ$$ 定义了一个新的函数，接受一个 $$τ1$$ 类型的参数 $$x$$，通过 $$g$$ 映射到 $$τ2$$，再通过 $$f$$ 映射到 $$τ3$$，最终得到结果。

---

### System F的特点

**Girard的F系统**(System F) 通过引入类型变量(type variables)来实现多态性，使得类型本身也可以作为参数进行抽象。通过这种机制，我们可以在不指定具体类型的情况下编写通用的代码，并在需要时根据不同类型进行实例化。这种方式极大地提高了代码的重用性和灵活性。

---

这是系统F中的基础概念及公式的解释，你可以继续提供内容以进行深入讲解。

### -------------------------------

### **多态性与递归类型的关系及其作用**

**多态性**（polymorphism）在类型系统中是一种强大的工具，它允许我们编写通用的代码，能够适用于不同类型的数据，而无需编写冗余的代码。多态性不仅解决了代码复用的问题，还与许多重要概念有密切联系，如**数据抽象**、**产品类型**、和**余归纳类型**。在更复杂的系统中，**一般递归类型**（general recursive types）进一步扩展了语言的表达能力，使得我们能够处理更加复杂的递归结构。

下面通过具体的例子讲解这些概念的联系。

---

### 1. **多态性与数据抽象**

#### **多态性简介**：
多态性使得函数可以在不指定具体类型的情况下运行。函数或数据类型可以泛化，从而适应不同类型的数据。例如，Haskell 中的多态函数 `map` 可以作用于任何类型的列表：

```haskell
map :: (a -> b) -> [a] -> [b]
```

- `map` 函数是多态的，它接受一个函数 `(a -> b)` 和一个类型为 `[a]` 的列表，返回类型为 `[b]` 的列表。
- 这里的 `a` 和 `b` 是类型变量，代表任何类型。

#### **数据抽象与多态性**：
**数据抽象**允许我们隐藏数据的具体实现细节，并通过多态接口进行操作。通过这种方式，程序员可以编写与具体数据类型无关的代码。

#### **例子：抽象的栈**

我们可以定义一个抽象的栈接口，并通过多态性让它适用于不同的数据类型：

```python
from typing import TypeVar, Generic, List

T = TypeVar('T')  # 定义类型变量 T

# 定义一个抽象的栈类，支持任何类型 T
class Stack(Generic[T]):
    def __init__(self):
        self.items: List[T] = []

    def push(self, item: T):
        self.items.append(item)

    def pop(self) -> T:
        return self.items.pop()

    def is_empty(self) -> bool:
        return len(self.items) == 0

# 使用多态栈
int_stack = Stack[int]()
int_stack.push(1)
int_stack.push(2)
print(int_stack.pop())  # 输出: 2
```

在这个例子中，栈是一个多态数据结构，可以适用于任何类型，而无需为每种类型编写单独的栈实现。**多态性**在这里与**数据抽象**紧密相关，因为我们可以通过抽象接口隐藏底层数据结构的细节。

---

### 2. **多态性与产品类型（Product Types）**

#### **产品类型简介**：
**产品类型**是一种复合数据类型，它由多个值组合而成。例如，元组 `(a, b)` 就是一种产品类型，它包含两个类型为 `a` 和 `b` 的值。

#### **多态与产品类型的结合**：
通过多态性，我们可以编写通用的代码来操作产品类型，而不必为每种不同的产品类型编写重复代码。

#### **例子：多态产品类型的函数**

我们可以定义一个通用函数，适用于任何类型的产品类型：

```haskell
fst :: (a, b) -> a
fst (x, _) = x

snd :: (a, b) -> b
snd (_, y) = y
```

- `fst` 函数适用于任何类型的元组 `(a, b)`，返回第一个元素 `x`。
- `snd` 函数适用于任何类型的元组 `(a, b)`，返回第二个元素 `y`。

#### **Python 实现**：

```python
from typing import Tuple, TypeVar

A = TypeVar('A')
B = TypeVar('B')

def fst(pair: Tuple[A, B]) -> A:
    return pair[0]

def snd(pair: Tuple[A, B]) -> B:
    return pair[1]

# 测试多态产品类型函数
pair = (1, "hello")
print(fst(pair))  # 输出: 1
print(snd(pair))  # 输出: hello
```

在这里，`fst` 和 `snd` 是多态函数，它们能够适用于任意类型的元组，而无需编写特定类型的函数。

---

### 3. **余归纳类型（Coinductive Types）与多态性**

#### **余归纳类型简介**：
**余归纳类型**（coinductive types）用于表示**无限数据结构**，如无限流（stream）。它们允许递归过程无限展开，并通过协递归（corecursion）来生成数据。

#### **例子：多态的无限流**

我们可以定义一个无限流类型，并使用多态性让流适用于不同类型的数据。

```python
from typing import TypeVar, Generic, Callable, Iterator

T = TypeVar('T')

# 定义一个多态的流类，支持任何类型 T
class Stream(Generic[T]):
    def __init__(self, start: T, next_fn: Callable[[T], T]):
        self.current = start
        self.next_fn = next_fn

    def __iter__(self) -> Iterator[T]:
        return self

    def __next__(self) -> T:
        value = self.current
        self.current = self.next_fn(self.current)
        return value

# 使用多态流生成自然数
natural_numbers = Stream(0, lambda n: n + 1)

for i in range(5):
    print(next(natural_numbers))  # 输出: 0 1 2 3 4
```

在这个例子中，`Stream` 是一个多态的无限流数据结构，可以适用于不同类型的流数据。我们通过协递归定义了自然数流，每次调用 `next()` 都会生成下一个自然数。

---

### 4. **一般递归类型扩展表达能力**

**一般递归类型**（general recursive types）允许我们定义递归结构，使得递归过程可以表示更复杂的数据结构，如树和图。递归类型扩展了语言的表达能力，能够处理更加复杂的递归模式。

#### **例子：多态递归树**

我们可以定义一个多态的递归树结构，用来表示任意类型的树。

```python
from typing import TypeVar, Generic, Optional

T = TypeVar('T')

# 定义一个多态的二叉树
class Tree(Generic[T]):
    def __init__(self, value: T, left: Optional['Tree[T]'] = None, right: Optional['Tree[T]'] = None):
        self.value = value
        self.left = left
        self.right = right

# 使用多态树存储整数
tree = Tree(1, Tree(2), Tree(3))

# 递归遍历二叉树（前序遍历）
def preorder(tree: Optional[Tree[T]]):
    if tree is not None:
        print(tree.value)
        preorder(tree.left)
        preorder(tree.right)

# 遍历树
preorder(tree)
```

在这个例子中，`Tree` 是一个多态的递归结构，可以存储任何类型的值。我们还定义了递归函数 `preorder`，用于前序遍历树的节点。

---

### **总结**

- **多态性** 是类型系统的核心，它允许代码在不同类型上复用，并且与**数据抽象**紧密结合，隐藏数据实现细节。
- **产品类型** 通过多态性可以简化复合数据的操作，避免重复定义。
- **余归纳类型** 允许处理**无限数据结构**，如流和无限树，配合多态性使得无限结构的定义更加灵活。
- **一般递归类型** 扩展了语言的表达能力，能够处理更加复杂的递归模式，如树和图。

通过结合多态性和递归类型，类型系统为我们提供了强大的工具，用来构造灵活、通用且表达能力丰富的数据结构。

### ---------------------------------

### 20.1 System F (Girard的F系统)

#### 背景概述

**System F**，又称为**多态λ演算**(polymorphic λ-calculus)，或者 **L{→∀}**，是一个展示多态类型核心概念的最小化函数式语言。System F 允许我们独立于其他语言特性，纯粹地分析多态类型的表达能力。它引入了对类型的抽象和实例化机制，从而提供了强大的表达能力。

#### 语法定义

System F 的语法通过以下文法给出：

- **类型(Types)**：
  - $$ τ ::= t $$ 变量
  - $$ arr(τ1; τ2) $$ 表示函数类型：$$ τ1 → τ2 $$
  - $$ all(t.τ) $$ 表示多态类型：$$ ∀t.τ $$

- **表达式(Expressions)**：
  - $$ e ::= x $$ 变量
  - $$ lam[τ](x.e) $$ 表示λ抽象：$$ λ(x:τ).e $$ (接受类型为 $$ τ $$ 的参数 $$ x $$，返回表达式 $$ e $$)
  - $$ ap(e1;e2) $$ 表示应用：$$ e1(e2) $$ (将表达式 $$ e1 $$ 应用到 $$ e2 $$ 上)
  - $$ Lam(t.e) $$ 表示类型抽象：$$ Λ(t.e) $$ (定义一个多态函数，参数为类型 $$ t $$)
  - $$ App[τ](e) $$ 表示类型应用：$$ e[τ] $$ (将类型 $$ τ $$ 应用到表达式 $$ e $$ 上)

#### 类型抽象和类型应用

- **类型抽象(Lam(t.e))**: 这一构造定义了一个**多态函数**(polymorphic function)，其中的类型参数 $$ t $$ 表示在 $$ e $$ 中未指定的类型。
- **类型应用(App[τ](e))**: 这一构造是将多态函数应用到一个特定的类型 $$ τ $$ 上，通过用这个类型来实例化类型参数 $$ t $$。

多态函数由**全称类型**(universal type) $$ all(t.τ) $$ 分类，该类型表示多态函数的结果类型是 $$ τ $$，作为类型参数 $$ t $$ 的函数。

---

#### **静态语义(Statics)**

System F 的静态语义包含两类判断形式：

1. **类型形成判断(Type formation judgment)**:  
   形式为 $$ ∆ \vdash τ \text{ type} $$，表示类型 $$ τ $$ 是在假设 $$ ∆ $$ 下形成的合法类型。

2. **类型判断(Typing judgment)**:  
   形式为 $$ ∆ \Gamma \vdash e : τ $$，表示在上下文 $$ ∆ $$ 和 $$ \Gamma $$ 下，表达式 $$ e $$ 的类型是 $$ τ $$。

其中，$$ ∆ $$ 是类型变量的集合，形式为 $$ t \text{ type} $$；$$ \Gamma $$ 是变量的类型环境，形式为 $$ x : τ $$。

#### **类型形成规则**:

1. **类型变量的形成**：
   $$
   \frac{}{∆, t \text{ type} \vdash t \text{ type}} \quad (20.1a)
   $$
   解释：在类型上下文 $$ ∆ $$ 中，若类型变量 $$ t $$ 被声明为类型，那么它确实是一个合法的类型。

2. **函数类型的形成**：
   $$
   \frac{∆ \vdash τ_1 \text{ type} \quad ∆ \vdash τ_2 \text{ type}}{∆ \vdash arr(τ_1; τ_2) \text{ type}} \quad (20.1b)
   $$
   解释：如果 $$ τ_1 $$ 和 $$ τ_2 $$ 都是合法的类型，那么函数类型 $$ τ_1 → τ_2 $$ 也是合法的。

3. **全称类型的形成**：
   $$
   \frac{∆, t \text{ type} \vdash τ \text{ type}}{∆ \vdash all(t.τ) \text{ type}} \quad (20.1c)
   $$
   解释：如果在扩展上下文 $$ ∆ $$ 加入 $$ t $$ 为类型后，$$ τ $$ 仍然是一个合法类型，那么全称类型 $$ ∀t.τ $$ 也是合法的。

---

#### **类型判断规则**:

1. **变量的类型判断**：
   $$
   \frac{}{∆ \Gamma, x:τ \vdash x : τ} \quad (20.2a)
   $$
   解释：在上下文 $$ ∆ \Gamma $$ 中，如果变量 $$ x $$ 的类型是 $$ τ $$，那么 $$ x $$ 就具有类型 $$ τ $$。

2. **λ抽象的类型判断**：
   $$
   \frac{∆ \vdash τ_1 \text{ type} \quad ∆ \Gamma, x:τ_1 \vdash e : τ_2}{∆ \Gamma \vdash lam[τ_1](x.e) : arr(τ_1; τ_2)} \quad (20.2b)
   $$
   解释：如果 $$ τ_1 $$ 和 $$ τ_2 $$ 是类型，且在上下文中 $$ e $$ 的类型是 $$ τ_2 $$，那么 $$ λ $$ 抽象 $$ λ(x:τ_1).e $$ 是函数类型 $$ τ_1 → τ_2 $$。

3. **函数应用的类型判断**：
   $$
   \frac{∆ \Gamma \vdash e_1 : arr(τ_2; τ) \quad ∆ \Gamma \vdash e_2 : τ_2}{∆ \Gamma \vdash ap(e_1; e_2) : τ} \quad (20.2c)
   $$
   解释：如果 $$ e_1 $$ 的类型是 $$ τ_2 → τ $$，且 $$ e_2 $$ 的类型是 $$ τ_2 $$，那么 $$ e_1(e_2) $$ 的类型是 $$ τ $$。

4. **类型抽象的类型判断**：
   $$
   \frac{∆, t \text{ type} \Gamma \vdash e : τ}{∆ \Gamma \vdash Lam(t.e) : all(t.τ)} \quad (20.2d)
   $$
   解释：如果在上下文 $$ ∆ $$ 中，$$ e $$ 的类型是 $$ τ $$，那么类型抽象 $$ Λ(t.e) $$ 是全称类型 $$ ∀t.τ $$。

5. **类型应用的类型判断**：
   $$
   \frac{∆ \Gamma \vdash e : all(t.τ_0) \quad ∆ \vdash τ \text{ type}}{∆ \Gamma \vdash App[τ](e) : [τ/t]τ_0} \quad (20.2e)
   $$
   解释：如果 $$ e $$ 的类型是 $$ ∀t.τ_0 $$，且 $$ τ $$ 是合法类型，那么类型应用 $$ e[τ] $$ 的类型是 $$ [τ/t]τ_0 $$，即将 $$ τ $$ 替换到 $$ τ_0 $$ 中得到的类型。

---

通过这些规则，我们能够分析和构造带有多态性表达的类型系统，**System F** 为进一步的多态系统提供了坚实的基础。

如果你有更多的内容或问题，可以继续提供。

### ---------------------------------

### Lemma 20.1 (Regularity)
**引理 20.1 (正规性)** 讨论了在上下文中表达式的类型规范性。其表述如下：

**Lemma 20.1** (Regularity):  
如果 $∆ \ \Gamma \vdash e : τ$，并且对于每个假设 $x_i : τ_i$ 都有 $∆ \vdash τ_i \text{ type}$，那么 $∆ \vdash τ \text{ type}$。

**证明**：通过对规则 (20.2) 的归纳法进行证明。

---

### Substitution Property (替换性质)

在静态语义中，替换性质是关键的，尤其是在类型形成和表达式类型判断中。

**Lemma 20.2** (Substitution):  
1. 如果 $∆, t \ \text{type} \vdash τ' \ \text{type}$ 并且 $∆ \vdash τ \ \text{type}$，那么 $∆ \vdash [τ/t]τ' \ \text{type}$。
2. 如果 $∆, t \ \text{type} \ \Gamma \vdash e' : τ'$ 并且 $∆ \vdash τ \ \text{type}$，那么 $∆ [τ/t] \Gamma \vdash [τ/t] e' : [τ/t]τ'$。
3. 如果 $∆ \ \Gamma, x:τ \vdash e' : τ'$ 并且 $∆ \ \Gamma \vdash e : τ$，那么 $∆ \ \Gamma \vdash [e/x] e' : τ'$。

**解释**：
- 第一个性质表明我们可以安全地将类型中的类型变量替换为另一个类型，并确保替换后的类型仍然是合法的类型。
- 第二个性质不仅说明我们可以替换表达式中的类型，还可以替换上下文中的类型变量，并保持类型判断的正确性。
- 第三个性质讨论了在表达式中替换变量时，如何保持类型不变。

---

### 多态函数的例子

通过这些引理，我们可以回到引言中的多态性函数的例子。以下是两个典型的多态函数：

1. **多态恒等函数 (Polymorphic Identity Function)**：
   多态恒等函数 $I$ 写作：
   $$
   Λ(t.λ (x:t) x)
   $$
   它的多态类型是：
   $$
   ∀(t.t → t)
   $$

   恒等函数的实例写作 $I[τ]$，其中 $τ$ 是某个类型，且类型为 $τ → τ$。

2. **多态组合函数 (Polymorphic Composition Function)**：
   多态组合函数 $C$ 写作：
   $$
   Λ(t_1.Λ(t_2.Λ(t_3.λ (f:t_2 → t_3) λ (g:t_1 → t_2) λ (x:t_1) f(g(x)))))
   $$

   它的多态类型为：
   $$
   ∀(t_1.∀(t_2.∀(t_3.(t_2 → t_3) → (t_1 → t_2) → (t_1 → t_3))))
   $$

   组合函数的实例通过对三个类型的应用来获得，写作 $C[τ_1][τ_2][τ_3]$，每个这样的实例的类型为：
   $$
     (τ_2 → τ_3) → (τ_1 → τ_2) → (τ_1 → τ_3)
   $$

---

组合函数的实例类型为：

$$(\tau_2 \to \tau_3) \to (\tau_1 \to \tau_2) \to (\tau_1 \to \tau_3)$$

### **箭头的应用顺序**

在这个类型表达式中，箭头 $\to$ 表示函数类型的方向，它是从**右往左**解析的。这意味着我们先从**最右侧的参数**开始应用，然后依次向左。

#### **类型解析顺序**：

- 最外层箭头 $\to$ 的右侧是一个函数：$\tau_1 \to \tau_2$，这是组合函数的**第一个参数**，即输入的第一个函数。
- 然后，最外层的左侧是一个函数：$\tau_2 \to \tau_3$，这是组合函数的**第二个参数**，即输入的第二个函数。
- 最终，组合函数返回的结果是一个将类型 $\tau_1$ 映射到类型 $\tau_3$ 的函数。

### **总结：右到左的应用顺序**
- 组合函数应用的顺序是**从右往左**。



### **组合函数的实例：详解**

组合函数的实例通过对三个类型的应用来获得，表示为 $C[\tau_1][\tau_2][\tau_3]$，其类型为：

$$(\tau_2 \to \tau_3) \to (\tau_1 \to \tau_2) \to (\tau_1 \to \tau_3)$$

这是一个典型的**高阶函数**类型，它接受两个函数作为参数，并返回一个新的函数。这种类型的表达式通常是组合函数（composition function）的类型，它的作用是将两个函数组合成一个新函数。

### **类型表达式的结构**

让我们逐步解析这个类型表达式：

1. **外层结构**：$$(\tau_2 \to \tau_3) \to (\tau_1 \to \tau_2) \to (\tau_1 \to \tau_3)$$
   - 该表达式表明这是一个**函数**，接受两个参数：
     1. **第一个参数**：类型为 $\tau_2 \to \tau_3$，它是一个从类型 $\tau_2$ 到 $\tau_3$ 的函数。
     2. **第二个参数**：类型为 $\tau_1 \to \tau_2$，它是一个从类型 $\tau_1$ 到 $\tau_2$ 的函数。
   - **返回类型**：该组合函数返回的类型是一个从 $\tau_1$ 到 $\tau_3$ 的函数，即 $\tau_1 \to \tau_3$。

### **箭头的应用顺序**

在这种类型表达式中，带有箭头 $ \to $ 的应用顺序是**从右往左**解析的。也就是说，最右侧的参数最先被应用，然后依次向左。

#### **应用顺序解析**：

1. **第一步**：组合函数接受一个类型为 $\tau_2 \to \tau_3$ 的函数，作为**第一个参数**。
2. **第二步**：组合函数接受一个类型为 $\tau_1 \to \tau_2$ 的函数，作为**第二个参数**。
3. **返回值**：组合函数返回一个新的函数，其类型为 $\tau_1 \to \tau_3$。

因此，组合函数的工作原理是通过将两个函数组合在一起，产生一个新函数。这个新函数首先将输入应用于第二个函数（$\tau_1 \to \tau_2$），然后将第二个函数的结果应用于第一个函数（$\tau_2 \to \tau_3$），最终得到类型 $\tau_3$ 的输出。

### **组合函数的例子**

#### **Haskell 示例：函数组合**

在 Haskell 中，组合函数可以用 `.` 运算符表示。它接受两个函数并返回一个组合后的新函数：

```haskell
(.) :: (b -> c) -> (a -> b) -> (a -> c)
f . g = \x -> f (g x)
```

这里的类型：

$$
(b \to c) \to (a \to b) \to (a \to c)
$$

正是组合函数的类型。这个组合函数 `f . g` 首先将输入 `x` 应用于函数 `g`，得到类型 `b` 的结果，然后将这个结果应用于函数 `f`，得到最终的结果类型 `c`。

#### **Python 示例：函数组合**

在 Python 中，我们可以通过嵌套函数来实现类似的组合函数：

```python
def compose(f, g):
    return lambda x: f(g(x))

# 定义两个简单的函数
def add_one(x):
    return x + 1

def multiply_by_two(x):
    return x * 2

# 组合两个函数
combined_function = compose(multiply_by_two, add_one)

# 结果是先加1，再乘以2
print(combined_function(3))  # 输出: 8
```

在这个 Python 示例中：
- `add_one` 的类型是 `int -> int`，相当于 $\tau_1 \to \tau_2$。
- `multiply_by_two` 的类型也是 `int -> int`，相当于 $\tau_2 \to \tau_3$。

组合函数 `compose` 的类型相当于：

$$(\tau_2 \to \tau_3) \to (\tau_1 \to \tau_2) \to (\tau_1 \to \tau_3)$$

它将两个函数组合在一起，返回一个新函数，该新函数先应用 `add_one`，再应用 `multiply_by_two`。

### **总结**

- **组合函数的类型**表示为：$$(\tau_2 \to \tau_3) \to (\tau_1 \to \tau_2) \to (\tau_1 \to \tau_3)$$
- **箭头的应用顺序**是**从右往左**解析的，表示先应用右侧的函数参数，再应用左侧的函数参数。
- 组合函数的作用是将两个函数结合在一起，产生一个新的函数，它依次执行每个函数，并传递中间结果。



### ---------------------------

在更复杂的组合函数中，函数类型的嵌套结构可能会涉及更多的参数和括号。为了说明如何组合和应用多个参数，我们通过一个复杂的例子逐步解析，并展示如何解析括号及组合函数的应用顺序。

### **复杂的组合函数类型：多参数与嵌套**

假设我们有一个更复杂的组合函数类型：

$$
((\tau_3 \to \tau_4) \to (\tau_2 \to \tau_3)) \to (\tau_1 \to \tau_2) \to \tau_1 \to \tau_4
$$

### **解析与组合步骤**

#### **1. 解析外层结构**

- 最外层结构是：
  $$
  ((\tau_3 \to \tau_4) \to (\tau_2 \to \tau_3)) \to (\tau_1 \to \tau_2) \to \tau_1 \to \tau_4
  $$
  表示一个组合函数，它接受两个函数作为参数：
  - 第一个参数的类型是 $((\tau_3 \to \tau_4) \to (\tau_2 \to \tau_3))$。
  - 第二个参数的类型是 $(\tau_1 \to \tau_2)$。
  - 返回值是一个函数，最终类型为 $(\tau_1 \to \tau_4)$。

#### **2. 解析第一个参数**

第一个参数的类型是一个嵌套的函数：

$$
(\tau_3 \to \tau_4) \to (\tau_2 \to \tau_3)
$$

这表示它接受一个类型为 $(\tau_3 \to \tau_4)$ 的函数，并返回一个类型为 $(\tau_2 \to \tau_3)$ 的函数。

- **类型解释**：
  - 它需要一个将类型 $\tau_3$ 映射到 $\tau_4$ 的函数。
  - 返回一个将类型 $\tau_2$ 映射到 $\tau_3$ 的函数。
  - 这类函数通常用于**部分应用**或**中间操作**，即它先处理一些类型的转换，再生成新的函数进行下一步处理。

#### **3. 组合与应用顺序**

让我们详细说明组合的顺序。假设我们有以下函数：

- $f_1 : \tau_3 \to \tau_4$
- $f_2 : \tau_2 \to \tau_3$
- $f_3 : \tau_1 \to \tau_2$

根据组合函数的类型，我们可以按以下步骤进行组合：

1. **第一步：应用第一个参数**

   组合函数的第一个参数是类型为 $(\tau_3 \to \tau_4) \to (\tau_2 \to \tau_3)$ 的函数，假设它被命名为 $C_1$。

   首先，组合函数接受 $C_1$ 和函数 $f_1 : \tau_3 \to \tau_4$，产生一个新函数，类型为 $(\tau_2 \to \tau_3)$。

   $$C_1(f_1) : \tau_2 \to \tau_3$$

2. **第二步：应用第二个参数**

   接下来，组合函数的第二个参数是类型为 $(\tau_1 \to \tau_2)$ 的函数 $f_3$，此时可以将 $f_3$ 与前一步得到的函数 $C_1(f_1)$ 组合起来。

   组合后的新函数的类型为：

   $$(\tau_1 \to \tau_2) \to (\tau_2 \to \tau_3) \to (\tau_1 \to \tau_3)$$

   因此，最终产生一个将 $\tau_1$ 映射到 $\tau_3$ 的新函数：

   $$f_3 \circ C_1(f_1) : \tau_1 \to \tau_3$$

3. **第三步：返回最终结果**

   在组合了 $f_3$ 和 $C_1(f_1)$ 之后，得到的新函数类型为 $\tau_1 \to \tau_3$。但是，我们还有更外层的类型需要处理，即整个组合函数还需要返回类型为 $\tau_1 \to \tau_4$ 的函数。

   为了完成最终的组合，我们再将结果传递给另一个类型为 $\tau_3 \to \tau_4$ 的函数 $f_2$，从而得到最终结果：

   $$f_2 \circ (f_3 \circ C_1(f_1)) : \tau_1 \to \tau_4$$

### **组合过程总结**

整个组合过程可以总结为以下顺序：

1. **首先**，应用第一个参数 $C_1$ 和函数 $f_1 : \tau_3 \to \tau_4$，得到一个新的函数 $C_1(f_1) : \tau_2 \to \tau_3$。
2. **然后**，将这个新的函数与第二个函数 $f_3 : \tau_1 \to \tau_2$ 组合，得到一个函数 $f_3 \circ C_1(f_1) : \tau_1 \to \tau_3$。
3. **最后**，将结果与 $f_2 : \tau_3 \to \tau_4$ 组合，得到最终结果 $f_2 \circ (f_3 \circ C_1(f_1)) : \tau_1 \to \tau_4$。

### **Haskell 示例：复杂的组合函数**

在 Haskell 中，我们可以通过 `.` 运算符来组合函数，下面是一个复杂的函数组合示例：

```haskell
-- 定义三个函数
f1 :: Int -> String
f1 = show  -- 将整数转为字符串

f2 :: String -> Bool
f2 = (== "True")  -- 判断字符串是否等于 "True"

f3 :: Char -> Int
f3 = fromEnum  -- 将字符转换为其 ASCII 编码

-- 组合函数类型:
-- ((String -> Bool) -> (Int -> String)) -> (Char -> Int) -> (Char -> Bool)
composeFunctions :: (String -> Bool) -> (Int -> String) -> (Char -> Int) -> (Char -> Bool)
composeFunctions f2 f1 f3 = f2 . f1 . f3

-- 测试组合函数
main = do
    print (composeFunctions f2 f1 f3 'T')  -- 输出: False
```

### **Python 示例：复杂的组合函数**

在 Python 中，我们也可以使用嵌套的 lambda 函数来模拟复杂的组合函数：

```python
# 定义三个函数
def f1(n: int) -> str:
    return str(n)

def f2(s: str) -> bool:
    return s == "True"

def f3(c: str) -> int:
    return ord(c)

# 组合函数
def compose_functions(f2, f1, f3):
    return lambda x: f2(f1(f3(x)))

# 测试组合函数
result = compose_functions(f2, f1, f3)('T')
print(result)  # 输出: False
```

### **总结：复杂组合函数解析**
- **从右向左解析**：组合函数的应用顺序是从最右侧开始，逐步向左解析。
- **逐步应用参数**：每个函数参数依次应用，最终组合成一个新的函数。
- **复杂结构**：在更复杂的类型中，我们需要依次解析嵌套的括号，并确定每个函数的类型和应用顺序，最终返回一个组合后的新函数。



### --------------------------

在类型表达式中，**括号的使用**和**箭头的结合方向**是至关重要的，它们决定了函数参数的绑定顺序和返回值的结构。为了理解复杂的函数类型以及括号的规则，我们需要首先明确一些基本的结合规则：

### **箭头的结合性规则**

1. **箭头类型 $A \to B$ 是右结合的**：这意味着在一个类型链中，箭头会从右到左结合。这也是为什么函数类型的应用顺序是从右向左解析的。
   
   例如：
   $$
   A \to B \to C
   $$
   等价于：
   $$
   A \to (B \to C)
   $$
   这表示一个函数，它接受一个类型 $A$ 的参数，返回另一个函数，该函数接受类型 $B$ 的参数，并返回类型 $C$。

2. **括号的作用**：括号用于明确函数类型的参数组合和返回值的顺序，帮助解析复杂的函数类型。它们优先决定某些部分的结合方式，确保正确的解析。

### **复杂类型表达式的规则**

在表达复杂的函数类型时，通常使用以下规则来添加括号：

- **右结合**：因为箭头是右结合的，最右侧的类型通常是函数的返回值，而左侧的部分表示函数的参数。
- **函数嵌套**：括号用来表示多个嵌套函数的顺序，特别是在高阶函数（函数的参数或返回值是其他函数）中。它们帮助明确参数和返回值的层次结构。

#### 例子：复杂的类型表达式

考虑下面的类型表达式：

$$
((\tau_3 \to \tau_4) \to (\tau_2 \to \tau_3)) \to (\tau_1 \to \tau_2) \to \tau_1 \to \tau_4
$$

让我们一步步解析这个表达式。

### **1. 外层结构解析**

按照箭头的右结合性规则，我们可以从右向左解析该表达式：

- **最右侧部分**：$\tau_1 \to \tau_4$，表示一个函数，它接受一个类型 $\tau_1$ 的参数，并返回一个类型 $\tau_4$ 的值。
  
- **前一部分**：$(\tau_1 \to \tau_2) \to (\tau_1 \to \tau_4)$，表示一个函数，它接受一个类型 $\tau_1 \to \tau_2$ 的函数作为参数，并返回一个新的函数 $\tau_1 \to \tau_4$。

### **2. 更复杂的嵌套函数解析**

- **进一步解析**：$((\tau_3 \to \tau_4) \to (\tau_2 \to \tau_3)) \to (\tau_1 \to \tau_2)$
  - 这一部分表示一个高阶函数，它接受两个函数作为参数：
    - 第一个参数是类型为 $\tau_3 \to \tau_4$ 的函数，返回类型为 $\tau_2 \to \tau_3$ 的函数。
    - 第二个参数是类型为 $\tau_1 \to \tau_2$ 的函数。
  - 最终返回一个新函数，类型为 $\tau_1 \to \tau_4$。

### **为什么返回值不是单独的 $\tau_4$，而是 $\tau_1 \to \tau_4$？**

这是因为：

1. **右结合性**：由于箭头类型是右结合的，最外层的返回值并不是直接的 $\tau_4$，而是一个函数类型 $\tau_1 \to \tau_4$。在解析函数类型时，必须理解箭头的右结合性，这意味着类型表达式会逐步嵌套函数。
  
2. **嵌套结构**：该表达式描述的是一个高阶函数，最终返回的是一个**新的函数**，而不是直接的值 $\tau_4$。最终返回的函数将类型为 $\tau_1$ 的参数映射到类型 $\tau_4$ 的结果。

### **类型表达式的标准格式：右结合与括号**

因此，当你看到类型表达式时，以下是标准的规则：

- **右结合性**：箭头类型默认是右结合的，最右侧的部分通常是返回值。
- **括号的使用**：括号用于明确多个函数参数的组合，帮助区分哪些部分是函数的参数，哪些部分是返回值。

#### 更复杂的例子解析

考虑一个更复杂的类型表达式：

$$
((\tau_5 \to \tau_6) \to ((\tau_4 \to \tau_5) \to (\tau_3 \to \tau_4))) \to (\tau_2 \to \tau_3) \to \tau_1 \to \tau_6
$$

根据右结合规则，解析步骤如下：

1. **最右侧**：$\tau_1 \to \tau_6$，表示返回的最终函数接受类型 $\tau_1$ 的参数，返回类型 $\tau_6$ 的结果。

2. **前一部分**：$(\tau_2 \to \tau_3) \to (\tau_1 \to \tau_6)$，表示一个高阶函数，接受类型为 $\tau_2 \to \tau_3$ 的函数，并返回类型为 $\tau_1 \to \tau_6$ 的函数。

3. **进一步解析嵌套部分**：$((\tau_5 \to \tau_6) \to ((\tau_4 \to \tau_5) \to (\tau_3 \to \tau_4))) \to (\tau_2 \to \tau_3)$，表示该组合函数接受两个参数：
   - 第一个参数是 $(\tau_5 \to \tau_6) \to ((\tau_4 \to \tau_5) \to (\tau_3 \to \tau_4))$，它是一个高阶函数，依次接受多个函数作为参数。
   - 第二个参数是 $\tau_2 \to \tau_3$。

最终，返回的函数类型是 $\tau_1 \to \tau_6$。

---

### **总结：括号添加的规则**

- **箭头类型是右结合的**：在没有括号的情况下，函数类型总是从右向左解析。右结合性规则确保最右侧是返回值，而左侧是参数。
- **括号用于明确嵌套函数**：当函数的参数是其他函数时，括号用来帮助区分每个参数的组合顺序。复杂函数中的括号有助于更好地理解参数与返回值之间的关系。
- **返回值不一定是简单类型**：由于右结合性，返回值可以是另一个函数的类型，而不必是一个简单的值类型。

复杂的类型表达式通过这些规则进行解析，并依赖于右结合和括号的结构来确定函数的参数和返回值的类型。

### ---------------------------------



### 总结

通过引理 20.1 和 20.2，我们能形式化多态系统中的替换过程，并确保多态函数的正确性和一致性。这些定理为 System F 的强大多态性表达提供了坚实的基础。

### ---------------------------------

**动态语义（Dynamics）详解：**

我们来详细解析L{→∀}的动态语义，确保对每个规则和公式都有深入理解。首先，L{→∀}的动态语义通过一组递归的推导规则来描述如何评估表达式。

### 动态规则详解

1. **规则 (20.3a):**
   $$
   \text{lam}[τ](x.e) \ val
   $$

   **解释**: 
   这个规则表明，形如 $\text{lam}[τ](x.e)$ 的表达式是一个值（val）。也就是说，在L{→∀}中，所有的lambda抽象 $\lambda(x:τ) e$ 都被认为是值。值在程序中不能进一步进行计算（即不可简化）。

   **符号解释**: 
   - $\text{lam}[τ](x.e)$: 这是一个带有类型标注 $τ$ 的lambda抽象，表示一个从类型 $τ$ 到某个目标类型的函数。
   - $val$: 表示值的状态，意味着该表达式不能再进一步简化。

2. **规则 (20.3b):**
   $$
   \text{Lam}(t.e) \ val
   $$

   **解释**: 
   这一规则类似于规则 (20.3a)，但是作用于类型抽象。它说明形如 $\text{Lam}(t.e)$ 的类型抽象也是一个值。类型抽象 $\Lambda(t.e)$ 是一种泛型函数，它的值是不会在运行时改变的。

   **符号解释**: 
   - $\text{Lam}(t.e)$: 表示一个类型抽象（多态lambda表达式），即一个带有类型参数 $t$ 的函数 $e$。$t$ 是一个类型变量。

3. **规则 (20.3c):**
   $$
   [e_2 \ val] \quad \text{ap}(\text{lam}[τ_1](x.e); e_2) \ 7→ \ [e_2/x]e
   $$

   **解释**: 
   这条规则描述了函数应用的简化过程。假设 $e_2$ 是一个值（$val$），当我们将一个lambda函数 $\lambda(x:τ_1).e$ 应用到 $e_2$ 时，结果是用 $e_2$ 替换函数体中的 $x$，即 $[e_2/x]e$。这是典型的函数调用过程，即将参数代入函数体。

   **符号解释**: 
   - $\text{ap}(e_1; e_2)$: 表示函数应用，即将 $e_2$ 应用于函数 $e_1$。
   - $[e_2/x]e$: 表示在表达式 $e$ 中，用 $e_2$ 替换所有出现的 $x$。
   - $7→$: 这里表示一个简化步骤（reduction），意味着表达式可以被简化为右边的结果。

4. **规则 (20.3d):**
   $$
   e_1 \ 7→ \ e_1' \quad \text{ap}(e_1; e_2) \ 7→ \ \text{ap}(e_1'; e_2)
   $$

   **解释**: 
   这条规则处理的是当函数本身 $e_1$ 可以简化时的情况。即如果 $e_1$ 可以被简化成 $e_1'$，那么整个函数应用 $\text{ap}(e_1; e_2)$ 就可以被简化成 $\text{ap}(e_1'; e_2)$。

   **符号解释**: 
   - $7→$: 表示简化关系。
   - $e_1'$: 是 $e_1$ 简化后的结果。

5. **规则 (20.3e):**
   $$
   e_1 \ val \quad e_2 \ 7→ \ e_2' \quad \text{ap}(e_1; e_2) \ 7→ \ \text{ap}(e_1; e_2')
   $$

   **解释**: 
   当 $e_1$ 是一个值，而 $e_2$ 可以进一步简化时，这条规则允许我们简化 $e_2$。整个应用表达式将变为 $\text{ap}(e_1; e_2')$，也就是说，简化发生在 $e_2$ 上，而 $e_1$ 保持不变。

6. **规则 (20.3f):**
   $$
   \text{App}[τ](\text{Lam}(t.e)) \ 7→ \ [τ/t]e
   $$

   **解释**: 
   这是类型应用的简化规则。当一个类型抽象 $\Lambda(t.e)$ 被应用于某个具体类型 $τ$ 时，结果是将 $τ$ 替换掉 $e$ 中的类型参数 $t$，即 $[τ/t]e$。这类似于函数应用，但作用于类型层次。

   **符号解释**: 
   - $\text{App}[τ](e)$: 表示将类型 $τ$ 应用于表达式 $e$。
   - $[τ/t]e$: 表示将类型 $τ$ 代入到 $e$ 中，替换所有出现的类型变量 $t$。

7. **规则 (20.3g):**
   $$
   e \ 7→ \ e_0 \quad \text{App}[τ](e) \ 7→ \ \text{App}[τ](e_0)
   $$

   **解释**: 
   这条规则处理的是类型应用中的表达式部分 $e$ 可以简化的情况。如果 $e$ 可以简化为 $e_0$，那么整个类型应用也可以简化为 $\text{App}[τ](e_0)$。

### 语义证明

1. **Lemma 20.3（Canonical Forms）:**
   
   这一引理说明了若某个表达式 $e$ 是某种特定类型 $τ$ 的值（val），那么它必然具有某种特定的形式。例如，如果 $τ$ 是 $τ_1 \to τ_2$ 形式的函数类型，那么 $e$ 必须是形如 $\lambda(x:τ_1) e_2$ 的lambda表达式。这个引理通过归纳静态推导规则得出，证明了值表达式的特征形式。

2. **Theorem 20.4（Preservation 定理）:**
   
   该定理表明，如果表达式 $e$ 拥有类型 $τ$，并且 $e$ 可以简化为 $e_0$，那么简化后的表达式 $e_0$ 也拥有相同的类型 $τ$。这个定理通过对动态规则的归纳证明，即每个简化步骤都保持类型不变。

3. **Theorem 20.5（Progress 定理）:**
   
   进展定理的含义是，如果某个表达式 $e$ 拥有类型 $τ$，那么 $e$ 要么已经是一个值，要么可以进一步简化，或者可能会发生运行时错误。通过对静态推导规则进行归纳，可以证明每个类型良好的表达式总能有进展。

### 总结

L{→∀} 系统通过这些规则精确描述了多态 lambda 演算的计算过程，确保程序的安全性（通过 preservation 和 progress 定理）。

### ---------------------------------

**20.2 多态可定义性（Polymorphic Definability）详解**

在本节中，我们讨论 L{→∀} 语言的强大表现力（expressiveness），尤其是它如何支持各种类型的定义。L{→∀} 是一种非常强大的多态语言，其定义能力涵盖了有限积（finite products）、有限和（finite sums），甚至包括归纳类型（inductive types）和余归纳类型（coinductive types）。

### 多态可定义性及其强大表现力

L{→∀} 语言的强大之处在于，它不仅可以定义基本的函数类型，还能够定义更复杂的类型构造，如积类型（product types）、和类型（sum types）、归纳类型和余归纳类型等。这意味着程序员可以用多态 lambda 演算表示几乎所有常见的数据结构和操作。

### 定义性相等（Definitional Equality）

为了表达这些类型定义，L{→∀} 中引入了 **定义性相等**（Definitional Equality）的概念。定义性相等是一种同构（congruence）关系，它允许我们认为某些表达式在逻辑上是等价的，尽管它们在形式上可能不同。定义性相等的基础是两条核心公理（axioms），即 (20.4a) 和 (20.4b)。

#### **(20.4a)** 函数应用的定义性相等

$$
\frac{\Delta \ \Gamma, \ x : \tau_1 \ ` \ e_2 : \tau_2 \quad \Delta \ \Gamma \ ` \ e_1 : \tau_1}{\Delta \ \Gamma \ ` \ \lambda (x: \tau_1) \ e_2(e_1) \equiv [e_1/x]e_2 : \tau_2}
$$

**解释**：
- 这个公理描述了函数应用的等价性规则。也就是说，如果我们有一个函数 $\lambda (x: \tau_1) e_2$ 和一个表达式 $e_1$，则应用该函数 $\lambda$ 到 $e_1$ 的结果与将 $e_1$ 替换为 $x$ 在 $e_2$ 中的效果是相等的。这一规则反映了函数应用的本质：将参数带入函数体并进行替换。

**符号解释**：
- $\lambda(x: \tau_1) e_2$: 带有类型标注 $τ_1$ 的 lambda 表达式，表示接受一个类型为 $τ_1$ 的参数，并返回类型为 $τ_2$ 的结果。
- $[e_1/x]e_2$: 表示在表达式 $e_2$ 中用 $e_1$ 替换所有出现的变量 $x$。

这个等式表明：函数应用和直接替换变量是等价的。这种等价性是多态系统中简化推导过程的重要部分。

#### **(20.4b)** 类型应用的定义性相等

$$
\frac{\Delta, \ t \ \text{type} \ \Gamma \ ` \ e : \tau \quad \Delta \ ` \ \rho \ \text{type}}{\Delta \ \Gamma \ ` \ \Lambda(t.e)[\rho] \equiv [\rho/t]e : [\rho/t] \tau}
$$

**解释**：
- 这个公理描述了类型应用的等价性规则。如果我们有一个类型抽象 $\Lambda(t.e)$ 并将其应用于具体类型 $\rho$，那么这个应用的结果与在表达式 $e$ 中用类型 $\rho$ 替换类型变量 $t$ 的结果是等价的。

**符号解释**：
- $\Lambda(t.e)$: 表示带有类型参数 $t$ 的多态函数 $e$。
- $[\rho/t]e$: 表示在表达式 $e$ 中用具体类型 $\rho$ 替换类型变量 $t$。
- $[\rho/t]\tau$: 表示类型 $τ$ 中的 $t$ 也被替换成 $\rho$。

这个等式表明：类型应用的效果是将类型参数代入到表达式和类型中，从而产生新的实例化版本。

### 定义性相等的扩展规则

除了上述两个核心公理之外，定义性相等的规则还包括了对所有表达式构造操作的同构性要求（即一致性要求）。这意味着定义性相等不仅在特定的lambda表达式和类型应用之间成立，而且在组合、嵌套以及其他复杂的表达式构造中也会保持相等。

### 小结

通过定义性相等的概念，L{→∀} 允许我们表达非常复杂的数据结构和函数定义，从而极大地增强了语言的表现力。通过这些规则，多态系统中的表达式可以在不同类型上下文中被复用，减少了代码的冗余，同时提高了代码的泛用性。

这些等价性规则也为类型推导和程序简化提供了坚实的理论基础，确保了程序的正确性和类型安全性。

### ---------------------------------

### 详解：L{→∀}中的积与和 (Products and Sums)

在这一节中，我们将通过 **L{→∀}** 语言（即 Girard 的 **System F**）来定义 **积类型**（Product types）和 **和类型**（Sum types）。通过使用多态 lambda 演算，我们能够定义这些类型并推导出它们的静态和动态性质。

#### 20.2.1 积类型 (Products)

首先，我们来看积类型。在编程语言中，积类型可以理解为一种能够同时保存多个不同类型值的数据结构。在 **L{→∀}** 中，我们可以通过多态函数的方式来表示积类型。

##### 零元积类型（Nullary Product Type）

零元积类型，或称为 **unit 类型**，可以通过以下方式定义：
$$
\text{unit} \equiv \forall (r.r \to r)
$$
这个定义意味着 unit 类型实际上是一个可以接受任何类型 $r$ 并返回 $r$ 自身的函数。

我们还定义了 unit 类型的唯一值：
$$
\langle \rangle \equiv \Lambda(r. \lambda(x:r) x)
$$
**解释**：
- **unit 类型**：这个类型是一个泛型（多态）函数，它接受类型 $r$ 并返回类型 $r$ 的值。这个定义类似于通常编程语言中的 `Unit`，表示没有特别的信息需要传递。
- **hi**：unit 类型的值是一个恒等函数，它接受类型为 $r$ 的参数，并返回这个参数。由于这个函数不包含任何有用的信息，因此它可以理解为一个“空元组”——在 unit 类型中唯一的值。

##### 二元积类型（Binary Product Type）

接下来是二元积类型，它表示一种可以同时存储两个不同类型值的数据结构。在 **L{→∀}** 中，它被定义为：
$$
\tau_1 \times \tau_2 \equiv \forall (r.(\tau_1 \to \tau_2 \to r) \to r)
$$
**解释**：
- **$\tau_1 \times \tau_2$**：这里我们通过一个多态函数定义了积类型，函数接受两个参数，类型分别为 $\tau_1$ 和 $\tau_2$，并返回类型 $r$ 的值。
- 这个表示法类似于一个“通用容器”，它能够在给定一个函数的情况下，存储两个不同类型的值并应用该函数来处理这两个值。

我们还定义了积类型的构造器（constructor）：
$$
\langle e_1, e_2 \rangle \equiv \Lambda(r. \lambda(x: \tau_1 \to \tau_2 \to r) x(e_1)(e_2))
$$
**解释**：
- **$\langle e_1, e_2 \rangle$**：表示一个由两个元素构成的“元组”，其中 $e_1$ 的类型是 $\tau_1$，$e_2$ 的类型是 $\tau_2$。通过给定的函数 $x$，我们可以将这两个元素应用于 $x$。

接着，我们定义两个投影函数来提取积类型中的元素：
$$
e \cdot l \equiv e[\tau_1](\lambda(x: \tau_1) \lambda(y: \tau_2) x)
$$
$$
e \cdot r \equiv e[\tau_2](\lambda(x: \tau_1) \lambda(y: \tau_2) y)
$$
**解释**：
- **$e \cdot l$**：这是一个函数，它从元组 $e$ 中提取第一个元素（类型为 $\tau_1$）。
- **$e \cdot r$**：这是一个函数，它从元组 $e$ 中提取第二个元素（类型为 $\tau_2$）。

这两个函数使用了多态性，通过定义投影函数，我们可以确保能够正确地提取积类型中的不同部分。

##### 推导的定义性相等性

通过上述定义，我们可以推导出如下等价关系：
$$
\langle e_1, e_2 \rangle \cdot l \equiv e_1 : \tau_1
$$
$$
\langle e_1, e_2 \rangle \cdot r \equiv e_2 : \tau_2
$$
**解释**：
- 这些等式表明，如果我们构造了一个元组 $\langle e_1, e_2 \rangle$，我们可以使用 $l$ 和 $r$ 操作来分别提取 $e_1$ 和 $e_2$，并且这些操作是类型安全的。

#### 20.2.2 和类型 (Sums)

接着我们来定义和类型。和类型表示一种能够保存多个类型之一的数据结构。在 **L{→∀}** 中，我们可以通过以下方式定义零元和类型和二元和类型。

##### 零元和类型（Nullary Sum Type）

零元和类型，也叫做 **void 类型**，可以这样定义：
$$
\text{void} \equiv \forall (r.r)
$$
这个定义表明，void 类型没有任何值可用，它是一个没有任何构造器的类型。

我们可以定义一个专门处理 void 类型的函数：
$$
\text{abort}[\rho](e) \equiv e[\rho]
$$
**解释**：
- **void 类型**：void 类型没有构造函数，也没有值，这意味着它不能实例化为某个具体的对象。
- **abort**：这是一个可以处理 void 类型的函数，它实际上是一个“不可能到达”的操作，因为 void 类型没有任何值。

##### 二元和类型（Binary Sum Type）

二元和类型表示可以存储两个不同类型之一的数据结构。在 **L{→∀}** 中，它被定义为：
$$
\tau_1 + \tau_2 \equiv \forall (r.(\tau_1 \to r) \to (\tau_2 \to r) \to r)
$$
**解释**：
- **$\tau_1 + \tau_2$**：这是一个多态函数，表示和类型，它允许存储类型为 $\tau_1$ 或 $\tau_2$ 的值，并应用一个函数来处理该值。

和类型的构造器定义如下：
$$
l \cdot e \equiv \Lambda(r. \lambda (x: \tau_1 \to r) \lambda (y: \tau_2 \to r) x(e))
$$
$$
r \cdot e \equiv \Lambda(r. \lambda (x: \tau_1 \to r) \lambda (y: \tau_2 \to r) y(e))
$$
**解释**：
- **$l \cdot e$**：这个构造器表示一个左边的和类型，它存储类型为 $\tau_1$ 的值 $e$，并将其传递给一个接受 $\tau_1$ 的函数。
- **$r \cdot e$**：这个构造器表示一个右边的和类型，它存储类型为 $\tau_2$ 的值 $e$，并将其传递给一个接受 $\tau_2$ 的函数。

最后，处理和类型的匹配函数定义为：
$$
\text{case } e \{l \cdot x_1 \Rightarrow e_1 | r \cdot x_2 \Rightarrow e_2\} \equiv e[\rho](\lambda(x_1: \tau_1) e_1)(\lambda(x_2: \tau_2) e_2)
$$
**解释**：
- **case** 语句表示对和类型进行模式匹配，根据和类型是左边还是右边，选择对应的分支并进行处理。

##### 推导的定义性相等性

通过上述定义，我们可以推导出如下等价关系：
$$
\text{case } l \cdot d_1 \{l \cdot x_1 \Rightarrow e_1 | r \cdot x_2 \Rightarrow e_2\} \equiv [d_1/x_1]e_1 : \rho
$$
$$
\text{case } r \cdot d_2 \{l \cdot x_1 \Rightarrow e_1 | r \cdot x_2 \Rightarrow e_2\} \equiv [d_2/x_2]e_2 : \rho
$$
**解释**：
- 这些等式表明，如果我们对一个和类型的值（如 $l \cdot d_1$ 或 $r \cdot d_2$）进行模式匹配，它会返回相应的处理结果，确保程序在执行时能够正确地处理和类型中的值。

### 总结

通过 **L{→∀}** 中定义的积类型和和类型，我们可以构造出复杂的数据结构，并确保其在静态和动态检查中都能保持类型安全。特别是定义性相等性确保了程序的行为在逻辑上是相

等的，即使它们在形式上有所不同。这种灵活性和强大的类型系统是多态 lambda 演算的核心优势。

### ---------------------------------

### 20.2.2 自然数 (Natural Numbers)

在 **L{→∀}**（即 Girard 的 **System F**）中，自然数也可以通过多态类型系统进行定义。这种定义依赖于我们如何对自然数的 **迭代器 (iterator)** 进行编码。

#### 迭代器的类型规则

我们首先回顾自然数迭代器的类型规则：
$$
e_0 : \text{nat}, \quad e_1 : \tau, \quad x : \tau \vdash e_2 : \tau
$$
$$
\text{iter}(e_0; e_1; x.e_2) : \tau
$$
**解释**：
- **$e_0$**：表示一个自然数（也即迭代的上限）。
- **$e_1$**：初始值，类型为 $\tau$。
- **$x.e_2$**：一个递归的函数体，将 $x$ 从 $e_1$ 通过某种变换 $s$ 迭代到自然数的上限 $e_0$。
- 该迭代函数的输出类型是 $\tau$，这意味着我们可以从一个自然数迭代计算出任意类型的值。

这个规则表明，给定一个自然数，我们可以使用迭代器将某个初始值进行迭代，直到达到该自然数。

#### 迭代器与自然数的定义

自然数在 **L{→∀}** 中的表示方法非常有趣，它的关键在于我们如何表示迭代器。可以通过以下方式定义自然数类型：
$$
\text{nat} \equiv \forall (t. t \to (t \to t) \to t)
$$
**解释**：
- **自然数类型**：自然数被定义为一个多态函数类型，即接受类型 $t$，然后接受一个初始值（类型为 $t$）和一个从 $t$ 到 $t$ 的递归函数，返回一个最终的 $t$ 类型结果。
- 这个定义实际上是将自然数与迭代函数等价，即自然数被表示为“迭代某个操作 $n$ 次”的过程。

接下来，我们定义自然数的零元和后继函数：
$$
z \equiv \Lambda(t. \lambda (z:t) \lambda (s:t \to t) z)
$$
$$
s(e) \equiv \Lambda(t. \lambda (z:t) \lambda (s:t \to t) s(e[t](z)(s)))
$$
**解释**：
- **$z$**：零元被定义为一个函数，它接受类型 $t$，然后接受初始值 $z$（类型为 $t$），以及一个递归函数 $s$，并直接返回初始值 $z$。这相当于表示自然数 $0$ 的递归基。
- **$s(e)$**：后继函数表示“对自然数 $e$ 进行一次递归操作”，它首先接受类型 $t$，然后将初始值 $z$ 和递归函数 $s$ 传递给 $e$，并通过 $s$ 对 $e$ 的结果进行迭代。

#### 自然数的迭代函数

在 **L{→∀}** 中，自然数的迭代函数可以定义为：
$$
\text{iter}(e_0; e_1; x.e_2) \equiv e_0[\tau](e_1)(\lambda (x:\tau) e_2)
$$
**解释**：
- **$\text{iter}$**：这是自然数的迭代器，它接受一个自然数 $e_0$、初始值 $e_1$ 以及一个递归函数 $x.e_2$。函数通过将初始值 $e_1$ 和递归函数应用于自然数 $e_0$，进行迭代计算。

#### 通过多态定义自然数

这个表示方法展示了自然数如何通过一个迭代函数来进行定义。每个自然数实际上被定义为对某个操作进行迭代的次数。这意味着：
- 自然数 $n$ 可以表示为一个迭代 $n$ 次的多态函数。
- **$z$** 表示零次迭代，即返回初始值。
- **$s(e)$** 表示将自然数 $e$ 增加 1，并执行一次递归操作。

#### L{→∀} 的表达能力

通过这些定义，我们可以得出结论，**L{→∀}** 的表达能力至少和 **L{nat →}**（简单的自然数函数语言）一样强大。这是因为我们能够通过 **L{→∀}** 完全定义自然数类型以及相关的操作。

然而，**L{→∀}** 的表达能力实际上更强大。我们可以证明，**L{nat →}** 的求值函数可以在 **L{→∀}** 中定义，尽管它无法在 **L{nat →}** 中定义。这表明 **L{→∀}** 拥有更多的表达能力。

##### 推广结论：
**L{→∀}** 是一个非常强大的语言系统，它不仅能够定义简单的数据类型如自然数，还能够通过多态性灵活地表达各种复杂类型。这使得它在编程语言设计中具有重要意义，尤其是在处理泛型和多态行为时。

### ---------------------------------

### 20.3 概述：参数性 (Parametricity Overview)

**L{→∀}**（即 Girard 的 System F）中的多态类型具有一个显著的特点：它们**强烈限制**了程序的行为。这种限制使得我们可以**仅凭类型信息推导出程序的某些性质**，而无需深入了解程序的具体实现。我们来详细讲解这一现象及其重要性。

#### 参数性 (Parametricity) 的基本思想

多态类型的一个令人惊叹的性质是，通过知道一个表达式的类型，我们可以推导出关于它的行为的有用定理，而不必查看具体的代码。这就是 **参数性** 的力量。

##### 示例 1：类型为 ∀(t.t → t) 的表达式

设想我们有一个表达式 $i$，它的类型为：
$$
i : ∀(t.t \to t)
$$
这意味着 $i$ 是一个多态函数，它接受一个类型参数 $t$，然后接受一个类型为 $t$ 的输入，返回一个类型为 $t$ 的值。

**推导过程**：
- 当我们将 $i$ 应用于某个类型 $\tau$ 和一个类型为 $\tau$ 的参数时，$i$ 必须返回一个 $\tau$ 类型的值。
- 由于 $t$（即 $\tau$）直到 $i$ 被调用时才确定，因此在 $i$ 被调用之前，$i$ 对这个类型一无所知。
- **结论**：由于 $i$ 无法对类型 $t$ 的内容做任何假设，它唯一能做的就是返回传入的参数。

因此，任何类型为 $\forall(t.t \to t)$ 的表达式 **必须** 是**恒等函数**（identity function），即：
$$
\Lambda(t. \lambda(x:t). x)
$$

##### 示例 2：类型为 ∀(t.t → t → t) 的表达式

现在我们看另一个类型为 $\forall(t.t \to t \to t)$ 的表达式 $b$。这意味着 $b$ 是一个多态函数，接受类型 $t$，然后接受两个类型为 $t$ 的参数，返回一个类型为 $t$ 的值。

**推导过程**：
- 当 $b$ 被应用于两个参数时，它必须返回一个类型为 $t$ 的值。
- 由于 $b$ 对于 $t$ 的内容没有任何了解，它无法对两个参数做出其他操作。
- **结论**：$b$ 唯一可以做的就是返回其中一个参数。因此，$b$ 必须是以下两种情况之一：
  - 返回第一个参数：$b = \Lambda(t. \lambda(x:t). \lambda(y:t). x)$
  - 返回第二个参数：$b = \Lambda(t. \lambda(x:t). \lambda(y:t). y)$

##### 总结

这些推导结果非常有趣，因为我们仅通过表达式的类型（即 **$\forall(t.t \to t)$** 和 **$\forall(t.t \to t \to t)$**）推导出了这些表达式的行为，而**完全不需要**了解它们的具体实现。

#### 参数性带来的“免费定理” (Free Theorems)

**参数性理论 (Parametricity Theory)** 提供了一种工具，使得我们能够仅通过了解程序的类型，推导出程序行为的某些性质。这些定理被称为 **“免费定理” (Free Theorems)**，因为它们不需要进行任何复杂的程序分析或验证，而是由类型系统自动推导得出的。

例如，针对类型 $\forall(t.t \to t)$ 的表达式，我们自动知道它是恒等函数；对于类型 $\forall(t.t \to t \to t)$ 的表达式，我们知道它要么返回第一个参数，要么返回第二个参数。这些都是 **“免费”** 的，因为只要表达式具有这些类型，参数性就足以限制它们的行为。

#### 参数性的重要性

**参数性** 带来了以下几点好处：
1. **代码的正确性**：参数性理论告诉我们，一个程序只要类型正确，它就很有可能按预期执行。类型系统的约束排除了大量潜在的错误，因此满足类型检查可以成为程序正确性的充分条件。
2. **排除错误行为**：由于参数性限制了程序的行为，具有相同类型的程序之间很难有未预期的行为。因此，参数性大大减少了编写代码时常见的错误。
3. **抽象类型的表示独立性**：参数性还保证了抽象类型的**表示独立性 (Representation Independence)**，这在第 21 章会进一步讨论。

#### 结论

参数性通过限制程序在多态类型下的行为，为编写正确和高效的程序提供了强有力的保障。它使得我们能够从类型本身推导出程序的某些行为，而无需了解其具体实现，这在程序验证和抽象数据类型的处理中尤为重要。

参数性不仅仅是理论上的成果，它对编程语言设计，特别是多态类型系统的设计，有着深远的影响。

### ---------------------------------

### 20.4 受限多态形式 (Restricted Forms of Polymorphism)

在本节中，我们将简要探讨几种比 L{→∀} 表达能力更弱的受限多态形式。这些形式通过对类型的量化进行限制，从而减少了 L{→∀} 的完整表达能力。我们主要通过以下两种方式来获得这些受限形式：

1. **限制类型量化** (Restricting Type Quantification)：
   - 这种方法要求对未量化的类型进行限制，也就是说，我们不允许类型量化器 $\forall$ 出现在某些类型表达式的某些位置。这通常限制了多态函数的定义，使其只能够处理特定的类型，而非泛型类型。
   
2. **限制量化符的出现** (Restricting the Occurrence of Quantifiers)：
   - 此方法限制了量化符（即 $\forall$）在类型表达式中的出现方式。例如，量化符可能只能出现在类型表达式的最外层，或者我们可能限制量化符嵌套的深度。这种限制方式进一步削弱了类型系统的多态表达能力。

我们来更详细地解释这两种限制的方式，并看看它们在编程语言中的具体体现。

---

#### 1. 限制类型量化 (Restricting Type Quantification)

在完整的 L{→∀} 系统中，类型量化器 $\forall$ 可以出现在类型的任意位置，使我们能够定义非常强大的多态函数。例如，我们可以写出这样一个完全泛型的多态类型：

$$
\forall t_1. \forall t_2. (t_1 \to t_2)
$$

这个类型表示一个可以接受任意两个类型 $t_1$ 和 $t_2$ 的泛型函数。然而，若我们对量化器进行限制，例如只允许对未量化的类型进行操作，则我们只能编写针对具体类型的函数。

**示例**：假设我们限制 $\forall$ 只能作用于基本类型 $int$ 或 $bool$。在这种情况下，我们可以定义一个接受 $int$ 和 $bool$ 类型的多态函数，但不能再定义泛型的函数：

$$
\forall t_1 \in \{int, bool\}. (t_1 \to t_1)
$$

这会限制我们只能处理特定类型的输入，而不能处理所有类型的输入。因此，函数的多态性被削弱了。

---

#### 2. 限制量化符的出现 (Restricting the Occurrence of Quantifiers)

另一种方式是限制量化符 $\forall$ 出现在类型表达式中的位置。例如，我们可以规定量化符只能出现在类型表达式的最外层，而不能嵌套出现在函数类型的内部。

**示例**：考虑下面的类型：

$$
\forall t_1. (t_1 \to \forall t_2. (t_2 \to t_1))
$$

这个类型表示一个函数，它接受任意类型 $t_1$ 的输入，并返回一个多态函数，而该多态函数又接受另一个类型 $t_2$ 的输入，最后返回 $t_1$ 的值。如果我们禁止量化符嵌套，则这样的类型将不被允许。

我们可以进一步限制多态类型的深度，例如只允许 $\forall$ 出现在某个固定的深度，或者规定量化符只能出现在最外层的类型定义中。这种方式限制了多态性，使得类型系统无法表示更复杂的泛型函数。

---

### 受限多态的实际应用

受限多态形式在编程语言的设计中起着重要作用，尤其是在需要平衡**表达能力**与**类型检查效率**时。例如，Haskell 中的**秩限制多态**（Rank-N Polymorphism）就是一种通过限制量化符嵌套深度来提高类型推导效率的策略。类似地，Java 的泛型系统也对多态类型的使用进行了限制，确保类型安全的同时保持了编译器的可行性。

#### 受限多态形式的好处：
- **简化类型检查**：由于限制了多态的复杂性，类型检查器可以更高效地处理类型推导，从而提高编译效率。
- **保证类型安全**：通过限制多态类型的使用范围，可以防止编写过于复杂或难以理解的代码，从而提高程序的可维护性。

---

### 总结

受限多态形式通过对类型量化的使用进行不同程度的限制，削弱了 L{→∀} 系统的表达能力。尽管这种削弱减少了多态性的灵活性，但它在编程语言的实际应用中具有重要价值，可以提高类型检查的效率和程序的可维护性。

不同语言对多态性的限制程度各不相同，这些受限形式帮助编译器在保持多态能力的同时，提高了编程语言的类型安全性。

### ---------------------------------

### 20.4.1 **限定性片段** (Predicative Fragment)

L{→∀} 语言的非凡表达能力很大程度上来源于它能够使用多态类型进行实例化，即允许一个多态类型应用另一个多态类型的实例。这种能力被称为 **非限定性** (impredicativity)，即 L{→∀} 允许 **非限定性（类型）量化**。这种特性具有很强的表达能力，但同时也带来了较大的复杂性。

### Impredicativity 和 Circularity

在解释 **非限定性** 的时候，最关键的是理解它包含一种“循环性”（**circularity**）。简单来说，非限定性允许类型表达式中的量化类型在实例化时可以包括自身。这种自我引用的性质使得类型系统具有高度的表达能力。

#### 示例分析

我们来看一个具体的例子。假设我们定义一个多态类型 $\tau$：

$$
\tau = \forall(t. t \to t)
$$

并且假设 $e: \tau$，我们可以将 $e$ 应用于它自己的类型 $\tau$，得到 $e[\tau]$。此时 $e[\tau]$ 的类型为：

$$
\tau \to \tau = \forall(t. t \to t) \to \forall(t. t \to t)
$$

这意味着我们将一个多态函数应用到了一个类型，该类型本身又是多态的。这种类型的实例化使得类型的表达式逐渐增大，甚至可以循环应用下去。例如，我们还可以继续将 $e[\tau]$ 再次应用到 $e$，得到 $e[\tau](e)$，其类型再次变回 $\tau$，即：

$$
e[\tau](e): \tau
$$

这个例子清楚地展示了**非限定性多态**的循环性：函数可以作用于它自己的类型，这种行为导致类型的表达在某些场景下会无限扩展。

---

### Predicativity 和 限定性量化

为了与非限定性形成对比，我们引入 **限定性多态** (predicativity)，即**限定性量化** (predicative polymorphism)。在限定性量化中，多态类型的实例化只能使用未量化的类型。这种约束消除了类型系统中的自我引用，降低了表达能力的同时，也减少了系统的复杂性。

#### 限定性多态的特性

在限定性量化的系统中，当我们进行多态类型的实例化时，实例化结果的量化层数会减少。例如，考虑以下类型表达式：

$$
\forall(t. t \to t)
$$

在限定性多态的系统中，我们只能用**未量化类型**（即不包含 $\forall$ 的类型）来实例化这个类型。例如我们可以用类型 $u \to u$ 来替换 $t$，得到实例化后的类型：

$$
(u \to u) \to (u \to u)
$$

注意，虽然实例化后的类型可能会在符号数量上变大，但它在量化层次上是**更小的**，因为实例化的结果不再包含 $\forall$ 量化符。这就避免了前面提到的“类型循环”和类型表达式无限扩展的问题。

---

### 限定性多态的表达能力限制

与非限定性多态相比，**限定性多态**的表达能力被大大削弱了。在限定性片段中，许多复杂的类型（尤其是递归和自引用类型）无法表示，甚至一些基本类型也无法定义。例如，**自然数**类型在限定性片段中无法定义。

在限定性多态系统中，我们不能将自然数表示为多态的“迭代函数”，因为这种函数的类型中包含了量化符的自我引用，而限定性系统禁止这种情况。因此，限定性多态片段比完整的非限定性多态系统表达能力更弱。

---

### 总结

**非限定性多态**允许类型表达式的实例化中包含自身，这赋予了 L{→∀} 强大的表达能力，但也带来了类型推理的复杂性。相比之下，**限定性多态**通过限制量化符的使用消除了这种自我引用，从而降低了复杂性，但也限制了系统的表达能力，甚至使得像自然数这样的类型也无法表示。

### ---------------------------------

### 20.4.2 **前束片段** (Prenex Fragment)

在多态类型系统中，**前束片段**是一种更为严格的多态形式。在前束片段中，多态只允许出现在最外层（外层量化），即所有的量化符只能出现在类型表达式的最外层，不能出现在类型构造器的参数中。这种限制不仅是**限定性量化** (predicative quantification)，还要求所有的量化符不能嵌套在类型构造器中。这种限制被称为**前束量化** (prenex quantification)。

#### 前束量化的动机

这种限制通常是为了简化类型推断（**type inference**）。在推断过程中，类型推断机制可以通过表达式的使用方式自动恢复被省略的类型注释，而不需要程序员明确地为每个表达式提供类型注释。

虽然我们在这里不深入讨论类型推断机制，但前束片段在多态语言设计中具有重要作用，特别是在构建实际的编程语言时，前束量化简化了类型推断的难度。

---

### 前束片段的定义

**前束片段**是 L{→∀} 的一种受限形式，通常被标记为 L₁{→∀}。在这一片段中，类型被分为两种主要形式：**单态** (monotypes 或 rank-0 types) 和 **多态** (polytypes 或 rank-1 types)。

1. **单态类型** (monotypes): 不涉及任何量化符的类型，可以用来实例化多态类型中的量化符。
2. **多态类型** (polytypes): 包含单态类型，同时允许对单态类型进行量化。

这两种类型通过推导规则来定义，这些规则使用了两类判断：`∆ ` τ mono` 和 `∆ ` τ poly`。在这里，`∆` 是一组有限的假设，它的形式为 `t mono`，表示类型变量 `t` 是单态类型（而不是多态类型）。以下是推导规则的定义：

#### 规则 1: 单态类型的基本规则
$$
\frac{}{\Delta, t \text{ mono} \vdash t \text{ mono}} \tag{20.5a}
$$
这个规则说明，如果 `t` 是一个被声明为单态类型的类型变量，那么它就被认为是单态的。这是单态类型的基本规则。

#### 规则 2: 单态类型的构造
$$
\frac{\Delta \vdash \tau_1 \text{ mono} \quad \Delta \vdash \tau_2 \text{ mono}}{\Delta \vdash \tau_1 \to \tau_2 \text{ mono}} \tag{20.5b}
$$
如果两个类型 $\tau_1$ 和 $\tau_2$ 都是单态类型，那么它们构造出的函数类型 $\tau_1 \to \tau_2$ 也是单态的。这条规则确保了单态类型在函数类型中的闭合性。

#### 规则 3: 从单态到多态
$$
\frac{\Delta \vdash \tau \text{ mono}}{\Delta \vdash \tau \text{ poly}} \tag{20.5c}
$$
如果某个类型 $\tau$ 是单态类型，那么它也可以被认为是多态类型。多态类型包含了单态类型，这是多态性的一个特点。

#### 规则 4: 多态量化规则
$$
\frac{\Delta, t \text{ mono} \vdash \tau \text{ poly}}{\Delta \vdash \forall(t. \tau) \text{ poly}} \tag{20.5d}
$$
如果 $\tau$ 是一个多态类型，并且其中的类型变量 `t` 被声明为单态类型，那么 $\forall(t. \tau)$ 也是一个多态类型。这条规则说明了在多态类型中如何量化单态类型。

---

### 前束片段的限制

在前束片段中，类型量化只允许出现在最外层，而不能嵌套在其他类型构造器中。例如，像 `∀t. (t → t)` 这样的类型是允许的，因为量化符在最外层；但像 `(∀t. t → t) → τ` 这样的类型则不被允许，因为量化符嵌套在函数类型的参数中。

这种限制有助于简化类型推断，但也限制了表达能力。例如，前束片段中不允许递归量化，这使得许多复杂的类型表达式无法表示。尽管如此，前束片段在设计多态语言时非常实用，因为它简化了类型推断，适用于实际编程语言的类型系统。

---

### 总结

**前束片段**通过限制量化符的位置，简化了类型系统的推断过程。它要求量化只能出现在最外层，并且量化只能对单态类型进行。相比 L{→∀} 的全多态系统，前束片段在表达能力上有所受限，但它为构建实际的编程语言提供了更为实用的多态性表达方式。

### ---------------------------------

### 20.4.2 **Base Types and Monotypes in L₁{→∀}**

在 L₁{→∀} 系统中，**基类型** (base types) 和其他类型构造器 (type constructors)，如 **和类型** (sums) 和 **积类型** (products)，被视为**单态类型** (monotypes)。它们扩展了语言的表达能力，同时保持多态性的限制。

---

### **L₁{→∀} 的静态规则**

L₁{→∀} 的静态规则通过推导形式 `∆ Γ ⊢ e : ρ` 来描述，其中 `∆` 包含形式为 `t mono` 的假设，`Γ` 包含形式为 `x : ρ` 的假设，且 `∆ ⊢ ρ poly`。这意味着每个类型要么是单态类型 (monotype)，要么是多态类型 (polytype)，其中单态类型也属于多态类型的一部分。

#### **推导规则**

1. **变量规则**：
   $$
   \frac{}{\Delta \Gamma, x : \tau \vdash x : \tau} \tag{20.6a}
   $$
   这条规则表示：如果在上下文 `Γ` 中，`x` 具有类型 `τ`，那么我们可以直接推导出 `x` 的类型是 `τ`。这个规则类似于其他语言中的变量使用规则。

2. **λ-抽象规则**：
   $$
   \frac{\Delta \vdash \tau_1 \text{ mono} \quad \Delta \Gamma, x : \tau_1 \vdash e_2 : \tau_2}{\Delta \Gamma \vdash \lambda[\tau_1](x.e_2) : \tau_1 \to \tau_2} \tag{20.6b}
   $$
   这个规则表示：如果 `τ_1` 是单态类型 (monotype)，并且在上下文中 `e_2` 是从类型 `τ_1` 到类型 `τ_2` 的函数，那么 λ-抽象 (lambda abstraction) 的类型是 `τ_1 → τ_2`。

3. **函数应用规则**：
   $$
   \frac{\Delta \Gamma \vdash e_1 : \tau_2 \to \tau \quad \Delta \Gamma \vdash e_2 : \tau_2}{\Delta \Gamma \vdash ap(e_1; e_2) : \tau} \tag{20.6c}
   $$
   这条规则表示：如果 `e_1` 是一个从 `τ_2` 到 `τ` 的函数，且 `e_2` 的类型是 `τ_2`，那么 `e_1(e_2)` 的结果类型是 `τ`。这是函数应用的标准规则。

4. **多态抽象规则**：
   $$
   \frac{\Delta, t \text{ mono} \Gamma \vdash e : \tau}{\Delta \Gamma \vdash \Lambda(t.e) : \forall(t.\tau)} \tag{20.6d}
   $$
   该规则描述了多态抽象：如果我们可以在上下文中推导出 `e` 具有类型 `τ`，其中 `t` 是单态类型，那么多态抽象 `Λ(t.e)` 的类型就是 `∀(t.τ)`。

5. **多态应用规则**：
   $$
   \frac{\Delta \vdash \tau \text{ mono} \quad \Delta \Gamma \vdash e : \forall(t.\tau_0)}{\Delta \Gamma \vdash \text{App}[\tau](e) : [\tau/t]\tau_0} \tag{20.6e}
   $$
   这条规则描述了多态应用：如果 `e` 是一个具有类型 `∀(t.τ_0)` 的表达式，并且 `τ` 是一个单态类型，那么 `App[τ](e)` 的结果类型是 `[τ/t]\tau_0`，也就是将类型 `τ` 替换到 `τ_0` 中得到的类型。

---

### **let 构造的扩展**

由于 L₁{→∀} 对多态抽象的限制，全局的 `let` 构造不能通过 λ-抽象直接定义。因此，L₁{→∀} 通常会通过一个原始的 `let` 语句进行扩展，以便能够绑定多态类型的表达式到变量上。

#### **let 语句的静态规则**
$$
\frac{\Delta \vdash \tau_1 \text{ poly} \quad \Delta \Gamma \vdash e_1 : \tau_1 \quad \Delta \Gamma, x : \tau_1 \vdash e_2 : \tau_2}{\Delta \Gamma \vdash \text{let}[\tau_1](e_1; x.e_2) : \tau_2} \tag{20.7}
$$
该规则表示：如果 `e_1` 是一个多态类型 `τ_1` 的表达式，并且在上下文 `Γ` 中，`e_2` 是在绑定了 `x : τ_1` 的情况下具有类型 `τ_2` 的表达式，那么 `let` 构造的结果类型是 `τ_2`。

---

### **示例解释**

一个典型的例子是多态恒等函数的定义：

$$
\text{let } I : \forall(t.t \to t) \text{ be } \Lambda(t.\lambda (x:t) x) \text{ in } I[\tau \to \tau](I[\tau])
$$

这段代码展示了 `let` 绑定多态恒等函数 `I`，然后对其进行多态实例化，应用于一个自函数。这里的类型 `I[\tau \to \tau]` 是 `τ → τ`。通过实例化多态类型，我们可以得到恒等函数的具体实现。

---

### **总结**

L₁{→∀} 的静态系统通过限制多态抽象的范围，简化了类型推断和推导。尽管在多态抽象的表达能力上有所牺牲，但通过增加 `let` 这样的原始构造，它仍然可以灵活地使用多态性，从而更好地适应实际的编程需求。这种片段的设计既保持了多态系统的表达能力，又减少了类型系统的复杂性。

### ---------------------------------

### 20.4.3 Rank-Restricted Fragments (限定等级的多态片段)

在 **L₁{→∀}** 片段中，我们使用单态类型 (monomorphic types) 和多态类型 (polymorphic types) 的二元划分。然而，这种划分可以推广为一个**层次化的语言**，其中多态类型的出现受到与函数类型相关的限制。通过这种方式，我们可以创建一个**层次化的多态系统**，并且这些层次系统之间的关系由 **类型的“等级”** 来定义。

---

### **类型等级的定义**

我们使用形式 $\tau \text{ type } [k]$ 的判断，其中 $k \geq 0$ 表示 $\tau$ 是**等级 $k$** 的类型。

- **等级 0 的类型**：无量化 (quantification)，即没有使用 $\forall$ 的类型。  
- **等级 $k+1$ 的类型**：可能涉及量化，但函数类型的域 (domain) 被限制为等级 $k$。

因此，等级 0 的类型可以视为单态类型，而等级 1 的类型对应于多态类型。

### **规则**

类型的等级通过以下规则递归定义：

1. **类型变量规则**：如果 `t` 是等级 $k$ 的类型变量，那么它也是等级 $k$ 的类型。
   $$
   \frac{}{\Delta, t \text{ type } [k] \vdash t \text{ type } [k]} \tag{20.8a}
   $$

2. **函数类型 (等级 0)**：如果 `τ₁` 和 `τ₂` 都是等级 0 的类型，那么 `arr(τ₁, τ₂)` (即 `τ₁ \to τ₂`) 也是等级 0 的类型。
   $$
   \frac{\Delta \vdash \tau_1 \text{ type } [0] \quad \Delta \vdash \tau_2 \text{ type } [0]}{\Delta \vdash arr(\tau_1, \tau_2) \text{ type } [0]} \tag{20.8b}
   $$

3. **函数类型 (等级 $k+1$)**：如果 `τ₁` 是等级 $k$ 的类型，`τ₂` 是等级 $k+1$ 的类型，那么 `arr(τ₁, τ₂)` 是等级 $k+1$ 的类型。
   $$
   \frac{\Delta \vdash \tau_1 \text{ type } [k] \quad \Delta \vdash \tau_2 \text{ type } [k+1]}{\Delta \vdash arr(\tau_1, \tau_2) \text{ type } [k+1]} \tag{20.8c}
   $$

4. **等级提升规则**：如果 `τ` 是等级 $k$ 的类型，它也是等级 $k+1$ 的类型。这允许我们在不同等级之间扩展类型。
   $$
   \frac{\Delta \vdash \tau \text{ type } [k]}{\Delta \vdash \tau \text{ type } [k+1]} \tag{20.8d}
   $$

5. **量化类型规则**：如果 `τ` 是等级 $k+1$ 的类型，且 `t` 是等级 $k$ 的类型变量，那么 `∀(t.τ)` 是等级 $k+1$ 的类型。
   $$
   \frac{\Delta, t \text{ type } [k] \vdash \tau \text{ type } [k+1]}{\Delta \vdash \forall(t.\tau) \text{ type } [k+1]} \tag{20.8e}
   $$

---

### **Lₖ{→∀} 语言的静态系统**

通过这些规则，我们可以为任意等级 $k$ 定义出一个限制等级的多态语言，称为 **Lₖ{→∀}**，其中的类型限制在等级 $k$ 或以下。这个系统不仅帮助我们理解多态的层次性，还澄清了在 L₁{→∀} 中为何需要原生的定义机制。

#### **λ-抽象规则**

λ-抽象规则中的类型等级受到限制：

1. **等级 0 的 λ-抽象**：
   $$
   \frac{\Delta \vdash \tau_1 \text{ type } [0] \quad \Delta \Gamma, x : \tau_1 [0] \vdash e_2 : \tau_2 [0]}{\Delta \Gamma \vdash \lambda[\tau_1](x.e_2) : arr(\tau_1, \tau_2) [0]} \tag{20.9a}
   $$

   这条规则说明：如果 `τ₁` 和 `τ₂` 都是等级 0 的类型，那么函数类型 `arr(τ₁, τ₂)` 也是等级 0。

2. **等级 $k+1$ 的 λ-抽象**：
   $$
   \frac{\Delta \vdash \tau_1 \text{ type } [k] \quad \Delta \Gamma, x : \tau_1 [k] \vdash e_2 : \tau_2 [k+1]}{\Delta \Gamma \vdash \lambda[\tau_1](x.e_2) : arr(\tau_1, \tau_2) [k+1]} \tag{20.9b}
   $$

   当 `τ₁` 是等级 $k$ 的类型，而 `τ₂` 是等级 $k+1` 时，抽象结果的函数类型是等级 $k+1$。

---

### **总结**

这种限定等级的多态语言有助于减少多态系统的复杂性，同时保持灵活性。通过这种层次化的类型系统，我们可以更好地控制多态类型的复杂度，并避免某些高阶多态带来的复杂推理。这些约束对于实现高效的编译和类型推导系统尤其重要。

### ---------------------------------

### 20.5 Notes

在这一节中，我们讨论了 **System F** 的历史背景以及相关概念的起源。

#### **System F 的起源**
**System F**，也称为**多态 λ 演算 (Polymorphic λ-calculus)**，是由 **Jean-Yves Girard** 于 1972 年首次提出的，最初是在**证明理论 (Proof Theory)** 的背景下进行的研究。与此同时，**John C. Reynolds** 在 1974 年独立地将其引入到**编程语言 (Programming Languages)** 的研究中。尽管两者的背景有所不同，但都在探讨如何通过多态类型 (Polymorphism) 来统一处理各种类型。

#### **参数化 (Parametricity)**
**参数化 (Parametricity)** 的概念最初由 **Christopher Strachey** 提出。他提出的核心思想是，具有多态类型的函数应该对所有类型保持一致的行为。这种行为的一致性为后来的研究奠定了基础。

然而，直到 **John C. Reynolds** 在 1983 年的工作中，参数化的概念才得到了充分的发展。他深入分析了多态类型系统中的参数化特性，并提出了严格的理论基础，帮助我们更好地理解多态类型系统的性质。

#### **“免费的定理” (Theorems for Free)**
**Philip Wadler** 在 1989 年通过一篇名为 “Theorems for Free!” 的论文推广了参数化的应用。他指出，在多态类型系统中，我们可以从类型推导出某些程序的性质，甚至不需要检查其代码。这些推导得来的性质被称为“免费的定理”，因为只要类型正确，程序的行为就会被严格地约束，而不需要进行复杂的验证。这种特性在编写和维护复杂程序时极为有用。

Wadler 通过参数化的原理展示了类型系统的强大之处：**类型不仅仅是程序的静态检查工具，它还能自动推导出程序的某些行为和性质**。这使得多态类型系统成为编程语言理论中的重要组成部分。

### 总结
**System F** 的引入以及 **参数化 (Parametricity)** 的发展，极大地丰富了我们对多态类型系统的理解。它不仅为编程语言的设计提供了理论支持，还展示了类型系统在程序行为预测中的潜力。


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------

[toc]



### **XVIII Equational Reasoning (等式推理)**

等式推理是程序语义学中的一种核心技术，用于证明程序在不同上下文中的等价性。通过研究程序的等式关系，可以帮助我们理解程序的行为、优化程序并确保其正确性。在这一节中，我们将深入讨论等式推理在不同语言模型中的应用，如 $T$ 和 PCF，并探讨与等式相关的其他重要概念，如观察等价（observational equivalence）、逻辑等价（logical equivalence）、参数多态性（parametricity）、以及过程等价（process equivalence）。

---

### **1. Equational Reasoning for T (针对 $T$ 的等式推理)**

#### **1.1 Observational Equivalence (观察等价)**

**观察等价**用于描述两个程序在所有上下文中表现相同的行为。换句话说，如果我们将两个程序放入任何相同的上下文中，它们的输出总是相同的，那么这两个程序就是观察等价的。观察等价在等式推理中是非常重要的概念，尤其是在优化和程序重构时，用来证明程序重写不会改变其行为。

#### **1.2 Logical Equivalence (逻辑等价)**

**逻辑等价**指的是两个程序在逻辑上满足相同的性质，通常基于程序的逻辑语义进行定义。它通过逻辑公式来描述程序的行为，如果两个程序在所有可能的输入下都满足相同的逻辑性质，那么它们就是逻辑等价的。

#### **1.3 Logical and Observational Equivalence Coincide (逻辑等价和观察等价的统一)**

对于某些语言（如 $T$ 和 PCF），**逻辑等价**和**观察等价**在很多情况下是一致的。这意味着，如果两个程序是观察等价的，它们也会在逻辑上等价，反之亦然。这种一致性帮助我们统一了两种推理方法，可以同时利用逻辑和观察视角来证明程序等价性。

#### **1.4 Some Laws of Equality (等式的一些法则)**

等式推理依赖于一些基础的等式法则，如：
- **反身性**：$P = P$。
- **对称性**：如果 $P = Q$，则 $Q = P$。
- **传递性**：如果 $P = Q$ 且 $Q = R$，则 $P = R$。

这些法则是等式推理的基础，可以用来在程序优化和等式证明中推导新的等式。

---

### **2. Equational Reasoning for PCF (针对 PCF 的等式推理)**

**PCF** 是一种简单的递归函数式编程语言，等式推理在其中非常重要，尤其是在验证程序的正确性和优化方面。

#### **2.1 Observational Equivalence (观察等价)**

在 PCF 中，观察等价表示如果两个程序在所有上下文中都有相同的结果，则它们是等价的。这个概念在程序优化中尤其重要，帮助我们确保不同的程序重写不会影响最终的输出。

#### **2.2 Logical Equivalence (逻辑等价)**

PCF 中的逻辑等价与 $T$ 中的定义相同。程序在逻辑上等价意味着它们满足相同的逻辑语义。

#### **2.3 Logical and Observational Equivalence Coincide (逻辑等价和观察等价的统一)**

和 $T$ 一样，PCF 中逻辑等价和观察等价通常是一致的。这为程序推理提供了强大的工具，使得我们可以通过等式推导确保程序在不同上下文中的正确性。

#### **2.4 Compactness (紧致性)**

**紧致性**是等式推理中的另一个重要概念，特别是在无穷结构中。紧致性原理保证如果程序在有限的上下文中是等价的，那么它们在所有上下文中也是等价的。这一特性帮助我们简化等式推理，避免需要枚举所有可能的上下文。

#### **2.5 Co-Natural Numbers (余自然数)**

**余自然数**是 PCF 中的一个高级概念，用于处理潜在无限的计算。余自然数通过协递归（corecursion）来定义，支持无限数据结构，如流（stream）和无限递归的自然数序列。余自然数使得等式推理更复杂，因为它们允许程序在理论上永远不停止计算。

---

### **3. Parametricity (参数多态性)**

**参数多态性** 是指程序可以在多种不同类型下工作，而不依赖于具体的类型。这种性质不仅允许程序具有更多的通用性，也保证了程序在不同类型的上下文中表现一致。

#### **3.1 Overview (概述)**

参数多态性在很多编程语言中是一项重要的特性，尤其是函数式语言。通过定义类型参数，程序可以在多个类型下工作。

#### **3.2 Observational Equivalence (观察等价)**

在参数多态性下，观察等价不仅仅适用于程序的特定实例，还要对不同类型的实例都保持等价性。即使在不同类型的上下文中，参数多态程序的行为也必须保持一致。

#### **3.3 Logical Equivalence (逻辑等价)**

逻辑等价在参数多态性下同样适用。对于多态程序，它必须在不同类型的上下文中都满足相同的逻辑性质。

#### **3.4 Parametricity Properties (参数多态性的性质)**

参数多态性具有一些特殊性质，最著名的性质是**表示独立性（representation independence）**。表示独立性意味着即使我们改变某个数据结构的表示，只要保持其接口不变，程序的行为也不应该改变。

#### **3.5 Representation Independence, Revisited (表示独立性的重访)**

表示独立性确保程序在处理多态数据时，不依赖于底层实现的具体表示。对于等式推理来说，这一点尤为重要，因为它保证了程序的通用性和鲁棒性。

---

### **4. Process Equivalence (过程等价)**

**过程等价**研究的是如何定义和证明并发系统中的等价性。

#### **4.1 Process Calculus (过程演算)**

**过程演算**是用来建模并发系统的一种数学工具。在过程演算中，程序的执行被视为不同进程之间的通信和同步。

#### **4.2 Strong Equivalence (强等价)**

**强等价**是指两个进程的行为在所有情况下都是完全相同的。如果两个进程无论在何种情况下都具有相同的通信和同步行为，它们就是强等价的。

#### **4.3 Weak Equivalence (弱等价)**

**弱等价**则允许某些行为的细节被忽略，关注于进程的主要行为。在弱等价下，某些中间步骤可能被忽略，只要最终的效果是一致的，进程就可以被认为是等价的。

---

### **总结**

**等式推理**是一种强大的工具，用来证明程序在不同上下文中的等价性。无论是观察等价、逻辑等价，还是参数多态性和过程等价，它们都为程序优化、验证和理解提供了关键的理论基础。在不同的编程语言中，这些等价性的概念有助于提升程序的正确性、可维护性和性能优化的可能性。

通过这些理论工具，我们可以将程序中的等价关系形式化，证明程序的优化和重构不会影响其正确性，同时理解复杂并发系统中的进程等价。

### ---------------------------------

### **46 Equality for System T (系统 T 中的等式)**

在函数式编程语言中，等式推理是与数学推理紧密相关的。在系统 T 中，表达式的等价性可以通过数学方法来证明和推理。这一节探讨了函数等价的两种主要概念：**观察等价**和**逻辑等价**，并展示了它们在特定上下文中如何重合。

在系统 T 中，虽然某些表达式看似不同，但通过数学推导，它们可能是**等价的**。例如，**加法的交换性**就意味着 `λ (x : nat) λ (y : nat) plus(x)(y)` 和 `λ (x : nat) λ (y : nat) plus(y)(x)` 是等价的。尽管这两者在形式上不同，但它们的计算结果是相同的。 

接下来，我们详细解释系统 T 中的不同等价性概念，以及相关的定律。

---

### **46.1 Observational Equivalence (观察等价)**

**观察等价**是指两个函数在任何上下文中都表现相同的行为。在函数式语言中，如果两个函数在所有输入上产生相同的结果，则它们是观察等价的。

例如，考虑以下两个函数：

1. `f(x, y) = plus(x)(y)`  
2. `g(x, y) = plus(y)(x)`

虽然 `f` 和 `g` 的定义形式不同，但它们的行为是一致的：在任何相同的输入下，它们的输出是一样的。因此，`f` 和 `g` 是**观察等价的**。这意味着可以在任何程序中相互替换这两个函数，而不会影响程序的行为。

#### **例子**：
```haskell
f = \x \y -> x + y
g = \x \y -> y + x
-- f 和 g 对任何输入都产生相同的结果，所以它们是观察等价的。
```

这种等价性依赖于我们如何**观察**函数的行为，而不是其内部实现。因此，只要两个函数在任何情况下表现一致，它们就是观察等价的。

---

### **46.2 Logical Equivalence (逻辑等价)**

**逻辑等价**指的是两个函数在逻辑上满足相同的性质。具体而言，如果两个函数在相同输入下产生相同的输出，则它们是逻辑等价的。逻辑等价与观察等价的不同在于，逻辑等价的证明通常涉及**推理**和**演绎**。

举例来说，若两个函数 $f$ 和 $g$ 对任何输入 $x$，$y$ 都满足 $f(x, y) = g(x, y)$，则它们是逻辑等价的。这不仅需要通过观察结果来验证，还要通过逻辑推理证明它们在所有情况下都等价。

#### **例子**：

在 `T` 中，函数 `f(x, y)` 和 `g(x, y)` 可以通过逻辑推导证明它们是逻辑等价的：
1. $f(x, y) = plus(x, y)$
2. $g(x, y) = plus(y, x)$

通过推导加法的交换性可以证明，$f$ 和 $g$ 的结果总是相等的，因此它们是逻辑等价的。

---

### **46.3 Logical and Observational Equivalence Coincide (逻辑等价和观察等价的统一)**

在系统 T 的变体中，当自然数类型的**后继函数**以**贪婪求值（eager evaluation）**的方式计算时，逻辑等价和观察等价是相同的。这意味着，对于每对逻辑等价的函数，它们在任何上下文中都将表现一致。因此，在这种情境下，**逻辑等价**和**观察等价**重合了。

换句话说，逻辑推导和观察行为都指向相同的等价性结论。在函数式编程中，这种一致性确保了程序在不同上下文中的一致行为，简化了函数等价性的验证和推理过程。

#### **例子**：
假设有两个函数 `f(x, y)` 和 `g(x, y)`，如果通过推理可以证明它们是逻辑等价的，那么在 T 的上下文中，它们也是观察等价的。这为我们提供了一个统一的推理框架，既可以通过逻辑证明等价性，也可以通过观察验证等价性。

---

### **46.4 Some Laws of Equality (等式的基本法则)**

系统 T 中的等式推理依赖于一组基本的等式法则。这些法则允许我们在推导过程中使用通用的数学规则来证明两个函数或表达式的等价性。

#### **46.4.1 General Laws (通用法则)**

- **反身性（Reflexivity）**：$f = f$。任何函数或表达式都是与自身等价的。
- **对称性（Symmetry）**：如果 $f = g$，则 $g = f$。等价性是对称的。
- **传递性（Transitivity）**：如果 $f = g$ 且 $g = h$，则 $f = h$。等价性是可传递的。

#### **46.4.2 Equality Laws (等式法则)**

- **函数等价的替换规则**：如果两个函数在所有输入上都相同，则可以在程序中任意替换这两个函数，而不改变程序的行为。
- **柯里化函数的等价性**：对于任何函数 $f$ 和 $g$，如果 $f(x) = g(x)$ 对所有 $x$ 都成立，则 $\lambda x.f(x) = \lambda x.g(x)$。

#### **46.4.3 Induction Law (归纳法则)**

在处理自然数时，归纳法则提供了证明函数等价的强有力工具。通过归纳，我们可以证明函数在**基底情况**和**归纳步骤**下的等价性。这通常用于递归定义的函数中。

---

### **46.5 Notes (附注)**

这一节总结了系统 T 中等式推理的重要性，并指出了函数式编程语言中等式推理与数学推理的紧密联系。程序中的函数等价性不仅可以通过逻辑推导来证明，还可以通过观察行为进行验证。在某些上下文中，逻辑等价与观察等价是统一的，这简化了推理过程。

---

### **总结**

系统 T 中的等式推理为我们提供了一种系统化的方式来验证和推导程序中的函数等价性。通过**观察等价**和**逻辑等价**，我们可以确保程序在不同上下文中的一致行为。两者的统一性在某些情况下进一步简化了验证过程。通过归纳法则和基本等式法则，函数等价性得以在更广泛的应用场景中证明和应用。

等式推理是函数式编程语言的核心工具之一，它为优化、重构和验证程序提供了理论基础，确保程序行为的正确性和一致性。

### ---------------------------------

### **46.1 观察等价 (Observational Equivalence)**

#### **等价表达式的定义**

何时两个表达式是等价的？直观上，当我们**无法区分**它们时，我们可以认为它们是等价的。虽然这种说法听起来像是陈词滥调，但其实它揭示了等价性背后的本质：我们用来区分表达式的方法决定了等价的标准。关键在于：我们允许通过什么样的“实验”来区分表达式？如果实验的结果在两种表达式下不同，那么我们可以确定它们是不同的。

**等式推理**中，允许我们关注表达式的语法细节时，只有很少的表达式可以被认为是等价的。例如，如果我们认为函数应用次数的不同或者是否包含 $\lambda$ 抽象是重要的区分标准，那么很少有表达式能够被认为是等价的。然而，这种考虑方式显然与我们直觉上的理解相悖——我们通常认为表达式的意义在于它们对最终计算结果的贡献，而不是它们获取结果的方式。

**总结**：
- **表达式的等价性**应该基于它们对整个程序结果的贡献，而不是它们的形式。
- **观察等价**：如果两个表达式在任何上下文中都表现一致，则它们是观察等价的。

#### **完整程序的定义**

我们需要明确“完整程序”的含义。根据以下两点，可以定义什么是完整程序：
1. **T 的动态语义**只对没有自由变量的表达式定义，因此，完整程序必须是一个**闭合表达式**。
2. 计算的结果必须是可观测的，因此我们定义完整程序是一个**自然数类型**的闭合表达式，它的可观测行为是它计算到的自然数结果。

**解释**：
- **闭合表达式**：没有自由变量的表达式，也就是在其作用域内所有变量都已绑定。
- **可观测行为**：程序执行到自然数结果的过程。

#### **表达式上下文与替换**

一个表达式上下文是指一个表达式中存在一个“空洞”，这个空洞可以被其他表达式填充。这个空洞可以出现在任何位置，包括在绑定符号的作用范围内。通过在上下文中的“空洞”进行替换，可以将新的表达式插入该上下文。

上下文中的替换表示将表达式 $e$ 放入上下文 $C$ 的空洞中，用 $C\{e\}$ 表示这种替换操作。关键是，$e$ 中的自由变量会被 $C$ 捕获，这意味着这种替换不同于**变量替换**，后者会避免变量捕获。

**例子**：
假设有上下文 $C = \lambda (x : nat) \cdot$，表达式 $e = x + x$，那么替换后的结果为：
$$
C\{e\} = \lambda (x : nat) (x + x)
$$
在这个例子中，$e$ 中的自由变量 $x$ 被 $\lambda$ 抽象捕获。

---

#### **公式解释**

我们引入了表达式上下文 $C$ 及其替换操作 $C\{e\}$。替换的关键在于，如果上下文 $C$ 是一个程序上下文（即闭合表达式上下文），那么替换后的结果也是一个完整程序，当且仅当 $e$ 的自由变量全部被捕获。

表达式上下文的类型推断规则扩展了系统 $T$ 的静态语义，定义如下：
$$
C : (\tau_1 \to \tau_2) \quad e : \tau_1 \vdash C\{e\} : \tau_2
$$
这意味着如果表达式上下文 $C$ 的类型为 $\tau_1 \to \tau_2$，且表达式 $e$ 的类型为 $\tau_1$，那么替换后的表达式 $C\{e\}$ 的类型为 $\tau_2$。

#### **静态推导树**：

通过上下文 $C$ 的类型推断规则，我们可以构建如下的推导树：

$$
\frac{}{\text{空洞：$C\{ \cdot \}$}}
$$
$$
\quad \frac{\frac{}{\text{空洞：$C\{ \cdot \}$}} \quad \frac{}{\text{表达式 $e$ 类型推断}}}{\text{替换后：$C\{e\}$ 的类型推导}}
$$
通过这种推导，我们可以确认表达式上下文的静态语义。

---

#### **表达式上下文的组合**

表达式上下文是可以**组合**的。例如，假设我们有两个上下文 $C_1$ 和 $C_2$，那么可以将它们组合成新的上下文：
$$
C\{ \cdot \} = C_1\{C_2\{ \cdot \}\}
$$
这意味着表达式 $e$ 的替换可以按顺序嵌套进行：
$$
C\{e\} = C_1\{C_2\{e\}\}
$$
这种组合性使得我们可以灵活地构建复杂的上下文，并在其中进行多层次的替换操作。

**例子**：
若 $C_1 = \lambda y \cdot$ 且 $C_2 = \lambda x \cdot$，那么组合后的上下文可以表示为：
$$
C_1\{C_2\{\cdot\}\} = \lambda y \lambda x \cdot
$$
然后将表达式 $e$ 替换进去：
$$
C_1\{C_2\{e\}\} = \lambda y \lambda x e
$$

---

#### **总结**：

- **观察等价**：两个表达式在任何上下文中的表现都相同，称它们是观察等价的。
- **上下文替换**：通过表达式上下文和替换，可以验证表达式在不同环境下的行为。
- **类型推导规则**：表达式上下文的类型推导可以扩展 $T$ 的静态语义，确保替换后的表达式类型一致。

通过观察等价和替换上下文的概念，我们能够形式化地分析和证明表达式的等价性。

### ---------------------------------

### **推导解释**

在这一部分中，我们探讨了如何将表达式 $e$ 替换到表达式上下文 $C$ 中，并推导出其类型。在系统 T 中，静态类型推导基于特定的规则，这些规则决定了上下文中的表达式如何与其他表达式组合并保持类型一致性。

我们将一一解释这些规则，逐步推导，并详细讲解每个公式中的符号及其意义。

---

### **公式 46.1a**

$$
\frac{}{\circ : (\tau \to \tau)}
$$

#### **解释**：
- **符号 $\circ$**：表示一个空洞上下文，可以被任意表达式替换。它的作用是占位符。
- **$\tau \to \tau$**：表示上下文从类型 $\tau$ 映射到类型 $\tau$，即任何类型为 $\tau$ 的表达式可以插入这个空洞，替换后得到类型为 $\tau$ 的新表达式。

**解释**：这是基本的上下文规则，表示一个“空洞”上下文本身是一个身份映射（identity map）。你可以将任意类型为 $\tau$ 的表达式填入其中，结果仍然保持类型 $\tau$。

---

### **公式 46.1b**

$$
\frac{C : (\tau \to \tau) \quad}{s(C) : (\tau \to nat)}
$$

#### **解释**：
- **$C$**：是一个表达式上下文，其类型从 $\tau$ 到 $\tau$。
- **$s(C)$**：表示一个新的上下文，它将上下文 $C$ 包装起来并进行某种变换。变换后的上下文的类型从 $\tau$ 到 $nat$。

**解释**：此规则表明，在某些上下文中，对 $C$ 进行封装可以将其结果类型从 $\tau$ 转换为 $nat$。这通常发生在递归或类型转换的场景中。

---

### **公式 46.1c**

$$
\frac{C : (\tau \to \tau) \quad e_0 : \tau \quad x : nat, y : \tau \vdash e_1 : \tau}{rec C \{ z \to e_0 | s(x) \ with\ y \to e_1 \} : (\tau \to \tau)}
$$

#### **解释**：
- **$rec$**：是递归的标记，表示在上下文 $C$ 中执行递归操作。
- **$z \to e_0$** 和 **$s(x) \ with\ y \to e_1$**：表示递归的基底情况和递归步骤。
- **$e_0$** 是当 $z$ 为零时的结果，**$e_1$** 是递归情况的结果。

**解释**：这一推导规则用于描述递归操作的类型推导。在上下文 $C$ 中，递归处理两个表达式：一个用于基底情况（$e_0$），另一个用于递归调用（$e_1$）。通过这个规则，我们可以确保递归操作在不同的输入下类型一致。

---

### **公式 46.1d**

$$
\frac{e : nat \quad C_0 : (\tau \to \tau) \quad x : nat, y : \tau \vdash e_1 : \tau}{rec e \{ z \to C_0 | s(x) \ with\ y \to e_1 \} : (\tau \to \tau)}
$$

#### **解释**：
- **$e$**：是一个自然数表达式，它作为递归的输入。
- **$C_0$**：是递归的基底情况上下文，其类型从 $\tau$ 到 $\tau$。
- **$x$ 和 $y$**：表示递归中的参数变量，$e_1$ 是递归调用中的表达式。

**解释**：这个规则和之前类似，但这里递归基于一个自然数 $e$。在这种情况下，递归的基底情况由上下文 $C_0$ 决定，递归步骤通过 $e_1$ 和变量 $x$，$y$ 进行处理。

---

### **公式 46.1e**

$$
\frac{e : nat \quad e_0 : \tau \quad C_1 : (\tau \to (\tau \times \tau))}{rec e \{ z \to e_0 | s(x) \ with\ y \to C_1 \} : (\tau \to \tau)}
$$

#### **解释**：
- **$e$**：是一个自然数表达式。
- **$e_0$**：是递归的基底情况，其类型为 $\tau$。
- **$C_1$**：是一个上下文，其类型为 $\tau \to (\tau \times \tau)$，表示递归调用的结果是一个类型为 $\tau$ 的二元组。

**解释**：在此规则中，递归操作会生成一个包含两个部分的结果，递归调用中会返回一个二元组。这一规则确保即使在处理复杂类型（如二元组）时，递归过程也可以保持类型一致。

---

### **公式 46.1f**

$$
\frac{C_2 : (\tau \to (\tau_1 \times \tau_2))}{\lambda (x : \tau_1) C_2 : (\tau \to (\tau_1 \to \tau_2))}
$$

#### **解释**：
- **$C_2$**：是一个上下文，其类型从 $\tau$ 到 $\tau_1 \times \tau_2$。
- **$\lambda (x : \tau_1)$**：是一个 $\lambda$ 抽象，将类型为 $\tau_1$ 的变量 $x$ 应用于上下文 $C_2$。

**解释**：这个推导规则说明了如何将一个上下文转换为一个函数。通过 $\lambda$ 抽象，我们可以将一个二元组类型的结果转换为一个从 $\tau_1$ 到 $\tau_2$ 的函数。

---

### **公式 46.1g**

$$
\frac{C_1 : (\tau \to (\tau_2 \to \tau)) \quad e_2 : \tau_2}{C_1(e_2) : (\tau \to \tau)}
$$

#### **解释**：
- **$C_1$**：是一个上下文，其类型为从 $\tau$ 到 $\tau_2 \to \tau$ 的映射。
- **$e_2$**：是一个类型为 $\tau_2$ 的表达式，作为 $C_1$ 的输入。

**解释**：在此推导中，将表达式 $e_2$ 替换到上下文 $C_1$ 中，并得到一个结果类型为 $\tau$ 的表达式。此规则保证了通过这种替换，类型推导保持一致。

---

### **公式 46.1h**

$$
\frac{e_1 : (\tau_2 \to \tau) \quad C_2 : (\tau \to \tau_2)}{e_1(C_2) : (\tau \to \tau)}
$$

#### **解释**：
- **$e_1$**：是一个从 $\tau_2$ 到 $\tau$ 的函数。
- **$C_2$**：是一个上下文，其类型为 $\tau \to \tau_2$。

**解释**：这一规则表示可以将 $C_2$ 作为输入传递给 $e_1$，最终得到类型为 $\tau$ 的结果。这个过程实际上是函数组合的一个例子，两个函数通过上下文进行组合，从而保持类型的一致性。

---

### **总结**

- 每个公式展示了如何通过表达式上下文和类型推导规则，保持表达式在不同环境下的类型一致性。
- 递归操作和 $\lambda$ 抽象的引入，使得表达式上下文可以更加灵活地组合和替换。
- 这些规则确保系统 T 中的表达式在递归、函数应用、上下文替换等场景下，能够始终保持正确的类型。

### ---------------------------------

### **逐条详解**

---

### **Lemma 46.1**

**命题**：如果 $C : (\Gamma * \tau) \to (\Gamma' * \tau')$，那么 $\Gamma' \subseteq \Gamma$，且如果 $\Gamma \vdash e : \tau$，则 $\Gamma' \vdash C\{e\} : \tau'$。

#### **解释**：

- **上下文 $C$** 的类型为从 $\Gamma$ 到 $\Gamma'$，并且从类型 $\tau$ 到类型 $\tau'$。
- **$\Gamma'$ 是 $\Gamma$ 的子集**：意味着在 $C$ 中，目标上下文 $\Gamma'$ 中的变量都是源上下文 $\Gamma$ 中的一部分，这保证了在进行上下文替换时，不会出现未定义的变量。
- **替换结果的类型**：如果表达式 $e$ 在上下文 $\Gamma$ 中具有类型 $\tau$，那么替换操作 $C\{e\}$ 后，结果在上下文 $\Gamma'$ 中具有类型 $\tau'$。

##### **公式解释**：
$$
\frac{C : (\Gamma * \tau) \to (\Gamma' * \tau') \quad \Gamma \vdash e : \tau}{\Gamma' \vdash C\{e\} : \tau'}
$$

这条推导规则表明，在替换操作完成后，替换后的表达式依然保持类型一致性。

#### **总结**：
该引理说明了上下文替换时类型和上下文的约束关系，并确保替换不会导致类型或自由变量错误。

---

### **Lemma 46.2**

**命题**：如果 $C : (\Gamma * \tau) \to (\Gamma' * \tau')$ 且 $C' : (\Gamma' * \tau') \to (\Gamma'' * \tau'')$，则 $C'\{C\{\circ\}\} : (\Gamma * \tau) \to (\Gamma'' * \tau'')$。

#### **解释**：

- **上下文组合**：这里描述了如何组合两个上下文。首先我们有 $C$ 从 $\Gamma$ 到 $\Gamma'$，然后 $C'$ 从 $\Gamma'$ 到 $\Gamma''$。组合后，整个上下文将从 $\Gamma$ 到 $\Gamma''$，并且类型从 $\tau$ 到 $\tau''$。
- **$\circ$ 占位符**：这里的 $\circ$ 是一个空洞，占位符，表示最终会被替换的表达式。

##### **公式解释**：
$$
\frac{C : (\Gamma * \tau) \to (\Gamma' * \tau') \quad C' : (\Gamma' * \tau') \to (\Gamma'' * \tau'')}{C'\{C\{\circ\}\} : (\Gamma * \tau) \to (\Gamma'' * \tau'')}
$$

这一推导表明，上下文的组合是封闭的，组合后的上下文可以看作一个从 $\Gamma$ 到 $\Gamma''$ 的整体上下文。

#### **总结**：
该引理证明了上下文的组合性，保证了上下文替换的可组合性，且组合结果依然保持类型一致性。

---

### **Lemma 46.3**

**命题**：如果 $C : (\Gamma * \tau) \to (\Gamma' * \tau')$ 且 $x \notin \text{dom}(\Gamma)$，则 $C : (\Gamma, x : \tau'') * \tau \to (\Gamma', x : \tau'') * \tau'$。

#### **解释**：

- **上下文扩展**：在给定上下文的基础上，我们可以扩展上下文，添加新的变量 $x$，并确保 $x$ 不属于原上下文 $\Gamma$。同时，上下文的目标也被扩展为 $\Gamma'$ 加上变量 $x$。
- **类型保持**：尽管上下文被扩展了，但是类型的转换依然保持不变。

##### **公式解释**：
$$
\frac{C : (\Gamma * \tau) \to (\Gamma' * \tau') \quad x \notin \text{dom}(\Gamma)}{C : (\Gamma, x : \tau'') * \tau \to (\Gamma', x : \tau'') * \tau'}
$$

这一推导说明了上下文可以安全扩展，并且上下文的目标也会相应扩展。

#### **总结**：
该引理表明上下文的可扩展性，特别是在引入新变量时，能够保持类型和上下文的一致性。

---

### **Definition 46.4 (Kleene 等价)**

**定义**：两个完整程序 $e$ 和 $e'$ 是 Kleene 等价的，记作 $e \sim e'$，当且仅当存在一个 $n \geq 0$，使得 $e \rightarrow^* n$ 且 $e' \rightarrow^* n$。

#### **解释**：

- **Kleene 等价**：表示两个程序在最终执行结果上是等价的，即它们都可以计算到相同的自然数 $n$。这里的 $\rightarrow^*$ 表示多步推导，程序可以经过多个步骤计算到结果。
- **完整程序**：完整程序是没有自由变量的闭合表达式，最终返回自然数。
- **$n \geq 0$**：$n$ 是程序的最终计算结果。

##### **公式解释**：
$$
e \sim e' \quad \text{iff} \quad \exists n \geq 0 \ \text{such that} \ e \rightarrow^* n \quad \text{and} \quad e' \rightarrow^* n
$$

这个定义指出，当两个程序的执行结果相同时，它们是 Kleene 等价的。

#### **总结**：
Kleene 等价用于形式化程序的最终等价性，两个程序如果在计算完成后产生相同的结果，则它们是 Kleene 等价的。

---

### **性质总结**

- **反身性（Reflexivity）**：对于任何程序 $e$，都有 $e \sim e$。
- **对称性（Symmetry）**：如果 $e \sim e'$，则 $e' \sim e$。
- **传递性（Transitivity）**：如果 $e \sim e'$ 且 $e' \sim e''$，则 $e \sim e''$。
- **闭包性（Closure under converse evaluation）**：程序的 Kleene 等价性也遵循求值顺序的封闭性，即如果两个程序在不同的求值顺序下得出相同的结果，它们也是 Kleene 等价的。

#### **总结**：
Kleene 等价定义了一种形式的程序等价性，通过这一定义可以推导出反身性、对称性和传递性等性质。这为验证程序正确性和优化提供了理论基础。

### ---------------------------------

### **详解 Definition 46.5 (定义 46.5)**

**定义**：假设 $\Gamma \vdash e : \tau$ 和 $\Gamma \vdash e' : \tau$ 是两个具有相同类型 $\tau$ 的表达式。我们说这两个表达式是**观察等价的**（observationally equivalent），记作 $\Gamma \vdash e \sim= e' : \tau$，当且仅当对于每一个程序上下文 $C : (\Gamma * \tau) \to (\emptyset * nat)$，都有 $C\{e\} \sim C\{e'\}$。

#### **解释**：

- **上下文 $\Gamma$**：是表达式 $e$ 和 $e'$ 的类型上下文，确保表达式中引用的变量都在 $\Gamma$ 中定义。
- **$\sim=$**：表示**观察等价**，即在所有上下文下，表达式 $e$ 和 $e'$ 的行为都是相同的。
- **$C$ 表示程序上下文**：$C$ 是一个类型为从 $(\Gamma * \tau)$ 到 $(\emptyset * nat)$ 的上下文，意味着它是一个完整程序的上下文，并且替换操作会将表达式 $e$ 或 $e'$ 插入到该上下文中。

##### **公式解释**：
$$
\Gamma \vdash e \sim= e' : \tau \quad \iff \quad \forall C : (\Gamma * \tau) \to (\emptyset * nat), C\{e\} \sim C\{e'\}
$$

该公式表示，在所有程序上下文 $C$ 下，如果将 $e$ 和 $e'$ 替换到上下文中，得到的程序都应该产生相同的结果。

#### **总结**：
观察等价的核心思想是：两个表达式如果在所有上下文中都表现相同，则它们是观察等价的。这是一种基于上下文的等价关系，确保无论表达式被如何使用，它们都产生相同的行为。

---

### **Congruence (同余关系)**

**定义**：一个等价关系 $\Gamma \vdash e_1 E e_2 : \tau$ 是一个**同余关系**（congruence），如果它在所有上下文中都保持不变。也就是说，如果 $\Gamma \vdash e E e' : \tau$，那么对于每一个上下文 $C : (\Gamma * \tau) \to (\Gamma' * \tau')$，都有 $\Gamma' \vdash C\{e\} E C\{e'\} : \tau'$。

#### **解释**：

- **同余关系**：同余关系是指这种等价关系在上下文替换中保持不变。换句话说，两个表达式在上下文中的替换不会改变它们的等价性。
- **上下文 $C$**：这里的上下文 $C$ 是从 $(\Gamma * \tau)$ 到 $(\Gamma' * \tau')$ 的映射，表示上下文中表达式的类型转换。

##### **公式解释**：
$$
\Gamma \vdash e E e' : \tau \quad \Rightarrow \quad \Gamma' \vdash C\{e\} E C\{e'\} : \tau'
$$

这意味着，如果 $e$ 和 $e'$ 在某种类型下是等价的，那么在任何上下文替换操作下，它们依然保持等价。

#### **总结**：
同余关系保证了表达式等价性的稳定性，即表达式的等价性在程序的任何部分都不会被破坏。这种性质在函数式编程中的等式推理中非常重要。

---

### **Consistency (一致性)**

**定义**：一个等价关系是**一致的**（consistent），当且仅当对于自然数类型的表达式，如果 $\emptyset \vdash e E e' : nat$，则 $e \sim e'$。换句话说，如果两个表达式在自然数类型下是等价的，那么它们的值也是相等的。

#### **解释**：

- **一致性**：一致性要求如果两个自然数类型的表达式被认为是等价的，它们必须计算到相同的结果。
- **自然数类型**：自然数类型是编程语言中常见的类型，它们有明确的计算规则，因此一致性可以通过比较最终的计算结果来验证。

##### **公式解释**：
$$
\emptyset \vdash e E e' : nat \quad \Rightarrow \quad e \sim e'
$$

该公式表明，如果两个自然数表达式在某种等价关系下是等价的，那么它们最终的计算结果必须是相同的。

#### **总结**：
一致性保证了等价关系在自然数上的正确性和可靠性。如果两个表达式在自然数类型下是等价的，那么它们必须计算到相同的数值。

---

### **Theorem 46.6 (定理 46.6)**

**定理**：观察等价是表达式上的最粗糙的一致同余关系。

#### **证明要点**：

1. **一致性**：从定义可以看出，观察等价是一种一致的等价关系。因为**平凡上下文**也是程序上下文，因此满足一致性。
   
2. **等价关系**：观察等价显然是一个等价关系，因为它满足反身性、对称性和传递性。
   
3. **同余性**：为了证明观察等价是同余的，我们只需要注意到，一个程序上下文与任意表达式上下文的类型正确组合，仍然是一个程序上下文。
   
4. **最粗糙的等价关系**：最后，观察等价是最粗糙的等价关系，因为对于任何一致同余关系 $E$，如果 $\Gamma \vdash e E e' : \tau$，那么对于所有程序上下文 $C$，都有 $\emptyset \vdash C\{e\} E C\{e'\} : nat$。根据一致性，得出 $C\{e\} \sim C\{e'\}$，因此 $e \sim= e'$。

#### **总结**：
该定理表明，观察等价是最粗糙的（即最宽松的）一致同余关系，这意味着它涵盖了所有可能的一致同余关系。换句话说，如果两个表达式是观察等价的，那么它们在任何合理的上下文下都可以互换使用。

---

### **Closing Substitution (闭合替换)**

**定义**：给定一个类型上下文 $\Gamma = x_1 : \tau_1, \dots, x_n : \tau_n$，闭合替换 $\gamma$ 是一个有限函数，它将闭合表达式 $e_1 : \tau_1, \dots, e_n : \tau_n$ 分别赋给 $x_1, \dots, x_n$。

#### **解释**：

- **闭合替换 $\gamma$**：闭合替换是一个从变量到闭合表达式的映射，即 $\gamma(x_1) = e_1$ 且 $e_1 : \tau_1$。它为上下文中的每个变量 $x$ 提供了一个类型匹配的闭合表达式。
- **$\hat{\gamma}(e)$**：表示将替换应用于表达式 $e$，即将 $e_1, \dots, e_n$ 替换为 $x_1, \dots, x_n$。
- **$\gamma : \Gamma$**：意味着如果 $x : \tau$ 出现在上下文 $\Gamma$ 中，则存在一个闭合表达式 $e$ 使得 $\gamma(x) = e$ 且 $e : \tau$。

##### **公式解释**：
$$
\gamma : \Gamma \quad \text{意味着} \quad \forall x \in \text{dom}(\Gamma), \exists e : \tau, \ \gamma(x) = e
$$

该公式表明，每个上下文中的变量 $x$ 都被映射到一个类型匹配的闭合表达式。

---

### **Substitution Equivalence (替换等价)**

**定义**：我们说 $\gamma \sim_\Gamma \gamma'$ 当且仅当对 $\Gamma$ 中声明的每个 $x$，都有 $\gamma(x) \sim_\Gamma(x) \gamma'(x)$。

#### **解释**：

- **$\gamma \sim_\Gamma \gamma'$**：表示两个替换 $\gamma$ 和 $\gamma'$ 是等价的，当且仅当对于 $\Gamma$ 中的每个变量 $x$，$\gamma(x)$ 和 $\gamma'(x)$ 是等价的。

##### **公式解释**：
$$
\gamma \sim_\Gamma \gamma' \quad \text{iff} \quad \forall x \in \text{dom}(\Gamma), \ \gamma(x) \sim_{\Gamma(x)} \gamma'(x)
$$

这意味着，如果两个替换在每个变量的值上都是等价的，那么它们在整个上下文中也是等价的。

#### **

总结**：
替换等价确保了在上下文中的所有变量替换都是等价的。通过这种替换规则，我们可以确保在程序的任何地方替换变量时，程序行为不会改变。

### ---------------------------------

### **详解 Lemma 46.7 (引理 46.7)**

**命题**：如果 $\Gamma \vdash e \sim= e' : \tau$ 且 $\gamma : \Gamma$，那么 $\hat{\gamma}(e) \sim=_{\tau} \hat{\gamma}(e')$。此外，如果 $\gamma \sim_{\Gamma} \gamma'$，则 $\hat{\gamma}(e) \sim=_{\tau} \gamma'(e)$ 和 $\hat{\gamma}(e') \sim=_{\tau} \gamma'(e')$。

#### **解释**：

- **$\Gamma$**：类型上下文，确保表达式中涉及的所有变量在上下文中都有定义。
- **$\gamma$ 和 $\gamma'$**：闭合替换，表示为上下文 $\Gamma$ 中的每个变量分配一个表达式。$\hat{\gamma}(e)$ 表示将替换应用于表达式 $e$。
- **$\sim=_{\tau}$**：观察等价，表示两个表达式在类型 $\tau$ 下是等价的。
  

这个引理的核心在于，当两个表达式 $e$ 和 $e'$ 在上下文 $\Gamma$ 下是观察等价的，那么将它们放入替换 $\gamma$ 中后，结果依然保持观察等价。此外，如果两个替换 $\gamma$ 和 $\gamma'$ 是等价的，那么在相同上下文下应用替换后的结果依然等价。

#### **证明结构**：

为了证明这个引理，我们需要展示以下几点：

1. **第一部分：$C\{\hat{\gamma}(e)\} \sim C\{\hat{\gamma}(e')\}$**
   
   给定 $C : (\emptyset * \tau) \to (\emptyset * nat)$ 是一个程序上下文，我们需要证明 $C\{\hat{\gamma}(e)\} \sim C\{\hat{\gamma}(e')\}$。
   
   - 由于上下文 $C$ 没有自由变量，这等价于证明 $\hat{\gamma}(C\{e\}) \sim \hat{\gamma}(C\{e'\})$。
   - 定义上下文 $D$ 为：
     $$
     D = \lambda (x_1 : \tau_1) \dots \lambda (x_n : \tau_n) C\{\circ\}(e_1) \dots (e_n)
     $$
     其中，$\Gamma = x_1 : \tau_1, \dots, x_n : \tau_n$，并且 $\gamma(x_1) = e_1, \dots, \gamma(x_n) = e_n$。

2. **上下文推导**：
   
   根据引理 46.3，$C : (\Gamma * \tau) \to (\Gamma * nat)$，因此 $D : (\Gamma * \tau) \to (\emptyset * nat)$。
   
   - 因为 $\Gamma \vdash e \sim= e' : \tau$，我们有 $D\{e\} \sim D\{e'\}$。
   - 通过构造，我们知道 $D\{e\} \sim \hat{\gamma}(C\{e\})$，$D\{e'\} \sim \hat{\gamma}(C\{e'\})$，因此我们得到 $\hat{\gamma}(C\{e\}) \sim \hat{\gamma}(C\{e'\})$。

   由此我们证明了 $\hat{\gamma}(e) \sim_{\tau} \hat{\gamma}(e')$。

---

3. **第二部分：替换等价 $\gamma \sim_{\Gamma} \gamma'$ 的情况**

   接下来，我们定义类似的上下文 $D'$，但基于替换 $\gamma'$ 而不是 $\gamma$。我们可以证明 $D'\{e\} \sim D'\{e'\}$，因此 $\gamma'(e) \sim_{\tau} \gamma'(e')$。
   
   - 如果 $\gamma \sim_{\Gamma} \gamma'$，则根据同余性，我们有 $D\{e\} \sim D'\{e\}$，$D\{e'\} \sim D'\{e'\}$。
   - 因此，$D\{e\} \sim D'\{e'\}$，根据观察等价的一致性，我们有 $D\{e\} \sim D'\{e'\}$，即 $\hat{\gamma}(e) \sim_{\tau} \gamma'(e')$。

#### **总结**：

- **第一部分**：如果表达式 $e$ 和 $e'$ 在上下文 $\Gamma$ 下是观察等价的，那么替换 $\gamma$ 应用于 $e$ 和 $e'$ 后的结果依然是观察等价的。
- **第二部分**：如果两个替换 $\gamma$ 和 $\gamma'$ 是等价的，那么将替换应用于相同表达式后，结果依然是观察等价的。

---

### **补充定理 46.6 (一致同余关系的最粗糙性)**

引理 46.7 为定理 46.6 提供了进一步的验证依据，说明了观察等价关系的稳定性和一致性。通过引理 46.7，我们可以进一步验证，观察等价是表达式上最粗糙的一致同余关系。

#### **推导树示例**：

$$
\frac{
\text{同余推导：$D \{ e \} \sim D \{ e' \}$}}{
\text{替换操作：$\hat{\gamma}(C \{ e \}) \sim \hat{\gamma}(C \{ e' \})$}
}
$$

### ---------------------------------

### **46.2 逻辑等价 (Logical Equivalence)**

逻辑等价是一种在程序推理中简化观察等价（observational equivalence）的关键工具。通过**类型**来组织和分类表达式的使用方式，我们可以区分两种使用场景：**被动使用**（passive uses）和**主动使用**（active uses）。在定义逻辑等价时，只有主动使用的情况才是真正重要的，因为它们涉及对表达式本身的操作。

#### **被动使用**与**主动使用**的区分

- **被动使用 (Passive Uses)**：这是指在表达式被传递或封装时，不对表达式本身进行操作。例如，将一个类型为 $\tau$ 的表达式传递给一个函数，而函数只是简单地返回这个表达式。在这种情况下，表达式不会被“解构”或深入处理。
- **主动使用 (Active Uses)**：与之相对，主动使用涉及对表达式的具体操作，例如对表达式进行模式匹配或者消解（elimination forms）。这些操作会深入表达式的结构，并因此可以区分不同的表达式。

在定义等价性时，只有**主动使用**才对区分表达式的等价性有意义。

---

### **Definition 46.8 (定义 46.8)**

**定义**：逻辑等价是一个针对闭合表达式的等价关系族，记作 $e \sim_{\tau} e'$，表示两个类型为 $\tau$ 的闭合表达式 $e$ 和 $e'$ 是逻辑等价的。它通过对类型 $\tau$ 的归纳定义如下：

1. **自然数类型的逻辑等价**：
   $$
   e \sim_{\text{nat}} e' \iff e \sim e'
   $$
   这意味着两个自然数类型的表达式如果是 Kleene 等价的（即它们计算得到相同的数值），那么它们在逻辑上也是等价的。

2. **函数类型的逻辑等价**：
   $$
   e \sim_{\tau_1 \to \tau_2} e' \iff \forall e_1 \sim_{\tau_1} e'_1, \ e(e_1) \sim_{\tau_2} e'(e'_1)
   $$
   这意味着对于函数类型的表达式 $e$ 和 $e'$，它们在类型 $\tau_1 \to \tau_2$ 下是逻辑等价的，当且仅当对于任何类型 $\tau_1$ 下等价的输入 $e_1$ 和 $e'_1$，它们应用到函数 $e$ 和 $e'$ 上的结果也是类型 $\tau_2$ 下的等价。

#### **公式解释**：

- 自然数类型的逻辑等价:
  $$
  e \sim_{\text{nat}} e' \iff e \sim e'
  $$
  该公式表示如果两个自然数表达式是 Kleene 等价的（即它们计算到相同的数值），它们就是逻辑等价的。

- 函数类型的逻辑等价:
  $$
  e \sim_{\tau_1 \to \tau_2} e' \iff \forall e_1 \sim_{\tau_1} e'_1, \ e(e_1) \sim_{\tau_2} e'(e'_1)
  $$
  该公式表示对于函数类型，如果给定两个输入 $e_1$ 和 $e'_1$，它们在类型 $\tau_1$ 下是等价的，那么应用到函数 $e$ 和 $e'$ 后的结果也必须在类型 $\tau_2$ 下是等价的。

---

### **自然数上的归纳原理**

**自然数类型的逻辑等价**允许我们使用**自然数归纳法**来证明等价性。

要证明对于两个自然数表达式 $e \sim_{\text{nat}} e'$，我们可以使用如下归纳法则：
1. 证明 $E(0, 0)$ 成立。
2. 如果 $E(n, n)$ 成立，证明 $E(n+1, n+1)$ 成立。

#### **解释**：

- **数学归纳法**：这是基于自然数的数学归纳法。我们通过证明 $n = 0$ 的基底情况，然后证明 $n+1$ 的递推情况，来证明所有自然数上的等价关系。
- **Kleene 等价**：根据 Kleene 等价的定义，两个自然数表达式 $e \rightarrow^* n$ 和 $e' \rightarrow^* n$，即它们都能经过多步推导到相同的自然数 $n$，因此它们是等价的。

---

### **总结**

1. **被动使用与主动使用的区分**：逻辑等价只在主动使用的情况下才是重要的，因为这是表达式本身被操作和解构的场景，而被动使用只是传递或封装表达式。
   
2. **逻辑等价的归纳定义**：逻辑等价是对类型 $\tau$ 进行归纳定义的，特别是对于自然数和函数类型的情况。自然数类型的逻辑等价基于 Kleene 等价，而函数类型的逻辑等价则依赖于函数应用的结果是否等价。

3. **自然数归纳原理**：通过自然数的归纳原理，我们可以证明自然数上的逻辑等价性。

通过这些工具，我们可以形式化地推导和证明程序中不同类型表达式的等价性。

### ---------------------------------

### **详解 Lemma 46.9 (引理 46.9)**

**命题**：逻辑等价具有对称性和传递性：
- **对称性**：如果 $e \sim_{\tau} e'$，那么 $e' \sim_{\tau} e$。
- **传递性**：如果 $e \sim_{\tau} e'$ 且 $e' \sim_{\tau} e''$，那么 $e \sim_{\tau} e''$。

#### **证明结构**：

##### 1. **对称性 (Symmetry)**

假设 $e \sim_{\tau} e'$，我们需要证明 $e' \sim_{\tau} e$。

- **基底情况**：当 $\tau = \text{nat}$ 时，结果是直接的。因为对于自然数类型，逻辑等价是由 Kleene 等价定义的，而 Kleene 等价本身具有对称性，即如果 $e \sim e'$，那么 $e' \sim e$。
  
- **递归情况**：当 $\tau = \tau_1 \to \tau_2$ 时，我们假设在类型 $\tau_1$ 和 $\tau_2$ 下逻辑等价具有对称性和传递性。现在，我们假设 $e \sim_{\tau} e'$，并且想要证明 $e' \sim_{\tau} e$。

  假设 $e'_1 \sim_{\tau_1} e_1$，我们需要证明 $e'(e'_1) \sim_{\tau_2} e(e_1)$。

  - 根据归纳假设，$e_1 \sim_{\tau_1} e'_1$，因此由逻辑等价的定义，我们有 $e(e_1) \sim_{\tau_2} e'(e'_1)$。
  - 因此，通过归纳假设的对称性，$e'(e'_1) \sim_{\tau_2} e(e_1)$，这证明了对称性。

##### 2. **传递性 (Transitivity)**

假设 $e \sim_{\tau} e'$ 且 $e' \sim_{\tau} e''$，我们需要证明 $e \sim_{\tau} e''$。

- **基底情况**：当 $\tau = \text{nat}$ 时，结果是直接的，因为 Kleene 等价具有传递性，即如果 $e \sim e'$ 且 $e' \sim e''$，则 $e \sim e''$。

- **递归情况**：当 $\tau = \tau_1 \to \tau_2$ 时，假设 $e_1 \sim_{\tau_1} e_1''$，我们需要证明 $e(e_1) \sim_{\tau_2} e''(e_1'')$。

  - 首先，$e_1 \sim_{\tau_1} e'_1$ 和 $e'_1 \sim_{\tau_1} e_1''$。根据对称性和传递性，我们有 $e_1 \sim_{\tau_1} e_1''$。
  - 由假设，$e(e_1) \sim_{\tau_2} e'(e_1)$，同时由假设，$e'(e_1) \sim_{\tau_2} e''(e_1'')$。
  - 因此，通过传递性，我们有 $e(e_1) \sim_{\tau_2} e''(e_1'')$，这证明了传递性。

#### **总结**：

引理 46.9 证明了逻辑等价具有对称性和传递性：
- **对称性**：如果 $e \sim_{\tau} e'$，则 $e' \sim_{\tau} e$。
- **传递性**：如果 $e \sim_{\tau} e'$ 且 $e' \sim_{\tau} e''$，则 $e \sim_{\tau} e''$。

这些性质对于逻辑等价的构建至关重要，因为它们确保了逻辑等价是一种等价关系。

---

### **Open Logical Equivalence (开放逻辑等价)**

**定义**：逻辑等价可以扩展到开放的表达式，即包含自由变量的表达式。对于上下文 $\Gamma$，我们定义开放逻辑等价 $\Gamma \vdash e \sim e' : \tau$，表示对于任意的替换 $\gamma \sim_{\Gamma} \gamma'$，都有 $\hat{\gamma}(e) \sim_{\tau} \gamma'(e')$。

#### **解释**：

- **开放逻辑等价**：在上下文 $\Gamma$ 下，两个表达式 $e$ 和 $e'$ 被认为是开放逻辑等价的，当且仅当在任何替换 $\gamma$ 和 $\gamma'$ 下，替换后的表达式依然是等价的。
- **替换 $\gamma \sim_{\Gamma} \gamma'$**：表示在上下文 $\Gamma$ 中，每个自由变量 $x$ 的替换结果 $\gamma(x)$ 和 $\gamma'(x)$ 是等价的。

##### **公式解释**：
$$
\Gamma \vdash e \sim e' : \tau \iff \forall \gamma \sim_{\Gamma} \gamma', \ \hat{\gamma}(e) \sim_{\tau} \gamma'(e')
$$

这意味着，如果两个表达式在某个上下文下是等价的，那么它们在任意替换后的结果也必须是等价的。

---

### **Lemma 46.10 (引理 46.10)**

**命题**：开放逻辑等价具有对称性和传递性。

#### **证明结构**：

1. **对称性**：根据引理 46.9，逻辑等价在闭合表达式下是对称的。由于开放逻辑等价是通过替换闭合表达式得到的，因此它继承了对称性。

2. **传递性**：同样，根据引理 46.9，逻辑等价在闭合表达式下是传递的。由于开放逻辑等价通过闭合表达式的替换来定义，因此它也继承了传递性。

#### **总结**：

引理 46.10 证明了开放逻辑等价在上下文中的两个表达式下同样具有对称性和传递性。通过替换得到的逻辑等价可以在任何上下文中保持一致。

---

### **进一步的解释**

引理 46.9 和 46.10 提供了逻辑等价的关键性质：**对称性**和**传递性**。这两个性质保证了逻辑等价是一种等价关系，特别是在包含函数类型的表达式中，可以递归地应用等价性。

通过这些性质，我们可以推导出复杂表达式的等价性，同时也为构建更复杂的类型系统中的等价关系提供了理论基础。

### ---------------------------------

### 46.3 逻辑等价与观察等价的重合 (Logical and Observational Equivalence Coincide)

在这一节中，我们证明了**逻辑等价 (Logical Equivalence)** 和**观察等价 (Observational Equivalence)** 是重合的，即两个表达式如果在逻辑上等价，它们在观察上也是等价的，反之亦然。这一证明依赖于一系列引理，逐步建立逻辑等价和观察等价的一致性。

---

### **Lemma 46.11 (逆向求值引理 - Converse Evaluation)**

**命题**：假设 $e \sim_{\tau} e'$。如果 $d \rightarrow e$，那么 $d \sim_{\tau} e'$；如果 $d' \rightarrow e'$，那么 $e \sim_{\tau} d'$。

#### **解释**：

这个引理说明了逻辑等价的**闭包性**。如果两个表达式 $e$ 和 $e'$ 是逻辑等价的，那么任何可以被推导到 $e$ 的表达式 $d$ 也应该与 $e'$ 等价，反之亦然。这里的核心思想是：等价的表达式在推导步骤中保持等价性。

#### **证明**：

通过对类型 $\tau$ 的结构进行归纳：

1. **当 $\tau = \text{nat}$ 时**，结论直接从 Kleene 等价的逆向闭包性得出，因为 Kleene 等价对逆向求值是封闭的。

2. **当 $\tau = \tau_1 \to \tau_2$ 时**，假设 $e \sim_{\tau} e'$ 并且 $d \rightarrow e$。为了证明 $d \sim_{\tau} e'$，我们假设 $e_1 \sim_{\tau_1} e'_1$，需要证明 $d(e_1) \sim_{\tau_2} e'(e'_1)$。

   - 根据假设，$e(e_1) \sim_{\tau_2} e'(e'_1)$。由于 $d(e_1) \rightarrow e(e_1)$，我们可以通过归纳假设得出 $d(e_1) \sim_{\tau_2} e'(e'_1)$。

---

### **Lemma 46.12 (一致性 - Consistency)**

**命题**：如果 $e \sim_{\text{nat}} e'$，那么 $e \sim e'$（即 Kleene 等价成立）。

#### **解释**：

这个引理表明：对于自然数类型的表达式，逻辑等价与 Kleene 等价是一致的。如果两个自然数表达式在逻辑上等价，它们的值必须相同。这为自然数类型的表达式提供了一种强大的等价性。

#### **证明**：

该引理直接从**定义 46.8**（逻辑等价的定义）中得出，因为自然数的逻辑等价基于 Kleene 等价。

---

### **Theorem 46.13 (反身性 - Reflexivity)**

**命题**：如果 $\Gamma \vdash e : \tau$，那么 $\Gamma \vdash e \sim e : \tau$。

#### **解释**：

反身性是逻辑等价的基本性质之一。该定理表明，任何表达式 $e$ 在逻辑上总是与自身等价的。证明依赖于对表达式的类型推导进行归纳分析。

#### **证明结构**：

通过对类型推导进行归纳，我们可以分解证明：

1. **情况 1：当 $\tau = \tau_1 \to \tau_2$，且 $e = \lambda (x : \tau_1) e_2$ 时**：

   我们需要证明 $\lambda (x : \tau_1) \hat{\gamma}(e_2) \sim_{\tau_1 \to \tau_2} \lambda (x : \tau_1) \gamma'(e_2)$。

   - 假设 $e_1 \sim_{\tau_1} e'_1$，根据引理 46.11，我们只需证明 $[e_1/x] \hat{\gamma}(e_2) \sim_{\tau_2} [e'_1/x] \gamma'(e_2)$。
   - 设 $\gamma_2 = \gamma \oplus (x \to e_1)$ 和 $\gamma'_2 = \gamma' \oplus (x \to e'_1)$。由于 $\gamma_2 \sim_{\Gamma, x : \tau_1} \gamma'_2$，通过归纳假设，我们得到 $\hat{\gamma_2}(e_2) \sim_{\tau_2} \hat{\gamma'_2}(e_2)$，从而证明了结果。

2. **情况 2：当使用递归规则 (rule 9.1d) 时**：

   我们需要证明：
   $$
   \text{rec}\{\hat{\gamma}(e_0); x.y.\hat{\gamma}(e_1)\}(\hat{\gamma}(e)) \sim_{\tau} \text{rec}\{\gamma'(e_0); x.y.\gamma'(e_1)\}(\gamma'(e))
   $$

   - 通过归纳假设应用于规则的第一个前提，我们有 $\hat{\gamma}(e) \sim_{\text{nat}} \gamma'(e)$。然后我们使用**自然数归纳法**（nat-induction）进行证明。

   - 对于基底情况 $z$，根据引理 46.11，我们只需要证明 $\hat{\gamma}(e_0) \sim_{\tau} \gamma'(e_0)$。这可以通过外部归纳假设得出。

   - 对于递归情况 $s(n)$，定义替换：
     $$
     \delta = \gamma \oplus (x \to n) \oplus (y \to \text{rec}\{\hat{\gamma}(e_0); x.y.\hat{\gamma}(e_1)\}(n))
     $$
     $$
     \delta' = \gamma' \oplus (x \to n) \oplus (y \to \text{rec}\{\gamma'(e_0); x.y.\gamma'(e_1)\}(n))
     $$

     根据归纳假设，我们有 $\delta \sim_{\Gamma, x : \text{nat}, y : \tau} \delta'$。通过应用外部归纳假设和引理 46.11，证明随之完成。

---

### **总结**：

这一节的核心在于通过一系列引理和定理来证明逻辑等价和观察等价是一致的：

1. **逆向求值引理 (Converse Evaluation)** 证明了在推导过程中，逻辑等价是保持不变的。
2. **一致性引理 (Consistency)** 证明了对于自然数类型，逻辑等价与 Kleene 等价是一致的。
3. **反身性定理 (Reflexivity)** 通过对类型推导的归纳，证明了任何表达式都与自身等价。

这些引理和定理共同构建了逻辑等价和观察等价之间的桥梁，并证明了两者的重合性。

### ---------------------------------

### **Corollary 46.14 (等价关系 - Equivalence)**

**命题**：开放逻辑等价是一个**等价关系**。

#### **解释**：

开放逻辑等价是一种等价关系，意味着它具有**自反性**、**对称性**和**传递性**，即：
- **自反性**：任何表达式 $e$ 与其自身是等价的，即 $e \sim e$。
- **对称性**：如果 $e \sim e'$，那么 $e' \sim e$。
- **传递性**：如果 $e \sim e'$ 且 $e' \sim e''$，那么 $e \sim e''$。

#### **推导**：

由于之前的定理（例如，反身性和对称性引理）已经证明了逻辑等价的这些性质，我们可以直接得出开放逻辑等价也是一个等价关系。

---

### **Corollary 46.15 (终止性 - Termination)**

**命题**：如果 $e : \text{nat}$，则存在某个 $e'$ 使得 $e \rightarrow^* e'$ 且 $e'$ 是一个值 (val)。

#### **解释**：

对于类型为 $\text{nat}$ 的表达式 $e$，该推论表明 $e$ 总是可以通过一系列推导步骤（$e \rightarrow^*$ 表示零或多步推导）最终归约到某个数值。这表明在 System T 中，自然数表达式是**可终止的**，不会进入无限循环。

#### **推导**：

该推论直接来源于 System T 的特性，即自然数表达式总是通过推导得到数值（值形式）。System T 中的自然数表达式通过**递归规则**（例如后继操作 $s(n)$ 和基底 $0$）逐步计算，必然会终止。

---

### **Lemma 46.16 (同余性 - Congruence)**

**命题**：如果 $C_0 : (\Gamma * \tau) \to (\Gamma_0 * \tau_0)$ 且 $\Gamma \vdash e \sim e' : \tau$，则 $\Gamma_0 \vdash C_0\{e\} \sim C_0\{e'\} : \tau_0$。

#### **解释**：

**同余性**（Congruence）是逻辑等价的重要性质之一，意味着如果两个表达式 $e$ 和 $e'$ 是等价的，那么将它们放入相同的上下文 $C_0$ 后，得到的两个新表达式仍然是等价的。

#### **证明结构**：

通过对 $C_0$ 的类型推导进行归纳，我们来证明该引理：

1. **情况：$C_0 = \lambda (x : \tau_1) C_2$**，因此 $C_0 : (\Gamma * \tau) \to (\Gamma_0 * \tau_1 \to \tau_2)$，且 $C_2 : (\Gamma * \tau) \to (\Gamma_0, x : \tau_1 * \tau_2)$。

   - 假设 $\Gamma \vdash e \sim e' : \tau$，我们需要证明 $\Gamma_0 \vdash \lambda (x : \tau_1) C_2\{e\} \sim \lambda (x : \tau_1) C_2\{e'\} : \tau_1 \to \tau_2$。

2. **归纳假设**：根据归纳假设，我们知道：
   $$
   \Gamma_0, x : \tau_1 \vdash C_2\{e\} \sim C_2\{e'\} : \tau_2
   $$

3. **使用替换 $\gamma_0$ 和 $\gamma'_0$**：

   - 设 $\gamma_0 \sim_{\Gamma_0} \gamma'_0$，并且假设 $e_1 \sim_{\tau_1} e'_1$。
   - 定义新的替换：$\gamma_1 = \gamma_0 \oplus (x \to e_1)$ 和 $\gamma'_1 = \gamma'_0 \oplus (x \to e'_1)$。

   根据定义 46.8 的逻辑等价规则，我们只需要证明：
   $$
   \hat{\gamma}_1(C_2\{e\}) \sim_{\tau_2} \hat{\gamma}'_1(C_2\{e'\})
   $$

4. **应用归纳假设**：

   根据归纳假设，$\hat{\gamma}_1(C_2\{e\}) \sim_{\tau_2} \hat{\gamma}'_1(C_2\{e'\})$ 是成立的，因此引理 46.16 成立。

#### **总结**：

引理 46.16 证明了逻辑等价的同余性：如果两个表达式是等价的，那么将它们放入相同的上下文中，得到的结果仍然是等价的。这对于构建更复杂的表达式推导和证明表达式等价性至关重要。

### ---------------------------------

### **Theorem 46.17 (观察等价与逻辑等价的重合)**

**命题**：如果 $\Gamma \vdash e \sim e' : \tau$，那么 $\Gamma \vdash e \sim= e' : \tau$。

#### **解释**：

该定理表明**逻辑等价**和**观察等价**在某种程度上是等价的。如果两个表达式在上下文 $\Gamma$ 下是逻辑等价的，那么它们在同样的上下文中也是观察等价的。

#### **证明**：

根据**引理 46.12**（一致性引理）和**引理 46.16**（同余性引理），以及**定理 46.6**（观察等价是最粗糙的一致同余关系），可以推导出该命题的正确性。逻辑等价确保了表达式在所有上下文中的行为一致，因此推导出它们在观察等价下也是一致的。

---

### **Corollary 46.18 (自然数上的观察等价)**

**命题**：如果 $e : \text{nat}$，那么存在某个 $n \geq 0$，使得 $e \sim=_{\text{nat}} n$。

#### **解释**：

对于类型为自然数的表达式 $e$，该推论表明，$e$ 总是观察等价于某个自然数 $n$。换句话说，任何自然数表达式最终都可以归约为某个具体的自然数 $n$，并且这个自然数与原表达式是观察等价的。

#### **证明**：

- 通过**定理 46.13**，我们知道 $e \sim_{\text{nat}} e$。因此，存在某个自然数 $n \geq 0$ 使得 $e \sim_{\text{nat}} n$。
- 根据**定理 46.17**，我们可以进一步推导出 $e \sim=_{\text{nat}} n$，即 $e$ 与 $n$ 在观察等价下也是一致的。

---

### **Lemma 46.19 (逻辑等价推出观察等价)**

**命题**：对于闭合表达式 $e : \tau$ 和 $e' : \tau$，如果 $e \sim=_{\tau} e'$，那么 $e \sim_{\tau} e'$。

#### **解释**：

该引理说明了**逻辑等价**可以推出**观察等价**。如果两个闭合表达式在某个类型 $\tau$ 下是逻辑等价的，那么它们也在观察等价下保持一致。

#### **证明结构**：

通过对类型 $\tau$ 的结构进行归纳：

1. **基底情况**：当 $\tau = \text{nat}$ 时，考虑空上下文，我们可以得到 $e \sim_{\text{nat}} e'$，因此 $e \sim_{\text{nat}} e'$ 成立。

2. **递归情况**：当 $\tau = \tau_1 \to \tau_2$ 时，我们需要证明：对于任何 $e_1 \sim_{\tau_1} e'_1$，都有 $e(e_1) \sim_{\tau_2} e'(e'_1)$。

   - 根据**定理 46.17**，我们知道 $e_1 \sim=_{\tau_1} e'_1$。因此，由观察等价的同余性，可以推导出 $e(e_1) \sim=_{\tau_2} e'(e'_1)$。
   - 最后，通过归纳假设，我们得到 $e(e_1) \sim_{\tau_2} e'(e'_1)$，因此结论成立。

---

### **Theorem 46.20 (逻辑等价推出观察等价)**

**命题**：如果 $\Gamma \vdash e \sim= e' : \tau$，那么 $\Gamma \vdash e \sim e' : \tau$。

#### **解释**：

这一定理表明逻辑等价能够推出观察等价。即如果两个表达式在上下文 $\Gamma$ 下是逻辑等价的，那么它们在同样的上下文下也是观察等价的。

#### **证明结构**：

假设 $\Gamma \vdash e \sim= e' : \tau$，并且 $\gamma \sim_{\Gamma} \gamma'$，我们需要证明 $e$ 和 $e'$ 是观察等价的。

1. 根据**定理 46.17**，我们知道 $\gamma \sim=_{\Gamma} \gamma'$。

2. 根据**引理 46.7**，我们可以得出 $\hat{\gamma}(e) \sim=_{\tau} \hat{\gamma}'(e')$。

3. 根据**引理 46.19**，我们进一步推导出 $\hat{\gamma}(e) \sim_{\tau} \hat{\gamma}'(e')$。

因此，我们得出了结论：$\Gamma \vdash e \sim e' : \tau$，即逻辑等价推出观察等价。

---

### **总结**

1. **定理 46.17** 证明了逻辑等价能够推出观察等价。
2. **推论 46.18** 进一步说明了自然数表达式的观察等价性，表明任何自然数表达式最终都可以归约为某个具体的自然数。
3. **引理 46.19** 证明了逻辑等价可以通过归纳结构推出观察等价。
4. **定理 46.20** 则总结了逻辑等价和观察等价之间的关系，证明了逻辑等价能够推出观察等价，从而进一步巩固了两者的一致性。

### ---------------------------------

### **Corollary 46.21 (推论 46.21)**

**命题**：$\Gamma \vdash e \sim= e' : \tau$ 当且仅当 $\Gamma \vdash e \sim e' : \tau$。

#### **解释**：

这一推论表明，**逻辑等价**和**观察等价**在上下文 $\Gamma$ 下是完全等价的。这意味着，如果两个表达式在某个上下文下是逻辑等价的，那么它们也是观察等价的，反之亦然。

#### **证明**：

通过之前的定理和引理：
- **定理 46.17** 证明了逻辑等价推出观察等价。
- **引理 46.19** 证明了观察等价可以从逻辑等价中推导出来。
因此，逻辑等价和观察等价在上下文 $\Gamma$ 下是等价的。

---

### **Theorem 46.22 (定义等价推出观察等价)**

**命题**：如果 $\Gamma \vdash e \equiv e' : \tau$，那么 $\Gamma \vdash e \sim e' : \tau$，从而 $\Gamma \vdash e \sim= e' : \tau$。

#### **解释**：

**定义等价 (Definitional Equality)** 是指两个表达式在语法上可以通过规则直接证明是等价的。这一定理表明，定义等价可以推出观察等价和逻辑等价。换句话说，如果两个表达式在语法规则下是定义等价的，那么它们在所有上下文中也是观察等价和逻辑等价的。

#### **证明**：

- 证明思路与**定理 46.13** 和**引理 46.16** 的证明类似。通过这些引理和定理，已经证明了逻辑等价和观察等价的一致性。
- 由于定义等价意味着两个表达式可以通过规则直接证明是等价的，因此，它们在所有上下文下的行为一致，即满足观察等价的条件。
- 根据**定理 46.17**，我们进一步可以推导出逻辑等价。

---

### **Corollary 46.23 (推论 46.23)**

**命题**：如果 $e \equiv e' : \text{nat}$，那么存在某个 $n \geq 0$，使得 $e \rightarrow^* n$ 且 $e' \rightarrow^* n$。

#### **解释**：

对于自然数类型的表达式 $e$ 和 $e'$，如果它们是定义等价的，那么它们最终都会归约到相同的数值 $n$，即 $e$ 和 $e'$ 最终会归约为相同的自然数。

#### **证明**：

- 根据**定理 46.22**，我们有 $e \sim_{\text{nat}} e'$，即 $e$ 和 $e'$ 是观察等价的。
- 通过 Kleene 等价，我们可以进一步得出 $e \sim e'$，因此 $e$ 和 $e'$ 都会归约到相同的数值 $n$。
- 这意味着存在某个 $n \geq 0$，使得 $e \rightarrow^* n$ 且 $e' \rightarrow^* n$。

---

### **总结**

1. **推论 46.21** 证明了逻辑等价和观察等价在上下文 $\Gamma$ 下是等价的。
2. **定理 46.22** 说明了定义等价可以推出观察等价和逻辑等价。定义等价的表达式在所有上下文中都是观察等价的。
3. **推论 46.23** 则表明，如果两个自然数表达式是定义等价的，那么它们最终会归约为相同的自然数。

### ---------------------------------

### **46.4 一些等价法则 (Some Laws of Equality)**

在本节中，我们总结了一些关于**观察等价 (Observational Equivalence)** 的重要原则，特别是对于语言 $T$ 的情况。大多数情况下，这些法则首先是**逻辑等价 (Logical Equivalence)** 的法则，然后通过 **推论 46.21** 转换为观察等价的法则。每个法则都表示为推理规则，意味着如果前提中的判断关于观察等价是正确的，那么结论也是正确的。换句话说，每个法则都是观察等价的可接受原则。

---

### **46.4.1 一般法则 (General Laws)**

逻辑等价确实是一个**等价关系**，这意味着它具有**自反性 (reflexive)**、**对称性 (symmetric)** 和**传递性 (transitive)**。

#### **公式 (46.5a): 自反性 (Reflexivity)**

$$
\frac{}{\Gamma \vdash e \sim= e : \tau}
$$

- **解释**：任何表达式 $e$ 在逻辑上都与其自身是等价的。该规则表明了逻辑等价的自反性，即表达式总是与自己等价。

---

#### **公式 (46.5b): 对称性 (Symmetry)**

$$
\frac{\Gamma \vdash e' \sim= e : \tau}{\Gamma \vdash e \sim= e' : \tau}
$$

- **解释**：如果 $e' \sim= e$ 成立，那么 $e \sim= e'$ 也成立。这是对称性的表达，即两个表达式的等价性是双向的。

---

#### **公式 (46.5c): 传递性 (Transitivity)**

$$
\frac{\Gamma \vdash e \sim= e' : \tau \quad \Gamma \vdash e' \sim= e'' : \tau}{\Gamma \vdash e \sim= e'' : \tau}
$$

- **解释**：如果 $e$ 与 $e'$ 等价，且 $e'$ 与 $e''$ 等价，那么 $e$ 也与 $e''$ 等价。这是逻辑等价的传递性，即如果两个表达式通过中间表达式等价，那么它们直接等价。

---

### **定义等价与观察等价 (Definitional Equality and Observational Equivalence)**

#### **公式 (46.6a): 定义等价推出观察等价**

$$
\frac{\Gamma \vdash e \equiv e' : \tau}{\Gamma \vdash e \sim= e' : \tau}
$$

- **解释**：**定义等价**（Definitional Equality）指的是两个表达式根据语法规则可以直接证明等价。这个规则表明，定义等价的两个表达式在观察等价下也是等价的。

---

### **观察等价的同余性 (Congruence of Observational Equivalence)**

#### **公式 (46.7a): 观察等价的同余性**

$$
\frac{\Gamma \vdash e \sim= e' : \tau \quad C : (\Gamma * \tau) \to (\Gamma' * \tau')}{\Gamma' \vdash C\{e\} \sim= C\{e'\} : \tau'}
$$

- **解释**：**同余性**（Congruence）意味着，如果两个表达式 $e$ 和 $e'$ 是等价的，那么在任意上下文 $C$ 中替换它们后，生成的表达式仍然是等价的。这说明观察等价在各种上下文下都保持一致。

### ---------------------------------

### **公式 (46.8a): 替换与等价的稳定性 (Substitution and Equivalence Stability)**

$$
\frac{
\Gamma \vdash e : \tau \quad \Gamma, x : \tau \vdash e_2 \sim= e'_2 : \tau'
}{
\Gamma \vdash [e/x]e_2 \sim= [e/x]e'_2 : \tau'
}
$$

#### **符号解释**：
- $\Gamma \vdash e : \tau$：表示在上下文 $\Gamma$ 中，$e$ 的类型是 $\tau$。
- $\Gamma, x : \tau \vdash e_2 \sim= e'_2 : \tau'$：表示在上下文 $\Gamma$ 中，$x$ 的类型是 $\tau$，并且 $e_2$ 和 $e'_2$ 在类型 $\tau'$ 下是等价的。
- $[e/x]e_2$：表示将 $x$ 替换为 $e$ 后得到的表达式。

#### **解释**：
如果 $e_2$ 和 $e'_2$ 在上下文 $\Gamma, x : \tau$ 下是等价的，并且 $e$ 是类型 $\tau$ 的表达式，那么将 $e$ 替换到 $e_2$ 和 $e'_2$ 中，结果仍然是等价的。这说明等价关系在变量替换下是稳定的。

---

### **公式 (46.8b): 等价表达式的替换与稳定性 (Substitution of Equivalent Expressions)**

$$
\frac{
\Gamma \vdash e_1 \sim= e'_1 : \tau \quad \Gamma, x : \tau \vdash e_2 \sim= e'_2 : \tau'
}{
\Gamma \vdash [e_1/x]e_2 \sim= [e'_1/x]e'_2 : \tau'
}
$$

#### **符号解释**：
- $\Gamma \vdash e_1 \sim= e'_1 : \tau$：表示在上下文 $\Gamma$ 中，$e_1$ 和 $e'_1$ 在类型 $\tau$ 下是等价的。
- $[e_1/x]e_2$ 和 $[e'_1/x]e'_2$：表示将 $x$ 替换为 $e_1$ 和 $e'_1$ 后得到的表达式。

#### **解释**：
如果 $e_1$ 和 $e'_1$ 是等价的，并且 $e_2$ 和 $e'_2$ 在上下文 $\Gamma, x : \tau$ 下是等价的，那么将 $x$ 替换为 $e_1$ 和 $e'_1$ 后，得到的表达式仍然是等价的。这进一步说明了等价关系在替换操作下的稳定性。

---

### **公式 (46.9): 函数等价性 (Equality of Functions)**

$$
\frac{
\Gamma, x : \tau_1 \vdash e(x) \sim= e'(x) : \tau_2
}{
\Gamma \vdash e \sim= e' : \tau_1 \to \tau_2
}
$$

#### **符号解释**：
- $\Gamma, x : \tau_1 \vdash e(x) \sim= e'(x) : \tau_2$：表示在上下文 $\Gamma$ 中，给定参数 $x$ 的类型为 $\tau_1$，则 $e(x)$ 和 $e'(x)$ 在类型 $\tau_2$ 下是等价的。
- $\Gamma \vdash e \sim= e' : \tau_1 \to \tau_2$：表示在上下文 $\Gamma$ 中，函数 $e$ 和 $e'$ 在类型 $\tau_1 \to \tau_2$ 下是等价的。

#### **解释**：
两个函数如果对于所有输入参数都产生相同的输出，则它们是等价的。这意味着如果 $e(x)$ 和 $e'(x)$ 对于任何 $x$ 都是等价的，那么函数 $e$ 和 $e'$ 本身也是等价的。

---

### **公式 (46.10): 函数表达式与 $\lambda$ 抽象 (Function Expression and λ-Abstraction)**

$$
\frac{}{
\Gamma \vdash e \sim= \lambda (x : \tau_1) e(x) : \tau_1 \to \tau_2
}
$$

#### **符号解释**：
- $\lambda (x : \tau_1) e(x)$：表示将表达式 $e(x)$ 用 $x$ 作为参数进行 $\lambda$ 抽象，生成一个函数。
- $\Gamma \vdash e \sim= \lambda (x : \tau_1) e(x) : \tau_1 \to \tau_2$：表示表达式 $e$ 和 $\lambda$ 抽象是等价的。

#### **解释**：
任何函数表达式都可以等价地表示为一个 $\lambda$ 抽象。换句话说，任意类型为 $\tau_1 \to \tau_2$ 的函数表达式可以表示为一个从参数 $x$ 到表达式 $e(x)$ 的 $\lambda$ 抽象。

---

### **公式 (46.11a): 归纳法则 (Induction Law)**

$$
\frac{
\Gamma \vdash [n/x]e \sim= [n/x]e' : \tau \text{ (for every $n \in \mathbb{N}$)}
}{
\Gamma, x : \text{nat} \vdash e \sim= e' : \tau
}
$$

#### **符号解释**：
- $[n/x]e$：表示将 $x$ 替换为自然数 $n$。
- $\Gamma \vdash [n/x]e \sim= [n/x]e' : \tau$：表示对于所有自然数 $n$，将 $x$ 替换为 $n$ 后，$e$ 和 $e'$ 在类型 $\tau$ 下是等价的。
- $\Gamma, x : \text{nat} \vdash e \sim= e' : \tau$：表示 $e$ 和 $e'$ 对所有自然数 $x$ 都是等价的。

#### **解释**：
这个规则是**归纳法则**，它表明如果对于每个自然数 $n$，表达式 $e$ 和 $e'$ 在 $x = n$ 时是等价的，那么可以推导出 $e$ 和 $e'$ 对所有自然数 $x$ 都是等价的。这是数学归纳法在类型系统中的应用。

---

### **归纳规则应用 (Application of the Induction Rule)**

为了应用归纳法则，我们通过对自然数 $n$ 进行数学归纳，归约为两个证明目标：
1. **基底情况**：证明对于 $n = 0$ 的情况，即：
   $$
   \Gamma \vdash [z/x]e \sim= [z/x]e' : \tau
   $$
2. **归纳步骤**：假设 $n$ 的情况成立，证明 $n+1$ 的情况也成立，即：
   $$
   \Gamma \vdash [s(n)/x]e \sim= [s(n)/x]e' : \tau
   $$
   条件是 $\Gamma \vdash [n/x]e \sim= [n/x]e' : \tau$ 已成立。

#### **解释**：
这个规则的关键在于应用归纳法证明带有自然数变量的等式。如果对于每个自然数 $n$，表达式 $e$ 和 $e'$ 的行为一致，那么我们就可以推导出它们对于所有自然数都是等价的。

---

### **总结**：

这些法则展示了等价关系的**稳定性**、**函数等价性**、以及**归纳法**在表达式中的应用，帮助我们推导复杂表达式的等价性，并确保观察等价和逻辑等价的一致性。


### ---------------------------------

### **46.5 备注 (Notes)**

#### **逻辑关系方法 (The Method of Logical Relations)**

**逻辑关系 (Logical Relations)** 是一种将类型解释为关系（这里主要是**等价关系 (Equivalence Relations)**）的方法。它通过将每个**类型构造器 (Type Constructor)** 关联到一个关系操作来实现，这个操作将解释其参数的关系转换为解释构造类型的关系。

#### **解释**：
- **类型构造器 (Type Constructor)** 是指构造复合类型的操作。例如，函数类型 $\tau_1 \to \tau_2$ 就是一个通过两个类型 $\tau_1$ 和 $\tau_2$ 构造的新类型。
- **关系操作 (Relational Action)** 指的是对于每个类型构造器的参数关系，生成该类型构造器的等价关系。例如，若 $\tau_1$ 和 $\tau_2$ 都有等价关系，那么可以定义 $\tau_1 \to \tau_2$ 的等价关系，即两个函数对相同输入给出相同的输出。

#### **逻辑关系在证明理论中的作用 (Role in Proof Theory)**

逻辑关系是**证明理论 (Proof Theory)** 中的基本工具。它们为**NuPRL 类型理论 (NuPRL Type Theory)** 的语义奠定了基础：
- **NuPRL 类型理论** 是一种依赖类型的构造主义逻辑，它用于证明数学定理并开发正确的程序。
- 这种逻辑关系方法最早由 **Statman (1985)** 提出，后续被应用在 **NuPRL 语义** 中，由 **Constable (1986)** 和 **Allen (1987)** 等人发展。

#### **与 Godel 系统 T 的适应性 (Adapting to Godel’s System T)**

在本章中，逻辑关系被用于刻画 **观察等价 (Observational Equivalence)**，这是 NuPRL 语义在更简单的 **Godel’s System T** 设置中的应用。

- **Godel’s System T** 是一种简单的递归函数语言，具有自然数和函数类型，常被用作逻辑基础。
- 通过逻辑关系方法，我们能够将复杂的 NuPRL 语义简化并应用于 Godel 系统 T，来证明程序的等价性。

---

### **总结**：
**逻辑关系**方法是通过将类型解释为关系，并通过类型构造器的关系操作来建立类型之间的等价关系。这种方法不仅在证明理论中具有重要地位，还为 **NuPRL 类型理论** 和 **Godel’s System T** 的语义奠定了基础，特别是在刻画 **观察等价**时有着广泛应用。

### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------
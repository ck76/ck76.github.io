[toc]



### 第 49 章：进程等价 (Process Equivalence)

在这一章中，我们讨论了**进程等价**的问题。在并发计算中，进程是一种持续进行的计算，它可能通过发送和接收消息与其他进程进行交互。与传统的单个程序不同，并发计算没有明确的“最终结果”，而是一个可以无限期继续的交互过程。因此，进程之间的等价性不能仅仅基于它们计算出的“答案”，而是基于它们的交互潜力。

### 49.1 进程等价的定义 (Process Equivalence)

假设有两个进程 $P$ 和 $Q$，并且 $\vdash P: \text{proc}$ 和 $\vdash Q: \text{proc}$，表示 $P$ 和 $Q$ 都是合法的进程。我们说 $P$ 和 $Q$ 是等价的，记作 $P \approx Q$，当且仅当存在一个**双向模拟 (bisimulation)** 关系 $R$ 使得 $P R Q$。

### 详细解析：

1. **双向模拟 (Bisimulation)** 的定义：
   - **双向模拟**关系 $R = \{R_\alpha\}$ 是一组关系，它们必须满足以下条件：
     - 如果进程 $P$ 能够通过执行某个动作 $\alpha$ 进化到另一个进程 $P'$，那么进程 $Q$ 也必须能够通过执行相同的动作 $\alpha$ 进化到某个进程 $Q'$，且 $P' R Q'$。
     - 反过来，如果 $Q$ 能通过动作 $\alpha$ 进化到 $Q'$，那么 $P$ 也必须能够通过动作 $\alpha$ 进化到某个 $P'$，且 $P' R Q'$。

2. **解释关键符号**：
   - **$P \approx Q$**: 表示 $P$ 和 $Q$ 是等价的进程，即它们在行为上表现一致。
   - **$P R Q$**: 表示 $P$ 和 $Q$ 之间存在某种双向模拟关系 $R$，即 $P$ 和 $Q$ 在与外界交互的能力上彼此模拟。
   - **$\alpha$**: 代表进程的某个动作，可能是消息的发送或接收等。

### 直观解释：

- 进程等价的概念反映的是两个进程在与环境交互时所展示出的行为是否一致。并不是仅仅比较进程的最终输出结果，而是关心进程是否能够以相同的方式进行交互，并对外界的行为做出相同的反应。
- **双向模拟**关系是捕捉这一等价性的工具，它要求两个进程的每一步行为都可以被彼此模拟，即每当一个进程做出某个动作，另一个进程也必须能够做出对应的动作，并保持彼此之间的模拟关系。

### 49.1 进程演算 (Process Calculus)

**进程演算** (Process Calculus) 是一种数学形式化方法，用于描述和分析并发系统中进程的行为。它允许我们对进程的行为进行形式化的定义和推理。接下来我们将介绍两种常见的进程等价性：**强等价 (strong equivalence)** 和 **弱等价 (weak equivalence)**。

### 49.2 强等价 (Strong Equivalence)

强等价是最严格的进程等价标准。两个进程 $P$ 和 $Q$ 是**强等价的**，如果它们的每一步行为都能够被彼此完全模拟，并且它们在执行每个具体动作时保持同步。换句话说，$P$ 和 $Q$ 的每一步进化都是严格对应的。

#### 形式定义：
如果进程 $P$ 通过动作 $\alpha$ 进化到 $P'$，则 $Q$ 也必须通过相同的动作 $\alpha$ 进化到 $Q'$，且 $P' \approx Q'$，反之亦然。

### 49.3 弱等价 (Weak Equivalence)

**弱等价**是稍微宽松一些的进程等价标准。两个进程是**弱等价的**，如果它们的行为在整体上相似，但可以忽略某些内部动作。例如，一个进程可能进行了一些内部计算或处理（通常记作 $\tau$ 动作），但只要这些内部动作对外部观察者不可见或无关紧要，我们就可以忽略它们。

#### 形式定义：
如果 $P$ 能通过一系列 $\tau$ 动作和一个显式动作 $\alpha$ 进化到 $P'$，则 $Q$ 也必须能够通过一系列 $\tau$ 动作和相同的显式动作 $\alpha$ 进化到某个 $Q'$，并且 $P' \approx Q'$。

### 49.4 备注 (Notes)

本节将讨论一些与进程等价有关的额外背景信息，例如与并发计算模型的联系、经典的进程演算如**CSP (Communicating Sequential Processes)** 或 **$\pi$-演算 (Pi Calculus)** 的等价定义。

### ---------------------------------

### 第 49.1 节：进程演算 (Process Calculus)

在这一节中，我们引入了一种进程演算 (Process Calculus)，该演算结合了第 39 章和第 40 章中探讨的主要思想。进程演算提供了一种描述并发系统中进程及其行为的形式化方法。在此模型中，进程通过消息传递进行交互，消息通过**通道 (channels)** 动态生成。

#### 1. 进程的语法 (Syntax of Processes)

进程的语法由以下的文法定义：

- **$P ::= stop \, 1$**: 表示**停止进程**或称为“惰性”进程。即进程不再进行任何操作。这个进程被称为**空进程**。
- **$P_1 ⊗ P_2$**: 表示**组合 (composition)**，即进程 $P_1$ 和 $P_2$ 并发执行。
- **$await(E) \, \$ E$**: 表示**同步 (synchronize)**，即进程等待事件 $E$ 的发生并在事件发生时进行同步。
- **$new[\tau](a.P) \, \nu a \sim \tau.P$**: 表示**分配 (allocation)**，即生成一个新通道 $a$ 类型为 $\tau$，然后执行进程 $P$。
- **$emit(e) \, ! e$**: 表示**广播 (broadcast)**，即向外部环境发送消息 $e$。

#### 2. 事件的语法 (Syntax of Events)

事件的语法定义如下：

- **$E ::= null \, 0$**: 表示**空事件**，即不进行任何操作。
- **$E_1 + E_2$**: 表示**选择 (choice)**，即两个事件的选择，如果 $E_1$ 或 $E_2$ 发生，则事件触发。
- **$acc(x.P) \, ?(x.P)$**: 表示**接受 (acceptance)**，即等待接受一个值 $x$，然后执行进程 $P$。

#### 3. 静态语义 (Statics)

静态语义定义了进程和事件的正确性判断规则，这些规则确保进程和事件的类型与定义是一致的：

- **$ \vdash 1 \, \text{proc}$** (规则 49.1a): 表示空进程是合法的进程。
- **$ \vdash P_1 \, \text{proc} \, \vdash P_2 \, \text{proc} \Rightarrow \vdash P_1 ⊗ P_2 \, \text{proc}$** (规则 49.1b): 如果 $P_1$ 和 $P_2$ 都是合法进程，那么它们的组合 $P_1 \otimes P_2$ 也是合法进程。
- **$ \vdash E \, \text{event} \Rightarrow \vdash \$ E \, \text{proc}$** (规则 49.1c): 如果 $E$ 是一个合法事件，那么等待该事件的进程也是合法进程。
- **$ \vdash a \sim \tau, P \, \text{proc} \Rightarrow \vdash \nu a \sim \tau.P \, \text{proc}$** (规则 49.1d): 如果 $P$ 是合法进程，且 $a$ 是通道，$a$ 的类型为 $\tau$，那么生成该通道的分配进程也是合法进程。
- **$ \vdash e : \text{clsfd} \Rightarrow \vdash ! e \, \text{proc}$** (规则 49.1e): 如果表达式 $e$ 是一个合法的**机密值 (classified value)**，那么广播该表达式的进程是合法的。
- **$ \vdash 0 \, \text{event}$** (规则 49.1f): 表示空事件是合法的事件。
- **$ \vdash E_1 \, \text{event} \, \vdash E_2 \, \text{event} \Rightarrow \vdash E_1 + E_2 \, \text{event}$** (规则 49.1g): 如果 $E_1$ 和 $E_2$ 都是合法事件，那么它们的选择也是合法事件。
- **$ \vdash x : \text{clsfd}, P \, \text{proc} \Rightarrow \vdash ?(x.P) \, \text{event}$** (规则 49.1h): 如果 $P$ 是合法进程，并且 $x$ 是合法的机密值，接受该值的事件是合法的。

#### 4. 动态语义 (Dynamics)

动态语义通过过程计算的演化规则定义，即描述进程如何在不同的状态之间进行转换。以下是一些主要的转换规则：

- **$P \overset{\alpha}{\longrightarrow} P'$**: 表示进程 $P$ 通过执行某个动作 $\alpha$ 进化为 $P'$。
- **$E \overset{\alpha}{\longrightarrow} P$**: 表示事件 $E$ 通过动作 $\alpha$ 导致进程 $P$ 的发生。

这些规则与第 39 章的规则类似，通过这些规则，可以确定进程如何响应事件并演化。

### 总结

进程演算是一种用于描述并发系统行为的形式化方法。在这种演算中，进程通过消息传递进行交互，进程之间的等价性基于它们与环境的交互行为是否一致。

### ---------------------------------

### 第 49.2 节：强等价 (Strong Equivalence)

在这一节中，我们引入了**进程动态语义 (process dynamics)**，描述了进程和事件如何通过动作演化。进程的演化通过**动作 $\alpha$** 来驱动，进程在每一步通过执行一个动作 $\alpha$ 转换为另一个进程。类似地，事件也会触发动作，导致进程的发生。

#### 1. 动态演化规则 (Dynamic Transition Rules)

首先，进程的动态演化用以下判断表示：

- **$P \alpha \longrightarrow P'$**：表示进程 $P$ 通过动作 $\alpha$ 演化为进程 $P'$。
- **$E \alpha \implies P$**：表示事件 $E$ 通过动作 $\alpha$ 导致进程 $P$。

在该模型中，表达式的演化则假设由 $e \longrightarrow e'$ 和 $e \, \text{val}$ 表示，即表达式 $e$ 演化为 $e'$，并且 $e$ 是一个有效值。进程和事件根据**结构同构 (structural congruence)** 进行标识，这一点在第 39 章中有详细描述。

#### 2. 主要演化规则 (Key Transition Rules)

以下是几条主要的进程演化规则：

1. **组合进程**的演化：
    $$
    \frac{P_1 \alpha \longrightarrow P'_1}{P_1 \otimes P_2 \alpha \longrightarrow P'_1 \otimes P_2} \quad (49.2a)
    $$
    如果 $P_1$ 可以通过动作 $\alpha$ 演化为 $P'_1$，那么组合进程 $P_1 \otimes P_2$ 也可以通过同样的动作演化为 $P'_1 \otimes P_2$。

    $$
    \frac{P_1 \alpha \longrightarrow P'_1 \quad P_2 \alpha \longrightarrow P'_2}{P_1 \otimes P_2 \epsilon \longrightarrow P'_1 \otimes P'_2} \quad (49.2b)
    $$
    如果 $P_1$ 和 $P_2$ 同时通过动作 $\alpha$ 分别演化为 $P'_1$ 和 $P'_2$，则组合进程 $P_1 \otimes P_2$ 通过 $\epsilon$ 动作演化为 $P'_1 \otimes P'_2$。

2. **事件的演化**：
    $$
    \frac{E \alpha \implies P}{\$ E \alpha \longrightarrow P} \quad (49.2c)
    $$
    如果事件 $E$ 可以通过动作 $\alpha$ 导致进程 $P$ 的发生，则等待事件 $E$ 的进程 $\$ E$ 也可以通过 $\alpha$ 动作演化为进程 $P$。

3. **分配新通道**：
    $$
    \frac{P \alpha \longrightarrow P'}{\nu a \sim \tau.P \alpha \longrightarrow \nu a \sim \tau.P'} \quad (49.2d)
    $$
    如果进程 $P$ 可以通过动作 $\alpha$ 演化为 $P'$，则生成通道 $a$ 的进程 $\nu a \sim \tau.P$ 可以通过同样的动作演化为 $\nu a \sim \tau.P'$。

4. **广播消息**：
    $$
    \frac{e \, \text{val}}{\! e \, ! \longrightarrow 1} \quad (49.2e)
    $$
    如果表达式 $e$ 是一个有效值（即 $e \, \text{val}$），则广播进程 $\! e$ 将成功并演化为惰性进程 $1$。

5. **事件的选择**：
    $$
    \frac{E_1 \alpha \implies P}{E_1 + E_2 \alpha \implies P} \quad (49.2f)
    $$
    如果事件 $E_1$ 通过动作 $\alpha$ 触发进程 $P$，则事件选择 $E_1 + E_2$ 也可以通过相同的动作触发进程 $P$。

6. **接受消息**：
    $$
    \frac{e \, \text{val}}{\? (x.P) e \? \implies [e/x]P} \quad (49.2g)
    $$
    如果表达式 $e$ 是一个有效值，则接受消息的事件 $\? (x.P)$ 将 $e$ 赋值给 $x$ 并演化为进程 $P$，其中 $P$ 中的所有 $x$ 被替换为 $e$。

#### 3. 替换规则 (Substitution Rules)

替换规则表明，如果表达式的替换是有效的，则进程和事件的替换也同样有效。我们有以下替换规则：

- **引理 49.1**：
  1. 如果 $ \vdash, x : \tau P \, \text{proc}$ 且 $ \vdash e : \tau$，则 $ \vdash [e/x]P \, \text{proc}$。这意味着如果进程 $P$ 中 $x$ 的类型为 $\tau$，并且 $e$ 是类型为 $\tau$ 的表达式，则可以将 $e$ 替换为 $x$，使得 $[e/x]P$ 仍是一个合法进程。
  2. 如果 $ \vdash, x : \tau E \, \text{event}$ 且 $ \vdash e : \tau$，则 $ \vdash [e/x]E \, \text{event}$。类似地，事件 $E$ 中 $x$ 的替换也保持合法。

#### 4. 进程和事件的正确性保持 (Preservation of Well-formedness)

进程和事件在演化时保持它们的正确性。以下引理描述了这种性质：

- **引理 49.2**：
  1. 如果 $P$ 是合法进程且 $P \alpha \longrightarrow P'$，则 $P'$ 也是合法进程。
  2. 如果 $E$ 是合法事件且 $E \alpha \implies P$，则 $P$ 是合法进程。

### 总结

这一节介绍了进程演算的动态语义，定义了进程和事件如何通过动作演化，以及在演化过程中如何保持它们的正确性。演化规则展示了进程和事件的并发、同步、消息传递等操作的行为。

### ---------------------------------

### 第 49.2 节：强等价 (Strong Equivalence)

在这一节中，我们引入了**强等价 (Strong Equivalence)** 的概念，它通过**互模拟 (bisimilarity)** 精确定义了进程之间的等价关系。简单来说，两个进程是等价的，当且仅当它们在进行相同的动作时，可以演化为等价的进程。

#### 1. 互模拟 (Bisimilarity)

互模拟的主要思想是，如果两个进程 $P$ 和 $Q$ 是等价的，那么它们在每个动作之后都会演化为另一个等价的进程。**进程关系 (Process Relation)** $P_𝜏$ 是进程之间的一个二元关系的集合，$P_𝜏$ 描述了两个进程 $P$ 和 $Q$ 的等价性（即 $\vdash P \, \text{proc}$ 且 $\vdash Q \, \text{proc}$）。类似地，**事件关系 (Event Relation)** $E_𝜏$ 是事件之间的二元关系的集合，描述了事件 $E$ 和 $F$ 的等价性（即 $\vdash E \, \text{event}$ 且 $\vdash F \, \text{event}$）。

**强互模拟 (Strong Bisimulation)** 是一个包含进程关系 $P_𝜏$ 和事件关系 $E_𝜏$ 的二元对 $(P, E)$，需要满足以下条件：

1. 如果 $P P_𝜏 Q$，那么：
   - 如果 $P$ 通过动作 $\alpha$ 演化为 $P'$（即 $P \alpha \longrightarrow P'$），那么存在一个进程 $Q'$，使得 $Q$ 也通过相同的动作 $\alpha$ 演化为 $Q'$ 且 $P' P_𝜏 Q'$。
   - 如果 $Q$ 通过动作 $\alpha$ 演化为 $Q'$，则存在进程 $P'$ 使得 $P \alpha \longrightarrow P'$ 且 $P' P_𝜏 Q'$。

2. 如果 $E E_𝜏 F$，那么：
   - 如果事件 $E$ 通过动作 $\alpha$ 导致进程 $P$ 的发生（即 $E \alpha \implies P$），那么存在进程 $Q$ 使得 $F$ 通过相同的动作 $\alpha$ 导致进程 $Q$，并且 $P P_𝜏 Q$。
   - 同样，如果 $F \alpha \implies Q$，则存在进程 $P$ 使得 $E \alpha \implies P$ 且 $P P_𝜏 Q$。

这一对应关系捕捉了进程之间的**交互机会的等价性**，即两个进程通过彼此的行为模拟了彼此的交互能力。

#### 2. 强等价的定义 (Definition of Strong Equivalence)

我们定义**强等价 (strong equivalence)** 为进程关系和事件关系的一个二元对 $(\approx, \approx)$，其中如果 $P \approx_𝜏 Q$ 和 $E \approx_𝜏 F$，则存在一个强互模拟 $(P, E)$，使得 $P P_𝜏 Q$ 且 $E E_𝜏 F$。

**引理 49.3：强等价是一个强互模拟 (Strong Equivalence is a Strong Bisimulation)**

**证明：** 这一结果直接从互模拟的定义中得出，因为强等价本身是一个符合互模拟条件的关系。

#### 3. 互模拟的共归证明法 (Proof by Coinduction)

共归 (coinduction) 是一种证明方法，它适用于证明两个进程 $P$ 和 $Q$ 是强等价的。共归法通过提供一个互模拟 $(P, E)$ 来证明 $P \approx_𝜏 Q$。

一种常见的共归实例是选择 $(P, E)$ 为 $(\approx ∪ P_0, \approx ∪ E_0)$，其中 $P_0$ 和 $E_0$ 是一些辅助关系，并且已经假设 $P P_0 Q$。然后，我们要证明扩展后的关系是一个互模拟。

在这种情况下，我们假设 $P_0$ 和 $E_0$ 是成立的条件，并通过这些条件证明 $P \approx_𝜏 Q$。这种证明方式在某种意义上可以看作是“**循环推理 (circular reasoning)**”，但在互模拟证明中这是完全有效的，因为我们利用了互模拟的定义和其共归性质。

### 结论

在第 49.2 节中，我们深入探讨了**强等价**的概念，它通过**强互模拟**精确定义了进程之间的等价关系。互模拟确保了两个进程在相同的动作下演化为等价的进程，进而证明了进程的等价性。

### ---------------------------------

### 引理 49.4：强等价是等价关系

**引理陈述：**  
强等价 (strong equivalence) 是一个等价关系。

**证明：**  
为了证明强等价是等价关系，我们需要验证以下三个性质：**自反性 (reflexivity)**、**对称性 (symmetry)** 和 **传递性 (transitivity)**。此外，我们还需要验证强等价是一个**同余关系 (congruence)**，这意味着每一个由进程或事件构造的操作都保留强等价。

#### 1. 自反性 (Reflexivity)

自反性意味着对于任意进程 $P$，我们有 $P \approx P$。  
为了证明这一点，我们只需注意到**恒等关系 (identity relation)** 是一个互模拟关系 (bisimulation)。具体来说，如果 $P = Q$，那么进程 $P$ 和 $Q$ 的每一次演化都是完全相同的，因此它们显然是互模拟的。  
因此，对于任意的进程 $P$，$P \approx P$ 成立。

#### 2. 对称性 (Symmetry)

对称性意味着如果 $P \approx Q$，那么 $Q \approx P$ 也成立。  
这同样容易证明，因为互模拟关系的**逆关系** (converse) 也是一个互模拟。具体来说，如果 $P \approx Q$，那么对于每个从 $P$ 到 $P'$ 的演化，都存在从 $Q$ 到 $Q'$ 的对应演化，反之亦然。因此，如果我们反转所有的演化方向，$Q$ 和 $P$ 仍然是互模拟的。

#### 3. 传递性 (Transitivity)

传递性意味着如果 $P \approx Q$ 且 $Q \approx R$，那么 $P \approx R$。  
为了证明这一点，我们需要说明两个互模拟关系的组合仍然是一个互模拟。这是直接从互模拟的定义推导出来的：如果 $P$ 可以演化到 $P'$，且 $P' \approx Q'$，而 $Q'$ 又可以演化到 $R'$，那么我们可以结合这些演化步骤，得到 $P \approx R$。

#### 4. 同余性 (Congruence)

同余性意味着如果两个进程 $P$ 和 $Q$ 是强等价的，那么将它们嵌入到更复杂的进程构造中，它们的等价性仍然保持。为了证明强等价是一个同余关系，我们需要展示所有进程和事件的构造保持强等价性。

这要求我们将强等价关系扩展到带有自由变量的进程和事件。具体来说，关系 $\Gamma \vdash P \approx Q$ 定义为：对于每个自由变量 $\Gamma$ 的闭值代换 $\gamma$，都满足 $γ(P) \approx \gamma(Q)$。

### 引理 49.5：接受事件的强等价

**引理陈述：**  
如果 $\Gamma, x : \text{clsfd} \vdash P \approx Q$，那么 $\Gamma \vdash ? (x.P) \approx ? (x.Q)$。

**证明：**  
为了证明这一点，我们固定一个变量代换 $\gamma$，并让 $P^\gamma = \gamma(P)$ 和 $Q^\gamma = \gamma(Q)$。根据假设，$x : \text{clsfd} \vdash P^\gamma \approx Q^\gamma$，我们需要证明 $?(x.P^\gamma) \approx ?(x.Q^\gamma)$。

使用共归法 (coinduction)，我们设 $P = \approx$，并定义辅助关系 $E_0 = \{ ?(x.P'), ?(x.Q') \mid x : \text{clsfd} \vdash P' \approx Q' \}$。显然，$?(x.P^\gamma) E_0 ?(x.Q^\gamma)$。假设 $?(x.P') E_0 ?(x.Q')$，通过规则 (49.2) 的分析，如果 $?(x.P')$ 通过动作 $v \,?$ 演化为 $[v/x]P'$，其中 $v$ 是一个闭值 (val)，且 $\vdash v : \text{clsfd}$，那么 $?(x.Q')$ 也通过相同的动作演化为 $[v/x]Q'$。由于 $[v/x]P' \approx [v/x]Q'$，因此 $[v/x]P' E_0 [v/x]Q'$。对称的情况也是类似的，因此证明完成。

### 引理 49.6：类绑定的强等价

**引理陈述：**  
如果 $\Gamma \vdash, a \sim \tau P \approx Q$，那么 $\Gamma \vdash \nu a \sim \tau.P \approx \nu a \sim \tau.Q$。

**证明：**  
我们固定一个变量代换 $\gamma$，并让 $P^\gamma = \gamma(P)$ 和 $Q^\gamma = \gamma(Q)$。假设 $P^\gamma \approx, a \sim \tau Q^\gamma$，我们需要证明 $\nu a \sim \tau.P^\gamma \approx \nu a \sim \tau.Q^\gamma$。

使用共归法，我们设 $P = \approx \cup P_0$，其中 $P_0 = \{ (\nu a \sim \tau.P', \nu a \sim \tau.Q') \mid P' \approx, a \sim \tau Q' \}$。显然，$\nu a \sim \tau.P^\gamma P_0 \nu a \sim \tau.Q^\gamma$。假设 $\nu a \sim \tau.P' P_0 \nu a \sim \tau.Q'$，并且 $\nu a \sim \tau.P'$ 通过动作 $\alpha$ 演化为 $\nu a \sim \tau.P''$，其中 $\alpha$ 是有效的动作，且 $P'' = \nu a \sim \tau.P'''$。根据 $P_0$ 的定义，我们有 $P' \approx, a \sim \tau Q'$，因此 $Q'$ 也通过相同的动作 $\alpha$ 演化为 $\nu a \sim \tau.Q'''$，并且 $P''' \approx, a \sim \tau Q'''$。因此 $\nu a \sim \tau.P'' \approx \nu a \sim \tau.Q''$，证明完成。

### 总结

引理 49.5 和 49.6 捕捉了两种不同的绑定方式：一个是变量绑定 (variable binding)，另一个是类绑定 (class binding)。在变量绑定中，假设的强等价关系涉及所有变量的代换，而在类绑定中，假设的强等价关系仅涉及类名的代换。这展示了变量和类必须是不同的概念，混淆这两者会导致问题。

### ---------------------------------

### 引理 49.7：如果 $\Gamma \vdash P_1 \approx Q_1$ 且 $\Gamma \vdash P_2 \approx Q_2$，则 $\Gamma \vdash P_1 \otimes P_2 \approx Q_1 \otimes Q_2$

**引理陈述：**  
如果两个进程 $P_1$ 和 $Q_1$ 是等价的，同时另两个进程 $P_2$ 和 $Q_2$ 也是等价的，那么它们的组合 $P_1 \otimes P_2$ 和 $Q_1 \otimes Q_2$ 也是等价的。

**证明：**  
我们通过共归法 (coinduction) 来证明此引理，设关系 $P = \approx \cup P_0$，其中 $P_0 = \{(P'_1 \otimes P'_2, Q'_1 \otimes Q'_2) | P'_1 \approx Q'_1 \text{ 且 } P'_2 \approx Q'_2 \}$。这意味着我们假设每对 $(P_1 \otimes P_2, Q_1 \otimes Q_2)$ 都满足强等价关系的假设，且可以共归地扩展。

1. 假设 $P'_1 \otimes P'_2 P_0 Q'_1 \otimes Q'_2$ 且 $P'_1 \otimes P'_2 \alpha \rightarrow P''$。  
   根据规则 (49.2b)，我们有 $P'' = P''_1 \otimes P''_2$，且 $P'_1 \alpha \rightarrow P''_1$ 以及 $P'_2 \alpha \rightarrow P''_2$。  
   根据 $P_0$ 的定义，我们知道 $Q'_1 \alpha \rightarrow Q''_1$ 且 $Q'_2 \alpha \rightarrow Q''_2$，并且 $P''_1 \approx Q''_1$ 和 $P''_2 \approx Q''_2$。设 $Q'' = Q''_1 \otimes Q''_2$，因此 $P'' P_0 Q''$，这证明了共归假设。

对称情况和规则 (49.2a) 的处理类似。

---

### 引理 49.8：如果 $\Gamma \vdash E_1 \approx F_1$ 且 $\Gamma \vdash E_2 \approx F_2$，则 $\Gamma \vdash E_1 + E_2 \approx F_1 + F_2$

**引理陈述：**  
如果事件 $E_1$ 和 $F_1$ 是等价的，且事件 $E_2$ 和 $F_2$ 也是等价的，那么它们的组合 $E_1 + E_2$ 和 $F_1 + F_2$ 也是等价的。

**证明：**  
这个结论直接从规则 (49.2f) 和互模拟的定义中推导出来。由于 $E_1 + E_2$ 和 $F_1 + F_2$ 的演化依赖于各自子事件的演化，子事件的等价性保证了它们的组合也保持等价性。

---

### 引理 49.9：如果 $\Gamma \vdash E \approx F$，则 $\Gamma \vdash \$ E \approx \$ F$

**引理陈述：**  
如果事件 $E$ 和 $F$ 是等价的，那么它们的同步形式 $\$ E$ 和 $\$ F$ 也是等价的。

**证明：**  
此引理的证明也是直接来自规则 (49.2c) 和互模拟的定义。$\$ E$ 和 $\$ F$ 的行为完全依赖于 $E$ 和 $F$ 的演化，因此如果 $E \approx F$，那么 $\$ E \approx \$ F$。

---

### 引理 49.10：如果 $\Gamma \vdash d \sim e : \text{clsfd}$，则 $\Gamma \vdash !d \approx !e$

**引理陈述：**  
如果两个表达式 $d$ 和 $e$ 是等价的，且类型为 $\text{clsfd}$ (分类值)，那么广播事件 $!d$ 和 $!e$ 也是等价的。

**证明：**  
在进程演算中，表达式的广播操作不会引入新的观察结果。由于 $d$ 和 $e$ 在 $\text{clsfd}$ 类型下是等价的，它们作为动作也无法区分。因此 $!d$ 和 $!e$ 也将保持等价。

---

### 定理 49.11：强等价是同余关系

**定理陈述：**  
强等价是同余关系。

**证明：**  
从之前的引理中可以看到，强等价在每一种进程和事件构造的情况下都保持等价性。因此，强等价满足同余关系的要求，这意味着任意两个等价的进程或事件在更复杂的进程或事件构造中也会保持等价。

由此定理的证明可以直接从前面的引理得出：引理 49.7 处理了进程组合，49.8 处理了事件选择，49.9 处理了同步，49.10 处理了广播。因此，强等价是同余的。

### ---------------------------------

### 49.3 弱等价 (Weak Equivalence)

**弱等价概述：**  
强等价(Strong Equivalence)要求两个进程必须逐步地模拟彼此，每一个动作都必须被匹配，这对非平凡的发送和接收动作来说是自然的。然而，对于静默动作 $ε$（表示没有外部可观察的动作），这种要求可能过于严格。弱等价的目的是放宽这一限制，允许一个进程的静默动作被另一个进程的多个静默动作匹配，忽略那些不必要的微小计算差异。

**引入静默动作：**  
静默动作是进程代数中一个重要的部分，尤其是当我们处理表达式的动态行为时，静默动作用来表示表达式的隐式计算过程。  
例如，如果表达式 $e$ 计算为 $e'$，写作 $e \rightarrow e'$，则在进程中会产生对应的静默转移 $!e \epsilon \rightarrow !e'$。在进程计算中，像 $run(m)$ 这样的原子进程会根据某个底层动态规则执行命令，并且这种命令执行的每一步都会引发一个静默转移。

**弱等价的动机：**  
考虑一个例子：$run(ret \, 3+4)$ 和 $run(ret \, (1+2)+(2+2))$ 两者都最终计算出相同的值 $7$，但第二个表达式需要更多的计算步骤。因此，我们不希望因为步骤数量的不同而把它们区分开来。弱等价允许这种计算步骤上的差异被忽略，只要两者的行为在本质上相同。

**弱互模拟 (Weak Bisimulation)：**  
弱互模拟是一个由进程关系 $P$ 和事件关系 $E$ 构成的二元关系对 $(P, E)$，需要满足以下条件：

1. **进程的条件：**
   - 如果 $P P' Q$，那么：
     - 当 $P \alpha \rightarrow P'$ 且 $\alpha \neq ε$ 时，存在 $Q''$ 和 $Q'$，使得 $Q \epsilon \rightarrow^* Q'' \alpha \rightarrow Q'$ 且 $P' P Q'$。  
     - 如果 $P \epsilon \rightarrow P'$，那么 $Q \epsilon \rightarrow^* Q'$，且 $P' P Q'$。
   - 同样地，如果 $Q \alpha \rightarrow Q'$ 且 $\alpha \neq ε$，则存在 $P''$ 和 $P'$，使得 $P \epsilon \rightarrow^* P'' \alpha \rightarrow P'$，且 $P' P Q'$。如果 $Q \epsilon \rightarrow Q'$，则 $P \epsilon \rightarrow^* P'$ 且 $P' P Q'$。

2. **事件的条件：**  
   - 与强互模拟中的条件相同，因为事件没有静默动作。

**弱等价 (Weak Equivalence)：**  
弱等价是通过弱互模拟定义的。如果存在弱互模拟 $(P, E)$，使得 $P P Q$ 且 $E E F$，那么我们称 $P$ 和 $Q$ 进程是弱等价的，记作 $P ∼ Q$，同样地，对于事件 $E ∼ F$。

弱等价的开放扩展写作 $\Gamma \vdash P ∼ Q$ 和 $\Gamma \vdash E ∼ F$，其定义方式与强等价的开放扩展相同。

---

### 定理 49.12：弱等价是等价关系且是同余关系

**定理陈述：**  
弱等价是一个等价关系，同时也是一个同余关系。

**证明思路：**  
证明的基本思路与定理 49.11 类似。我们首先证明弱等价满足等价关系的三个性质：自反性、对称性和传递性。然后我们再证明它是同余关系，即弱等价在所有进程和事件构造中都保持不变。

1. **自反性：**  
   每个进程都与自身弱等价，因为没有任何进程会有与自己不相容的行为。只需通过静默转移，进程总能模拟自身。

2. **对称性：**  
   如果 $P ∼ Q$，则 $Q ∼ P$，因为弱互模拟对称性直接来自关系的定义。每当 $P$ 能进行某个转移时，$Q$ 也能进行相应的转移，反之亦然。

3. **传递性：**  
   假设 $P ∼ Q$ 且 $Q ∼ R$。通过组合这两个弱互模拟，我们可以得到一个新的弱互模拟，表明 $P ∼ R$。

4. **同余性：**  
   我们依次证明弱等价在每个进程构造和事件构造中保持不变。引理 49.7 和 49.8 证明了组合和选择保持等价，引理 49.9 证明了同步操作保持等价，最后，引理 49.10 证明了广播操作保持等价。

因此，弱等价是一个同余关系。

---

总结来说，弱等价通过允许多个静默转移的匹配，忽略了进程内部的微小计算差异，提供了更灵活的进程等价概念。

### ---------------------------------

### 有限集背景知识

本节解释了**有限集 (finite set)** 和**有限函数 (finite function)** 的概念，这些概念在计算和理论上非常常用。让我们详细解释每个概念的定义、条件和用途。

---

#### **离散集 (Discrete Set)**

**定义：**  
当一个集合 $X$ 中的元素可以被可判定的方式区分时，我们称 $X$ 为**离散的 (discrete)**。也就是说，对于任意的 $x, y \in X$，我们能够有效地判断 $x$ 是否等于 $y$。这一条件是构造性地陈述的，意味着我们能够通过算法确定两个元素是否相等。

**基本例子：**
- 自然数集 $\mathbb{N}$ 是离散集的典型例子。对于任意的两个自然数 $x, y$，我们都可以通过比较它们的值，确定它们是否相等。

#### **可数集 (Countable Set)**

**定义：**  
如果集合 $X$ 中的元素可以通过一个双射 $f : X \sim \mathbb{N}$ 与自然数集 $\mathbb{N}$ 一一对应，那么集合 $X$ 被称为**可数的 (countable)**。这意味着集合 $X$ 的元素可以被编号，我们可以构造一个映射使得每个元素都与自然数中的某个数对应。

#### **有限集 (Finite Set)**

**定义：**  
集合 $X$ 是**有限的 (finite)**，当存在一个双射 $f : X \sim \{0, ..., n-1\}$，其中 $n \in \mathbb{N}$，表明集合 $X$ 可以与某个自然数的初始段 $\{0, 1, ..., n-1\}$ 一一对应。这同样是一个构造性的定义，意味着我们不仅能够列出有限集的所有元素，还可以计算其大小。

---

#### **有限函数 (Finite Function)**

**定义：**  
给定两个可数集 $U$ 和 $V$，一个**有限函数 (finite function)** 是 $U$ 到 $V$ 之间的**部分可计算函数** $\varphi : U \to V$。这意味着 $\varphi$ 在 $U$ 的某些元素上定义，在其他元素上可能未定义。

**有限函数的定义域：**  
$\varphi$ 的定义域 (domain) 记作 $dom(\varphi)$，它是一个由 $U$ 中元素组成的集合，满足 $\varphi(u) = v$，即 $\varphi$ 在 $u$ 上定义，并且映射到 $V$ 中的某个元素 $v$。

**有限函数之间的相交性：**  
如果两个有限函数 $\varphi$ 和 $\psi$ 的定义域没有交集，即 $dom(\varphi) \cap dom(\psi) = \emptyset$，我们称它们是**不相交的 (disjoint)**。

---

#### **特殊有限函数**

1. **空函数 (Empty Function)：**  
   空有限函数 $\emptyset$ 是 $U$ 到 $V$ 之间完全未定义的部分函数。

2. **单一映射 (Singleton Mapping)：**  
   如果 $u \in U$ 且 $v \in V$，则有限函数 $u \to v$ 是将 $u$ 映射到 $v$ 的函数，并且在其他元素上未定义。它的定义域是单元素集 $\{u\}$。

3. **有限函数的并 (Union of Finite Functions)：**  
   如果 $\varphi$ 和 $\psi$ 是 $U$ 到 $V$ 的两个不相交的有限函数，则它们的并 $\varphi \otimes \psi$ 定义为：
   $$
   (\varphi \otimes \psi)(u) =
   \begin{cases}
   \varphi(u) & \text{如果 } u \in dom(\varphi) \\
   \psi(u) & \text{如果 } u \in dom(\psi) \\
   \text{未定义} & \text{否则}
   \end{cases}
   $$

4. **多对多映射：**  
   如果 $u_1, u_2, ..., u_n \in U$ 是成对不相交的元素，$v_1, v_2, ..., v_n \in V$，则有限函数 $u_1 \to v_1 \otimes u_2 \to v_2 \otimes ... \otimes u_n \to v_n$ 定义为：
   $$
   u_1 \sim v_1, ..., u_n \sim v_n
   $$
   其中，符号 $u \sim v$ 也可以表示有限函数 $u \to v$。

---

### 总结：

- **离散集 (Discrete Set)：** 一个集合的元素可以通过判定算法有效区分。
- **可数集 (Countable Set)：** 通过一个双射与自然数集对应。
- **有限集 (Finite Set)：** 通过一个双射与自然数集的有限段对应。
- **有限函数 (Finite Function)：** 是在定义域上部分定义的可计算函数，定义域是 $U$ 的一个有限子集，目标集是 $V$。

这种对有限集和有限函数的处理方法是构造性和计算性的，强调了在实践中可计算的性质。在有限集上的这些概念在许多算法和理论的基础中扮演着重要角色。


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------
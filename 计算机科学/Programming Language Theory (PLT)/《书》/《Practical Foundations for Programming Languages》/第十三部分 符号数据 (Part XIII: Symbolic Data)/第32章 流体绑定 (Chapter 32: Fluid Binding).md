[toc]



### 第33章 流动绑定（Fluid Binding）

---

本章重新探讨了**动态作用域**（Dynamic Scoping）的概念，这一概念在第8章中受到了批评。动态作用域是一种在某些编程语言中使用的变量作用域规则，但它存在一些问题。在本章中，我们将介绍一种类型安全的动态作用域的替代方案，称为**流动绑定**（Fluid Binding）。

---

#### 33.1 动态作用域的问题

##### 1. 动态作用域的定义

- **动态作用域**：在动态作用域规则下，变量的绑定是在程序执行时根据调用栈动态确定的，而不是在程序的文本结构中确定的。

- **静态作用域**：与动态作用域相反，静态作用域（或词法作用域）在程序的文本结构中确定变量的作用域，变量的绑定在编译时就已确定。

##### 2. 动态作用域的问题

在第8章中，我们指出动态作用域存在至少两个主要问题：

1. **变量重命名的问题**：

   - 在动态作用域下，对一个绑定变量进行重命名可能会改变程序的意义。
   - 这违反了我们对变量的预期行为，即变量的名字不应影响程序的逻辑。

2. **类型安全性的问题**：

   - 由于变量的作用域在运行时动态解析，类型系统无法在编译时确保变量的类型一致性。
   - 这可能导致类型错误在运行时才被发现，破坏了类型安全性。

##### 3. 动态作用域的问题的影响

- **与数学实践不符**：在数学中，变量的绑定和作用域是明确且静态的，动态作用域的行为与此不一致。

- **破坏模块化**：动态作用域使得程序的行为依赖于执行时的上下文，难以进行模块化和重用。

---

#### 33.2 流动绑定：动态作用域的类型安全替代方案

##### 1. 流动绑定的概念

为了解决动态作用域的问题，我们引入了一种新的机制，称为**流动绑定**（Fluid Binding）或**动态绑定**（Dynamic Binding）。

- **基本思想**：将动态作用域的行为从变量的概念中分离出来，引入**符号**（Symbols）和**流动绑定**的机制。

- **符号**：一种特殊的标识符，与变量不同，它不直接表示某个值，而是通过绑定机制在特定的作用域内关联到一个值。

##### 2. 流动绑定的工作原理

- **绑定过程**：

  - 在特定的作用域内，将一个值绑定到一个符号。
  - 当离开该作用域时，绑定被撤销或恢复为周围上下文中的绑定。

- **作用域控制**：流动绑定通过显式的作用域控制，避免了动态作用域中变量绑定的不确定性。

- **类型安全**：由于绑定的是符号，且类型系统明确规定了符号的类型，类型安全性得以保证。

---

### 33.1 静态语义（Statics）

---

#### 1. L{fluid} 语言的定义

我们在第32章定义的语言 L{sym} 基础上，扩展出语言 L{fluid}，增加了与流动绑定相关的构造：

##### 1.1 语法扩展

- **表达式语法**：

  $$
  \text{Exp}\ e ::= \dotsb\ |\ \text{put}[a](e_1; e_2) \quad \text{绑定} \quad \text{put } e_1\ \text{for } a\ \text{in } e_2
  $$

  $$
  \quad\quad\quad\quad |\ \text{get}[a] \quad \text{获取符号} \ a \ \text{的绑定值}
  $$

  - **$\text{put}[a](e_1; e_2)$**：在表达式 $e_2$ 的求值过程中，将符号 $a$ 绑定到值 $e_1$。
  - **$\text{get}[a]$**：获取符号 $a$ 当前的绑定值。

- **符号 $a$**：表示一个未指定的符号，与第32章一致。

##### 1.2 流动绑定的行为

- **$\text{get}[a]$**：

  - 如果符号 $a$ 有当前的绑定值，则返回该值。
  - 如果符号 $a$ 没有绑定值，则计算被卡住（stuck）。

- **$\text{put}[a](e_1; e_2)$**：

  - 将符号 $a$ 绑定到值 $e_1$，在 $e_2$ 的求值过程中生效。
  - 当 $e_2$ 的求值完成后，符号 $a$ 的绑定恢复为之前的状态。

- **注意**：符号 $a$ **不是**被 $\text{put}$ 表达式绑定的变量，而是作为一个参数使用。

#### 2. 类型系统

##### 2.1 类型判断形式

- **类型判断**：形式为 $\Gamma \vdash_{\Sigma} e : \tau$。

  - **$\Gamma$**：变量上下文，记录变量的类型信息。
  - **$\Sigma$**：符号上下文（签名，Signature），是符号声明的有限集合，形式为 $a \sim \tau$。
    - **约束**：符号 $\Sigma$ 中的每个符号只声明一次。

##### 2.2 类型规则

###### 规则 (33.1a)：获取符号绑定的类型

$$
\frac{}{\Gamma \vdash_{\Sigma, a \sim \tau}\ \text{get}[a] : \tau}
\tag{33.1a}
$$

- **解释**：

  - 在符号上下文 $\Sigma, a \sim \tau$ 下，$\text{get}[a]$ 的类型为 $\tau$。
  - **要求**：符号 $a$ 必须在 $\Sigma$ 中声明，其类型为 $\tau$。

###### 规则 (33.1b)：流动绑定的类型

$$
\frac{
\Gamma \vdash_{\Sigma, a \sim \tau_1}\ e_1 : \tau_1 \quad
\Gamma \vdash_{\Sigma, a \sim \tau_1}\ e_2 : \tau_2
}{
\Gamma \vdash_{\Sigma, a \sim \tau_1}\ \text{put}[a](e_1; e_2) : \tau_2
}
\tag{33.1b}
$$

- **解释**：

  - **$e_1$**：绑定给符号 $a$ 的值，其类型为 $\tau_1$。
  - **$e_2$**：在符号 $a$ 绑定到 $e_1$ 的情况下求值，其类型为 $\tau_2$。
  - **结论**：$\text{put}[a](e_1; e_2)$ 的类型为 $\tau_2$。

- **注意**：

  - 符号 $a$ 是表达式的参数，必须在符号上下文 $\Sigma$ 中声明，其类型为 $\tau_1$。

- **作用**：

  - 确保在 $e_1$ 和 $e_2$ 中，符号 $a$ 的类型一致，并在类型系统中得到验证。

---

### 33.2 动态语义（Dynamics）

---

#### 1. 符号的堆栈式动力学

##### 1.1 符号绑定的堆栈模型

- **堆栈式动力学**：符号的绑定在执行过程中以堆栈的方式变化，新的绑定压入堆栈，离开作用域时弹出。

- **动机**：模拟静态作用域的嵌套，但允许符号的绑定在运行时动态变化。

##### 1.2 执行过程中符号的绑定

- **绑定环境 $\mu$**：记录符号到值的映射关系，是一个有限函数。

  - **形式**：$\mu : \text{符号} \rightarrow \text{值}$。

- **符号的绑定操作**：

  - **绑定符号**：将符号 $a$ 绑定到值 $e$，表示为 $\mu \oplus (a \mapsto e)$。

  - **解除绑定**：当离开作用域时，恢复符号 $a$ 之前的绑定。

#### 2. 转换判断的形式

- **转换判断**：$e \xrightarrow{\Sigma}_{\mu} e'$。

  - **$e$**：当前的表达式。

  - **$\Sigma$**：符号上下文。

  - **$\mu$**：符号的绑定环境，记录了符号到值的映射。

  - **$e'$**：求值后的表达式。

- **符号绑定的表示**：

  - **已绑定的符号**：如果 $\mu$ 中定义了符号 $a$，则记为 $a \mapsto e$，表示 $a$ 绑定到值 $e$。

  - **未绑定的符号**：如果 $\mu$ 中未定义符号 $a$，可以视为 $a \mapsto \bullet$，其中 $\bullet$ 表示未绑定。

#### 3. 动态语义规则

##### 规则 (33.2a)：获取符号的绑定值

$$
\frac{}{\text{get}[a]\ \xrightarrow{\Sigma, a \sim \tau}_{\mu \oplus (a \mapsto e)}\ e}
\tag{33.2a}
$$

- **解释**：

  - 当符号 $a$ 在绑定环境 $\mu$ 中绑定到值 $e$，则 $\text{get}[a]$ 求值为 $e$。

  - **要求**：符号 $a$ 必须在符号上下文 $\Sigma$ 中声明，其类型为 $\tau$。

- **含义**：

  - **$\text{get}[a]$** 操作从当前的绑定环境中获取符号 $a$ 的值。

##### 规则 (33.2b)：绑定值的求值

$$
\frac{
e_1\ \xrightarrow{\Sigma}_{\mu}\ e_1'
}{
\text{put}[a](e_1; e_2)\ \xrightarrow{\Sigma}_{\mu}\ \text{put}[a](e_1'; e_2)
}
\tag{33.2b}
$$

- **解释**：

  - 在绑定环境 $\mu$ 下，首先求值 $e_1$，结果为 $e_1'$。

  - 然后，继续求值 $\text{put}[a](e_1'; e_2)$。

- **含义**：

  - **绑定前**，需要先求值绑定值 $e_1$。

##### 规则 (33.2c)：在新的绑定环境下求值 $e_2$

$$
\frac{
e_1\ \text{val}_{\Sigma, a \sim \tau} \quad e_2\ \xrightarrow{\Sigma, a \sim \tau}_{\mu \oplus (a \mapsto e_1)}\ e_2'
}{
\text{put}[a](e_1; e_2)\ \xrightarrow{\Sigma}_{\mu}\ \text{put}[a](e_1; e_2')
}
\tag{33.2c}
$$

- **解释**：

  - 当 $e_1$ 已经求值到一个值，在绑定环境 $\mu \oplus (a \mapsto e_1)$ 下，求值 $e_2$，得到 $e_2'$。

  - 然后，继续求值 $\text{put}[a](e_1; e_2')$。

- **含义**：

  - **在 $e_2$ 的求值过程中**，符号 $a$ 被绑定到值 $e_1$。

  - 无论 $a$ 是否已经在环境中绑定，都将新的绑定添加到环境中。

##### 规则 (33.2d)：解除绑定

$$
\frac{
e_1\ \text{val}_{\Sigma, a \sim \tau} \quad e_2\ \text{val}_{\Sigma, a \sim \tau}
}{
\text{put}[a](e_1; e_2)\ \xrightarrow{\Sigma}_{\mu}\ e_2
}
\tag{33.2d}
$$

- **解释**：

  - 当 $e_1$ 和 $e_2$ 都已经求值到值，$\text{put}[a](e_1; e_2)$ 求值为 $e_2$。

- **含义**：

  - **流动绑定结束**：当 $e_2$ 的求值完成后，解除符号 $a$ 的绑定，恢复之前的环境。

#### 4. 动态语义规则的总结

- **规则 (33.2a)**：获取符号的当前绑定值。

- **规则 (33.2b)**：在创建绑定之前，先求值绑定的值。

- **规则 (33.2c)**：在新的绑定环境下求值作用域内的表达式。

- **规则 (33.2d)**：当作用域内的求值完成后，解除绑定，恢复之前的环境。

#### 5. 卡住状态和未绑定判断

##### 5.1 卡住状态

- **卡住状态（stuck state）**：当尝试获取一个未绑定的符号的值时，程序无法继续执行，进入卡住状态。

- **示例**：如果 $\mu(a) = \bullet$，即符号 $a$ 未绑定，那么 $\text{get}[a]$ 无法继续求值。

##### 5.2 未绑定判断

- **判断形式**：$e\ \text{unbound}_{\mu}$，表示表达式 $e$ 在绑定环境 $\mu$ 下会导致卡住状态。

- **定义**：通过以下规则归纳定义未绑定判断。

###### 规则 (33.3a)：获取未绑定符号

$$
\frac{\mu(a) = \bullet}{\text{get}[a]\ \text{unbound}_{\mu}}
\tag{33.3a}
$$

- **解释**：如果符号 $a$ 未绑定，则 $\text{get}[a]$ 会导致卡住状态。

###### 规则 (33.3b)：绑定值导致卡住

$$
\frac{e_1\ \text{unbound}_{\mu}}{\text{put}[a](e_1; e_2)\ \text{unbound}_{\mu}}
\tag{33.3b}
$$

- **解释**：如果 $e_1$ 会导致卡住，那么 $\text{put}[a](e_1; e_2)$ 也会导致卡住。

###### 规则 (33.3c)：作用域内表达式导致卡住

$$
\frac{e_1\ \text{val}_{\Sigma} \quad e_2\ \text{unbound}_{\mu}}{\text{put}[a](e_1; e_2)\ \text{unbound}_{\mu}}
\tag{33.3c}
$$

- **解释**：如果 $e_1$ 已经求值到值，但 $e_2$ 会导致卡住，那么 $\text{put}[a](e_1; e_2)$ 也会导致卡住。

##### 5.3 错误传播规则

- 在更大的语言中，还需要包含错误传播规则，使得卡住状态可以在程序中正确传播和处理。

- **参考**：第6章讨论的错误传播规则。

---

### 33.3 类型安全性（Type Safety）

---

虽然在原文中没有给出类型安全性的证明，但我们可以推测并讨论流动绑定机制下的类型安全性。

#### 1. 类型安全性的目标

- **保持性（Preservation）**：如果在给定的类型环境下，表达式 $e$ 的类型为 $\tau$，并且 $e$ 可以转换为 $e'$，那么 $e'$ 的类型仍然是 $\tau$。

- **前进性（Progress）**：如果表达式 $e$ 在给定的类型环境下类型为 $\tau$，那么 $e$ 要么是一个值，要么可以进一步求值。

#### 2. 保持性的讨论

- **流动绑定的类型规则**确保了在绑定和解除绑定过程中，类型的一致性。

- **动态语义规则**中的每一步转换都保持了类型的正确性。

#### 3. 前进性的讨论

- **卡住状态的处理**：

  - 当尝试获取一个未绑定的符号时，程序会进入卡住状态。

  - 为了维持前进性，我们需要确保在程序中不会出现对未绑定符号的获取。

- **类型系统的作用**：

  - 类型系统无法直接防止获取未绑定符号，因为绑定环境是在运行时维护的。

  - 程序员需要确保符号在使用前已正确绑定。

#### 4. 错误处理机制

- 为了增强类型安全性和程序的鲁棒性，可以引入错误处理和传播机制。

- **示例**：当获取未绑定的符号时，抛出一个运行时错误，程序可以捕获并处理该错误，而不是进入卡住状态。

---

### 总结

---

在本章中，我们介绍了**流动绑定**（Fluid Binding）作为动态作用域的类型安全替代方案。通过将动态绑定从变量的概念中分离出来，引入符号和显式的绑定机制，我们解决了动态作用域中变量重命名和类型安全性的问题。

- **符号**：作为特殊的标识符，具有明确的类型，与绑定机制关联。

- **流动绑定机制**：允许在特定作用域内将值绑定到符号，离开作用域后绑定被撤销或恢复。

- **类型系统**：通过符号上下文和类型规则，确保了符号绑定和获取操作的类型安全性。

- **动力学**：采用堆栈式的符号绑定模型，定义了符号绑定和解除的执行过程。

- **错误处理**：考虑了获取未绑定符号时的卡住状态，并讨论了错误传播的必要性。

通过引入流动绑定，我们在保持类型安全性的同时，获得了动态作用域的一些灵活性。这对于需要动态绑定机制的编程语言设计和程序开发具有重要意义。

### ---------------------------------

### 33.3 类型安全（Type Safety）

---

在上一节中，我们讨论了流动绑定（Fluid Binding）的静态语义和动态语义。本节将证明在引入流动绑定后，语言仍然满足类型安全性（Type Safety），即保持性（Preservation）和前进性（Progress）。为此，我们需要定义一个辅助判断，并证明相关的定理。

#### 1. 辅助判断的定义

为了在证明类型安全性时处理符号绑定的类型，我们定义一个辅助判断 $\mu : \Sigma$，其规则如下：

##### 规则 (33.4a)：空环境

$$
\frac{}{\emptyset : \emptyset}
\tag{33.4a}
$$

- **解释**：
  - 空的绑定环境 $\mu = \emptyset$ 对应于空的符号上下文 $\Sigma = \emptyset$。

##### 规则 (33.4b)：绑定符号到值

$$
\frac{
\vdash_{\Sigma} e : \tau \quad \mu : \Sigma
}{
\mu \oplus (a \mapsto e) : \Sigma, a \sim \tau
}
\tag{33.4b}
$$

- **解释**：
  - 如果在符号上下文 $\Sigma$ 下，表达式 $e$ 的类型为 $\tau$，且 $\mu$ 对应于 $\Sigma$（即 $\mu : \Sigma$），
  - 那么将符号 $a$ 绑定到值 $e$ 的新绑定环境 $\mu \oplus (a \mapsto e)$ 对应于扩展了符号上下文的 $\Sigma, a \sim \tau$。

##### 规则 (33.4c)：符号未绑定

$$
\frac{
\mu : \Sigma
}{
\mu \oplus (a \mapsto \bullet) : \Sigma, a \sim \tau
}
\tag{33.4c}
$$

- **解释**：
  - 如果 $\mu$ 对应于符号上下文 $\Sigma$，
  - 那么将符号 $a$ 未绑定（或绑定到“黑洞” $\bullet$）的绑定环境 $\mu \oplus (a \mapsto \bullet)$ 对应于扩展了符号上下文的 $\Sigma, a \sim \tau$。

**注意**：

- 这些规则规定了绑定环境 $\mu$ 和符号上下文 $\Sigma$ 之间的关系。
- 特别地，当符号 $a$ 被绑定到一个值时，该值必须是符号上下文 $\Sigma$ 中与 $a$ 关联的类型 $\tau$ 的值。

#### 2. 类型安全性的证明

我们将证明以下两个定理，以确保流动绑定机制下的类型安全性。

---

##### 定理 33.1（保持性，Preservation）

**陈述**：

如果 $e\ \xrightarrow{\Sigma}_{\mu}\ e'$，其中 $\mu : \Sigma$ 且 $\vdash_{\Sigma} e : \tau$，那么 $\vdash_{\Sigma} e' : \tau$。

**解释**：

- 在绑定环境 $\mu$ 和符号上下文 $\Sigma$ 下，表达式 $e$ 的类型为 $\tau$，且 $e$ 转换为 $e'$。
- 那么，$e'$ 在符号上下文 $\Sigma$ 下的类型仍然是 $\tau$。

**证明思路**：

- 我们对动态语义规则（33.2）的应用进行规则归纳（Rule Induction）。

**证明详情**：

1. **对于规则 (33.2a)**：

   - 该规则处理 $\text{get}[a]$ 的求值。
   - 由于 $\mu : \Sigma$，根据辅助判断的定义，$\mu(a)$ 要么未绑定（$\bullet$），要么绑定到某个值 $e$，且 $\vdash_{\Sigma} e : \tau$。
   - 因此，当 $\text{get}[a]$ 求值为 $e$ 时，$\vdash_{\Sigma} e : \tau$，满足保持性。

2. **对于规则 (33.2b)**：

   - 该规则处理 $\text{put}[a](e_1; e_2)$ 中 $e_1$ 的求值。
   - 根据归纳假设，$e_1$ 的求值保持类型不变。
   - 因此，$\text{put}[a](e_1'; e_2)$ 的类型仍然是 $\tau$。

3. **对于规则 (33.2c)**：

   - 该规则处理在新的绑定环境下求值 $e_2$。
   - 通过对类型规则（33.1）的逆向推理和归纳假设，我们可以得出 $e_2'$ 的类型仍然是 $\tau_2$。
   - 因此，$\text{put}[a](e_1; e_2')$ 的类型为 $\tau_2$，满足保持性。

4. **对于规则 (33.2d)**：

   - 该规则在 $e_1$ 和 $e_2$ 都已求值到值的情况下，$\text{put}[a](e_1; e_2)$ 求值为 $e_2$。
   - 由于 $\vdash_{\Sigma} e_2 : \tau_2$，因此 $\vdash_{\Sigma} e_2 : \tau_2$，满足保持性。

**结论**：

- 在所有情况下，转换后的表达式 $e'$ 的类型与原始表达式 $e$ 的类型相同，证明了保持性。

---

##### 定理 33.2（前进性，Progress）

**陈述**：

如果 $\vdash_{\Sigma} e : \tau$ 且 $\mu : \Sigma$，那么要么 $e$ 是值（$e\ \text{val}_{\Sigma}$），要么 $e$ 未绑定（$e\ \text{unbound}_{\mu}$），要么存在 $e'$ 使得 $e\ \xrightarrow{\Sigma}_{\mu}\ e'$。

**解释**：

- 在符号上下文 $\Sigma$ 和绑定环境 $\mu$ 下，表达式 $e$ 要么已经求值到值，要么会导致未绑定错误，要么可以进一步求值。

**证明思路**：

- 我们对类型规则（33.1）进行规则归纳。

**证明详情**：

1. **对于规则 (33.1a)**（处理 $\text{get}[a]$）：

   - 我们知道 $\Sigma$ 中包含 $a \sim \tau$。
   - 由于 $\mu : \Sigma$，根据辅助判断的定义，有两种情况：
     - **情况 1**：$\mu(a) = \bullet$，即 $a$ 未绑定。
       - 此时，根据未绑定判断规则 (33.3a)，$\text{get}[a]\ \text{unbound}_{\mu}$。
     - **情况 2**：$\mu(a) = e$，且 $\vdash_{\Sigma} e : \tau$。
       - 此时，根据动态语义规则 (33.2a)，$\text{get}[a]\ \xrightarrow{\Sigma}_{\mu}\ e$。

2. **对于规则 (33.1b)**（处理 $\text{put}[a](e_1; e_2)$）：

   - 根据归纳假设，对 $e_1$ 进行分析：
     - **情况 1**：$e_1\ \text{val}_{\Sigma}$，即 $e_1$ 已经是一个值。
     - **情况 2**：$e_1\ \text{unbound}_{\mu}$，即 $e_1$ 会导致未绑定错误。
     - **情况 3**：存在 $e_1'$，使得 $e_1\ \xrightarrow{\Sigma}_{\mu}\ e_1'$。
   - **处理**：
     - **情况 1**（$e_1$ 是值）：
       - 根据归纳假设，对 $e_2$ 进行分析：
         - **子情况 1**：$e_2\ \text{val}_{\Sigma}$。
           - 根据动态语义规则 (33.2d)，$\text{put}[a](e_1; e_2)\ \xrightarrow{\Sigma}_{\mu}\ e_2$。
         - **子情况 2**：$e_2\ \text{unbound}_{\mu \oplus (a \mapsto e_1)}$。
           - 根据未绑定判断规则 (33.3c)，$\text{put}[a](e_1; e_2)\ \text{unbound}_{\mu}$。
         - **子情况 3**：存在 $e_2'$，使得 $e_2\ \xrightarrow{\Sigma}_{\mu \oplus (a \mapsto e_1)}\ e_2'$。
           - 根据动态语义规则 (33.2c)，$\text{put}[a](e_1; e_2)\ \xrightarrow{\Sigma}_{\mu}\ \text{put}[a](e_1; e_2')$。
     - **情况 2**（$e_1$ 未绑定）：
       - 根据未绑定判断规则 (33.3b)，$\text{put}[a](e_1; e_2)\ \text{unbound}_{\mu}$。
     - **情况 3**（$e_1$ 可进一步求值）：
       - 根据动态语义规则 (33.2b)，$\text{put}[a](e_1; e_2)\ \xrightarrow{\Sigma}_{\mu}\ \text{put}[a](e_1'; e_2)$。

**结论**：

- 在所有情况下，要么表达式 $e$ 已经求值到值，要么会导致未绑定错误，要么可以进一步求值，证明了前进性。

---

### 33.4 一些微妙之处（Some Subtleties）

---

在引入流动绑定后，程序的行为可能会出现一些微妙的情况，特别是在处理返回值为函数类型的表达式时。本节将通过示例来探讨这些细节，并讨论其对程序设计的影响。

#### 1. 流动绑定对函数类型的影响

##### 1.1 基本类型的情况

- 当 $\text{put}\ e_1\ \text{for}\ a\ \text{in}\ e_2$ 的类型是基本类型（如 $\text{nat}$）时，绑定的恢复不会影响结果的意义。
- 因为基本类型的值在求值时已经确定，不再依赖于符号的绑定。

##### 1.2 函数类型的情况

- 如果 $\text{put}\ e_1\ \text{for}\ a\ \text{in}\ e_2$ 的类型是函数类型，即返回值是一个 $\lambda$ 抽象（lambda abstraction）。
- 返回的函数体可能引用符号 $a$ 的绑定。
- **问题**：当离开 $\text{put}$ 的作用域后，符号 $a$ 的绑定被恢复或解除，导致函数体中的 $\text{get}[a]$ 无法找到有效的绑定。

#### 2. 示例分析

##### 示例 1：流动绑定下返回函数

考虑以下表达式：

$$
\text{put } 17\ \text{for } a\ \text{in}\ \lambda (x:\text{nat})\ x + \text{get}[a]
\tag{33.5}
$$

- **解释**：
  - 我们在符号 $a$ 绑定到值 $17$ 的情况下，定义了一个函数 $\lambda (x:\text{nat})\ x + \text{get}[a]$。
  - 符号 $a$ 的类型为 $\text{nat}$。
- **行为**：
  - 该表达式返回一个函数，其行为取决于符号 $a$ 的绑定。
  - 离开 $\text{put}$ 的作用域后，符号 $a$ 的绑定被解除。
- **问题**：
  - 如果在没有绑定符号 $a$ 的情况下调用返回的函数，将导致运行时错误，因为 $\text{get}[a]$ 无法找到绑定。

##### 示例 2：在调用函数时提供绑定

假设我们将表达式 (33.5) 的结果赋值给变量 $f$，即 $f = \text{put } 17\ \text{for } a\ \text{in}\ \lambda (x:\text{nat})\ x + \text{get}[a]$。

考虑以下表达式：

1. **提供新的绑定**：

   $$
   \text{put } 21\ \text{for } a\ \text{in}\ f(7)
   \tag{33.6}
   $$

   - **解释**：
     - 在符号 $a$ 绑定到 $21$ 的情况下，调用函数 $f(7)$。
   - **结果**：
     - 计算 $7 + \text{get}[a] = 7 + 21 = 28$。
   - **说明**：
     - 即使函数 $f$ 定义时符号 $a$ 绑定到 $17$，但在调用时，$a$ 绑定到新的值 $21$。

2. **没有提供绑定**：

   - **表达式**：$f(7)$
   - **结果**：
     - 由于符号 $a$ 未绑定，$\text{get}[a]$ 导致运行时错误。

##### 示例 3：使用静态绑定的变量

对比以下使用静态绑定变量的表达式：

$$
\text{let } y = 17\ \text{in}\ \lambda (x:\text{nat})\ x + y
\tag{33.7}
$$

- **解释**：
  - 我们使用静态绑定的变量 $y$，定义了一个函数 $\lambda (x:\text{nat})\ x + y$。
- **行为**：
  - 该函数返回 $x + 17$，与符号的绑定无关。
- **说明**：
  - 静态绑定的变量在函数定义时就确定了，其值不会在函数调用时改变，也不会受外部环境影响。
  - 这避免了运行时未绑定错误的风险。

#### 3. 讨论与比较

##### 3.1 流动绑定与额外参数

- **流动绑定的作用**：
  - 提供了一种在函数调用时动态传递参数的方式，而不需要在函数定义中显式增加参数。
- **模拟流动绑定**：
  - 可以通过在函数中增加额外的参数来模拟流动绑定的行为。

##### 示例：增加额外参数

1. **定义新的函数**：

   $$
   e' = \lambda (y:\text{nat})\ \lambda (x:\text{nat})\ x + y
   $$

2. **调用函数**：

   - **第一次调用**：$e'(7)(9)$，结果为 $9 + 7 = 16$。
   - **第二次调用**：$e'(8)(9)$，结果为 $9 + 8 = 17$。

- **比较**：
  - 通过显式传递参数 $y$，我们可以在函数调用时控制其行为，与使用流动绑定时相同。

##### 3.2 流动绑定的优缺点

- **优点**：
  - 简化了函数调用时参数的传递，特别是当多个调用使用相同的绑定时。
  - 使得代码更简洁，更易于维护。

- **缺点**：
  - 函数的类型无法反映其对符号绑定的依赖性。
  - 可能导致运行时错误（未绑定符号），难以及早在编译时发现问题。

##### 3.3 编程实践的考虑

- **使用流动绑定**：
  - 适用于需要在运行时动态改变函数行为的场景。
  - 需要小心管理符号的绑定，避免未绑定错误。

- **使用显式参数**：
  - 函数类型清晰，参数依赖性明确。
  - 增加了代码的冗余度，但提高了类型安全性。

#### 4. 总结

- 流动绑定提供了一种灵活的机制，可以在函数调用时动态控制其行为。
- 然而，这种灵活性可能带来类型安全性的问题，因为函数的类型无法体现其对符号绑定的依赖。
- 在编程语言设计中，需要权衡流动绑定的便利性与类型系统的完整性。
- 对于需要严格类型安全性的场景，显式传递参数可能是更好的选择。

---

### 总结

在本章中，我们深入探讨了流动绑定机制的类型安全性和一些潜在的细节问题。通过定义辅助判断和证明类型安全性定理，我们确认了流动绑定在我们的语言中是类型安全的。然而，当处理返回值为函数类型的表达式时，流动绑定可能会引入一些微妙的问题，需要程序员注意。

在实际编程中，流动绑定提供了灵活性，但也带来了类型系统无法捕获的依赖性。因此，理解流动绑定的工作原理，谨慎地使用它，才能充分发挥其优势，同时避免潜在的运行时错误。

### ---------------------------------

### 33.5 流动引用（Fluid References）

---

#### 1. 引入流动引用的动机

在之前的**流动绑定**（Fluid Binding）机制中，`get` 和 `put` 操作都需要在语法中显式指定目标符号。这意味着我们在编写代码时，必须静态地指定要操作的符号。这种静态绑定限制了程序的灵活性，无法在运行时动态地选择要操作的符号。

**问题**：

- **静态限制**：无法在运行时动态选择要绑定或获取的符号。
- **灵活性不足**：对于一些需要动态决定符号的程序，显得不够灵活。

**解决方案**：

- 引入**流动引用**（Fluid References），允许将符号的名字表示为一个值。
- 通过引入对流动绑定的引用，可以在运行时动态地选择要操作的符号。

---

#### 2. 流动引用的语法扩展

为了支持流动引用，我们对语言 L{fluid} 进行了扩展，增加了以下语法：

##### 2.1 类型语法

$$
\text{Typ}\ \tau ::= \dotsb\ |\ \text{fluid}(\tau) \quad \text{流动类型}
$$

- **$\text{fluid}(\tau)$**：表示对类型为 $\tau$ 的流动绑定的引用类型。

##### 2.2 表达式语法

$$
\text{Exp}\ e ::= \dotsb\ |\ \text{fl}[a] \quad \text{引用符号}\ a \\
\quad\quad\quad\quad\quad |\ \text{getfl}(e) \quad \text{获取流动绑定} \\
\quad\quad\quad\quad\quad |\ \text{putfl}(e; e_1; e_2) \quad \text{绑定流动绑定}
$$

- **$\text{fl}[a]$**：将符号 $a$ 作为一个值，类型为 $\text{fluid}(\tau)$。
- **$\text{getfl}(e)$**：获取流动引用 $e$ 指向的符号的绑定值。
- **$\text{putfl}(e; e_1; e_2)$**：在 $e_2$ 的求值过程中，将流动引用 $e$ 指向的符号绑定到值 $e_1$。

---

#### 3. 流动引用的静态语义（Statics）

流动引用的类型规则如下：

##### 规则 (33.8a)：流动引用的引入

$$
\frac{}{\Gamma \vdash_{\Sigma, a \sim \tau}\ \text{fl}[a] : \text{fluid}(\tau)}
\tag{33.8a}
$$

- **解释**：
  - 在符号上下文 $\Sigma, a \sim \tau$ 下，$\text{fl}[a]$ 的类型为 $\text{fluid}(\tau)$。
  - 符号 $a$ 必须在 $\Sigma$ 中声明，其类型为 $\tau$。

##### 规则 (33.8b)：获取流动引用的绑定值

$$
\frac{
\Gamma \vdash_{\Sigma}\ e : \text{fluid}(\tau)
}{
\Gamma \vdash_{\Sigma}\ \text{getfl}(e) : \tau
}
\tag{33.8b}
$$

- **解释**：
  - 如果 $e$ 的类型为 $\text{fluid}(\tau)$，则 $\text{getfl}(e)$ 的类型为 $\tau$。

##### 规则 (33.8c)：绑定流动引用的符号

$$
\frac{
\Gamma \vdash_{\Sigma}\ e : \text{fluid}(\tau) \quad
\Gamma \vdash_{\Sigma}\ e_1 : \tau \quad
\Gamma \vdash_{\Sigma}\ e_2 : \tau_2
}{
\Gamma \vdash_{\Sigma}\ \text{putfl}(e; e_1; e_2) : \tau_2
}
\tag{33.8c}
$$

- **解释**：
  - **$e$**：流动引用，类型为 $\text{fluid}(\tau)$。
  - **$e_1$**：要绑定给符号的值，类型为 $\tau$。
  - **$e_2$**：在绑定发生的情况下求值的表达式，类型为 $\tau_2$。
  - **结论**：$\text{putfl}(e; e_1; e_2)$ 的类型为 $\tau_2$。

##### 3.1 可移动性的限制

- **注意**：由于我们使用的是有作用域的动力学（Scoped Dynamics），因此对流动绑定的引用不能被视为可移动的。
- **原因**：流动引用可能涉及到局部符号的绑定，如果被移动到作用域之外，可能导致绑定的丢失，破坏类型安全性。

---

#### 4. 流动引用的动态语义（Dynamics）

流动引用的动力学包括解析引用的符号，并调用作用于符号的基本操作。

##### 规则 (33.9a)：流动引用是值

$$
\frac{}{\text{fl}[a]\ \text{val}_{\Sigma, a \sim \tau}}
\tag{33.9a}
$$

- **解释**：$\text{fl}[a]$ 在符号上下文 $\Sigma, a \sim \tau$ 下是一个值。

##### 规则 (33.9b)：求值 $\text{getfl}(e)$ 的参数

$$
\frac{
e\ \xrightarrow{\Sigma}_{\mu}\ e'
}{
\text{getfl}(e)\ \xrightarrow{\Sigma}_{\mu}\ \text{getfl}(e')
}
\tag{33.9b}
$$

- **解释**：如果 $e$ 可以求值为 $e'$，则 $\text{getfl}(e)$ 求值为 $\text{getfl}(e')$。

##### 规则 (33.9c)：解析 $\text{getfl}(\text{fl}[a])$

$$
\frac{}{\text{getfl}(\text{fl}[a])\ \xrightarrow{\Sigma}_{\mu}\ \text{get}[a]}
\tag{33.9c}
$$

- **解释**：当 $e$ 是 $\text{fl}[a]$ 时，$\text{getfl}(e)$ 求值为 $\text{get}[a]$。

##### 规则 (33.9d)：求值 $\text{putfl}(e; e_1; e_2)$ 的参数

$$
\frac{
e\ \xrightarrow{\Sigma}_{\mu}\ e'
}{
\text{putfl}(e; e_1; e_2)\ \xrightarrow{\Sigma}_{\mu}\ \text{putfl}(e'; e_1; e_2)}
\tag{33.9d}
$$

- **解释**：如果 $e$ 可以求值为 $e'$，则 $\text{putfl}(e; e_1; e_2)$ 求值为 $\text{putfl}(e'; e_1; e_2)$。

##### 规则 (33.9e)：解析 $\text{putfl}(\text{fl}[a]; e_1; e_2)$

$$
\frac{}{\text{putfl}(\text{fl}[a]; e_1; e_2)\ \xrightarrow{\Sigma}_{\mu}\ \text{put}[a](e_1; e_2)}
\tag{33.9e}
$$

- **解释**：当 $e$ 是 $\text{fl}[a]$ 时，$\text{putfl}(e; e_1; e_2)$ 求值为 $\text{put}[a](e_1; e_2)$。

---

#### 5. 示例：使用流动引用

##### 5.1 动机

- **场景**：希望在运行时动态地选择要操作的符号，而不是在编写代码时静态地指定。

##### 5.2 示例代码

```pseudo
// 定义符号 a 和 b，其类型为 nat
Σ = { a ∼ nat, b ∼ nat }

// 创建对符号的流动引用
let ref = if condition then fl[a] else fl[b];

// 绑定符号引用 ref 到值 42，在表达式 e 中生效
putfl(ref; 42; e)

// 在表达式 e 中获取符号引用 ref 的绑定值
let value = getfl(ref)
```

##### 5.3 解释

- **条件选择**：根据条件选择要操作的符号引用，`ref` 可能是 `fl[a]` 或 `fl[b]`。
- **动态绑定**：使用 `putfl(ref; 42; e)`，在表达式 `e` 中将 `ref` 指向的符号绑定到值 `42`。
- **动态获取**：在表达式 `e` 中，使用 `getfl(ref)` 获取绑定的值。

---

#### 6. 总结

- **流动引用**扩展了流动绑定的机制，允许在运行时动态地选择要操作的符号。
- **类型系统**确保了流动引用的类型安全性，规定了流动引用的类型和相关操作的类型规则。
- **动态语义**定义了流动引用的求值过程，通过解析引用的符号，委托给基本的 `get` 和 `put` 操作。

---

### 33.6 注释（Notes）

---

#### 1. 动态绑定的历史背景

- **早期 Lisp 方言**：动态绑定的概念起源于早期的 Lisp 方言中，当时变量和符号的概念混淆在一起。
- **变量和符号的区分**：
  - **变量**：在正确区分后，变量保留了其替换意义（Substitutive Meaning），即通过替换实现变量的绑定。
  - **符号**：引入了一个独立的概念，即流动绑定，使得符号可以独立于变量进行动态绑定。

#### 2. 相关文献

- **Allen (1978)**：Allen 在 1978 年的工作中对流动绑定的实现进行了深入的讨论。
  - **参考文献**：Allen, J. R. (1978). Anatomy of Lisp. McGraw-Hill.
- **Nanevski (2003)**：本章的表述也借鉴了 Nanevski 在 2003 年的工作。
  - **参考文献**：Nanevski, A. (2003). Functional programming with names and necessity. In Proceedings of the 30th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL '03).

#### 3. 重要性

- **符号与变量的分离**：正确区分变量和符号，有助于设计更加健全和灵活的编程语言。
- **流动绑定的作用**：流动绑定为程序提供了动态绑定的能力，支持在运行时动态地改变符号的绑定。
- **类型安全性**：通过引入符号和流动绑定，可以在保持类型安全性的同时，提供动态绑定的功能。

---

### 练习题与讨论

虽然在提供的文本中没有直接的练习题，但我们可以基于内容设计一些练习，以加深对流动引用和流动绑定的理解。

#### 练习 1：流动引用的类型推导

**题目**：给定符号上下文 $\Sigma = \{ a \sim \text{nat}, b \sim \text{bool} \}$，推导以下表达式的类型：

1. $\text{fl}[a]$
2. $\text{getfl}(\text{fl}[b])$
3. $\text{putfl}(\text{fl}[a]; 5; \text{getfl}(\text{fl}[a]))$

**解答**：

1. **$\text{fl}[a]$**：
   - 根据规则 (33.8a)，$\Gamma \vdash_{\Sigma, a \sim \text{nat}}\ \text{fl}[a] : \text{fluid}(\text{nat})$。
   - **类型**：$\text{fluid}(\text{nat})$。

2. **$\text{getfl}(\text{fl}[b])$**：
   - 首先，$\text{fl}[b]$ 的类型为 $\text{fluid}(\text{bool})$。
   - 根据规则 (33.8b)，$\Gamma \vdash_{\Sigma}\ \text{getfl}(\text{fl}[b]) : \text{bool}$。
   - **类型**：$\text{bool}$。

3. **$\text{putfl}(\text{fl}[a]; 5; \text{getfl}(\text{fl}[a]))$**：
   - $\text{fl}[a]$ 的类型为 $\text{fluid}(\text{nat})$。
   - $5$ 的类型为 $\text{nat}$。
   - $\text{getfl}(\text{fl}[a])$ 的类型为 $\text{nat}$。
   - 根据规则 (33.8c)，$\Gamma \vdash_{\Sigma}\ \text{putfl}(\text{fl}[a]; 5; \text{getfl}(\text{fl}[a])) : \text{nat}$。
   - **类型**：$\text{nat}$。

#### 练习 2：流动引用的动态求值

**题目**：考虑以下程序片段，求出其求值结果，或者说明是否会产生运行时错误。

```pseudo
// 符号上下文：Σ = { a ∼ nat }
let ref = fl[a];
let result = putfl(ref; 10; getfl(ref));
```

**解答**：

- **步骤 1**：`ref = fl[a]`，`ref` 的值是 `fl[a]`，类型为 `fluid(nat)`。
- **步骤 2**：`putfl(ref; 10; getfl(ref))`：
  - **绑定**：在 `getfl(ref)` 的求值过程中，符号 `a` 被绑定到 `10`。
  - **求值**：`getfl(ref)` 被解析为 `get[a]`，返回绑定的值 `10`。
- **结果**：`result = 10`。

---

### 总结

通过引入**流动引用**，我们进一步扩展了流动绑定的能力，使得程序可以在运行时动态地选择和操作符号。这种机制在保持类型安全性的同时，提供了更大的灵活性。

在编程语言设计中，正确区分变量和符号，以及理解它们各自的作用，对于构建健全和强大的语言至关重要。流动绑定和流动引用为程序员提供了强大的工具，但也需要谨慎使用，以避免潜在的运行时错误。

通过对本章内容的学习和练习，我们加深了对流动绑定和流动引用的理解，为进一步探索编程语言的高级特性奠定了基础。


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------
[toc]





### ---------------------------------

### 第32章 符号（Symbols）

---

在编程语言理论中，**符号**（Symbol）是一个没有内部结构的原子数据类型。它的主要特征在于：

- **原子性**：符号是不可分割的，没有内部结构。
- **唯一性**：每个符号都是独特的，可以用来标识特定的对象或操作。

符号的引入丰富了编程语言的表达能力，使我们能够模拟各种概念，如：

- **流动绑定**（Fluid Binding）
- **动态分类**（Dynamic Classification）
- **可变存储**（Mutable Storage）
- **通信信道**（Communication Channels）

下面我们将详细探讨符号的定义、作用、以及在编程语言中的应用。

---

#### 32.1 符号声明（Symbol Declaration）

##### 1. 符号与变量的区别

在讨论符号之前，先了解它与变量的区别：

- **变量**：通过替换（Substitution）获得意义，变量的值可以被替换为其他值。
- **符号**：通过一组以符号为索引的操作获得意义。符号本身没有内部结构，也不直接表示某个值。

**举例**：

- 变量 `x` 可以被赋值为 `5`，并在表达式中使用，如 `x + 2`。
- 符号 `a` 不是一个值，而是一个标识符，用于在操作中引用特定的实例。

##### 2. 符号的意义

符号的意义取决于与其关联的操作。不同的操作可以赋予符号不同的语义，例如：

- **可变存储**：符号可以表示存储单元的地址，操作可以读取或写入该地址的值。
- **通信信道**：符号可以表示通信信道的标识符，操作可以在该信道上发送或接收消息。

##### 3. 符号的类型

每个符号都关联有一个类型，这个类型影响了与该符号关联的操作的类型。

**重要概念**：

- **符号的类型**并不意味着符号本身是该类型的值。
- 符号的类型**限制**了对该符号进行操作的方式。

**举例**：

- 如果符号 `a` 的类型是 `int`，表示与 `a` 关联的操作只能处理整数类型的值。

##### 4. 符号的声明与作用域

###### 4.1 符号声明的语法

符号的声明用于在程序中引入新的符号，语法如下：

$$
\text{Exp}\ e ::= \text{new}[\tau](a.e) \quad \text{或} \quad \nu a:\tau\ \text{in}\ e
$$

- **$\text{new}[\tau](a.e)$**：在表达式 `e` 中引入一个新的符号 `a`，其类型为 `τ`。
- **$\nu a:\tau\ \text{in}\ e$**：另一种表示方式，效果相同。

###### 4.2 符号上下文（Signature）

在符号的静态语义中，引入了**符号上下文** `Σ`，用于记录符号与其类型的关联：

$$
\Sigma = \{a_1 \sim \tau_1, a_2 \sim \tau_2, \dotsc, a_n \sim \tau_n\}
$$

- 其中，每个 `a_i` 是一个符号，`τ_i` 是其关联的类型。

###### 4.3 类型判断

符号的类型判断表达式形式为：

$$
\Gamma \vdash_\Sigma e : \tau
$$

- **$\Gamma$**：变量上下文，记录变量的类型信息。
- **$e$**：表达式。
- **$\tau$**：表达式 `e` 的类型。

###### 4.4 符号声明的类型规则

符号声明的类型规则如下：

$$
\frac{
  \Gamma \vdash_{\Sigma, a \sim \rho} e : \tau \quad \tau\ \text{mobile}
}{
  \Gamma \vdash_\Sigma\ \text{new}[\rho](a.e) : \tau
} \tag{32.1}
$$

- **解释**：
  - 上方条件：
    - 在扩展了符号上下文的情况下（添加了 `a ∼ ρ`），表达式 `e` 的类型是 `τ`。
    - 类型 `τ` 必须是**可移动的**（`mobile`）。
  - 下方结论：
    - 在原始符号上下文 `Σ` 下，符号声明表达式的类型是 `τ`。

###### 4.5 可移动性（Mobility）

**可移动性**是一个关键概念，用于限制符号的作用域和范围。

- **可移动类型**：其值不依赖于任何符号。
- **不可移动类型**：其值可能依赖于符号。

**可移动性的作用**：

- **有作用域的动力学**（Scoped Dynamics）：
  - 限制符号的范围在其声明的作用域内。
  - 要求返回的类型 `τ` 是可移动的，以防止符号“逃逸”出其作用域。
- **自由的动力学**（Free Dynamics）：
  - 符号的范围可以超出其声明的作用域，延伸到整个程序。
  - 所有类型都被视为可移动的。

##### 5. 符号的作用域（Scope）与范围（Extent）

- **作用域**：符号在程序中可见的区域，由**静态语义**决定。
- **范围**：符号在程序中有效的区域，由**动力学**（Dynamics）决定。

**两种动力学**：

1. **有作用域的动力学**（Scoped Dynamics）：
   - 符号的范围限制在其作用域内。
   - 符号的生命周期仅限于其声明的作用域内的计算过程。

2. **自由的动力学**（Free Dynamics）：
   - 符号的范围可以超出其作用域，延伸到整个程序执行过程中。
   - 符号的作用域被扩展，以包含符号可能影响的所有计算。

**举例**：

- 在有作用域的动力学中，符号 `a` 在表达式 `new[τ](a.e)` 内部是可见和有效的，离开 `e` 后，`a` 不再有效。
- 在自由的动力学中，符号 `a` 可以从 `e` 中“逃逸”，在程序的其他部分继续存在。

##### 6. 符号引用（Symbolic Reference）

除了符号声明，另一个重要的概念是**符号引用**。

###### 6.1 符号引用的定义

- **符号引用**用于在程序中引用特定的符号。
- 符号引用的表达式形式为 `&a`，其中 `a` 是一个符号。
- 符号引用的类型为 `τ\ \text{sym}`，表示引用了类型为 `τ` 的符号。

###### 6.2 符号引用的操作

- **消去形式**：用于对符号引用进行模式匹配或条件判断。
- 例如，可以检查一个符号引用是否引用了特定的符号，并根据结果执行不同的操作。

###### 6.3 类型安全性

- 在处理符号引用的消去形式时，必须小心设计静态语义，以确保类型安全性。
- **关键点**：
  - 当判断符号引用引用了特定的符号时，可以获得该符号的类型信息。
  - 当无法确定引用的符号时，不能假设任何类型信息。

##### 7. 符号在编程中的应用

###### 7.1 可变存储（Mutable Storage）

- 符号可以用于标识存储单元，例如内存地址。
- 通过符号引用，可以对存储单元进行读取或写入操作。

**示例**：

```pseudo
new[int](a.
  let cell = &a in
  write(cell, 42);
  let value = read(cell) in
  ...
)
```

- 在上面的示例中，`a` 是一个新声明的符号，类型为 `int`。
- `cell` 是对符号 `a` 的引用，用于表示一个存储单元。
- `write` 和 `read` 是与符号关联的操作，用于写入和读取存储单元的值。

###### 7.2 通信信道（Communication Channels）

- 符号可以表示通信信道的标识符。
- 通过符号引用，可以在信道上发送或接收消息。

**示例**：

```pseudo
new[message](channel.
  let ch = &channel in
  send(ch, "Hello");
  let msg = receive(ch) in
  ...
)
```

- `channel` 是一个新声明的符号，类型为 `message`。
- `ch` 是对符号 `channel` 的引用，用于表示通信信道。
- `send` 和 `receive` 是与符号关联的操作，用于在信道上发送和接收消息。

###### 7.3 动态绑定（Dynamic Binding）

- 符号可以用于实现动态绑定机制，允许在运行时决定变量的绑定关系。

**示例**：

```pseudo
new[τ](a.
  bind(a, value);
  let v = lookup(a) in
  ...
)
```

- `bind` 和 `lookup` 是与符号关联的操作，用于动态绑定和查找值。

---

### 总结

- **符号**是编程语言中的一个强大概念，允许我们以灵活和抽象的方式处理标识、存储和通信等。
- **符号声明**引入了新的符号，并通过类型系统和作用域规则确保了符号的正确使用。
- **可移动性**概念和不同的**动力学**模型决定了符号的范围和生命周期，影响了程序的行为和安全性。
- **符号引用**提供了一种安全的方式来引用和操作符号，支持各种高级编程模式。

通过深入理解符号的概念和机制，我们可以设计更灵活、更安全和更强大的编程语言和系统，实现复杂的抽象和功能。

### ---------------------------------

### 32.1.1 有作用域的动力学（Scoped Dynamics）

---

在本节中，我们讨论**符号声明**（Symbol Declaration）的**有作用域的动力学**（Scoped Dynamics）。有作用域的动力学限制了符号的范围，使其仅在声明的作用域内有效。一旦离开了这个作用域，符号就被“遗忘”了。

#### 1. 转换判断的形式

有作用域的动力学使用了一种特殊的**转换判断**（Transition Judgment），形式为：

$$
e \xrightarrow{\Sigma} e'
$$

- **$e$** 和 **$e'$**：表达式，可能涉及符号。
- **$\Sigma$**：签名（Signature），即符号上下文，指定了转换中活动的符号。

**重要**：

- **$e$** 或 **$e'$** 可能涉及到 $\Sigma$ 中声明的符号，但不能涉及其他符号。

#### 2. 动力学规则

有两个主要的动力学规则：

##### 规则 (32.2a)：符号声明内部的求值

$$
\frac{e \xrightarrow{\Sigma, a \sim \rho} e'}{\text{new}[\rho](a.e) \xrightarrow{\Sigma} \text{new}[\rho](a.e')}
\tag{32.2a}
$$

**解释**：

- **上方条件**：在扩展了符号上下文 $\Sigma$（添加了 $a \sim \rho$）的情况下，$e$ 可以转换为 $e'$。
- **下方结论**：在原始符号上下文 $\Sigma$ 下，$\text{new}[\rho](a.e)$ 转换为 $\text{new}[\rho](a.e')$。

**含义**：

- 在符号声明的作用域内，表达式 $e$ 的求值发生在扩展了符号上下文的环境中。
- 符号 $a$ 仅在 $e$ 的求值过程中是可见的。

##### 规则 (32.2b)：符号的遗忘

$$
\frac{e\ \text{val}_{\Sigma}}{\text{new}[\rho](a.e) \xrightarrow{\Sigma} e}
\tag{32.2b}
$$

**解释**：

- **上方条件**：表达式 $e$ 在符号上下文 $\Sigma$ 下是一个值（已求值到值）。
- **下方结论**：$\text{new}[\rho](a.e)$ 在符号上下文 $\Sigma$ 下转换为 $e$。

**含义**：

- 一旦符号声明的作用域内的表达式 $e$ 被求值到值，符号 $a$ 就被“遗忘”了。
- 结果表达式 $e$ 不再涉及符号 $a$，因为它的作用域已经结束。

#### 3. 可移动性的条件

为了确保符号在离开作用域后不会影响外部，需要对类型的**可移动性**（Mobility）进行限制。

**可移动性条件**：

如果 $\tau$ 是可移动的（$\tau\ \text{mobile}$），并且：

- $\vdash_{\Sigma, a \sim \rho} e : \tau$（在扩展了符号上下文的情况下，$e$ 的类型是 $\tau$），
- $e$ 在 $\Sigma, a \sim \rho$ 下已经求值到值（$e\ \text{val}_{\Sigma, a \sim \rho}$），

那么：

- $\vdash_{\Sigma} e : \tau$（在原始符号上下文下，$e$ 的类型仍是 $\tau$），
- $e$ 在 $\Sigma$ 下也是一个值（$e\ \text{val}_{\Sigma}$）。

**解释**：

- 这个条件确保了当表达式 $e$ 不再涉及符号 $a$ 时，它的类型和值在不含符号 $a$ 的上下文中仍然有效。

#### 4. 可移动性的影响

**举例**：

- **符号引用（Symbolic References）**（将在 32.2 节中讨论）：

  - 如果引入了符号引用，函数类型不能被视为可移动的。
  - 因为函数可能包含对局部符号的引用，如果符号被遗忘，函数的行为就可能不再定义。

- **自然数类型（nat）**：

  - 只有在**严格求值**（Eager Evaluation）后继函数时，才可以被视为可移动的。
  - 否则，符号引用可能出现在该类型的值中，违反可移动性条件。

#### 5. 定理和证明

##### 定理 32.1（保持性，Preservation）

**陈述**：

如果 $\vdash_{\Sigma} e : \tau$ 且 $e \xrightarrow{\Sigma} e'$，那么 $\vdash_{\Sigma} e' : \tau$。

**解释**：

- 在符号上下文 $\Sigma$ 下，表达式 $e$ 的类型为 $\tau$。
- 如果 $e$ 在 $\Sigma$ 下转换为 $e'$，那么 $e'$ 的类型仍然是 $\tau$。

**证明思路**：

- 对符号声明的动力学进行归纳（Induction）。
- 规则 (32.2a)：

  - 直接应用归纳假设和类型规则 (32.1)。

- 规则 (32.2b)：

  - 由可移动性条件直接得出。

##### 定理 32.2（前进性，Progress）

**陈述**：

如果 $\vdash_{\Sigma} e : \tau$，那么要么存在 $e'$ 使得 $e \xrightarrow{\Sigma} e'$，要么 $e$ 已经是一个值（$e\ \text{val}_{\Sigma}$）。

**解释**：

- 在符号上下文 $\Sigma$ 下，表达式 $e$ 要么可以进一步求值，要么已经是一个值。

**证明思路**：

- 只有一个规则需要考虑，即符号声明的类型规则 (32.1)。
- 通过归纳，得到以下两种情况：

  - 如果存在 $e'$ 使得 $e \xrightarrow{\Sigma, a \sim \rho} e'$，则应用规则 (32.2a)。
  - 如果 $e\ \text{val}_{\Sigma, a \sim \rho}$，则根据可移动性条件，$e\ \text{val}_{\Sigma}$，然后应用规则 (32.2b)。

---

### 32.1.2 无作用域的动力学（Scope-Free Dynamics）

---

在无作用域的动力学中，符号的范围不再被限制在其声明的作用域内，而是延伸到整个计算过程中。

#### 1. 转换系统的形式

无作用域的动力学使用了新的**转换系统**，状态形式为：

$$
\nu\ \Sigma\ \{ e \}
$$

- **$\nu$**：表示符号的引入或存在。
- **$\Sigma$**：签名，记录了当前活动的符号及其类型。
- **$e$**：表达式，可能涉及符号 $\Sigma$ 中的符号。

**转换判断**：

$$
\nu\ \Sigma\ \{ e \} \longrightarrow \nu\ \Sigma'\ \{ e' \}
$$

- 该判断表示：在符号上下文 $\Sigma$ 下求值表达式 $e$，结果是新的表达式 $e'$，符号上下文扩展为 $\Sigma'$。

#### 2. 动力学规则

##### 规则 (32.3)：符号生成

$$
\nu\ \Sigma\ \{ \text{new}[\rho](a.e) \} \longrightarrow \nu\ \Sigma, a \sim \rho\ \{ e \}
\tag{32.3}
$$

**解释**：

- 在符号上下文 $\Sigma$ 下，遇到符号声明 $\text{new}[\rho](a.e)$，通过将新符号 $a \sim \rho$ 添加到 $\Sigma$ 中，继续求值表达式 $e$。

**含义**：

- 符号生成通过扩展签名 $\Sigma$ 来丰富符号上下文。
- 新的符号 $a$ 对于后续的所有转换都是可见的。

#### 3. 其他规则的调整

由于符号可以超出其原始作用域，其他的动力学规则也需要相应调整，以处理可能出现的符号。

**示例**：函数应用的动力学

##### 调整后的规则 (32.4a)：求值函数应用的函数部分

$$
\frac{
  \nu\ \Sigma\ \{ e_1 \} \longrightarrow \nu\ \Sigma'\ \{ e_1' \}
}{
  \nu\ \Sigma\ \{ e_1(e_2) \} \longrightarrow \nu\ \Sigma'\ \{ e_1'(e_2) \}
}
\tag{32.4a}
$$

**解释**：

- 首先在符号上下文 $\Sigma$ 下求值 $e_1$，得到 $e_1'$，符号上下文扩展为 $\Sigma'$。
- 然后在扩展后的符号上下文下，求值函数应用 $e_1'(e_2)$。

##### 调整后的规则 (32.4b)：函数应用的执行

$$
\nu\ \Sigma\ \{ \lambda (x:\tau) e (e_2) \} \longrightarrow \nu\ \Sigma\ \{ [e_2 / x] e \}
\tag{32.4b}
$$

**解释**：

- 对于一个函数 $\lambda (x:\tau) e$ 应用于参数 $e_2$，通过替换，将 $e_2$ 替换到函数体 $e$ 中，继续求值。

**注意**：

- 在所有规则中，符号上下文 $\Sigma$ 被适当地传递或扩展，以反映符号的存在和范围。

#### 4. 定理和证明

##### 定理 32.3（保持性，Preservation）

**陈述**：

如果 $\nu\ \Sigma\ \{ e \} \longrightarrow \nu\ \Sigma'\ \{ e' \}$ 且 $\vdash_{\Sigma} e : \tau$，那么 $\Sigma' \supseteq \Sigma$ 且 $\vdash_{\Sigma'} e' : \tau$。

**解释**：

- 表达式 $e$ 在符号上下文 $\Sigma$ 下类型为 $\tau$。
- 如果 $e$ 在符号上下文扩展到 $\Sigma'$ 后转换为 $e'$，那么 $e'$ 在新的符号上下文 $\Sigma'$ 下的类型仍然是 $\tau$。

**证明思路**：

- 主要考虑规则 (32.3)。
- 通过对类型规则 (32.1) 的逆向推理，可以得出结论。

##### 定理 32.4（前进性，Progress）

**陈述**：

如果 $\vdash_{\Sigma} e : \tau$，那么要么 $e$ 在 $\Sigma$ 下是一个值（$e\ \text{val}_{\Sigma}$），要么存在 $\Sigma'$ 和 $e'$，使得 $\nu\ \Sigma\ \{ e \} \longrightarrow \nu\ \Sigma'\ \{ e' \}$。

**解释**：

- 在符号上下文 $\Sigma$ 下，表达式 $e$ 要么已经是一个值，要么可以进一步求值。

**证明思路**：

- 直接应用规则 (32.3)。

---

### 总结

通过对有作用域和无作用域的动力学的讨论，我们可以看到符号在不同的动力学模型下如何影响程序的行为：

- **有作用域的动力学**严格限制了符号的范围，符号在离开其声明的作用域后就被遗忘。这需要对类型的可移动性进行限制，以确保类型安全性。

- **无作用域的动力学**允许符号的范围超出其原始作用域，延伸到整个程序。这需要调整程序的动力学规则，以正确处理符号的传播。

这些讨论对于理解符号在编程语言中的作用，以及如何设计安全和高效的符号机制具有重要意义。

### ---------------------------------

### 32.2 符号引用（Symbolic References）

---

在前面的讨论中，我们了解了**符号**（Symbols）的声明和作用域。本节将介绍如何在程序中**引用符号**，即**符号引用**（Symbolic References），以及与之相关的类型规则、动力学和安全性。

#### 1. 引入符号引用的动机

尽管符号本身不是值（Values），但我们可以利用符号来构造值。例如：

- **符号引用**：一种特殊的值类型，用于引用特定的符号。

符号引用的引入使我们能够在程序中动态地检查和操作符号，从而实现更复杂的编程模式，如动态绑定、模式匹配等。

---

#### 2. 符号引用的语法

符号引用的语法定义如下：

- **类型语法**：

  $$
  \begin{align*}
  \text{Typ}\ \tau ::= \dotsb\ |\ \text{sym}(\tau) \quad \text{符号类型}
  \end{align*}
  $$

  - **$\text{sym}(\tau)$**：表示引用类型，其值是类型为 $\tau$ 的符号的引用。

- **表达式语法**：

  $$
  \begin{align*}
  \text{Exp}\ e ::= \dotsb\ |\ \text{sym}[a] \quad \text{引用符号}\ a \\
  \quad\quad\quad\quad\quad |\ \text{is}[a][t.\tau](e; e_1; e_2) \quad \text{符号比较}
  \end{align*}
  $$

  - **$\text{sym}[a]$**：构造一个符号引用，引用符号 $a$，其类型为 $\text{sym}(\tau)$，其中 $\tau$ 是 $a$ 的类型。
  - **$\text{is}[a][t.\tau](e; e_1; e_2)$**：对表达式 $e$ 进行符号比较。
    - 如果 $e$ 引用的符号是 $a$，则计算结果为 $e_1$。
    - 否则，计算结果为 $e_2$。

---

#### 3. 符号引用的静态语义（Statics）

符号引用的类型规则如下：

##### 规则 (32.5a)：符号引用的引入（Introduction）

$$
\frac{}{\Gamma \vdash_{\Sigma, a \sim \rho}\ \text{sym}[a] : \text{sym}(\rho)}
\tag{32.5a}
$$

- **解释**：
  - 在符号上下文 $\Sigma$ 中，如果符号 $a$ 的类型是 $\rho$，那么 $\text{sym}[a]$ 的类型就是 $\text{sym}(\rho)$。

##### 规则 (32.5b)：符号引用的消除（Elimination）

$$
\frac{
\Gamma \vdash_{\Sigma, a \sim \rho}\ e : \text{sym}(\rho') \quad
\Gamma \vdash_{\Sigma, a \sim \rho}\ e_1 : [\rho / t]\tau \quad
\Gamma \vdash_{\Sigma, a \sim \rho}\ e_2 : [\rho' / t]\tau
}{
\Gamma \vdash_{\Sigma, a \sim \rho}\ \text{is}[a][t.\tau](e; e_1; e_2) : [\rho' / t]\tau
}
\tag{32.5b}
$$

- **解释**：
  - **$e$**：一个符号引用，类型为 $\text{sym}(\rho')$，引用了某个符号 $b$，其类型为 $\rho'$。
  - **$e_1$**：在 $e$ 引用的符号与 $a$ 相同时的计算分支，其类型为 $[\rho / t]\tau$。
  - **$e_2$**：在 $e$ 引用的符号与 $a$ 不同时的计算分支，其类型为 $[\rho' / t]\tau$。
  - **$\tau$**：一个类型表达式，可能依赖于类型变量 $t$。

- **注意**：
  - **类型变量替换**：
    - **$[\rho / t]\tau$**：将类型表达式 $\tau$ 中的类型变量 $t$ 替换为 $\rho$。
    - **$[\rho' / t]\tau$**：将类型变量 $t$ 替换为 $\rho'$。
  - **目的**：
    - 在比较成功的情况下，我们知道 $e$ 引用的符号类型与 $a$ 的类型 $\rho$ 相同，因此可以使用 $[\rho / t]\tau$。
    - 在比较失败的情况下，我们只能知道 $e$ 引用的符号类型为 $\rho'$，因此使用 $[\rho' / t]\tau$。

---

#### 4. 规则 (32.5b) 的详细解读

##### 4.1 类型不一致的处理

- **问题**：
  - 符号 $a$ 的类型 $\rho$ 与 $e$ 引用的符号类型 $\rho'$ 可能不同。
- **解决方案**：
  - 使用**类型操作符** $t.\tau$，引入类型变量 $t$，在不同的分支中替换 $t$ 为相应的类型。
- **效果**：
  - 确保无论比较的结果如何，整个表达式的类型都是一致的，即 $[\rho' / t]\tau$。

##### 4.2 类型安全性

- **在比较成功的情况下**：
  - $e$ 引用的符号就是 $a$，因此 $\rho' = \rho$。
  - $e_1$ 的类型为 $[\rho / t]\tau = [\rho' / t]\tau$。
- **在比较失败的情况下**：
  - $e$ 引用的符号不是 $a$，其类型为 $\rho'$，可能不同于 $\rho$。
  - $e_2$ 的类型为 $[\rho' / t]\tau$。
- **确保类型一致性**：
  - 整个表达式的类型为 $[\rho' / t]\tau$，保证类型系统的一致性和安全性。

---

#### 5. 符号引用的动力学（Dynamics）

##### 规则 (32.6a)：符号引用是值

$$
\frac{}{\text{sym}[a]\ \text{val}_{\Sigma, a \sim \rho}}
\tag{32.6a}
$$

- **解释**：
  - 符号引用 $\text{sym}[a]$ 在符号上下文 $\Sigma, a \sim \rho$ 下是一个值。

##### 规则 (32.6b)：比较成功的情况下

$$
\frac{}{\text{is}[a][t.\tau](\text{sym}[a]; e_1; e_2) \xrightarrow{\Sigma, a \sim \rho} e_1}
\tag{32.6b}
$$

- **解释**：
  - 当 $e$ 的值是 $\text{sym}[a]$，即引用的符号就是 $a$，计算结果为 $e_1$。

##### 规则 (32.6c)：比较失败的情况下

$$
\frac{a \ne b}{\text{is}[a][t.\tau](\text{sym}[b]; e_1; e_2) \xrightarrow{\Sigma, a \sim \rho, b \sim \rho'} e_2}
\tag{32.6c}
$$

- **解释**：
  - 当 $e$ 的值是 $\text{sym}[b]$，且 $b \ne a$，计算结果为 $e_2$。

##### 规则 (32.6d)：对 $e$ 的求值

$$
\frac{e \xrightarrow{\Sigma, a \sim \rho} e'}{\text{is}[a][t.\tau](e; e_1; e_2) \xrightarrow{\Sigma, a \sim \rho} \text{is}[a][t.\tau](e'; e_1; e_2)}
\tag{32.6d}
$$

- **解释**：
  - 当 $e$ 可以进一步求值时，推进 $e$ 的求值过程。

---

#### 6. 类型安全性（Safety）

##### 6.1 确保可移动性条件

- **关键点**：
  - 为了满足可移动性条件，**符号引用类型**不能被视为可移动的。
  - 因为符号引用可能包含对局部符号的引用，如果符号被遗忘，引用将变得无效。

##### 6.2 定理 32.5（保持性，Preservation）

**陈述**：

如果 $\vdash_{\Sigma} e : \tau$ 且 $e \xrightarrow{\Sigma} e'$，那么 $\vdash_{\Sigma} e' : \tau$。

**证明思路**：

- 对动力学规则 (32.6) 进行规则归纳。
- **重点在规则 (32.6b)**：
  - 当比较成功时，符号 $a$ 和 $b$ 是相同的，因此类型 $\rho$ 和 $\rho'$ 也相同。
  - 因此，$e_1$ 的类型 $[\rho / t]\tau$ 与整个表达式的类型 $[\rho / t]\tau$ 一致。

##### 6.3 引理 32.6（规范形式，Canonical Forms）

**陈述**：

如果 $\vdash_{\Sigma} e : \text{sym}(\rho)$ 且 $e\ \text{val}_{\Sigma}$，那么 $e = \text{sym}[a]$，其中 $a \sim \rho$。

**解释**：

- 这表明类型为 $\text{sym}(\rho)$ 且已求值的表达式必须是形式 $\text{sym}[a]$。

##### 6.4 定理 32.7（前进性，Progress）

**陈述**：

如果 $\vdash_{\Sigma} e : \tau$，那么要么 $e$ 是值（$e\ \text{val}_{\Sigma}$），要么存在 $e'$ 使得 $e \xrightarrow{\Sigma} e'$。

**证明思路**：

- 对类型规则 (32.5) 进行规则归纳。
- **对于规则 (32.5b)**：
  - 如果 $e$ 不是值，则根据归纳假设，$e$ 可以进一步求值，应用规则 (32.6d)。
  - 如果 $e$ 是值，根据引理 32.6，$e$ 是形式 $\text{sym}[b]$，其中 $b \sim \rho'$。
  - 因为符号的相等性是可判定的（要么 $a = b$，要么 $a \ne b$），因此根据规则 (32.6b) 和 (32.6c) 保证了前进性。

---

#### 7. 示例和应用

##### 7.1 示例：符号比较

假设有以下符号：

- $\Sigma = \{ a \sim \rho, b \sim \rho' \}$

我们有表达式：

$$
\text{is}[a][t.\tau](\text{sym}[b]; e_1; e_2)
$$

- **情况 1**：如果 $a = b$，即 $a$ 和 $b$ 是相同的符号。

  - **求值**：根据规则 (32.6b)，结果为 $e_1$。
  - **类型**：$e_1$ 的类型为 $[\rho / t]\tau$。

- **情况 2**：如果 $a \ne b$。

  - **求值**：根据规则 (32.6c)，结果为 $e_2$。
  - **类型**：$e_2$ 的类型为 $[\rho' / t]\tau$。

##### 7.2 应用：动态类型检查

- **场景**：在运行时，需要根据符号的类型执行不同的操作。
- **实现**：
  - 使用 $\text{is}[a][t.\tau](e; e_1; e_2)$，根据符号引用的符号是否为 $a$，选择执行 $e_1$ 或 $e_2$。
  - 在 $e_1$ 中，可以利用已知的类型信息（因为符号类型已知），进行类型安全的操作。

---

### 总结

- **符号引用**扩展了符号的应用，使我们能够在程序中引用和比较符号。
- **类型规则**确保了在符号比较过程中类型的正确性和一致性。
- **动力学规则**定义了符号引用的求值行为，特别是符号比较的逻辑。
- **类型安全性**通过保持性和前进性定理得到保证，确保程序的正确执行。

通过理解符号引用的机制，我们可以在编程语言中实现更强大的动态特性，如动态绑定、类型反射和模式匹配，从而编写更灵活和安全的程序。


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------
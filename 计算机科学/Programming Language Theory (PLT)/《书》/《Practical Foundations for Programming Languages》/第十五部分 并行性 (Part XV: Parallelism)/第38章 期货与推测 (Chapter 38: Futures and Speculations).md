[toc]



### 第40章：Futures 和 Speculations

**Futures** 和 **Speculations** 是并行计算中的两种机制，旨在通过提前计算或推测性计算来提高程序的执行效率，尽可能减少延迟，并充分利用处理器资源。

### Futures (未来值)

**Futures** 是一种提前启动计算的机制，即便尚未对结果提出需求。Futures 的核心思想是在不依赖于当前计算的情况下，启动并行计算，以期在未来某个时间点需要结果时，计算已经完成。

#### **Futures 的特点：**

1. **像 Suspensions（延迟计算）一样，Futures 也代表一个将来会确定的值**。但是，和 suspensions 不同，Futures 不管其值是否真正需要，都会立即启动计算。
   
2. **Futures 的重要性在于并行场景**。在顺序执行中，Futures 不会带来太多优势，因为它仅仅相当于一个普通表达式。在并行环境下，Futures 可以让某些计算提前开始，为未来的结果需求做好准备。

#### **Futures 的典型应用：**

Futures 最常见的应用场景是实现**流水线 (Pipelining)**。流水线的目的是最大化重叠多阶段计算的各个阶段，减少因为等待前一阶段结果而带来的延迟。

- **流水线并行**：一个典型的流水线任务是分为多个阶段的计算。在阶段1的计算结果还没完成时，阶段2可以先行计算自己的部分（如果它不依赖阶段1的最终结果）。一旦阶段1完成，阶段2可以迅速完成剩下的部分。
  
- **流水线停顿 (Pipeline Stall)**：最理想的情况是早期阶段的计算在稍后阶段需要它的结果时已经完成。但如果早期阶段没有按时完成，后续阶段不得不等待，这就是所谓的“流水线停顿”。

### Speculations (推测性计算)

**Speculations** 则是延迟计算，它的结果可能在某些情况下用不到。和 Futures 类似，Speculations 会提前启动一些计算，但不同的是，推测性计算可能最终完全不需要。

#### **Speculations 的特点：**

1. **并行执行**：Speculations 会和主线程同时进行，通常不考虑主线程是否需要它的结果。

2. **推测计算的代价**：如果主线程最终确实需要推测性计算的结果，那么提前计算将节省时间并提升性能。然而，如果主线程不需要推测计算的结果，那么计算的努力就浪费了。这意味着推测性计算具有一定风险，可能导致无用功。

3. **效率问题**：Speculations 被认为是工作效率低的机制，因为可能会执行一些不必要的工作，最终整体工作量可能超过顺序执行所需的工作量。

### **Futures 与 Speculations 的区别：**

1. **工作效率 (Work Efficiency)**：
   - **Futures 是工作效率高的**，因为 Futures 提前启动计算，但整体的工作量不会超过顺序执行的总工作量。也就是说，Futures 提供了并行性，而不会增加计算负担。
   - **Speculations 是工作效率低的**，因为 Speculations 可能执行不必要的计算，导致工作量超过顺序执行的工作量。Speculations 是一种冒险的并行策略，如果推测计算不被需要，整个计算的效率将受到影响。

2. **应用场景**：
   - **Futures** 适用于那些确定未来会需要的计算，它们旨在提高并行效率，不影响整体工作量。
   - **Speculations** 更适合用于存在不确定性的计算任务，尽管它可能会提高性能，但也有可能造成不必要的开销。

### **总结**：

- **Futures** 提供了一种优化并行计算的机制，通过提前启动未来可能需要的计算，减少等待时间。
- **Speculations** 则是一种冒险的策略，可能会因为提前计算不需要的结果而增加工作量，但在某些场景下也可能大大提高计算的效率。

两者的核心差异在于工作效率和计算的需求性。Futures 是一种较为安全的并行策略，而 Speculations 则需要权衡性能提升和工作负载之间的关系。

### ---------------------------------

### 40.1 Futures

在本节中，我们介绍了 **Futures** 的语法、静态规则和顺序动态规则。Futures 是一种并行计算模型，允许我们提前启动某些计算，以期在未来需要结果时已经完成。以下是 Futures 的定义和相关的语法规则。

#### **Futures 的语法**：

Futures 的语法通过以下文法定义：

1. **类型文法 (Typ τ)**：
   - **$τ\ fut$**：表示类型 $τ$ 的 Futures 类型。Futures 类型 $τ\ fut$ 是指一个值类型为 $τ$ 的 future。

2. **表达式文法 (Exp e)**：
   - **$fut(e)$**：引入一个 future。它将表达式 $e$ 调度为一个 future 任务，并返回对该任务的引用。换句话说，$fut(e)$ 表示将 $e$ 的计算作为 future 启动，程序可以在将来某个时间同步这个计算的结果。
   - **$fsyn(e)$**：消除一个 future，表示对 future 的同步操作。它会等待表达式 $e$ 所表示的 future 计算完成，并返回该计算的结果。

#### **Futures 的工作机制**：

1. **类型**：
   - 类型 $τ\ fut$ 是表示类型为 $τ$ 的 future，类似于一种占位符，表示将在将来的某个时间点计算出的值。

2. **表达式 $fut(e)$**：
   - $fut(e)$ 启动并行计算，将表达式 $e$ 的计算调度为一个 future，允许计算在后台并行执行。程序不需要立刻获取 $e$ 的值，$fut(e)$ 返回的是一个对 $e$ 的引用，可以稍后通过同步操作获取 $e$ 的计算结果。

3. **表达式 $fsyn(e)$**：
   - $fsyn(e)$ 用于同步 future，确保当程序需要 $e$ 的计算结果时，该计算已经完成。这个操作会阻塞程序的执行，直到 future 计算完成，然后返回 future 任务的最终值。

### 40.1.1 静态规则 (Statics)

在静态类型检查中，我们需要验证 Futures 类型是否符合其定义。Futures 的静态类型规则如下：

1. **Futures 引入的类型检查**：
   - 当我们写 $fut(e)$ 时，表达式 $e$ 应该有一个类型 $τ$，并且 $fut(e)$ 的类型应该是 $τ\ fut$。也就是说，如果表达式 $e$ 的类型是 $τ$，那么 $fut(e)$ 的类型是 $τ\ fut$，表示这个 future 的结果将是类型 $τ$ 的值。
   
   静态类型规则可以表示为：
   $$
   \frac{\Gamma \vdash e : τ}{\Gamma \vdash fut(e) : τ\ fut}
   $$

   其中 $\Gamma$ 是类型环境，$e$ 是表达式，$τ$ 是表达式 $e$ 的类型。

2. **Futures 同步的类型检查**：
   - 当我们写 $fsyn(e)$ 时，表达式 $e$ 应该有一个类型 $τ\ fut$，表示它是一个 future。同步操作 $fsyn(e)$ 返回的是 future 的实际值，即类型为 $τ$ 的结果。
   
   静态类型规则可以表示为：
   $$
   \frac{\Gamma \vdash e : τ\ fut}{\Gamma \vdash fsyn(e) : τ}
   $$

   这个规则确保了当我们同步一个 future 时，我们获得的是它的计算结果的类型。

### 40.1.2 顺序动态规则 (Sequential Dynamics)

在顺序动态规则中，我们描述了如何在顺序执行中处理 Futures。尽管 Futures 是为了并行计算而设计的，但在顺序计算环境中，它们的行为仍然需要明确。

#### **顺序动态的关键步骤**：

1. **Futures 引入**：
   - 当遇到 $fut(e)$ 时，表达式 $e$ 被调度为一个 future 任务。顺序执行中，$fut(e)$ 会立即返回对这个任务的引用，允许程序继续执行而不等待 $e$ 的计算完成。
   
   动态规则表示为：
   $$
   fut(e) \rightarrow \text{future reference of } e
   $$

2. **Futures 同步**：
   - 当遇到 $fsyn(e)$ 时，程序会等待 $e$ 的计算完成，并返回 $e$ 的值。顺序执行中，程序会阻塞直到计算 $e$ 完成，这与并行环境中的同步操作类似。
   
   动态规则表示为：
   $$
   fsyn(fut(e)) \rightarrow e
   $$

   这意味着，在顺序执行中，$fsyn$ 确保获得的是 $fut(e)$ 计算的结果。

### **总结**：

- **Futures 的引入**：通过 $fut(e)$ 提前启动计算，但不立刻需要其结果。程序可以在需要结果时，通过 $fsyn(e)$ 来同步获取结果。
- **静态规则**：验证 $fut(e)$ 是否生成一个 future 类型 $τ\ fut$，以及 $fsyn(e)$ 是否正确同步该类型。
- **顺序动态规则**：描述了如何在顺序执行中调度和同步 Futures。

Futures 的这种机制在并行计算中尤为有用，因为它允许我们提前启动并行计算，并在需要时同步其结果。

### ---------------------------------

### 40.1.1 静态规则 (Statics)

静态规则定义了如何类型检查 Futures。Futures 的类型规则相对简单，主要是引入了新的类型构造和同步操作。

#### **公式解释**：

1. **引入 Future 的规则 (40.1a)**：
   - 当表达式 $e$ 的类型为 $τ$ 时，$fut(e)$ 的类型为 $fut(τ)$，表示 $e$ 被包装成了一个 Future 并且将在未来某个时间点被计算。这个规则的形式化表示为：
     $$
     \frac{\Gamma \vdash e : τ}{\Gamma \vdash fut(e) : fut(τ)}
     $$
   - 其中 $\Gamma$ 是类型环境，表示变量的类型上下文；$e$ 是表达式，$τ$ 是其类型。

2. **同步 Future 的规则 (40.1b)**：
   - 如果 $e$ 是类型 $fut(τ)$ 的一个 future，则 $fsyn(e)$ 的类型是 $τ$，即通过同步操作 $fsyn$，返回的是 future 任务的实际计算结果。
     $$
     \frac{\Gamma \vdash e : fut(τ)}{\Gamma \vdash fsyn(e) : τ}
     $$

#### **总结**：
- **$fut(e)$** 引入了并行计算的机制，但在静态类型上，它只是将表达式类型包裹为 Future 类型，没有引入额外的复杂性。
- **$fsyn(e)$** 通过同步 Future，获取其实际的值，类型也从 $fut(τ)$ 转换为 $τ$，与 Future 的底层类型保持一致。

### 40.1.2 顺序动态规则 (Sequential Dynamics)

顺序动态规则描述了 Futures 在顺序执行中的行为，主要包括 Future 的引入和同步的计算过程。在顺序环境中，Futures 立即评估，并且在同步时返回 Future 的值。

#### **公式解释**：

1. **Future 的引入 (40.2a)**：
   - 当表达式 $e$ 已经求值完成，即 $e$ 为一个值 ($e\ val$)，那么 $fut(e)$ 也是一个值。这是因为 $fut(e)$ 表示调度了一个 Future 任务，但在顺序执行中，它立即完成。公式如下：
     $$
     e\ val \quad fut(e)\ val
     $$
   
2. **Future 的逐步求值 (40.2b)**：
   - 如果表达式 $e$ 还没有完全求值，那么 $fut(e)$ 会随着 $e$ 的求值而逐步更新。如果 $e$ 逐步求值为 $e'$，那么 $fut(e)$ 也会更新为 $fut(e')$：
     $$
     e \rightarrow e' \quad fut(e) \rightarrow fut(e')
     $$

3. **同步的逐步求值 (40.2c)**：
   - 同理，对于同步操作 $fsyn(e)$，如果 $e$ 还没有完全求值为一个 future，那么 $fsyn(e)$ 随着 $e$ 的求值更新为 $fsyn(e')$：
     $$
     e \rightarrow e' \quad fsyn(e) \rightarrow fsyn(e')
     $$

4. **同步已完成的 Future (40.2d)**：
   - 如果 $e$ 已经是一个值，并且 $fut(e)$ 已经完成，那么执行 $fsyn(fut(e))$ 会立即返回 $e$ 的值：
     $$
     e\ val \quad fsyn(fut(e)) \rightarrow e
     $$
   - 这表明当 Future 已经求值完成后，同步操作会立即返回其结果，而不再需要等待。

#### **公式符号详解**：

- **$val$**：表示表达式已经求值为一个值，即计算已经完成，不需要进一步求值。
- **$7→$**：表示计算步骤的转换关系。例如 $e \rightarrow e'$ 表示表达式 $e$ 在计算中逐步被求值为 $e'$。
- **$fut(e)$**：表示调度一个 Future 任务。
- **$fsyn(e)$**：表示同步一个 Future，等待其完成并获取其值。

### **总结**：

- 在顺序执行中，Futures 通过 $fut(e)$ 提前启动计算，并且在需要结果时，通过 $fsyn(e)$ 获取其值。
- 静态规则确保了 $fut(e)$ 和 $fsyn(e)$ 的类型正确性，顺序动态规则则详细描述了 Futures 的求值和同步过程。
- 顺序动态规则强调了 Futures 的计算是迫切求值的，即使不立即需要其值，它们仍会被启动并完成。

### ---------------------------------

### 40.2 Speculations (推测计算)

Speculations 是一种允许延迟计算的机制，与 Futures 不同，Speculations 是一种可能不需要实际使用其结果的计算方式。它通过提前执行一些计算来尝试加速程序，但这些计算的结果可能不会被最终使用。

#### **Speculations 的语法**：

Speculations 的语法通过以下文法定义：

1. **类型文法 (Typ τ)**：
   - **$τ\ spec$**：表示类型 $τ$ 的推测计算 (Speculation) 类型。这个类型表示一种推测性的计算，结果可能会在未来被使用，也可能不被使用。

2. **表达式文法 (Exp e)**：
   - **$spec(e)$**：表示一个推测计算，调度表达式 $e$ 作为推测计算，允许其并行执行。这个表达式类似于 Future 的 $fut(e)$，但它的计算结果不一定会被使用。
   - **$ssyn(e)$**：表示同步推测计算，等待推测计算的完成并返回其结果。这个操作类似于 Future 的 $fsyn(e)$，但它同步的是推测计算。

### 40.2.1 静态规则 (Statics)

Speculations 的静态规则确保 Speculation 的引入和同步过程符合类型系统的要求。静态类型检查定义了如何验证 Speculation 类型。

#### **规则说明**：

1. **引入 Speculation 的规则**：
   - 如果表达式 $e$ 的类型为 $τ$，则 $spec(e)$ 的类型为 $τ\ spec$，表示将 $e$ 的计算作为推测任务启动，结果类型为 $τ$。形式化表示为：
     $$
     \frac{\Gamma \vdash e : τ}{\Gamma \vdash spec(e) : τ\ spec}
     $$

2. **同步 Speculation 的规则**：
   - 如果表达式 $e$ 是类型为 $τ\ spec$ 的推测计算，则 $ssyn(e)$ 的类型为 $τ$，表示通过同步操作返回推测计算的结果。形式化表示为：
     $$
     \frac{\Gamma \vdash e : τ\ spec}{\Gamma \vdash ssyn(e) : τ}
     $$

这些规则与 Futures 的静态规则非常类似，确保推测计算和其结果的类型匹配。

### 40.2.2 顺序动态规则 (Sequential Dynamics)

在顺序执行的场景下，Speculations 的计算方式类似于 Futures。尽管 Speculations 允许并行执行推测计算，但在顺序执行中，仍然需要处理推测计算的调度和同步。

#### **顺序动态规则**：

1. **引入 Speculation**：
   - 当遇到 $spec(e)$ 时，表达式 $e$ 被调度为推测计算任务。在顺序执行中，这个推测计算可能会立刻执行或稍后执行。推测计算立即返回一个对该计算的引用。表示如下：
     $$
     spec(e) \rightarrow \text{speculation reference of } e
     $$

2. **推测计算的逐步求值**：
   - 如果 $e$ 没有立即完成计算，推测任务会逐步计算。当 $e$ 逐步求值为 $e'$ 时，$spec(e)$ 也会更新为 $spec(e')$。表示为：
     $$
     e \rightarrow e' \quad spec(e) \rightarrow spec(e')
     $$

3. **同步推测计算的逐步求值**：
   - 类似地，当 $ssyn(e)$ 需要同步推测计算时，如果推测计算尚未完成，它会随着 $e$ 的逐步求值而更新为 $ssyn(e')$：
     $$
     e \rightarrow e' \quad ssyn(e) \rightarrow ssyn(e')
     $$

4. **同步已完成的推测计算**：
   - 当推测计算 $spec(e)$ 已经完成，且 $e$ 为一个值时，执行 $ssyn(spec(e))$ 会返回 $e$ 的值：
     $$
     e\ val \quad ssyn(spec(e)) \rightarrow e
     $$

   这意味着，一旦推测计算完成，同步操作可以立即返回结果。

#### **公式符号详解**：

- **$spec(e)$**：表示推测性启动计算 $e$，并且可能不会立即需要其结果。
- **$ssyn(e)$**：表示同步操作，等待推测计算完成并获取其值。
- **$val$**：表示表达式已经求值为一个值。
- **$7→$**：表示表达式的计算步骤转换关系。

### **总结**：

- **Speculations** 允许推测性启动计算，虽然结果可能并不会最终被使用。
- **静态规则**确保 $spec(e)$ 和 $ssyn(e)$ 的类型正确性，与 Futures 的静态规则类似，但推测计算的使用场景更具有不确定性。
- **顺序动态规则** 描述了推测计算的执行过程，尽管在顺序执行中，它们的并行优势有限，但仍然允许提前启动计算并在需要时同步其结果。

### ---------------------------------

### 40.2 Speculations (推测计算)

推测计算 (**Speculations**) 是一种允许提前启动某些计算的机制，和 Futures 类似，但推测计算的结果可能不会被实际使用。这使得推测计算具有一定的风险，因为它可能执行了不必要的工作。推测计算允许我们在程序的主线程之外执行一些推测性的任务，以期在主线程需要这些计算结果时，推测计算已经完成，减少等待时间。

#### **推测计算的语法**：

1. **类型文法 (Typ τ)**：
   - **$τ\ spec$**：表示推测计算的类型。$τ\ spec$ 类型是指一个类型为 $τ$ 的推测计算，它可能会被提前执行，但不一定会被使用。

2. **表达式文法 (Exp e)**：
   - **$spec(e)$**：创建一个推测计算，它将表达式 $e$ 作为推测任务执行。与 $fut(e)$ 类似，$spec(e)$ 启动计算，但它的结果不一定会被立即需求。
   - **$ssyn(e)$**：同步推测计算，表示获取 $e$ 的推测计算结果。如果推测任务还未完成，该操作会等待其完成，并返回结果。

### 40.2.1 静态规则 (Statics)

Speculations 的静态规则非常直观，与 Futures 的静态规则类似。其主要作用是验证推测计算的类型是否正确。

#### **公式解释**：

1. **引入推测计算的规则 (40.3a)**：
   - 当表达式 $e$ 的类型为 $τ$ 时，$spec(e)$ 的类型为 $spec(τ)$，表示表达式 $e$ 被包装为一个推测任务，类型为 $τ$。
     $$
     \frac{\Gamma \vdash e : τ}{\Gamma \vdash spec(e) : spec(τ)}
     $$

2. **同步推测计算的规则 (40.3b)**：
   - 如果表达式 $e$ 是类型为 $spec(τ)$ 的推测计算，则 $ssyn(e)$ 的类型为 $τ$，表示同步推测计算并返回结果。
     $$
     \frac{\Gamma \vdash e : spec(τ)}{\Gamma \vdash ssyn(e) : τ}
     $$

这些静态规则验证了推测计算的类型推导，并确保了在同步操作中，推测计算的结果与其初始表达式类型相符。

### 40.2.2 顺序动态规则 (Sequential Dynamics)

Speculations 的顺序动态规则类似于 Futures，但有一个关键区别：推测计算本身是一个值，而 Futures 不是。推测计算的同步可以在计算尚未完成时进行，而 Futures 的同步则要求其计算完成。

#### **公式解释**：

1. **推测计算是值 (40.4a)**：
   - 规则 $spec(e)\ val$ 表示推测计算本身是一个值。即使表达式 $e$ 还没有被完全求值，推测计算 $spec(e)$ 仍被视为一个值。这与 Futures 不同，Futures 需要等待计算完成后才能返回值。
     $$
     spec(e)\ val
     $$

2. **同步推测计算 (40.4b)**：
   - 规则 $ssyn(spec(e)) \rightarrow e$ 表示同步推测计算时，如果推测计算 $spec(e)$ 已经完成，它会返回表达式 $e$ 的值。不同于 Futures，推测计算可以在任务尚未完成时同步，最终等待结果完成再返回值。
     $$
     ssyn(spec(e)) \rightarrow e
     $$

#### **公式符号详解**：

- **$val$**：表示表达式已经求值为一个值，推测计算本身是值，即使其结果还未计算完成。
- **$7→$**：表示表达式的计算步骤转换。

### **推测计算与 Futures 的对比**：

1. **值的差异**：推测计算是一个值，即使它尚未完成，而 Futures 只有在计算完成后才是一个值。
2. **同步操作的差异**：在 Futures 中，只有当计算完成时，$fsyn(e)$ 才能获取值。而在推测计算中，$ssyn(e)$ 可以在推测任务尚未完成时进行，只是最终会等待结果完成。
3. **计算的风险**：推测计算可能在同步时发现其结果没有被实际使用，这使得推测计算相比 Futures 更具不确定性，可能导致无用计算。

### **总结**：

推测计算为并行计算提供了一种更为灵活的机制，允许提前启动某些计算，并在稍后通过同步操作获取结果。推测计算和 Futures 类似，但其同步操作具有更大的灵活性，允许计算在结果尚未完成时就进行同步。

### ---------------------------------

### 40.3 Parallel Dynamics (并行动态)

并行动态模型是 Futures 和 Speculations 真正具有意义的地方，因为它们允许任务在其他计算的同时并行进行。在并行动态中，任务的创建、执行和同步被显式处理。虽然 Futures 和 Speculations 的并行动态非常相似，但它们的关键区别在于终止条件：Futures 需要所有任务完成后才能终止，而 Speculations 允许在任务未完成时被中断或放弃。

#### **并行动态模型概述**：

1. **任务命名扩展**：
   - 为了处理并行任务，我们引入了任务的命名系统。用 $\Sigma$ 表示一个有限的映射，它将任务的名称映射到类型。表达式 **$fut[a]$** 是一个值，表示任务 $a$ 的结果。这个表示使得每个 Future 可以通过其名称被引用。

2. **静态规则扩展 (40.5)**：
   - 静态规则通过以下形式化规则扩展，确保任务的类型在 $\Sigma$ 中正确映射：
     $$
     \Gamma \vdash_{\Sigma, a \sim \tau} fut[a] : fut(\tau)
     $$
     这条规则表示，如果任务 $a$ 的类型是 $\tau$，则 $fut[a]$ 的类型是 $fut(\tau)$，与之前的 Futures 规则保持一致，只是引入了任务命名。

3. **状态定义**：
   - 在并行动态中，状态的形式为 $\nu\ \Sigma\ \{ e \ k \ \mu \}$，其中：
     - **$e$**：正在计算的表达式。
     - **$k$**：当前的上下文，代表当前正在处理的任务或表达式。
     - **$\mu$**：记录了已经激活的并行 Futures 或 Speculations。它是一个有限的映射，将任务名称映射到与这些任务相关的表达式。

4. **状态的形式化规则 (40.6)**：
   - 一个状态的良好形成性由以下规则给出：
     $$
     \forall a \in dom(\Sigma), \quad \Gamma \vdash_\Sigma \mu(a) : \Sigma(a)
     $$
     这条规则表示每个任务 $a$ 的映射结果 $\mu(a)$ 必须与 $\Sigma(a)$ 的类型一致。

#### **并行动态的两个阶段**：

并行动态可以分为两个主要阶段：**局部阶段** 和 **全局阶段**。

1. **局部阶段 (Local Phase)**：
   - 局部阶段处理单个任务的基本计算步骤。这些步骤对应于表达式的求值。局部步骤是按照顺序执行的，但它们在每个任务内部独立。

2. **全局阶段 (Global Phase)**：
   - 全局阶段执行所有可能的局部步骤，并行处理多个任务。所有任务的局部步骤可以在多个处理器上同时执行。

### **局部动态规则**：

局部动态规则定义了 Futures 在并行动态中的基础求值步骤。以下是局部阶段的一些关键规则：

1. **创建 Future 任务**：
   - 当我们遇到表达式 $fut[e]$ 时，一个新任务会被创建，并被命名为 $a$。这个任务会并行启动，而表达式的主线程可以继续处理其他任务。任务 $a$ 的结果将通过 $fut[a]$ 引用。

2. **同步 Future 任务**：
   - 当我们同步一个 Future 任务时 ($fsyn(e)$)，程序会等待任务 $e$ 的结果。如果任务已经完成，$fsyn$ 会立即返回其结果。如果任务尚未完成，主线程会被阻塞，直到任务完成。

3. **Speculations 的局部动态规则**：
   - Speculations 的局部动态与 Futures 相同，唯一的区别是当主线程发现推测的结果不再需要时，可以放弃该任务。这意味着 Speculations 可以在某些情况下提前终止，而 Futures 任务需要等待完成。

### **公式与符号解释**：

- **$fut[a]$**：表示任务 $a$ 的 Future 结果，通过命名任务使得可以引用并行任务的结果。
- **$\mu$**：记录所有激活的并行任务，并将任务名称映射到具体的计算表达式。
- **局部和全局转换**：局部步骤是单个任务的计算，全局步骤则是多个任务的并行执行。
  
### **总结**：

并行动态为 Futures 和 Speculations 提供了一个明确的模型，定义了任务的创建、执行和同步方式。虽然 Futures 和 Speculations 的并行动态在形式上相似，但 Speculations 允许提前终止任务，而 Futures 需要等待所有任务完成。这种并行模型为程序提供了灵活性和效率，特别是在需要处理多个任务并行执行的场景中。

### ---------------------------------

### 40.3 Parallel Dynamics (并行动态)

并行动态的引入是为了处理 Futures 和 Speculations 的并行执行。并行动态允许计算在多个任务之间共享，同时不依赖于它们完成的顺序。通过并行动态模型，我们可以明确任务的创建、执行以及同步。在并行动态中，任务被标记并跟踪其状态，主线程可以在任务完成之前继续执行，直至需要任务结果。

#### **动态规则介绍**：

并行动态由两个主要阶段组成：

1. **局部阶段 (Local Phase)**：
   - 局部阶段处理单个任务的基本计算步骤。
2. **全局阶段 (Global Phase)**：
   - 全局阶段允许多个任务同时执行局部步骤，实现并行计算。

Futures 和 Speculations 的并行动态几乎相同，唯一的区别在于 Speculations 允许中断未完成的任务，而 Futures 必须等待所有任务完成。

---

### **局部动态规则**

#### 公式 **(40.7a)**：Future 的值

$$
fut[a] \ val_{\Sigma, a \sim \tau}
$$

这个公式表示命名的 Future **$fut[a]$** 是一个值。这是局部动态中一个关键的定义，指出 Future 一旦被创建，它可以通过任务名称 $a$ 被引用。在 $fut[a]$ 表示的值 $a$ 被计算完成后，它会成为 Future 的值。

- **$fut[a]$**：指向任务 $a$ 的 Future 结果。
- **$\Sigma$**：表示任务名称到类型的映射。
- **$a \sim \tau$**：表示任务 $a$ 的类型为 $τ$。

#### 公式 **(40.7b)**：激活 Future

$$
\nu\ \Sigma\ \{ fut(e) \ k \ \mu \} \ 7→_{loc} \ \nu\ \Sigma,\ a \sim \tau \ \{ fut[a] \ k \ \mu ⊗ a \mapsto e \}
$$

这个规则表示当我们遇到一个 Future 表达式 **$fut(e)$** 时，系统会激活一个新任务 $a$，并将表达式 $e$ 作为该任务的计算任务。计算任务 $a$ 启动后，返回对 Future **$fut[a]$** 的引用。

- **$fut(e)$**：表示创建了一个 Future 任务，$e$ 是任务的计算内容。
- **$fut[a]$**：表示任务 $a$ 的 Future 结果，供后续引用。
- **$\nu$**：状态中的符号栈，记录任务的状态。
- **$a \sim \tau$**：表示任务 $a$ 的类型为 $τ$，此任务被并行启动。

#### 公式 **(40.7c)**：同步 Future 的逐步求值

$$
\nu\ \Sigma\ \{ fsyn(e) \ k \ \mu \} \ 7→_{loc} \ \nu\ \Sigma' \ \{ fsyn(e') \ k \ \mu' \}
$$

这个公式表示在同步 Future 时，$fsyn(e)$ 会通过逐步求值来同步 Future 任务。如果 Future 任务还未完成，则会继续等待其结果，直到 Future 任务完成。

- **$fsyn(e)$**：表示 Future 的同步操作，获取 Future 结果。
- **$\nu$**：状态中的符号栈。
- **$e \rightarrow e'$**：表示表达式 $e$ 的逐步求值。
- **$k$**：当前计算的上下文。

#### 公式 **(40.7d)**：同步已经完成的 Future

$$
\begin{aligned}
e_0 \ val_{\Sigma, a \sim \tau} \\
\nu\ \Sigma,\ a \sim \tau \ \{ fsyn(fut[a]) \ k \ \mu \otimes a \mapsto e_0 \} & \ 7→_{loc} \ \nu\ \Sigma,\ a \sim \tau \ \{ e_0 \ k \ \mu \otimes a \mapsto e_0 \}
\end{aligned}
$$

这个公式表示当一个 Future **$fut[a]$** 已经计算完成，并且其结果是 $e_0$，同步操作 **$fsyn(fut[a])$** 将返回该结果。此时任务 $a$ 的计算已经完成，因此 Future 的同步可以立即获得任务的值。

- **$fsyn(fut[a])$**：表示对已经完成的任务 $a$ 进行同步操作。
- **$e_0$**：任务 $a$ 的计算结果。
- **$a \mapsto e_0$**：表示任务 $a$ 的结果映射为 $e_0$，并且可以同步获得其值。

---

### **全局动态规则**

全局动态处理多个任务的并行执行。每个全局步骤允许多个局部步骤并行执行，这意味着我们可以同时计算多个任务。

#### 全局转换的形式

全局转换的形式表示为：

$$
\begin{aligned}
\nu\ \Sigma_1 \ a_1 \sim \tau_1 \ \{ \mu_1 \otimes a_1 \mapsto e_1 \} & \ 7→_{loc} \ \nu\ \Sigma_1' \ a_1 \sim \tau_1 \ \{ \mu_1' \otimes a_1 \mapsto e_1' \} \\
\cdots \\
\nu\ \Sigma_n \ a_n \sim \tau_n \ \{ \mu_n \otimes a_n \mapsto e_n \} & \ 7→_{loc} \ \nu\ \Sigma_n' \ a_n \sim \tau_n \ \{ \mu_n' \otimes a_n \mapsto e_n' \} \\
\nu\ \Sigma_0 \ \Sigma_1 a_1 \sim \tau_1 \dots \Sigma_n a_n \sim \tau_n & \ \{ \mu_0 \otimes \mu_1 \otimes a_1 \mapsto e_1 \otimes \dots \otimes \mu_n \otimes a_n \mapsto e_n \} \ 7→_{glo} \ \nu\ \Sigma_0 \Sigma_1' \dots \Sigma_n' \ \{ \mu_0 \otimes \mu_1' \otimes a_1 \mapsto e_1' \otimes \dots \mu_n' \otimes a_n \mapsto e_n' \}
\end{aligned}
$$

在每个全局步骤中，我们允许多个任务同时执行局部步骤。例如，任务 $a_1$ 和任务 $a_2$ 可以在同一时刻进行计算，并更新它们的状态。

#### 公式解释：

- **$\nu\ \Sigma_1 \dots \Sigma_n$**：表示多个任务的状态。
- **$a_1, a_2, \dots, a_n$**：任务的名称。
- **$\mu_1, \mu_2, \dots, \mu_n$**：每个任务的当前映射，记录其任务状态。
- **$7→_{glo}$**：表示全局并行执行，多个任务同时进行局部计算。

### **总结**：

并行动态模型允许多个任务同时进行并行计算。通过任务命名机制，任务的结果可以通过名称引用，并且可以在主线程的同步操作中获得。局部动态规则定义了每个任务如何逐步求值，而全局动态则管理多个任务的并行执行。Futures 和 Speculations 的唯一差异在于终止条件，Speculations 可以在未完成时中断，而 Futures 需要等待所有任务完成。

### ---------------------------------

### 40.3 Parallel Dynamics (并行动态)

在并行动态中，我们需要处理多个任务的创建、同步、以及它们的完成状态。任务可以通过 Futures 或者 Speculations 的形式存在。Futures 需要在所有任务完成后才能终止，而 Speculations 允许某些任务在未完成的情况下终止，因为它们的结果可能并不需要。

#### **公式详解：**

#### 公式 **(40.8a)**：全局动态规则

首先，公式 (40.8a) 的目标是描述多个并行任务在全局步骤中的执行。

$$
\mu = \mu_0 \otimes a_1 \mapsto e_1 \otimes \dots \otimes a_n \mapsto e_n
$$

这意味着 $\mu$ 是并行任务的映射，其中每个任务 $a_i$ 都映射到相应的表达式 $e_i$，并且这些任务可以独立执行。公式中的 $\otimes$ 表示并行执行的多个任务。

- **$\mu_0$**：主线程的任务映射。
- **$a_1 \mapsto e_1, \dots, a_n \mapsto e_n$**：表示每个并行任务的映射，任务 $a_i$ 由表达式 $e_i$ 代表。

$$
\mu' = \mu_0 \otimes a_1 \mapsto e'_1 \otimes \dots \otimes a_n \mapsto e'_n
$$

这里，$\mu'$ 表示所有任务在一个局部步骤后的更新状态。每个任务 $a_i$ 的表达式 $e_i$ 经过局部步骤后更新为 $e'_i$。

公式右侧则表示全局步骤中的转换规则：

$$
\nu\ \Sigma\ \{ e \ k \ \mu \} \ 7→_{loc} \ \nu\ \Sigma\ \Sigma_0 \ \{ e' \ k \ \mu \otimes \mu' \}
$$

- **$\nu \Sigma$**：表示状态中的符号栈，跟踪每个任务的当前状态。
- **$e \ k \ \mu$**：表示当前的主线程正在执行的表达式 $e$，以及当前并行任务的映射 $\mu$。
- **$\mu'$**：表示在全局步骤中，并行任务的结果经过局部步骤后产生的新状态。

> **符号详解**：
>
> - **$7→_{loc}$**：表示局部步骤。
> - **$\otimes$**：表示并行执行的任务组合。

整个公式的最后部分是全局转换规则的定义：

$$
\nu\ \Sigma\ \Sigma_0 \Sigma_1 \dots \Sigma_n \ \{ e' \ k \ \mu_0 \otimes \mu_1 \otimes a_1 \mapsto e'_1 \dots \mu_n \otimes a_n \mapsto e'_n \}
$$

这意味着所有并行任务的结果经过局部步骤的更新后，会形成新的状态 $\mu'$，该状态包括所有任务在局部步骤后的更新结果。

---

### **局部和全局动态解释：**

- **局部步骤**：每个任务单独执行局部计算步骤，可能涉及表达式的部分求值。局部步骤只影响单个任务，而不影响其他任务的状态。
  
- **全局步骤**：全局步骤允许多个任务同时执行局部步骤，并将所有任务的状态更新同步到主线程。每个全局步骤可以包含多个并行局部步骤。

公式 (40.8a) 的核心思想在于：并行执行的任务彼此独立，它们的结果可以通过局部步骤单独计算，并在全局步骤中合并。整个过程中的符号栈 $\nu$ 和任务映射 $\Sigma$ 确保了任务状态的正确管理。

#### **公式 **(40.9)**：初始状态

$$
\nu\ \emptyset\ \{ e \ k \ \emptyset \} \ \text{initial}
$$

这条规则定义了一个计算的初始状态。在这个初始状态中，没有任务 ($\emptyset$)，并且主线程的表达式 $e$ 将开始执行。

#### **公式 **(40.10)**：Futures 的终止条件

- 公式 (40.10a) 定义了 Futures 的终止状态：
  $$
  e \ val_{\Sigma} \ \mu \ val_{\Sigma}
  $$
  这意味着如果主线程表达式 $e$ 是一个值，并且所有并行任务 $\mu$ 也都是值，那么这个状态就被认为是终止状态。
  
- 公式 (40.10b) 补充说明了对于每个任务 $a$，如果任务结果 $μ(a)$ 是值，那么任务映射 $\mu$ 也是值。也就是说，所有任务必须完成，整个程序才能终止。

#### **公式 **(40.11)**：Speculations 的终止条件

$$
e \ val_{\Sigma}
$$

Speculations 的终止条件比 Futures 更宽松，只要主线程的表达式 $e$ 是值，就认为它已经终止，而不需要所有的并行任务都完成。

---

### **总结**：

并行动态通过局部和全局步骤处理多个并行任务的计算和同步。Futures 和 Speculations 的区别在于终止条件，Futures 要求所有任务完成，而 Speculations 只要求主线程完成即可。公式 (40.8a) 描述了全局步骤如何通过多个局部步骤同时处理任务的执行，而公式 (40.10) 和 (40.11) 则分别定义了 Futures 和 Speculations 的终止条件。

### ---------------------------------

### 40.4 Futures 的应用

#### 背景说明

在本节中，作者通过 **流水线 (Pipelining)** 提供了一个关于 **并行 futures** 的实际应用示例。该示例场景涉及两个部分：**生产者 (Producer)** 和 **消费者 (Consumer)**。

- **生产者**：生成一系列待处理的工作单元，这些工作单元被构造成一个列表。
- **消费者**：遍历该工作列表，并对列表中的每个元素执行相应的操作。

在顺序实现中，生产者首先生成完整的工作列表，然后消费者遍历该列表。然而，如果每个元素的生成过程较慢，使用 futures 可以优化此过程，使得生产者生成下一个元素的同时，消费者可以并行处理之前的工作单元。此时，生产和消费可以重叠进行，从而提高效率。

---

### 递归类型定义与生产者函数

我们首先定义了一个 **递归类型**，表示该工作列表的结构：

#### **类型定义：**

$$
\text{flist} = \mu t. \text{unit} + (\text{nat} \times t \ \text{fut})
$$

- **flist** 是一种递归类型，表示一个列表。
- $\mu t$ 表示递归定义，意思是 $t$ 作为递归类型的一部分。
- $\text{unit}$ 表示空列表，即 `nil`。
- $\text{nat} \times t \ \text{fut}$ 表示列表中的元素类型为自然数和下一个未来列表的组合。这里的 `fut` 表示未来类型，允许并行计算下一个元素。

#### **列表元素的构造：**

- **nil**：定义为 `fold(l · \langle \rangle)`，表示空列表。
- **cons(e_1, e_2)**：定义为 `fold(r · \langle e_1, fut(e_2) \rangle)`，表示包含元素 $e_1$ 和递归调用未来列表 $e_2$ 的非空列表。

#### **生产者函数：**

生产者是一个递归函数，用来生成类型为 **flist** 的值：

```haskell
fix produce : (nat → nat opt) → nat → flist is
λ f. λ i.
case f(i) {
  null ⇒ nil
  | just x ⇒ cons(x, fut(produce f (i+1)))
}
```

- **$f$**：一个函数，接受一个自然数并返回一个可选值（`nat opt`），用于判断是否生成下一个元素。
- **$i$**：生产者当前处理的自然数。
- **$nil$**：当 $f(i)$ 返回 `null` 时，生成一个空列表。
- **$cons(x, fut(produce f (i+1)))$**：当 $f(i)$ 返回 `just x` 时，生成一个 `cons`，其中 $x$ 是当前元素，$fut(produce f (i+1))$ 是并行生成的未来列表的尾部。

> **详解公式：**
>
> - **$fut(produce f (i+1))$**：调用 `produce` 递归地生成下一个元素，但通过 `fut` 使其并行计算，从而与当前的生成过程重叠。

---

### 消费者函数

消费者是一个递归函数，用于遍历 **flist** 并对其进行处理：

```haskell
fix consume : ((nat × nat) → nat) → nat → flist → nat is
λ g. λ a. λ xs.
case xs {
  nil ⇒ a
  | cons (x, xs) ⇒ consume g (g (x, a)) (syn xs)
}
```

- **$g$**：一个函数，用于处理每个元素 $x$ 与累积值 $a$ 之间的关系，返回新的累积值。
- **$a$**：当前的累积值。
- **$xs$**：当前的工作列表。

#### **消费者的逻辑：**

- **$nil ⇒ a$**：如果工作列表为空，则返回累积值 $a$。
- **$cons(x, xs)$**：如果列表包含元素 $x$ 和尾部 $xs$，则递归调用 `consume`，对 $g(x, a)$ 进行累积。同时，使用 `syn(xs)` 来同步尾部 $xs$，确保它已经准备好继续处理。

> **详解公式：**
>
> - **$syn(xs)$**：同步未来值。如果尾部列表的计算尚未完成，消费者将在此处等待，直到尾部准备就绪。
> - **$consume g (g(x, a)) (syn xs)$**：递归地消费工作列表，将当前元素 $x$ 和累积值 $a$ 结合，并处理尾部 $xs$。

---

### 总结

通过 futures，生产者可以在生成列表的同时并行处理下一个元素，消费者则通过同步机制确保它能够在需要时等待未来值的完成，从而实现流水线式的并行处理。这种并行方式有助于提高整体效率，尤其是当生产和消费的工作负载较大时。

### ---------------------------------

### Futures 的另一种应用 —— 控制惰性求值中的并行性

#### 背景说明

在包含 **惰性 suspension**（参见第 37 章）机制的语言中，**futures** 可以提供更多的并行控制。使用 futures 而不是直接对 suspension 进行投机性求值（work inefficient）可以提高效率。一个典型的应用就是 **spark**。

- **spark** 是一种并行执行的计算，目的是提前强制执行数据结构中的 suspensions，确保它们的值在后续主计算需要时已经被计算好。尽管 spark 本身不产生任何有用的输出，但它加速了 suspensions 的求值过程。

#### spark 的工作原理

**spark(e₁; e₂)** 的顺序动态行为是先执行 $e₁$ 再执行 $e₂$。在惰性求值（**by-need dynamics**）的上下文中，$e₁$ 的求值会将 suspension 的结果记录在 memo 表中，以便后续计算 $e₂$ 使用。

**并行动态** 在此基础上增加了 $e₁$ 和 $e₂$ 并行执行的行为。为了更好地理解 spark 的作用，我们可以将 spark 的定义用 futures 表达为：

$$
\text{let } b = \text{fut}(e₁) \text{ in } e₂
$$

这个表达式的含义是，$e₁$ 的计算立即开始，但它的值可以被抛弃。虽然这种编码方式并不允许 $e₁$ 的求值在 $e₂$ 达到值时就立即中止，但由于 spark 的主要目的是在计算主线程前强制执行 suspensions，所以这个情境不太可能出现。

---

#### spark 的应用示例

让我们以 **流**（**stream**）为例，流是通过递归类型定义的：

$$
\text{strm} = \mu t.(\text{unit} + (\text{nat} \times t)) \ \text{spec}
$$

这意味着流的元素是 **suspension** 的计算，当强制求值时，返回的是流的结束标志（unit）或者一个数和另一个流（nat × t）。我们假设某个流 $s$ 是有限的，并且我们希望对其应用映射函数 $f$，即 **map(f)(s)**，并希望将元素的生成与映射操作并行化。

#### 使用 futures 强制执行 stream 中的 suspensions

为此，我们可以使用函数 **mapforce** 来强制执行输入流中的连续元素，但不产生有用的输出。我们可以通过以下计算来实现：

$$
\text{spark(mapforce(s); map(f)(s))}
$$

这个表达式会强制执行流中的所有元素，同时并行地进行 **map(f)(s)** 的计算。通过这种方式，stream 中的所有 suspensions 都会在主计算需要它们的值之前被强制求值。

---

### 使用 futures 实现二元嵌套并行性

我们还可以通过 futures 实现 **二元嵌套并行性**。考虑以下定义：

$$
\text{par}(e₁; e₂; x₁.x₂.e) \equiv \text{let } x₀₁ = \text{fut}(e₁) \text{ in let } x₂ = e₂ \text{ in let } x₁ = \text{fsyn}(x₀₁) \text{ in } e
$$

这里 **par** 表示并行计算两个表达式 $e₁$ 和 $e₂$，然后在 $x₁$ 和 $x₂$ 中使用它们的值进行计算。使用 futures 来实现这一点的关键在于保证 $e₂$ 的计算与 $e₁$ 并行执行，而 $e$ 的计算要等到 $e₁$ 和 $e₂$ 都完成后才能继续。

> **详解公式：**
>
> - **$\text{let } x₀₁ = \text{fut}(e₁)$**：启动 $e₁$ 的计算并创建一个 future，用 $x₀₁$ 表示 future。
> - **$\text{let } x₂ = e₂$**：并行执行 $e₂$，同时 $e₁$ 的计算也在进行。
> - **$\text{let } x₁ = \text{fsyn}(x₀₁)$**：同步 $x₁$，等待 $e₁$ 的计算完成后再继续。
> - **$e$**：在 $e₁$ 和 $e₂$ 都完成后，最终计算 $e$。

通过这种方式，我们确保并行计算的效率，同时保证计算顺序的正确性。

---

### 总结

1. **spark** 提供了一种高效控制并行性的方式，特别适合与 **suspensions** 搭配使用，以提前强制求值。通过 futures，我们能够保证在主计算之前并行完成所需的 suspension 计算。
2. **futures** 还可以用于实现复杂的并行模式，例如 **二元嵌套并行性**，通过并行执行多个子任务并最终合并结果。

这些应用展示了 **futures** 在控制并行计算和优化惰性求值方面的强大能力。

### ---------------------------------

### 40.5 备注

**Futures** 最早是在 **MultiLisp 语言**（Halstead, 1985）中引入的。这个概念也被 Arvind 等人（1986）提出，称为“**I-structures**”（数据结构的一种形式，用于并行计算）。本书中给出的 futures 形式主要基于 Greiner 和 Blelloch（1999）的工作。

#### 重要背景：

- **MultiLisp 语言** 是一种 Lisp 的并行扩展，设计用于在共享内存多处理器上进行并行编程。它的一个核心特点就是 futures 这种并行机制，它允许程序员明确表示某个计算可以被并行化，并随后在计算完成时获取结果。
  
- **I-structures** 是一种用于并行计算的数据结构，允许并行任务安全地读写共享数据。Arvind 等人提出的这种结构为高效的并行计算提供了模型，允许多个任务在共享内存中执行，类似于 futures 的行为。

#### 现代应用：

- **Greiner 和 Blelloch**（1999）的工作进一步将 futures 应用于现代并行编程的上下文中，通过理论模型和并行算法证明 futures 的高效性。他们的工作对本书中的 futures 概念有深远的影响，为程序设计中的并行计算提供了坚实的理论基础。

#### 小结：
futures 的概念从最初的 MultiLisp 中引入，并通过 I-structures 进一步发展，最终在 Greiner 和 Blelloch 的工作中得到了正式化和广泛应用。在编程语言中，futures 为并行计算提供了一种灵活而高效的机制，允许在多个计算任务之间并行化执行，提升程序的执行效率。


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------
[toc]

### 第1章 语法对象 (Chapter 1: Syntactic Objects)

#### 编程语言的定义 (Definition of Programming Languages)

编程语言是一种表达**计算**(computation)的语言形式，它不仅可以被**人类**(people)理解，也能够被**机器**(machines)理解。语言的**语法**(syntax)定义了各种短语（如**表达式**(expressions)、**命令**(commands)、**声明**(declarations)等）如何组合成程序的规则。

> **关键点**：这里强调了语言不仅仅是沟通人和机器的工具，其核心是通过语法规则组合形成**程序**(program)。

#### 表面语法与结构语法 (Surface Syntax and Structural Syntax)

语法的**非正式概念**(informal concept of syntax)可以细分为几个不同的概念：

1. **表面语法**(Surface Syntax) 或 **具体语法**(Concrete Syntax)：  
   关注短语如何在计算机上被输入和显示。表面语法通常被认为是由某个字母表（如**ASCII**或**Unicode**）中的**字符串**(strings of characters)给定的。  
   - 表面语法是程序的外在表现形式，通常表现为一串字符，这些字符可以被人类和机器读取和分析。

2. **结构语法**(Structural Syntax) 或 **抽象语法**(Abstract Syntax)：  
   关注短语的**结构**(structure)，特别是它们是如何由其他短语组合而成的。在这个层次上，短语是一棵**树**(tree)，称为**抽象语法树**(Abstract Syntax Tree, AST)，树的节点是操作符，用来组合多个短语形成新的短语。  
   - 这里的树结构反映了程序内部的逻辑结构，而不是字符如何在屏幕上显示。
  
3. **绑定结构**(Binding Structure)：  
   关注标识符的引入和使用方式：标识符如何声明，声明的标识符又是如何使用的。此时，短语被视为**抽象绑定树**(Abstract Binding Tree)，它在抽象语法树的基础上添加了**绑定**(binding)和**作用域**(scope)的概念。  
   - 这部分处理变量和标识符的作用域，确保标识符在正确的上下文中使用。

> **关键点**：表面语法与结构语法的区别在于前者是外在表现，后者是内在结构。**抽象语法树**(Abstract Syntax Tree, AST)和**抽象绑定树**(Abstract Binding Tree)是这两个层次的重要工具，尤其在编译器和解释器设计中非常关键。

#### 抽象语法树与抽象绑定树 (Abstract Syntax Trees and Abstract Binding Trees)

本书将不会涉及**表面语法**(concrete syntax)的内容，而是专注于**抽象语法**(abstract syntax)层面的讨论。为了为全书后续内容做准备，本章首先定义了**抽象语法树**(Abstract Syntax Trees, AST)和**抽象绑定树**(Abstract Binding Trees)，并讨论与它们相关的一些函数和关系。

- **抽象语法树**(Abstract Syntax Trees, AST)：树的每个节点是操作符，而操作符用于组合多个短语形成新的短语。  
- **抽象绑定树**(Abstract Binding Trees)：在抽象语法树的基础上，增加了标识符绑定和作用域的概念，处理变量声明和使用的语法。

#### 技术性定义与阅读建议 (Technical Definitions and Reading Suggestions)

本章的一些定义可能有些**技术性**(technical)，但是对于后续内容至关重要。建议首次阅读时可以略读此章，之后根据需要回顾。

> **总结**：编程语言的语法分为表面语法和抽象语法，抽象语法通过抽象语法树和抽象绑定树来表示。这些概念虽然技术性较强，但它们为后续编程语言设计的讨论奠定了基础。

---



### -----------------------------------

为保证**性质 P** 对任何类型为 Exp 的抽象语法树 a 成立，我们需要覆盖所有可能生成 a 的情况。这意味着，如果我们能证明每种情况都满足性质 P，那么 P(a) 对于所有类型为 Exp 的抽象语法树都成立。

#### 精确定义 (Precise Definitions)

为了更准确地定义前述概念，设 $S$ 为有限的**类型集合**(sorts)，定义一个**运算符**(operators)的类型索引族 $\{O_s\}_{s \in S}$，其中每个运算符 $o$ 的类型为 $s$，其**元数**(arity)为 $ar(o) = (s_1, \ldots, s_n)$。同时，定义一个**变量**(variables)的类型索引族 $\{X_s\}_{s \in S}$，其中每个变量 $x$ 的类型为 $s$。语法树 $A[X] = \{A[X]_s\}_{s \in S}$ 是满足以下条件的最小集合：

1. **变量**是抽象语法树：如果 $x \in X_s$，则 $x \in A[X]_s$。
2. **运算符组合语法树**：如果 $o$ 是类型为 $s$ 的运算符，且 $ar(o) = (s_1, \ldots, s_n)$，并且 $a_1 \in A[X]_{s_1}, \ldots, a_n \in A[X]_{s_n}$，则 $o(a_1; \ldots; a_n) \in A[X]_s$。

基于此定义，我们可以使用**结构归纳法**(structural induction)证明某一性质 P 对所有抽象语法树都成立。具体证明步骤如下：

1. 若 $x \in X_s$，则 $P_s(x)$ 成立。
2. 若 $o \in O_s$ 且 $ar(o) = (s_1, \ldots, s_n)$，并且 $P_{s_1}(a_1), \ldots, P_{s_n}(a_n)$ 成立，则 $P_s(o(a_1; \ldots; a_n))$ 也成立。

例如，我们可以通过结构归纳法很容易证明，如果 $X \subseteq Y$，则 $A[X] \subseteq A[Y]$。

#### 变量的加入 (Adjoining Variables)

如果 $X$ 是一个类型索引的变量族，记作 $X, x$，其中 $x$ 是类型为 $s$ 的变量，表示为 $X / s$。这一符号表示通过将变量 $x$ 加入到 $X$ 中生成的新变量族 $Y$，其中 $Y_s = X_s \cup \{x\}$，且对于 $s' \neq s$，有 $Y_{s'} = X_{s'}$。这个过程称为**将变量 $x$ 加入到 $X$**。

#### 替换 (Substitution)

变量的意义通过**替换**(substitution)来赋予。设 $x$ 是类型为 $s$ 的变量，$a \in A[X, x]_{s'}$，$b \in A[X]_s$，则 $[b/x]a \in A[X]_{s'}$ 表示用 $b$ 替换 $a$ 中所有 $x$ 的结果。此时，$a$ 称为替换的**目标**(target)，$x$ 称为替换的**主题**(subject)。替换的定义如下：

1. $[b/x]x = b$ 且 $[b/x]y = y$ 若 $x \neq y$。
2. $[b/x]o(a_1; \ldots; a_n) = o([b/x]a_1; \ldots; [b/x]a_n)$。

例如，可以验证：
$$
[num[2]/x]\text{plus}(x; \text{num[3]}) = \text{plus}(\text{num[2]}; \text{num[3]}).
$$

我们可以通过**结构归纳法**证明，抽象语法树上的替换是**良定义的**(well-defined)。

### --------------------

### 定理 1.1 (Theorem 1.1)

**定理**：  
设 $a \in A[X, x]$，则对每个 $b \in A[X]$，存在唯一的 $c \in A[X]$，使得 $[b/x]a = c$。

**证明**：  
通过对 $a$ 进行**结构归纳**(structural induction)证明。

1. **基本情况**：  
   - 如果 $a = x$，则根据定义，$c = b$。
   - 如果 $a = y$ 且 $y \neq x$，则根据定义，$c = y$。
  
2. **归纳情况**：  
   - 如果 $a = o(a_1, \ldots, a_n)$，则根据归纳假设，对于每个 $a_i$，存在唯一的 $c_i$，使得 $[b/x]a_i = c_i$。因此，$c = o(c_1; \ldots; c_n)$，根据替换的定义，这就是 $[b/x]a$ 的唯一结果。

### 可扩展的操作符 (Extensible Operators)

在大多数情况下，可以预先列举生成某种类型的所有操作符。然而，在某些情况下，某些操作符仅在特定上下文中可用。此时，不能提前固定操作符集合 $O$，而是必须允许其**可扩展**(extensible)。这是通过引入由**符号参数**(symbolic parameters)索引的操作符族实现的，这些符号参数充当实例的“名称”。

例如，在第 34 章中，我们将讨论一个零元操作符族 $\text{cls}[u]$，其中 $u$ 是从**活动参数集合**(active parameters)中选取的符号参数。重要的一点是，不同的参数确定不同的操作符：如果 $u \neq v$，则 $\text{cls}[u]$ 和 $\text{cls}[v]$ 是不同的操作符。通过引入新的活动参数实现扩展性。如果 $u$ 不活跃，则 $\text{cls}[u]$ 没有意义；但如果 $u$ 成为活跃参数，则 $\text{cls}[u]$ 是一个零元操作符。

### 参数与变量的区别 (Difference Between Parameters and Variables)

- **变量**(variables)：表示其类型的未知抽象语法树(ast)，其意义通过**替换**(substitution)赋予。
- **参数**(parameters)：纯粹的符号标识符，其唯一意义在于它是否与另一个参数相同或不同。参数不能被替换，也无意义进行替换。

在替换过程中，**参数的不等性**(disequality of parameters)被保留，而**变量的不等性**(disequality of variables)则不一定保留，因为同一个抽象语法树可能被替换为两个不同的变量。

#### 活动参数的表示 (Active Parameters Representation)

为了考虑活动参数的集合，我们使用 $A[U; X]$ 表示抽象语法树集合，变量来自 $X$，参数来自 $U$。某些操作符（如 $\text{cls}[u]$）依赖于某个类型的参数 $u$，这些参数与其参数通过方括号区分。只有当参数来自活动集合 $U$ 时，才允许实例化这些操作符。

例如，当 $u \in U$ 时，$\text{cls}[u]$ 是一个零元操作符，但如果 $u \notin U$，则 $\text{cls}[u]$ 不是有效的操作符。在下一节中，我们将介绍如何扩展 $U$ 以便在某个上下文中使操作符可用。

### ---------------------------

### 定理 1.1 (Theorem 1.1)

**定理**：  
如果 $a \in A[X, x]$，那么对于每个 $b \in A[X]$，存在唯一的 $c \in A[X]$，使得 $[b/x]a = c$。

**证明**：  
我们通过对 $a$ 进行**结构归纳**(structural induction)来证明。

1. **基本情况**：
   - 如果 $a = x$，即 $a$ 是我们要替换的变量 $x$，根据替换的定义，$[b/x]x = b$，因此此时 $c = b$。
   - 如果 $a = y$ 且 $y \neq x$，即 $a$ 是一个与 $x$ 不同的变量，根据替换的定义，$[b/x]y = y$，因此 $c = y$。

2. **归纳情况**：
   - 如果 $a = o(a_1, a_2, \dots, a_n)$，即 $a$ 是由操作符 $o$ 作用于子树 $a_1, a_2, \dots, a_n$ 组合而成的抽象语法树。根据归纳假设，我们知道对于每个 $a_i$（$1 \leq i \leq n$），存在唯一的 $c_i$ 使得 $[b/x]a_i = c_i$。  
     根据替换的定义，对于 $a = o(a_1, a_2, \dots, a_n)$，有 $[b/x]o(a_1, a_2, \dots, a_n) = o([b/x]a_1, [b/x]a_2, \dots, [b/x]a_n)$，因此 $c = o(c_1, c_2, \dots, c_n)$。  
     这表明，$[b/x]a$ 也是唯一的，因为 $c$ 是由归纳得到的唯一 $c_1, c_2, \dots, c_n$ 组合而成。

**总结**：通过结构归纳法，证明了对于每个 $b \in A[X]$，$[b/x]a$ 存在且唯一。

---

### 可扩展操作符 (Extensible Operators)

在许多情况下，可以预先枚举生成某种类型抽象语法树的所有操作符。比如在前面的例子中，我们提前定义了零元操作符 $num[n]$ 和二元操作符 $plus$、$times$，它们能生成类型为 Exp 的抽象语法树。但是在某些情况下，某些操作符仅在特定上下文中可用。这种情况下，我们不能提前固定操作符的集合 $O$，而是需要让其具备**可扩展性**(extensibility)。这可以通过引入由符号参数索引的操作符族来实现，符号参数充当这些实例的“名称”。

#### 可扩展操作符的例子

例如，在第 34 章中，我们将会讨论一个零元操作符族 $\text{cls}[u]$，其中 $u$ 是从**活动参数集合**(set of active parameters)中选取的符号参数。重要的是，不同的参数必须对应不同的操作符。如果 $u \neq v$，则 $\text{cls}[u]$ 和 $\text{cls}[v]$ 是不同的操作符。通过引入新的活动参数，可以实现扩展性。

- **活动参数的引入**：如果 $u$ 是非活跃的参数，$\text{cls}[u]$ 没有意义；但如果 $u$ 成为活跃参数，则 $\text{cls}[u]$ 成为有效的零元操作符。这个设计允许我们根据上下文引入新的操作符，从而实现操作符的可扩展性。

---

### 参数与变量的区别 (Difference Between Parameters and Variables)

**变量**(variables)和**参数**(parameters)在编程语言的抽象语法中是两个不同的概念。虽然它们都可以用符号表示，但它们的作用和使用方式有所不同：

1. **变量**：  
   - 变量表示某个特定类型的**未知**(unknown)抽象语法树。变量的含义通过**替换**(substitution)赋予，即用某个具体的抽象语法树替换变量，得到一个新的抽象语法树。
   - 变量在不同上下文中可以有不同的值，例如可以用不同的抽象语法树替换相同的变量。

2. **参数**：  
   - 参数是**纯符号标识符**(symbolic identifier)，不表示任何对象。它们唯一的意义在于它们的符号是否相同或不同。参数不能被替换，也没有替换的意义。
   - 参数的作用是引入新的操作符，并通过它们的符号来区分不同的操作符。例如，$\text{cls}[u]$ 和 $\text{cls}[v]$ 是不同的操作符，即使它们的结构类似。

#### 参数与变量在替换中的表现

- **变量**的相等性或不等性在替换后可能会改变，因为不同的变量可以被替换为相同的抽象语法树。
- **参数**的相等性在替换过程中始终保持不变，因为参数只是符号标识符，不会被替换。

---

### 活动参数的语法表示 (Representation of Active Parameters)

为了同时处理变量和参数，我们用 $A[U; X]$ 表示变量来自集合 $X$ 且参数来自集合 $U$ 的抽象语法树集合。某些操作符，如 $\text{cls}[u]$，依赖于参数 $u$，参数的符号与操作符的参数通过方括号区分。

例如：
- 当 $u \in U$ 时，$\text{cls}[u]$ 是一个有效的零元操作符。
- 当 $u \notin U$ 时，$\text{cls}[u]$ 不再是一个有效的操作符。

在下一节中，我们将介绍如何通过扩展 $U$ 使得新的操作符在某些上下文中可用。

### ------------------------

### 1.2 抽象绑定树 (Abstract Binding Trees)

**抽象绑定树**(Abstract Binding Trees, ABT) 是对抽象语法树（AST）的扩展，能够引入新的变量和参数（称为**绑定**(binding)），并且为这些绑定指定它们的作用范围（称为**作用域**(scope)）。绑定的作用域是 ABT 中的一个子树，在该子树中可以使用被绑定的标识符，标识符可以作为占位符（如变量声明的情况），或者作为某些操作符的索引（如参数声明的情况）。因此，在 ABT 的某些子树中，活动标识符的集合可能比外部树中的要大，并且不同的子树可以引入具有不相交作用域的标识符。

#### 变量的引用 (Reference of Variables)

**引用**(reference)的核心原则是，任何标识符的使用都应当被理解为对其绑定的引用，或者称为对绑定的**抽象指针**(abstract pointer)。因此，标识符的选择是无关紧要的，只要我们始终能将每次标识符的使用唯一地关联到一个绑定。

#### 示例：let 表达式

考虑表达式 `let x be a1 in a2`，该表达式引入了一个变量 $x$，在 $a_2$ 中可以使用 $x$ 代表表达式 $a_1$。在这个表达式中，$x$ 由 `let` 绑定，且只在 $a_2$ 中有效。任何在 $a_1$ 中使用 $x$ 的情况，实际上指的是另一个具有相同名称但不同绑定的变量。

例如，表达式 `let x be 7 in x + x` 中，两个 $x$ 的使用都引用了由 `let` 引入的变量 $x$。而在表达式 `let x be x * x in x + x` 中，乘法中的 $x$ 引用了不同的变量，而加法中的 $x$ 引用了由 `let` 引入的变量。

#### 变量名称的无关性 (Irrelevance of Bound Variable Names)

对于绑定的变量，其名称并不影响表达式的含义，只要绑定保持不变。例如，表达式 `let x be x * x in x + x` 可以等效地写作 `let y be x * x in y + y`，两者的含义完全相同，因为它们的**指针结构**(pointer structure)保持一致。然而，表达式 `let x be y * y in x + x` 与前两者不同，因为其中的 $y$ 引用了另一个外部的变量。

变量的重命名受到一定限制，不能改变表达式的引用结构。例如，表达式 `let x be 2 in let y be 3 in x + x` 和 `let y be 2 in let y be 3 in y + y` 有不同的含义。因为在第二个表达式中，$y + y$ 中的 $y$ 引用的是内部的 $y$，而在第一个表达式中，$x + x$ 引用的是外部的 $x$。

#### 抽象绑定树的结构 (Structure of Abstract Binding Trees)

为了处理变量的绑定和作用域，抽象语法树的概念可以被扩展为**抽象绑定树**(Abstract Binding Trees, ABT)。ABT 允许操作符在每个参数位置绑定任意数量（可能为零）的变量。操作符的参数称为**抽象器**(abstractor)，形式为 $x_1, \dots, x_k.a$，其中变量序列 $x_1, \dots, x_k$ 在 ABT $a$ 内部被绑定。

- 当 $k = 0$ 时，抽象器可以被简化为 $a$ 本身。
- 例如，表达式 `let x be a1 in a2` 可以被写作 `let(a1; x.a2)`，这更加清晰地表明 $x$ 被绑定在 $a_2$ 内，而不是 $a_1$。

我们常用 $~x$ 表示一组有限个不同的变量 $x_1, \dots, x_n$，并写作 $~x.a$ 来表示 $x_1, \dots, x_n.a$。

### ---------------------------

### 1.2 抽象绑定树 (Abstract Binding Trees) 之扩展元数 (Extended Arity)

为了处理**绑定**(binding)，操作符的**元数**(arity)被推广为由一系列**形式**(valences)组成的有限序列。序列的长度决定参数的数量，每个形式决定了参数的**类型**(sort)以及在参数中绑定的变量的数量和类型。

#### 操作符的扩展元数 (Generalized Arity of Operators)

如果一个形式的结构为 $(s_1, \dots, s_k)s$，则表示参数的类型为 $s$，并在该参数内绑定了 $k$ 个变量，这些变量的类型分别为 $s_1, \dots, s_k$。我们用 $\sim s$ 表示有限序列 $s_1, \dots, s_n$，如果序列 $\sim x$ 的元素类型与序列 $\sim s$ 对应，则称 $\sim x$ 的类型为 $\sim s$。

例如，操作符 `let` 的元数可以表示为 $(\text{Exp}, (\text{Exp})\text{Exp})$，这意味着它有两个参数，分别是：
1. 第一个参数的类型为 Exp，并且不绑定任何变量。
2. 第二个参数的类型为 Exp，并且绑定一个 Exp 类型的变量。

因此，表达式 `let x be 2 + 2 in x * x` 对应的抽象绑定树 (ABT) 表示为：
$$
\text{let}(\text{plus(num[2]; num[2]); x.times(x; x)})
$$

#### 抽象绑定树的定义 (Definition of Abstract Binding Trees)

设 $O$ 为带有元数 $ar(o)$ 的类型索引操作符族，$X$ 为变量的类型索引族，定义 $B[X]$ 为带有绑定的抽象绑定树族，其定义类似于抽象语法树 $A[X]$，但不同之处在于每个参数中的活动变量集合根据绑定的变量而变化。

初步定义如下：

1. 如果 $x \in X_s$，则 $x \in B[X]_s$。
2. 如果 $ar(o) = ((\sim s_1)s_1, \dots, (\sim s_n)s_n)$，且对于每个 $1 \leq i \leq n$，$\sim x_i$ 的类型为 $\sim s_i$ 且 $a_i \in B[X, \sim x_i]_{s_i}$，则 $o(\sim x_1.a_1; \dots; \sim x_n.a_n) \in B[X]_s$。

这意味着，绑定的变量被加入到每个参数中的活动变量集合中，变量的类型由操作符的形式决定。

#### 绑定变量冲突与重命名 (Handling Bound Variable Conflicts and Renaming)

然而，上述定义并没有完全处理绑定变量的行为问题。例如，形式为 `let(a1; x.let(a2; x.a3))` 的 ABT 按照上述定义是不合法的，因为第一个 `let` 会将 $x$ 加入到 $X$ 中，这意味着第二个 `let` 无法再次将 $x$ 加入到 $X$ 中而不会引起冲突。

**解决方案**是确保每个参数在选择绑定变量名时都能合法生成树结构。为了解决这个问题，我们需要引入**重命名**(renaming)的机制。

改进后的定义如下：

如果 $ar(o) = ((\sim s_1)s_1, \dots, (\sim s_n)s_n)$，且对于每个 $1 \leq i \leq n$，存在重命名 $\pi_i: \sim x_i \leftrightarrow \sim x'_i$，其中 $\sim x'_i \in X'$，使得 $\pi_i \cdot a_i \in B[X, \sim x'_i]$，则 $o(\sim x_1.a_1; \dots; \sim x_n.a_n) \in B[X]_s$。

**重命名**的作用是确保当我们遇到嵌套绑定时避免变量名的冲突，这被称为**绑定的新鲜条件**(freshness condition on binders)，它确保所有绑定变量在其上下文中是“新鲜的”，即不与外部绑定的变量重名。

#### 重命名的作用 (Role of Renaming)

重命名 $\pi$ 在抽象绑定树中的作用是显式地替换每个出现的变量 $x$ 为 $\pi(x)$，包括抽象器中的变量列表及其主体内部的每次使用。这确保了在嵌套的绑定情况下，所有的绑定都是合法的，并且不会出现变量名称冲突。



### ------------------------------------



### 结构归纳法扩展到抽象绑定树 (Structural Induction for Abstract Binding Trees)

结构归纳法的原理可以扩展到抽象绑定树 (ABT)，称为**模重命名的结构归纳法**(structural induction modulo renaming)。要证明 $P(a)[X]$ 对于所有 $a \in B[X]$ 成立，通常只需要证明以下两点：

1. 若 $x \in X_s$，则 $P[X]_s(x)$ 成立。
2. 对于任意类型为 $s$ 的操作符 $o$ 和其元数 $((\sim s_1)s_1, \dots, (\sim s_n)s_n)$，若对每个 $1 \leq i \leq n$，存在重命名 $\pi_i: \sim x_i \leftrightarrow \sim x'_i$，使得对于所有 $i$，有 $P[X, \sim x'_i]_{s_i}(\pi_i \cdot a_i)$ 成立，那么 $P[X]_s(o(\sim x_1.a_1; \dots; \sim x_n.a_n))$ 成立。

第二个条件中的重命名确保了归纳假设对于所有**新鲜**(fresh)的绑定变量名的选择都成立，而不仅仅是 ABT 中给定的那些绑定名。

#### 自由变量的定义 (Free Variables)

定义 $x \in a$ 表示 $x$ 是 $a \in B[X, x]$ 中的自由变量(free variable)，即 $x$ 在 $a$ 中不是局部绑定的，意味着 $x$ 被绑定在 $a$ 之外的某个地方。如果 $x$ 在 $a$ 中被绑定，那么这些 $x$ 的使用与外部绑定的 $x$ 是不同的。

**定义**：
1. $x \in x$，即 $x$ 是它自身的自由变量。
2. 如果存在 $1 \leq i \leq n$，对于所有新鲜的重命名 $\pi: \sim x_i \leftrightarrow \sim z_i$，有 $x \in \pi \cdot a_i$，则 $x \in o(\sim x_1.a_1; \dots; \sim x_n.a_n)$。

第一个条件表明 $x$ 是它自身的自由变量，但不是其他变量的自由变量。第二个条件表明，如果 $x$ 是某个参数中的自由变量，并且在该参数中的绑定变量名选择是独立的，那么 $x$ 是整个 ABT 的自由变量。这也意味着，例如在 `let(zero; x.x)` 中，$x$ 不是自由变量。

#### α-等价 (α-Equivalence)

**α-等价**(α-equivalence)的关系（出于历史原因得名）表示两个 ABT 在绑定变量名的选择上是相同的。α-等价是包含以下两个条件的最强的同余关系(congruence)：

1. $x =_\alpha x$。
2. 如果对于每个 $1 \leq i \leq n$，有 $\pi_i \cdot a_i =_\alpha \pi'_i \cdot a'_i$ 对所有新鲜的重命名 $\pi_i: \sim x_i \leftrightarrow \sim z_i$ 和 $\pi'_i: \sim x'_i \leftrightarrow \sim z_i$ 成立，则 $o(\sim x_1.a_1; \dots; \sim x_n.a_n) =_\alpha o(\sim x'_1.a'_1; \dots; \sim x'_n.a'_n)$。

这个定义的关键思想是重命名 $\sim x_i$ 和 $\sim x'_i$ 一致，避免混淆，并检查 $a_i$ 和 $a'_i$ 是否 α-等价。如果 $a =_\alpha b$，那么我们称 $a$ 和 $b$ 是彼此的 α-变体 (α-variants)。

#### 替换 (Substitution)

在某个 ABT 中将 $b$ 替换为自由变量 $x$ 的过程（记作 $[b/x]a$）的定义如下：

1. $[b/x]x = b$，且若 $x \neq y$，则 $[b/x]y = y$。
2. $[b/x]o(\sim x_1.a_1; \dots; \sim x_n.a_n) = o(\sim x_1.a'_1; \dots; \sim x_n.a'_n)$，其中对于每个 $1 \leq i \leq n$，如果 $x \notin \sim x_i$，则 $a'_i = [b/x]a_i$，否则 $a'_i = a_i$。

第二个条件表明，如果 $x$ 在某个操作符的参数中被绑定，那么替换过程不会进入该参数的作用域，因为这样做会混淆两个不同的变量。因此，我们在定义 $a'_i$ 时必须考虑 $x$ 是否在 $\sim x_i$ 中。我们还需要确保 $\sim x_i \notin b$，以避免捕获(capture)，即 $b$ 中的自由变量被误认为是绑定变量。

#### 捕获避免 (Capture Avoidance)

在替换时，如果 $b$ 中的某些变量是自由的，那么替换可能导致捕获。例如，$[b/x]a_i$ 中包含 $b$ 的自由变量，如果将其形式化为 $\sim x_i.[b/x]a_i$，则这些自由变量可能被绑定为 $\sim x_i$ 的某个元素，从而改变它们的引用。为避免这种捕获，我们需要确保替换中的绑定变量是“新鲜”的。

#### 通过结构归纳法的解决方案 (Solution via Structural Induction)

通过结构归纳法，我们可以归纳地证明，对于任何重命名 $\pi_i: \sim x_i \leftrightarrow \sim x'_i$，只要 $\sim x'_i$ 是新鲜的，替换 $[b/x](\pi_i \cdot a_i)$ 是良定义的。因此，我们可以定义：
$$
[b/x]o(\sim x_1.a_1; \dots; \sim x_n.a_n) = o(\sim x'_1.[b/x](\pi_1 \cdot a_1); \dots; \sim x'_n.[b/x](\pi_n \cdot a_n))
$$
其中 $\sim x'_i$ 是新鲜的绑定变量名。

我们可以通过选择 α-等价的目标 ABT 来避免未定义的替换，在这个等价类中，替换过程不会导致捕获。因此，替换过程可以在 ABT 的 α-等价类上完全定义。

#### α-等价类上的操作 (Operations on α-Equivalence Classes)

为了简化绑定操作的繁琐过程，本书采用以下约定：

**抽象绑定树总是按 α-等价进行识别**，即我们隐式地处理的是 ABT 的 α-等价类，而不是具体的 ABT 本身。所有对 ABT 的操作和关系都要尊重 α-等价，并在 α-等价类上正确定义。

#### 参数绑定 (Binding Parameters)

不仅变量可以在操作符的参数中绑定，参数也可以。在参数声明中，参数被引入为“新鲜”的，在绑定的作用域中可以使用这些参数来构造进一步的 ABT。

为允许参数声明，参数的形式可以推广为 $(\sim s_1; \sim s_2)s$，其中 $\sim s_1$ 指定了参数的类型，$\sim s_2$ 指定了变量的类型。使用这些参数 $U$ 和变量 $X$ 的操作符集合决定了类型索引族 $B[U; X]$ 中的 ABT。

我们使用命名约定来区分**参数**(parameters)和**变量**(variables)，通常用 $u$ 和 $v$ 表示参数，用 $x$ 和 $y$ 表示变量。

### 1.3 备注 (Notes)

抽象语法的概念源自**丘奇**(Church)、**图灵**(Turing)和**哥德尔**(Gödel)的开创性工作，他们最早探讨了编写能够操作程序表示的程序的可能性。最初，程序通过自然数表示，使用编码方式，这些编码基于素数分解定理，现在被称为**哥德尔编码**(Gödel-numbering)。关于这些表示的详细介绍可以在任何标准的数理逻辑书籍中找到，如 Kleene 的著作 (1952)。

**Lisp 语言**(McCarthy, 1965; Allen, 1978) 引入了一种更加实用且直接的语法表示方式，即**符号表达式**(symbolic expressions)。这些思想后来在 **ML 语言**(Gordon et al., 1979) 中得到了进一步发展，ML 具有一种能够表达抽象语法树的类型系统。

**AUTOMATH 项目**(Nederpelt et al., 1994) 引入了使用**丘奇 λ 记法**(Church’s λ notation, 1941) 来处理变量的绑定和作用域的思想。这些思想在 **LF** (Logical Framework) 语言 (Harper et al., 1993) 中得到了进一步的发展。

---

这些历史背景表明了抽象语法的起源以及其在不同编程语言中的应用和演变。

### --------------------------

### 1.3 备注 (Notes) 详细讲解

#### 抽象语法的起源 (Origins of Abstract Syntax)

抽象语法的概念最早可以追溯到 **阿隆佐·丘奇**(Alonzo Church)、**艾伦·图灵**(Alan Turing) 和 **库尔特·哥德尔**(Kurt Gödel) 的工作，他们最早探讨了编写能够操作**程序表示**(representation of programs)的程序的可能性。这个想法具有革命性，因为它开始研究程序如何不仅仅是静态的描述，而是可以用来处理和操作其他程序。这一概念后来发展为所谓的**元编程**(metaprogramming)，即编写能够生成、操作、分析或转换其他程序的程序。

#### 哥德尔编码与自然数表示 (Gödel Numbering and Natural Numbers Representation)

在哥德尔的编码方法中，程序被用自然数表示。这种编码方式基于**素数分解定理**(prime factorization theorem)，其中每个程序的表示形式可以被映射为一个自然数，利用素数的唯一分解性质来编码复杂的结构。例如，程序中的每个元素都可以与一个素数相关联，然后通过这些素数的乘积来唯一标识该程序。这种编码方式被称为**哥德尔编号**(Gödel-numbering)。

虽然这种方法在理论上是有效的，但它并不实际，因为直接用自然数来表示复杂的程序非常笨拙，也不直观。然而，它为逻辑编程和程序的自动化处理奠定了理论基础，并在数理逻辑中发挥了重要作用。经典的数理逻辑书籍（如 **Kleene** 在 1952 年的著作）中对此有详细的论述。

#### Lisp 语言和符号表达式 (Lisp and Symbolic Expressions)

**Lisp 语言** 由 **约翰·麦卡锡**(John McCarthy) 在 1965 年引入，随后在 **Allen** (1978) 的工作中得到了进一步发展。Lisp 语言的引入标志着抽象语法的一个重大进步，它提供了一种更加**实用**且**直接**的方式来表示程序语法，称为**符号表达式**(symbolic expressions)。在 Lisp 中，程序的语法结构不仅被表示为符号的集合，而且这些符号的结构可以直接操作和解释。这种表示方式极大地简化了对程序语法的处理，使得编写能够操作自身结构的程序变得更加实际和有效。

符号表达式的引入使得 Lisp 具备了非常强大的元编程能力，使得程序能够直接操作其自身的结构，而无需像哥德尔编码那样借助自然数。这种机制也是 Lisp 语言在人工智能和自动推理系统中的广泛应用的关键之一。

#### ML 语言与抽象语法树 (ML and Abstract Syntax Trees)

**ML 语言** (MetaLanguage) 于 1979 年由 **Gordon** 等人发展，是另一种重要的编程语言，它引入了一个能够表示抽象语法树 (Abstract Syntax Trees, AST) 的**类型系统**。在 ML 中，程序不仅仅被看作符号的集合，而是被看作由树状结构组成的，树的节点表示操作符，叶子表示变量或常量。这种结构被称为**抽象语法树**(AST)。

ML 语言的这种抽象表示允许开发者更容易地处理程序的结构，尤其是元编程和编译器设计中的结构操作。例如，编译器的前端可以用抽象语法树来解析源代码，通过操作 AST 可以实现优化、类型检查以及代码生成。ML 的类型系统进一步增强了这种表示的安全性，保证了抽象语法树的结构在语法层面上是合法的。

#### AUTOMATH 项目与 λ 记法 (AUTOMATH and λ-Notation)

**AUTOMATH 项目** 是由 **Nederpelt** 等人于 1994 年引入的。AUTOMATH 发展了**阿隆佐·丘奇的 λ 记法**(Church’s λ-notation)，为变量的**绑定**(binding)和**作用域**(scope)提供了一种机制。在 λ-记法中，函数被看作绑定变量的表达式，变量可以在函数的作用域内使用。AUTOMATH 项目将这种 λ-记法扩展到了程序语法的表示，尤其是处理那些涉及复杂绑定和作用域的情况。

λ-记法提供了一种形式化的方法来处理变量的引入、作用域的界定和绑定，从而避免了常见的命名冲突和变量覆盖问题。AUTOMATH 项目利用这种 λ-记法，推动了形式化系统的发展，特别是在逻辑和数学证明领域中，这种方式得到了广泛应用。

#### LF 语言与抽象语法的进一步发展 (LF and Further Developments in Abstract Syntax)

这些思想在 **LF (Logical Framework)** 语言 (Harper 等人, 1993) 中得到了进一步发展。LF 是一种逻辑框架语言，它提供了一个通用的框架，用于定义各种形式化系统，包括编程语言的语法、类型系统和推理规则。在 LF 中，抽象语法被表示为 λ-抽象的形式，从而可以轻松处理涉及复杂绑定的逻辑系统和编程语言。

LF 的发展使得抽象语法的表示更加**精确**和**可扩展**，它能够处理多种不同的逻辑系统，特别是在涉及绑定和作用域的情况下，LF 提供了比之前方法更为灵活的解决方案。LF 对编程语言设计、形式化验证以及逻辑推理的贡献至关重要。

#### 总结

- **抽象语法**起源于哥德尔等人的工作，通过哥德尔编码用自然数表示程序，但这种方法过于笨拙。
- **Lisp 语言**引入了符号表达式，使得程序表示更加直接和实用，推动了元编程的发展。
- **ML 语言**通过类型系统支持抽象语法树，提供了程序结构的更强大的表示和操作能力。
- **AUTOMATH 项目**利用 λ-记法处理变量绑定和作用域的问题，这在逻辑和编程语言设计中起到了重要作用。
- **LF 语言**进一步发展了这些思想，使抽象语法的表示和处理更加精确和灵活，广泛应用于形式化系统的定义与验证。

这些发展展示了抽象语法在编程语言理论和形式化系统中的重要地位，并且这些概念至今仍在影响着现代编程语言设计和逻辑推理系统。
















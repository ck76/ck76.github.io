[toc]



### 28.1 **Exceptions 概述** (Exceptions Overview)

在编程语言中，**异常 (Exceptions)** 提供了一种非本地的控制转移机制，从抛出异常的地方直接转移到一个合适的异常处理程序。这种转移打断了程序的正常执行流程，通常是为了响应某种**异常条件 (exceptional condition)**，如错误信号或特殊情况。这些情况在正常情况下可能不常见，但当它们发生时，需要对其进行特殊处理。

例如：
- **错误处理 (Error Handling)**：在发生计算错误或某些非法操作时，程序可以抛出异常，而不是通过检查每个操作的结果来判断是否出错。
- **稀有条件处理 (Rare Condition Handling)**：一些特殊的、稀有的条件发生时可以通过异常机制直接跳转到对应的处理逻辑，而无需在每一步进行显式判断。

### 1. **异常与条件判断的对比 (Exceptions vs Conditionals)**

虽然我们可以使用条件语句（如 `if-else` 语句）来检测并处理错误或异常情况，但使用异常往往更加方便。通过异常，程序可以直接、快速地将控制转移给合适的处理器，而无需在多个步骤中不断地检查条件。特别是当异常发生在深层嵌套的函数调用中时，异常机制能够使程序跳过多个调用栈帧，直接跳到异常处理程序。

例如，在嵌套的函数调用过程中，假设某个深层函数遇到了异常条件，通过**异常机制**，可以直接从该函数跳出，而不用逐步返回每一层函数的调用者。

### 2. **异常的使用场景 (Use Cases for Exceptions)**

   **错误信号 (Error Signals)**：异常可以用来处理程序中的错误。例如，当程序中出现未定义的行为或不合法的输入时，直接抛出异常，而不是让程序继续运行并产生错误结果。

   **资源管理 (Resource Management)**：在资源密集型操作（如文件读写、网络连接等）中，资源分配失败时可通过异常机制进行资源清理和回收。

   **中断执行 (Interrupt Execution)**：有时，程序在特定情况下需要打断当前流程，如用户手动取消了操作，异常可以有效实现这种中断。

### 3. **异常处理机制 (Exception Handling Mechanism)**

**异常处理器 (Exception Handlers)** 是专门设计用于捕获和处理异常的程序块。异常处理的关键机制包括：

1. **抛出异常 (Raising an Exception)**: 当某种不正常的条件出现时，程序通过 `raise` 或 `throw` 语句抛出异常，并中止当前的计算。
   
2. **捕获异常 (Catching an Exception)**: 异常一旦抛出，控制流会寻找最近的**异常处理器**。处理器可以通过 `try-catch` 或 `try-except` 结构来定义。当找到匹配的异常处理器时，控制流会跳转到该处理器继续执行。

3. **中断控制流 (Interrupting Control Flow)**: 一旦异常被抛出，正常的控制流就被中断，直到找到合适的异常处理器为止。这个跳转过程不依赖于显式的函数调用返回，而是通过异常机制自动完成。

### 4. **异常类型 (Exception Types)**

在多数语言中，异常是有**类型**的，这意味着不同的异常可以用来表示不同种类的错误或特殊情况。每种类型的异常可能由不同的处理器捕获和处理。通过定义不同类型的异常，我们可以更灵活地应对不同种类的错误。

例如：
- `IOException`: 表示输入输出错误。
- `NullPointerException`: 访问空指针时产生的错误。

### 5. **封装异常 (Encapsulation of Exceptions)**

异常还可以**封装**，意味着我们可以将异常作为对象传递给处理器，使得处理器可以对其进行更详细的检查和处理。这种封装机制允许处理器基于异常对象的类型和属性进行更复杂的错误处理逻辑。

#### 总结：
异常提供了一种非本地的控制流管理方式，通过直接跳转到异常处理器，它简化了错误处理的复杂性，尤其是在多层嵌套调用的情况下。同时，异常通过类型系统提供了灵活的处理方式，使得程序能够应对各种不同的错误和特殊情况。

### ---------------------------------

### 28.1 Failures (失败机制)

**Failures** (失败) 是一种控制机制，允许计算在遇到某种条件时停止并不返回任何值。失败可以通过处理器 (handler) 捕获，捕获失败会中断正常的程序流，并将控制权转移到相应的处理器，这样处理器可以将失败转换为成功（除非处理器本身也失败）。

### 1. 语法
Failures 的语法可以用以下 BNF 表示：
$$
\text{Exp} \ e ::= \ \text{fail} \ \mid \ \text{catch}(e_1; e_2)
$$
- `fail` 表示当前计算失败。
- `catch(e_1; e_2)` 表示在表达式 $e_1$ 中发生失败时，执行表达式 $e_2$。

### 2. 静态语义
失败的静态语义比较直接：
1. 任何失败表达式都可以拥有任意类型，因为失败不会返回任何值。
2. `catch` 表达式中的两个子表达式 $e_1$ 和 $e_2$ 必须具有相同的类型，因为失败和成功的结果都可能决定最终表达式的值。

推导规则如下：
$$
\frac{}{\Gamma \vdash \text{fail} : \tau} \quad (28.1a)
$$
$$
\frac{\Gamma \vdash e_1 : \tau \quad \Gamma \vdash e_2 : \tau}{\Gamma \vdash \text{catch}(e_1; e_2) : \tau} \quad (28.1b)
$$
解释：
- 在规则 $(28.1a)$ 中，无论上下文环境 $\Gamma$ 为何，失败的表达式 `fail` 可以具有任何类型 $\tau$。
- 在规则 $(28.1b)$ 中，表达式 `catch(e_1; e_2)` 的类型由 $e_1$ 和 $e_2$ 的共同类型 $\tau$ 决定，因为 $e_1$ 的失败可能导致 $e_2$ 的执行。

### 3. 动态语义
在动态语义中，失败通过一种叫做 **栈展开** (stack unwinding) 的机制来实现。当执行 `catch(e_1; e_2)` 时，会在控制栈中安装一个处理器 (handler)，当执行失败时，控制栈将逐帧展开，直到找到处理器。找到处理器后，将控制权转交给该处理器。

为了定义这一动态过程，我们引入了以下的 **控制栈** (control stack) 规则：
1. 栈包含两种状态：
   - $k . e$ 表示在栈 $k$ 上评估表达式 $e$。
   - $k / e$ 表示将值 $e$ 返回给栈 $k$。
2. 我们增加了一种新的状态形式 $k J$，用于将失败传递给栈中最近的处理器。

#### 4. 扩展的转换规则
失败机制引入了新的控制栈框架及其转换规则：
1. 当遇到 `fail` 时，直接传递失败：
   $$
   k . \text{fail} \rightarrow k J \quad (28.2a)
   $$

2. 在 `catch(e_1; e_2)` 中，首先将处理器推入栈中并评估 $e_1$：
   $$
   k . \text{catch}(e_1; e_2) \rightarrow k; \text{catch}(−; e_2) . e_1 \quad (28.2b)
   $$

3. 如果 $e_1$ 的评估得到值 $v$，那么将该值直接返回到控制栈上：
   $$
   k; \text{catch}(−; e_2) / v \rightarrow k / v \quad (28.2c)
   $$

4. 如果 $e_1$ 失败，则执行处理器中的 $e_2$：
   $$
   k; \text{catch}(−; e_2) J \rightarrow k . e_2 \quad (28.2d)
   $$

5. 失败会通过普通帧向上传播，直到找到合适的处理器：
   $$
   k; f J \rightarrow k J \quad (28.2e)
   $$

#### 5. 栈的终态定义
为了处理失败，我们需要扩展之前的栈终态定义：
1. 正常的值结果：
   $$
   e \ \text{val} \quad e / e \ \text{final} \quad (28.3a)
   $$

2. 失败状态的终态：
   $$
   e J \ \text{final} \quad (28.3b)
   $$

这意味着，如果整个程序都没有处理该失败，则程序的终态是一个失败。

#### 6. 安全性 (Safety)
安全性定理在引入了失败机制后得到了适当的调整：
1. **类型保持性**：如果栈状态 $s$ 是合法的，并且 $s$ 能够转换为 $s'$，那么 $s'$ 也是合法的。
2. **进展**：如果栈状态 $s$ 是合法的，那么要么 $s$ 是终态，要么 $s$ 可以进行进一步的计算或引发失败。

总结：
失败 (Failures) 是一种控制结构，用于在程序遇到错误或特定条件时中断正常的执行流，并将控制权传递给处理器。通过栈展开和处理器的动态插入，程序能够灵活处理异常情况。

### ---------------------------------

### 28.1 Failures (失败机制)

**Failures** (失败) 是一种控制机制，允许在遇到某种异常或条件时停止程序的正常执行，并将控制转移到处理器 (handler)。这个机制通过不返回任何值来中断程序流，并通过处理器将失败转换为成功（除非处理器本身也失败）。Failures 使得程序可以处理特殊情况或错误而不需要显式地在代码中进行大量条件检查。

### 1. 语法

Failures 的语法可以用以下 BNF 表示：
$$
\text{Exp} \ e ::= \ \text{fail} \ \mid \ \text{catch}(e_1; e_2)
$$
- **fail** 表示当前计算失败。
- **catch(e_1; e_2)** 表示在表达式 $e_1$ 中发生失败时，执行表达式 $e_2$。

### 2. 静态语义

Failures 的静态语义比较简单：

1. **fail** 可以具有任何类型，因为它从不返回值。
2. **catch(e_1; e_2)** 中，两个表达式 $e_1$ 和 $e_2$ 必须具有相同的类型，因为失败与成功的结果都可能决定最终表达式的值。

推导规则如下：
$$
\frac{}{\Gamma \vdash \text{fail} : \tau} \quad (28.1a)
$$
$$
\frac{\Gamma \vdash e_1 : \tau \quad \Gamma \vdash e_2 : \tau}{\Gamma \vdash \text{catch}(e_1; e_2) : \tau} \quad (28.1b)
$$

解释：
- 在规则 $(28.1a)$ 中，无论上下文 $\Gamma$ 如何，表达式 **fail** 可以被赋予任意类型 $\tau$，因为失败的表达式不会返回任何值。
- 在规则 $(28.1b)$ 中，**catch(e_1; e_2)** 的类型由 $e_1$ 和 $e_2$ 的共同类型 $\tau$ 决定，因为 $e_1$ 的失败可能导致执行 $e_2$，而 $e_1$ 成功则直接返回其结果。

### 3. 动态语义

在动态语义中，失败通过 **栈展开** (stack unwinding) 实现。当执行 **catch(e_1; e_2)** 时，在控制栈中安装一个处理器。如果 **fail** 表达式被执行，控制栈会逐帧展开，直到找到最近的处理器，并将控制转交给该处理器。

为了定义这种动态行为，我们引入了以下的 **控制栈** (control stack) 规则：

- 栈包含两种状态：
  - $k . e$ 表示在栈 $k$ 上评估表达式 $e$。
  - $k / e$ 表示将值 $e$ 返回给栈 $k$。
- 增加一种新的状态 $k J$，用于将失败向上传递到栈中最近的处理器。

#### 扩展的转换规则

Failure 机制引入了一些新的控制栈框架及其转换规则：

1. 遇到 **fail** 时，直接将失败传递到栈上：
   $$
   k . \text{fail} \rightarrow k J \quad (28.2a)
   $$

2. 在 **catch(e_1; e_2)** 中，首先将处理器推入栈中并评估 $e_1$：
   $$
   k . \text{catch}(e_1; e_2) \rightarrow k; \text{catch}(−; e_2) . e_1 \quad (28.2b)
   $$

3. 如果 $e_1$ 的评估成功并得到值 $v$，则处理器被移除，继续返回值 $v$：
   $$
   k; \text{catch}(−; e_2) / v \rightarrow k / v \quad (28.2c)
   $$

4. 如果 $e_1$ 的评估失败，则执行处理器中的 $e_2$：
   $$
   k; \text{catch}(−; e_2) J \rightarrow k . e_2 \quad (28.2d)
   $$

5. 当栈帧中不是处理器时，失败会逐帧向上传播：
   $$
   k; f J \rightarrow k J \quad (28.2e)
   $$

### 4. 栈的终态定义

为了处理失败，我们需要扩展之前的栈终态定义：
1. 正常返回值的终态：
   $$
   e \ \text{val} \quad e / e \ \text{final} \quad (28.3a)
   $$

2. 失败终态：
   $$
   e J \ \text{final} \quad (28.3b)
   $$

这意味着，如果整个程序都未处理失败，则程序会在传播到整个栈时进入失败终态。

### 5. 安全性

引入 Failure 后，我们需要重新定义 **安全性** (safety)。这里的安全性分为两部分：

1. **类型保持性**：如果栈状态 $s$ 是合法的，并且 $s \rightarrow s'$，那么 $s'$ 也是合法的。
2. **进展**：如果栈状态 $s$ 是合法的，要么 $s$ 是终态，要么 $s$ 可以进一步评估，或者信号失败。

推导式如下：
$$
\frac{s \text{ ok} \quad s \rightarrow s'}{s' \text{ ok}} \quad (28.1c)
$$
$$
\frac{s \text{ ok}}{s \text{ final} \ \vee \ \exists s', s \rightarrow s'} \quad (28.1d)
$$

总结：
Failure 是一种灵活的异常处理机制，允许通过栈展开来处理异常情况。在程序执行失败时，它能中断当前的计算，传递到处理器进行异常处理。这种机制不仅提升了程序的灵活性，还避免了显式的条件检查，从而简化了代码的编写。

### ---------------------------------

### 28.2 Exceptions (异常机制)

**Exceptions** (异常) 是对 **Failures** (失败) 的一种泛化，它允许与失败相关联的值传递给处理器。这种机制为处理器提供了关于异常的附加信息，从而使处理器能够根据异常的不同类型进行相应的处理。与失败不同，异常携带了一个值，该值可以用于传递更多的上下文信息，以便更灵活地应对异常。

### 1. 语法

异常的语法扩展了失败的机制，并且允许在异常发生时传递值：
$$
\text{Exp} \ e ::= \ \text{raise}[\tau](e) \ \mid \ \text{handle}(e_1; x.e_2)
$$
- **raise[τ](e)**：抛出异常并将表达式 $e$ 的结果作为异常值传递。
- **handle(e_1; x.e_2)**：尝试评估 $e_1$，如果在评估过程中发生异常，则捕获异常并执行处理器 $x.e_2$，其中 $x$ 是异常值的绑定变量。

### 2. 静态语义

在静态语义上，异常扩展了失败的类型系统，并引入了一个类型 $\tau_{exn}$，用于表示与异常相关联的值的类型。

#### 推导规则如下：

1. **raise[τ](e)** 表达式抛出异常值，异常本身可以有任意类型 $\tau$，因为它从不返回正常值：
$$
\frac{\Gamma \vdash e : \tau_{exn}}{\Gamma \vdash \text{raise}[\tau](e) : \tau} \quad (28.4a)
$$

2. **handle(e_1; x.e_2)** 中，如果 $e_1$ 的评估过程中发生异常，则 $x$ 绑定到异常值，并且处理器 $e_2$ 必须返回与 $e_1$ 相同类型的结果：
$$
\frac{\Gamma \vdash e_1 : \tau \quad \Gamma, x : \tau_{exn} \vdash e_2 : \tau}{\Gamma \vdash \text{handle}(e_1; x.e_2) : \tau} \quad (28.4b)
$$

### 3. 动态语义

异常的动态语义是对失败机制的扩展。我们通过引入携带异常值的异常状态 $k J e$ 来传递异常，并将异常值与控制流一同传递。

#### 规则如下：

1. **raise[τ](e)** 表达式首先评估其参数 $e$，然后将结果作为异常值传递：
   $$
   k . \text{raise}[\tau](e) \rightarrow k;\text{raise}[\tau](−) . e \quad (28.5a)
   $$

2. 如果 $e$ 的值已经被评估出来，则将异常状态传递给栈：
   $$
   k;\text{raise}[\tau](−) / e \rightarrow k J e \quad (28.5b)
   $$

3. 异常继续沿着栈传播：
   $$
   k;\text{raise}[\tau](−) J e \rightarrow k J e \quad (28.5c)
   $$

4. **handle(e_1; x.e_2)** 首先在栈中压入一个处理器框架并评估 $e_1$：
   $$
   k . \text{handle}(e_1; x.e_2) \rightarrow k;\text{handle}(−; x.e_2) . e_1 \quad (28.5d)
   $$

5. 如果 $e_1$ 评估成功，处理器被移除，继续返回值：
   $$
   k;\text{handle}(−; x.e_2) / e \rightarrow k / e \quad (28.5e)
   $$

6. 如果 $e_1$ 评估失败并抛出异常，则执行处理器 $e_2$，并将异常值 $e$ 绑定到变量 $x$：
   $$
   k;\text{handle}(−; x.e_2) J e \rightarrow k . [e/x]e_2 \quad (28.5f)
   $$

7. 如果栈帧不是处理器，异常继续向上传递：
   $$
   (f \neq \text{handle}(−; x.e_2)) \quad k; f J e \rightarrow k J e \quad (28.5g)
   $$

### 4. 栈的扩展

异常的引入要求我们将栈扩展到包含异常处理器框架，如 **handle(−; x.e_2)**。当异常传播到处理器时，处理器会捕获异常并执行相应的代码。如果处理器不匹配，异常继续向上传递，直到被捕获或传播到整个栈。

### 5. 安全性

与失败机制类似，异常机制的安全性也可以通过类型系统来保证。我们可以扩展之前的安全性定理，保证异常传播和处理的过程中，程序的类型一致性保持不变。

总结：
异常机制通过传递异常值，使得程序可以根据异常类型进行更加灵活的处理。通过扩展栈和引入异常状态，异常可以沿着栈传播，直到找到适合的处理器。

### ---------------------------------

### 28.3 Exception Type (异常类型)

异常类型系统的静态语义通过一个特定的异常值类型 $\tau_{exn}$ 来进行参数化。这里的关键在于 $\tau_{exn}$ 必须是程序中所有异常共用的一个类型，这样才能确保异常处理器能够在处理异常时，保证类型安全，不会因为类型的不同而发生错误。下面我们详细解析异常类型选择的不同方案以及其适用性。

### 1. 异常类型的选择
#### 1.1 字符串类型 (String Type)
一种非常简单的选择是将 $\tau_{exn}$ 定义为字符串类型 `str`，这样每个异常都可以携带一个描述性的字符串，解释错误的原因。比如：
$$
\text{raise} \ "Division \ by \ zero \ error."
$$
这个表达式表示抛出一个 "除零错误" 的异常。虽然这种方法简单，但它的问题在于，异常处理器需要对字符串进行解析才能区分不同的异常来源，这显然是不切实际的，因为字符串解析存在大量的不可控因素，极易导致错误。

#### 1.2 整数类型 (Natural Numbers)
另一种常见的方法是将 $\tau_{exn}$ 设为自然数类型 `nat`，这种方案类似于操作系统中的错误码机制。例如，Unix 系统中，错误码用整数表示不同的错误情况。异常处理器可以根据数值来区分不同的异常并做出相应的处理。但是，这种方案的问题在于需要全局统一的错误码系统，这不仅增加了开发和维护的复杂度，还不利于模块化开发和重用。

#### 1.3 代数数据类型 (Sum Type)
为了使异常类型能够携带更多有用的信息，我们可以将 $\tau_{exn}$ 设计为一个代数数据类型（Sum Type）。这种类型可以包含不同类别的异常，每个类别可以携带与异常相关的特定数据。例如：
$$
\tau_{exn} = [\text{div} \rightarrow \text{unit}, \text{fnf} \rightarrow \text{string}, \dots]
$$
- 类别 **div** 代表除法错误，不携带数据（类型为 `unit`）。
- 类别 **fnf** 代表 "文件未找到" 错误，并携带与文件名相关的数据（类型为 `string`）。

在这种方案下，异常处理器可以轻松区分不同的异常类型并提取与异常相关的数据信息。例如：
$$
\text{try} \ e_1 \ \text{ow} \ x \Rightarrow
\begin{cases}
\text{div} \ \langle \rangle \Rightarrow e_{div}, \\
\text{fnf} \ s \Rightarrow e_{fnf}
\end{cases}
$$
这个表达式通过模式匹配来处理不同的异常情况，根据不同的异常类型执行不同的分支。

### 2. 动态分类异常类型 (Dynamic Classification)
上述的代数数据类型虽然能够携带丰富的异常信息，但是它要求在程序的设计阶段就定义所有可能的异常类型，这对模块化开发带来了限制。在大型系统中，各个模块可能会引入各自的异常类型，要求这些模块事先约定异常类型不利于模块的独立性和可扩展性。

一种更好的方法是采用 **动态分类** 的方式。动态分类允许在运行时生成新的异常类型，这样各个模块可以在执行时生成自己的异常类型，而不需要和其他模块进行协调。例如，初始化一个模块时可以动态生成新的异常类，并确保这些类与其他模块的异常类型不冲突。

### 总结
异常类型的选择影响到异常的灵活性和模块化开发的能力。从简单的字符串、自然数到代数数据类型，每种方法都有其优缺点。而通过动态分类，我们可以在运行时为不同模块生成各自独立的异常类型，这使得异常处理更加灵活，尤其适用于大型模块化系统。

### ---------------------------------

### 28.4 Encapsulation of Exceptions (异常的封装)

在程序中，我们有时需要区分哪些表达式可能会失败或抛出异常，哪些则不会。这样的表达式被称为**易错表达式**（fallible expression）或**异常表达式**（exceptional expression），而那些不可能失败或抛出异常的表达式被称为**不易错表达式**（infallible expression）。这种区分对于控制程序的执行顺序和逻辑至关重要，因为对于不易错表达式，它们的求值顺序不会影响最终的计算结果；但是对于易错表达式，求值顺序可能会直接影响计算的结果。

### 1. 易错性与不易错性（Fallibility vs. Infallibility）

在形式化这种区分时，我们引入了**易错模式**（fallible mode）和**不易错模式**（infallible mode），并通过一种称为**模态**（modality）的机制对易错表达式进行分类。这些模态区分了一个类型是否包含可能会失败或抛出异常的表达式。

#### 类型语法：
$$
\tau ::= \text{fallible}(\tau)
$$
- **fallible(τ)**：表示类型为 $\tau$ 的易错表达式，即可能会抛出异常或失败。
  

这意味着类型 $\tau$ 的易错表达式可以在求值时失败，而其结果类型仍然是 $\tau$。对于表达式，可能是一个失败的操作，也可能是一个成功的操作。

#### 表达式语法：
$$
\text{Fall} \ f ::= \text{fail} \mid \text{ok}(e) \mid \text{try}(e; x.f_1; f_2)
$$
- **fail**：表示一个失败的操作。
- **ok(e)**：表示一个成功的操作，其中 $e$ 是一个不易错的表达式。
- **try(e; x.f_1; f_2)**：表示一种错误处理机制，其中 $e$ 是一个表达式，如果 $e$ 成功，则将其结果绑定到变量 $x$ 并执行 $f_1$；如果 $e$ 失败，则执行 $f_2$。

#### 不易错表达式：
$$
\text{Infall} \ e ::= x \mid \text{fall}(f) \mid \text{try}(e; x.e_1; e_2)
$$
- **fall(f)**：表示将一个易错表达式封装成不易错表达式。
- **try(e; x.e_1; e_2)**：表示处理可能抛出异常的表达式 $e$，如果 $e$ 成功，将结果绑定到变量 $x$ 并执行 $e_1$；如果 $e$ 失败，则执行 $e_2$。

### 2. 语义与类型规则

在这种表示下，类型系统允许我们精确区分**易错**和**不易错**的表达式。我们使用不同的类型推导规则来处理这两种情况。

#### 易错表达式的类型推导规则：
1. **规则 (28.6d)**：
   $$
   \frac{}{\Gamma \vdash \text{fail} \sim \tau}
   $$
   - 该规则表示**fail**可以有任何类型 $\tau$，因为失败的表达式不会返回具体的值。

2. **规则 (28.6e)**：
   $$
   \frac{\Gamma \vdash e : \tau}{\Gamma \vdash \text{ok}(e) \sim \tau}
   $$
   - 表示如果表达式 $e$ 是类型 $\tau$ 的不易错表达式，那么我们可以将 $e$ 封装为一个易错表达式 $\text{ok}(e)$，它表示 $e$ 在求值时不会失败。

3. **规则 (28.6f)**：
   $$
   \frac{\Gamma \vdash e : \text{fallible}(\tau) \quad \Gamma, x : \tau \vdash f_1 \sim \tau_0 \quad \Gamma \vdash f_2 \sim \tau_0}{\Gamma \vdash \text{try}(e; x.f_1; f_2) \sim \tau_0}
   $$
   - 该规则表示我们可以将 $e$（一个可能抛出异常的表达式）进行异常处理。如果 $e$ 成功，则执行 $f_1$，否则执行 $f_2$。

#### 不易错表达式的类型推导规则：
1. **规则 (28.6a)**：
   $$
   \frac{}{\Gamma, x : \tau \vdash x : \tau}
   $$
   - 该规则是变量的基本规则，表示 $x$ 拥有类型 $\tau$。

2. **规则 (28.6b)**：
   $$
   \frac{\Gamma \vdash f \sim \tau}{\Gamma \vdash \text{fall}(f) : \text{fallible}(\tau)}
   $$
   - 表示如果 $f$ 是类型为 $\tau$ 的易错表达式，那么 $\text{fall}(f)$ 是类型为 $\text{fallible}(\tau)$ 的不易错表达式（即封装了的易错表达式）。

3. **规则 (28.6c)**：
   $$
   \frac{\Gamma \vdash e : \text{fallible}(\tau) \quad \Gamma, x : \tau \vdash e_1 : \tau_0 \quad \Gamma \vdash e_2 : \tau_0}{\Gamma \vdash \text{try}(e; x.e_1; e_2) : \tau_0}
   $$
   - 该规则与易错表达式类似，但用于不易错表达式。它表示如果 $e$ 是一个封装了的易错表达式，$e_1$ 和 $e_2$ 都是类型 $\tau_0$ 的不易错表达式，则 $\text{try}(e; x.e_1; e_2)$ 是类型 $\tau_0$ 的不易错表达式。

### 3. 总结

在这部分中，我们介绍了异常的封装机制，通过类型系统，我们能够精确地区分易错和不易错表达式，并通过规则来确保异常处理的正确性。

### ---------------------------------

### 详细解析 28.4 Encapsulation of Exceptions 中的公式

在本节中，我们定义了异常封装的机制，区分**易错表达式** (fallible expression) 和**不易错表达式** (infallible expression)，并使用**模态** (modality) 来管理这两者之间的转换。我们还定义了处理异常的规则，并描述了这些表达式在不同上下文中如何进行求值。

---

#### 规则 (28.6d)
$$
\frac{}{\Gamma \vdash \text{fail} \sim \tau}
$$
这条规则表示 **fail** 可以具有任何类型 $\tau$。由于失败操作不会产生具体的结果，因此其类型可以是任意的。形式上，$\text{fail}$ 可以适用于任何类型的上下文，这反映了失败操作永远不会返回有效的结果。

#### 规则 (28.6e)
$$
\frac{\Gamma \vdash e : \tau}{\Gamma \vdash \text{ok}(e) \sim \tau}
$$
该规则表示，如果表达式 $e$ 是类型 $\tau$ 的不易错表达式，则 $\text{ok}(e)$ 是类型为 $\tau$ 的易错表达式。这意味着我们将一个不易错表达式封装为一个“看起来”可能会失败的易错表达式，尽管它实际上不会失败。

#### 规则 (28.6f)
$$
\frac{\Gamma \vdash e : \text{fallible}(\tau) \quad \Gamma, x : \tau \vdash f_1 \sim \tau_0 \quad \Gamma \vdash f_2 \sim \tau_0}{\Gamma \vdash \text{try}(e; x. f_1; f_2) \sim \tau_0}
$$
该规则表示，如果 $e$ 是一个可能失败的表达式，并且 $f_1$ 和 $f_2$ 都是类型 $\tau_0$ 的易错表达式，那么 $\text{try}(e; x. f_1; f_2)$ 也是类型 $\tau_0$ 的易错表达式。这里 $e$ 的执行结果将决定后续的计算：如果 $e$ 成功，那么执行 $f_1$，否则执行 $f_2$。

---

### 公式解析：

#### 规则 (28.7a)
$$
\text{fall}(f) \ \text{val}
$$
该规则说明 **fall(f)** 是一个值。这意味着我们可以将一个易错表达式 $f$ 封装为一个不易错的表达式 **fall(f)**。这在表达式求值时表示，如果 $f$ 是成功的，那么它的结果将不会再被视为易错的。

#### 规则 (28.7b)
$$
k . \text{try}(e; x.e_1;e_2) \ 7\to \ k; \text{try}(-; x.e_1; e_2) . e
$$
这条规则表示，尝试求值一个表达式 $\text{try}(e; x.e_1;e_2)$ 时，首先需要将其推入栈，并开始求值 $e$。栈中的框架记录了 $e_1$ 和 $e_2$，分别作为成功和失败的处理分支。

#### 规则 (28.7c)
$$
k; \text{try}(-; x.e_1;e_2) / \text{fall}(f) \ 7\to \ k;\text{try}(-; x.e_1; e_2); \text{fall}(-) . f
$$
该规则说明，当我们捕获一个 **fall(f)** 时，异常处理器会继续求值封装的表达式 $f$。这表示系统在执行过程中，栈帧会记录当前的求值状态，直到找到合适的处理程序。

#### 规则 (28.7d)
$$
k . \text{fail} \ 7\to \ k \ J
$$
当遇到 **fail** 时，栈的执行状态将被转化为失败状态，并传播给栈中的处理程序。如果没有适当的处理程序，这个失败将继续向上传播。

#### 规则 (28.7e)
$$
k . \text{ok}(e) \ 7\to \ k;\text{ok}(-) . e
$$
该规则表示，如果我们遇到一个 **ok(e)**，那么我们将继续求值 $e$ 并在栈中记录该操作。这是因为 **ok(e)** 表示一个成功的操作，并且我们需要确认它的具体值。

#### 规则 (28.7f)
$$
k;\text{ok}(-) / e \ 7\to \ k / \text{ok}(e)
$$
一旦 $e$ 的求值完成，我们将结果返回到栈上，并确认它是一个成功的结果 **ok(e)**。

#### 规则 (28.7g)
$$
e \ \text{val} \quad k;\text{try}(-; x.e_1;e_2); \text{fall}(-) / \text{ok}(e) \ 7\to \ k . [e/x] e_1
$$
这条规则处理的是异常捕获的成功分支。如果表达式 $e$ 成功求值，则执行 $e_1$ 并将 $e$ 的结果绑定到变量 $x$。

#### 规则 (28.7h)
$$
k;\text{try}(-; x.e_1;e_2); \text{fall}(-) \ J \ 7\to \ k . e_2
$$
如果表达式失败，则执行失败分支 $e_2$，并将结果传播下去。

---

通过这些规则，我们定义了如何通过栈管理易错和不易错表达式的求值和异常处理过程。这套规则确保了程序中的异常能够在不同的求值路径中被有效处理，从而保证程序的安全性和正确性。

### ---------------------------------

本节的**注释**（Notes）部分为我们提供了一些历史背景以及对异常机制的探讨：

1. **异常机制的历史**：
   - 异常机制的各种形式早期被探索于不同版本的 **Lisp** 中。例如，**Steele (1990)** 探索了异常机制在 Lisp 中的使用。
   - 最早的 **ML** 语言的设计（**Gordon 等人，1979**）主要作为一种元语言（metalanguage），用于机械化逻辑中的推理策略实现。在这个背景下，异常（称为“失败”）被广泛使用来实现策略（tactics）和策略组合（tacticals）。

2. **现代语言中的异常机制**：
   - 现今大多数编程语言中都包含类似于这里讨论的异常机制。异常机制是现代编程语言中不可或缺的一部分，主要用于处理在程序执行过程中可能发生的错误或意外情况。

3. **异常机制与异常值的区别**：
   - 本节提到，异常机制与异常值的区别常常被误解。**异常值**（exception values）常常是动态分类的，这与第34章中讨论的动态分类（dynamic classification）有关。然而，动态分类的用途远不止于异常值。实际上，动态分类在许多其他场景中也很有用，例如根据运行时上下文动态调整程序行为等。
   
4. **异常机制与流动绑定的误解**：
   - 另一个常见的误解是将异常机制错误地与**流动绑定**（fluid binding）混淆（第33章将讨论）。流动绑定是一种变量绑定的动态管理方式，而异常机制涉及到的是控制流的非本地跳转和错误处理，这两者在概念上是不同的。

总结来说，本节通过回顾异常机制的发展历史、讨论异常值的处理方式以及澄清常见误解，帮助我们更深入地理解异常机制在编程语言中的设计思想和实际应用。


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------
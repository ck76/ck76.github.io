[toc]



### 第九章：哥德尔的 $T$ (Gödel’s T)

**语言** $L\{nat \to\}$，更为人熟知的是**哥德尔的 $T$**，是将**函数类型** (function types) 与**自然数类型** (natural numbers) 相结合的语言。与 $L\{num \, str\}$ 不同的是，后者为自然数提供了一些任意选择的算术原语，而 $L\{nat \to\}$ 提供了一种更为通用的机制，称为**原始递归** (primitive recursion)，从而可以定义这些原语。

#### 1. 原始递归与自然数的归纳性质
原始递归捕捉到了自然数的本质**归纳特性** (inductive character)，因此每一个程序的终止都可以在语言内证明。这意味着，$L\{nat \to\}$ 中定义的每一个函数都是**全函数** (total functions)，即对于每一个输入参数，它们总会返回一个结果。换句话说，每一个 $L\{nat \to\}$ 程序都“自带”了一个终止证明，保证了程序不会陷入无限循环。

#### 2. 语言中的限制与权衡
虽然这种结构似乎是一种**防御机制**，阻止了无限循环的出现，但它也引入了一种限制：有些程序**无法在 $L\{nat \to\}$ 中编写**。原因在于，$L\{nat \to\}$ 的设计要求每个程序必须具有其终止性的证明。然而，编写一个能够证明所有程序终止的“主终止证明” (master termination proof) 是不可能的。接下来我们将证明这一点。

---

### 哥德尔的 $T$ 的构成

#### 1. **静态语义 (Statics)**：
$L\{nat \to\}$ 的类型系统通过函数类型和自然数类型来进行扩展。原始递归是通过类型系统保证程序在每一个递归调用中向终止条件逼近，确保所有程序都能终止。

#### 2. **动态语义 (Dynamics)**：
动态语义描述了如何通过原始递归对函数进行计算。在 $L\{nat \to\}$ 中，自然数的处理不仅依赖于其值，还需要根据递归的结构进行计算。这是通过构造递归函数来实现的。

#### 3. **可定义性 (Definability)**：
我们能够在 $L\{nat \to\}$ 中定义很多常见的自然数运算，例如加法、乘法等。这些操作的定义依赖于原始递归规则。

#### 4. **不可定义性 (Undefinability)**：
尽管 $L\{nat \to\}$ 允许定义许多常见的运算，但也有一些程序是**不可定义**的。这是由于原始递归的限制，即要求每个递归过程都必须终止。因此，无法定义不终止的计算过程，比如某些无限递归。

#### 5. **哥德尔的证明 (Gödel's Proof)**：
哥德尔在他的 $T$ 语言中展示了，尽管我们可以通过原始递归来定义许多常见的数学运算，但并不是所有的计算都可以通过这种方式进行。因此，他证明了在 $L\{nat \to\}$ 语言中并不能定义所有可能的程序，特别是那些涉及无限递归或不确定终止性的程序。

---

### 小结

**哥德尔的 $T$** 提供了一个强大的机制，通过函数类型和自然数类型相结合的方式来定义计算。其最大的特点在于通过**原始递归**保证了每一个程序都具有**终止证明**，从而避免了无限循环的发生。然而，这种设计也带来了限制，某些程序由于缺乏终止性的证明而无法在该语言中实现。这种限制展示了编程语言设计中安全性与表达能力之间的权衡。

### ---------------------------------

### 9.1 静态语义 (Statics) 详解

在 $L\{nat \to\}$ 语言中，定义了函数类型和自然数类型，并且通过原始递归来处理自然数的操作。这里首先介绍了该语言的语法和类型规则，以及原始递归的定义方式。让我们逐步解析公式，理解其含义。

#### 1. **语法定义 (Syntax)**
$L\{nat \to\}$ 语言的语法可以通过如下文法表示：

- 类型 (Types) 定义如下：
  $$
  \text{Typ} \, \tau ::= \text{nat} \, \text{自然数} \quad \text{arr}(\tau_1; \tau_2) \, \tau_1 \to \tau_2 \, \text{函数类型}
  $$

  - $\text{nat}$ 表示自然数类型。
  - $\text{arr}(\tau_1; \tau_2)$ 表示函数类型，其中 $\tau_1$ 是函数的参数类型，$\tau_2$ 是函数的返回类型。

- 表达式 (Expressions) 定义如下：
  $$
  \text{Exp} \, e ::= x \, \text{变量} \quad z \, \text{零} \quad s(e) \, \text{后继} \quad \text{rec}(e;e_0;x.y.e_1) \, \text{原始递归}
  $$

  - $x$ 代表变量。
  - $z$ 表示自然数零。
  - $s(e)$ 表示后继函数，即自然数加一操作。
  - $\text{rec}(e; e_0; x.y.e_1)$ 表示原始递归，递归地从 $e_0$ 开始进行 $e$ 次迭代，$x$ 是前驱变量，$y$ 是递归调用的结果。

#### 2. **递归与迭代 (Recursion vs. Iteration)**

- 原始递归 $\text{rec}(e; e_0; x.y.e_1)$ 表示从初始值 $e_0$ 开始，进行 $e$ 次迭代。
- 迭代 $\text{iter}(e; e_0; y.e_1)$ 是原始递归的简化形式，只绑定递归调用结果 $y$，而忽略前驱 $x$。
  

如果我们有产品类型 (Product Types)，可以将原始递归表示为迭代的一种形式。

#### 3. **类型规则 (Typing Rules)**

接下来，我们逐个解析公式并解释它们的意义。

##### (9.1a) **变量规则**
$$
\frac{}{\Gamma, x : \tau \vdash x : \tau}
$$
该规则表示，在上下文 $\Gamma$ 中，如果 $x$ 具有类型 $\tau$，那么 $x$ 的类型就是 $\tau$。这是一种基本的变量类型规则。

##### (9.1b) **零值规则**
$$
\frac{}{\Gamma \vdash z : \text{nat}}
$$
该规则表示，零 $z$ 的类型是自然数 $\text{nat}$。

##### (9.1c) **后继规则**
$$
\frac{\Gamma \vdash e : \text{nat}}{\Gamma \vdash s(e) : \text{nat}}
$$
该规则表示，如果 $e$ 是自然数，则其后继 $s(e)$ 也是自然数。这反映了自然数的结构化定义。

##### (9.1d) **原始递归规则**
$$
\frac{\Gamma \vdash e : \text{nat} \quad \Gamma \vdash e_0 : \tau \quad \Gamma, x : \text{nat}, y : \tau \vdash e_1 : \tau}{\Gamma \vdash \text{rec}(e; e_0; x.y.e_1) : \tau}
$$
这是原始递归的类型规则，它表示：
- 首先，$e$ 必须是自然数；
- $e_0$ 必须具有类型 $\tau$；
- 对于每次递归，前驱 $x$ 是自然数，结果 $y$ 具有类型 $\tau$，则递归体 $e_1$ 的类型是 $\tau$。

这表明原始递归从一个初始值 $e_0$ 开始，进行 $e$ 次迭代，每次使用递归调用的前驱 $x$ 和结果 $y$。

##### (9.1e) **函数抽象规则**
$$
\frac{\Gamma, x : \rho \vdash e : \tau}{\Gamma \vdash \lambda (\rho) (x.e) : \text{arr}(\rho; \tau)}
$$
该规则定义了函数抽象 $\lambda (\rho) (x.e)$ 的类型。如果在上下文 $\Gamma$ 中，$x$ 的类型是 $\rho$，并且 $e$ 的类型是 $\tau$，那么函数 $\lambda (\rho)(x.e)$ 的类型就是 $\rho \to \tau$。

##### (9.1f) **函数应用规则**
$$
\frac{\Gamma \vdash e_1 : \text{arr}(\tau_2; \tau) \quad \Gamma \vdash e_2 : \tau_2}{\Gamma \vdash \text{ap}(e_1; e_2) : \tau}
$$
该规则定义了函数应用的类型。如果 $e_1$ 是一个从 $\tau_2$ 到 $\tau$ 的函数，而 $e_2$ 的类型是 $\tau_2$，那么函数应用 $\text{ap}(e_1; e_2)$ 的类型是 $\tau$。

#### 4. **结构规则 (Structural Rule)**
类型规则的关键是**结构规则**，特别是**替换规则 (substitution rule)**。替换规则如下：

##### 替换引理 (Substitution Lemma)
$$
\text{Lemma 9.1} \quad \frac{\Gamma \vdash e : \tau \quad \Gamma, x : \tau \vdash e' : \tau'}{\Gamma \vdash [e/x]e' : \tau'}
$$
该引理表示，如果在上下文 $\Gamma$ 中，$e$ 具有类型 $\tau$，并且在上下文 $\Gamma, x : \tau$ 中，$e'$ 具有类型 $\tau'$，那么将 $e$ 替换到 $e'$ 中后，$[e/x]e'$ 仍然具有类型 $\tau'$。

替换引理是保证递归和函数应用正确性的核心工具，它确保在递归和函数调用过程中，替换后的表达式仍然是类型正确的。

---

### 小结

在 $L\{nat \to\}$ 语言中，原始递归允许我们在不引入无限循环的情况下定义自然数的各种操作。每个程序都自带终止证明，这确保了类型系统的安全性。通过函数类型的引入，$L\{nat \to\}$ 允许函数抽象和应用的定义，并结合替换引理，确保递归和函数调用的一致性。

### ---------------------------------

### 9.2 动态语义 (Dynamics) 详解

在 $L\{nat \to\}$ 语言中，动态语义描述了程序如何在执行过程中逐步计算出结果。通过一系列转换规则定义了表达式如何进行计算，并通过值 (value) 的概念描述程序的最终结果。本节解释了 $L\{nat \to\}$ 语言的**值**和**转换规则**。

#### 1. **闭合值 (Closed Values)**

首先，$L\{nat \to\}$ 的闭合值是通过以下规则定义的：

##### (9.2a) 自然数零是一个值：
$$
z \, \text{val}
$$
零 $z$ 是自然数类型的值。

##### (9.2b) 后继的值：
$$
\frac{e \, \text{val}}{s(e) \, \text{val}}
$$
该规则表示，如果 $e$ 是一个值，则后继 $s(e)$ 也是一个值。这是一个 eager 求值 (立即求值) 的规则，因为它要求 $e$ 必须是值。

##### (9.2c) 函数抽象是一个值：
$$
\lambda[\tau](x.e) \, \text{val}
$$
任何函数抽象 (lambda 抽象) 都是一个值。

#### 2. **转换规则 (Transition Rules)**

接下来，定义了如何从一个表达式转换到另一个表达式的规则。这些规则描述了程序如何逐步执行，直到计算出最终的结果。

##### (9.3a) 后继函数的转换：
$$
\frac{e \, \to \, e_0}{s(e) \, \to \, s(e_0)}
$$
该规则表示，如果表达式 $e$ 可以转换为 $e_0$，那么 $s(e)$ 也可以转换为 $s(e_0)$。这是一个结构化规则，它描述了后继函数如何逐步计算。

##### (9.3b) 函数应用的转换 (左部求值)：
$$
\frac{e_1 \to e_1'}{ap(e_1;e_2) \to ap(e_1';e_2)}
$$
该规则表示，函数应用的左部 $e_1$ 如果可以转换为 $e_1'$，那么整个函数应用 $ap(e_1; e_2)$ 可以转换为 $ap(e_1'; e_2)$。

##### (9.3c) 函数应用的转换 (右部求值)：
$$
\frac{e_1 \, \text{val} \quad e_2 \to e_2'}{ap(e_1;e_2) \to ap(e_1;e_2')}
$$
该规则表示，如果 $e_1$ 是一个值，而 $e_2$ 可以转换为 $e_2'$，那么函数应用可以转换为 $ap(e_1; e_2')$。

##### (9.3d) 函数调用 (值的替换)：
$$
\frac{e_2 \, \text{val}}{ap(lam[\tau](x.e); e_2) \to [e_2/x]e}
$$
该规则表示，如果 $e_2$ 是一个值，那么应用函数 $\lambda[\tau](x.e)$ 到 $e_2$ 上的结果是将 $e_2$ 替换到函数体 $e$ 中。

##### (9.3e) 递归的转换：
$$
\frac{e \to e_0}{rec(e;e_0;x.y.e_1) \to rec(e_0;e_0;x.y.e_1)}
$$
该规则表示，递归的第一个参数 $e$ 进行转换后，整个递归表达式也进行相应的转换。

##### (9.3f) 递归零值的转换：
$$
rec(z; e_0; x.y.e_1) \to e_0
$$
该规则表示，当递归的第一个参数是零时，递归结果为 $e_0$。

##### (9.3g) 递归后继值的转换：
$$
rec(s(e); e_0; x.y.e_1) \to [e, rec(e; e_0; x.y.e_1)/x, y] e_1
$$
该规则表示，当递归的第一个参数是后继 $s(e)$ 时，变量 $x$ 绑定为前驱 $e$，$y$ 绑定为递归调用 $rec(e; e_0; x.y.e_1)$ 的结果。

#### 3. **典型形式 (Canonical Forms)**

##### 引理 9.2：**典型形式** (Canonical Forms)

如果 $e : \tau$ 并且 $e$ 是一个值，那么：
1. 如果 $\tau = \text{nat}$，那么 $e = s(s(\dots z))$，即 $e$ 是由若干个后继操作构成的自然数。
2. 如果 $\tau = \tau_1 \to \tau_2$，那么 $e = \lambda (x : \tau_1) e_2$，即 $e$ 是一个函数抽象。

这两个情况描述了自然数和函数类型的典型形式，它们定义了值在不同类型下的具体形式。

#### 4. **类型安全性 (Safety)**

##### 定理 9.3：**安全性** (Safety)

1. 如果 $e : \tau$ 且 $e \to e_0$，则 $e_0 : \tau$。
2. 如果 $e : \tau$，则要么 $e$ 是一个值，要么存在 $e_0$ 使得 $e \to e_0$。

**解释**：
- **第一部分 (Preservation)** 确保类型在转换过程中保持不变。如果一个表达式 $e$ 的类型是 $\tau$，并且它可以转换为另一个表达式 $e_0$，那么 $e_0$ 的类型也必须是 $\tau$。
- **第二部分 (Progress)** 确保任何类型正确的表达式要么是一个值，要么可以继续计算。它确保程序不会陷入无法计算的状态。

---

### 小结

$L\{nat \to\}$ 语言通过一系列值定义和转换规则，描述了自然数和函数类型的动态语义。通过递归函数处理自然数的操作，并且通过类型安全性定理，确保在执行过程中，类型不会发生变化，程序可以正常计算。

### ---------------------------------

### 9.3 定义性 (Definability)

**定义性** (Definability) 是指某个数学函数是否可以在给定的语言中定义。在这里，我们讨论如何在 $L\{nat \to\}$ 语言中定义自然数上的函数。公式的解释将以 $f: \mathbb{N} \to \mathbb{N}$ 作为讨论对象。

#### 1. **可定义函数 (Definable Functions)**

对于一个自然数函数 $f: \mathbb{N} \to \mathbb{N}$，我们说它在 $L\{nat \to\}$ 中是**可定义**的，当且仅当存在一个表达式 $e_f$ 使得对于任意自然数 $n \in \mathbb{N}$，满足以下条件：
$$
e_f(n) \equiv f(n) : nat. \tag{9.4}
$$
这意味着函数 $f$ 在 $L\{nat \to\}$ 中是可定义的，如果有一个表达式 $e_f$ 的类型是 $nat \to nat$，并且应用这个表达式到自然数表示 $n$ 上时，结果等于 $f(n)$ 对应的自然数表示。

#### 2. **定义性等式规则 (Definitional Equality Rules)**

在 $L\{nat \to\}$ 中的定义性等式 $\Gamma \vdash e \equiv e_0 : \tau$ 是一个最强的同余关系 (congruence)，由以下公理所构成：

##### (9.5a) 函数应用的定义性等式：
$$
\Gamma \vdash ap(lam[\tau_1](x.e_2);e_1) \equiv [e_1/x]e_2 : \tau
$$
该规则描述了函数应用如何被替换为其函数体，类似于通常的 $\lambda$-抽象替换。

##### (9.5b) 递归零值的定义性等式：
$$
\Gamma \vdash rec(z; e_0; x.y.e_1) \equiv e_0 : \tau
$$
当递归的初始值为零时，递归表达式直接等价于 $e_0$。

##### (9.5c) 递归后继值的定义性等式：
$$
\Gamma \vdash rec(s(e); e_0; x.y.e_1) \equiv [e, rec(e; e_0; x.y.e_1)/x, y] e_1 : \tau
$$
该规则描述了当递归遇到后继值 $s(e)$ 时，如何替换变量 $x$ 为前驱 $e$，以及 $y$ 为递归调用的结果。

#### 3. **实例：倍增函数 (Doubling Function)**

倍增函数 $d(n) = 2 \times n$ 可以通过以下表达式 $e_d : nat \to nat$ 定义：
$$
\lambda (x:nat) \, rec \, x \, \{z \Rightarrow z \, | \, s(u) \, \text{with} \, v \Rightarrow s(s(v)) \}.
$$
为了验证这是倍增函数的定义，我们使用数学归纳法来证明：

- 基础情况 (Base case): 对于 $n = 0$，容易验证：
  $$
  e_d(0) \equiv 0 : nat.
  $$

- 归纳假设 (Inductive hypothesis): 假设 $e_d(n) \equiv d(n) : nat$，即 $e_d(n) = 2 \times n$。

- 归纳步骤 (Inductive step): 对于 $n+1$，我们计算：
  $$
  e_d(n + 1) \equiv s(s(e_d(n))) \equiv s(s(2 \times n)) = 2 \times (n + 1) = d(n + 1).
  $$

因此，倍增函数在 $L\{nat \to\}$ 中是可定义的。

#### 4. **实例：Ackermann 函数 (Ackermann's Function)**

Ackermann 函数的定义如下：
$$
A(0, n) = n + 1
$$
$$
A(m + 1, 0) = A(m, 1)
$$
$$
A(m + 1, n + 1) = A(m, A(m + 1, n)).
$$
Ackermann 函数是一个高阶递归函数，递归得非常快。例如，$A(4, 2)$ 大约为 $2^{65536}$，远远超过宇宙中的原子数量。

为了定义 Ackermann 函数，我们需要观察到 $A(m + 1, n)$ 是对函数 $A(m, -)$ 的 $n$ 次迭代。首先，我们定义一个高阶函数 $it$，其作用是迭代应用函数：
$$
it : (nat \to nat) \to nat \to nat \to nat
$$
定义为：
$$
\lambda (f:nat \to nat) \lambda (n:nat) rec \, n \, \{z \Rightarrow id \, | \, s() \, \text{with} \, g \Rightarrow f \circ g\},
$$
其中，$id = \lambda (x:nat) x$ 是恒等函数，$f \circ g = \lambda (x:nat) f(g(x))$ 表示 $f$ 和 $g$ 的复合。

然后，我们可以定义 Ackermann 函数 $e_a : nat \to nat \to nat$ 为：
$$
\lambda (m:nat) \, rec \, m \, \{z \Rightarrow s \, | \, s() \, \text{with} \, f \Rightarrow \lambda (n:nat) \, it(f)(n)(f(1)) \}.
$$

可以验证以下等式：
$$
e_a(0)(n) \equiv s(n) \tag{9.6}
$$
$$
e_a(m + 1)(0) \equiv e_a(m)(1) \tag{9.7}
$$
$$
e_a(m + 1)(n + 1) \equiv e_a(m)(e_a(s(m))(n)). \tag{9.8}
$$
这表明 Ackermann 函数在 $L\{nat \to\}$ 中是可定义的。

---

### 总结

在本节中，我们讨论了如何在 $L\{nat \to\}$ 中定义自然数上的函数。倍增函数是通过简单的递归定义的，而 Ackermann 函数则是一个更复杂的高阶递归函数，它展示了该语言的强大定义能力。

### ---------------------------------

好的，我会详细讲解相关内容，并且对涉及的公式进行详细解释，包括符号的含义、作用以及公式的推导过程。

### 9.3 定义性 (Definability)

#### 1. **函数定义性 (Definability of Functions)**

首先，我们讨论在 $L\{nat \to\}$ 语言中如何定义一个函数。函数 $f: \mathbb{N} \to \mathbb{N}$ 的可定义性，要求存在一个表达式 $e_f$，它的类型为 $nat \to nat$，并且满足对于每一个自然数 $n$，$e_f$ 应该等于 $f(n)$。

用公式表示的话，定义性条件是：
$$
e_f(n) \equiv f(n) : nat \tag{9.4}
$$

- 其中，$e_f(n)$ 表示将表达式 $e_f$ 应用于自然数 $n$ 的结果。
- $f(n)$ 是自然数上的函数 $f$ 对 $n$ 的应用。
- $\equiv$ 表示定义性等价，即在 $L\{nat \to\}$ 中，$e_f(n)$ 和 $f(n)$ 在类型 $nat$ 下是等价的。

这个定义性条件表明，如果 $e_f$ 是一个在语言 $L\{nat \to\}$ 中的表达式，那么当我们将自然数 $n$ 应用于 $e_f$ 时，结果应该等价于 $f(n)$，且类型为 $nat$。

#### 2. **定义性等式规则 (Definitional Equality Rules)**

为了确保函数应用和递归的正确性，我们需要使用定义性等式规则来确保表达式之间的转换保持一致。在 $L\{nat \to\}$ 中，定义性等式 $\Gamma \vdash e \equiv e_0 : \tau$ 是通过以下几条关键规则构成的：

##### (9.5a) 函数应用：
$$
\frac{}{\Gamma \vdash ap(lam[\tau_1](x.e_2);e_1) \equiv [e_1/x]e_2 : \tau}
$$
这里的表达式解释了函数应用的定义性等价：

- $ap(lam[\tau_1](x.e_2);e_1)$ 表示对 $\lambda$-抽象 $lam[\tau_1](x.e_2)$ 的应用，$e_1$ 是实际的参数。
- 规则的右侧 $[e_1/x]e_2$ 表示将 $e_1$ 作为参数代入到表达式 $e_2$ 中，这相当于执行了函数应用后的结果。
- $\equiv$ 表示应用函数后的结果与进行参数替换后的结果是定义性等价的。

##### (9.5b) 递归基础情况：
$$
\frac{}{\Gamma \vdash rec(z; e_0; x.y.e_1) \equiv e_0 : \tau}
$$
在递归的基础情况下，如果递归的第一个参数是 $z$，即零，则整个递归表达式等价于初始值 $e_0$。

##### (9.5c) 递归后继情况：
$$
\frac{}{\Gamma \vdash rec(s(e); e_0; x.y.e_1) \equiv [e, rec(e; e_0; x.y.e_1)/x, y] e_1 : \tau}
$$
当递归的第一个参数是 $s(e)$，即后继函数时，表达式进行递归展开：

- $rec(s(e); e_0; x.y.e_1)$ 表示递归调用，其中 $s(e)$ 是后继。
- 展开后，$x$ 被绑定为前驱 $e$，$y$ 被绑定为递归调用 $rec(e; e_0; x.y.e_1)$ 的结果。
- 结果 $e_1$ 是用 $x$ 和 $y$ 替换后的表达式。

#### 3. **倍增函数 (Doubling Function)**

倍增函数 $d(n) = 2 \times n$ 是一个简单的递归函数，它在 $L\{nat \to\}$ 中可以定义如下：
$$
e_d = \lambda (x:nat) \, rec \, x \, \{z \Rightarrow z \, | \, s(u) \, \text{with} \, v \Rightarrow s(s(v)) \}
$$
在这里：
- $x$ 是输入的自然数。
- $rec \, x$ 是对 $x$ 进行递归，$z$ 表示当 $x = 0$ 时的初始值。
- $s(u)$ 是递归展开的后继情况，$s(s(v))$ 表示倍增的递归步骤，$v$ 是递归调用的结果。

验证这个函数是倍增函数：

1. **基础情况**：当 $n = 0$ 时：
   $$
   e_d(0) \equiv z \equiv 0 : nat
   $$

2. **归纳步骤**：假设 $e_d(n) \equiv 2 \times n : nat$，我们验证 $e_d(n+1)$：
   $$
   e_d(n+1) \equiv s(s(e_d(n))) \equiv s(s(2 \times n)) = 2 \times (n+1)
   $$

因此，我们证明了倍增函数在 $L\{nat \to\}$ 中是正确的。

#### 4. **Ackermann 函数 (Ackermann's Function)**

Ackermann 函数是一个著名的高阶递归函数，定义如下：
$$
\begin{aligned}
A(0, n) &= n + 1 \\
A(m + 1, 0) &= A(m, 1) \\
A(m + 1, n + 1) &= A(m, A(m + 1, n)).
\end{aligned}
$$
Ackermann 函数递归非常快，比如 $A(4, 2) \approx 2^{65536}$。虽然这个函数在数学上是总定义的 (total)，但它超出了基本的递归定义，因此在语言中定义它需要使用更高阶的递归技巧。

为了定义 Ackermann 函数，我们首先定义一个高阶迭代函数 $it$，用于迭代函数 $f$：
$$
it : (nat \to nat) \to nat \to nat \to nat
$$
定义为：
$$
\lambda (f:nat \to nat) \lambda (n:nat) \, rec \, n \, \{z \Rightarrow id \, | \, s() \, \text{with} \, g \Rightarrow f \circ g\}
$$
这里，$id = \lambda (x:nat) x$ 是恒等函数，$f \circ g = \lambda (x:nat) f(g(x))$ 表示 $f$ 和 $g$ 的复合。

然后 Ackermann 函数可以定义为：
$$
e_a = \lambda (m:nat) \, rec \, m \, \{z \Rightarrow s \, | \, s() \, \text{with} \, f \Rightarrow \lambda (n:nat) \, it(f)(n)(f(1)) \}
$$

通过验证，可以得到以下等式：
$$
e_a(0)(n) \equiv s(n) \tag{9.6}
$$
$$
e_a(m + 1)(0) \equiv e_a(m)(1) \tag{9.7}
$$
$$
e_a(m + 1)(n + 1) \equiv e_a(m)(e_a(s(m))(n)) \tag{9.8}
$$
这证明了 Ackermann 函数可以在 $L\{nat \to\}$ 中定义。

### 总结

我们深入分析了如何通过 $L\{nat \to\}$ 语言定义自然数上的函数，包括简单的递归函数如倍增函数以及复杂的高阶递归函数如 Ackermann 函数。通过这些定义性等式和推导步骤，我们验证了这些函数在 $L\{nat \to\}$ 语言中的正确性。

### ---------------------------------

### 9.4 不可定义性 (Undefinability)

**不可定义性定理 (Theorem 9.4)**：在 $L\{nat \to\}$ 中，无法定义无限循环。换句话说，如果 $e : \tau$，那么总存在一个值 $v \ val$ 使得 $e \equiv v : \tau$。这意味着在这个系统中，任何表达式都必定会计算出某个值，而不会出现无限循环或“卡住”的情况。

#### 定理证明的意义：

这一点说明了 $L\{nat \to\}$ 中的函数值就像数学中的函数一样：对于任何类型为 $nat \to nat$ 的函数 $f$ 和表达式 $e$，$f(e)$ 总是能够计算出某个值 $v$。尤其是当 $e : nat$ 时，必定存在某个自然数 $n$ 使得 $e \equiv n : nat$。

### 1. **哥德尔编号 (Gödel-numbering)**

为了展示某些自然数上的函数无法在 $L\{nat \to\}$ 中定义，我们引入了**哥德尔编号**(Gödel-numbering) 技术。这个技术的核心思想是将 $L\{nat \to\}$ 中的每一个闭合表达式对应到一个唯一的自然数。这使得我们可以将表达式视作数据，并在 $L\{nat \to\}$ 中通过计算这些表达式的编号来执行程序。

#### **哥德尔编号的定义：**

给定一个抽象语法树 $a$，它的形式是 $o(a_1, \dots, a_k)$，其中 $o$ 是操作符，$a_1, \dots, a_k$ 是子树。我们为每个操作符赋予一个唯一的自然数索引 $m$，同时将 $a_1, \dots, a_k$ 对应的哥德尔编号为 $n_1, \dots, n_k$。哥德尔编号的定义为：
$$
p a q = 2^m \cdot 3^{n_1} \cdot 5^{n_2} \cdot \dots \cdot p_k^{n_k}
$$
这里，$p_k$ 是第 $k$ 个素数，$n_1, \dots, n_k$ 是子树 $a_1, \dots, a_k$ 的哥德尔编号。

这个编号方法通过素数的乘积唯一地编码每一个表达式。

#### **反向解码：**

根据素数分解定理，我们可以将任何自然数 $n$ 分解为其素数因子，从而恢复出对应的抽象语法树。如果某个自然数无法解析为合法的抽象语法树，则它不代表任何合法表达式。

### 2. **通用函数 (Universal Function)**

通过哥德尔编号，我们定义一个通用函数 $funiv : \mathbb{N} \to \mathbb{N} \to \mathbb{N}$，它的行为如下：
$$
funiv(peq)(m) = n \quad \text{当且仅当} \quad e(m) \equiv n : nat
$$

也就是说，$funiv(peq)(m)$ 表示在 $e$ 是一个自然数到自然数的函数时，$e(m)$ 的计算结果是 $n$。该函数是 $L\{nat \to\}$ 的通用函数，因为它描述了任何类型为 $nat \to nat$ 的表达式 $e$ 的行为。

#### **对角线函数 (Diagonal Function)**

为了证明某些函数在 $L\{nat \to\}$ 中不可定义，我们引入了**对角线函数** $d : \mathbb{N} \to \mathbb{N}$，定义为：
$$
d(m) = funiv(m)(m)
$$
即，对角线函数的定义是，$d(m)$ 表示 $funiv(m)$ 对 $m$ 的计算结果。

对角线函数的作用是帮助我们证明某些函数无法在 $L\{nat \to\}$ 中定义。我们接下来展示这一点。

### 3. **不可定义性证明：**

假设对角线函数 $d$ 可以由表达式 $e_d$ 定义，即存在 $e_d$ 使得：
$$
e_d(peq) \equiv e(peq) : nat
$$

我们定义一个新函数 $e_D$：
$$
e_D = \lambda (x:nat) \, s(e_d(x))
$$
这个函数的类型为 $nat \to nat$。根据定义：
$$
e_D(pe_Dq) \equiv s(e_d(pe_Dq)) \equiv s(e_D(pe_Dq))
$$

然而，根据终止定理 (Termination Theorem)，应当存在一个自然数 $n$ 使得：
$$
e_D(pe_Dq) \equiv n
$$

但是这意味着：
$$
n \equiv s(n)
$$
这显然是矛盾的，因为 $n$ 不能等于 $s(n)$。因此，对角线函数 $d$ 是不可定义的。

### 4. **不可定义性与语言的通用性：**

最后，我们讨论语言的通用性问题。我们称一个语言 $L$ 是**通用的 (universal)**，当它能够在自身内部编写解释器时。尽管通用函数 $funiv$ 在某些强大的编程语言中是可计算的，但 $L\{nat \to\}$ 并不足够强大，无法定义该通用函数。

因此，$L\{nat \to\}$ 不是通用的。换句话说，为了确保程序总是终止（即终止性），我们必须牺牲某些表达能力（即通用性）。这是一个无法避免的权衡：如果你想要通用性，就必须放弃终止性；如果你想要终止性，就必须放弃通用性。

### ---------------------------------

### 9.5 备注 (Notes)

$L\{nat \to\}$ 是由哥德尔 (Gödel) 在研究**算术一致性**（consistency of arithmetic）时引入的语言。哥德尔展示了如何将算术中的证明“编译”成 $L\{nat \to\}$ 中的**良类型项 (well-typed terms)**，并将算术一致性问题转化为 $L\{nat \to\}$ 中程序的**终止性问题**（termination of programs）。

#### 背景解析：
1. **哥德尔与一致性问题**：
   - 哥德尔通过 $L\{nat \to\}$ 语言展示了如何将算术中的证明映射到良类型的函数表达式。通过这一过程，他展示了算术一致性问题可以归结为一个程序终止性问题。具体来说，他研究了如何通过构造能够证明终止的函数来验证算术的一致性。
   
   - 这是编程语言设计直接受到**验证程序终止性**（termination verification）影响的一个早期例子。

#### **终止性问题的重要性**：
   - **终止性 (Termination)**：即在 $L\{nat \to\}$ 中，所有程序必须在有限步数内终止。这一性质确保了程序不会陷入无限循环。这种语言设计理念直接影响了之后对编程语言设计中的终止性验证方法。
   
   - $L\{nat \to\}$ 的设计理念旨在确保程序的**总函数性**（totality）。总函数意味着函数对其每一个合法输入总能产生一个输出，而不会出现无法计算的情形。这使得该语言非常适合于数学证明的形式化和可靠性验证。

#### **语言设计的历史意义**：
   - $L\{nat \to\}$ 可以被视为一种早期的形式化验证工具，用于验证程序是否正确终止。这种思想后来对**函数式编程语言**和**依赖类型**的研究产生了深远影响。例如，现代的依赖类型编程语言（如 Coq 和 Agda）都基于类似的设计理念，确保程序的终止性。

   - $L\{nat \to\}$ 的设计直接影响了编程语言的理论发展，它提出了一种将程序设计和数学证明紧密结合的方法。这种结合成为之后编程语言研究的重要方向之一。

总结来说，$L\{nat \to\}$ 不仅是一个确保终止性的语言，它还展示了如何将数学证明转化为可验证的程序。这种语言设计的历史意义在于，它引发了编程语言中的终止性验证的研究，并奠定了现代形式化验证的基础。

### ---------------------------------

**$L\{nat \to\}$** 可以被理解为描述自然数上的可定义和不可定义函数的语言，其中的箭头符号 "$\to$" 通常用于表示函数类型。这里，我们讨论的是关于自然数（`nat`）的函数在某种逻辑系统中**可定义性**（definability）和**不可定义性**（undefinability）的相关问题。这与哥德尔在**1931年不完备定理**以及**递归可定义性**中的工作密切相关。

我们将通过以下几个方面来探讨：

1. **哥德尔的可定义性与不可定义性**背景
2. **自然数函数的可定义性**
3. **$L\{nat \to\}$ 语言中的可定义性与不可定义性**
4. **总结与扩展**

### 1. **哥德尔的可定义性与不可定义性背景**

哥德尔的工作（特别是1931年发表的**不完备定理**）展示了，在足够强的形式系统中，存在一些在系统内**不可定义**的命题。该定理表明，对于任何递归可枚举的公理系统，如果它足够强大以表达自然数的算术，那么它必定是**不完备的**，即：在系统内存在**既不可证明又不可否定的命题**。这个定理的核心在于**可定义性**（definability）和**不可定义性**（undefinability）之间的关系。

在不完备定理中，哥德尔使用了**递归函数**和**可计算性**理论的概念来构建他所谓的**哥德尔数**（Gödel numbers），并证明了某些**递归函数**是无法通过系统内的公式完全表达的。

因此，哥德尔的工作为自然数上定义的函数的**可定义性**与**不可定义性**提供了一个框架。对于自然数上的函数，有些是可以在系统内明确**定义**的（例如加法和乘法），而另一些则是**不可定义**的。

### 2. **自然数函数的可定义性**

在自然数上的可定义函数的研究通常基于**递归函数理论**。在递归函数理论中，我们可以讨论不同类型的函数是否可以在特定的语言或系统中定义。最常见的例子包括：

- **原始递归函数**：这些是通过基本的递归定义，如零函数、后继函数、加法和乘法。
- **递归函数**：这是一个更广泛的类，包含了可以通过**最小化操作**定义的函数。

在这些函数定义的框架内，自然数上的可定义函数是那些可以通过有限步骤在给定逻辑系统中构建的函数。换句话说，一个自然数函数 $f$ 被认为是**可定义的**，如果存在一个系统（如某种形式化的语言 $L$），可以表达 $f$ 的计算步骤。

但是，不是所有的自然数函数都可以在这些系统中定义。这就引出了自然数上**不可定义函数**的问题。例如，某些函数的定义可能需要超出递归定义的范畴，从而在系统内变得不可定义。

### 3. **$L\{nat \to\}$ 语言中的可定义性与不可定义性**

我们可以将 $L\{nat \to\}$ 看作是一个语言，它定义了从自然数到其他自然数的函数。在这个框架中，讨论的核心问题是：哪些自然数上的函数可以在这个语言中被定义，哪些则不能。

#### (1) **$L\{nat \to\}$ 中的可定义性**

在 $L\{nat \to\}$ 这样的语言中，基本的自然数函数，如零函数、后继函数、加法、乘法、以及基本的递归函数是可定义的。这些函数的定义遵循形式系统中的规则，可以通过递归或有限步骤明确表示。

例如，考虑加法函数 `add(x, y)`，它在 $L\{nat \to\}$ 中可以通过如下递归定义：
- `add(x, 0) = x`
- `add(x, y+1) = add(x, y) + 1`

类似的，乘法函数也可以通过递归定义。对于这些基本函数，它们的可定义性是显而易见的。

#### (2) **$L\{nat \to\}$ 中的不可定义性**

尽管许多常见的函数可以在 $L\{nat \to\}$ 中定义，但并不是所有自然数函数都可以在这样的系统中定义。正如哥德尔的不完备定理所揭示的，某些函数是系统内不可定义的。例如，**停机问题**（Halting Problem）是一个典型的不可计算问题，因此在语言 $L\{nat \to\}$ 中，它也是不可定义的。

哥德尔的工作通过构造**不可定义性**的例子表明，某些函数不能通过系统内的公式表达。具体而言，对于任何能够表达算术的系统，都存在某些自然数函数，它们不能通过该系统内的公式表达或推导。

此外，像**非递归函数**，尤其是那些依赖于不确定性的函数，也是不可定义的。对于这些函数，虽然它们可能在外部通过某种操作定义，但在形式化系统中无法通过递归定义来表示。

### 4. **总结与扩展**

哥德尔的工作为讨论自然数上函数的可定义性和不可定义性提供了一个基础框架。$L\{nat \to\}$ 作为描述自然数函数的语言，其中的一些函数（如加法、乘法）可以被递归定义，因此是**可定义的**。然而，根据哥德尔不完备定理，某些自然数函数（如停机问题）是系统内**不可定义的**。

通过这个框架，我们可以进一步讨论不同语言和系统中的可定义性问题。例如，扩展到更加复杂的函数类型或更高阶的系统时，某些函数的可定义性或不可定义性将更加明显。

- **可定义性**：通过递归或构造性定义可以在系统内被表达和计算的函数。
- **不可定义性**：超出递归函数的范围，或者在系统内无法通过有限的规则表达的函数。

因此，哥德尔的可定义性和不可定义性的概念直接适用于讨论 $L\{nat \to\}$ 这样的系统，帮助我们理解哪些自然数上的函数可以在系统内定义，哪些则不能。


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------


### ---------------------------------
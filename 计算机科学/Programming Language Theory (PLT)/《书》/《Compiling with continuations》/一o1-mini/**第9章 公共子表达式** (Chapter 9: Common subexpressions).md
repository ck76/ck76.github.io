[toc]



好的，我将**详细**解释您提供的《Compiling with Continuations》第九章**“公共子表达式（Common Subexpressions）”**的内容。这一章节探讨了在续延传递风格（Continuation-Passing Style, CPS）下进行公共子表达式消除（CSE）的优化技术，包括CSE的定义、应用条件、具体示例以及其与其他优化技术（如向上提升和β展开）的结合。以下内容严格基于您提供的文本，旨在帮助您全面理解公共子表达式消除及其在CPS优化中的应用。

---

## **第九章 公共子表达式（Common Subexpressions）**

### **1. 公共子表达式消除的定义**

**公共子表达式消除（Common Subexpression Elimination, CSE）**是一种编译器优化技术，用于识别并消除程序中重复计算的相同表达式。通过消除这些重复计算，可以减少程序的执行次数，从而提升运行效率。

#### **1.1 基本概念**

当一个程序中相同的计算在执行过程中被多次执行时，可以通过CSE优化来消除冗余的计算。具体来说，CSE通过以下方式实现优化：

- **识别重复计算**：确定哪些表达式在程序中被多次计算。
- **消除冗余计算**：保留第一次计算的结果，将后续重复计算的地方替换为第一次计算的结果。

#### **1.2 CSE在CPS中的特殊性**

在CPS表示中，所有函数调用都被转换为续延调用（continuation calls），这使得CSE的应用具有一些特殊性：

- **变量绑定**：在CPS中，闭包（closure）用于实现带有自由变量的函数。闭包通常表示为一个记录（record），其中第一个槽位存储闭合函数（closed function），其余槽位存储自由变量。
- **作用域规则**：CPS中的作用域规则规定，如果一个变量绑定了一个`FIX`操作符定义的函数，那么该函数的定义体也在该变量的作用域内。这意味着CSE可以跨函数边界进行。

### **2. CSE的应用条件**

为了在CPS中有效地应用CSE，必须满足以下条件：

- **表达式的等价性**：两个表达式必须在语义上等价，即在相同的上下文中总是产生相同的结果。
- **表达式的词法支配关系**：被消除的表达式必须被等价表达式所词法支配。这意味着被消除的表达式必须在等价表达式的作用域内，并且在等价表达式之前计算。

#### **2.1 词法支配的必要性**

词法支配（Lexical Dominance）是指一个表达式在另一个表达式的作用域内，并且在代码中位于另一个表达式之前被计算。只有当被消除的表达式被等价表达式词法支配时，CSE才能安全地应用，确保替换不会改变程序的语义。

### **3. CSE的具体示例**

通过具体示例，我们可以更直观地理解CSE在CPS中的应用。

#### **3.1 示例一：简单的重复计算**

考虑以下ML表达式：

```sml
val z = a * b * c + a * b * c
```

这个表达式中，`a * b * c` 被计算了两次。将其转换为CPS表示，代码会变得更加复杂：

```sml
PRIMOP(*, [VAR a, VAR b], [u], [
  PRIMOP(*, [VAR u, VAR c], [v], [
    PRIMOP(*, [VAR a, VAR b], [w], [
      PRIMOP(*, [VAR w, VAR c], [x], [
        PRIMOP(+, [VAR v, VAR x], [z], [ ... ])
      ])
    ])
  ])
])
```

在这个CPS表示中，`PRIMOP(*, [VAR a, VAR b], [w], ...)` 被重复定义了两次。根据CSE的规则，因为第二个`PRIMOP(*, [VAR a, VAR b], [w], ...)`位于第一个`PRIMOP(*, [VAR a, VAR b], [w], ...)`的作用域内，并且两者计算的结果相同，可以进行CSE优化。

**优化步骤如下：**

1. **识别重复计算**：发现`PRIMOP(*, [VAR a, VAR b], [w], ...)`被计算了两次。
2. **消除冗余计算**：保留第一次计算的结果，将第二次计算的地方替换为第一次计算的结果。

优化后的CPS代码如下：

```sml
PRIMOP(*, [VAR a, VAR b], [u], [
  PRIMOP(*, [VAR u, VAR c], [v], [
    PRIMOP(*, [VAR u, VAR c], [x], [
      PRIMOP(+, [VAR v, VAR x], [z], [ ... ])
    ])
  ])
])
```

进一步优化，发现变量`x`仅仅是`v`的一个冗余绑定，可以将`x`替换为`v`，得到最终优化后的代码：

```sml
PRIMOP(*, [VAR a, VAR b], [u], [
  PRIMOP(*, [VAR u, VAR c], [v], [
    PRIMOP(+, [VAR v, VAR v], [z], [ ... ])
  ])
])
```

这样，重复的计算被有效地消除了，程序的执行效率得到了提升。

#### **3.2 示例二：跨函数边界的CSE**

根据CPS的作用域规则，如果一个变量`w`的定义包含一个`FIX`操作符，那么由该`FIX`操作符定义的函数体也在`w`的作用域内。这意味着CSE可以跨函数边界进行。

考虑以下CPS表达式：

```sml
SELECT(i, v, w, ...)
FIX([(f, [a, c], SELECT(i, v, u, B))], E)
```

在这个例子中，`SELECT(i, v, u, B)` 在函数`f`的作用域内重复出现了两次：

1. **外部`SELECT`**：`SELECT(i, v, w, ...)`
2. **内部`SELECT`**：`SELECT(i, v, u, B)`

根据CSE的规则，内部的`SELECT`可以被外部的`SELECT`所消除，并将`u`替换为`w`，得到优化后的CPS代码：

```sml
SELECT(i, v, w, ...)
FIX([(f, [a, c], SELECT(i, v, w, B))], E)
```

这样，内部的`SELECT`操作被消除了，程序的执行效率得到了提升。

#### **3.3 示例三：SWITCH分支中的CSE**

考虑以下CPS表达式：

```sml
SWITCH(VAR v, [
  PRIMOP(+, [VAR a, VAR b], x, A),
  B,
  PRIMOP(+, [VAR a, VAR b], y, C)
])
```

在这个例子中，`PRIMOP(+, [VAR a, VAR b], ...)` 在两个不同的分支中被计算了两次。理论上，我们希望能够将`a + b`的计算提升到`SWITCH`之前，以消除重复计算。然而，这样做存在两个问题：

1. **浪费时间**：如果分支`B`被大多数情况下执行，提升后的计算可能会导致不必要的计算开销。
2. **副作用问题**：如果`PRIMOP(+, [VAR a, VAR b], ...)`具有副作用（如可能溢出），则提升可能会改变程序的行为。

因此，对于“非纯函数”操作符，如可能引发副作用的算术操作，CSE的应用需要谨慎。

### **4. CSE与向上提升的结合**

在某些情况下，CSE的应用需要与向上提升（Hoisting）等其他优化技术结合，以实现更有效的优化效果。

#### **4.1 示例四：向上提升后的CSE**

考虑以下CPS表达式：

```sml
FIX([(f, [a, c], PRIMOP(+, [VAR x, VAR y], [z], [
  PRIMOP(+, [VAR z, VAR a], [u], [
    APP(VAR c, [VAR u])
  ])
])])],
PRIMOP(+, [VAR x, VAR y], [w], [
  APP(VAR f, [VAR w, VAR k])
]))
```

在这个例子中，`x + y` 被计算了两次，分别绑定到变量`z`和`w`。根据CSE的规则，第二次计算`x + y`可以被消除，并将`w`替换为`z`，得到优化后的CPS代码：

```sml
PRIMOP(+, [VAR x, VAR y], [w], [
  FIX([(f, [a, c], PRIMOP(+, [VAR w, VAR a], [u], [
    APP(VAR c, [VAR u])
  ])])],
  APP(VAR f, [VAR w, VAR k])
))
```

进一步优化，发现`w`和`z`可以互相替换，得到：

```sml
PRIMOP(+, [VAR x, VAR y], [w], [
  FIX([(f, [a, c], PRIMOP(+, [VAR w, VAR a], [u], [
    APP(VAR c, [VAR u])
  ])])],
  APP(VAR f, [VAR w, VAR k])
))
```

### **5. CSE在循环优化中的应用**

一个重要的优化应用场景是**循环不变式提升（Loop-Invariant Hoisting）**。这是指将循环内部每次迭代都计算相同结果的表达式提升到循环外部，只执行一次计算，从而减少重复计算的开销。

#### **5.1 示例五：循环不变式提升**

考虑以下ML代码：

```sml
let 
  fun loop(0, s) = s
  | loop(i, s) = loop(i - 1, a + b + s)
in 
  loop(n, 0)
end
```

将其转换为CPS表示，并应用CSE和向上提升，优化后的CPS代码如下：

```sml
FIX([
  (loop, [i, s, c],
    PRIMOP(ieql, [VAR i, INT 0], [
      APP(VAR c, [VAR s]),
      PRIMOP(-, [VAR i, INT 1], [j], [
        PRIMOP(+, [VAR a, VAR b], [x], [
          PRIMOP(+, [VAR x, VAR s], [y], [
            APP(VAR loop, [VAR j, VAR y, VAR c])
          ])
        ])
      ])
    ])
  )
],
PRIMOP(ieql, [VAR n, INT 0], [
  APP(VAR k, [INT 0]),
  PRIMOP(-, [VAR n, INT 1], [j’], [
    PRIMOP(+, [VAR a, VAR b], [x’], [
      PRIMOP(+, [VAR x’, INT 0], [y’], [
        APP(VAR loop, [VAR j’, VAR y’, VAR k])
      ])
    ])
  ])
]))
```

在这个优化过程中，通过β展开和向上提升，将循环不变式`a + b`提升到循环外部，只计算一次，从而减少了重复计算的开销。

#### **5.2 优化步骤详解**

1. **β展开**：通过内联展开优化循环体，减少函数调用的开销。
2. **向上提升**：将循环不变式`a + b`提升到循环外部，只计算一次。
3. **CSE应用**：识别并消除提升后的重复计算，进一步优化代码。

最终优化后的CPS代码：

```sml
PRIMOP(ieql, [VAR n, INT 0], [
  APP(VAR k, [INT 0]),
  PRIMOP(-, [VAR n, INT 1], [j’], [
    PRIMOP(+, [VAR a, VAR b], [x’], [
      FIX([
        (loop, [i, s, c],
          PRIMOP(ieql, [VAR i, INT 0], [
            APP(VAR c, [VAR s]),
            PRIMOP(-, [VAR i, INT 1], [j], [
              PRIMOP(+, [VAR x’, VAR s], [y], [
                APP(VAR loop, [VAR j, VAR y, VAR c])
              ])
            ])
          ])
        )
      ],
      APP(VAR loop, [VAR j’, VAR x’, VAR k]))
    ])
  ])
])
```

通过上述优化步骤，循环不变式`a + b`只被计算一次，显著减少了循环内部的计算开销，提高了程序的运行效率。

### **6. CSE的限制与挑战**

尽管CSE是一种强大的优化技术，但在实际应用中仍然存在一些限制和挑战：

#### **6.1 作用域限制**

CSE要求被消除的表达式必须被等价表达式词法支配。在某些情况下，表达式之间没有明确的词法支配关系，导致CSE无法应用。

**示例**：

```sml
SWITCH(VAR v, [
  PRIMOP(+, [VAR a, VAR b], x, A),
  B,
  PRIMOP(+, [VAR a, VAR b], y, C)
])
```

在这个例子中，`PRIMOP(+, [VAR a, VAR b], ...)` 在两个不同的分支中被计算了两次。理论上，可以将`a + b`的计算提升到`SWITCH`之前，但这样做存在两个问题：

1. **性能问题**：如果分支`B`被大多数情况下执行，提升后的计算可能会导致不必要的计算开销。
2. **副作用问题**：如果`PRIMOP(+, [VAR a, VAR b], ...)`具有副作用（如可能溢出），提升可能会改变程序的行为。

因此，对于具有副作用的操作符，CSE的应用需要谨慎。

#### **6.2 CSE与其他优化技术的结合**

为了克服CSE的限制，通常需要结合其他优化技术，如向上提升和β展开，以实现更有效的优化效果。

**示例**：

通过向上提升，将循环不变式提升到循环外部，再应用CSE消除重复计算，从而实现循环不变式提升的优化效果。

#### **6.3 纯函数与非纯函数的区分**

CSE在应用时，需要区分“纯函数”和“非纯函数”：

- **纯函数**：不改变或检查存储，不引发异常的操作符，如`SELECT`、`RECORD`等。
- **非纯函数**：可能改变存储或引发异常的操作符，如赋值操作符（`:=`）、算术操作符（可能溢出）等。

对于纯函数操作符，CSE的应用更为安全和有效；而对于非纯函数操作符，必须确保消除操作不会引入副作用或改变程序行为。

### **7. 总结**

**第九章 公共子表达式（Common Subexpressions）**详细探讨了在CPS优化过程中，通过识别并消除重复计算的表达式来提升程序性能的技术。关键要点包括：

1. **CSE的定义与基本原理**：理解CSE如何通过消除重复计算来减少程序的执行次数，提高运行效率。
2. **CSE在CPS中的应用条件**：确保被消除的表达式被等价表达式词法支配，避免作用域冲突和副作用问题。
3. **具体示例分析**：通过具体的CPS代码示例，展示如何识别和消除重复计算，以及优化后的效果。
4. **CSE与其他优化技术的结合**：通过结合向上提升和β展开，实现更有效的优化，特别是在循环优化中的应用。
5. **CSE的限制与挑战**：识别CSE应用中的作用域限制和副作用问题，确保优化的安全性和正确性。

通过合理应用CSE，结合向上提升等其他优化技术，编译器能够生成高效、紧凑的CPS程序，充分利用重复计算消除带来的优化机会，提高程序的整体性能和运行效率。

---

如果您对**第九章 公共子表达式（Common Subexpressions）**中的任何具体部分有进一步的问题或需要更深入的解释，请随时提问！

### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------
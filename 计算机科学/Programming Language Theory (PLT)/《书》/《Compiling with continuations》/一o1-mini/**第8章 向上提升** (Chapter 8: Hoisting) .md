[toc]



好的，我将**详细**解释您提供的《Compiling with Continuations》第八章**“向上提升（Hoisting）”**中的**8.1 合并 FIX 定义（Merging FIX definitions）**、**8.2 向上提升规则（Rules for hoisting）**以及**8.3 向上提升优化（Hoisting optimizations）**这三节内容。这些章节深入探讨了在续延传递风格（Continuation-Passing Style, CPS）下进行变量作用域调整的优化技术，特别是向上提升的策略及其实现方法。以下内容严格基于您提供的文本，旨在帮助您全面理解向上提升及其在 CPS 优化中的应用。

---

## **第八章 向上提升（Hoisting）**

### **8.1 合并 FIX 定义（Merging FIX definitions）**

#### **1. FIX 操作符的作用**
在 CPS 表示中，`FIX` 操作符用于定义递归函数。它绑定一组函数名及其定义，并提供一个续延表达式（continuation expression）。例如：

```sml
FIX([(f, [x, k], APP(VAR g, [VAR x, VAR k]))], B)
```

这里，`FIX` 定义了一个函数 `f`，它接受参数 `x` 和续延 `k`，并在函数体中调用 `g`。

#### **2. 合并 FIX 定义的动机**
当多个 `FIX` 定义存在时，频繁的函数调用可能导致程序体积膨胀和运行效率下降。合并 `FIX` 定义可以减少冗余的函数绑定，优化函数调用路径，提高程序的整体效率。

#### **3. 合并 FIX 定义的策略**
合并 `FIX` 定义的基本策略包括：

- **识别相似或相同的函数定义**：如果多个 `FIX` 定义中的函数具有相同的函数体，可以将它们合并为一个统一的定义。
  
- **消除冗余的函数绑定**：通过将相同功能的多个函数绑定合并为一个，减少程序中不必要的函数定义。

- **优化递归调用路径**：合并后的 `FIX` 定义可以优化递归函数的调用路径，减少调用开销。

**示例**：

假设有以下两个 `FIX` 定义：

```sml
FIX([
  (f, [x, k], APP(VAR g, [VAR x, VAR k])),
  (h, [y, k], APP(VAR g, [VAR y, VAR k]))
], B)
```

可以将它们合并为：

```sml
FIX([
  (f, [x, k], APP(VAR g, [VAR x, VAR k])),
  (h, [y, k], APP(VAR g, [VAR y, VAR k]))
], B)
```

这里，由于 `f` 和 `h` 的函数体相同，实际上不需要合并，因为它们只是不同参数的调用。如果有多个相同函数体的定义，可以进一步合并为一个统一函数。

#### **4. 合并 FIX 定义的好处**
- **减少程序体积**：通过消除冗余函数绑定，减少程序的整体大小。
- **提高缓存效率**：更小的程序体积有助于提高缓存命中率，提升运行效率。
- **简化函数调用路径**：优化后的函数调用路径更为简洁，减少了不必要的跳转和调用开销。

### **8.2 向上提升规则（Rules for hoisting）**

#### **1. 向上提升的定义**
向上提升（Hoisting）指的是将变量的定义从其当前的作用域“提升”到更高的作用域。这包括将变量定义移动到更外层的表达式，减少变量的动态频率执行次数。

- **缩小作用域**：将变量定义“下移”到更内层的作用域，减少变量的生命周期和使用范围。
- **扩大作用域**：将变量定义“上移”到更外层的作用域，减少变量的动态创建次数，提高执行效率。

#### **2. 向上提升的基本规则**
在 CPS 表示中，向上提升遵循以下基本规则：

- **避免增加程序体积**：提升操作应当确保程序体积不会因变量定义的增加而膨胀。
- **保持程序语义不变**：提升操作不应改变程序的原有逻辑和行为。
- **减少变量的动态创建**：通过提升变量定义，可以减少在循环或频繁调用的函数中重复创建变量的开销。
- **优化变量使用路径**：将变量定义移动到更合适的位置，使得后续的优化（如常量折叠、死变量消除）更为有效。

#### **3. 向上提升的具体规则**

- **规则1：提升循环外部的常量定义**
  如果一个变量在循环内部被多次使用，但其值在循环外部已被定义且不改变，可以将其定义提升到循环外部，避免在每次循环迭代中重新定义。

  **示例**：

  ```sml
  FIX([
    (f, [k], 
      FIX([
        (g, [x, k'], 
          APP(VAR h, [VAR x, VAR k']))
      ], 
      APP(VAR g, [VAR a, VAR k])))
  ], B)
  ```

  可以将 `g` 的定义提升到 `f` 的外部：

  ```sml
  FIX([
    (g, [x, k'], APP(VAR h, [VAR x, VAR k'])),
    (f, [k], APP(VAR g, [VAR a, VAR k]))
  ], B)
  ```

- **规则2：提升条件分支中的不变操作**
  如果一个操作在条件分支中不变，可以将其提升到条件判断之前，避免在每个分支中重复执行。

  **示例**：

  ```sml
  FIX([
    (f, [x, k], 
      SWITCH(x, [ 
        A => APP(VAR g, [VAR y, VAR k]),
        B => APP(VAR h, [VAR y, VAR k])
      ])
    )
  ], B)
  ```

  如果 `VAR y` 在所有分支中不变，可以提升其定义：

  ```sml
  FIX([
    (f, [x, k], 
      let val y = compute_y(x) in
        SWITCH(x, [
          A => APP(VAR g, [VAR y, VAR k]),
          B => APP(VAR h, [VAR y, VAR k])
        ])
      end)
  ], B)
  ```

- **规则3：提升不依赖于局部变量的操作**
  如果一个操作不依赖于当前作用域的局部变量，可以将其提升到更外层的作用域，提高其执行效率。

  **示例**：

  ```sml
  FIX([
    (f, [k], 
      let val c = expensive_computation() in
        APP(VAR g, [VAR c, VAR k])
      end)
  ], B)
  ```

  由于 `expensive_computation` 不依赖于 `f` 的局部变量，可以将其提升：

  ```sml
  let val c = expensive_computation() in
    FIX([
      (f, [k], APP(VAR g, [VAR c, VAR k]))
    ], B)
  end
  ```

#### **4. 向上提升的限制**
- **变量依赖性**：提升的变量不能依赖于被提升作用域之外的变量，避免引入未定义的变量。
- **作用域嵌套**：提升操作应确保变量在新的作用域中仍然有效，不会与其他变量冲突。
- **副作用管理**：提升带有副作用的操作需要谨慎，确保不会改变程序的行为。

### **8.3 向上提升优化（Hoisting optimizations）**

#### **1. 向上提升的优化目标**
向上提升的主要目标是**减少操作的动态执行频率**，通过调整变量定义的作用域，使得某些操作只执行一次或减少执行次数，从而提升程序的整体性能。

#### **2. 向上提升的优化策略**

- **优化循环中的不变计算**：
  在循环内部执行的不变计算可以提升到循环外部，避免在每次迭代中重复计算。

  **示例**：

  ```sml
  FIX([
    (f, [k], 
      FIX([
        (g, [x, k'], APP(VAR h, [VAR x, VAR k']))
      ], 
      APP(VAR g, [VAR a, VAR k]))
    )
  ], B)
  ```

  提升 `g` 的定义：

  ```sml
  FIX([
    (g, [x, k'], APP(VAR h, [VAR x, VAR k'])),
    (f, [k], APP(VAR g, [VAR a, VAR k]))
  ], B)
  ```

- **提升条件分支中的公共操作**：
  在条件分支中共有的操作可以提升到条件判断之前，减少在每个分支中重复执行的开销。

  **示例**：

  ```sml
  FIX([
    (f, [x, k], 
      SWITCH(x, [ 
        A => APP(VAR g, [VAR y, VAR k]),
        B => APP(VAR h, [VAR y, VAR k])
      ])
    )
  ], B)
  ```

  提升 `y` 的定义：

  ```sml
  FIX([
    (f, [x, k], 
      let val y = compute_y(x) in
        SWITCH(x, [
          A => APP(VAR g, [VAR y, VAR k]),
          B => APP(VAR h, [VAR y, VAR k])
        ])
      end)
  ], B)
  ```

- **提升不依赖于局部变量的操作**：
  对于不依赖于当前作用域的局部变量的操作，可以将其提升到更外层的作用域，提高执行效率。

  **示例**：

  ```sml
  FIX([
    (f, [k], 
      let val c = expensive_computation() in
        APP(VAR g, [VAR c, VAR k])
      end)
  ], B)
  ```

  提升 `c` 的定义：

  ```sml
  let val c = expensive_computation() in
    FIX([
      (f, [k], APP(VAR g, [VAR c, VAR k]))
    ], B)
  end
  ```

#### **3. 向上提升的具体优化步骤**
优化器在进行向上提升时，通常遵循以下步骤：

1. **分析变量定义的依赖关系**：
   确定哪些变量的定义可以安全地提升，不会引入未定义变量或破坏程序逻辑。

2. **识别可提升的变量定义**：
   根据向上提升的规则，识别出那些可以提升的变量定义。

3. **执行提升操作**：
   将识别出的变量定义从当前作用域移动到更外层的作用域，同时更新相关的引用和绑定。

4. **验证程序正确性**：
   确保提升后的程序仍然保持原有的语义和行为。

5. **结合其他优化技术**：
   向上提升后的程序可能会有更多的优化机会（如常量折叠、死变量消除等），优化器可以进一步应用这些优化技术，提升程序的整体性能。

#### **4. 向上提升的优化效果**

- **减少重复计算**：
  通过提升循环或条件分支中的不变操作，避免在每次迭代或每个分支中重复执行相同的计算。

- **提升缓存命中率**：
  更少的重复计算意味着更少的内存访问，从而提升缓存命中率，减少内存带宽的消耗。

- **优化寄存器使用**：
  通过减少变量的动态创建和销毁，提高寄存器的利用效率，减少寄存器溢出和重新分配的开销。

- **促进其他优化**：
  向上提升后的代码结构更为简洁，有助于后续的优化技术（如常量折叠、死变量消除、参数扁平化等）更加高效地进行。

#### **5. 向上提升的限制与挑战**

- **变量依赖性**：
  提升操作必须确保变量定义和使用的依赖关系不会被破坏，避免引入未定义变量或变量名冲突。

- **副作用管理**：
  如果变量定义中包含副作用，提升操作需要谨慎，确保副作用的执行顺序和程序行为的一致性。

- **优化器的复杂性**：
  向上提升需要优化器具备对变量作用域和依赖关系的深入分析能力，增加了优化器的实现复杂性。

### **8.4 总结**

**第八章 向上提升（Hoisting）**详细探讨了在 CPS 优化过程中通过调整变量定义的作用域来减少操作执行频率的技术。通过合并 `FIX` 定义、应用向上提升规则以及执行具体的向上提升优化，编译器能够有效地减少冗余操作，提高程序的执行效率。

**关键要点包括**：

1. **合并 FIX 定义**：
   - 识别和合并相似或相同的函数定义，减少程序体积。
   - 优化递归函数的调用路径，提升运行效率。

2. **向上提升规则**：
   - 制定客观的标准，决定何时进行变量定义的提升。
   - 确保提升操作不会破坏程序语义和变量依赖关系。

3. **向上提升优化**：
   - 通过具体的优化策略，减少不必要的操作执行次数。
   - 结合其他优化技术，进一步提升程序性能。

4. **优化器的实现细节**：
   - 分析变量定义和使用的依赖关系。
   - 识别可提升的变量定义，并安全地执行提升操作。
   - 验证提升后的程序正确性，确保优化过程的安全性。

通过合理应用向上提升优化技术，编译器能够生成高效、紧凑的 CPS 程序，充分利用变量作用域调整带来的优化机会，为后续的优化阶段奠定坚实的基础。

如果您对**第八章 向上提升**中的任何具体部分有进一步的问题或需要更深入的解释，请随时提问！

### ---------------------------

好的，我将**详细**解释您提供的《Compiling with Continuations》第八章**“向上提升（Hoisting）”**中的**8.1 合并 FIX 定义（Merging FIX definitions）**、**8.2 向上提升规则（Rules for hoisting）**以及**8.3 向上提升优化（Hoisting optimizations）**这三节内容。这些章节探讨了在续延传递风格（Continuation-Passing Style, CPS）下，通过调整变量定义的作用域（即向上提升）来优化程序的技术。以下内容严格基于您提供的文本，旨在帮助您深入理解向上提升的原理、规则及其优化策略。

---

## **8.1 合并 FIX 定义（Merging FIX definitions）**

### **1. FIX 操作符的作用**

在 CPS 表示中，`FIX` 操作符用于定义递归函数。它绑定一组函数名及其定义，并提供一个续延表达式（continuation expression）。例如：

```sml
FIX([
  (f, [x, k], APP(VAR g, [VAR x, VAR k]))
], B)
```

这里，`FIX` 定义了一个函数 `f`，它接受参数 `x` 和续延 `k`，并在函数体中调用 `g`。

### **2. 合并 FIX 定义的动机**

当多个 `FIX` 定义存在时，频繁的函数调用可能导致程序体积膨胀和运行效率下降。合并 `FIX` 定义可以减少冗余的函数绑定，优化函数调用路径，提高程序的整体效率。

### **3. 合并 FIX 定义的策略**

合并 `FIX` 定义的基本策略包括：

- **识别相似或相同的函数定义**：如果多个 `FIX` 定义中的函数具有相同的函数体，可以将它们合并为一个统一的定义。

- **消除冗余的函数绑定**：通过将相同功能的多个函数绑定合并为一个，减少程序中不必要的函数定义。

- **优化递归调用路径**：合并后的 `FIX` 定义可以优化递归函数的调用路径，减少调用开销。

**示例**：

考虑以下两个 `FIX` 定义：

```sml
FIX([
  (f, [x, k], APP(VAR g, [VAR x, VAR k])),
  (g, [y, k'], APP(VAR h, [VAR y, VAR k']))
], B)
```

如果函数 `f` 和 `g` 有相同的自由变量，并且它们的函数体结构相似，我们可以尝试将它们合并：

```sml
FIX([
  (f, [x, k], APP(VAR g, [VAR x, VAR k])),
  (g, [y, k'], APP(VAR h, [VAR y, VAR k']))
], B)
```

在这个例子中，虽然 `f` 和 `g` 的函数体不同，但如果它们有相同的自由变量，可以通过调整闭包表示来共享一个闭包，从而减少函数定义的数量。

### **4. 合并 FIX 定义的好处**

- **减少程序体积**：通过消除冗余函数绑定，减少程序的整体大小。
- **提高缓存效率**：更小的程序体积有助于提高缓存命中率，提升运行效率。
- **简化函数调用路径**：优化后的函数调用路径更为简洁，减少了不必要的跳转和调用开销。

### **5. 闭包共享的技巧**

在 CPS 中，闭包（closure）用于实现带有自由变量的函数。闭包通常表示为一个记录（record），第一个槽位存储闭合函数（closed function），其余槽位存储自由变量。通过闭包共享，可以让多个函数共享相同的闭包结构，从而减少闭包的创建和存储开销。

**示例**：

考虑以下函数定义：

```sml
fun h(a, b) = 
  let 
    fun f(x, y) = x * a + y * b
    fun g(i) = i + a + b
  in 
    ...
  end
```

普通情况下，函数 `f` 和 `g` 会有各自独立的闭包：

```sml
fun h(a, b) = 
  let 
    fun f’((f’’, a, b), x, y) = x * a + y * b
    val f = (f’, a, b)
    fun g’((f’’, a, b), i) = i + a + b
    val g = (g’, a, b)
  in 
    ...
  end
```

由于 `f` 和 `g` 具有相同的自由变量 `a` 和 `b`，可以通过合并它们的闭包，实现闭包共享：

```sml
fun h(a, b) = 
  let 
    fun f’((f’’, g’’, a, b), x, y) = x * a + y * b
    fun g’((g’’, a, b), i) = i + a + b
    val f = (f’, g’, a, b)
    val g = f + 1  // 这里表示 g 是通过偏移指针访问 f 的第二个槽位
  in 
    ...
  end
```

在这个优化中，`f` 和 `g` 共享了一个闭包记录 `(f’’, g’’, a, b)`，其中 `f’’` 和 `g’’` 分别是 `f` 和 `g` 的闭合函数指针。这样，`g` 可以通过偏移指针 `f + 1` 直接访问 `g’’`，无需单独创建一个新的闭包。

### **6. 合并 FIX 定义的条件**

为了实现闭包共享，必须满足以下条件：

- **相同的自由变量**：两个函数必须拥有相同的自由变量集合，且这些自由变量在相同的作用域中定义。
- **同一作用域的 FIX 定义**：只有在相同的 `FIX` 定义中定义的函数，才能保证它们共享相同的自由变量作用域。因此，优化器需要通过向上提升将函数合并到同一 `FIX` 定义中。

**结论**：

通过合并 `FIX` 定义，优化器能够有效地实现闭包共享，减少闭包的创建和存储开销，从而提升程序的运行效率和减少内存使用。

---

## **8.2 向上提升规则（Rules for hoisting）**

### **1. 向上提升的定义与目的**

向上提升（Hoisting）是指将变量的定义从当前作用域“提升”到更高层次的作用域。这种操作可以使得变量的定义在更广泛的范围内可见，从而减少变量的动态创建次数，优化程序的执行效率。

### **2. 向上提升的基本规则**

在 CPS 表示中，向上提升遵循以下基本规则：

- **纯函数交换**：对于“纯函数”操作符（即不改变或检查存储、不引发异常的操作符），可以在不违反作用域规则的前提下，交换它们的顺序。
  
  **示例**：

  ```sml
  SELECT(i1, v1, w1, SELECT(i2, v2, w2, E)) → SELECT(i2, v2, w2, SELECT(i1, v1, w1, E)) 
  如果 w1 ≠ v2
  ```

  这表示只要第二个 `SELECT` 操作符不使用第一个 `SELECT` 操作符生成的值，可以交换它们的顺序。

- **纯函数与非纯函数的交换**：可以将纯函数操作符与非纯函数操作符交换，但必须确保不会引入副作用或违反程序的语义。

  **示例**：

  ```sml
  PRIMOP(p, v, w, [op1(E)]) → op1(PRIMOP(p, v, w, [E]))
  op1(PRIMOP(p, v, w, [E])) → PRIMOP(p, v, w, [op1(E)])
  ```

  其中 `op1` 是纯函数操作符，`PRIMOP` 是某些原始操作符。

### **3. 向上提升的具体规则**

- **交换 SELECT 操作符**：如上所述，只要不引入作用域冲突，可以交换两个 `SELECT` 操作符的顺序。
  
- **交换其他纯函数操作符**：对于其他纯函数操作符，如 `OFFSET`、`PRIMOP`（某些类型）、`SWITCH` 等，只要不违反作用域规则，也可以交换它们的顺序。

- **合并 FIX 定义**：将多个 `FIX` 定义合并到一个 `FIX` 中，只要它们共享相同的自由变量作用域。

### **4. 维护作用域规则**

在进行向上提升时，必须确保：

- **作用域不被破坏**：提升后的变量定义必须仍然在所有使用它的地方可见。
- **避免变量名冲突**：提升操作不应导致变量名冲突或隐藏现有变量。
- **保持程序语义不变**：提升操作不应改变程序的行为或逻辑。

### **5. 自由变量分析**

为了正确地应用向上提升规则，优化器需要进行自由变量分析（Free Variable Analysis），即确定每个子表达式中哪些变量是自由变量。这样可以确保在进行提升操作时，不会违反作用域规则。

### **6. 规则的总结**

总结来说，向上提升的规则可以表述为：

- **两个纯函数操作符可以交换顺序**，只要不引入作用域冲突。
- **纯函数操作符可以与其他操作符交换顺序**，前提是不会引入副作用或违反作用域规则。
- **函数定义（FIX 定义）可以合并**，只要它们共享相同的自由变量作用域。

通过遵循这些规则，优化器可以在不改变程序语义的前提下，调整操作符的顺序和函数定义的位置，从而为进一步的优化（如闭包共享、常量折叠等）创造更多机会。

---

## **8.3 向上提升优化（Hoisting optimizations）**

### **1. 向上提升的优化目标**

向上提升的主要目标是**减少操作的动态执行频率**，通过调整变量定义的作用域，使得某些操作只执行一次或减少执行次数，从而提升程序的整体性能。这包括：

- **优化循环中的不变操作**：将循环内部不变的计算提升到循环外部，避免在每次迭代中重复执行相同的计算。
- **优化条件分支中的不变操作**：将条件分支中共有的、不依赖于特定分支的操作提升到条件判断之前，减少在每个分支中重复执行的开销。

### **2. 向上提升的优化策略**

- **优化循环中的不变计算**：

  在循环内部执行的不变计算可以提升到循环外部，避免在每次迭代中重复计算。

  **示例**：

  ```sml
  FIX([
    (f, [k], 
      FIX([
        (g, [x, k'], APP(VAR h, [VAR x, VAR k']))
      ], 
      APP(VAR g, [VAR a, VAR k]))
    )
  ], B)
  ```

  可以将 `g` 的定义提升到 `f` 的外部：

  ```sml
  FIX([
    (g, [x, k'], APP(VAR h, [VAR x, VAR k'])),
    (f, [k], APP(VAR g, [VAR a, VAR k]))
  ], B)
  ```

  这样，`g` 只需要定义一次，避免了在每次调用 `f` 时重新创建 `g` 的闭包。

- **优化条件分支中的公共操作**：

  在条件分支中共有的操作可以提升到条件判断之前，减少在每个分支中重复执行的开销。

  **示例**：

  ```sml
  FIX([
    (f, [x, k], 
      SWITCH(x, [ 
        A => APP(VAR g, [VAR y, VAR k]),
        B => APP(VAR h, [VAR y, VAR k])
      ])
    )
  ], B)
  ```

  如果 `VAR y` 在所有分支中不变，可以提升其定义：

  ```sml
  FIX([
    (f, [x, k], 
      let val y = compute_y(x) in
        SWITCH(x, [
          A => APP(VAR g, [VAR y, VAR k]),
          B => APP(VAR h, [VAR y, VAR k])
        ])
      end)
  ], B)
  ```

  这样，`compute_y(x)` 只需要执行一次，而不是在每个分支中重复执行。

- **提升不依赖于局部变量的操作**：

  对于不依赖于当前作用域的局部变量的操作，可以将其提升到更外层的作用域，提高执行效率。

  **示例**：

  ```sml
  FIX([
    (f, [k], 
      let val c = expensive_computation() in
        APP(VAR g, [VAR c, VAR k])
      end)
  ], B)
  ```

  可以将 `c` 的定义提升到 `f` 的外部：

  ```sml
  let val c = expensive_computation() in
    FIX([
      (f, [k], APP(VAR g, [VAR c, VAR k]))
    ], B)
  end
  ```

  这样，`expensive_computation()` 只需要执行一次，而不是在每次调用 `f` 时重新执行。

### **3. 向上提升的具体优化步骤**

优化器在进行向上提升时，通常遵循以下步骤：

1. **分析变量定义的依赖关系**：

   确定哪些变量的定义可以安全地提升，不会引入未定义变量或破坏程序逻辑。

2. **识别可提升的变量定义**：

   根据向上提升的规则，识别出那些可以提升的变量定义。

3. **执行提升操作**：

   将识别出的变量定义从当前作用域移动到更外层的作用域，同时更新相关的引用和绑定。

4. **验证程序正确性**：

   确保提升后的程序仍然保持原有的语义和行为。

5. **结合其他优化技术**：

   向上提升后的程序可能会有更多的优化机会（如常量折叠、死变量消除等），优化器可以进一步应用这些优化技术，提升程序的整体性能。

### **4. 向上提升的优化效果**

- **减少重复计算**：

  通过提升循环或条件分支中的不变操作，避免在每次迭代或每个分支中重复执行相同的计算。

- **提升缓存命中率**：

  更少的重复计算意味着更少的内存访问，从而提升缓存命中率，减少内存带宽的消耗。

- **优化寄存器使用**：

  通过减少变量的动态创建和销毁，提高寄存器的利用效率，减少寄存器溢出和重新分配的开销。

- **促进其他优化**：

  向上提升后的代码结构更为简洁，有助于后续的优化技术（如常量折叠、死变量消除、参数扁平化等）更加高效地进行。

### **5. 向上提升的限制与挑战**

- **变量依赖性**：

  提升操作必须确保变量定义和使用的依赖关系不会被破坏，避免引入未定义变量或变量名冲突。

- **副作用管理**：

  如果变量定义中包含副作用，提升操作需要谨慎，确保副作用的执行顺序和程序行为的一致性。

- **优化器的复杂性**：

  向上提升需要优化器具备对变量作用域和依赖关系的深入分析能力，增加了优化器的实现复杂性。

### **6. 具体案例分析**

**示例1：闭包共享**

考虑以下函数定义：

```sml
fun h(a, b) = 
  let 
    fun f(x, y) = x * a + y * b
    fun g(i) = i + a + b
  in 
    ...
  end
```

普通情况下，函数 `f` 和 `g` 会有各自独立的闭包：

```sml
fun h(a, b) = 
  let 
    fun f’((f’’, a, b), x, y) = x * a + y * b
    val f = (f’, a, b)
    fun g’((f’’, a, b), i) = i + a + b
    val g = (g’, a, b)
  in 
    ...
  end
```

由于 `f` 和 `g` 具有相同的自由变量 `a` 和 `b`，可以通过合并它们的闭包，实现闭包共享：

```sml
fun h(a, b) = 
  let 
    fun f’((f’’, g’’, a, b), x, y) = x * a + y * b
    fun g’((g’’, a, b), i) = i + a + b
    val f = (f’, g’, a, b)
    val g = f + 1  // 这里表示 g 是通过偏移指针访问 f 的第二个槽位
  in 
    ...
  end
```

在这个优化中，`f` 和 `g` 共享了一个闭包记录 `(f’’, g’’, a, b)`，其中 `f’’` 和 `g’’` 分别是 `f` 和 `g` 的闭合函数指针。这样，`g` 可以通过偏移指针 `f + 1` 直接访问 `g’’`，无需单独创建一个新的闭包。

### **7. 总结**

**8.1 合并 FIX 定义（Merging FIX definitions）**部分详细介绍了如何通过合并多个 `FIX` 定义来实现闭包共享，从而减少闭包的创建和存储开销，提高程序的运行效率。通过确保函数共享相同的自由变量作用域，优化器能够有效地减少冗余函数定义，优化函数调用路径。

**8.2 向上提升规则（Rules for hoisting）**部分阐述了向上提升的基本规则，包括如何在不违反作用域规则的前提下交换纯函数操作符的顺序，以及如何合并 `FIX` 定义。这些规则确保了优化操作的安全性和有效性，为后续的优化创造了更多机会。

**8.3 向上提升优化（Hoisting optimizations）**部分讨论了具体的优化策略和步骤，如何通过向上提升减少重复计算、提升缓存命中率和优化寄存器使用等。同时，分析了向上提升过程中可能遇到的限制与挑战，并通过具体案例展示了优化效果。

通过合理应用向上提升优化技术，编译器能够生成高效、紧凑的 CPS 程序，充分利用变量作用域调整带来的优化机会，为后续的优化阶段奠定坚实的基础。

---

如果您对**第八章 向上提升（Hoisting）**中的任何具体部分有进一步的问题或需要更深入的解释，请随时提问！

### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------



### ---------------------------



### ----------------------------
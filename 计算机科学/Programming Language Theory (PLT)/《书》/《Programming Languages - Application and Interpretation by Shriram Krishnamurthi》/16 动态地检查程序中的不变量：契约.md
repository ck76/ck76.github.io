[toc]



16.1 以契约实现谓词
16.2 标签、类型和对值的观测
16.3 高阶契约
16.4 便捷语法
16.5 扩展到复合数据结构
16.6 再论契约和观测
16.7 契约和赋值
16.8 契约的组合
16.9 问责

- [16.1 以契约实现谓词](https://lotuc.org/PLAI-cn/chap16/#161)
- [16.2 标签、类型和对值的观测](https://lotuc.org/PLAI-cn/chap16/#162)
- [16.3 高阶契约](https://lotuc.org/PLAI-cn/chap16/#163)
- [16.4 便捷语法](https://lotuc.org/PLAI-cn/chap16/#164)
- [16.5 扩展到复合数据结构](https://lotuc.org/PLAI-cn/chap16/#165)
- [16.6 再论契约和观测](https://lotuc.org/PLAI-cn/chap16/#166)
- [16.7 契约和赋值](https://lotuc.org/PLAI-cn/chap16/#167)
- [16.8 契约的组合](https://lotuc.org/PLAI-cn/chap16/#168)
- [16.9 问责](https://lotuc.org/PLAI-cn/chap16/#169)

在软件开发中，类型系统是一个强有力的工具，用于在编译时捕捉潜在的错误。然而，类型系统并不能捕捉所有可能的程序错误，特别是一些涉及业务逻辑或更复杂不变量的错误。这就是为什么动态检查（例如契约编程）在某些情况下显得非常重要。

### 动态检查和契约

动态检查是一种在程序运行时验证某些属性或不变量的方式。契约（Contracts）是这种方法的一种具体形式，它使得程序员可以明确声明程序的预期行为，并在运行时检查这些行为是否得到满足。

### 契约的基本概念

契约通常包括以下几部分：

1. **前置条件（Preconditions）**：在调用函数之前必须满足的条件。如果前置条件不满足，函数不应被调用。
  
2. **后置条件（Postconditions）**：在函数完成之后必须满足的条件。如果后置条件不满足，表明函数的实现可能有错误。

3. **不变式（Invariants）**：在对象或数据结构的整个生命周期内必须保持为真的条件。例如，一个有序列表的数据结构可能会要求其元素始终按升序排列。

### 契约编程的作用

- **提升代码可靠性**：契约使得程序员能够在代码中明确地表达假设和期望，从而减少逻辑错误。
  
- **文档化代码意图**：契约在某种程度上可以充当代码的文档，帮助理解代码的行为和限制。

- **调试和测试辅助**：在开发和测试过程中，契约可以帮助快速定位错误，确保代码按照预期行为运行。

### 实现契约的方式

契约通常在运行时进行验证，以下是几种实现契约的常见方式：

1. **断言（Assertions）**：断言是一种最简单的契约形式，通常用于检查前置条件和后置条件。断言在条件不满足时会抛出一个异常，从而中断程序的执行。

2. **专用契约库**：一些编程语言提供了专门的契约库，用于更详细地描述和检查契约。比如 Eiffel 语言原生支持契约编程，Python 中有 `PyContracts` 库，Java 中有 `Java Modeling Language (JML)` 等等。

3. **手动检查**：在没有专用库的情况下，开发者可以手动在函数开始和结束时编写代码来检查前置条件和后置条件。

### 契约的限制和权衡

尽管契约编程能够增强代码的可靠性，但它也有一些限制：

- **运行时开销**：契约是运行时检查的，因此它们可能会引入额外的性能开销，特别是在高频调用的代码路径中。

- **不可验证的属性**：有些属性可能无法通过契约完全验证，或者验证这些属性的复杂度太高，使得契约变得不实用。

- **开发负担**：编写和维护契约需要额外的工作量，特别是在复杂系统中，这可能会增加开发的难度和成本。

### 适用场景

契约编程特别适用于以下场景：

- **复杂的业务逻辑**：当程序包含复杂的业务规则或算法时，契约能够帮助确保这些规则在运行时被遵守。

- **接口开发**：在开发公共 API 或接口时，契约可以帮助明确接口的使用方式，并防止误用。

- **关键系统**：在高可靠性要求的系统（如金融系统、医疗系统）中，契约编程可以帮助捕捉运行时的异常情况，从而提高系统的可靠性。

通过动态地检查程序中的不变量和契约编程，开发者可以捕捉到在编译时无法检测到的问题，从而提高软件的质量和稳定性。然而，在使用契约编程时，也需要考虑其性能开销和开发成本，并在适当的场景中进行权衡使用。



# -----------------------------

在这一节中，我们讨论如何通过契约来实现谓词检查。契约是一种用于动态检查程序不变量的机制，它可以确保某些条件在运行时被满足。

### 契约的基本实现

契约的实现思想非常简单：我们定义一个契约，它接收一个谓词函数和一个值。如果该值满足谓词函数的条件，契约就返回该值；否则，契约会报告一个错误。这个契约行为类似于一个检查点，确保值符合预期。

### 实现代码

以下是契约的基本实现代码，使用了 `#lang plai` 语言来模拟动态类型编程：

```scheme
#lang plai

;; 定义一个契约生成器函数
(define (make-contract pred?)
  (lambda (val)
    (if (pred? val) 
        val 
        (blame "violation"))))  ;; 如果不满足谓词，报告错误

;; 定义一个错误报告函数
(define (blame s) 
  (error 'contract "~a" s))

;; 例子：一个非负数的契约
(define non-neg?-contract
  (make-contract
   (lambda (n) (and (number? n)  ;; 检查是否为数字
                    (>= n 0))))) ;; 检查是否为非负数

;; 使用契约的函数：计算平方根
(define (real-sqrt-1 x)
  (sqrt (non-neg?-contract x))) ;; 通过契约检查参数

;; 另一种形式的实现
(define (real-sqrt-2 x)
  (begin
    (non-neg?-contract x)  ;; 先检查契约
    (sqrt x)))             ;; 然后计算平方根
```

### 代码解释

1. **`make-contract` 函数**：这是一个契约生成器。它接受一个谓词函数 `pred?` 作为参数，返回一个新的函数。这个新函数接收一个值 `val`，并根据 `pred?` 对 `val` 进行检查。如果检查通过，直接返回该值；否则调用 `blame` 函数报错。

2. **`blame` 函数**：当契约不满足时，该函数用于报告错误。它通过调用 `error` 函数终止程序执行，并输出错误信息。

3. **`non-neg?-contract` 例子**：这是一个具体的契约示例，检查一个值是否为非负数。它使用了 `make-contract` 函数，将一个匿名的谓词函数传递给它，这个谓词函数检查值是否为数字以及是否为非负数。

4. **`real-sqrt-1` 函数**：这是一个计算平方根的函数，但在计算之前，它通过契约检查参数是否为非负数。如果检查通过，则返回平方根；否则，报错。

5. **`real-sqrt-2` 函数**：这是另一种实现形式，它先执行契约检查，然后再计算平方根。这种形式在某些情况下更清晰，因为它将契约检查明确地放在函数的开始部分。

### 契约的应用

- **提高代码的健壮性**：通过在关键函数前加上契约检查，可以避免不符合预期的输入，减少潜在的运行时错误。
- **增强文档性**：契约清晰地表达了函数的预期输入条件，这有助于代码的可读性和可维护性。
- **简化调试**：当契约检查失败时，系统会直接报错，提示错误的具体位置和原因，方便开发者进行调试。

### 适用场景

契约特别适用于以下场景：
- 需要动态验证的业务逻辑，例如参数验证、函数返回值验证等。
- 接口开发，尤其是在公开 API 时，可以通过契约来明确接口的使用条件。
- 复杂算法或数据结构的实现中，契约可以用来确保各种不变量在整个程序生命周期内保持一致。

总之，契约为动态类型语言中的不变量检查提供了一个强有力的工具，它不仅增强了代码的健壮性，还提升了代码的可读性和可维护性。


# -----------------------------

在这一节中，我们讨论了动态检查程序中的不变量，特别是在处理具有复杂类型（例如函数类型）时所遇到的挑战。

### 契约和类型检查的基本挑战

#### 1. **标签（Tag）与类型的区别**：
   - **标签**：在大多数编程语言中，运行时系统对值的类型信息存储非常有限，这种信息通常被称为“标签”。标签用于标识值的大类，例如数字、字符串、函数、对象等。
   - **类型**：类型包含更丰富的信息，包括值的结构、参数类型和返回类型等。类型系统在编译时提供静态检查，而标签则是在运行时用于简单地标识值的基本类别。

#### 2. **标签的局限性**：
   - 对于基本数据类型，如数字或字符串，标签和类型可以很好地对应。例如，数字值带有“number”标签，字符串值带有“string”标签。
   - 对于复杂数据结构，如向量或对象，标签可能仅指示其为“向量”或“对象”，但无法描述其内部元素的类型或结构。
   - 对于函数，标签只能告诉我们这是一个函数，而无法描述函数的输入输出类型。例如，在JavaScript中，`typeof`运算符返回“function”作为函数的标签，但并不提供关于参数或返回值类型的信息。

#### 3. **处理结构化值**：
   - 对于像向量这样的结构化值，虽然运行时可能无法直接获取内部元素的类型信息，但我们可以遍历这些结构来收集所需的信息。
   - 类似地，对象可能只标识为“对象”，但在支持反射（reflection）的语言中，可以动态地检查对象的属性和方法。

### 处理函数契约的局限性

函数类型契约的实现是一个复杂的挑战，因为函数在运行时的表示非常有限。运行时系统只能确认一个值是否是函数，而无法检查更详细的类型信息（如参数类型和返回类型）。这导致函数契约在动态检查时只能确保一个值是函数，但无法进一步确认它是否符合预期的输入输出类型。

### 示例与思考

#### 编写契约检查偶数链表：

以下是一个简单的契约，用于检查链表是否只包含偶数：

```scheme
(define list-of-even?-contract
  (make-contract
   (lambda (l)
     (and (list? l)             ; 检查是否为链表
          (andmap number? l)    ; 检查链表中的每个元素是否为数字
          (andmap even? l)))))  ; 检查每个数字是否为偶数
```

这个契约对链表中的每个元素进行检查，确保它们都是偶数。如果该语言有静态类型系统，可以在编译时直接推断出链表是数的链表，就不需要前两个检查。

### 处理函数契约的思路

尽管我们无法直接检查函数的输入输出类型，但这并不意味着我们必须放弃对函数契约的检查。可以考虑以下思路：
- **运行时监控**：在函数的调用过程中检查实际传递的参数和返回的结果，动态验证是否符合期望的类型。
- **组合契约**：在更高层次的抽象中组合多个简单契约，通过对函数行为的观测来推测它的符合性。

### 总结

在动态语言中，契约提供了一种灵活的方式来检查程序的不变量。然而，由于运行时类型信息的限制，特别是对于函数类型的检查，契约面临着一些挑战。通过合理地设计契约，我们仍然可以在一定程度上确保程序行为的正确性，即使无法覆盖所有可能的错误。这种权衡也是动态检查与静态类型系统之间的一个重要区别。


# -----------------------------

### 高阶契约的概念与实现

高阶契约是用于处理更复杂的情况，特别是函数契约。与基本的契约不同，高阶契约不仅在函数被创建时进行检查，还会在函数被调用时动态地验证输入输出的类型或其他属性。

#### 核心概念

1. **即时契约 vs. 高阶契约**：
   - **即时契约（Immediate Contracts）**：这是我们之前实现的简单契约，它们立即检查值并确保符合某个谓词（如非负数、偶数等）。即时契约对基本类型或数据结构的检查非常有效，但对函数或其他高阶类型的检查有局限性。
   - **高阶契约（Higher-Order Contracts）**：针对函数等复杂类型的契约。高阶契约不仅在函数被创建时检查其类型，还会在函数调用时对其输入和输出进行动态检查。

2. **契约延迟检查**：
   - 对于函数类型的契约，直接在创建时检查输入和输出是不现实的。因此，检查会被延迟到函数实际调用时。
   - 这种延迟检查可以确保当函数被应用时，输入符合定义域的契约，输出符合值域的契约。

#### 实现高阶契约

```scheme
(define (immediate pred?)
  (lambda (val)
    (if (pred? val) val (blame val))))

(define (function dom rng)
  (lambda (val)
    (if (procedure? val)
        (lambda (x) (rng (val (dom x))))
        (blame val))))
```

- **immediate** 函数是基本的即时契约，它检查传入的值是否符合给定的谓词。
- **function** 函数是高阶契约的核心，它接受两个契约：`dom`（定义域契约）和 `rng`（值域契约）。它首先检查 `val` 是否是一个函数，然后返回一个代理函数，该函数在调用时对输入进行 `dom` 契约检查，对输出进行 `rng` 契约检查。

#### 示例：封装函数

```scheme
(define num?-con (immediate number?))

(define a1
  (guard (function num?-con num?-con)
         add1))
```

- 这里我们封装了一个简单的 `add1` 函数，并为其添加了契约。封装后的 `a1` 函数将确保输入和输出都为数字。

通过这些封装，当 `a1` 被调用时，契约系统会确保传入的参数为数字，并且返回值也是数字。任何违反契约的行为都会被及时捕捉并报告。

#### 违规情况的检测与处理

在上述高阶契约的示例中，可能会发生以下三种违规情况：

1. **非函数值**：尝试将非函数值应用于函数契约。
2. **参数类型不匹配**：传递给函数的参数不符合定义域契约。
3. **返回值类型不匹配**：函数返回的值不符合值域契约。

### 深入探讨

1. **嵌套契约的延迟检查**：
   - 在更复杂的情况下，如处理高阶函数（如 `d/dx`），嵌套的契约将延迟检查，直到实际的函数调用发生。
   - 这意味着可能存在违反契约的潜在风险，但这些风险只会在特定情况下暴露出来。

2. **改进错误报告**：
   - 可以通过更详细的错误信息来改进契约系统。例如，当契约被违反时，报告是哪个契约（定义域或值域）出了问题，并给出更详细的上下文信息，帮助开发者快速定位问题。

### 练习

- **违反契约的方式**：
  - 为函数契约创建的 `d/dx` 有多个可能的违规点：传递非函数、函数接受非数字参数、返回非数字值等。
  - 通过编写测试用例，尝试触发这些不同的违规情况，并观察契约系统的行为。

通过理解和实现高阶契约，我们可以动态地检查更复杂的不变量，确保在运行时捕捉到可能的错误。这种动态检查机制虽然在性能上可能会带来开销，但对于捕捉复杂逻辑错误非常有用，是静态类型系统的有力补充。


# -----------------------------

### 便捷语法与契约系统的优化

在编写契约系统时，我们经常需要权衡可读性、效率和代码的简洁性。前面讨论了两种封装契约的风格，各自有优缺点。为了优化契约的使用，我们可以引入便捷的语法（通常是宏），使得开发人员能够更自然、更高效地使用契约。

#### 两种封装风格的回顾

1. **风格1：在值使用处进行契约检查**
   - 在`real-sqrt-1`的例子中，契约被直接应用于函数体内部的值使用上。这确保了每次使用值时都进行契约检查。
   - **缺点**：
     - 可能忘记某些使用位置的契约检查。
     - 每次使用值时都会重复进行契约检查，效率较低。
     - 契约检查和功能行为混合在一起，降低代码可读性。

2. **风格2：在函数入口进行契约检查**
   - `real-sqrt-2`的例子展示了在函数入口处通过`begin`语法分离契约检查和功能实现。这种方法更接近传统的断言系统。
   - **缺点**：
     - 无法处理高阶函数的契约检查，因为封装的值需要被传递。

#### 便捷语法的引入

为了解决上述缺点，可以引入便捷的语法，通过宏自动生成必要的契约封装代码。例如，使用`define/contract`宏，开发人员可以在函数定义时直接附加契约：

```scheme
(define/contract (real-sqrt (x :: (immediate positive?)))
  (sqrt x))
```

这个宏的目标是将契约检查逻辑放在函数入口处，并且在函数体内使用经过检查的值。这种做法有以下优点：

- **一次性契约检查**：契约检查仅在函数调用时执行一次，避免了重复检查的开销。
- **清晰的契约与功能分离**：函数体内只处理核心功能逻辑，而契约检查在函数体外处理，使代码更清晰可读。
- **减少遗漏**：通过宏的自动生成，避免了开发人员可能忘记在某些位置进行契约检查的问题。

#### 宏的实现

为了实现这一便捷语法，我们可以定义一个宏`define/contract`，如下所示：

```scheme
(define-syntax (define/contract stx)
  (syntax-case stx (::)
    [(_ (f (id :: c) ...) b)
     (with-syntax ([(new-id ...) (generate-temporaries #'(id ...))])
       #'(define f
           (lambda (new-id ...)
             (let ([id (guard c new-id)]
                   ...)
               b))))]))
```

- **宏解析**：
  - `syntax-case`用于模式匹配宏的输入。
  - `generate-temporaries`用于为每个参数生成临时变量，以便在内部使用经过契约检查的值。
  - 宏生成的代码将契约检查逻辑放在`let`表达式中，以确保所有输入参数在进入函数体之前都经过检查。

- **生成的代码**：
  - 对于上面的`real-sqrt`例子，宏展开后将生成以下代码：
    ```scheme
    (define (real-sqrt new-x)
      (let ([x (guard (immediate positive?) new-x)])
        (sqrt x)))
    ```

#### 结论

通过引入便捷的语法，契约系统变得更加易用，同时也提高了代码的效率和可读性。这种做法展示了如何通过语言级别的优化（如宏）来增强编程体验，使得开发人员在编写复杂程序时可以更自然地使用契约系统，确保程序的健壮性和正确性。


# -----------------------------

### 扩展到复合数据结构的挑战与优化策略

在将契约系统扩展到复合数据结构时，我们遇到了几个关键的挑战。以下是对这些挑战的详细分析，以及可能的优化策略。

#### 1. **性能问题**
   - **问题描述**：契约系统可能会带来严重的性能问题，特别是当契约应用于复杂的递归数据结构时。例如，在平衡二叉搜索树中，理想情况下，插入和查找的时间复杂度是对数级别的。然而，契约检查可能会强制访问整个树，从而导致线性时间复杂度。更糟糕的是，递归结构可能会导致重复检查子树，从而使性能进一步恶化。

   - **优化策略**：可以通过**记忆化（memoization）**来缓解这一问题。每个值在与契约关联时，可以记录它已经通过的契约。如果相同的契约再次应用于该值，可以跳过检查。这种策略特别适用于不可变的数据结构，因为对于不可变的值，一旦契约检查通过，结果就不会再变化。

#### 2. **递归结构的挑战**
   - **问题描述**：递归数据结构中的契约检查特别复杂。例如，在平衡二叉搜索树中，平衡性和顺序性是递归属性，每个子树都需要满足这些属性。如果在插入过程中对每个访问的子树都进行契约检查，可能会导致极大的性能开销。

   - **优化策略**：一种解决方案是**增量检查**，即在构建或修改数据结构时逐步完成契约检查，而不是在每次访问时都进行全面检查。这种策略可以将契约检查的开销分摊到数据结构的修改过程中，从而避免在读取时的重复检查。

#### 3. **惰性检查**
   - **问题描述**：有些数据结构中的某些元素可能根本不会被使用，但契约检查仍然会访问这些元素，这可能不符合用户的期望。比如，检查数链表中所有值是否为偶数的契约，如果用户只关心链表的第一个元素，检查所有元素可能显得多余。

   - **优化策略**：可以考虑**惰性检查（Lazy Evaluation）**。在这种策略下，契约的检查只在值被实际访问时进行。这种延迟检查策略可以减少不必要的开销，并且符合用户期望，即只检查实际使用的部分。然而，这种策略在处理存在别名的数据结构时可能会遇到问题，特别是当数据结构是可变的时。

#### 4. **别名问题**
   - **问题描述**：别名问题在惰性检查中尤为突出。如果两个不同的标识符引用同一个数据结构，而其中一个受到契约保护，另一个则没有，我们必须确保它们都能按预期运行。这种情况下，简单的延迟检查可能不再适用，因为一旦数据结构发生变化，原来的契约可能会失效。

   - **优化策略**：处理别名问题可以通过**更严格的契约管理**来实现，比如确保在不同上下文中应用的契约不会互相冲突。对于可变数据结构，可能需要引入额外的机制来确保契约的正确性和一致性，例如在数据结构变化时重新验证契约。

### 表格总结

| **挑战**           | **问题描述**                                                 | **优化策略**                                                 |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **性能问题**       | 契约检查可能带来线性甚至更高的复杂度，特别是在递归数据结构中。 | 记忆化（Memoization）检查，减少重复计算。                    |
| **递归结构的挑战** | 递归属性需要在每个子树上进行契约检查，可能导致极大的性能开销。 | 增量检查，分摊契约检查的开销，避免在每次访问时进行全面检查。 |
| **惰性检查**       | 对未实际使用的数据元素进行契约检查，可能导致不必要的开销，且不符合用户期望。 | 惰性检查（Lazy Evaluation），仅在值被实际访问时才进行契约检查。 |
| **别名问题**       | 数据结构的多个别名可能导致契约检查失效，特别是在可变数据结构中。 | 更严格的契约管理，确保不同上下文中的契约不会冲突，或在数据结构变化时重新验证契约。 |

### 结论

在复合数据结构中扩展契约系统时，虽然面临诸多挑战，但通过合适的优化策略，如记忆化、增量检查、惰性检查等，可以有效减轻这些问题带来的影响。与此同时，特别是对于动态数据结构，契约系统的设计和实现需要更加细致的处理，以确保契约的正确性和执行效率。


# -----------------------------

### 16.6 再论契约和观测

在讨论契约的实现时，我们遇到了一个普遍且复杂的问题，即如何在保护数据结构的同时，保持程序的正常行为。这一问题在处理复杂数据时尤其显著。具体来说，我们面临的问题可以分为以下几个方面：

#### 1. **观测能力的局限**
   - **函数契约**：在之前的讨论中，我们抱怨过对函数进行契约检查的困难。这是因为在大多数编程语言中，我们对函数的观测能力有限。我们可以知道一个值是否是函数，但无法直接检查其输入输出的类型。这使得我们只能在运行时，通过代理函数来延迟检查契约。

#### 2. **观测能力的过剩**
   - **数据结构契约**：与函数的观测能力不足相反，在数据结构契约中，我们的问题是观测能力过剩。例如，如果我们采用延迟检查链表的策略，那么可能需要使用某种结构体来保存实际的链表数据，并修改 `first` 和 `rest` 函数，以便在检查契约后获取这些结构体中的值。

#### 3. **不一致的观测结果**
   - **类型检查的破坏**：一旦我们引入这些结构体来封装链表，原本用于检查链表的函数（如 `list?`）可能不再返回 `true`，因为封装后的结构体不再是一个真正的链表。这就需要对 `list?`、`cons?`、`pair?` 等函数进行修改，使得它们在遇到这些特殊的表示链表的结构体时仍然返回 `true`。

#### 4. **eq? 的问题**
   - **观测基本问题**：在所有观测函数中，`eq?` 是一个特别棘手的问题。通常情况下，每个值 `eq?` 自己，这在函数中尤其如此。然而，当我们封装函数时，新生成的函数与原始函数显然不是 `eq?` 的，因为它们的行为已经不同，尤其是在处理契约违反时。然而，这种变化意味着恶意的程序模块可以通过检查 `eq?` 来检测一个值是否被契约保护。如果检测到是受保护的值，模块可能会改变行为，绕过契约检查。

### 影响与挑战

1. **一致性问题**：一旦引入契约，我们就面临着如何保持程序中数据结构和函数的一致性问题。契约的引入改变了程序的行为，这在某些情况下可能导致程序行为的不可预见性，特别是在存在别名或者复杂数据结构时。

2. **运行时性能的影响**：为了保证契约检查的完整性，我们需要对原有的数据结构和函数进行封装，这可能会增加运行时的开销，并且在某些情况下会破坏原有程序的性能优化。

3. **程序语义的透明性**：契约的引入可能会导致程序语义的改变，尤其是在引入延迟检查或者封装函数时。这种改变可能导致调试和程序验证的困难，尤其是在存在多层嵌套和复杂的数据结构时。

### 可能的解决方案

1. **全局契约系统支持**：在设计编程语言时，可以从语言层面上支持契约检查，使得契约成为语言的内置特性。这可以避免手动封装和函数行为不一致的问题。

2. **弱观测原则**：在一些情况下，可以考虑设计一个“弱观测”原则，即程序仅在关键点进行契约检查，减少不必要的观测和封装。这种策略可以减少性能开销，并提高契约系统的透明性。

3. **动态语言的契约优化**：对于动态语言，可以引入更智能的契约优化机制，比如动态分析和运行时契约剖析，来判断何时进行契约检查，并对契约系统的行为进行更精细的控制。

### 总结

在引入契约系统时，我们必须谨慎处理程序的观测行为。契约系统可以帮助我们捕捉程序的不变量，但同时也可能导致观测能力的改变，甚至破坏原有程序的行为一致性。解决这些问题需要在语言设计、契约实现以及运行时系统优化之间进行权衡，确保契约系统既能有效工作，又不会对程序的性能和行为带来负面影响。

# -----------------------------

### 16.7 契约和赋值

在讨论契约系统时，我们必须特别关注契约与赋值操作之间的相互作用，尤其是在契约检查具有延迟特性时。这涉及到两大方面的问题：将契约值存储在可变状态中，以及为可变状态本身编写契约。

#### 1. **存储契约值**

当一个契约值被存储在一个可变状态（如变量、数据结构的字段等）中时，我们需要确保契约检查在取值和使用时正确进行。这是通过封装策略来实现的：

- **即时检查**：在存储契约值时，契约会尽可能多地对值进行检查。如果值符合契约，契约会返回原值（或封装的值），以便存储在可变状态中。
- **延迟检查**：如果契约无法立即检查（例如，对函数的契约），封装值将包含“剩余”的契约检查逻辑。当该值最终被取出并使用时，封装中的契约检查将被触发，从而确保契约要求得到满足。

这种封装策略使得即使在赋值操作后，契约检查仍然能够正常进行，不会因为赋值而跳过检查步骤。

#### 2. **为可变数据编写契约**

当我们为可变数据结构（如 box、向量等）编写契约时，问题变得更加复杂。可变数据结构允许其内容在存储后被修改，因此契约不仅要在初始存储时检查，还需要在每次更新时都进行检查。

- **封装数据结构**：为了实现这一点，我们需要为整个数据结构创建一个封装，该封装负责确保每次更新操作都正确应用契约。例如，`set-box!` 操作在更新 box 内容时，必须从封装中检索契约，并对新值应用契约检查。如果新值通过检查，则将封装后的值存储回数据结构中。

- **行为修改**：这意味着我们需要修改数据结构的赋值操作符，使它们能够识别并处理封装后的值，并正确应用契约检查。这确保了无论数据结构的内容如何变化，契约检查都不会被绕过。

#### 3. **赋值与契约违规的时机**

赋值操作与契约之间的相互作用并不会改变违规行为的发生时机：

- **即时契约**：即时契约在值存储或取值时立即进行检查。如果值违反了契约要求，违规会立刻被捕获和报告。

- **延迟契约**：延迟契约在值实际被使用时进行检查。如果延迟契约被违反，违规行为将在使用时被捕获和报告，而不是在赋值操作发生时。

这意味着，即使赋值操作发生在契约检查之前或之后，契约违规的检测时机取决于契约本身的特性，而不是赋值操作的时机。

### 总结

契约与赋值操作的相互作用涉及到确保契约检查在赋值后仍然有效。通过封装策略和修改赋值操作符的行为，我们可以确保即使在数据结构发生变化时，契约检查也能正确执行。即时契约和延迟契约的检查时机不同，但两者都确保契约要求在程序执行过程中得到遵守，不会因为赋值操作而导致违规行为的发生点被推迟或忽略。

# -----------------------------

### 16.8 契约的组合

在前面章节中，我们讨论了如何为简单的数据类型编写契约，并探讨了契约在更复杂的上下文中的应用。现在，让我们讨论如何组合契约。就像我们在类型系统中讨论联合和交叉类型一样，我们也可以考虑契约的联合和交叉，以及取反操作。不过，由于契约和类型的本质不同，我们需要专门针对契约来处理这些问题。

#### 1. **契约的联合（Disjunction of Contracts）**

联合契约是通过“或”操作来组合的。我们可以直接用逻辑 `or` 来组合多个契约的结果。这种组合方式意味着只要有一个契约通过，整个联合契约就会通过。例如，假设我们有两个契约，一个检查是否为正数，另一个检查是否为偶数，那么一个值只要符合其中任何一个契约，它就会被接受。

**实现示例**：

```scheme
(define (or-contract c1 c2)
  (lambda (val)
    (or (c1 val) (c2 val))))
```

这个 `or-contract` 函数组合了两个契约 `c1` 和 `c2`，只要 `val` 通过任意一个契约，整个契约就会通过。

#### 2. **契约的交叉（Conjunction of Contracts）**

交叉契约是通过“与”操作来组合的。我们使用逻辑 `and` 来组合多个契约的结果。这种组合方式要求值必须通过所有子契约的检查。如果任一子契约失败，整个交叉契约就会失败。

**实现示例**：

```scheme
(define (and-contract c1 c2)
  (lambda (val)
    (and (c1 val) (c2 val))))
```

在这个 `and-contract` 中，`val` 必须同时满足 `c1` 和 `c2`，否则契约会失败。

#### 3. **契约的取反（Negation of Contracts）**

取反契约要求一个值不满足给定的契约。我们可以通过对原始契约的谓词结果取反来实现这一点。例如，如果一个契约 `c` 检查一个值是否为正数，那么它的取反契约将检查值是否为非正数。

**实现示例**：

```scheme
(define (not-contract c)
  (lambda (val)
    (not (c val))))
```

在这个 `not-contract` 中，`val` 只有在不满足契约 `c` 时才会通过检查。

#### 4. **延迟和高阶契约的组合**

当我们处理高阶契约（如函数契约）时，联合和交叉契约的实现变得复杂。对于函数契约的取反，我们会遇到语义上的困难：一个契约的取反到底应该检查什么？是否应该拒绝该函数接受某个类型的参数，还是应该拒绝它返回某个类型的值，或者两者都要？在实际操作中，这可能会导致一些不可预见的行为，特别是在未定义域上运行函数时可能导致程序崩溃。

- **交叉契约**：对于交叉契约，值必须通过所有子契约的检查。这要求我们在高阶值上重新封装，并检查所有的定义域和值域契约。
- **联合契约**：联合契约更为复杂，因为任一子契约的失败并不意味着整个契约的失败。相反，系统需要记录每个子契约的成功与失败，当所有子契约都失败时才报告错误。这意味着我们需要额外的状态来记录子契约的执行情况。

**联合契约的实现示例**：

```scheme
(define (or-contract c1 c2)
  (lambda (val)
    (let ([result1 (c1 val)]
          [result2 (c2 val)])
      (or result1 result2))))
```

在多线程环境中，还需要考虑并发执行时的竞争条件，确保在契约检查时不会出现竞态。

### 总结

契约的组合提供了一个灵活的机制来表达复杂的程序不变量。通过联合、交叉和取反操作，我们可以构建强大的契约系统，确保程序在运行时的行为符合预期。然而，在处理高阶和延迟契约时，契约组合变得更加复杂，需要仔细考虑如何实现这些操作，同时保持系统的效率和正确性。

# -----------------------------

### 16.9 问责

本节讨论了如何有效地报告契约违反的情况，特别是在处理复杂系统时的问责问题。理解这个问题的关键是，当系统中的不同模块通过契约相互合作时，如何追踪并准确归咎于引发错误的模块。

#### 1. **问题背景**

考虑到前面提到的 `d/dx` 函数的例子，其中将一个函数作为参数传递并计算其导数。如果我们传递给 `d/dx` 一个不合适的函数（例如 `string-append`），虽然这个函数通过了即时的契约检查（因为它确实是一个函数），但在实际使用时可能会导致错误。当我们将 `d/dx` 的结果应用于一个数时，错误可能发生在 `d/dx` 内部，但实际原因并非 `d/dx` 本身的问题，而是由于我们传递了一个不合适的函数。

#### 2. **传统错误报告的局限性**

在传统的错误报告机制中，当错误发生时，系统会报告当前的调用栈信息。然而，这种方法在处理复杂系统时可能无法准确地归因于导致错误的根本原因。特别是在回调机制中，错误可能是由某个先前的实体引入的，但此时它已经不在调用栈中。因此，错误报告无法指向真正的责任方。

#### 3. **问责（Blame）机制**

为了解决这一问题，契约系统可以引入问责（blame）的概念。通过记录引入契约违反的实体（即代码位置），当发生契约违反时，我们可以准确地将错误归因于正确的地方。

**基本思想**：
- **负位置（Negative Position）**：对应于函数的参数或契约的先验条件。如果函数被赋予了错误的值，则应该归因于调用方。
- **正位置（Positive Position）**：对应于函数的返回值或契约的后验条件。如果函数生成了错误的值，则应该归因于函数本身。

#### 4. **实现问责机制**

在实际实现中，契约不再只是简单的谓词检查，它们还会记录正负位置的标签。当契约违反时，`blame` 函数会根据这些标签生成详细的错误报告。

**示例代码**：
```scheme
(define (guard ctc val pos neg)
  ((ctc pos neg) val))

(define (blame s)
  (error 'contract s))

(define (immediate pred?)
  (lambda (pos neg)
    (lambda (val)
      (if (pred? val) val (blame pos)))))

(define (function dom rng)
  (lambda (pos neg)
    (let ([dom-c (dom neg pos)]
          [rng-c (rng pos neg)])
      (lambda (val)
        (if (procedure? val)
            (lambda (x) (rng-c (val (dom-c x))))
            (blame pos))))))
```

在这个实现中，`guard` 函数负责在契约调用时传递正负位置的标签。`immediate` 和 `function` 契约分别检查即时值和函数，并在发生契约违反时使用 `blame` 函数生成错误报告。

#### 5. **例子：`add1` 和 `d/dx`**

考虑以下例子：
- **封装 `add1` 函数**：通过契约确保输入和输出都是数值。
- **封装 `d/dx` 函数**：确保传递的函数和返回的函数都遵循特定的数值契约。

```scheme
(define a1 (guard (function (immediate number?)
                            (immediate number?))
                  add1
                  "add1 body"
                  "add1 input"))

(define d/dx-a1 (d/dx a1))
```

当我们用 `a1` 处理不合适的输入时，比如字符串 `"x"`，我们可以清楚地看到错误归咎于 `add1 input`。

```scheme
(a1 "x")
; 结果: contract violation at "add1 input"
```

在 `d/dx` 的例子中，我们如果传递一个不合适的函数，如 `number->string`，错误报告将显示为 `d/dx` 传递了错误的输入，或生成了错误的输出。

```scheme
(define bad-dx (d/dx (guard (function (immediate number?)
                                      (immediate string?))
                            number->string
                            "n->s body"
                            "n->s input")))

(bad-dx 10)
; 结果: contract violation at "n->s input"
```

#### 6. **总结**

通过引入问责机制，我们可以显著改善契约违反时的错误报告，准确指示错误的来源。这对调试复杂系统，特别是包含高阶函数和回调机制的系统，尤为重要。问责机制通过记录契约位置，确保错误报告能够准确地反映系统中的责任分配，使得调试过程更加直观和有效。

# -----------------------------

### 第16章：动态地检查程序中的不变量——契约

这一章的核心主题是如何在运行时通过契约（contracts）来确保程序中的某些不变量。这是一个重要的话题，因为静态类型系统虽然强大，但并不能捕捉所有可能的程序行为。为了弥补静态类型系统的不足，程序员可以使用动态检查机制，确保在运行时一些关键的不变量得到维护。

#### 16.1 以契约实现谓词

在本节中，我们引入了契约的基本概念。契约可以看作是对程序输入和输出的一种约束。通过使用谓词（predicate）函数，契约可以动态地检查一个值是否满足某种条件。如果值不满足条件，契约将会抛出一个错误，从而保证程序的正确性。

契约在很多语言中都有类似的实现，通常通过断言机制（assertion）实现。不同于静态类型检查，契约是在运行时检查的，这意味着只有在程序实际运行时，才会检查相关的条件。

#### 16.2 标签、类型和对值的观测

契约的实现依赖于我们对值的观测能力。在动态类型语言中，运行时系统通常使用标签（tag）来表示值的类型。我们可以利用这些标签来编写简单的契约，如检查一个值是否为数字或字符串。

然而，当涉及到更复杂的值（如函数）时，标签的局限性变得明显。因为在大多数语言中，函数只标识为函数类型，而不包含输入输出的详细类型信息。这使得编写检查函数契约变得困难。尽管如此，我们可以通过在函数实际调用时检查契约来部分解决这个问题。

#### 16.3 高阶契约

为了应对函数的契约检查问题，我们引入了高阶契约（higher-order contracts）。高阶契约的关键思想是推迟检查，直到函数实际调用时才执行契约检查。具体而言，我们可以在函数的定义域和值域分别设置契约，并在函数被调用时应用这些契约。

这种方法要求我们将函数封装为代理函数，以便在代理中检查契约。虽然这增加了系统的复杂性，但它提供了一种有效的方法来处理动态类型语言中的函数契约。

#### 16.4 便捷语法

为了简化契约的使用，我们引入了便捷语法。便捷语法通过宏（macro）扩展，为程序员提供了一种简洁且易于使用的契约定义方式。通过使用便捷语法，程序员可以在定义函数时直接指定参数的契约，从而使代码更加清晰，减少了人为错误的可能性。

这种语法糖在提高代码可读性和效率的同时，也增强了契约的健壮性，使得契约的定义更加符合直观的编程习惯。

#### 16.5 扩展到复合数据结构

在处理简单的数据类型之后，我们进一步探讨了如何将契约应用于复合数据结构（如链表、向量和树）。复合数据结构的契约检查面临着性能挑战，因为对整个结构的契约检查可能导致性能瓶颈。特别是在处理递归数据结构时，契约检查可能会带来意外的线性时间复杂度。

为了优化契约的执行，我们可以使用记忆化（memoization）技术，避免重复的契约检查。记忆化允许我们记录已经通过检查的值，并在以后使用时跳过重复检查。这种策略可以大幅提升契约检查的效率，特别是在处理不可变数据结构时。

#### 16.6 再论契约和观测

在本节中，我们讨论了契约检查过程中可能遇到的一个奇怪问题：观测能力的过剩。例如，当我们为链表添加契约时，延迟检查可能会导致链表被封装为一种特殊的结构体，从而影响对链表的正常操作（如使用 `list?` 函数）。此外，封装函数后，它们可能不再与原函数 `eq?`，从而导致一些不期望的副作用。

这个问题提醒我们，在设计契约系统时，需要特别注意如何处理观测操作，以避免对程序行为的意外影响。

#### 16.7 契约和赋值

契约与赋值操作的相互作用是另一个需要关注的点。当契约被延迟检查时，赋值可能会导致契约检查的时机和方式发生变化。为了解决这一问题，我们需要确保契约在赋值后仍能正确应用。

对于可变数据结构，我们可以为整个数据结构添加契约封装，确保在更新数据时执行适当的契约检查。这种策略要求我们修改数据结构的赋值操作符，以便在赋值时正确处理契约。

#### 16.8 契约的组合

本节讨论了如何组合契约。契约可以通过逻辑操作进行组合，如联合（`or`）、交叉（`and`）和取反（`not`）。这些组合操作使得我们可以构建复杂的契约，适用于更广泛的场景。

组合契约的实现需要考虑多个子契约的执行顺序和策略。特别是在处理联合契约时，需要记录哪些子契约通过或失败，以便在所有子契约失败时报告错误。组合契约的正确实现对于构建健壮的契约系统至关重要。

#### 16.9 问责

契约的一个重要特性是问责（blame）。当契约被违反时，我们需要明确是谁引入了这个错误。这在调试复杂系统时尤其重要。通过记录正负位置的标签（positive and negative positions），我们可以准确地追踪到契约违反的责任方，从而更有效地进行错误报告和调试。

问责机制为契约系统提供了更高的透明度，使得错误报告不仅能够指出错误发生的位置，还能追溯到引入错误的根源。这在多模块的复杂系统中尤为关键。

内容从基本的契约概念出发，逐步引入了处理复杂数据结构和高阶函数的策略，最后讨论了如何组合契约以及如何在错误发生时追踪责任。通过这些讨论，我们看到契约系统在动态类型语言中的重要性，以及它们如何补充静态类型系统的不足。

深入探讨如何通过实际的编程范式和设计模式，将这些契约应用到更复杂的系统中。契约不仅是动态检查不变量的工具，还可以作为设计和文档的一部分，明确模块之间的接口和责任。通过将契约与设计模式结合，我们可以构建更加可靠、可维护的软件系统。

# -----------------------------

以下是第16章（关于契约系统）的核心内容在主流编程语言中的实现与支持情况的详细对比分析。表格形式提供了各个语言在契约系统上的支持、特性以及实现方式。

| **语言**       | **契约支持**                                                 | **契约实现**                                                 | **契约的主要特性**                                           | **局限性**                                                   |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **Racket**     | 原生支持契约系统，Racket中契约是核心部分。                   | 使用`contract`库，可以为函数、模块、结构体等定义契约。       | - 支持高阶契约<br>- 详细的错误报告<br>- 支持模块级别的契约<br>- 支持契约组合（and、or、not） | - 性能开销，尤其是在复杂数据结构上进行延迟契约检查时<br>- 使用时需要仔细设计，避免契约导致的性能瓶颈 |
| **Python**     | 无原生契约支持，但有多个第三方库支持。                       | 使用库如`PyContracts`、`icontract`等来实现契约。             | - 基本契约支持<br>- 合同库可以扩展检查复杂数据结构           | - 没有原生支持，依赖第三方库<br>- 不支持复杂的高阶契约<br>- 性能较差 |
| **Ruby**       | 无原生契约支持，主要通过第三方库实现。                       | 使用库如`contracts.ruby`来实现契约。                         | - 灵活的契约实现<br>- 可以为方法和模块添加契约               | - 没有原生支持<br>- 性能开销较大                             |
| **JavaScript** | 没有原生契约支持，但可以通过编写自定义代码或使用库实现。     | 可以通过编写自定义检查代码或使用库如`contract-js`实现。      | - 基本契约实现<br>- 函数契约支持（依赖库）                   | - 没有原生支持<br>- 运行时性能开销较大                       |
| **Clojure**    | 提供了基本的契约支持，主要通过宏实现。                       | 使用`preconditions`和`postconditions`来定义契约。            | - 支持函数契约<br>- 可以定义前置和后置条件                   | - 不支持复杂的契约组合和高阶契约                             |
| **Haskell**    | 没有传统契约支持，主要通过类型系统表达不变量。               | 可以使用Haskell的强类型系统，或使用`Liquid Haskell`进行契约检查。 | - 通过类型系统确保大部分不变量<br>- 使用`Liquid Haskell`可以增加额外的契约检查 | - 类型系统已经非常强大，使用契约系统反而显得多余<br>- `Liquid Haskell`复杂且增加了编写和维护代码的难度 |
| **Scala**      | 原生支持“契约式设计”，但并未流行。                           | 使用Scala的`Contracts`库实现契约。                           | - 支持契约组合<br>- 支持高阶契约                             | - 运行时性能开销较大<br>- 需要手动添加契约，可能会被忽略     |
| **OCaml**      | 没有传统的契约系统支持，但可以通过组合类型系统与断言来表达契约。 | 使用OCaml的强类型系统和断言机制进行契约检查。                | - 强类型系统提供大部分安全保障<br>- 断言机制可以补充类型系统的不足 | - 没有标准的契约系统<br>- 复杂的契约需要手动实现，增加开发复杂度 |
| **Rust**       | 没有原生契约支持，主要通过类型系统和`assert!`实现断言。      | 使用Rust的强类型系统和`assert!`宏来确保运行时不变量。        | - 类型系统极为严格，可以捕获大部分错误<br>- `assert!`提供基本的契约功能 | - 没有完整的契约系统支持<br>- 复杂契约需要手动实现，维护成本高 |
| **Kotlin**     | 没有原生契约支持，但提供了类型系统与断言机制。               | 使用Kotlin的`require`、`check`和`assert`函数实现基本的契约。 | - 类型系统和断言机制结合提供基本的契约支持<br>- 合理使用扩展函数和泛型可以增强契约检查 | - 没有完整的契约系统支持<br>- 复杂契约需要手动实现，开发难度增加 |
| **Java**       | 没有原生契约支持，但可以通过第三方库或自定义代码实现契约。   | 使用库如`JContract`或`Guava Preconditions`，或通过自定义断言代码实现。 | - 基本契约支持<br>- 结合类型系统和断言机制                   | - 没有原生支持<br>- 高级契约功能有限                         |
| **C#**         | 提供了基本的契约支持，通过Code Contracts实现。               | 使用Code Contracts库实现契约，但从.NET Core 3.0开始已不再官方支持。 | - 支持前置、后置条件和不变量契约<br>- 提供编译时和运行时检查<br>- 与.NET生态系统的良好集成 | - Code Contracts不再官方支持<br>- 可能需要依赖第三方库或旧版本.NET Framework进行契约实现 |
| **Eiffel**     | 原生支持契约式设计，这是该语言的核心特性之一。               | 契约直接作为语言的内置功能，使用`require`、`ensure`等关键字来定义契约。 | - 全面的契约支持<br>- 强大的错误报告机制<br>- 内置的前置条件、后置条件和不变量契约支持 | - 语言相对小众，生态系统不如主流语言丰富                     |
| **Swift**      | 没有传统契约系统支持，但可以通过断言和类型系统实现。         | 使用`assert`和类型系统来实现契约的基本功能。                 | - 类型系统和断言结合提供基本契约功能<br>- 使用泛型和协议增强契约表达能力 | - 没有完整的契约系统支持<br>- 复杂的契约需要手动实现         |

### 多角度分析：

1. **契约支持类型**：
   - **原生支持**：如Racket、Eiffel，契约系统是语言的核心部分。
   - **第三方库支持**：如Python、Ruby、Java等，依赖第三方库来实现契约功能。
   - **类型系统替代**：如Haskell、OCaml、Rust等，通过类型系统确保大部分不变量，并使用断言进行补充。

2. **契约的实现复杂度**：
   - **简易实现**：一些语言如Python、JavaScript可以通过简单的库或手写断言实现基本的契约检查。
   - **复杂实现**：语言如Haskell、Scala通过额外的库和工具来实现契约功能，但需要更深入的学习和实践。

3. **性能影响**：
   - **高性能影响**：Racket等语言中，契约的全面支持带来了较大的运行时性能开销。
   - **低性能影响**：Rust等语言，通过强类型系统避免了大多数运行时检查，减少了性能开销。

4. **可读性和易用性**：
   - **高可读性**：通过便捷语法糖（如Racket、Eiffel）提高契约的可读性。
   - **低可读性**：如Haskell的`Liquid Haskell`库，由于复杂的类型系统和契约表达，代码的可读性较低。

5. **应用场景和适用性**：
   - **面向教育和研究**：Eiffel等语言在教学和研究中广泛使用，因其对契约式设计的全面支持。
   - **通用编程**：Java、C#等主流语言在企业级开发中广泛使用，但契约功能通常由第三方库或类型系统补充。

这个表格及其分析有助于理解各主流编程语言在契约实现方面的差异和适用场景，帮助开发者根据具体需求选择合适的语言和契约实现方式。


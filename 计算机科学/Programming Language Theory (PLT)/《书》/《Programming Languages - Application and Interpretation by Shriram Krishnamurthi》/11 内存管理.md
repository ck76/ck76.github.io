[toc]

### 11. 内存管理

内存管理是计算机程序设计中的一个重要主题，尤其在涉及到长期运行的大型程序或系统时。如何有效地管理和回收不再使用的内存空间，避免内存泄漏，保证程序的高效运行，是内存管理要解决的核心问题。

#### 11.1 垃圾

**垃圾**（garbage）是指那些已经分配但不再需要的内存空间。在大多数编程语言中，内存分配有两种方式：

1. **环境分配**：与静态作用域保持一致，主要用于管理函数调用的栈空间。当函数返回时，栈上的空间会被自动释放。
   
2. **贮存分配**：与程序的动态行为相关，通常用于堆内存的分配。这部分内存的生命周期可能会超过其创建的位置或作用域，需要更复杂的管理策略。

贮存分配需要考虑何时以及如何释放不再使用的内存，否则可能导致内存泄漏或内存碎片化。

#### 11.2 什么样的垃圾回收是“正确的”？

**垃圾回收**需要解决两个核心问题：

1. **可靠性**（soundness）：不应过早地回收仍然需要使用的内存。
2. **完备性**（completeness）：不应过迟回收内存，避免浪费资源。

理想的垃圾回收系统既要自动化，又要保证可靠性和完备性。然而，实际情况往往不可兼得。在大多数情况下，垃圾回收系统优先确保可靠性，因为它对程序的正确性影响更大。

#### 11.3 人工回收

**人工回收**指的是由程序员显式管理内存分配和释放。这种方式的典型例子是在 C 语言中使用 `malloc` 和 `free` 进行内存管理。

虽然人工回收可以让程序员更细粒度地控制内存，但容易出错，并且需要付出很大的精力来避免内存泄漏和内存碎片化等问题。

##### 11.3.1 完全人工回收的代价

人工内存管理的最大问题之一是**内存碎片化**，这会导致即使有足够的内存可用，也无法为新对象分配连续的内存空间。为了解决碎片化问题，程序员必须手动管理空闲空间，并决定如何最佳地利用这些空闲空间，这使得人工回收变得复杂且容易出错。

##### 11.3.2 引用计数

**引用计数**是一种半自动化的内存管理技术，每个对象都维护一个引用计数器，记录有多少个引用指向它。当引用计数为零时，内存可以被回收。

虽然引用计数能减少人工管理的负担，但它有两个主要问题：

1. **循环引用**：如果对象之间互相引用，引用计数永远不会降为零，导致内存泄漏。
2. **开销**：维护引用计数的增减操作需要额外的时间和空间开销。

#### 11.4 自动回收，或垃圾收集

**自动垃圾收集**（GC）是一种完全自动化的内存回收技术，通过算法自动识别哪些内存已经不再需要，然后回收这些内存。

##### 11.4.1 概览

自动垃圾收集算法通常会从**根集**（root set）开始遍历所有可达的内存地址，以识别哪些内存仍然被引用。这些仍然被引用的内存被标记为“存活”，而其它内存则被标记为垃圾，可以回收。

##### 11.4.2 事实和可证性

垃圾回收系统的设计必须在可靠性和完备性之间做出平衡。理论上，自动化的垃圾回收算法无法同时保证这两者，因此在实际设计中，通常优先考虑可靠性。

##### 11.4.3 核心假设

为了有效地执行垃圾回收，系统需要了解内存中的对象类型和布局。这些信息通常由语言的类型系统和内存管理机制提供。

#### 11.5 保守垃圾回收

**保守垃圾回收**是一种特别为 C 和 C++ 等语言设计的技术。这些语言允许将指针和整数相互转换，使得垃圾回收系统难以判断哪些内存地址是有效的指针。保守垃圾回收通过假设大部分内存地址不是指针，从而减少错误判断的风险。

虽然保守垃圾回收可以使得 C 和 C++ 等语言也能使用垃圾回收机制，但这种方式并不精确，可能会漏掉一些需要回收的内存。

#### 11.6 精确垃圾回收

**精确垃圾回收**（precise GC）相对于保守垃圾回收，可以准确地识别哪些内存地址是指针，从而更加高效和安全。精确垃圾回收依赖于语言的类型系统和内存管理机制，能够更好地回收内存。

### 总结

内存管理和垃圾回收是编程语言设计中的重要部分，影响着程序的性能和可靠性。通过自动化技术，如垃圾回收，程序员可以避免手动管理内存的复杂性和风险。然而，自动化也带来了性能和完备性上的权衡。理解和选择合适的内存管理技术是构建高效和可靠软件系统的关键。





下面是内存管理章节中几种内存管理技术的详细对比表格，从多个角度分析了每种技术的优缺点和适用场景：

| **角度/技术**            | **手动内存管理（如 `malloc/free`）**                         | **引用计数**                                                 | **保守垃圾回收（Conservative GC）**                          | **精确垃圾回收（Precise GC）**                               |
| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **自动化程度**           | 完全手动，程序员需要显式地管理内存分配和释放                 | 半自动化，程序员负责增减引用计数，系统负责回收引用计数为 0 的内存 | 自动化，但可能会误认为某些数据是引用而保留这些数据           | 完全自动化，系统精确地管理和回收内存                         |
| **可靠性**               | 可靠性低，容易出错，尤其是在忘记释放内存或重复释放内存时     | 可靠性中等，容易因引用计数错误导致内存泄漏或过早回收         | 可靠性高，但可能保留一些不必要的数据                         | 可靠性高，能够精确识别和回收不再使用的内存                   |
| **完备性**               | 低，程序员容易忘记释放内存，导致内存泄漏                     | 中等，引用计数无法处理循环引用，导致内存泄漏                 | 完备性低，可能会保留一些实际不需要的数据                     | 高，能够完全回收不再使用的内存                               |
| **实现复杂度**           | 实现复杂，要求程序员具备深厚的内存管理知识                   | 实现相对简单，但在有循环引用的情况下实现复杂度增加           | 实现复杂，需要处理可能的伪引用和误判的情况                   | 实现复杂，需要对内存结构和对象类型有精确的管理               |
| **性能开销**             | 性能开销低，但需要程序员手动管理，可能会导致低效的内存使用   | 性能开销中等，增减引用计数会带来一些性能负担，尤其是在递归结构中 | 性能开销中等，由于保守策略可能会保留一些不必要的内存，导致内存占用增加 | 性能开销较低，回收过程通常在内存中并发进行，能够减少程序暂停的时间 |
| **内存碎片问题**         | 严重，容易导致内存碎片化，除非程序员手动进行内存整理         | 中等，引用计数本身不会导致碎片化，但内存分配和释放模式可能引发碎片 | 较少，保守GC通常采用分代或区域回收策略，减少碎片化           | 最小，精确GC通常使用标记-清除或复制回收算法，能有效减少内存碎片 |
| **对循环引用的处理**     | 无法处理，需要程序员手动打破循环                             | 无法处理循环引用，可能导致内存泄漏                           | 可以处理，但可能会误判和保留循环中的数据                     | 能够精确处理循环引用，并且在回收时不会遗漏循环引用产生的垃圾 |
| **代码可读性和可维护性** | 低，增加代码复杂度，内存管理代码容易分散到整个程序中         | 中等，引用计数的逻辑容易在程序中散布，影响代码可读性         | 中等，GC过程对程序员透明，但可能会引入一些与内存管理相关的不可预见行为 | 高，内存管理过程完全自动化，程序员不需要关注内存释放，代码更加简洁和易于维护 |
| **适用场景**             | 适用于对内存管理有极高要求且内存布局较为简单的系统，如嵌入式系统 | 适用于内存占用较少且不涉及复杂数据结构的程序，如小型应用或脚本 | 适用于需要与非托管语言（如 C/C++）互操作的系统，或需要快速移植和实现自动GC的场合 | 适用于几乎所有需要复杂内存管理的程序，特别是需要处理大量动态分配内存的大型应用程序，如服务器和桌面软件 |

### 总结
- **手动内存管理**适用于对内存控制有极高要求的场合，但复杂且容易出错，通常仅用于对性能有极高要求的系统。
- **引用计数**提供了一种简单的自动化内存管理方式，但在处理循环引用时存在缺陷，适合简单内存管理需求的应用。
- **保守垃圾回收**适用于需要与非托管语言互操作的场景，但由于可能会保留一些不必要的数据，可能导致内存效率降低。
- **精确垃圾回收**是最通用和高效的自动化内存管理技术，适用于各种复杂应用，尤其是在需要高性能和可靠性的系统中。
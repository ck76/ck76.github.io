

Thinking with Types

《Haskell think with types》

**前言** (Preface) ix  
**致谢** (Acknowledgments) xi  
**引言** (Introduction) 1  

---

**第一部分 基础** (Part I: Fundamentals) 5  

**第1章 类型背后的代数** (Chapter 1: The Algebra Behind Types) 7  
1.1 同构与基数 (Isomorphisms and Cardinalities) 7  
1.2 和类型、积类型和指数类型 (Sum, Product, and Exponential Types) 10  
1.3 示例：井字棋 (Example: Tic-Tac-Toe) 13  
1.4 Curry-Howard 同构 (The Curry–Howard Isomorphism) 15  
1.5 规范表示法 (Canonical Representations) 16  

**第2章 项、类型与种类** (Chapter 2: Terms, Types, and Kinds) 19  
2.1 种类系统 (The Kind System) 19  
2.1.1 “类型”的种类 (The Kind of “Types”) 20  
2.1.2 箭头种类 (Arrow Kinds) 20  
2.1.3 约束种类 (Constraint Kinds) 21  
2.2 数据种类 (Data Kinds) 22  
2.3 内置类型的提升 (Promotion of Built-In Types) 25  
2.3.1 符号 (Symbols) 25  
2.3.2 自然数 (Natural Numbers) 27  
2.3.3 列表 (Lists) 28  
2.3.4 元组 (Tuples) 29  
2.4 类型层级函数 (Type-Level Functions) 30  

**第3章 变异性** (Chapter 3: Variance) 35  

---

**第二部分 解除限制** (Part II: Lifting Restrictions) 41  

**第4章 类型操作** (Chapter 4: Working with Types) 43  
4.1 类型作用域 (Type Scoping) 43  
4.2 类型应用 (Type Applications) 45  
4.3 模糊类型与非单射性 (Ambiguous Types and Non-Injectivity) 47  

**第5章 约束与广义代数数据类型 (GADTs)** (Chapter 5: Constraints and GADTs) 51  
5.1 简介 (Introduction) 51  
5.2 广义代数数据类型 (GADTs) 52  
5.3 异质列表 (Heterogeneous Lists) 55  

**第6章 Rank-N 类型** (Chapter 6: Rank-N Types) 61  
6.1 简介 (Introduction) 61  
6.2 Rank 的定义 (Ranks) 63  
6.3 详细内容 (The Nitty Gritty Details) 65  
6.4 Continuation Monad (Continuation Monad) 66  

**第7章 存在类型** (Chapter 7: Existential Types) 71  
7.1 存在类型与消去器 (Existential Types and Eliminators) 71  
7.1.1 动态类型 (Dynamic Types) 74  
7.1.2 广义约束类存在类型 (Generalized Constraint Kinded Existentials) 76  
7.2 使用存在类型封装信息 (Scoping Information with Existentials) 79  

**第8章 角色** (Chapter 8: Roles) 85  
8.1 强制 (Coercions) 85  
8.2 角色 (Roles) 90  

---

**第三部分 类型层级计算** (Part III: Computing at the Type-Level) 95  

**第9章 关联类型族** (Chapter 9: Associated Type Families) 97  
9.1 从架构构建类型 (Building Types from a Schema) 98  
9.2 生成关联项 (Generating Associated Terms) 102  

**第10章 一类类型族** (Chapter 10: First Class Families) 107  
10.1 Defunctionalization (Defunctionalization) 107  
10.2 类型层级 Defunctionalization (Type-Level Defunctionalization) 109  
10.3 使用一类类型族 (Working with First Class Families) 113  
10.4 特定多态性 (Ad-Hoc Polymorphism) 116  

**第11章 可扩展数据** (Chapter 11: Extensible Data) 119  
11.1 简介 (Introduction) 119  
11.2 开放和类型 (Open Sums) 120  
11.3 开放积类型 (Open Products) 125  
11.4 重载标签 (Overloaded Labels) 131  

**第12章 自定义类型错误** (Chapter 12: Custom Type Errors) 133  

**第13章 泛型** (Chapter 13: Generics) 141  
13.1 泛型表示法 (Generic Representations) 142  
13.2 导出结构多态性 (Deriving Structural Polymorphism) 145  
13.3 使用泛型元数据 (Using Generic Metadata) 151  
13.4 性能 (Performance) 163  
13.5 Kan 扩展 (Kan Extensions) 165  

**第14章 Indexed Monads** (Chapter 14: Indexed Monads) 169  
14.1 定义与必要机制 (Definition and Necessary Machinery) 169  
14.2 线性分配 (Linear Allocations) 173  

**第15章 依赖类型** (Chapter 15: Dependent Types) 181  
15.1 概览 (Overview) 182  
15.2 特定实现 (Ad-Hoc Implementation) 182  
15.3 泛化的机制 (Generalized Machinery) 187  
15.4 单例包 (The Singletons Package) 192  
15.5 依赖对 (Dependent Pairs) 195  
15.5.1 结构化日志 (Structured Logging) 199  

---

**附录** (Appendices) 203  

**术语表** (Glossary) 205  
**解决方案** (Solutions) 211  
**参考文献** (Bibliography) 233  
**作者简介** (About the Author) 235  


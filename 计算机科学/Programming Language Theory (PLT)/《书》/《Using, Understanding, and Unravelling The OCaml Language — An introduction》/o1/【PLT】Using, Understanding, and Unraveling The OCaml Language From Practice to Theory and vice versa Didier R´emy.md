[toc]



**详细解读：**

**引言**

第一段：

“OCaml 是 ML 家族的一种语言，继承了数十年来在类型理论、语言设计和函数式语言实现方面的研究成果。此外，该语言相当成熟，其编译器能生成高效的代码，并且配备了大量的通用和特定领域的库。因此，OCaml 非常适合教学和学术项目，同时也被业界所使用，特别是在一些高科技软件公司中。”

**解读：**

OCaml 是一种编程语言，属于 ML（Meta Language）家族。它的设计和实现受益于数十年来在以下领域的研究：

- **类型理论（Type Theory）**：这是数学逻辑的一个分支，研究类型系统以及它们如何影响程序的正确性和安全性。OCaml 的类型系统非常强大，能够在编译时捕获许多错误。
- **语言设计（Language Design）**：OCaml 从前人的研究中吸取了许多语言设计的优秀理念，使其语言结构清晰、简洁。
- **函数式语言实现（Implementation of Functional Languages）**：函数式编程是一种编程范式，强调使用函数和不可变数据。OCaml 在函数式编程方面有深厚的积累。
OCaml 的编译器非常成熟，能够生成高效的机器代码。这意味着用 OCaml 编写的程序在运行时具有良好的性能。此外，OCaml 提供了大量的库，既有通用的库，也有针对特定领域的库。这使得开发者可以在各种项目中使用 OCaml，减少了从头开始编写代码的需求。

因此，OCaml 非常适合用于教学和学术研究项目。它的强类型系统和函数式特性使其成为教授编程语言概念的理想选择。同时，OCaml 也在工业界得到应用，特别是在一些高科技的软件公司中，这些公司需要处理复杂的算法和系统，OCaml 的性能和强大特性满足了他们的需求。

第二段：

“本文档对 OCaml 语言进行了多维度的介绍，结合了对语言的非正式和直观的方法，以及对包括 ML 在内的大部分语言的严格定义和形式语义。在整个介绍过程中，我们解释了底层的设计原则，突出展示了语言各个方面之间的众多交互，并强调了理论与实践之间的紧密联系。”

**解读：**

作者希望通过多种角度来介绍 OCaml 语言：

- **非正式和直观的方法**：作者会以一种易于理解的方式介绍 OCaml，避免过多复杂的术语，帮助读者直观地理解语言的特性。
- **严格的定义和形式语义**：同时，作者也提供了对语言的严格定义和形式化的语义描述。这对于深入理解语言的工作原理和底层机制非常重要。
- **涵盖了包括 ML 在内的大部分语言**：OCaml 是 ML 家族的一员，ML 是一种历史悠久的函数式编程语言。因此，作者的介绍不仅限于 OCaml，还涉及 ML 的相关内容。
在整个介绍过程中，作者会：

- **解释底层的设计原则**：帮助读者理解 OCaml 的设计理念和背后的思考。
- **突出展示语言各个方面之间的交互**：语言的各个特性并不是孤立的，它们之间存在着相互影响和依赖。理解这些交互有助于更好地使用语言。
- **强调理论与实践之间的紧密联系**：OCaml 的设计深受理论研究的影响，但同时也是一门实用的编程语言。作者希望展示如何将理论应用于实践，以及实践如何反过来推动理论的发展。
第三段：

“实际上，理论和实践应该经常交汇。有时，为了保持实践的简单性，理论被故意削弱。相反，几个相关的特性可能会建议一种泛化，并被合并，导致更具表现力和规律性的设计。我们希望读者能跟随我们，将一些理论应用于实践，或者相反，从实践的例子和直觉中重建部分理论。然而，我们坚持认为，底层的数学应该始终保持简单。”

**解读：**

这段强调了理论与实践之间的动态关系：

- **理论与实践的交汇**：在编程语言的设计和使用中，理论（如类型系统的形式化）和实践（如实际编程需求）应当相互影响。
- **为了实践的简单性削弱理论**：有时，为了让语言更易于使用，可能会在某些地方放松严格的理论限制。例如，引入一些灵活性，尽管在理论上可能不够严谨，但提高了实用性。
- **通过泛化合并相关特性**：当发现多个特性之间有相似性时，可以考虑将它们泛化，设计出一个更通用、更一致的特性，提高语言的表达能力和一致性。
- **鼓励读者将理论应用于实践，或从实践中重建理论**：作者希望读者在学习 OCaml 时，既理解理论基础，又通过实践来巩固和检验这些理论。
- **底层数学应保持简单**：尽管涉及到理论和数学，但作者希望这些内容保持简单，不要过于复杂，以免阻碍理解。
第四段：

“对 OCaml 的自我审视由于该语言是自举的这一事实而变得更加有意义，即其编译链是用 OCaml 本身编写的，只有部分运行时是用 C 编写的。因此，一些实现笔记，特别是关于类型检查的，可以被放大，实际上非常接近于 OCaml 自身的类型检查器。”

**解读：**

这段强调了 OCaml 的一个重要特性，即它是**自举（boot-strapped）**的：

- **自举**：指编译器或编译链是用该语言本身编写的。这意味着 OCaml 的编译器是用 OCaml 写的。
- **部分运行时用 C 编写**：运行时系统负责支持程序运行的底层功能，如内存管理、输入输出等。OCaml 的运行时部分用 C 实现，以便更好地与系统交互和提高性能。
- **实现笔记接近于 OCaml 自身的类型检查器**：由于编译器是用 OCaml 编写的，因此研究其实现细节（如类型检查）时，实际上就是在研究 OCaml 编译器本身的实现。这使得理解语言的内部机制更加直接。
第五段：

“本文所呈现的材料分为三类。在实践方面，课程包含了对 OCaml 的简要介绍。尽管这个介绍并不详尽，当然也不是语言的参考手册，但它是一个自包含的语言入门：涵盖了语言的所有方面；然而，大多数细节被省略了。包含了一系列不同难度级别的编程练习，其中大多数的解决方案可以在附录 C 中找到。至少掌握一种 ML 方言的知识和实践可能有助于从其他方面获得最大收益。不过，这并不是强制性的，初学者可以从附录 A 开始，学习他们在 OCaml 中的第一步。相反，高级的 OCaml 程序员可以从一些算法的内联 OCaml 实现中学习。实现笔记总是可以跳过，至少在第一次阅读时，当 OCaml 的核心还没有掌握时——其他部分从不依赖于它们。然而，我们将实现笔记以及一些更高级的练习内联在文本中，以强调实现与形式化的紧密联系。此外，这也使得已经了解 OCaml 语言的人可以连续地阅读所有材料，使其成为一个更高级的课程。”

**解读：**

这段介绍了本文档的内容和组织方式：

- **材料分为三类**：**实践方面**：提供对 OCaml 的简要介绍。**不详尽**：不是全面的语言手册。**不是参考手册**：不适合作为查阅具体语言特性的参考。**自包含的语言入门**：涵盖 OCaml 的所有方面，使读者可以从零开始了解语言的主要特性。**省略了大多数细节**：重点在于总体概念，而不是细节实现。**编程练习**：**不同难度级别**：适合不同水平的读者。**大多数解决方案在附录 C 中**：读者可以参考这些解决方案来学习和验证。**实现笔记和高级练习**：**内联在文本中**：与主要内容交织在一起，方便有经验的读者深入。
- **已有 ML 方言的知识有助于学习**：**但不是强制性的**：初学者仍然可以通过附录 A 开始学习。
- **初学者的建议**：**从附录 A 开始**：学习 OCaml 的基础。**通过练习巩固**：利用不同难度的练习来实践。
- **高级程序员的建议**：**深入实现笔记**：了解 OCaml 内部机制和高级特性。**可以跳过实现笔记**：对于第一次阅读或还未掌握核心内容的读者，可以暂时跳过。
- **实现笔记的作用**：**强调实现与形式化的紧密联系**：展示理论如何在实际实现中应用。**提供更高级的学习材料**：适合已经熟悉 OCaml 的读者。
第六段：

“在理论方面——数学仍然相当初等，我们给出了 OCaml 语言的大部分子集的形式定义，包括其动态和静态语义，以及将它们联系起来的健全性结果。然而，证明被省略了。我们还详细描述了类型推断。事实上，这是 ML 最具特色的方面之一。”

**解读：**

这段介绍了本文的理论内容：

- **形式定义**：**OCaml 语言的大部分子集**：对语言的主要部分进行了形式化描述。**动态语义**：描述程序在运行时的行为。**静态语义**：主要涉及类型系统，描述程序在编译时的性质。**健全性结果**：证明静态语义与动态语义之间的正确性关系，例如类型安全性。
- **省略证明**：虽然给出了形式化定义，但具体的证明过程未包含在本文中。
- **详细描述类型推断**：**类型推断是 ML 的特色**：编译器自动推断类型，使编程更简洁。
第七段：

“实际上，很多材料实际上介于理论和实践之间：我们强调了设计原则、语言构造的模块化（它们的介绍通常是增量式的），以及它们的依赖性。一些在理论上独立的构造最终在实践中是互补的，因此很难没有另一个：通常是它们的组合同时提供了灵活性和表达能力。”

**解读：**

这段强调了理论和实践的结合，以及语言设计中的一些重要考虑：

- **材料介于理论和实践之间**：内容既有理论意义，又有实际应用价值。
- **强调设计原则**：说明语言设计背后的理念。
- **语言构造的模块化**：**增量式介绍**：逐步引入语言特性，便于理解。
- **构造的依赖性**：不同特性之间的相互依赖和影响。
- **理论上独立但实践中互补的构造**：**组合使用提供灵活性和表达能力**：某些特性单独使用时可能有限，但结合起来能发挥更大作用。
第八段：

“本文档组织为四个部分（参见图1中的路线图）。前三个部分分别涉及 OCaml 的不同层次：核心语言（第1和第2章）、对象和类（第3章）、以及模块（第4章）；最后一部分（第5章）重点关注对象和模块的组合，并讨论了一些展望。每个部分的介绍风格不同。核心语言的介绍更加形式化和完整，而第3章对象和类的重点放在类型检查上，模块系统的介绍保持非正式，最后一部分主要基于示例。这是一个有意的选择，受限于篇幅，同时也基于各部分的相对重要性和形式化的兴趣。我们在每章的结尾处参考其他作品以获得更正式的介绍或进一步阅读，第119页有一个相关工作的更全面概述。”

**解读：**

这段介绍了本文的组织结构：

- **四个部分**：**核心语言（第1和第2章）**：形式化和完整的介绍。**对象和类（第3章）**：重点在类型检查。**模块系统（第4章）**：保持非正式的介绍。**对象和模块的组合（第5章）**：主要通过示例展示。
- **介绍风格的差异是有意的选择**：**受限于篇幅**：无法对每个部分都进行全面的形式化描述。**基于各部分的相对重要性和形式化的兴趣**：核心语言更基础，给予更多关注。
- **提供进一步阅读的参考**：**每章结尾的技术参考**：供深入研究。**第119页的相关工作概述**：提供更广泛的背景。
第九段：

“因此，本文档面向广泛的读者群。通过多个入口点，它可以部分阅读或按照不同的方向阅读（参见图1中的路线图）。对编程语言语义感兴趣的人可以只阅读第1和第2章。相反，对 OCaml 的面向对象层感兴趣的人可以跳过这些章节，从第3章开始。初学者或主要对学习编程语言感兴趣的人可以从附录 A 开始，然后在前几章中获取示例和练习，最后阅读对象和模块的章节；他们可以在掌握了 OCaml 编程后随时回到前几章，并将实现类型检查器作为一个项目，无论是遵循还是忽略相关的实现笔记。”

**解读：**

这段说明了本文的适用读者和阅读建议：

- **面向广泛的读者群**：无论是初学者、理论研究者，还是有经验的程序员，都可受益。
- **多个入口点**：**对语义感兴趣**：阅读第1和第2章。**对面向对象层感兴趣**：从第3章开始。**初学者**：**从附录 A 开始**：学习基础。**通过练习巩固**：利用前几章的示例和练习。**阅读对象和模块章节**：逐步深入。**回到前几章**：在掌握编程后，深入理解核心概念。**实现类型检查器作为项目**：高级练习，巩固所学。
第十段：

“编程语言是数学语言的严格但不完整的近似。通用语言是图灵完备的。也就是说，它们允许编写所有的算法。（因此，终止性和许多其他有用的程序性质是不可判定的。）然而，编程语言并非都是等价的，因为它们在描述某些类型的算法的简洁性上有所不同。这导致了对新的编程结构的——无休止的？——研究，这些结构更具表达力，允许对算法进行更短和更安全的描述。当然，表达能力并非最终目标。特别是，程序执行的安全性不应为了表达能力而被放弃。我们通常将自己限制在一个相对较小的、类型正确的程序子集中，保证能够安全地运行。我们还寻找一小组简单、本质和正交的构造。”

**解读：**

这段讨论了编程语言的性质和设计目标：

- **编程语言是数学语言的近似**：它们提供了数学概念的可操作表达。
- **通用语言是图灵完备的**：可以实现任何可计算的函数。
- **不可判定性**：无法决定程序的某些性质，如是否终止。
- **编程语言的差异**：**描述算法的简洁性不同**：一些语言更适合表达特定类型的算法。
- **对新编程结构的研究**：**寻找更具表达力的结构**：使算法描述更简洁、安全。
- **表达能力不是唯一目标**：**程序执行的安全性更重要**：不能为了表达能力而牺牲安全性。**限制在类型正确的程序子集**：通过类型系统保证安全。
- **寻找简单、本质和正交的构造**：**简单**：易于理解和使用。**本质**：核心必要的特性。**正交**：特性之间相互独立。
第十一段：

“学习编程语言

学习一门编程语言是理解语言构造和实践的结合。当然，编程语言应该有清晰的语义，无论是形式化给出的，即使用数学符号，如 Standard ML [51]，还是非形式化的，使用文字描述，如 OCaml。理解语义和设计原则是良好编程习惯的前提，但良好的编程也是实践的结果。因此，使用手册、教程和在线帮助是正常的做法。一个人可能很快学习核心库的所有函数，但即使是熟练的程序员有时也需要检查一些不常用的标准库函数的规范。”

**解读：**

这段讨论了如何学习编程语言：

- **理解语言构造和实践的结合**：学习不仅是理论，还需要实践。
- **语言应有清晰的语义**：**形式化语义**：用数学定义，如 Standard ML。**非形式化语义**：用文字描述，如 OCaml。
- **理解语义和设计原则**：有助于良好的编程习惯。
- **实践的重要性**：通过编写代码来巩固所学。
- **使用资源是正常的**：手册、教程、在线帮助等。
- **熟练程序员也需要查阅**：因为可能不记得所有细节。
第十二段：

“在任何编程阶段，复制（好的）示例都可能节省时间。这包括从练习的解决方案中剪切和粘贴，特别是在开始时。与他人分享经验也可能有所帮助：你遇到的第一个问题很可能是“常见问题”，你缺少的库可能已经在“OCaml hump”中电子方式提供。关于 ML 的书籍，请参阅“进一步阅读”，第119页。”

**解读：**

这段提供了学习的实用建议：

- **复制好的示例**：可以加快学习速度。
- **从练习解决方案中学习**：特别是初学者。
- **与他人分享经验**：**解决常见问题**：很多问题已经有答案。**利用现有库**：可能已有你需要的功能。
- **OCaml hump**：一个在线资源库。
- **参考书籍**：在第119页有推荐。
第十三段：

“OCaml 的简史

当前对 OCaml 语言的定义和实现是过去二十年来持续进行并仍在进行的研究的结果。OCaml 语言属于 ML 家族。ML 语言于1975年由 Robin Milner 发明，用作 LCF 证明助手中的一种“元语言”，即控制语言或脚本语言，用于编程证明搜索策略。该语言很快被认为是一种完整的编程语言。最早的 ML 实现在1981年左右用 Lisp 实现。不久，出现了多个 ML 方言：爱丁堡的 Standard ML，INRIA 的 Caml，新泽西的 Standard ML，Chalmers 开发的 Lazy ML，或格拉斯哥的 Haskell。后两个方言与前面的略有不同，它们依赖于惰性求值策略（称为惰性语言），而其他都是严格求值策略（称为严格语言）。传统语言，如 C、Pascal、Ada 也是严格语言。Standard ML 和 Caml 彼此非常接近。它们之间的主要差异是它们的实现和表面的——有时令人恼火的——语法差异。另一个小的差异是它们的模块系统。然而，SML 没有面向对象层。”

**解读：**

这段介绍了 OCaml 的历史和与其他 ML 方言的关系：

- **ML 的起源**：**1975年由 Robin Milner 发明**。**最初作为 LCF 证明助手的元语言**。
- **早期实现**：**1981年左右用 Lisp 实现**。
- **ML 方言的发展**：**Standard ML（SML）**：爱丁堡大学。**Caml**：INRIA。**SML of New-Jersey**：美国新泽西。**Lazy ML**：Chalmers 大学，惰性求值。**Haskell**：格拉斯哥大学，惰性求值。
- **惰性语言 vs 严格语言**：**惰性求值**：表达式在需要时才计算。**严格求值**：表达式在定义时立即计算。
- **Standard ML 和 Caml 的相似性**：**主要差异在实现和语法**。**模块系统的差异**。**SML 没有面向对象层**。
第十四段：

“继续 Caml 的历史，Xavier Leroy 和 Damien Doligez 在1990年设计了一个新的实现，称为 Caml-Light，将之前的实现从过多的实验性高级特性中解放出来，更重要的是，摆脱了旧的 Le Lisp 后端。”

**解读：**

这段讲述了 Caml 的进一步发展：

- **Caml-Light 的诞生**：**1990年由 Xavier Leroy 和 Damien Doligez 设计**。**目标是简化之前的实现**。
- **改进**：**去除了过多的实验性高级特性**。**摆脱了对 Le Lisp 后端的依赖**。
第十五段：

“1995年添加了本地代码编译器和强大的模块系统，1996年添加了对象和类层，使 OCaml 成为一个非常成熟和有吸引力的编程语言。该语言仍在开发中：例如，2000年，Jacques Garrigue 添加了标记和可选参数以及匿名变体到语言中。”

**解读：**

这段介绍了 OCaml 的重要更新：

- **1995年**：**添加了本地代码编译器**：提高了性能。**强大的模块系统**：改善了代码组织。
- **1996年**：**添加了对象和类层**：支持面向对象编程。
- **语言的持续发展**：**2000年更新**：**Jacques Garrigue 添加了标记和可选参数**：提高了函数调用的灵活性。**匿名变体**：增加了语言的表达能力。
第十六段：

“在过去的十年中，其他 ML 方言也独立地发展。此后，我们使用 ML 一词来指代大多数方言共有的核心语言特性，我们在示例中使用 OCaml 来指代这个特定的实现。除了包含对象和类的示例外，大多数示例都可以轻松地转换为 Standard ML。然而，只有少数可以直接转换为 Haskell，主要是因为两种语言有不同的求值策略，但也因为它们的设计有许多其他差异。”

**解读：**

这段总结了 ML 方言之间的关系：

- **各方言的独立发展**。
- **ML 一词的使用**：指代共同的核心特性。
- **示例的可移植性**：**大多数示例可转换为 SML**。**少数可转换为 Haskell**：**求值策略不同**：Haskell 是惰性求值。**设计差异**：如类型系统、语法等。
第十七段：

**“相似性和差异在几个关键字中

所有的 ML 方言都是函数式的。也就是说，函数被认真对待。特别地，它们是一等公民：它们可以作为其他函数的参数并作为结果返回。所有的 ML 方言也是强类型的。这意味着类型正确的程序不会出错。通过这点，我们的意思是，假设没有编译器错误，程序将永远不会执行错误的内存访问或其他类型的异常执行步骤，并且如果程序不陷入死循环，将始终正常终止。当然，这并不保证程序执行了程序员的意图！

所有的 ML 方言的另一个共同属性是类型推断，也就是说，表达式的类型是可选的，由系统推断出来的。正如大多数现代语言一样，ML 具有自动内存管理。

此外，OCaml 语言并非纯函数式的：允许使用可变的值和副作用进行命令式编程。OCaml 也是面向对象的（除了原型设计外，OCaml 仍然是唯一的面向对象的 ML 方言）。OCaml 还具有一个强大的模块系统，受到了 Standard ML 的启发。”**

**解读：**

这段总结了 ML 方言的共同特性和 OCaml 的独特之处：

- **共同特性**：**函数式编程**：函数是一等公民。**强类型**：类型系统保证程序的安全性。**类型推断**：编译器自动推断类型。**自动内存管理**：垃圾回收机制。
- **OCaml 的独特之处**：**支持命令式编程**：允许可变状态和副作用。**面向对象**：提供类和对象的特性。**强大的模块系统**：受 SML 启发，但有自己的扩展。
**致谢**

“非常感谢 Jacques Garrigue、Xavier Leroy 和 Brian Rogoff 对部分笔记的仔细阅读。”

**解读：**

作者向同事表示感谢，他们对本文的部分内容进行了审阅，可能提供了有价值的反馈和建议。

**总结**

通过对引言的详细解读，我们了解了 OCaml 的背景、特性、设计原则以及本文档的组织方式。作者旨在通过结合理论和实践，为读者提供对 OCaml 的全面理解，无论是初学者、理论研究者还是有经验的程序员，都可以从中受益。
  



**详细解读：**

**第1章 核心ML**

**1.1 发现核心ML**

**第一段：**

*“我们首先展示一些示例，强调语言的函数式方面。然后，我们形式化一个极其小的语言子集，令人惊讶的是，它本身就包含了ML的精髓。最后，我们展示如何在可能的情况下保留核心ML中的其他构造，或者在必要时进行小的扩展。”*

**解读：**

- **展示示例，强调函数式特性：** 作者计划通过示例来展示核心ML的函数式编程特性，让读者直观地感受这种编程范式。
- **形式化一个极小的语言子集：** 他们将对一个非常小的核心语言进行形式化描述，这个小的子集包含了ML语言的核心概念。
- **展示如何从核心构造其他特性：** 最后，他们将展示如何基于这个核心语言来构建其他语言特性，或者在必要时对语言进行小的扩展。
**第二段：**

*“核心ML是一个小型的函数式语言。这意味着函数被认真对待，例如，它们可以作为其他函数的参数传递或作为结果返回。我们也说函数是一等公民。”*

**解读：**

- **小型函数式语言：** 核心ML是一个精简的函数式编程语言，关注于核心概念。
- **函数被认真对待：** 在核心ML中，函数可以像数据一样操作，可以传递给其他函数或从函数中返回。
- **函数是一等公民（first-class values）：** 这意味着函数在语言中与其他基本类型（如整数、字符串）具有相同的地位，可以随意传递、存储和操作。
**第三段：**

*“原则上，函数的概念尽可能地与数学中的概念紧密相关。然而，也存在重要的差异，因为程序中操作的对象总是可数的（在实践中是有限的）。实际上，核心ML基于λ-演算，后者是由丘奇发明的，用于建模计算。”*

**解读：**

- **函数概念与数学的联系：** 核心ML中的函数概念力求与数学中的函数概念一致。
- **重要差异：** 程序中的对象是可数且有限的，而数学中的函数可以作用于无限集。
- **λ-演算的基础：** 核心ML基于λ-演算，这是阿隆佐·丘奇（Alonzo Church）发明的一种形式系统，用于研究函数定义、函数应用和递归。
**第四段：**

*“在语法上，λ-演算的表达式（用字母a表示）有三种可能的形式：变量x，它们作为一个可数集的元素给出，函数λx.a，或应用a₁ a₂。此外，核心ML有一个特殊的构造let x = a₁ in a₂，用于在表达式a₂中将表达式a₁绑定到变量x（正如我们将在下面看到的，这个构造也用于引入多态性）。此外，ML语言带有原始值，例如整数、浮点数、字符串等（用字母c表示）以及这些值上的函数。”*

**解读：**

- **λ-演算的三种表达式形式：****变量 x：** 代表一个变量，可以取任何值。**函数 λx.a：** 代表一个匿名函数，参数是 x，函数体是 a。**应用 a₁ a₂：** 代表函数 a₁ 应用于参数 a₂。
- **let 绑定构造：** `let x = a₁ in a₂`，将表达式 a₁ 的值绑定到变量 x，然后在表达式 a₂ 中使用 x。
- **用于引入多态性：** 这个 let 构造在 ML 中也用于实现多态性（后面会详细解释）。
- **原始值和函数：** ML 提供了一些基本的数据类型（如整数、浮点数、字符串）和对这些类型操作的函数。
**第五段：**

*“最后，程序由一系列语句组成，这些语句可以用双分号“;;”可选地分隔开。一个语句是单个表达式或一个绑定，写作 let x = a，将表达式 a 绑定到变量 x。”*

**解读：**

- **程序结构：** 一个程序是由多个语句组成的序列。
- **语句的分隔：** 可以使用双分号 `;;` 来分隔语句，但这是可选的。
- **语句的形式：****单个表达式：** 例如，一个计算或函数调用。**绑定：** 使用 `let x = a` 形式，将表达式 a 的值绑定到变量 x。
**第六段：**

*“在正常模式下，程序可以写在一个或多个文件中，分别编译，然后链接在一起形成可执行的机器代码（参见4.1.1节）。然而，在核心语言中，我们可以假设所有的语句都写在一个文件中；此外，我们可以将 ;; 替换为 in，将语句序列转换为单个表达式。OCaml 语言还提供了一个交互式循环，用户输入的语句被立即编译和执行；然后，它们的结果被打印在终端上。”*

**解读：**

- **程序的编写方式：****多文件编写和编译：** 在正常使用中，程序可以分成多个文件，各自编译后再链接。
- **核心语言的简化假设：****单个文件：** 为了简化，假设所有语句都在一个文件中。**将 ;; 替换为 in：** 可以将多个语句串联为一个表达式，使用 `let` 和 `in` 构造。
- **交互式循环（REPL）：****即时编译执行：** 在 OCaml 的交互式环境中，可以立即编译和执行输入的语句。**结果输出：** 执行结果会被打印到终端，方便即时查看。
**注意：**

*“我们使用交互模式来演示大多数示例。输入语句以双分号“;;”结束。当有用时，解释器的输出才会显示出来。然后，它以较小的字体出现，并以双竖线“”开头。错误消息有时可能很冗长，因此我们不会总是完整地显示它们。相反，我们使用“ihih”来标记将被编译器拒绝的输入语句。一些更大的示例，称为实现笔记，被水平括号括起来，如下所示：”*

**解读：**

- **示例演示方式：****使用交互模式（REPL）：** 为了直观演示代码执行。**输入语句以 ;; 结束：** 表示一个语句的结束，触发执行。
- **输出格式：****仅在有用时显示输出：** 避免不必要的冗长。**输出格式：** 使用较小字体，前面有双竖线 `||`。
- **错误消息：****可能很长，不会总是完整显示：** 为了简洁。**使用“ihih”标记错误语句：** 表示这个语句会被编译器拒绝。
- **实现笔记（Implementation notes）：****用水平括号括起来：** 用于包含一些更大的示例或深入的解释。
**实现笔记，文件 README**

*“实现笔记被像这样括起来。它们包含用英语（而不是 OCaml 注释）编写的解释和几个 OCaml 短语。

let readme = "lisez-moi";;

所有笔记的短语属于同一个文件（这个属于 README），并且旨在被编译（而不是解释）。”*

**解读：**

- **实现笔记的目的：** 提供更深入的解释或示例，可能涉及多个相关的代码片段。
- **包含的内容：****英文解释：** 直接用英语写的说明，而不是代码注释。**OCaml 代码：** 一个或多个相关的代码片段。
- **示例：****let readme = "lisez-moi";;**：将字符串 "lisez-moi" 绑定到变量 readme。
- **编译而非解释：****这些代码片段是打算被编译的：** 可能需要放在文件中，通过编译器编译，而不是在交互式环境中直接运行。
**示例：**

*“作为示例，以下是在交互式循环中评估的几个短语。

print_string "Hello\n";;
Hello
− : unit = ()

let pi = 4.0 *. atan 1.0;;
val pi : float = 3.141593

let square x = x *. x;;
val square : float -&gt; float = &lt;fun&gt;”*

**解读：**

- **第一个短语：****print_string "Hello\n";;**：打印字符串 "Hello\n"。**输出：**
```
Hello
− : unit = ()
```
**打印了 "Hello"：** `\n` 是换行符。**返回值：** `unit` 类型的值 `()`，表示没有有意义的返回值。
- **第二个短语：****let pi = 4.0 *. atan 1.0;;**：计算 π 的近似值。**解释：****atan 1.0：** 计算 1.0 的反正切，结果是 π/4。**乘以 4.0：** 得到 π。**输出：**
```arduino
val pi : float = 3.141593
```
**pi 的值：** 3.141593（近似值）。
- **第三个短语：****let square x = x *. x;;**：定义一个函数 `square`，计算浮点数的平方。**输出：**
```kotlin
val square : float -&gt; float = 
```
**类型签名：** 接受一个 `float`，返回一个 `float`。**`&lt;fun&gt;`：表示这是一个函数。
**错误示例：**

*“对类型的不匹配，通常揭示了程序员的错误，被检测并报告：

square "pi";;
Characters 7−11:
This expression has type string but is here used with type float”*

**解读：**

- **尝试调用 square "pi";;：** 用字符串 `"pi"` 作为参数。
- **错误信息：****Characters 7−11:** 指出错误发生的位置。**This expression has type string but is here used with type float：****表达式类型是 string，但预期类型是 float。**
- **解释：****square 函数期望一个 float 参数，但传入了一个 string，导致类型错误。**
**递归函数示例：**

*“函数定义可以是递归的，前提是明确要求，使用关键字 `rec`：

let rec fib n = if n &lt; 2 then 1 else fib(n−1) + fib(n−2);;
val fib : int -&gt; int = &lt;fun&gt;

fib 10;;
− : int = 89”*

**解读：**

- **定义斐波那契函数 fib：****使用 let rec：** 表示这是一个递归函数。**函数体：****if n &lt; 2 then 1 else fib(n−1) + fib(n−2)****递归计算斐波那契数列。**
- **函数类型：****val fib : int -&gt; int = &lt;fun&gt;：** 接受一个 int，返回一个 int。
- **调用 fib 10;;****输出：**
```arduino
− : int = 89
```
**第10个斐波那契数是89。**
**高阶函数示例：**

*“函数可以作为参数传递给其他函数，或作为结果接收，从而导致高阶函数，也称为函数式。

例如，两个函数的组合可以完全按照数学中的方式定义：

let compose f g = fun x -&gt; f (g x);;
val compose : (’a -&gt; ’b) -&gt; (’c -&gt; ’a) -&gt; ’c -&gt; ’b = &lt;fun&gt;”*

**解读：**

- **定义函数组合 compose：****let compose f g = fun x -&gt; f (g x);;****接受两个函数 f 和 g，返回它们的组合函数。**
- **类型签名：****val compose : (’a -&gt; ’b) -&gt; (’c -&gt; ’a) -&gt; ’c -&gt; ’b****f 的类型：'a -&gt; 'b****g 的类型：'c -&gt; 'a****结果函数的类型：'c -&gt; 'b**
- **解释：****compose f g 返回一个函数，接受参数 x，先计算 g x，然后计算 f (g x)。**
**函数的幂示例：**

*“OCaml 中最能说明函数威力的可能是函数“power”本身！

let rec power f n =
if n &lt;= 0 then (fun x -&gt; x) else compose f (power f (n−1));;
val power : (’a -&gt; ’a) -&gt; int -&gt; ’a -&gt; ’a = &lt;fun&gt;”*

**解读：**

- **定义函数 power：****let rec power f n =****递归地计算函数 f 的 n 次组合，即 f 的 n 次幂。**
- **函数体：****if n &lt;= 0 then (fun x -&gt; x)****如果 n 小于等于 0，返回恒等函数 fun x -&gt; x。****else compose f (power f (n−1))****否则，返回 f 与 power f (n−1) 的组合。**
- **类型签名：****val power : (’a -&gt; ’a) -&gt; int -&gt; ’a -&gt; ’a****接受一个函数 f，一个整数 n，返回一个函数 ’a -&gt; ’a。**
- **解释：****power f n 相当于将函数 f 应用 n 次。**
**求导函数示例：**

*“在与数学的平行扩展中，我们可以定义任意函数 `f` 的导数。由于我们使用数值而非形式计算，导数由增量步长 `dx` 参数化：

let derivative dx f = function x -&gt; (f(x +. dx) −. f(x)) /. dx;;
val derivative : float -&gt; (float -&gt; float) -&gt; float -&gt; float = &lt;fun&gt;”*

**解读：**

- **定义数值求导函数 derivative：****let derivative dx f = function x -&gt; (f(x +. dx) -. f(x)) /. dx;;****使用差商 (f(x + dx) - f(x)) / dx 近似导数。**
- **类型签名：****val derivative : float -&gt; (float -&gt; float) -&gt; float -&gt; float****接受步长 dx，函数 f，返回一个函数 float -&gt; float。**
- **解释：****derivative dx f 返回函数 x 的数值导数。**
**计算三阶导数示例：**

*“然后，正弦函数的三阶导数 `sin'''` 可以通过计算导数函数的三次幂并将其应用于正弦函数来获得。最后，我们计算它在实数 `pi` 处的值。

let sin''' = (power (derivative 1e−5) 3) sin in sin''' pi;;
− : float = 0.999999”*

**解读：**

- **计算正弦函数的三阶导数：****power (derivative 1e−5) 3****将数值导数函数 derivative 1e−5 应用 3 次，即计算三阶导数。****(power ... ) sin****将上述结果应用于 sin 函数，得到 sin 的三阶导数函数 sin'''。**
- **计算 sin''' pi：****计算 sin''' 在 pi 处的值。**
- **输出：**
```arduino
− : float = 0.999999
```
**近似于 1，符合数学预期。**
- **解释：****利用高阶函数和函数组合，实现了数值求导和高阶导数的计算。**
**总结：**

- **函数式编程的强大表达能力：** 通过将函数作为一等公民，可以方便地实现复杂的数学运算和高阶函数。
- **高阶函数与数学的对应关系：** 代码中的操作与数学中的函数操作直接对应，增强了代码的可读性和可维护性。
**1.2 核心ML的语法**

**第一段：**

*“在继续介绍 OCaml 的更多特性之前，让我们看看如何对语言的一个非常简单的子集进行形式化。”*

**解读：**

- **形式化语言子集：** 作者计划对核心ML的一个极简子集进行形式化描述，以便更深入地理解其语法和语义。
- **目的是为后续扩展奠定基础：** 通过理解这个核心子集，可以更容易地学习和理解OCaml的其他特性。
**第二段：**

*“通常，在给出语言的形式化介绍时，我们倾向于通过尽可能多地分解相似的构造来保持构造数量的精简，并通过简单的翻译（如语法糖）来解释派生的构造。”*

**解读：**

- **保持构造数量精简：** 在形式化语言时，为了简化模型，我们希望语言的基本构造尽可能少。
- **分解相似构造：** 将具有相似功能的构造进行归纳和统一。
- **使用语法糖：** 对于高级或方便的语言特性，可以通过语法糖的方式，从基本构造出发进行解释和实现。
**第三段：**

*“例如，在核心语言中，我们可以省略短语。也就是说，我们将绑定序列如 let x1 = a1;; let x2 = a2;; a 转换为形式 let x1 = a1 in let x2 = a2 in a 的表达式。类似地，数字、字符串，以及列表、对等值以及对这些值的操作，都可以被视为常量和常量对值的应用。”*

**解读：**

- **省略短语（phrases）：** 在核心语言的形式化中，可以不考虑程序的整体结构（如多条语句的序列），而是将其转换为嵌套的 `let ... in ...` 表达式。
- **示例转换：****从多个 let 语句：**
```bash
let x1 = a1;;
let x2 = a2;;
a
```
**转换为嵌套的 let 表达式：**
```bash
let x1 = a1 in
  let x2 = a2 in
    a
```
- **数字、字符串等：****将它们视为常量（constants）：** 可以统一处理基本类型的值。**对这些值的操作视为常量的应用：** 如加法、乘法等操作可以看作是函数的应用。
**第四段：**

*“形式上，我们假设一个常量集合 c ∈ C，它被划分为构造子 C ∈ C⁺ 和原语 f ∈ C⁻。常量还带有一个元数（arity），即我们假设从 C 到自然数的映射 arity。举例来说，整数和布尔值是元数为0的构造子，pair 是元数为2的构造子，算术运算如 + 或 × 是元数为2的原语，not 是元数为1的原语。直观地说，构造子是被动的：它们可以接受参数，但应该忽略参数的结构，只是用嵌入的参数构建更大的值。相反，原语是主动的：它们可以检查参数的结构，操作内部嵌入的值，并对其进行转换。这种常量和原语之间的区别将在下面定义它们的语义时更清晰地体现。”*

**解读：**

- **常量集合 C：** 包含所有的常量，包括构造子和原语。
- **构造子的定义：****C⁺：** 构造子的集合。**特征：****被动的：** 不改变或检查参数的结构，只是将参数组合起来。**示例：****整数、布尔值：** 元数为0的构造子，即不需要参数。**pair：** 元数为2的构造子，将两个值组合成一个对。
- **原语的定义：****C⁻：** 原语的集合。**特征：****主动的：** 可以检查参数的结构，执行计算或转换。**示例：****加法 +、乘法 ×：** 元数为2的原语。**逻辑非 not：** 元数为1的原语。
- **元数（arity）：** 一个常量所需的参数数量。
- **构造子与原语的区别：****构造子：** 构建数据结构，不进行计算。**原语：** 执行计算或操作，可能检查和改变参数的值。
**第五段：**

*“总之，表达式的语法如下所示：

a ::= x | λx.a | a a
{λ-演算}
| c | let x = a in a
c ::= C | f
{构造子 | 原语}”*

**解读：**

- **表达式（a）的可能形式：****变量 x：** 一个变量。**函数 λx.a：** 一个匿名函数，参数为 x，函数体为 a。**应用 a a：** 将一个表达式应用于另一个表达式。**常量 c：** 包括构造子和原语。**let x = a in a：** 绑定表达式。
- **常量（c）的可能形式：****构造子 C：** 如整数、布尔值、pair 等。**原语 f：** 如加法、乘法、逻辑非等。
- **总结：****基本上是 λ-演算的扩展，增加了常量和绑定构造。**
**实现笔记，文件 syntax.ml**

*“表达式可以在 OCaml 中通过它们的抽象语法树来表示，即类型 expr 的元素：

type name = Name of string | Int of int;;
type constant = { name : name; constr : bool; arity : int}
type var = string
type expr =
| Var of var
| Const of constant
| Fun of var * expr
| App of expr * expr
| Let of var * expr * expr;;

为了方便起见，我们定义辅助函数来构建常量。

let plus = Const {name = Name "+"; arity = 2; constr = false}
let times = Const {name = Name "*"; arity = 2; constr = false}
let int n = Const {name = Int n; arity = 0; constr = true};;

这是一个示例程序。

let e =
let plus_x n = App (App (plus, Var "x"), n) in
App (Fun ("x", App (App (times, plus_x (int 1)), plus_x (int (-1)))),
App (Fun ("x", App (App (plus, Var "x"), int 1)),
int 2));;

当然，一个完整的实现还应该提供一个词法分析器和一个解析器，以便可以使用具体语法输入表达式 e（如 (λx.x * x) ((λx.x + 1) 2)），并自动转换为上述的抽象语法树。”*

**解读：**

- **定义抽象语法树（AST）：****type name：** 表示常量的名称，可以是字符串或整数。**type constant：** 包含常量的名称、是否为构造子、元数。**type var：** 变量名，字符串类型。**type expr：** 表达式的可能形式，包括变量、常量、函数、应用、绑定。
- **辅助函数：****plus：** 表示加法原语。**times：** 表示乘法原语。**int n：** 构造一个整数常量。
- **示例程序：****let plus_x n = App (App (plus, Var "x"), n)****定义一个函数，表示 x + n。****构建表达式 e：****外层应用：****App (Fun ("x", ...), App (Fun ("x", ...), int 2))****相当于 (λx. ... ) ( (λx. x + 1) 2 )****内部函数和应用：****构建一个函数，参数为 x，计算 ( x + 1 ) * ( x + ( -1 ) )**
- **解释：****手动构建了一个较复杂的表达式，演示如何使用抽象语法树来表示程序。**
- **词法分析器和解析器：****完整的实现应包括词法分析器和解析器：****将源代码（如 (λx.x * x) ((λx.x + 1) 2)）转换为抽象语法树。**
**总结：**

- **形式化语言语法：** 通过定义核心的语法规则，理解语言的基本结构。
- **抽象语法树的作用：** 在编译器和解释器中，抽象语法树是源代码的结构化表示，方便后续的分析和转换。
- **构造子和原语的区别：** 理解构造子和原语有助于区分数据的构建和操作，方便语言的设计和实现。
- **进一步的实现工作：** 完整的语言实现需要词法分析、语法解析等步骤，将源代码转换为抽象语法树，再进行编译或解释。
**整体理解：**

通过对核心ML的语法和示例的详细解读，我们可以看到：

- **核心ML的简洁性和表达能力：** 通过少量的基本构造，可以表达复杂的程序逻辑。
- **函数式编程的思想：** 函数是一等公民，可以传递、组合和操作，支持高阶函数。
- **形式化语法的意义：** 有助于理解语言的本质，为语言的分析和实现奠定基础。
- **实现细节的重要性：** 从抽象语法树到解析器的实现，需要对语言的各个部分有深入的理解。
**后续学习建议：**

- **深入理解 λ-演算：** 作为函数式编程的理论基础，掌握 λ-演算有助于理解函数的本质。
- **实践编程：** 通过编写实际的 OCaml 程序，巩固对语法和语义的理解。
- **研究编译器原理：** 学习词法分析、语法解析、类型检查等编译器技术，理解语言实现的过程。
- **探索高级特性：** 在掌握核心ML后，可以进一步学习 OCaml 的其他特性，如模块系统、对象和类等。
  



**详细解读：**

**1.3 核心ML的动态语义**

**理解语义的必要性**

定义一门编程语言的语法只是完整定义语言的第一步。语法规定了哪些程序是形式正确的，即哪些符号序列被认为是有效的输入。然而，语法并没有告诉我们这些程序应该如何计算，也没有说明它们的含义。为了完全理解和定义编程语言，我们需要指定其**语义**，即为语法正确的程序赋予意义。

换句话说，语法告诉我们程序的形式，而语义告诉我们程序的行为。

**操作语义与指称语义**

定义编程语言语义主要有两种方法：

1. **操作语义（Operational Semantics）**：描述程序的执行过程，定义如何一步一步地评估程序。这种方法直观，接近程序在实际计算机上的执行方式，适用于证明关于程序执行的属性，如一致性（收敛性）或类型健全性。然而，由于涉及许多低级细节，对于某些证明来说会变得复杂。
2. **指称语义（Denotational Semantics）**：将程序映射到数学结构中的对象（称为域），赋予程序数学意义，独立于其在机器上的执行。指称语义更加抽象，不涉及程序的语法或执行过程。然而，构建这些数学域可能很困难，但它可以以极其简洁的方式证明一些复杂的属性。
这两种方法是互补的。在这里，我们将专注于**操作语义**，特别是为了理解核心ML的评价过程及其正确性。

**操作语义和化简语义**

操作语义将程序与其评估结果（称为**答案**）联系起来。其中，**值（values）**是正常评估的结果，不包含错误或无限循环。

**化简语义（Reduction Semantics）是操作语义的一种特殊情况，它通过使用化简规则一步一步地（小步）简化程序，定义了程序之间的关系。每个化简步骤将程序转换为更简单的形式，直到达到值。这种方法也称为小步操作语义（Small-Step Operational Semantics）或结构化操作语义（Structural Operational Semantics）**。

另一种方法是**大步操作语义（Big-Step Operational Semantics）**，也称为**自然语义（Natural Semantics）**，它通过可能的递归定义，直接将整个程序映射到其结果。

**1.3.1 化简语义**

在核心ML中，**传值调用（Call-by-Value）**的化简语义通过特定的值和化简规则来定义。

**核心ML中的值：**

- **函数**：形式为 λx.a 的表达式（lambda抽象）。
- **构造值（Constructed Values）**：构造子应用于与其元数（arity）匹配的值。例如，如果 C 是元数为 n 的构造子，那么 C v1 ... vn 是一个值，其中每个 vi 都是值。
- **部分应用的常量（Partially Applied Constants）**：原语或构造子应用于少于其元数的参数。例如，如果 f 是元数为 n 的原语，那么 f v1 ... vk（k &lt; n）是一个值。
用代码表示，我们将值 `v` 表示为：

```plaintext
v ::= λx.a | C v1 ... vn | c v1 ... vk (k &lt; n)
```

其中，`C` 表示构造子，`c` 表示常量（原语）。

**部分应用的常量的行为：**

一个部分应用的常量 `c v1 ... vk` 表现得像一个接受剩余参数的函数。例如，它等价于 `λx_{k+1} ... λx_n. c v1 ... vk x_{k+1} ... x_n`。

**在OCaml中实现值**

在OCaml实现中，我们可以使用谓词 `evaluated` 来检查表达式是否为值。

```ocaml
let rec evaluated = function
  | Fun (_, _) -&gt; true
  | u -&gt; partial_application 0 u

and partial_application n = function
  | Const c -&gt; (c.constr || c.arity &gt; n)
  | App (u, v) -&gt; (evaluated v && partial_application (n+1) u)
  | _ -&gt; false;;
```

- Fun (_, _) 表示lambda抽象（函数），总是一个值。
- Const c 检查常量是否为构造子（c.constr），或者尚未完全应用（c.arity &gt; n）。
- App (u, v) 表示应用，当 u 是常量且 v 是值时，是一个部分应用。
**化简规则（Redexes）**

化简规则定义了如何简化表达式。核心的化简规则（红ex）包括：

1. **Beta化简（βv）**：
```plaintext
(λx.a) v → a[v/x]
```
该规则表示将函数应用于值，结果是将函数体中的参数替换为该值。
2. **Let绑定（Letv）**：
```plaintext
let x = v in a → a[v/x]
```
类似于Beta化简，`let`绑定将 `a` 中的 `x` 替换为 `v`。
3. **Delta规则（δ）**：对于原语（常量），我们有特定的规则定义它们如何操作其参数。例如，对于加法：
```plaintext
(+) p q → n   其中 n 是 p + q 的结果
```
这里，`p` 和 `q` 是整数值，`n` 是它们的和。
在代码中，我们可以为算术操作表示delta规则：

```ocaml
exception Reduce;;

let delta_bin_arith op code = function
  | App (App (Const { name = Name _; arity = 2 } as c,
              Const { name = Int x }),
         Const { name = Int y })
    when c = op -&gt; int (code x y)
  | _ -&gt; raise Reduce;;

let delta_plus = delta_bin_arith plus ( + );;
let delta_times = delta_bin_arith times ( * );;

let delta_rules = [ delta_plus; delta_times ];;

let delta = List.fold_right union delta_rules (fun _ -&gt; raise Reduce);;
```

- delta_bin_arith 是一个函数，接受操作符 op 和一个函数 code（如 (+) 或 (*)），并返回一个函数，尝试应用该操作。
- delta_plus 和 delta_times 是针对加法和乘法的特定实例。
- delta 将所有delta规则组合在一起。
**替换（Substitution）**

为了实现Beta化简，我们需要执行替换，将变量替换为表达式中的值。由于我们替换的是值（闭合的表达式），我们不必担心变量捕获（无需α转换）。

以下是替换的实现：

```ocaml
let rec subst x v a =
  assert (evaluated v);
  match a with
  | Var y -&gt;
      if x = y then v else a
  | Fun (y, a') -&gt;
      if x = y then a else Fun (y, subst x v a')
  | App (a', a'') -&gt;
      App (subst x v a', subst x v a'')
  | Let (y, a', a'') -&gt;
      if x = y then Let (y, subst x v a', a'') else Let (y, subst x v a', subst x v a'')
  | Const c -&gt; Const c;;
```

- 当遇到变量 x 时，我们将其替换为值 v。
- 我们递归遍历表达式，注意不要在重新绑定 x 的函数或 let 绑定中替换。
**顶级化简函数**

我们可以定义一个顶级化简函数，尝试应用Beta化简或delta规则：

```ocaml
let top_reduction = union beta delta;;
```

这里，`union` 是一个函数，先尝试应用 `delta`，如果失败，则尝试 `beta`。

**评价上下文（Evaluation Contexts）**

评价上下文指定了表达式中可以发生化简的位置。在传值调用语义中，评价上下文被定义为确保函数参数在函数应用之前被评估。

ML的评价上下文（传值调用）：

```plaintext
E ::= [·] | E a | v E | let x = E in a
```

- [·] 表示一个可以发生下一次化简的孔洞。
- E a 表示我们可以在应用的左部进行化简。
- v E 允许在右部化简，前提是左部是值。
- let x = E in a 允许在被绑定的表达式中进行化简。
**定义小步化简**

小步化简通过以下方式定义：

1. 在当前评价上下文中应用redex：如果 `a → a'`，则 `E[a] → E[a']`。
2. 评价关系是小步化简的传递闭包。
根据这些规则，值是不可化简的。

**实现评价**

根据小步语义，有多种方法实现评价。

**直接递归评价**

我们可以定义一个递归的评价函数，遍历表达式树，按照评价上下文指定的顺序评估子表达式。

```ocaml
let rec eval =
  let eval_top_reduce a = try eval (top_reduction a) with Reduce -&gt; a in
  function
  | App (a1, a2) -&gt;
      let v1 = eval a1 in
      let v2 = eval a2 in
      eval_top_reduce (App (v1, v2))
  | Let (x, a1, a2) -&gt;
      let v1 = eval a1 in
      eval_top_reduce (Let (x, v1, a2))
  | a -&gt;
      eval_top_reduce a;;
```

- 在应用 App (a1, a2) 中，评估器首先评估 a1 和 a2。
- 然后，尝试使用 top_reduction 进行化简。
**逐步化简**

或者，为了更贴近小步语义，我们可以实现一个一次执行一个化简步骤的评价函数。

```ocaml
let rec eval_step = function
  | App (a1, a2) when not (evaluated a1) -&gt;
      App (eval_step a1, a2)
  | App (a1, a2) when not (evaluated a2) -&gt;
      App (a1, eval_step a2)
  | Let (x, a1, a2) when not (evaluated a1) -&gt;
      Let (x, eval_step a1, a2)
  | a -&gt; top_reduction a;;
```

- 函数 eval_step 找到下一个可化简的表达式并对其进行化简。
- 这种方法使评价步骤更加明确。
**显式使用评价上下文**

在文本中提供的练习中，建议使用数据结构显式表示评价上下文。这使我们能够直接检查和操作上下文，对于某些分析或转换非常有用。

提供了使用**拉链（Zipper）**概念的上下文表示方法。

**拉链（Zipper）**

- 拉链是一种表示数据结构（如树）的方法，专注于特定元素，允许高效的导航和更新。
- 在评价上下文中，我们可以将上下文表示为从焦点（当前表达式）回到表达式树根的路径。
**在OCaml中定义上下文**

```ocaml
type context =
  | Top
  | AppL of context * expr
  | AppR of value * context
  | LetL of string * context * expr
and value = int * expr
```

- Top 表示表达式的根。
- AppL 和 AppR 分别表示应用的左部和右部。
- LetL 表示一个 let 绑定的上下文。
**操作上下文的函数**

- context_fill 根据上下文和表达式重建完整的表达式。
- decompose_down 向下导航表达式树，找到下一个可化简的表达式。
- decompose_up 向上导航上下文，找到下一个评价位置。
**示例评价**

考虑表达式：

```plaintext
(λx.(x * x)) ((λx.(x + 1)) 2)
```

化简步骤为：

1. 评估 `((λx.(x + 1)) 2)`：
```plaintext
(λx.(x * x)) ((λx.(x + 1)) 2)
→ (λx.(x * x)) (2 + 1)          // Beta化简
```
2. 计算 `2 + 1`：
```plaintext
→ (λx.(x * x)) 3                // Delta规则（加法）
```
3. 应用外部函数：
```plaintext
→ (3 * 3)                       // Beta化简
```
4. 计算 `3 * 3`：
```plaintext
→ 9                             // Delta规则（乘法）
```
**关于表示评价上下文的练习**

在练习中，要求你实现函数来显式表示和操作评价上下文。这包括：

- 定义 context_fill 来根据上下文重建表达式。
- 实现 decompose_down 和 decompose_up 来导航表达式和上下文。
- 使用这些函数执行逐步评价和跟踪。
**1.3.2 化简的性质**

**传名调用与传值调用**

在传值调用策略中，函数参数在函数应用之前被评估。相反，在**传名调用（Call-by-Name）**策略中，参数在传递给函数之前不被评估。

为了定义传名调用的化简：

- 将传值调用的Beta化简规则 `(βv)` 替换为不要求参数为值的版本：
```plaintext
(λx.a) a₀ → a[a₀/x]    // (βn)
```
- 类似地，修改 `let` 绑定规则。
- 调整评价上下文，防止在函数应用之前评估参数。
这种策略可能导致计算的重复，因为参数被直接替换而未被预先评估。

**传名调用的化简示例**

使用相同的表达式：

```plaintext
(λx.x * x) ((λx.x + 1) 2)
```

在传名调用下的化简步骤为：

1. 替换参数：
```plaintext
→ ((λx.x + 1) 2) * ((λx.x + 1) 2)
```
2. 化简左操作数：
```plaintext
→ (2 + 1) * ((λx.x + 1) 2)
```
3. 计算 `2 + 1`：
```plaintext
→ 3 * ((λx.x + 1) 2)
```
4. 化简右操作数：
```plaintext
→ 3 * (2 + 1)
```
5. 计算 `2 + 1`：
```plaintext
→ 3 * 3
```
6. 计算 `3 * 3`：
```plaintext
→ 9
```
注意 `((λx.x + 1) 2)` 被评估了两次，导致了计算的重复。

**按需调用（惰性求值）**

为了避免重复，**按需调用（Call-by-Need）**（或惰性求值）共享表达式的评估，使得一个表达式至多被评估一次。实现按需调用需要更复杂的机制，如记忆化或闭包。

**确定性和一致性**

我们定义的传值调用化简策略是确定性的；在每一步，至多有一个可应用的化简规则。然而，通过改变评价上下文，我们可以引入非确定性。

例如，如果我们允许评价上下文包含 `E a` 和 `a E`（即，我们不指定函数和参数的评估顺序），则评价顺序是不确定的。

**Church-Rosser性质**

如果一个化简关系具有**Church-Rosser性质**，则当一个表达式可以通过不同的路径化简到两个不同的结果时，存在一个公共的表达式，这两个结果都可以进一步化简到该表达式。

在具有副作用的语言中，Church-Rosser性质通常不成立，因为评价顺序会影响程序的行为。

**评价分类**

在确定性的传值调用语义下，程序的评价可以导致：

1. **正常评价**：程序化简为一个值。
2. **运行时错误**：程序达到一个不可化简但非值的表达式（例如，对非函数进行应用）。
3. **发散（无限循环）**：程序的评价无限进行，既不达到值，也不发生错误。
类型系统旨在防止运行时错误，确保类型正确的程序不会“卡住”（即，达到一个不可化简的非值表达式）。然而，由于停机问题的不可判定性，它不能保证程序的终止。

**1.3.3 大步操作语义**

虽然化简语义（小步语义）简洁且模块化，但它假设值是程序的子集。在我们希望将值与程序语法分离的情况下，使用**大步操作语义**可能更合适。

**大步语义**

在大步语义中，我们定义一个关系，将程序直接（可能通过递归定义）映射到它们的值。这种方法通常更适合于实现目的。

在核心ML的大步语义中，评价在环境 `ρ` 中定义，环境将变量映射到值。

**值和答案**

- **值（v）**：与之前类似，但我们可能将函数表示为**闭包（closure）**，它将函数代码与定义它的环境配对。
```plaintext
v ::= ⟨λx.a, ρ⟩ | C v1 ... vn | c v1 ... vk  (k &lt; n)
```
- **答案（r）**：值或显式的 `error`。
**评价关系**

评价关系写作 `ρ ⊢ a ⇒ r`，表示在环境 `ρ` 中，表达式 `a` 评估为结果 `r`。

**推导规则**

大步语义使用推导规则定义，指定表达式如何根据其子表达式进行评价。

例如，函数应用的规则是：

```plaintext
Eval-App:
ρ ⊢ a ⇒ ⟨λx.a₀, ρ₀⟩    ρ ⊢ a₁ ⇒ v    ρ₀[x ↦ v] ⊢ a₀ ⇒ v₀
-----------------------------------------------
         ρ ⊢ a a₁ ⇒ v₀
```

该规则表示：

- 如果 a 评估为闭包 ⟨λx.a₀, ρ₀⟩，
- 并且 a₁ 评估为值 v，
- 并且在扩展的环境 ρ₀[x ↦ v] 中评估 a₀ 得到 v₀，
- 那么应用 a a₁ 评估为 v₀。
**错误传播**

大步语义必须显式处理错误及其传播。这导致了针对子表达式评估为错误的情况的额外规则。

**在OCaml中实现大步语义**

基于大步语义的解释器可以如下实现。

**值的表示**

```ocaml
type env = (string * value) list
and value =
  | Closure of var * expr * env
  | Constant of constant * value list
```

- **闭包**：表示函数及其环境。
- **常量**：原语或构造子及其参数。
**答案类型**

```ocaml
type answer = Error | Value of value;;
```

- 使用 Error 值来表示运行时错误。
**评价函数**

```ocaml
let rec eval env = function
  | Var x -&gt; get x env
  | Const c -&gt; Value (Constant (c, []))
  | Fun (x, a) -&gt; Value (Closure (x, a, env))
  | Let (x, a1, a2) -&gt;
      begin match eval env a1 with
      | Value v1 -&gt; eval ((x, v1)::env) a2
      | Error -&gt; Error
      end
  | App (a1, a2) -&gt;
      begin match eval env a1 with
      | Value v1 -&gt;
          begin match v1, eval env a2 with
          | Constant (c, l), Value v2 -&gt;
              let k = List.length l + 1 in
              if c.arity &lt; k then Error
              else if c.arity &gt; k then Value (Constant (c, v2::l))
              else if c.constr then Value (Constant (c, v2::l))
              else delta c (v2::l)
          | Closure (x, e, env0), Value v2 -&gt;
              eval ((x, v2) :: env0) e
          | _, Error -&gt; Error
          end
      | Error -&gt; Error
      end
  | _ -&gt; Error;;
```

- 函数 eval 递归地评估表达式。
- 它处理变量、常量、函数、let 绑定和应用。
- 错误被显式管理，反映了大步语义中的错误传播。
**Delta函数**

```ocaml
let delta c l =
  match c.name, l with
  | Name "+", [Constant ({name=Int u}, []); Constant ({name=Int v}, [])] -&gt;
      val_int (u + v)
  | Name "*", [Constant ({name=Int u}, []); Constant ({name=Int v}, [])] -&gt;
      val_int (u * v)
  | _ -&gt;
      Error;;
```

- delta 函数处理原语操作。
**优缺点**

- **大步语义的优点**：通常导致更简单、更直观的解释器。实现效率高，因为评价过程遵循程序的结构。
- **缺点**：在理论上不如小步语义精确。非模块化；添加新语言特性可能需要重新定义许多规则。无法轻松处理发散计算的性质。
总之，虽然大步语义在实现解释器时很实用，但小步语义为像核心ML这样的语言提供了更精确和模块化的理论框架。

**总结**

通过深入理解核心ML的动态语义，我们了解到：

- **语义的必要性**：语法仅定义程序的形式，语义赋予程序以行为和意义。
- **操作语义的两种方法**：小步（化简语义）和大步（自然语义），各有优缺点。
- **化简语义**：通过明确的化简规则和评价上下文，定义了程序的逐步求值过程。
- **评价上下文的重要性**：指定了在哪些位置可以进行化简，确保了计算的正确顺序。
- **不同的调用策略**：传值调用、传名调用和按需调用，影响了程序的计算方式和效率。
- **大步语义的实用性**：在实现解释器时更直观，但在理论分析中可能不如小步语义精确。
通过理解这些概念，我们可以更深入地掌握核心ML语言的工作原理，并为后续的编程语言学习和研究奠定坚实的基础。
  



**补充详解：**

**1.3.3 大步操作语义（续）**

在之前的解读中，我们提到了大步操作语义的推导规则。这些规则详细地定义了在给定环境下，如何将表达式评估为值或错误。接下来，我们将深入解释 **图1.1** 中给出的核心ML的大步化简规则。

### 图1.1：核心ML的大步化简规则

**Eval-Const**

$$
\frac{\rho \vdash a \Rightarrow v}{\rho \vdash C_1\ a \Rightarrow C_1\ v}
$$

**Eval-Const-Error**

$$
\frac{\rho \vdash a \Rightarrow error}{\rho \vdash c\ a \Rightarrow c\ error}
$$

**Eval-Prim**

$$
\frac{\rho \vdash a \Rightarrow v_1 \quad v_1 \rightarrow v_0}{\rho \vdash f_1\ a \Rightarrow v_0}
$$

**Eval-Prim-Error**

$$
\frac{\rho \vdash a \Rightarrow v_1 \quad v_1 \nrightarrow v_0}{\rho \vdash f_1\ a \Rightarrow error}
$$

**Eval-Var**

$$
\frac{z \in dom(\rho)}{\rho \vdash z \Rightarrow \rho(z)}
$$

**Eval-Fun**

$$
\frac{}{\rho \vdash \lambda x.a \Rightarrow \langle \lambda x.a, \rho \rangle}
$$

**Eval-App**

$$
\frac{\rho \vdash a \Rightarrow \langle \lambda x.a_0, \rho_0 \rangle \quad \rho \vdash a' \Rightarrow v \quad \rho_0[x \mapsto v] \vdash a_0 \Rightarrow v_0}{\rho \vdash a\ a' \Rightarrow v_0}
$$

**Eval-App-Error**

$$
\frac{\rho \vdash a \Rightarrow C_1\ v_1}{\rho \vdash a\ a' \Rightarrow error}
$$

**Eval-App-Error-Left**

$$
\frac{\rho \vdash a \Rightarrow error}{\rho \vdash a\ a' \Rightarrow error}
$$

**Eval-App-Error-Right**

$$
\frac{\rho \vdash a \Rightarrow \langle \lambda x.a_0, \rho_0 \rangle \quad \rho \vdash a' \Rightarrow error}{\rho \vdash a\ a' \Rightarrow error}
$$

**Eval-Let**

$$
\frac{\rho \vdash a \Rightarrow v \quad \rho[x \mapsto v] \vdash a_0 \Rightarrow v_0}{\rho \vdash \text{let}\ x = a\ \text{in}\ a_0 \Rightarrow v_0}
$$

**Eval-Let-Error**

$$
\frac{\rho \vdash a \Rightarrow error}{\rho \vdash \text{let}\ x = a\ \text{in}\ a_0 \Rightarrow error}
$$

### 规则详解

接下来，我们逐一解释这些推导规则。

#### **1. Eval-Const**

**规则形式：**

$$
\frac{\rho \vdash a \Rightarrow v}{\rho \vdash C_1\ a \Rightarrow C_1\ v}
$$

**解释：**

- **前提（上方）：** 在环境 $\rho$ 下，表达式 $a$ 评估为值 $v$，记为 $\rho \vdash a \Rightarrow v$。
- **结论（下方）：** 那么，构造子 $C_1$ 应用于 $a$，即 $C_1\ a$，在环境 $\rho$ 下评估为 $C_1\ v$，其中 $v$ 是之前得到的值。
**含义：**

- 如果我们能够评估参数 $a$，并得到值 $v$，那么应用构造子 $C_1$ 于 $a$ 的结果就是将构造子应用于值 $v$，形成新的构造值 $C_1\ v$。
- **构造子**是用于构建数据结构的，如元组、列表等。
**示例：**

假设 $C_1$ 是构造子 `Some`，$a$ 是表达式 `3`，那么：

- $\rho \vdash 3 \Rightarrow 3$
- $\rho \vdash \text{Some}\ 3 \Rightarrow \text{Some}\ 3$
#### **2. Eval-Const-Error**

**规则形式：**

$$
\frac{\rho \vdash a \Rightarrow error}{\rho \vdash c\ a \Rightarrow c\ error}
$$

**解释：**

- **前提：** 在环境 $\rho$ 下，表达式 $a$ 评估为错误。
- **结论：** 那么，将常量 $c$ 应用于 $a$ 的结果是将 $c$ 应用于 error，即 $c\ error$。
**含义：**

- 如果参数 $a$ 评估为错误，那么应用常量 $c$ 于 $a$ 的结果也是错误。
- 这里的 **错误传播** 很重要，确保错误不会被忽略。
#### **3. Eval-Prim**

**规则形式：**

$$
\frac{\rho \vdash a \Rightarrow v_1 \quad v_1 \rightarrow v_0}{\rho \vdash f_1\ a \Rightarrow v_0}
$$

**解释：**

- **前提：**在环境 $\rho$ 下，表达式 $a$ 评估为值 $v_1$。$v_1$ 可以通过原语 $f_1$ 进一步计算，得到 $v_0$，记为 $v_1 \rightarrow v_0$。
- **结论：** 那么，应用原语 $f_1$ 于 $a$ 的结果是 $v_0$。
**含义：**

- **原语（Primitive）** 是基本的操作，如算术运算。
- 如果参数 $a$ 评估为值 $v_1$，并且原语 $f_1$ 能够将 $v_1$ 转换为 $v_0$，那么整体评估结果就是 $v_0$。
**示例：**

- $a$ 为表达式 2，$\rho \vdash 2 \Rightarrow 2$。
- $f_1$ 为函数 succ（后继函数，加1）。
- $2 \rightarrow 3$，因此 $\rho \vdash \text{succ}\ 2 \Rightarrow 3$。
#### **4. Eval-Prim-Error**

**规则形式：**

$$
\frac{\rho \vdash a \Rightarrow v_1 \quad v_1 \nrightarrow v_0}{\rho \vdash f_1\ a \Rightarrow error}
$$

**解释：**

- **前提：**在环境 $\rho$ 下，$a$ 评估为值 $v_1$。但 $v_1$ 无法通过原语 $f_1$ 计算得到值 $v_0$，即 $v_1 \nrightarrow v_0$。
- **结论：** 那么，应用原语 $f_1$ 于 $a$ 的结果是 error。
**含义：**

- 如果参数 $a$ 评估为某个值 $v_1$，但 $f_1$ 无法对其进行计算（例如，类型不匹配），则评估结果是错误。
**示例：**

- $a$ 为表达式 "hello"，$\rho \vdash "hello" \Rightarrow "hello"`。
- $f_1$ 为函数 succ。
- 因为 succ 不能作用于字符串，故产生错误。
#### **5. Eval-Var**

**规则形式：**

$$
\frac{z \in dom(\rho)}{\rho \vdash z \Rightarrow \rho(z)}
$$

**解释：**

- **前提：** 变量 $z$ 在环境 $\rho$ 中有绑定，即 $z \in dom(\rho)$。
- **结论：** 那么，变量 $z$ 在环境 $\rho$ 下评估为其在环境中的值 $\rho(z)$。
**含义：**

- 变量的评估就是从环境中查找其值。
#### **6. Eval-Fun**

**规则形式：**

$$
\frac{}{\rho \vdash \lambda x.a \Rightarrow \langle \lambda x.a, \rho \rangle}
$$

**解释：**

- **前提：** 无（这是一个公理）。
- **结论：** 在环境 $\rho$ 下，函数抽象 $\lambda x.a$ 评估为闭包 $\langle \lambda x.a, \rho \rangle$。
**含义：**

- 函数的评估结果是一个闭包，包括函数体和定义它的环境。
#### **7. Eval-App**

**规则形式：**

$$
\frac{\rho \vdash a \Rightarrow \langle \lambda x.a_0, \rho_0 \rangle \quad \rho \vdash a' \Rightarrow v \quad \rho_0[x \mapsto v] \vdash a_0 \Rightarrow v_0}{\rho \vdash a\ a' \Rightarrow v_0}
$$

**解释：**

- **前提：**在环境 $\rho$ 下，表达式 $a$ 评估为闭包 $\langle \lambda x.a_0, \rho_0 \rangle$。在环境 $\rho$ 下，表达式 $a'$ 评估为值 $v$。在扩展的环境 $\rho_0[x \mapsto v]$ 下，函数体 $a_0$ 评估为值 $v_0$。
- **结论：** 那么，函数应用 $a\ a'$ 在环境 $\rho$ 下评估为 $v_0$。
**含义：**

- 函数应用的评估步骤：评估函数部分，得到闭包。评估参数部分，得到值。在闭包的环境中，将参数值绑定到参数名，评估函数体。最终结果是函数体的评估结果。
**注意：**

- 这里的环境扩展 $\rho_0[x \mapsto v]$ 是关键，确保在正确的环境中评估函数体。
#### **8. Eval-App-Error**

**规则形式：**

$$
\frac{\rho \vdash a \Rightarrow C_1\ v_1}{\rho \vdash a\ a' \Rightarrow error}
$$

**解释：**

- **前提：** 在环境 $\rho$ 下，$a$ 评估为构造值 $C_1\ v_1$。
- **结论：** 那么，应用 $a\ a'$ 在环境 $\rho$ 下评估为 error。
**含义：**

- 如果试图将一个构造子应用于某个参数，这是非法的，产生错误。
- 函数应用要求函数部分评估为闭包，而不是构造值。
#### **9. Eval-App-Error-Left**

**规则形式：**

$$
\frac{\rho \vdash a \Rightarrow error}{\rho \vdash a\ a' \Rightarrow error}
$$

**解释：**

- **前提：** 在环境 $\rho$ 下，$a$ 评估为错误。
- **结论：** 那么，应用 $a\ a'$ 在环境 $\rho$ 下评估为错误。
**含义：**

- 如果函数部分评估为错误，整个应用的评估结果也是错误。
- **错误传播**：错误从函数部分传播到整个应用。
#### **10. Eval-App-Error-Right**

**规则形式：**

$$
\frac{\rho \vdash a \Rightarrow \langle \lambda x.a_0, \rho_0 \rangle \quad \rho \vdash a' \Rightarrow error}{\rho \vdash a\ a' \Rightarrow error}
$$

**解释：**

- **前提：**在环境 $\rho$ 下，$a$ 评估为闭包。但参数部分 $a'$ 评估为错误。
- **结论：** 那么，应用 $a\ a'$ 在环境 $\rho$ 下评估为错误。
**含义：**

- 如果参数部分评估为错误，整个应用的评估结果也是错误。
- **错误传播**：错误从参数部分传播到整个应用。
#### **11. Eval-Let**

**规则形式：**

$$
\frac{\rho \vdash a \Rightarrow v \quad \rho[x \mapsto v] \vdash a_0 \Rightarrow v_0}{\rho \vdash \text{let}\ x = a\ \text{in}\ a_0 \Rightarrow v_0}
$$

**解释：**

- **前提：**在环境 $\rho$ 下，$a$ 评估为值 $v$。在扩展的环境 $\rho[x \mapsto v]$ 下，$a_0$ 评估为值 $v_0$。
- **结论：** 那么，let 表达式在环境 $\rho$ 下评估为 $v_0$。
**含义：**

- let 绑定的评估步骤：评估被绑定的表达式 $a$，得到值 $v$。将 $v$ 绑定到 $x$，扩展环境。在新的环境中评估 $a_0$，得到结果 $v_0$。
#### **12. Eval-Let-Error**

**规则形式：**

$$
\frac{\rho \vdash a \Rightarrow error}{\rho \vdash \text{let}\ x = a\ \text{in}\ a_0 \Rightarrow error}
$$

**解释：**

- **前提：** 在环境 $\rho$ 下，$a$ 评估为错误。
- **结论：** 那么，let 表达式在环境 $\rho$ 下评估为错误。
**含义：**

- 如果被绑定的表达式评估为错误，整个 let 表达式评估为错误。
- **错误传播**：错误从绑定部分传播到整个 let 表达式。
### 总结

这些规则系统地定义了核心ML的大步操作语义，说明了在给定环境下，如何评估各种表达式，以及在何种情况下会产生错误。

**关键点：**

- **环境的作用**：环境 $\rho$ 存储变量的绑定，对于变量和函数的评估至关重要。
- **闭包的使用**：函数评估为闭包，包含函数体和定义时的环境。
- **错误处理和传播**：明确了在评估过程中可能出现的错误，以及如何将错误传播到更大的表达式中。
- **评估顺序的体现**：例如，在函数应用中，函数部分和参数部分的评估顺序，以及在 let 表达式中，先评估绑定部分，再评估主体。
### 实际应用

在实现解释器或编译器时，这些规则可以指导如何处理不同的表达式类型，如何管理环境，以及如何处理错误。

例如，在OCaml中实现解释器时，我们可以根据这些规则：

- 定义一个环境类型，存储变量绑定。
- 在评估函数应用时，先评估函数部分，再评估参数部分，然后在扩展的环境中评估函数体。
- 明确处理错误情况，确保错误不会被忽略或错误传播。
**补充说明**

- **大步语义的优点**：规则直观，直接反映了表达式的评估过程，便于实现。
- **大步语义的缺点**：不适合描述发散（无限循环）的情况，因为对于这些情况，没有可用的评估结果。
**结束语**

通过对图1.1中规则的详细解读，我们深入理解了核心ML的大步操作语义。这些规则不仅在理论上定义了语言的行为，还为实际的语言实现提供了明确的指导。
  



**详细解读：**

## **1.4 核心ML的静态语义**

在本节中，我们将介绍核心ML的静态语义，首先从简单类型开始。我们将呈现类型规则，解释类型推导、统一，然后引入多态性。最后，我们将讨论递归。

### **1.4.1 类型和程序**

**类型的引入**

核心ML的表达式是无类型的——它们不显式提及类型。然而，我们已经看到，一些表达式在语义上是无意义的。这些表达式在经过有限步的化简后会卡住（stuck），即不可化简且不是值。

**卡住（stuck）示例**

例如，当一个元数为0的常量（如整数 `2`）被应用于一个参数（如 `1`）时，会发生这种情况：

```plaintext
2 1
```

在这里，`2` 不是一个函数，却试图应用于 `1`，这是不合理的。

**防止卡住的必要性**

为了防止这种情况，我们需要排除不仅是卡住的程序，还要排除所有会化简到卡住程序的程序。这意味着我们需要排除一大类程序。

然而，决定一个程序在评估过程中是否会卡住与评估本身是等价的，这是不可判定的。为了安全起见，我们必须接受也会排除一些本来行为正确的程序。

**练习 2**

*(*) 证明：在没有常量的情况下，核心ML中没有自由变量的程序（即lambda演算）永远不会卡住。*

**解答：**

在纯lambda演算中，所有的表达式要么是值（lambda抽象），要么可以继续化简（通过beta化简）。因为没有常量，也没有可能导致错误的应用，因此不会卡住。

**类型的作用**

类型是一种强大的工具，用于分类程序，以确保良类型的程序在评估过程中不会卡住。直观地说，类型抽象了表达式的内部行为，只记住其他表达式的形状（类型），例如整数、布尔值、从整数到整数的函数等。这些类型可以作为参数传递给表达式，或者作为结果返回。

**类型的定义**

- 假设存在一个可数的类型符号集合 `g ∈ G`。每个符号都有固定的元数（arity）。
- 类型的集合由以下语法定义：
```plaintext
τ ::= α | gⁿ(τ₁, ..., τₙ)
```
α 表示类型变量。gⁿ 表示元数为 n 的类型构造子，应用于类型参数 τ₁ 到 τₙ。
**函数类型**

- 函数类型在ML中扮演着关键角色。
- 假设存在一个特殊的类型符号 →，它的元数为2。
- 我们用 τ → τ' 表示 →(τ, τ')。
**类型变量的自由变量**

- ftv(τ) 表示类型 τ 中出现的类型变量的集合。
**类型环境**

- 类型假设（或类型环境）A 是程序变量和常量到类型的部分映射。
- 我们使用 z 表示变量或常量，z ∈ dom(A) 表示 z 在环境 A 中有类型。
**类型判断**

- 类型判断表示为 A ⊢ a : τ，表示在类型环境 A 下，表达式 a 的类型为 τ。
**类型和类型判断的汇总**

**图1.2：类型、类型环境和判断的总结**

#### **图1.2**

**类型**

```plaintext
τ ::= α | τ → τ | gⁿ(τ₁, ..., τₙ)
```

- α：类型变量
- τ → τ：函数类型
- gⁿ(τ₁, ..., τₙ)：类型构造子
**类型环境**

```plaintext
A ::= ∅ | A, z : τ
```

- ∅：空类型环境
- A, z : τ：在类型环境 A 中添加 z 的类型为 τ
**变量和常量**

```plaintext
z ::= x | c
```

- x：变量
- c：常量
**类型判断**

```plaintext
A ⊢ a : τ
```

- 在类型环境 A 下，表达式 a 的类型为 τ
**类型规则**

类型判断是通过满足图1.3中的推导规则来定义的。

#### **图1.3：简单类型的类型规则**

**Var-Const（变量和常量）**

```plaintext
z ∈ dom(A)
———————
A ⊢ z : A(z)
```

- **解释**：如果 z（变量或常量）在类型环境 A 中有类型，那么它的类型就是 A(z)。
**Fun（函数抽象）**

```plaintext
A, x : τ ⊢ a : τ'
—————————————
A ⊢ λx.a : τ → τ'
```

- **解释**：如果在扩展的类型环境 A, x : τ 下，a 的类型为 τ'，那么函数抽象 λx.a 的类型为 τ → τ'。
**App（函数应用）**

```plaintext
A ⊢ a : τ' → τ    A ⊢ a' : τ'
————————————————————
A ⊢ a a' : τ
```

- **解释**：如果 a 的类型为 τ' → τ，a' 的类型为 τ'，那么应用 a a' 的类型为 τ。
**初始类型环境**

- 封闭的程序在初始类型环境 A₀ 下进行类型判断。
- 我们必须假设常量的类型假设与它们的元数一致。
**假设0（初始环境）**

- 初始类型环境 A₀ 的域是常量集合，并且尊重元数。
- 对于任何 Cⁿ ∈ dom(A₀)，A₀(Cⁿ) 的形式为 τ₁ → ... → τₙ → τ₀。
**类型健全性**

- 类型健全性断言良类型的程序不会出错。
- 这来自两个更强的性质：**类型的保持（Subject Reduction）**：化简保持类型，即如果 A ⊢ a : τ，并且 a → a'，那么 A ⊢ a' : τ。**进展性（Progress）**：良类型的程序要么是值，要么可以进一步化简。
**形式化类型的保持**

- 定义一个关系 `⊑`（用 `⊑` 代表原文的 `⊒`）表示类型的保持：
```plaintext
(a ⊑ a') ⇔ ∀(A, τ)(A ⊢ a : τ ⇒ A ⊢ a' : τ)
```
- `⊑` 关系表示两个程序之间类型判断的保持，不考虑它们的动态属性。
**假设1（常量的类型保持）**

- Delta化简（δ）保持类型，即 (δ) ⊆ (⊑)。
**定理1（类型的保持）**

- 化简保持类型。
**进展性**

- 对于良类型的程序，要么是值，要么可以进一步化简。
**假设2（常量的进展性）**

- Delta化简是良定义的。如果 A₀ ⊢ fⁿ v₁ ... vₙ : τ，那么 fⁿ v₁ ... vₙ ∈ dom(δ_f)。
**定理2（进展性）**

- 在初始环境下良类型的程序要么是值，要么可以进一步化简。
**Let绑定**

- 在简单类型下，我们可以将 `let` 表达式视为语法糖，定义为：
```plaintext
let x = a₁ in a₂ ≡ (λx.a₂) a₁
```
- 如果我们想直接为 `let` 节点定义类型规则，可以使用以下规则：
**Let-Mono（单态的Let绑定）**

```plaintext
A ⊢ a₁ : τ₁    A, x : τ₁ ⊢ a₂ : τ₂
—————————————————————————————
A ⊢ let x = a₁ in a₂ : τ₂
```

- **解释**：如果 a₁ 的类型为 τ₁，并且在扩展的类型环境 A, x : τ₁ 下，a₂ 的类型为 τ₂，那么 let 表达式的类型为 τ₂。
### **1.4.2 类型推导**

**类型推导的目的**

- 我们已经看到，良类型的表达式不会卡住。
- 但是，我们如何检查给定的表达式是否是良类型的呢？
- 类型推导的作用就是确定一个表达式是否是良类型的，并找到所有可以赋给它的类型。
**类型推导的问题**

- 给定一个类型环境 A，一个表达式 a，和一个类型 τ，找到所有的替换 θ，使得 θ(A) ⊢ a : θ(τ)。
- 一个解 θ 是问题 P 的**主解（principal solution）**，如果所有其他的解都是 θ 的实例，即存在替换 θ'，使得其他解是 θ' ∘ θ。
**定理3（主类型）**

- ML的类型推导问题存在主解。
- 也就是说，任何可解的类型推导问题都有一个主解。
- 此外，存在一个算法，给定任何类型推导问题，要么成功并返回一个主解，要么在无解时失败。
**初始类型环境**

- 通常，初始类型环境 A₀ 是封闭的，即不含有自由类型变量。
- 因此，找到一个在初始类型环境下闭合程序 a 的主类型，与找到类型推导问题 (A, a, α) 的主解是同一个问题。
**类型推导和类型判断的区别**

- 有一种类型推导问题的变体称为**类型判断（typing inference）**：给定一个表达式 a，找到最小的类型环境 A 和最小的类型 τ，使得 A ⊢ a : τ。
- ML没有主类型判断。
**解决类型推导问题的方法**

- 我们使用 A . a : τ 表示类型推导问题。
- 需要注意的是，A . a : τ 并不意味着 A ⊢ a : τ，前者是一个三元组的表示，后者是关于这个三元组的一个断言。
- 一个替换 θ 是类型推导问题 A . a : τ 的解，如果 θ(A) ⊢ a : θ(τ)。
**性质**

- 类型推导问题的解集在实例化下是封闭的（即，左组合任意替换）。
- 这源于类型判断的类似性质：如果 A ⊢ a : τ，那么对于任何替换 θ，都有 θ(A) ⊢ a : θ(τ)。
**约束问题**

- 这个性质允许将类型推导问题视为**约束问题**，这是统一问题的推广。
- 我们使用字母 `U` 表示约束问题，它可以是以下形式之一：
```plaintext
U ::= A . a : τ        （类型推导问题）
     τ₁ ⋍ ... ⋍ τₙ     （多重等式）
     U ∧ U            （约束问题的合取）
     ∃α. U            （存在量化）
     ⊥                （不可解）
     ⊤                （可解）
```
- 约束问题可以通过重写规则进行简化，最终化简为统一问题。
**约束问题的等价关系**

- 我们将约束问题在以下等价关系下进行辨识，这些等价关系显然保持了解集：合取 ∧ 是交换和结合的。约束问题 ⊥ 是吸收元，即 U ∧ ⊥ = ⊥。⊤ 是单位元，即 U ∧ ⊤ = U。对于存在量化 ∃α. U，如果 α 不在 U 中自由出现，那么可以进行变量重命名和量词外推。
**类型推导的简化规则**

**图1.4：类型推导问题的简化**

#### **图1.4**

**I-Var-Fail**

```plaintext
如果 x 不在 dom(A) 中
————————————
A . x : τ
   ⊥
```

- **解释**：如果变量 x 不在类型环境 A 中，那么类型推导失败，产生不可解的问题 ⊥。
**I-Var**

```plaintext
如果 x ∈ dom(A)
——————————————
A . x : τ
   τ ⋍ A(x)
```

- **解释**：如果变量 x 在类型环境 A 中，那么需要使得 τ 与 A(x) 相等，形成一个统一问题。
**I-Fun**

```plaintext
α₁, α₂ 不在 τ 和 A 的自由类型变量中
————————————————————————————
A . λx.a : τ
   ∃α₁, α₂.(A, x : α₁ . a : α₂ ∧ τ ⋍ α₁ → α₂)
```

- **解释**：对于函数抽象，引入两个新的类型变量 `α₁` 和 `α₂`，其中：参数 x 的类型为 α₁。函数体 a 的类型为 α₂。整个函数的类型 τ 必须等于 α₁ → α₂。
**I-App**

```plaintext
α 不在 τ 和 A 的自由类型变量中
————————————————————————
A . a₁ a₂ : τ
   ∃α.(A . a₁ : α → τ ∧ A . a₂ : α)
```

- **解释**：对于函数应用，引入一个新的类型变量 `α`，使得：a₁ 的类型为 α → τ。a₂ 的类型为 α。
**Let绑定的处理**

- 我们可以将 let 视为语法糖，或者使用从 Let-Mono 规则派生的简化规则。
**Let-Sugar**

```plaintext
A . let x = a₁ in a₂ : τ
   A . (λx.a₂) a₁ : τ
```

- **解释**：将 let 表达式转换为函数应用。
**Let-Mono**

```plaintext
A . let x = a₁ in a₂ : τ
   ∃α.(A . a₁ : α ∧ A, x : α . a₂ : τ)
```

- **解释**：引入一个新的类型变量 `α`，使得：a₁ 的类型为 α。在扩展的类型环境 A, x : α 下，a₂ 的类型为 τ。
**实现笔记（文件 infer.ml）**

- 由于常量是无限的（例如整数），我们将初始环境表示为一个将常量映射到类型的函数。
- 我们稍微偏离了形式化的表示，将常量的绑定（表示为全局函数 type_of_const）和变量的绑定分开。
```ocaml
exception Undefined_constant of string

let type_of_const c =
  let int3 = tarrow tint (tarrow tint tint) in
  match c.name with
  | Int _ -&gt; tint
  | Name ("+" | "*") -&gt; int3
  | Name n -&gt; raise (Undefined_constant n);;

exception Free_variable of var

let type_of_var tenv x =
  try List.assoc x tenv
  with Not_found -&gt; raise (Free_variable x);;

let extend tenv (x, t) = (x, t) :: tenv;;
```

- 类型推导使用下面定义的函数 unify 来解决统一问题。
**类型推导的实现**

```ocaml
let rec infer tenv a t =
  match a with
  | Const c -&gt; funify (type_of_const c) t
  | Var x -&gt; funify (type_of_var tenv x) t
  | Fun (x, a) -&gt;
      let tv1 = tvar() and tv2 = tvar() in
      infer (extend tenv (x, tv1)) a tv2;
      funify t (tarrow tv1 tv2)
  | App (a1, a2) -&gt;
      let tv = tvar() in
      infer tenv a1 (tarrow tv t);
      infer tenv a2 tv
  | Let (x, a1, a2) -&gt;
      let tv = tvar() in
      infer tenv a1 tv;
      infer (extend tenv (x, tv)) a2 t;;
```

- infer 函数递归地推导表达式的类型。
- type_of 函数用于获取表达式的类型。
### **1.4.3 简单类型的统一**

**统一问题的标准形式**

- 统一问题的正常形式是 ⊥、⊤ 或 ∃α. U，其中 U 是多重等式的合取，每个多重等式最多包含一个非变量项。
**解的求取**

- 通过对多重等式进行重新排列，可以将 U 转化为 α₁ ⋍ τ₁ ∧ ... ∧ αₙ ⋍ τₙ 的形式，其中变量 αⱼ 不在 τᵢ 中出现，i ≤ j。
- 如果找不到这样的排列，存在循环，则问题无解。
- 否则，替换 θ = (α₁ ↦ τ₁) ∘ ... ∘ (αₙ ↦ τₙ) 是一个主解。
**统一规则**

**图1.5：简单类型的统一规则**

#### **图1.5**

**Merge（合并）**

```plaintext
α ⋍ e₁ ∧ α ⋍ e₂
———————————
α ⋍ e₁ ⋍ e₂
```

- **解释**：如果有两个关于 α 的等式，那么可以将它们合并为一个多重等式。
**Decompose（分解）**

```plaintext
g(αᵢ∈I) ⋍ g(τᵢ∈I) ⋍ e
———————————————————————
g(αᵢ∈I) ⋍ e ∧ ∧_{i∈I}(αᵢ ⋍ τᵢ)
```

- **条件**：g 是相同的类型构造子。
- **解释**：如果两个类型构造子的名称相同，那么将它们的参数逐一对应，并生成新的等式。
**Fail（失败）**

```plaintext
如果 g₁ ≠ g₂
———————————
g₁(τ₁) ⋍ g₂(τ₂) ⋍ e
   ⊥
```

- **解释**：如果类型构造子的名称不同，则统一失败。
**Generalize（泛化）**

```plaintext
如果 τ₀ ∉ V，且 α ∉ ftv(g(α, τ₀, τ₀')) ∪ ftv(e)
———————————————————————————————
g(τ, τ₀, τ₀') ⋍ e
∃α.(g(τ, α, τ₀') ⋍ e ∧ α ⋍ τ₀)
```

- **解释**：通过引入新的类型变量 α，将复杂的类型替换为变量，生成新的等式。
**Trivial（平凡）**

```plaintext
α ⋍ α ⋍ e
———————————
α ⋍ e
```

- **解释**：消除重复的等式。
**Cycle（循环）**

```plaintext
如果 α_{i+1} ∈ ftv(eᵢ)，α₁ ∈ τ，τ ∈ e_n \ V
———————————————————————
∧_{i=1}^n (αᵢ ⋍ eᵢ) → ⊥
```

- **解释**：检测到循环，统一失败。
**统一算法的效率**

- 除了 Cycle 规则的侧条件外，每个规则的成本都是常数。
- 为了效率，循环检测应尽可能推迟到最后进行。
**规则的应用顺序**

- 规则的应用顺序可以是任意的，最终会产生相同的结果。
- 但是，在失败的情况下，算法应该帮助用户报告可理解的类型错误信息。
**实现笔记（文件 unify.ml）**

**类型和统一项的表示**

- 类型和统一项的定义是交织在一起的：统一项是类型之间的指针。类型可以由短类型（高度至多为1）表示，其叶子节点是被约束为等于某个其他类型的变量。
**类型的OCaml实现**

```ocaml
type type_symbol = Tarrow | Tint

type texp = { mutable texp : node; mutable mark : int }
and node = Desc of desc | Link of texp
and desc = Tvar of int | Tcon of type_symbol * texp list;;
```

- texp：表示类型表达式，包含可变的 texp 字段和 mark 字段用于标记节点。
- node：类型表达式的节点，可以是描述（Desc）或链接（Link）。
- desc：描述，可以是类型变量（Tvar）或类型构造子（Tcon）。
**辅助函数**

- tvar()：创建新的类型变量。
- repr t：获取类型 t 的表示形式，跟随链接到最终的表示。
- desc t：获取类型 t 的描述。
**统一函数的实现**

```ocaml
let rec unify t1 t2 =
  let t1 = repr t1 and t2 = repr t2 in
  if t1 == t2 then () else
  match desc t1, desc t2 with
  | Tvar _, _ -&gt;
      link t1 t2
  | _, Tvar _ -&gt;
      link t2 t1
  | Tcon (g1, l1), Tcon (g2, l2) when g1 = g2 -&gt;
      link t1 t2;
      List.iter2 unify l1 l2
  | _, _ -&gt; raise (Unify (t1, t2));;
```

- unify 函数尝试将类型 t1 和 t2 统一。
- 使用链接和描述来表示等式和多重等式。
- 在统一过程中，如果检测到循环，会在最后进行检测。
**循环检测**

```ocaml
let acyclic t =
  (* 循环检测的实现 *)
```

- 在统一完成后，使用 acyclic 函数检测类型中的循环。
**示例**

- 尝试统一以下类型：
```ocaml
let x = tvar() in funify x (tarrow x x);;
```
- 由于类型 `x` 需要等于 `x → x`，会导致循环，统一失败。
**练习 3**

*(*) 为非循环类型编写一个简单的类型的漂亮打印器（使用变量编号生成变量名）。*

**解答：**

- 我们可以使用深度优先搜索遍历类型表达式，避免重复打印相同的类型变量，生成可读的类型表示。
### **1.4.4 多态性**

**简单类型的局限性**

- 目前为止，我们只考虑了简单类型，不允许任何形式的多态性。
- 这在某些情况下会带来不便，例如身份函数 λx.x 的类型是 α → α。
- 我们期望它可以应用于任何类型的值，但在简单类型系统中，只能为整个程序选择一种类型 α。
**ML的多态性**

- ML 允许将类型方案赋给 let 绑定的变量，这就是ML多态性的载体。
- **类型方案**是一个形式为 ∀α. τ 的对，其中 α 是类型变量的集合，τ 是类型。
**类型方案**

- 一个类型方案的实例是将其所有量化变量 α 替换为简单类型 τ' 后得到的类型。
- 记号 τ[τ'/α] 表示在 τ 中用 τ' 替换 α。
**自由类型变量**

- ftv(∀α. τ) 表示类型方案 ∀α. τ 中的自由类型变量，即 ftv(τ) \ α。
**实现笔记（文件 type-scheme.ml）**

- 类型方案的表示是直接的：
```ocaml
type scheme = texp list * texp;;
```
**练习 4**

*(*) 为类型实现计算自由类型变量的函数 `ftv_type`。*

**解答：**

- 类似于循环检测，我们可以遍历类型表达式，收集其中的自由类型变量。
**类型实例化**

- 编写函数 type_instance，接受类型方案 σ，返回其类型实例。
**多态性的引入**

- 为了支持多态性，我们在类型环境中引入多态的绑定 z : σ。
- 所有的绑定都可以假设为形式 z : σ。
**Var-Const 规则的修改**

```plaintext
A(z) = ∀α. τ
——————————————
A ⊢ z : τ[τ'/α]
```

- **解释**：变量 z 的类型是类型方案 ∀α. τ，在使用时，需要将量化的类型变量替换为具体的类型。
**Let规则的修改**

```plaintext
A ⊢ a : τ    A, x : ∀(ftv(τ) \ ftv(A)). τ ⊢ a' : τ'
———————————————————————————————————————————————
A ⊢ let x = a in a' : τ'
```

- **解释**：在 let 绑定中，对 τ 进行尽可能多的泛化，将 τ 中不在 A 中出现的类型变量进行量化。
**类型推导的扩展**

- 类型推导也可以扩展以处理ML多态性。
**I-Var 规则的调整**

```plaintext
如果 A(x) = ∀α. τ' 且 α ∩ ftv(τ) = ∅
——————————————————————————
A . x : τ
   ∃α. τ ⋍ τ'
```

- **解释**：在类型推导中，使用 A(x) 的实例化类型。
**I-Let 规则的调整**

- Let 规则需要更多的注意，因为左右前提之间存在依赖关系。
**实现笔记（文件 poly.ml）**

- 多态类型推导的实现是对简单类型推导的直接修改。
**泛化变量的计算**

- 需要一个函数 generalizable 来计算可泛化的变量 ftv(τ) \ ftv(A)。
- 可以通过同时遍历类型 τ 和类型环境 A 来实现。
**类型推导算法的修改**

```ocaml
let rec infer tenv a t =
  match a with
  | Const c -&gt; unify (type_instance (type_of_const c)) t
  | Var x -&gt; unify (type_instance (type_of_var tenv x)) t
  | Fun (x, a) -&gt;
      let tv1 = tvar() and tv2 = tvar() in
      infer (extend tenv (x, ([], tv1))) a tv2;
      unify t (tarrow tv1 tv2)
  | App (a1, a2) -&gt;
      let tv = tvar() in
      infer tenv a1 (tarrow tv t);
      infer tenv a2 tv
  | Let (x, a1, a2) -&gt;
      let tv = tvar() in
      infer tenv a1 tv;
      let s = generalizable tenv tv, tv in
      infer (extend tenv (x, s)) a2 t;;
```

- 对于 Let 表达式，我们在推导 a1 的类型后，计算可泛化的变量，然后将泛化的类型方案加入类型环境。
**总结**

通过引入类型和类型推导，我们可以防止程序在评估过程中卡住。类型推导和统一算法使我们能够自动地为表达式推导类型，并验证其类型正确性。ML的多态性允许我们编写更加通用和灵活的代码。

**后续学习建议**

- **深入理解类型系统**：了解类型系统的理论基础，如类型推导、统一、多态性等。
- **实践编程**：尝试在ML或OCaml中编写代码，练习使用类型系统。
- **研究高级类型特性**：如类型类、GADT、类型推断等。
  



**详细解读：**

## **1.5 递归**

为了使ML语言具有图灵完备性，必须支持某种形式的**递归**。这通过 `let rec f = λx.a₁ in a₂` 的形式实现，它允许 `f` 在 `λx.a₁` 中递归地出现。递归表达式 `λx.a₁` 被限制为函数，因为在传值调用策略中，它对于任意表达式都不是良定义的。

### **1.5.1 不动点组合子（Fix-point Combinator）**

**引入不动点组合子**

与其在语言中添加新构造，我们可以利用语言定义中参数化的原语集合，通过引入一个新的原语 `fix`（元数为2）来实现递归，其类型为：

$$
\text{fix} : \forall \alpha_1, \alpha_2. ((\alpha_1 \rightarrow \alpha_2) \rightarrow \alpha_1 \rightarrow \alpha_2) \rightarrow \alpha_1 \rightarrow \alpha_2
$$

**fix 的语义**

`fix` 的语义由其 δ-规则给出：

$$
\text{fix}\ f\ v \rightarrow f\ (\text{fix}\ f)\ v \quad (\delta_{\text{fix}})
$$

- **解释**：fix 接受一个函数 f 和一个值 v，然后将 f 应用于 fix f 和 v。这实现了递归调用，其中 fix f 表示函数自身的递归应用。
**惰性计算的重要性**

由于 `fix` 的元数为2，在规则 $(\delta_{\text{fix}})$ 的右侧出现的表达式 `(fix f)` 是一个值，其求值被冻结，直到它出现在应用的求值上下文中。因此，评估必须继续对外部应用 `f` 进行化简。

**为什么需要 fix 的元数为2**

重要的是，`fix` 必须具有元数2，以便 `fix` 能够惰性地计算不动点。否则，如果 `fix` 的元数为1，并具有以下 δ-规则：

$$
\text{fix}\ f \rightarrow f\ (\text{fix}\ f)
$$

那么对 `fix f v` 的评估将陷入无限循环（活动部分下划线）：

$$
\underline{\text{fix}\ f}\ v \rightarrow \underline{f\ (\text{fix}\ f)}\ v \rightarrow f\ (\underline{f\ (\text{fix}\ f)})\ v \rightarrow \dots
$$

这里，`fix f` 不断被展开，没有机会应用于参数 `v`。

**let rec 的语法糖**

为了方便，我们可以将 `let rec f = λx.a₁ in a₂` 视为 `let f = fix (λf.λx.a₁) in a₂` 的语法糖。

**注释 4**

常量 `fix` 的行为与以下（无类型的）表达式完全相同：

$$
\lambda f_0.(\lambda f.\lambda x.f_0 (f\ f)\ x)\ (\lambda f.\lambda x.f_0 (f\ f)\ x)
$$

然而，这个表达式在ML中是不可类型化的（没有递归类型时）。

#### **练习 6**

*(*) **不动点的不可类型化**

验证上述给出的 `fix` 的定义在ML中是不可类型化的。

**解答：**

- 在ML的简单类型系统中，我们无法为 `fix` 赋予类型，因为它涉及到自引用的类型，即需要解决类型等式 `τ = τ → τ'`，这会导致无限类型。
- 因此，`fix` 的定义在没有递归类型的情况下是不可类型化的。
#### **练习 7**

*(*) **使用不动点组合子**

使用 `fix` 和 `let` 绑定（而不是 `let rec` 绑定）定义阶乘函数。

**解答：**

```ocaml
let factorial = fix (fun fact n -&gt;
  if n = 0 then 1 else n * fact (n - 1));;
```

- 这里，fact 是递归函数，通过 fix 实现递归。
- n 为输入参数，当 n = 0 时返回 1，否则返回 n * fact (n - 1)。
#### **练习 8**

*(**) **不动点组合子的类型健全性**

验证对于不动点组合子 `fix`，假设1和假设2是成立的。

**解答：**

- **假设1（类型的保持）**：δ-规则保持类型，即如果 `A ⊢ fix f v : τ`，并且 `fix f v → f (fix f) v`，那么 `A ⊢ f (fix f) v : τ`。由于 fix 的类型为 ((α₁ → α₂) → α₁ → α₂) → α₁ → α₂，并且 f 的类型匹配，那么类型保持成立。
- **假设2（进展性）**：δ-规则是良定义的，良类型的程序要么是值，要么可以进一步化简。fix 的 δ-规则定义明确，评估可以继续，因此假设2成立。
### **互相递归定义**

OCaml 允许**互相递归**的定义。例如：

```ocaml
let rec f1 = λx.a₁ and f2 = λx.a₂ in a
```

- 这里，f1 和 f2 可以在 a₁、a₂ 和 a 中互相出现。
**翻译为嵌套的 let rec**

这可以视为以下形式的缩写：

```ocaml
let rec f1' = λf2.λx. let f1 = f1' f2 in a₁ in
let rec f2' = λx. let f2 = f2' in let f1 = f1' f2 in a₂ in
a
```

- **解释**：f1' 是一个接受 f2 和 x 的函数，其内部定义了 f1 = f1' f2，然后计算 a₁。f2' 是一个接受 x 的函数，其内部定义了 f2 = f2' 和 f1 = f1' f2，然后计算 a₂。最后，在 a 中可以使用 f1 和 f2。
**一般化**

这可以容易地推广到：

```ocaml
let rec f1 = λx.a₁ and ... and fn = λx.aₙ in a
```

#### **练习 9**

*(*) **多个递归定义**

你能翻译三个递归函数的情况吗？

```ocaml
let rec f1 = λx.a₁ and f2 = λx.a₂ and f3 = λx.a₃ in a
```

**解答：**

```ocaml
let rec f1' = λf2 f3.λx. let f1 = f1' f2 f3 in a₁ in
let rec f2' = λf3.λx. let f2 = f2' f3 in let f1 = f1' f2 f3 in a₂ in
let rec f3' = λx. let f3 = f3' in let f2 = f2' f3 in let f1 = f1' f2 f3 in a₃ in
a
```

- **解释**：f1' 接受 f2、f3 和 x，内部定义 f1 = f1' f2 f3，然后计算 a₁。f2' 接受 f3 和 x，内部定义 f2 = f2' f3，然后定义 f1 = f1' f2 f3，计算 a₂。f3' 接受 x，内部定义 f3 = f3'，然后定义 f2 = f2' f3，再定义 f1 = f1' f2 f3，计算 a₃。在 a 中使用 f1、f2、f3。
### **递归与多态性**

由于表达式 `let rec f = λx.a in a₀` 被理解为 `let f = fix (λf.λx.a) in a₀`，因此在对函数体 `λx.a` 进行类型检查时，函数 `f` 是单态的，因为它出现在上下文 `λf.[·]` 中，其中 `f` 是被 λ 绑定的。

相反，`f` 可以在 `a₀` 中是多态的（如果 `f` 的类型允许），因为那些出现是 `let` 绑定的。

**多态递归**

多态递归指允许 `f` 在 `a₀` 中也是多态的系统。在没有限制的情况下，这些系统中的类型推导问题是不可判定的 [28, 75]。

### **1.5.2 递归类型**

默认情况下，ML的类型系统不允许**递归类型**（但允许递归数据类型定义——参见第2.1.3节）。然而，允许递归类型是一个简单的扩展。

实际上，OCaml 使用此扩展为对象赋予递归类型。类型系统的重要性质，包括类型的保持和主类型的存在性，都被此扩展所保留。

**在类型推导中的作用**

类型推导依赖于**统一**，它自然地在图上工作，即可能引入循环，然后被拒绝。为了使类型推导算法在递归类型下工作，只需在统一算法中移除**occurs check（出现检查）**规则即可。

然而，在处理和打印类型时必须小心，因为它们可能是递归的。

**不动点组合子的类型化**

如练习8所示（见第47页），不动点组合子在没有递归类型的情况下是不可类型化的。不出所料，如果允许递归类型，那么传值调用的不动点组合子 `fix` 可以在语言中定义。

#### **练习 10**

*(*) **具有递归类型的不动点**

验证 `fix` 在具有递归类型的情况下是可类型化的。

**解答：**

- 在允许递归类型的情况下，我们可以为 `fix` 赋予类型：
$$
\text{fix} : (\tau \rightarrow \tau) \rightarrow \tau
$$
- 其中，`τ` 可以是递归类型，例如 `τ = τ₁ → τ₂`。
- 因此，`fix` 可以类型化。
**使用 let 绑定编写 fix 的简短等价版本**

**解答：**

```ocaml
let fix = fun f -&gt; (fun x -&gt; f (x x)) (fun x -&gt; f (x x));;
```

- 这是著名的Y组合子，在允许递归类型的情况下可以类型化。
#### **练习 11**

*(**) **打印递归类型**

编写一个更复杂的函数 `print_type` 的版本，可以处理递归类型（例如，可以像OCaml那样使用 `as` 来给类型起别名）。

**解答：**

- 我们可以使用哈希表或标记来检测递归类型，并在打印时引入类型变量别名。
- 当检测到类型重复出现时，使用 `as` 关键字为类型命名，以避免无限打印。
**参见第3.2.1节，了解在对象类型中递归类型的使用。**

**递归类型的影响**

- 递归类型相对容易地被纳入语言中。
- 它们非常强大，可以为不动点组合子类型化，也很有用，有时是必要的，例如在对象类型的情况下。
- 然而，递归类型有时过于强大，因为它们可能会隐藏程序员的错误。特别是，它可能会很晚才检测到一些常见的错误形式，例如缺少或额外的参数（参见下面的练习提示）。
- 出于这个原因，OCaml 系统默认情况下拒绝在递归中不涉及对象类型构造子的递归类型。
- 然而，为了表达能力或实验的目的，用户可以使用选项 `-rectypes` 显式地要求不受限制的递归类型，但需要自行承担某些错误晚期检测的风险——当然，系统仍然是安全的！
#### **练习 12**

*(**) **具有递归类型的Lambda演算**

验证在没有常量的情况下，所有闭合程序都可以用递归类型进行类型化。

**解答：**

- 在纯粹的λ演算中，所有的闭合表达式都可以被赋予递归类型。
- 由于可以构造自引用的类型，例如 `τ = τ → τ`，因此任何函数都可以被类型化。
- 因此，在具有递归类型的情况下，所有闭合的λ演算程序都是可类型化的。
### **1.5.3 类型推导与类型检查**

**ML程序是无类型的**

- 类型推导为程序寻找最一般的类型。
- 实际上，很容易在类型推导过程中，为每个子项同时注释其类型（以及 `let` 绑定的类型方案），从而将无类型的项转换为类型项。
**类型检查的优势**

- 类型项比无类型的项提供了更多的信息，但它们仍可能是不良类型的。
- 幸运的是，检查类型项是否良类型通常比检查无类型项更容易。
- 特别是，类型检查不需要“猜测”类型，因此不需要一阶统一。
**类型推导与类型检查的区别**

- **类型推导**假设项是无类型的，需要推断类型。
- **类型检查**假设项是有类型的，需要验证类型的正确性。
- 这并不意味着类型检查比类型推导更简单。例如，一些类型检查问题是不可判定的 [59]。
- 然而，通常情况下，通过提供足够的类型注释，类型检查变得更容易。
**ML的方式**

- ML的方式是从无类型的项开始，之后推导类型，通常称为 **Curry 风格**。
- 另一种方式是从一开始就在项中包含类型，只需进行检查，称为 **Church 风格**。
**类型注释的作用**

- 类型注释不仅仅是使类型验证更简单的注释，也是构造程序的有用工具：它们在文档中发挥作用，支持模块化编程并提高安全性。
- 例如，在ML中，核心ML之上的模块系统是显式类型的。
**类型推导与类型检查的界限**

- 语言的所有节点都携带隐式的类型信息。例如，`1` 与 `1 : int` 之间没有真正的区别。
- 此外，一些显式的类型注释也可以隐藏在新的常量背后。
### **进一步阅读**

- 关于λ演算的参考书籍，它是ML的核心：[6, 29]。两者都包括对简单类型λ演算的讨论。
- 描述ML多态性及其类型推导算法（称为W）的参考文章是 [16]。
- 然而，Mini-ML [14] 更常被用作进一步扩展的起点，其中也包括类型推导的描述。
- 该算法的高效实现见 [63]。
- 当然，文献中还有许多其他的介绍，有时带有扩展。
- 关于统一的基本参考资料有 [49, 31]。
- 一篇好的综述文章是 [40]，它也引入了我们在演示中使用的存在性统一项的概念。
**总结**

在本节中，我们探讨了ML语言中的递归，包括使用不动点组合子实现递归、互相递归定义、多态性与递归的关系以及递归类型的引入。我们讨论了类型系统的扩展，以及在类型推导和类型检查之间的区别。通过这些内容，我们对ML语言的强大特性和类型系统有了更深入的理解。
  



**概览**

在本章中，我们将深入探讨 **OCaml** 的核心特性，了解其如何在 **核心ML** 的基础上构建和扩展。OCaml 是 ML 家族的一种强大的函数式编程语言，具有丰富的特性，如数据类型、模式匹配、可变存储和异常处理等。许多 OCaml 的特性可以在核心ML之上形式化，通过选择特定的原语、编码或小的扩展来实现。

我们将从 **数据类型和模式匹配** 开始，探讨如何定义自定义的数据类型，以及如何使用模式匹配来解构和处理数据。接着，通过 **OCaml 的示例**，展示这些概念的实际应用。然后，我们将对 **表面模式匹配的形式化** 进行讨论，理解模式匹配的底层机制和理论基础。

接下来，我们将深入 **递归数据类型定义**，了解如何定义复杂的数据结构，以及 **类型别名** 和 **记录类型** 如何帮助我们构建更加清晰和结构化的代码。

在 **可变存储和副作用** 部分，我们将讨论 OCaml 中的可变性，了解如何使用可变变量和引用，以及它们对程序行为的影响。随后，我们将 **形式化存储**，并探讨 **类型健全性**、**存储和多态性** 等概念。

最后，我们将讨论 **多字段可变记录** 和 **异常处理**，了解如何在 OCaml 中处理复杂的可变数据结构，以及如何使用异常来处理错误和特殊情况。

## **第二章：OCaml 的核心**

### **2.1 数据类型和模式匹配**

**数据类型的定义**

OCaml 提供了强大的机制来定义自定义的数据类型，使我们能够创建复杂的数据结构。数据类型通过 `type` 关键字定义，允许我们指定各种构造子（constructors）来表示不同的变体。

**示例**

```ocaml
type color = Red | Green | Blue
```

在这个示例中，我们定义了一个名为 `color` 的数据类型，它可以是 `Red`、`Green` 或 `Blue` 中的一个。这种类型称为 **代数数据类型（Algebraic Data Type, ADT）**，因为它可以组合多个构造子来形成复杂的类型。

**模式匹配**

模式匹配是 OCaml 中处理数据的一种强大方式。通过模式匹配，我们可以根据数据的形状和构造子来执行不同的操作。

**示例**

```ocaml
let describe_color c =
  match c with
  | Red -&gt; "The color is red."
  | Green -&gt; "The color is green."
  | Blue -&gt; "The color is blue."
```

在这个函数中，我们使用 `match...with` 语句来检查变量 `c` 的值，并根据不同的构造子返回相应的字符串描述。

### **2.2 OCaml 中的示例**

为了更好地理解数据类型和模式匹配，我们来看一些更复杂的示例。

**定义一个递归数据类型**

```ocaml
type 'a tree = Empty | Node of 'a * 'a tree * 'a tree
```

这里，我们定义了一个泛型的二叉树类型 `'a tree`，它要么是 `Empty`（空树），要么是一个包含值和左右子树的 `Node`。

**使用模式匹配遍历二叉树**

```ocaml
let rec size tree =
  match tree with
  | Empty -&gt; 0
  | Node (_, left, right) -&gt; 1 + size left + size right
```

这个递归函数计算二叉树的节点数量。通过模式匹配，我们区分空树和非空节点，然后递归地计算左右子树的大小。

### **2.3 表面模式匹配的形式化**

**模式匹配的机制**

在核心ML中，模式匹配可以形式化为一组规则，这些规则定义了如何将模式应用于数据结构，并提取所需的信息。

**匹配规则**

- **变量模式**：匹配任何值，并绑定到变量。
- **常量模式**：仅当值等于常量时匹配成功。
- **构造子模式**：如果值是对应的构造子，则尝试匹配其参数。
**示例**

考虑以下数据类型和匹配：

```ocaml
type expr = Const of int | Add of expr * expr

let rec eval e =
  match e with
  | Const n -&gt; n
  | Add (e1, e2) -&gt; eval e1 + eval e2
```

在这里，我们定义了一个简单的表达式类型，可以是常量或两个表达式的加法。`eval` 函数使用模式匹配来区分这两种情况，并计算表达式的值。

**形式化**

模式匹配的形式化涉及到定义匹配的语法和语义，以及如何处理嵌套的模式和可能的失败情况。

### **2.4 递归数据类型定义**

**递归数据类型**

递归数据类型允许我们定义自引用的数据结构，如列表、树等。这使我们能够表示复杂的数据结构，并使用递归函数来处理它们。

**列表的定义**

```ocaml
type 'a list = Nil | Cons of 'a * 'a list
```

这里，我们定义了一个通用的列表类型，要么是空列表 `Nil`，要么是一个包含头部元素和尾部列表的 `Cons`。

**列表操作**

```ocaml
let rec length lst =
  match lst with
  | Nil -&gt; 0
  | Cons (_, tail) -&gt; 1 + length tail
```

这个函数计算列表的长度，通过模式匹配区分空列表和非空列表，并递归地计算长度。

### **2.5 类型别名**

类型别名允许我们为现有的类型赋予新的名字，以提高代码的可读性和可维护性。

**示例**

```ocaml
type point = float * float

let distance (x1, y1) (x2, y2) =
  sqrt ((x2 -. x1) ** 2. +. (y2 -. y1) ** 2.)
```

在这里，我们将 `float * float` 类型别名为 `point`，表示二维平面上的点。这样可以使代码更加清晰。

### **2.6 记录类型**

**记录类型的定义**

记录类型类似于结构体，允许我们定义具有命名字段的复合数据类型。

**示例**

```ocaml
type person = {
  name : string;
  age : int;
}

let john = { name = "John"; age = 30 }

let greet p =
  "Hello, " ^ p.name ^ ". You are " ^ string_of_int p.age ^ " years old."
```

在这个示例中，我们定义了一个 `person` 类型，包含 `name` 和 `age` 字段。我们可以创建 `person` 的实例，并通过字段名访问其值。

**模式匹配记录**

```ocaml
let print_person { name; age } =
  Printf.printf "%s is %d years old.\n" name age
```

我们可以在模式匹配中直接解构记录的字段。

### **2.7 可变存储和副作用**

**可变性**

OCaml 是一门主要的函数式编程语言，强调不可变性。然而，它也支持可变存储，允许我们修改数据，从而产生副作用。

**引用类型**

```ocaml
let x = ref 0

x := !x + 1
```

- ref：创建一个引用，类似于指针或可变容器。
- !x：获取引用 x 中的值。
- x := v：将值 v 赋给引用 x。
**副作用的影响**

引入可变性后，程序的行为可能会依赖于执行顺序和状态变化。这需要我们在设计和分析程序时考虑副作用的影响。

### **2.8 存储的形式化**

**引入存储**

为了形式化可变存储的语义，我们需要引入一个全局的 **存储（Store）**，它将位置（标识符）映射到值。

**存储操作**

- **分配**：为新值分配一个存储位置。
- **读取**：从存储位置获取值。
- **写入**：将新值写入存储位置。
**操作语义的扩展**

在操作语义中，我们需要扩展评估规则，使其能够处理存储的变化。这通常涉及到将评估关系从 `a ⇒ v` 扩展为 `(a, s) ⇒ (v, s')`，其中 `s` 和 `s'` 分别表示评估前后的存储状态。

### **2.9 类型健全性**

**类型系统的扩展**

为了确保程序在引入可变存储后仍然是类型安全的，我们需要扩展类型系统，包含对引用和可变性的支持。

**引用类型**

```ocaml
type 'a ref
```

- 一个引用类型 t ref 表示存储中包含类型为 t 的值的引用。
**类型规则的更新**

- **分配**：创建引用的表达式，例如 ref a，其类型为 t ref，其中 a 的类型为 t。
- **读取**：获取引用中的值，例如 !x，其类型为 t，其中 x 的类型为 t ref。
- **写入**：更新引用中的值，例如 x := v，需要 x 的类型为 t ref，并且 v 的类型为 t。
### **2.10 存储和多态性**

**值限制**

在引入可变性后，多态性可能导致类型系统的不健全。为了避免这个问题，OCaml 引入了 **值限制（Value Restriction）**。

**值限制的规则**

只有在 `let` 绑定的右侧是值时，才能对类型进行泛化。这防止了可变引用被赋予多态类型，避免了潜在的类型安全问题。

**示例**

```ocaml
let r = ref []

(* r 的类型为 '_a list ref'，其中 '_a' 是一个未确定的类型变量 *)

(* 在使用 r 时，'_a' 会被具体化 *)
```

### **2.11 多字段可变记录**

**定义可变字段**

在记录类型中，我们可以使用 `mutable` 关键字定义可变字段。

**示例**

```ocaml
type counter = {
  mutable count : int;
}

let c = { count = 0 }

let increment counter =
  counter.count &lt;- counter.count + 1
```

这里，`count` 是一个可变字段，我们可以使用 `&lt;-` 操作符更新其值。

### **2.12 异常**

**异常的引入**

异常提供了一种处理错误和特殊情况的机制，使我们能够从嵌套的计算中跳出。

**定义异常**

```ocaml
exception NotFound

let find x lst =
  try
    (* 尝试在 lst 中找到 x *)
    ...
  with NotFound -&gt;
    (* 处理未找到的情况 *)
    ...
```

**抛出异常**

```ocaml
raise NotFound
```

**捕获异常**

```ocaml
try
  (* 可能抛出异常的代码 *)
with
| NotFound -&gt; (* 处理异常 *)
```

**异常的类型**

- 异常可以携带附加的数据，例如：
```ocaml
exception Error of string

raise (Error "Something went wrong")
```
**总结**

在本章中，我们深入探讨了 OCaml 的核心特性，了解了其在核心ML之上的扩展和形式化。我们从 **数据类型和模式匹配** 开始，学习了如何定义自定义的数据类型，以及如何使用模式匹配来处理数据。

通过 **OCaml 中的示例**，我们看到了这些概念的实际应用，理解了模式匹配在处理递归数据结构（如列表和树）时的强大之处。然后，我们对 **表面模式匹配的形式化** 进行了讨论，了解了模式匹配的底层机制。

在 **递归数据类型定义** 中，我们学习了如何定义复杂的数据结构，以及如何使用递归函数来操作它们。**类型别名** 和 **记录类型** 使我们的代码更加清晰和可维护，允许我们构建具有命名字段和自定义类型名称的数据结构。

随后，我们讨论了 **可变存储和副作用**，了解了如何在 OCaml 中引入可变性，以及如何处理可变引用和字段。我们通过 **存储的形式化**，理解了可变存储对程序语义的影响，以及如何扩展操作语义来处理存储状态的变化。

为了确保类型安全，我们探讨了 **类型健全性** 和 **存储与多态性**，了解了值限制如何防止类型系统的不健全性。接着，我们讨论了 **多字段可变记录**，学习了如何定义和操作具有可变字段的记录类型。

最后，我们介绍了 **异常**，了解了如何在 OCaml 中定义、抛出和捕获异常，以处理错误和特殊情况。

通过本章的学习，我们对 OCaml 的核心特性有了全面的理解，掌握了在核心ML之上扩展和形式化这些特性的方法。这为我们进一步深入学习 OCaml 和其他函数式编程语言奠定了坚实的基础。
  



**概览**

本段内容主要讲解了 **OCaml** 中的数据类型和模式匹配的概念，以及如何将这些概念形式化地融入到核心ML语言中。具体来说，它涵盖了以下几个主题：

1. **OCaml 中的示例**：介绍了如何在 OCaml 中定义新的数据类型，特别是代数数据类型，以及如何使用模式匹配来处理这些数据类型。
2. **表面模式匹配的形式化**：讨论了如何将只测试顶层构造子的表面模式匹配形式化到核心ML中，包括新类型构造子的声明、新构造子的引入和新的常量。
3. **递归数据类型定义**：探讨了递归数据类型的定义，特别是如何定义递归类型，如自然数，并讨论了 OCaml 中对递归数据类型的限制。
4. **类型别名**：介绍了类型别名的概念，与数据类型的区别，以及如何在形式化中处理类型别名，特别是在统一过程中。
5. **记录类型**：讨论了记录类型的定义及其形式化，与变体类型的相似之处，以及如何引入新类型符号、构造子和常量来实现记录类型。
通过这些主题，我们可以深入理解 OCaml 中的数据类型和模式匹配的机制，以及如何将这些概念形式化地融入到核心ML语言的框架中。

## **2.1 数据类型和模式匹配**

OCaml 语言包含了诸如整数、浮点数、字符串、数组等原始数据类型以及对它们的操作。同时，OCaml 还允许使用命名的记录（records）或变体（variants）来定义新的数据类型，并通过模式匹配（pattern matching）来探索和操作这些数据类型。模式匹配是一种强大的机制，它在单个构造中结合了多个投影和案例分析。

### **2.1.1 OCaml 中的示例**

**定义扑克牌的数据类型**

我们可以使用 OCaml 来定义扑克牌的类型。以下是一个示例：

```ocaml
type card = Card of regular | Joker
and regular = { suit : card_suit; name : card_name; }
and card_suit = Heart | Club | Spade | Diamond
and card_name = Ace | King | Queen | Jack | Simple of int;;
```

**解释：**

- type card 定义了一个名为 card 的类型，它是一个变体类型（variant type），具有两个可能的值：Card of regular：表示一张普通的牌，包含一个 regular 类型的值。Joker：表示小丑牌，无需任何额外的数据。
- regular 是一个记录类型（record type），具有两个字段：suit：类型为 card_suit，表示花色。name：类型为 card_name，表示牌面值。
- card_suit 是一个变体类型，可能的值为 Heart（红心）、Club（梅花）、Spade（黑桃）和 Diamond（方块）。
- card_name 也是一个变体类型，可能的值为 Ace（A）、King（K）、Queen（Q）、Jack（J）和 Simple of int，其中 Simple 包含一个整数，表示点数（如2到10）。
**定义了四个不同的数据类型：**

1. card
2. regular
3. card_suit
4. card_name
**创建扑克牌的实例**

我们可以直接使用变体标签和记录字段来创建扑克牌：

```ocaml
let club_jack = Card { name = Jack; suit = Club; };;
```

**解释：**

- 我们创建了一个名为 club_jack 的变量，其类型为 card，值为：Card 构造子，包含一个 regular 类型的记录 { name = Jack; suit = Club; }。
- 这表示一张梅花 J。
**输出：**

```ocaml
val club_jack : card = Card {suit=Club; name=Jack}
```

**使用函数创建扑克牌**

我们也可以通过定义函数来创建扑克牌，这样可以缩短表示，并且有助于强制执行不变量（例如，只允许合法的牌面值和花色）：

```ocaml
let card n s = Card {name = n; suit = s}
let king s = card King s;;
```

**解释：**

- card 是一个函数，接受一个 name 和一个 suit，返回一个 card。
- king 是一个函数，接受一个 suit，返回一个国王牌（King）。
**输出：**

```ocaml
val card : card_name -&gt; card_suit -&gt; card = 
val king : card_suit -&gt; card = 
```

**使用函数的好处：**

- 缩短了表示，使代码更简洁。
- 作为强制执行不变量的手段。例如，可以在函数中添加检查，确保创建的牌是合法的。
**使用模式匹配**

OCaml，和所有的 ML 方言一样，提供了一种方便的机制，通过 **模式匹配** 来探索和解构数据类型的值，也称为 **案例分析**（case analysis）。例如，我们可以定义一个函数来计算牌的点数：

```ocaml
let value c =
  match c with
  | Joker -&gt; 0
  | Card {name = Ace} -&gt; 14
  | Card {name = King} -&gt; 13
  | Card {name = Queen} -&gt; 12
  | Card {name = Jack} -&gt; 11
  | Card {name = Simple k} -&gt; k;;
```

**解释：**

- value 是一个函数，接受一个 card 类型的参数 c，返回一个整数。
- 使用 match c with 进行模式匹配，根据 c 的不同形式执行不同的计算：如果 c 是 Joker，返回 0。如果 c 是 Card {name = Ace}，返回 14。依此类推，对于 King、Queen、Jack。如果 c 是 Card {name = Simple k}，则返回 k，其中 k 是点数（2到10）。
**模式匹配的工作方式：**

- 函数 value 通过对参数 c 的外层构造子进行案例分析。
- 如果需要，进一步对数据结构的内部值进行分析（如访问 name 字段）。
- **匹配顺序**：模式是自上而下进行匹配的。当一个分支失败时，分析会继续尝试下一个可能的分支。一旦某个分支成功匹配，其右侧的表达式将被求值并返回结果，分析停止。
#### **练习 13**

**（**）匹配扑克牌**

我们说一组牌是 **兼容的（compatible）**，如果它不包含两个具有不同点数的普通牌。目标是找到包含四张兼容牌的手牌。编写一个函数 `find_compatible`，给定一手牌（以无序的牌列表给出），返回一个解的列表。每个解应该是一个兼容的牌组（以无序的牌列表表示），大小大于或等于四，且两个不同的解应该是不兼容的。

**解答：**

这个练习要求我们编写一个函数，寻找给定手牌中的所有兼容的牌组，每个牌组包含至少四张牌，并且不同的解之间应该是不兼容的（即没有共同的牌）。

**步骤：**

1. **理解兼容性：** 一组牌是兼容的，如果其中的所有普通牌（非小丑牌）具有相同的点数。
2. **遍历手牌：** 我们需要检查所有可能的牌组，找到满足条件的组合。
3. **避免重复和重叠：** 两个解应该是不兼容的，即没有共同的牌。
**实现思路：**

- 使用组合生成的方法，生成手牌中所有大小为4或以上的子集。
- 过滤出满足兼容性条件的子集。
- 确保不同的解之间没有共同的牌。
**可能的实现：**

```ocaml
let find_compatible hand =
  let rec combinations k lst =
    if k = 0 then [ [] ]
    else
      match lst with
      | [] -&gt; []
      | x :: xs -&gt;
          let with_x = List.map (fun l -&gt; x :: l) (combinations (k - 1) xs) in
          let without_x = combinations k xs in
          with_x @ without_x
  in
  let rec find_all_combinations n =
    if n &lt; 4 then []
    else combinations n hand @ find_all_combinations (n - 1)
  in
  let is_compatible cards =
    let values =
      List.fold_left
        (fun acc card -&gt;
          match card with
          | Joker -&gt; acc
          | Card { name = n; _ } -&gt; n :: acc)
        [] cards
    in
    match values with
    | [] -&gt; true
    | first :: rest -&gt; List.for_all (( = ) first) rest
  in
  let all_combinations = find_all_combinations (List.length hand) in
  List.filter is_compatible all_combinations
```

**解释：**

- combinations 函数生成列表 lst 中大小为 k 的所有组合。
- find_all_combinations 函数生成手牌中所有大小为 4 到手牌大小的组合。
- is_compatible 函数检查一组牌是否兼容：收集所有普通牌的点数（name）。如果所有普通牌的点数都相同，则该组牌兼容。
- 最后，过滤出所有兼容的牌组。
### **2.1.2 表面模式匹配的形式化**

**引入**

表面模式匹配（superficial pattern matching）指的是只测试顶层构造子的模式匹配，可以很容易地在核心ML中形式化，方法是声明新的类型构造子、新的构造子和新的常量。为了简化，我们假设所有的数据类型定义都是预先给定的，即我们将语言参数化为一组类型定义。

**单个数据类型定义的形式化**

考虑以下数据类型定义，位于任何表达式之前：

```plaintext
type g(α) = C₁ of τ₁ | ... | Cₙ of τₙ
```

- g(α)：定义了一个类型构造子 g，其参数为类型变量 α。
- C₁ 到 Cₙ：是类型 g(α) 的构造子，每个构造子可能带有类型为 τᵢ 的参数。
- τᵢ 中的自由变量都在 α 中（即类型参数）。
**与 OCaml 的对比**

- 我们使用标准的前缀表示法（prefix notation）进行形式化，而 OCaml 使用后缀表示法（postfix notation）。
**引入新类型符号和构造子**

这相当于引入了：

- 一个新的类型符号 `g`，其元数由 `α` 的长度给出。
- `n` 个一元构造子 `C₁` 到 `Cₙ`。
- 一个元数为 `n+1` 的原语 `f_g`，具有以下 δ-规则：
```plaintext
f_g (Cₖ v) v₁ ... vₖ ... vₙ → vₖ v     (δg)
```
- **解释**：`f_g` 接受一个类型为 `g(α)` 的值 `Cₖ v`，以及 `n` 个函数参数 `v₁` 到 `vₙ`，返回第 `k` 个函数 `vₖ` 应用于 `v`。
**扩展类型环境**

类型环境也必须扩展，包含以下类型假设：

- 对于构造子：
```plaintext
Cᵢ : ∀α. τᵢ → g(α)
```
- 对于原语 `f_g`：
```plaintext
f_g : ∀α, β. g(α) → (τ₁ → β) → ... → (τₙ → β) → β
```
**引入语法糖**

为了方便，可以将以下模式匹配：

```plaintext
match a with
| C₁(x) -&gt; a₁
| ...
| Cₙ(x) -&gt; aₙ
```

表示为：

```plaintext
f_g a (λx.a₁) ... (λx.aₙ)
```

**解释：**

- 将模式匹配转换为对 f_g 的函数调用，a 是被匹配的值，后面跟着 n 个函数（lambda 表达式），对应于每个构造子的处理。
#### **练习 14**

**（**）数据类型的类型健全性**

验证假设1和假设2是有效的。

**解答：**

- **假设1（类型的保持）**：δ-规则保持类型。我们需要验证，使用 δ-规则 `f_g (Cₖ v) v₁ ... vₖ ... vₙ → vₖ v`，类型是保持的。**前提**：Cₖ : ∀α. τₖ → g(α)f_g : ∀α, β. g(α) → (τ₁ → β) → ... → (τₙ → β) → βv : τₖ**应用 f_g 时**：f_g (Cₖ v) v₁ ... vₖ ... vₙ 的类型是 β，前提是 vₖ 的类型是 τₖ → β。**右侧**：vₖ v，类型是 β。**因此，类型保持成立**。
- **假设2（进展性）**：δ-规则是良定义的，良类型的程序要么是值，要么可以进一步化简。δ-规则定义明确，当匹配成功时，可以进行化简，评估可以继续。**因此，假设2成立**。
#### **练习 15**

**（**）数据类型定义**

如果 `τᵢ` 的自由变量不是 `α` 中的一个，会发生什么？反之，如果 `α` 中的一个变量没有出现在任何 `τᵢ` 中，会发生什么？

**解答：**

- **如果 τᵢ 的自由变量不在 α 中**：这意味着类型 `g(α)` 的定义中引用了未绑定的类型变量，类型是不良定义的，可能导致类型系统的不健全性。**结果**：类型定义不合法，类型检查可能失败。
- **如果 α 中的一个变量没有出现在任何 τᵢ 中**：这意味着类型参数 `α` 中包含了未使用的类型变量。**结果**：对于类型系统来说，这不是一个问题。但在实践中，这可能表明类型定义存在冗余，类型参数可以被省略。
#### **练习 16**

**（*）布尔值作为数据类型定义**

验证布尔值是数据类型的一个特例。

**解答：**

- 布尔值可以定义为一个数据类型：
```ocaml
type bool = True | False
```
- 这里，`bool` 是一个变体类型，具有两个构造子 `True` 和 `False`。
- **因此，布尔值可以被视为数据类型定义的一个特例**。
#### **练习 17**

**（**）对作为数据类型定义的元组**

验证元组（pairs）是数据类型的一个广义特例。

**解答：**

- 我们可以使用数据类型来定义元组类型：
```ocaml
type ('a, 'b) pair = Pair of 'a * 'b
```
- 或者，更直接地：
```ocaml
type ('a, 'b) pair = Pair of 'a * 'b
```
- 这里，`pair` 是一个泛型的数据类型，具有一个构造子 `Pair`，包含类型为 `'a * 'b` 的值。
- **因此，元组可以被视为数据类型定义的一个广义特例**。
### **2.1.3 递归数据类型定义**

**递归类型的引入**

注意，由于我们可以假设类型符号 `g` 是首先给定的，那么类型 `τᵢ` 可以引用 `g`。这允许我们定义 **递归类型**，例如以一元基数表示的自然数（类似于 OCaml 中的列表定义）：

```ocaml
type IN = Zero | Succ of IN
```

- 这里，IN 是一个数据类型，表示自然数：Zero：零。Succ of IN：自然数的后继，包含一个 IN 类型的值。
**OCaml 中的限制**

OCaml 对递归数据类型定义施加了一个限制：如果一个数据类型定义 `g(α)` 是递归的，那么所有对 `g` 的引用都应该使用完全相同的参数 `α`。

- **原因**：这种限制保留了两个类型定义等价性的可判定性。
- **如果放松限制**：问题“两个给定的数据类型定义是否定义了同构的结构？”将变得不可判定。
- **实际意义**：由于数据类型定义是生成式的，类型总是通过名称进行比较，因此这个问题并不那么有意义。
- **其他 ML 方言**：有些不施加这个限制。
- **然而**：只要语言不允许多态递归，那么这种放松并没有显著的好处，因为无法编写操作不遵循此限制的数据类型的有趣函数。
**使用数据类型编码 lambda 演算**

正如以下练习所示，可以使用变体数据类型编码不动点组合子，更一般地，可以编码整个 lambda 演算。

- **注意**：这并不令人惊讶，因为不动点可以通过 δ-规则实现，变体数据类型已经通过特殊形式的 δ-规则进行了编码。
- **负递归**：编码使用了 **负递归**，即在箭头类型的左侧出现的递归。
- **正递归**：如果将数据类型限制为 **正递归**（即递归只出现在类型的正位置，例如函数的返回类型），则可以保留程序的终止性（在没有其他形式的递归的 ML 中）。
#### **练习 18**

**（**）使用数据类型实现递归**

**第一部分：**

使用数据类型 `value` 定义两个互为逆的函数 `fold` 和 `unfold`，其类型分别为：

```ocaml
val fold : (value -&gt; value) -&gt; value = 
val unfold : value -&gt; value -&gt; value = 
```

**解答：**

- **定义数据类型 value**：
```ocaml
type value = Fun of (value -&gt; value)
```
- **定义 fold 和 unfold**：
```ocaml
let fold f = Fun f

let unfold (Fun f) x = f x
```
- **解释**：fold 接受一个函数 f，返回一个 Fun f，即将函数包装为数据类型 value。unfold 接受一个 value 类型的值（必须是 Fun f），以及一个参数 x，返回 f x。
**第二部分：**

提出一个形式化的编码 `[·]`，将 lambda 演算编码到包含 `fold` 和 `unfold` 的 ML 中，使得 lambda 演算的任何表达式的编码都是良类型的项。

**解答：**

- **编码策略**：将 lambda 演算中的函数编码为 value 类型，即使用 fold 和 unfold。
- **编码规则**：变量：[x] = x函数抽象：[λx.e] = fold (fun x -&gt; [e])函数应用：[e1 e2] = unfold [e1] [e2]
- **解释**：fold 将函数抽象封装为 value 类型。unfold 解封装 value，并对其应用参数。
**第三部分：**

验证 `[fix]` 是良类型的。

**解答：**

- **编码不动点组合子 fix**：
```ocaml
let fix = fold (fun f -&gt; unfold f f)
```
- **类型检查**：fold 的类型为 (value -&gt; value) -&gt; value。unfold f f 的类型为 value，其中 f : value。
- **因此**，`fix` 的类型为 `value`，编码成功，类型良好。
### **2.1.4 类型别名**

OCaml 还允许使用 `type g(α) = τ` 来声明 **类型别名（type abbreviation）**。

**与数据类型的区别**

- **数据类型定义**：
```ocaml
type g(α) = C of τ
```
定义了一个新的类型符号 g，与所有其他类型不兼容。
- **类型别名**：
```ocaml
type g(α) = τ
```
定义了一个新的类型符号 g，但它与 τ 的顶层类型符号兼容，因为 g(α) 可以在任何地方与 τ 互换。
**形式化处理**

- **最简单的形式化**：在预处理阶段展开类型别名。**限制**：只要不允许递归的类型别名，就可以将所有的类型别名替换为实际的类型。
- **问题**：如果允许递归的类型别名，展开可能会导致无限循环。展开的类型可能会变得非常大，导致代码可读性和可维护性下降。
- **更直接的表示**：将类型别名视为引入一个新的符号 `h`，并伴随着一个公理 `h(α) = τ`。**注意**：这是一个公理，而不是一个多重等式。
**在统一过程中的处理**

- **参数化统一过程**：将统一过程参数化为一组类型别名定义 `{h(α_h) = τ_h | h ∈ A}`。
- **在统一过程中展开类型别名**：当它们可能导致与另一个符号冲突时，展开类型别名。
- **添加新的重写规则**：**Abbrev 规则**：
```plaintext
Abbrev if g ≠ h
α ⋍ h(α) ⋍ g(τ) ⋍ e
————————————————
α ⋍ τ_h[α / α_h] ⋍ g(τ) ⋍ e
```
**解释**：如果在统一过程中遇到一个类型变量 `α` 等于类型别名 `h(α)`，并且需要与另一个类型 `g(τ)` 进行统一，则展开类型别名。
- **改进的规则**：**Abbrev' 规则**：
```plaintext
Abbrev' if g ≠ h
α ⋍ h(α) ⋍ g(τ) ⋍ e
——————————————————
∃α'. (α ⋍ h(α) ⋍ e ∧ α' ⋍ τ_h[α / α_h] ⋍ g(τ))
```
**解释**：在展开类型别名后，保留类型别名的存在，以保持类型的抽象性。
- **递归的类型别名**：类型别名可以是递归的，即 `h` 可以出现在 `τ_h` 中。与数据类型类似，递归中的类型参数必须与定义中的参数相同。
#### **练习 19**

**（*）相互递归的类型别名定义**

解释如何将类型别名的递归定义 `type h₁(α) = τ₁` 和 `type h₂(α₂) = τ₂` 表示为多个单一的但递归的类型别名定义。

**解答：**

- **处理方法**：将多个相互递归的类型别名定义视为单个类型别名定义，但允许递归引用。
- **示例**：
```ocaml
type h₁(α) = τ₁    (* τ₁ 中可能包含 h₂(α₂) *)
type h₂(α₂) = τ₂   (* τ₂ 中可能包含 h₁(α) *)
```
- **形式化**：将类型别名定义为公理：
```plaintext
h₁(α) = τ₁
h₂(α₂) = τ₂
```
在统一过程中，当遇到类型别名时，按照需要展开，处理递归引用。
- **需要注意**：确保递归定义中的类型参数匹配，防止出现不一致。
**参见第 3.2.1 节，了解对象类型中类型别名的使用。**

### **2.1.5 记录类型**

**形式化记录类型**

记录类型的定义可以以类似于变体类型定义的方式进行形式化。考虑以下定义：

```plaintext
type g(α) = { f₁ : τ₁; ...; fₙ : τₙ }
```

- **解释**：定义了一个新的类型符号 g(α)，表示具有字段 f₁ 到 fₙ 的记录类型，每个字段的类型为 τᵢ。
**引入新类型符号和构造子**

- 引入一个新的类型符号 `g`，其元数由 `α` 的长度给出。
- 一个 `n` 元的构造子 `C_g`。
- `n` 个一元原语 `fᵢ`，具有以下 δ-规则：
```plaintext
fᵢ (C_g v₁ ... vᵢ ... vₙ) → vᵢ     (δg)
```
- **解释**：`fᵢ` 是字段访问函数，接受一个记录（由构造子 `C_g` 创建），返回第 `i` 个字段的值 `vᵢ`。
**类型假设**

- 对于构造子 `C_g`：
```plaintext
C_g : ∀α. τ₁ → ... → τₙ → g(α)
```
- 对于字段访问函数 `fᵢ`：
```plaintext
fᵢ : ∀α. g(α) → τᵢ
```
**语法糖**

- 使用 `a.fᵢ` 和 `{ f₁ = a₁; ...; fₙ = aₙ }` 来代替 `fᵢ a` 和 `C_g a₁ ... aₙ`。
- **解释**：将记录类型的创建和字段访问表示得更接近 OCaml 的语法。
**与变体类型的相似之处**

- 记录类型和变体类型在形式化上非常相似，都涉及到引入新的类型符号、构造子和原语，并定义相应的 δ-规则。
**总结**

在本段内容中，我们深入探讨了 OCaml 中的数据类型和模式匹配的概念，以及如何将这些概念形式化地融入到核心ML语言中。

首先，我们通过 **OCaml 中的示例**，了解了如何定义新的数据类型，包括变体类型和记录类型，以及如何使用模式匹配来处理这些数据类型。我们看到了如何定义扑克牌的数据类型，并使用模式匹配来计算牌的点数。

接着，我们讨论了 **表面模式匹配的形式化**，了解了如何在核心ML中引入新的类型符号、构造子和常量，以及如何定义相应的 δ-规则，以形式化地支持模式匹配。

然后，我们探讨了 **递归数据类型定义**，了解了如何定义递归类型，如自然数，以及 OCaml 对递归数据类型的限制。我们还讨论了使用数据类型来编码 lambda 演算和不动点组合子的方法。

在 **类型别名** 部分，我们介绍了类型别名的概念，与数据类型的区别，以及如何在形式化中处理类型别名，特别是在统一过程中。当涉及递归的类型别名定义时，我们讨论了如何将其表示为多个单一的但递归的类型别名定义。

最后，我们讨论了 **记录类型**，了解了如何将记录类型形式化地融入到核心ML中。我们引入了新的类型符号、构造子和字段访问函数，并定义了相应的 δ-规则，使得记录类型的创建和字段访问得以实现。

通过这些内容，我们深入理解了 OCaml 中的数据类型和模式匹配的机制，以及如何将这些概念形式化地融入到核心ML语言的框架中。这不仅帮助我们理解了 OCaml 语言的强大特性，也为我们提供了将高级语言特性形式化的思路和方法。
  



**概览**

本段内容主要讨论了 **OCaml** 语言中的 **可变存储（Mutable Storage）** 和 **副作用（Side Effects）**。在之前的描述中，我们的语言是纯函数式的，即对同一表达式的多次求值总是产生相同的结果。然而，这样的限制使得我们无法实现某些需要记忆状态的程序，比如计数器。为了引入状态，我们需要使用可变存储，并通过副作用来与存储进行交互。

在 OCaml 中，我们可以通过 **引用（References）** 和 **可变记录（Mutable Records）** 来实现可变存储。引用实际上是特殊的可变记录。我们将探讨如何形式化地引入存储，以及如何确保在引入可变存储后，类型系统仍然保持健全。此外，我们还将讨论 **异常（Exceptions）** 的引入，它们也是一种命令式构造，无法仅通过新的原语和 δ-规则来描述。

## **2.2 可变存储和副作用**

### **引言**

**纯函数式语言的限制**

到目前为止，我们描述的语言是纯函数式的，这意味着对同一表达式的多次求值总是产生相同的结果。这限制了我们无法实现需要记忆状态的程序。例如，实现一个计数器，其接口是一个函数 `next : unit -&gt; int`，每次调用都会递增计数器并返回新值。重复调用该函数应返回连续的整数序列，即每次都返回不同的结果。

**引入可变存储**

为了实现这样的功能，计数器需要记忆其状态，存储在某个特定的位置，并能够进行读/写访问。最重要的是，在两次对 `next` 的调用之间，需要共享一些信息。解决方案是使用 **可变存储**，并通过所谓的 **副作用** 与存储进行交互。

### **在 OCaml 中的实现**

**计数器示例**

在 OCaml 中，计数器可以如下定义：

```ocaml
let new_count =
  let r = ref 0 in
  let next () = r := !r + 1; !r in
  next;;
```

**解释：**

- ref 0：创建一个初始值为 0 的引用 r。引用是一个可变的存储位置，可以存储类型为 int 的值。
- let next () = ...：定义一个函数 next，每次调用都会：r := !r + 1：将 r 的值增加 1。!r：返回 r 的新值。
- new_count：将函数 next 赋值给 new_count，所以 new_count 是一个函数，每次调用都会返回递增的整数。
**银行账户示例**

另一个更具体的可变存储示例是银行账户。在 OCaml 中，记录（record）的字段可以声明为 **可变的（mutable）**，这样就可以在之后为其赋予新值。

```ocaml
type account = { number : int; mutable balance : float }

let retrieve account requested =
  let s = min account.balance requested in
  account.balance &lt;- account.balance -. s;
  s;;
```

**解释：**

- type account = { ... }：定义了一个记录类型 account，包含：number : int：账户号码，不可变。mutable balance : float：账户余额，可变的浮点数。
- retrieve 函数：接受一个 account 和一个 requested 金额。计算实际可取的金额 s，为账户余额和请求金额中的较小值。更新账户余额：account.balance &lt;- account.balance -. s。返回实际取款金额 s。
**引用不是原始的**

事实上，在 OCaml 中，引用并不是原始的（primitive）。它们是可变记录的特殊情况。例如，我们可以定义：

```ocaml
type 'a ref = { mutable content : 'a }
let ref x = { content = x }
let deref r = r.content
let assign r x = r.content &lt;- x; x
```

**解释：**

- type 'a ref = { mutable content : 'a }：定义了一个参数化类型 'a ref，是一个包含可变字段 content 的记录，content 的类型为 'a。
- let ref x = { content = x }：创建一个新的引用，初始值为 x。
- let deref r = r.content：解引用操作，获取引用 r 中的值。
- let assign r x = r.content &lt;- x; x：赋值操作，将 x 赋给引用 r，并返回 x。
### **2.2.1 存储的形式化**

**引入存储位置**

为了形式化存储，我们引入一组可数的 **存储位置（store locations）** `ℓ ∈ L`。我们还扩展了程序的语法，包含存储位置和操作存储的构造：

```plaintext
a ::= ... | ℓ | ref a | deref a | assign a a'
```

- ℓ：存储位置，是一种值。
- ref a：创建一个新的存储位置，存储值 a。
- deref a：解引用，获取存储位置 a 中的值。
- assign a a'：将值 a' 赋给存储位置 a。
**存储的建模**

存储被建模为一个全局的部分映射 `s`，从存储位置映射到值，即 `s : L ⇀ V`。小步化简需要访问存储，并能够改变其内容。因此，我们将 **表达式-存储对（a / s）** 作为计算的基本单位，而不是仅仅化简表达式。

**值的扩展**

存储位置也是值的一种：

```plaintext
v ::= ... | ℓ
```

**语义规则**

对于不操作存储的程序，其语义被简单地提升，使得存储保持不变：

```plaintext
a / s → a' / s     如果 a → a'
```

操作存储的原语的行为如下：

- **创建引用**
```plaintext
ref v / s → ℓ / s, ℓ ↦ v    ℓ ∉ dom(s)
```
为值 v 创建一个新的存储位置 ℓ，并将其存储在存储 s 中。
- **解引用**
```plaintext
deref ℓ / s → s(ℓ) / s    ℓ ∈ dom(s)
```
获取存储位置 ℓ 中的值。
- **赋值**
```plaintext
assign ℓ v / s → v / s, ℓ ↦ v    ℓ ∈ dom(s)
```
将值 v 存储到位置 ℓ 中，并返回 v。
**扩展评估上下文**

我们将上下文规则提升为作用于 **表达式-存储对**：

```plaintext
E[a] / s → E[a'] / s    如果 a / s → a' / s
```

**示例 3**

这是一个简单的化简示例：

```plaintext
(let x = ref 1 in assign x (1 + deref x)) / ∅
→ (let x = ℓ in assign x (1 + deref x)) / { ℓ ↦ 1 }
→ assign ℓ (1 + deref ℓ) / { ℓ ↦ 1 }
→ assign ℓ (1 + 1) / { ℓ ↦ 1 }
→ assign ℓ 2 / { ℓ ↦ 1 }
→ 2 / { ℓ ↦ 2 }
```

**解释：**

- 初始状态：存储为空 ∅。
- 创建引用 ref 1，生成新的存储位置 ℓ，存储值 1。
- 解引用 deref ℓ，获取值 1。
- 计算 1 + 1，得到 2。
- 赋值 assign ℓ 2，将值 2 存储到位置 ℓ。
- 最终结果是 2，存储更新为 { ℓ ↦ 2 }。
**备注 5：垃圾回收**

需要注意，我们尚未建模 **垃圾回收（Garbage Collection）**：在化简过程中，由 `ref` 规则创建的新位置将永远保留在存储中。

**尝试建模垃圾回收**

一种尝试是使用额外的规则：

```plaintext
a / s → a / (s \ ℓ)    如果 ℓ ∉ a
```

- 这里，s \ ℓ 表示从存储 s 中移除位置 ℓ。
**问题：**

- **间接可达性**：位置 ℓ 可能仍然是可访问的，例如，通过另一个位置 ℓ'，其中 s(ℓ') 可能引用 ℓ。简单地检查 ℓ ∉ a 并不足够。
- **循环引用**：修改条件为 ℓ ∉ a, (s \ ℓ) 可以解决间接可达性的问题，但引入了新的问题：如果存储中存在无法从 a 到达的循环引用，将无法被回收。
- **正确性**：在局部应用垃圾回收规则，然后通过上下文规则提升到整个表达式，可能不正确。
**解决方案：**

- **顶层化简**：定义一种 **顶层化简（toplevel reduction）**，防止局部应用垃圾回收。
- **复杂的存储处理**：通过更复杂的存储处理，使得位置可以在局部处理。（参考 [77] 了解更多细节）
### **类型检查的扩展**

**扩展类型环境**

为了对包含存储位置的程序进行类型检查，我们需要扩展类型环境，包含位置的类型假设：

```plaintext
A ::= ... | A, ℓ : τ
```

**注意：**

- 存储位置不允许是多态的（polymorphic）。详见后续讨论。
**位置的类型规则**

```plaintext
Loc
ℓ : τ ∈ A
———————
A ⊢ ℓ : τ
```

**存储操作的类型**

存储操作可以视为应用以下类型方案的常量：

- ref : ∀α. α → ref α
- deref : ∀α. ref α → α
- assign : ∀α. ref α → α → α
（为 `Ref`、`Deref` 和 `Assign` 定义特定的类型规则将不必要地重复 `App` 规则）

### **2.2.2 类型健全性**

**存储类型判断**

我们首先定义存储类型判断。我们记作 `A ⊢ a / s : τ`，如果存在类型环境的扩展 `A'`，使得：

- A' 是 A 的扩展（即在 A 的域之外）。
- A' ⊢ a : τ。
- 对于所有 ℓ ∈ dom(A')，有 A' ⊢ s(ℓ) : A'(ℓ)。
**值的包含关系**

我们将 `v` 重新定义为存储类型的包含：

```plaintext
(a / s ⊑ a' / s') ⇔ ∀(A, τ)(A ⊢ a / s : τ ⇒ A ⊢ a' / s' : τ)
```

**定理 5（主题缩减）**

存储化简保持存储类型判断。

**解释：**

- 如果 A ⊢ a / s : τ，并且 a / s → a' / s'，那么 A ⊢ a' / s' : τ。
**定理 6（进展性）**

如果 `A₀ ⊢ a / s : τ`，那么 `a` 要么是一个值，要么 `a / s` 可以进一步化简。

### **2.2.3 存储和多态性**

**问题的提出**

注意，存储位置不能是多态的。此外，为了保持主题缩减，如果表达式如 `ref v` 可以是多态的，那么会引发问题，因为 `ref v` 化简为一个新的位置 `ℓ`，其类型与 `v` 的类型相同。

**解决方案：值限制**

强制 `let x = a in a'` 中的 `a` 是一个值 `v`。其他情况可以视为 `(λx.a') a` 的语法糖。由于 `ref a` 不是一个值（它是一个应用），因此它不能是多态的。

**解释：**

- 通过限制多态性仅适用于值，我们避免了类型系统的不健全性。
- 这个解决方案被称为 **“仅值多态性”（value-only polymorphism）**，被认为是在简单性和表达能力之间的最佳折衷。
**反例**

如果允许存储多态引用，会导致主题缩减失败的情况。例如：

```ocaml
let id = ref (fun x -&gt; x) in (id := succ; !id true);;
```

- id 被初始化为一个多态函数 fun x -&gt; x，类型为 ∀α. α → α。
- 然后，我们将 succ（类型为 int -&gt; int）赋值给 id。
- 最后，尝试将 id 应用于 true（类型为 bool）。
- 由于 succ 无法应用于 bool，导致类型错误。
**其他可能的解决方案**

- 确保赋值给 id 的值具有至少与位置类型一样一般的类型方案。
- 然而，ML 无法强制表达式具有多态类型。
**结论**

- 因此，值限制是避免类型系统不健全性的简单而有效的方法。
#### **练习 20**

**（**）使用引用实现递归**

展示如何仅使用引用（即不使用递归绑定、递归类型等）来定义不动点组合子 `fix`。

**解答：**

我们可以使用引用来实现递归函数。以下是一个使用引用实现 `fix` 的示例：

```ocaml
let fix f =
  let r = ref (fun x -&gt; x) in
  r := f (fun x -&gt; !r x);
  !r;;
```

**解释：**

- r 是一个引用，初始值为 fun x -&gt; x。
- 然后，我们将 f (fun x -&gt; !r x) 赋值给 r。这里，!r x 表示对 r 解引用，并应用于 x。
- 最后，返回 !r，即递归函数。
这个实现利用了引用的可变性，允许我们在定义中引用自身，实现递归。

### **2.2.4 多字段可变记录**

在 OCaml 中，引用单元实际上是具有可变字段的记录的特例。为了对它们进行建模，我们应该引入具有多个字段的存储位置。这在原则上没有问题，但会使符号变得相当繁琐。

## **2.3 异常**

### **引言**

**异常的引入**

异常是另一种命令式构造。与引用类似，异常的语义不能仅通过引入新的原语和 δ-规则来给出。

**扩展语法**

我们扩展核心 ML 的语法：

```plaintext
a ::= ... | try a with x ⇒ a | raise a
```

- try a with x ⇒ a'：尝试执行 a，如果发生异常，捕获异常的值到 x，然后执行 a'。
- raise a：抛出异常，异常的值为 a。
### **语义规则**

**扩展评估上下文**

为了允许对异常和异常处理器的求值，我们扩展评估上下文：

```plaintext
E ::= ... | try E with x ⇒ a | raise E
```

**添加新的归约规则**

- **Try 规则**
```plaintext
try v with x ⇒ a' → v    (Try)
```
如果 a 求值为值 v，则 try a with x ⇒ a' 直接返回 v。
- **Raise 规则**
```plaintext
try E₀[raise v] with x ⇒ a' → let x = v in a'    (Raise)
```
条件：E₀ 不包含任何形式为 try with 的节点。这里，E₀ 是一个没有包含异常处理器的评估上下文。
**解释：**

- **Raise 规则** 表示，如果在求值 a 时抛出异常 v，则执行最内层的异常处理器，将异常的值绑定到 x，然后执行 a'。
- **Try 规则** 表示，如果 a 正常求值为值 v，则移除异常处理器，返回 v。
**评估上下文的定义**

`E₀` 可以由以下语法定义：

```plaintext
E₀ ::= [·] | E₀ a | v E₀ | raise E₀
```

### **类型检查**

**异常类型的问题**

异常的类型检查与引用的类型检查有类似的问题：如果一个异常可以被赋予多态类型 `σ`，那么它可以被以类型实例 `τ₁` 的形式抛出，并假设其类型为另一个类型实例 `τ₂` 来处理。如果 `τ₁` 和 `τ₂` 不兼容，这可能导致类型错误。

**解决方案：**

- 我们假设一个特定的闭合类型 τ₀，用于异常的类型。
**类型规则**

- **Raise 规则**
```plaintext
Raise
A ⊢ a : τ₀
————————
A ⊢ raise a : α
```
如果 a 的类型为异常类型 τ₀，则 raise a 可以具有任何类型 α。
- **Try 规则**
```plaintext
Try
A ⊢ a₁ : τ    A, x : τ₀ ⊢ a₂ : τ
———————————————
A ⊢ try a₁ with x ⇒ a₂ : τ
```
如果 a₁ 的类型为 τ，且在 x 具有异常类型 τ₀ 的扩展环境下，a₂ 也具有类型 τ，则 try a₁ with x ⇒ a₂ 的类型为 τ。
#### **练习 21**

**（**）异常的类型健全性**

证明此扩展的正确性。

**解答：**

- **主题缩减**：需要证明在异常扩展的语义规则下，类型系统的主题缩减性质仍然成立。
- **进展性**：需要证明良类型的程序要么是值，要么可以进一步化简。
通过检查异常的类型规则和语义规则，可以验证类型系统的健全性。

#### **练习 22**

**（**）使用异常实现递归**

是否可以使用异常来定义不动点组合子 `fix`？

**解答：**

是的，可以使用异常来实现不动点组合子。以下是一个示例：

```ocaml
let fix f =
  try
    raise (fun x -&gt; raise x)
  with x -&gt; f (fun v -&gt; (try raise x with y -&gt; y) v);;
```

**解释：**

- 我们利用异常的回溯特性，在异常处理器中实现递归调用。
- 通过抛出和捕获异常，实现对自身的引用。
## **进一步阅读**

我们仅形式化了真实语言的一些要素，而且对许多细节进行了抽象。例如，我们假设给出了完整的程序，因此类型声明可以移动到所有表达式之前。

尽管有许多表面上的差异，**Standard ML** 实际上与 OCaml 非常接近。Standard ML 也被形式化了，但细节更多 [51, 50]。这是一项相当不同的任务：对于规范性文档而言，低级别和细粒度的描述是必要的，但不幸的是，这可能会掩盖 ML 背后的原理和简单性。

在为 ML 提出的许多扩展中，有一些值得更多关注，因为它们既具有表达力，又易于形式化，并且本质上与 ML 非常接近。

**多态记录访问**

作为数据类型定义的记录有一个不便之处：它们必须始终在使用之前声明。更糟糕的是，它们不允许定义一个函数，可以在任何包含至少该字段的记录中统一地访问某个特定字段。这个问题称为 **多态记录访问（polymorphic record access）**，已经有多种解决方案被提出 [65, 57, 33, 37]，所有这些都或多或少地直接依赖于 **行变量（row variables）** 的强大思想 [73]。

其中一些解决方案同时允许在给定字段上统一地扩展记录，即不考虑其他字段。这种操作称为 **多态记录扩展（polymorphic record extension）**，非常有表达力。然而，可扩展的记录在类型检查和编译效率上都无法与简单记录相提并论。

**多态变体**

相反，变体允许通过使用标签构建开放和类型的值，而无需事先定义所有可能的情况。实际上，OCaml 最近扩展了此类变体 [23]。

**存在类型和通用类型**

数据类型也可用于将 **存在类型（existential types）** 或 **通用类型（universal types）** 嵌入到 ML 中 [41, 64, 53, 24]。

**总结**

在本段内容中，我们深入探讨了 OCaml 中的 **可变存储和副作用** 以及 **异常** 的概念。

首先，我们了解了纯函数式语言的限制，特别是在需要记忆状态的程序中，如计数器和银行账户。为了克服这些限制，我们引入了可变存储，通过引用和可变记录来实现。在形式化存储时，我们引入了存储位置，并将表达式-存储对作为计算的基本单位。我们定义了存储操作的语义规则，并扩展了类型系统，以确保类型健全性。

接着，我们讨论了存储和多态性的问题。为了防止类型系统的不健全性，我们引入了 **值限制（value restriction）**，限制多态性仅适用于值。这有效地避免了在多态引用中出现类型错误。

然后，我们探讨了 **异常** 的引入。异常作为另一种命令式构造，允许我们处理运行时的错误和特殊情况。我们扩展了语法和评估上下文，定义了异常的语义规则。我们还讨论了异常的类型检查，确保类型系统的健全性。

最后，我们提到了进一步的阅读材料，指出了 OCaml 和 Standard ML 的相似之处，以及一些值得关注的扩展，如多态记录访问、多态变体、存在类型和通用类型。

通过本段的学习，我们对 OCaml 中可变存储、引用、异常以及它们的形式化有了深入的理解。我们了解了如何在语言中引入状态和副作用，以及如何确保类型系统在引入这些特性后仍然保持健全。这为我们在实际编程中使用这些特性，以及在理论上理解编程语言的设计和形式化奠定了基础。
  



**概览**

本段内容主要介绍了 **OCaml** 语言中的 **对象层（Object Layer）**，包括对象和类的引入、基本示例、多态性、子类型、多参数类，以及对象和类的类型检查等高级主题。OCaml 是一门强大的函数式编程语言，它在核心语言之上增加了对象和类的特性，使得程序员可以以面向对象的方式构建复杂的程序。本章首先非正式地介绍了对象和类，然后呈现了对象层的核心部分，最后展示了一些对象的高级用法。

## **第三章：对象层**

### **3.1 探索对象和类**

**对象和类的引入**

在 OCaml 中，对象和类为程序员提供了以面向对象的方式组织代码的能力。对象是具有状态和行为的实体，而类是创建对象的模板或蓝图。通过使用对象和类，程序员可以封装数据和操作，提高代码的可重用性和可维护性。

**非正式的介绍**

在本节中，我们将非正式地介绍 OCaml 中的对象和类，帮助读者理解它们的基本概念和用途。我们将讨论对象和类的基本语法，以及如何在 OCaml 中定义和使用它们。

### **3.2 基本示例**

**定义一个简单的类**

以下是一个在 OCaml 中定义简单类的示例：

```ocaml
class point x_init y_init = object
  val mutable x = x_init
  val mutable y = y_init
  method get_x = x
  method get_y = y
  method move dx dy =
    x &lt;- x +. dx;
    y &lt;- y +. dy
end
```

**解释：**

- class point x_init y_init：定义了一个名为 point 的类，带有初始参数 x_init 和 y_init。
- object ... end：类的主体，由一个 object 表达式定义，包含字段和方法。
- val mutable x = x_init：定义了一个可变的实例变量 x，初始值为 x_init。
- method get_x = x：定义了一个方法 get_x，返回 x 的值。
- method move dx dy = ...：定义了一个方法 move，接受参数 dx 和 dy，用于移动点的位置。
**创建对象的实例**

```ocaml
let p = new point 0.0 0.0
```

- new point 0.0 0.0：创建一个 point 类的实例，初始位置为 (0.0, 0.0)。
**使用对象的方法**

```ocaml
p#get_x    (* 返回 x 的值 *)
p#move 1.0 2.0   (* 将点移动到 (1.0, 2.0) *)
```

- p#get_x：调用对象 p 的方法 get_x，获取当前的 x 坐标。
- p#move 1.0 2.0：调用对象 p 的方法 move，将点的位置移动。
### **3.3 多态性、子类型和参数化类**

**多态性**

多态性允许对象以多种形式出现，特别是一个对象可以被看作是其类的多个超类的实例。OCaml 支持 **参数化类**，使得类可以接受类型参数，从而定义更加通用和灵活的结构。

**示例：定义一个泛型类**

```ocaml
class ['a] container init = object
  val mutable content : 'a = init
  method get = content
  method set x = content &lt;- x
end
```

- class ['a] container init：定义了一个参数化类 container，类型参数为 'a，初始值为 init。
- val mutable content : 'a：定义了一个可变的实例变量 content，类型为 'a。
- 该类可以用于存储任意类型的值。
**子类型**

子类型允许一个类继承另一个类的属性和方法。OCaml 支持单继承，即一个类可以继承自另一个类，获得其所有的字段和方法。

**示例：定义一个继承的类**

```ocaml
class colored_point x_init y_init c_init = object
  inherit point x_init y_init
  val mutable color = c_init
  method get_color = color
  method set_color c = color &lt;- c
end
```

- inherit point x_init y_init：colored_point 类继承自 point 类，传递初始参数。
- 新增了一个可变的实例变量 color，以及相关的方法。
**多态类型和子类型的关系**

在 OCaml 中，子类型多态性（也称为 **亚型多态性**）允许我们将一个对象视为其父类的类型。这意味着，可以将一个 `colored_point` 的实例用作 `point` 类型的对象。

### **3.4 理解对象和类**

**对象的本质**

对象是包含状态（字段）和行为（方法）的实体。它们封装了数据，并通过方法与外界交互。对象的状态通常是私有的，只有通过方法才能访问或修改。

**类的本质**

类是创建对象的模板。它定义了对象的结构（字段）和行为（方法）。类可以包含构造函数，用于初始化对象的状态。

**方法调度**

OCaml 中的方法调用使用符号 `#`，如 `obj#method`。方法调度是在运行时完成的，根据对象的实际类型来确定调用的方法。

**类型系统中的对象**

OCaml 的类型系统对对象和类进行了扩展，支持类型推断、多态性和子类型。这使得程序员能够编写类型安全的面向对象代码，同时享受类型推断带来的便利。

### **3.5 对象的类型检查**

**对象类型**

对象类型描述了对象的公共接口，即其方法的签名。对象类型的语法如下：

```plaintext
&lt; method1 : type1; method2 : type2; ... &gt;
```

**示例**

```ocaml
val p : &lt; get_x : float; get_y : float; move : float -&gt; float -&gt; unit &gt;
```

- 这是一个对象类型，描述了一个具有 get_x、get_y、move 方法的对象。
**类型检查规则**

在类型检查过程中，OCaml 会检查对象的方法是否符合其类型签名。这包括方法的名称、参数类型和返回类型。

**子类型规则**

子类型关系允许在需要基类类型的地方使用派生类的对象。这要求派生类的对象类型必须是基类对象类型的子类型。

### **3.6 类的类型检查**

**类类型**

类类型描述了类的类型签名，包括其构造函数参数和生成的对象类型。类类型的语法如下：

```plaintext
class_type_name = [ 'a1, ..., 'an ] -&gt; object_type
```

**示例**

```ocaml
class type point_class_type = object
  method get_x : float
  method get_y : float
  method move : float -&gt; float -&gt; unit
end
```

**类型参数**

参数化类可以有类型参数，用于定义泛型类。这些类型参数在类类型中也需要明确地表示。

**类型推断**

OCaml 的类型系统能够推断类和对象的类型，大多数情况下，程序员不需要显式地指定类型。

### **3.7 对象的高级用法**

**多态方法**

OCaml 支持定义多态方法，即方法可以对多种类型的参数进行操作。

**闭包和对象**

对象可以捕获其创建时的环境，从而形成闭包。这允许对象的方法访问创建时的上下文。

**私有方法和字段**

OCaml 允许定义私有的字段和方法，使得它们只能在类的内部访问，增强了封装性。

**虚方法**

虚方法是未在类中实现的方法，需要在派生类中进行实现。OCaml 支持抽象类和虚方法的概念。

**示例：定义一个抽象类**

```ocaml
class virtual shape = object
  method virtual area : float
end
```

- class virtual：定义一个抽象类 shape。
- method virtual area : float：声明了一个虚方法 area，返回类型为 float。
**在派生类中实现虚方法**

```ocaml
class circle r = object
  inherit shape
  method area = 3.1415 *. r *. r
end
```

- inherit shape：circle 类继承自 shape。
- 实现了虚方法 area。
**总结**

本章深入探讨了 OCaml 中的 **对象层**，介绍了对象和类的概念，以及它们在语言中的实现。我们从非正式的角度开始，探索了对象和类的基本概念，理解了如何在 OCaml 中定义和使用它们。

通过 **基本示例**，我们看到了如何定义一个简单的 `point` 类，包含可变字段和方法，以及如何创建对象的实例并调用其方法。我们还讨论了多态性、子类型和参数化类，了解了如何定义泛型类，以及如何通过继承实现子类型。

在 **理解对象和类** 的过程中，我们深入探讨了对象和类的本质，了解了方法调度的机制，以及对象在类型系统中的表示。我们讨论了对象类型和类类型的定义，以及类型检查的规则，特别是对象的类型检查和类的类型检查。

最后，我们展示了一些 **对象的高级用法**，包括多态方法、闭包、私有成员、虚方法和抽象类。通过这些高级特性，OCaml 的对象系统变得更加灵活和强大，允许程序员编写更加抽象和可重用的代码。

总体而言，本章为读者提供了一个全面的指南，帮助理解 OCaml 中的对象和类的概念，以及如何在实践中使用它们。通过掌握这些知识，读者将能够在 OCaml 中以面向对象的方式构建复杂的应用程序，同时利用 OCaml 强大的类型系统和函数式编程特性。
  



**概览**

本段内容主要介绍了 **OCaml** 中的 **对象（objects）** 和 **类（classes）**，以及与之相关的核心概念，如多态性、子类型和参数化类。通过一系列基本示例，阐述了对象和类的区别、它们在 OCaml 中的定义和使用方式，以及它们之间的关系。还深入探讨了对象类型、类类型，以及如何利用多态性和子类型来编写灵活和可重用的代码。最后，介绍了高级概念，如自类型（self types）和二元方法（binary methods），并通过练习来巩固理解。

## **3.1 探索对象和类**

### **引言**

在本节中，我们将通过一系列非常基础的示例，来介绍 OCaml 中的对象和类。首先，我们会讨论对象、类和类型之间的明确区别。然后，介绍对象和类的基本用法，展示它们如何在 OCaml 中定义和交互。最后，我们将引入多态性，这是 OCaml 中对象层的一个重要特性。

### **对象、类和类型的区别**

**对象（Objects）**

- **定义**：对象是值（values），可以通过求值返回，并可作为参数传递给函数。
- **交互方式**：与对象的交互方式是通过发送消息，即调用其方法（methods）。
- **特性**：对象只与其他值的交互方式不同，即通过方法调用。
**类（Classes）**

- **定义**：类不是对象，而是用于构建对象的定义。
- **构建方式**：可以从头开始构建。可以通过继承（inheritance）从其他类构建。
- **实例化**：对象通常通过类的实例化（使用 new 构造）来创建，也可以通过克隆或重写其他对象来创建。
**类型（Types）**

- **对象类型（Object Types）**：对象具有对象类型，是常规类型，类似于但不同于箭头类型（函数类型）或积类型（元组类型）。
- **类类型（Class Types）**：类也有类型，但类类型不是常规类型，就像类不是常规表达式一样，而是属于一个小的类语言的表达式。
- **关系**：**继承关系（sub-classing）**：类之间可能存在继承关系，当一个类继承自另一个类时。**子类型关系（subtyping）**：对象类型之间可能存在子类型关系。然而，子类化和子类型之间并没有直接的对应关系。
### **3.1.1 基本示例**

#### **定义一个简单的类**

我们从一个简单的示例开始，定义一个计数器类 `counter`：

```ocaml
class counter = object
  val mutable n = 0
  method incr = n &lt;- n + 1
  method get = n
end;;
```

**解释**：

- **类声明**：class counter 定义了一个名为 counter 的类。
- **对象主体**：object ... end 定义了对象的主体。
- **实例变量**：val mutable n = 0：定义了一个可变的实例变量 n，初始值为 0。
- **方法**：method incr = n &lt;- n + 1：定义了一个方法 incr，用于将 n 增加 1。method get = n：定义了一个方法 get，用于获取当前计数器的值 n。
**类型推断**：

OCaml 系统会为此声明推断一个主要类型：

```ocaml
class counter :
object
  val mutable n : int
  method get : int
  method incr : unit
end
```

- **解释**：类类型描述了类中每个字段和每个方法的类型，模仿了类的声明。
#### **创建对象实例**

从类创建对象实例，可以使用 `new` 构造：

```ocaml
let c = new counter;;
```

- **解释**：c 是一个 counter 类的实例。
**类型信息**：

```ocaml
val c : counter = 
```

- c 的类型是 counter。
#### **调用对象的方法**

可以调用对象的方法，这是与对象交互的唯一形式：

```ocaml
c#incr; c#incr; c#get;;
```

- **结果**：
```ocaml
- : int = 2
```

- **解释**：c#incr：调用 c 的 incr 方法，计数器加 1。c#get：调用 c 的 get 方法，返回当前计数器的值，结果为 2。
**注意**：

- **方法调用符号**：使用 # 进行方法调用，例如 c#incr。
- **字段的封装**：字段是封装的，只能通过方法访问。不能直接访问字段，如 c.n 是非法的。
- **对象的独立性**：同一类的两个实例会产生不同的对象，具有不同的封装状态。
```ocaml
(new counter)#get;;
```

- **结果**：
```ocaml
- : int = 0
```

- **解释**：每次创建新对象，计数器的初始值都是 0。
#### **对象的身份**

- **对象的比较**：通用相等运算符 = 总是区分两个不同的对象，即使它们属于同一个类，并且它们的字段具有相同的值。
```ocaml
(new counter) = (new counter);;
```

- **结果**：
```ocaml
- : bool = false
```

- **解释**：对象具有自己的身份，从不通过结构进行比较。
#### **使用类来封装方法**

类通常用于封装状态和方法，但也可以在没有任何字段的情况下使用它们，仅作为分组相关方法的一种方式。

**示例**：

```ocaml
class out =
object
  method char x = print_char x
  method string x = print_string x
end;;
```

- **解释**：out 类包含两个方法：method char x：打印字符 x。method string x：打印字符串 x。
**另一个具有更丰富接口和不同行为的类**：

```ocaml
class fileout filename =
object
  val chan = open_out filename
  method char x = output_char chan x
  method string x = output_string chan x
  method seek x = seek_out chan x
end;;
```

- **解释**：val chan：一个不可变的实例变量，打开了文件 filename 的输出通道。method char x：将字符 x 输出到文件。method string x：将字符串 x 输出到文件。method seek x：将输出位置移动到位置 x。
**编程范式**：这支持了所谓的 **“通过消息编程”（programming by messages）** 的范式。

**示例**：

```ocaml
let stdout = new out and log = new fileout "log";;
let echo_char c = stdout#char c; log#char c;;
```

- **解释**：创建了两个对象 stdout 和 log。定义了函数 echo_char，它对两个对象发送 char 消息（调用 char 方法），但它们的行为不同。stdout#char c：在标准输出上打印字符 c。log#char c：在日志文件中输出字符 c。
**多态性**：两个对象可能以不同的方式响应相同的消息，运行它们自己的方法，这取决于它们的类。

#### **继承**

类不仅用于创建对象，还用于通过 **继承（inheritance）** 创建更丰富的类。

**示例**：扩展 `fileout` 类，添加一个方法来关闭输出通道：

```ocaml
class fileout' filename =
object (self)
  inherit fileout filename
  method close = close_out chan
end;;
```

- **解释**：object (self)：定义了 self，表示对象自身。inherit fileout filename：继承了 fileout 类，传递了参数 filename。method close：定义了一个新的方法 close，用于关闭输出通道。
**仅用于继承的类**：也可以定义一个类，专门用于通过继承来构建其他类。

**示例**：定义一个虚类 `writer`：

```ocaml
class virtual writer =
object (this)
  method virtual char : char -&gt; unit
  method string s =
    for i = 0 to String.length s - 1 do this#char s.[i] done
  method int i = this#string (string_of_int i)
end;;
```

- **解释**：class virtual writer：定义了一个虚类 writer。method virtual char：声明了一个虚方法 char，需要在子类中实现。method string s：定义了方法 string，通过调用 this#char 来输出字符串的每个字符。method int i：定义了方法 int，将整数转换为字符串，然后调用 this#string。
**注意**：

- this 绑定到运行该方法的对象，允许方法调用同一对象的其他方法。
- writer 类被标记为 virtual，因为它引用了尚未定义的 char 方法。
- 结果是，writer 不能被实例化为对象，只能被继承。
- 虚方法 char 将在子类中定义。
**继承示例**：`fileout` 类可以被定义为 `writer` 的扩展：

```ocaml
class fileout filename = object
  inherit writer
  method char x = output_char chan x
  method seek pos = seek_out chan pos
end;;
```

- **解释**：继承了 writer 类。实现了虚方法 char。添加了方法 seek。
#### **晚绑定（Late Binding）**

- **定义**：在继承过程中，父类的某些方法可能会被重新定义。晚绑定指的是，在对象创建时，会采用方法的最新定义。
- **重要性**：晚绑定是面向对象编程的一个重要方面，但也带来了复杂性。
**示例**：更有效地定义 `fileout` 类，忽略 `writer` 中 `string` 方法的默认定义，使用直接且更快的实现：

```ocaml
class fileout filename = object
  inherit writer
  method char x = output_char chan x
  method string x = output_string chan x
  method seek pos = seek_out chan pos
end;;
```

- **解释**：重写了 string 方法，提供了更高效的实现。现在，int 方法将调用新的 string 方法，而不是 writer 中的默认定义。
#### **类型别名**

- **定义**：类的定义同时为该类的对象类型定义了一个类型别名。
- **示例**：
```ocaml
val stdout : out = 
val log : fileout = 
```

- **解释**：当定义 stdout 和 log 时，系统给出了它们的类型 out 和 fileout。
**对象类型是结构化的**：

- 可以随时通过展开别名来查看它们的确切结构。
```ocaml
(stdout : &lt; char : char -&gt; unit; string : string -&gt; unit &gt;);;
- : out = 
```

- **解释**：stdout 的类型是一个对象类型，具有 char 和 string 方法。
**类型约束的失败示例**：

```ocaml
(log : &lt; char : char -&gt; unit; string : string -&gt; unit &gt;);;
```

- **解释**：此类型约束会失败，因为 log 的类型 fileout 包含额外的方法 seek，而目标类型中没有 seek 方法。
### **3.1.2 多态性、子类型和参数化类**

#### **多态性**

多态性在对象层中扮演着重要角色。对象类型如 `out`、`fileout` 或 `&lt; char : char -&gt; unit; string: string -&gt; unit &gt;` 被称为 **封闭的（closed）**。封闭类型详尽列举了对象的所有可访问方法。

**开放对象类型**：

- **定义**：仅指定对象可访问方法的子集，可能还有其他未指定的方法。
- **示例**：
```ocaml
let send_char x = x#char;;
val send_char : &lt; char : 'a; .. &gt; -&gt; 'a = 
```

- **解释**：send_char 函数的参数类型是一个对象，至少具有一个 char 方法，类型为 'a。.. 表示对象可能还有其他方法。.. 实际上代表一个匿名的行变量（row variable），对应的类型是多态的。
**多态性的关键点**：

- send_char 是多态的，可以应用于任何具有 char 方法的对象。
- **示例**：可以应用于 stdout 或 log，即使它们的类型不同。
```ocaml
let echo c = send_char stdout c; send_char log c;;
```

- **如果没有多态性**，上述代码将无法编译。
#### **子类型**

在大多数面向对象语言中，具有更大接口的对象可以用在需要较小接口的对象的地方。这种特性称为 **子类型（subtyping）**。

- **在 OCaml 中**：这也是可能的，但必须显式地指明子类型的使用。
**示例**：

```ocaml
let channels = [stdout; (log : fileout :&gt; out)];;
val channels : out list = [; ]
```

- **解释**：log 被强制转换为类型 out，以便与 stdout 放在同一个列表中。:&gt; 是子类型转换的符号。
**省略子类型转换的域**：

- 在许多情况下，可以省略子类型转换的源类型，这是合法的：
```ocaml
let channels = [stdout; (log :&gt; out)];;
```

**注意**：

- 在 OCaml 中，子类型转换的需求并不频繁，因为多态性通常可以更好地使用，特别是在多态方法调用中。
- 反向转换（从超类型到子类型）在 OCaml 中从不可能。
#### **参数化类**

多态性在参数化类中也扮演着重要角色。参数化类对应于面向对象风格的多态数据结构，如列表、集合等。

**示例**：定义一个元素类型参数化的栈类：

```ocaml
class ['a] stack = object
  val mutable p : 'a list = []
  method push v = p &lt;- v :: p
  method pop =
    match p with h :: t -&gt; p &lt;- t; h | [] -&gt; failwith "Empty"
end;;
```

- **解释**：class ['a] stack：定义了一个参数化类，类型参数为 'a。val mutable p : 'a list：定义一个可变的实例变量 p，类型为 'a list。method push v：将元素 v 压入栈。method pop：弹出栈顶元素。
**类型推断**：

```ocaml
class ['a] stack :
object
  val mutable p : 'a list
  method pop : 'a
  method push : 'a -&gt; unit
end
```

- **解释**：系统推断出该类的多态类型。
**参数必须显式引入**：

- 定义参数化类时，必须显式引入类型参数，并在类内部使用。
- 原因：参数化类不仅定义了类的代码，还定义了该类对象的类型别名。
- 类似于类型别名定义中，自由类型变量必须在类型参数中绑定。
**参数化类的用途**：

- 非常有用于定义通用目的的类。
- **示例**：维护订阅者列表并通过 send 消息转发消息的类。
```ocaml
class ['a] relay = object
  val mutable l : 'a list = []
  method add x = if not (List.mem x l) then l &lt;- x :: l
  method remove x = l &lt;- List.filter (fun y -&gt; x &lt;&gt; y) l
  method send m = List.iter m l
end;;
```

**对象的多态性**：

- 参数化类是多态的，但参数化类的对象不是。
- 创建类的实例 new c 类似于创建引用 ref a。
- 因为对象的创建可能也会创建可变字段，因此它不能安全地是多态的。
#### **self 类型**

OCaml 的另一个重要特性是能够在不知道对象的确切结构的情况下，精确地关联两个对象的类型。

**示例**：返回给定对象的浅拷贝的库函数 `Oo.copy`：

```ocaml
Oo.copy : (&lt; .. &gt; as 'a) -&gt; 'a
```

- **解释**：参数类型为 (&lt; .. &gt; as 'a)：表示参数必须是一个对象，.. 代表“任何其他方法”。返回类型为 'a：表示无论参数的具体类型是什么，返回的类型与参数类型完全相同。
- **多态性**：Oo.copy 的类型是多态的，可以实例化为 fileout -&gt; fileout、&lt; gnu : int &gt; -&gt; &lt; gnu : int &gt; 等。
**在类中内部化拷贝方法**：

```ocaml
class copy = object (self) method copy = Oo.copy self end;;
```

- **类型信息**：
```ocaml
class copy : object ('a) method copy : 'a end
```

- **解释**：('a) 是 self 类型，放在括号中。方法 copy 返回类型为 'a，即 self 类型。
- **self 类型的特性**：self 类型是开放类型，类在 self 类型上是多态的。类的对象类型始终是封闭的，实际上是其类的 self 类型的一个实例。
**一般情况**：

- 对于任何类 C，其子类的对象类型都是类 C 的 self 类型的一个实例。
#### **练习 23：自类型的区别**

**问题**：

解释以下两个类之间的区别：

```ocaml
class c1 = object (self) method c = Oo.copy self end
class c2 = object (self) method c = new c2 end;;
```

**解答**：

- **class c1**：方法 c 返回 Oo.copy self，即返回 self 的浅拷贝。返回的对象与调用方法的对象类型相同，包含所有字段和方法的当前状态。
- **class c2**：方法 c 返回 new c2，即创建并返回一个新的 c2 类的实例。返回的对象是一个新的 c2 对象，与调用方法的对象无关。
- **区别**：c1 的 c 方法返回调用对象的拷贝，保留了对象的状态和类型，包括可能的子类扩展。c2 的 c 方法总是返回一个新的 c2 实例，不考虑子类的扩展。
- **结论**：c1 更加通用，因为在子类中，self 类型会相应地更新，c 方法返回的对象类型与子类对象类型一致。c2 的 c 方法在子类中不会返回子类类型的对象，而是始终返回 c2 类型的对象。
#### **练习 24：备份**

**问题**：

定义一个类 `backup`，具有方法 `save` 和 `restore`，以便在（几乎）任意类中继承时，方法 `save` 将备份内部状态，方法 `restore` 将对象返回到上次备份时的状态。

**解答**：

**思路**：

- 我们需要在对象中存储一个备份的内部状态，可以使用可变字段来存储备份。
- 在 save 方法中，保存当前状态。
- 在 restore 方法中，将状态恢复到备份的状态。
**实现**：

```ocaml
class backup = object (self)
  val mutable saved_state = None
  method save = saved_state &lt;- Some (Oo.copy self)
  method restore = match saved_state with
    | Some s -&gt; s
    | None -&gt; self
end;;
```

- **解释**：saved_state：一个可变字段，类型为 option，用于存储备份的对象。method save：使用 Oo.copy self 来保存当前对象的拷贝到 saved_state。method restore：如果有备份，则返回备份的对象，否则返回自身。
**继承示例**：

```ocaml
class my_class = object
  inherit backup
  (* 其他字段和方法 *)
end;;
```

- **解释**：在继承自 backup 的类中，可以使用 save 和 restore 方法来备份和恢复对象的状态。
#### **函数式备份版本**

还有一个避免使用可变字段的函数式版本，使用 `{&lt; &gt;}` 构造，它返回 `self` 的一个拷贝，可以在拷贝时更改字段的值。

**实现**：

```ocaml
class original =
object (self)
  val original = None
  method copy = {&lt; original = Some self &gt;}
  method restore =
    match original with None -&gt; self | Some x -&gt; x
end;;
```

- **解释**：method copy：返回一个新的对象，字段 original 被设置为 Some self。method restore：如果 original 有值，则返回存储的对象，否则返回自身。
- **优点**：original 字段不需要是可变的。
#### **练习 25：对数级备份**

**问题**：

编写 `backup` 或 `original` 类的变体，保留所有中间备份。添加一个方法 `clean`，选择性地移除一些中间备份，例如，仅保留年龄为 `2^0`、`2^1`、...、`2^n` 的版本。

**解答**：

**思路**：

- 使用一个列表来存储所有的备份。
- 每次调用 save，将当前状态添加到备份列表中。
- clean 方法按照指定规则删除部分备份。
**实现**：

```ocaml
class advanced_backup = object (self)
  val mutable backups = []
  method save = backups &lt;- (Oo.copy self) :: backups
  method restore n =
    let rec find_nth l i =
      match l with
      | [] -&gt; self
      | h :: t -&gt; if i = 0 then h else find_nth t (i - 1)
    in
    find_nth backups n
  method clean =
    backups &lt;- List.filteri (fun i _ -&gt; is_power_of_two i) backups
  (* 辅助函数 *)
  method private is_power_of_two n =
    n &lt;&gt; 0 && (n land (n - 1)) = 0
end;;
```

- **解释**：backups：可变字段，存储所有备份的列表。method save：保存当前对象的拷贝到 backups。method restore n：恢复第 n 个备份。method clean：只保留索引为 2 的幂次的备份。is_power_of_two：检查一个数是否是 2 的幂次。
#### **二元方法（Binary Methods）**

最后，我们讨论一个众所周知的问题，即 **二元方法**。这些方法接受一个对象（或包含对象的值）作为参数，其类型与 `self` 的类型相同。

**继承中的问题**：

- 从这样的类继承通常是一个问题。
- 但在 OCaml 中，由于自类型的表达能力和多态性的使用，这种困难并不明显。
**示例**：两个玩家：业余玩家和专业玩家。

**业余玩家**：

```ocaml
class amateur = object (self)
  method play x risk = if Random.int risk &gt; 0 then x else self
end;;
```

- **解释**：method play x risk：与另一个玩家 x 玩游戏，risk 是风险级别。如果随机数大于 0，则返回对手 x，否则返回自己 self。
**专业玩家**：

```ocaml
class professional k = object (self)
  inherit amateur as super
  method level = k
  method play x risk = super#play x (risk + self#level - x#level)
end;;
```

- **解释**：inherit amateur as super：继承自 amateur，并命名父类为 super。val k：专业玩家的级别。method level：返回玩家的级别。method play：重写 play 方法，根据玩家的级别调整风险。
**类型问题**：

- 专业玩家不能被视为业余玩家，尽管他有更多的方法。
- 原因是专业玩家的 play 方法期望参数 x 具有与 self 相同的类型，而业余玩家没有 level 方法。
**对象类型**：

```ocaml
class amateur : object ('a)
  method play : 'a -&gt; int -&gt; 'a
end

class professional : object ('a)
  method level : int
  method play : 'a -&gt; int -&gt; 'a
end
```

- **解释**：由于 play 方法的参数 x 的类型是 self 类型，这是一个逆变位置的递归出现。因此，具有二元方法的对象类型没有除自身以外的任何子类型。
#### **练习 26：面向对象的字符串**

**问题**：

定义一个 `string` 类，将字符串的大多数重要操作嵌入到类中。扩展前面的定义，添加一个方法 `concat`。

**解答**：

**实现**：

```ocaml
class string_object s = object (self)
  val mutable str = s
  method get = str
  method set s = str &lt;- s
  method length = String.length str
  method concat s' = str &lt;- str ^ s'#get
  method substring start len = String.sub str start len
  method index c = String.index str c
  (* 其他字符串操作方法 *)
end;;
```

- **解释**：val mutable str：可变字段，存储字符串内容。method get：获取当前字符串。method set：设置新的字符串。method length：获取字符串长度。method concat s'：将另一个 string_object 的字符串连接到当前字符串。s'#get 获取另一个对象的字符串内容。**扩展**：可以添加更多字符串操作方法，如 uppercase、lowercase、split 等。
**总结**

本节深入探讨了 OCaml 中的对象和类的基本概念和高级用法。首先，我们明确了对象、类和类型之间的区别，了解了对象是值，类是构建对象的定义，而对象类型和类类型分别描述了对象和类的结构。

通过基本示例，我们学习了如何定义类、创建对象实例、调用方法，以及对象的身份和封装特性。我们看到，类可以用来封装状态和方法，也可以仅用于分组相关的方法。继承是创建更丰富类的重要机制，我们可以通过继承来扩展类的功能，定义虚类和虚方法，实现晚绑定。

多态性在对象层中扮演着重要角色，开放对象类型允许我们编写更加通用和灵活的代码。通过多态性和子类型，我们可以在需要较小接口的地方使用具有更大接口的对象。参数化类使我们能够定义泛型类，如栈和集合，增强了代码的可重用性。

自类型（self types）和二元方法（binary methods）是对象系统中的高级概念。自类型允许我们在不知道对象确切结构的情况下，精确地关联对象的类型。二元方法是接受与自身类型相同的对象作为参数的方法，虽然在继承中可能带来类型问题，但在 OCaml 中得到了很好的处理。

通过练习，我们进一步理解了这些概念，例如实现了一个支持备份和恢复的类，探索了二元方法在实际中的应用，以及如何定义一个面向对象的字符串类。

总之，本节为我们提供了深入理解 OCaml 对象系统的基础，展示了如何利用对象和类来编写灵活、高效和可维护的代码。通过掌握这些概念，我们可以在 OCaml 中充分发挥面向对象编程的优势，同时享受函数式编程的强大特性。
  



**概览**

本段内容深入探讨了 **OCaml** 中对象层的核心，特别是对象和类的形式化及其类型检查。我们将了解对象类型和类类型的定义和类型检查规则，探讨了对象类型的结构化和多态性，以及递归类型在对象类型中的应用。还讨论了类型推断中如何处理对象类型的统一，以及类型缩略的作用。此外，我们还会了解可变字段、重写和子类型的概念，以及它们在 OCaml 类型系统中的处理方式。

## **3.2 理解对象和类**

### **引言**

在本节中，我们将形式化地探讨 OCaml 对象层的核心部分。在这个过程中，我们做了一些简化，虽然稍微减少了对象和类的表达能力，但保留了所有有趣的特性。

#### **主要限制**

- **字段不可变**：我们考虑字段是不可变的。虽然可变字段在实践中很重要，但命令式特性与面向对象机制是正交的。命令式对象可以很好地解释为带有引用的函数式对象：可变字段通常可以替换为内容为引用的不可变字段。**损失**：这种替换会有一些损失，我们将在后面讨论。因此，我们仍将描述可变字段，包括它们的类型检查，但只会非正式地描述它们的语义。
### **多态性的重要性**

正如在对象和类的非正式介绍中所展示的，多态性确实是 OCaml 对象和类的表达能力的关键。特别是，以下几点至关重要：

- **对象类型是结构化的**（即它们的结构是透明的），并使用 **行变量（row variables）** 来允许多态性。
- **类类型在 self 的类型上是多态的**，以允许进一步的精炼。
除了增加表达能力，多态性在类型推断中也起着重要作用：

- **发送消息给未知类的对象**：多态性允许我们发送消息给未知类的对象，特别是无需确定它们所属的类。
- **结构化对象类型和行变量**：这通过使用结构化对象类型和行变量成为可能。结构化类型意味着类型的结构始终是透明的，不能被不透明的名称隐藏。（我们也说对象类型具有结构化等价性，与数据类型的按名称等价性相反。）
- **对象是“一等公民”**：它们可以作为函数的参数，作为参数传递或作为结果返回。
**相反**，**类是“二等公民”**：

- **类不能作为其他表达式的参数**。
- **因此，只有已存在的类**（即已知的类类型）可以被继承或实例化为对象。
- **结果**：类的类型重建不需要比类的组件的类型推断更多的机制，即大致与核心语言的表达式的类型推断相当。
### **对象和类的语法**

我们假设以下三个集合：

- **字段名称集合**：u ∈ F
- **方法名称集合**：m ∈ M
- **类名称集合**：z ∈ Z
为了考虑对象和类，我们扩展了核心语言的语法，如 **图 3.1** 所示。

#### **图 3.1：对象和类的语法**

```plaintext
表达式：
a ::= ... | new a | a#m | class z = d in a

类表达式：
d ::= object B end
     | {z}                 // 创建
     | z | λx.d | d a
     | {z}                 // 抽象和实例化

类体：
B ::= ∅ | B inherit d | B u = a | {z}        // 字段
      | B m = ς(x) a
      | {z}                 // 方法
```

**说明**：

- **表达式**：new a：创建一个新对象。a#m：对象 a 调用方法 m。class z = d in a：在表达式 a 中定义类 z。
- **类表达式**：object B end：定义一个新的类，类体为 B。z：类变量。λx.d：类抽象，参数为 x，类体为 d。d a：类应用，将值 a 应用于类表达式 d。
- **类体**：∅：空的类体。B inherit d：继承自类 d 的类体 B。B u = a：在类体 B 中添加字段 u，其值为 a。B m = ς(x) a：在类体 B 中添加方法 m，方法体为 a，x 绑定为 self。
**注意**：

- 与 OCaml 的一个小差异是，我们选择在每个方法中绑定 self，而不是在每个类体的开头一次性绑定。因此，方法形式为 ς(x) a，其中 x 是 self 的绑定器。
- 我们可以将 OCaml 表达式 object (x) u=a; m1=a1; m2=a2 end 视为语法糖，等价于 object u = a; m1 = ς(x) a1; m2 = ς(x) a2 end。
### **对象和类的类型检查**

正如上面所建议的，对象和类的类型检查是正交的，并依赖于设计的不同方面。我们在两个不同的部分中分别考虑它们。

## **3.2.1 对象的类型检查**

对象的成功类型检查源于以下特性的精心组合：

- **结构化对象类型**。
- **行变量（Row Variables）**。
- **递归类型**。
- **类型缩略（Type Abbreviations）**。
**目的**：

- **结构化类型和行多态性**允许消息的多态调用。
- **递归类型的需求**：由于类型的结构化处理，对象类型本质上是递归的（对象通常引用自己）。
- **类型缩略的作用**：由于结构化类型的另一个结果是对象类型往往非常大，它们描述了所有可访问方法的类型，这些方法本身通常是具有大类型的对象之间的函数。因此，使用一种智能的类型缩略机制来保持类型相对较小，并使其表示紧凑。
**进一步说明**：

- **类型缩略在理论上不是必需的**，但在实践中至关重要，既有助于与用户的平滑交互，又有助于类型推断的合理效率。
- **匿名行变量**：观察到某些形式的对象类型永远不会被推断出来，这允许保持所有行变量匿名，这显著简化了向用户呈现对象类型。
### **对象类型**

**直观理解**：

- 对象类型由所有可见方法及其类型的行组成（对于封闭对象类型），并可选择以一个行变量结束（对于开放对象类型）。
**问题**：

- 这种表示方式不太模块化，特别是用一个行替换行变量并不会产生一个良构的类型。
**解决方案**：

- 我们分两步定义类型。假设有一个可数的行变量集合 `% ∈ R`，原始类型和行由以下语法描述：
```plaintext
τ ::= ... | ⟨ρ⟩
ρ ::= 0 | % | m : τ ; ρ
```
这禁止在对象类型的末尾之外的任何地方使用行变量。
**需要注意的非法类型**：

- 一些原始类型没有意义，应该被拒绝。例如：**重复标签的行**：如 (m : τ ; m : τ' ; ρ)，应被视为不良构的类型。**非法类型嵌套**：如 ⟨m : τ ; ρ⟩ → ⟨ρ⟩，如果用 ρ 替换为 m : τ' ; ρ，将产生一个不良构的类型。
**良构性的保持**：

- **模块化标准**：通过给每个行分配它不应该定义的标签集来对原始类型进行排序，并将顶层行（在类型构造器 `⟨·⟩` 下面立即出现的行）分配空集 `∅`。
- **类型的定义**：类型是所有良排序的原始类型的集合。
- **行的等价**：行被认为是模左交换（左结合）的，即 `m1 : τ1 ; (m2 : τ2 ; ρ)` 等价于 `m2 : τ2 ; (m1 : τ1 ; ρ)`。为了记号方便，我们假设 (m : τ ; ) 右结合紧密，因此我们可以简单地写成 (m : τ ; m' : τ' ; ρ)。
#### **备注 6**

- **对象类型与多态记录类型的相似性**：对象类型实际上类似于（不可扩展的）多态记录的类型。**多态记录访问**对应于消息调用。**多态记录扩展**在这里不需要，因为 OCaml 基于类的对象是不可扩展的。因此，可以使用一些更简单的针对记录类型的 **具化类型（kinded types）** 方法。
- **参考**：参见第 2 章结尾，第 66 页，了解更多关于多态记录的参考资料。
### **消息调用的类型化**

**消息调用的类型规则**：

```plaintext
Message
A ⊢ a : ⟨m : τ ; ρ⟩
——————————————
A ⊢ a#m : τ
```

- **解释**：如果表达式 a 是一个对象，具有方法 m，类型为 τ，并且可能还有其他方法（由行 ρ 捕获），那么表达式 a#m 是良类型的，类型为 τ。
**替代方案**：

- 我们更喜欢将消息调用 `a#m` 视为对表达式 `a` 应用一个原语 `#m`。
- 因此，我们假设初始环境包含一组假设：
```plaintext
(.m) : ∀α, %. ⟨m : α; %⟩ → α
```
对于所有方法名 m ∈ M。
- **优势**：我们利用了语言中原语的参数化，避免了引入新的类型规则。
### **对象类型的类型推断**

**统一问题**：

- 由于我们没有更改表达式的集合，因此消息调用的类型推断问题归结为解决统一问题，就像之前一样。
- 但是，现在类型更丰富，包含了对象类型和行。
- 因此，类型推断归结为对这些更丰富的类型进行统一。
**良构性的约束**：

- **对象类型必须是良排序的**，这显著限制了左交换方程的应用。
- 结果是，可解的统一问题具有主解。
- 此外，带有对象类型的类型的统一算法可以通过对简单类型的算法进行简单修改而获得。
#### **练习 27：对象类型**

**问题**：

- 检查重写规则是否保持了排序（良构性）。
**图 3.2：对象类型的统一**

```plaintext
使用表 1.5 中的规则，其中 Fail 排除了由两个形式为 (m : ; ) 的符号组成的对，并添加以下规则：

Mute
如果 m1 ≠ m2 且 α ∉ {α1, α2} ∪ ftv(e)

(m1 : α1; %1) ⋍ (m2 : α2; %2) ⋍ e
————————————————————————————————————————
∃%.(m1 : α1; m2 : α2; %) ⋍ e ∧ %1 ⋍ (m2 : α2; %) ∧ %2 ⋍ (m1 : α1; %)
```

**说明**：

- 这个规则用于处理不同方法名的行的统一。
### **匿名行变量**

事实上，OCaml 使用了另一种对类型的限制，这不是强制性的，但在实践中非常方便，因为它避免了向用户显示行变量。

**全局限制**：

- 在任何统一项中，我们强制任何以相同行变量结尾的两个行相等。
**表示方式**：

- 这样的统一项可以写成：
```plaintext
U ∧ ⋀_{i∈I} (∃%_i . ⟨m_i : τ_i ; %_i⟩ ⋍ e_i)
```
其中 U、所有 τ_i 和 e_i 不包含任何行变量。
- 在这种情况下，我们可以将 `∃%_i . ⟨m_i : τ_i ; %_i⟩ ⋍ e_i` 简化为 `⟨m_i : τ_i ; 1⟩ ⋍ e`，使用匿名行变量 `1` 代替 `%`。
**重要性**：

- 重要的是，这一性质在简化统一问题的过程中始终可以保持。
#### **练习 28：对象类型的统一**

**问题**：

- 为受限的统一问题给出简化规则，以保持问题在受限形式中（使用匿名行变量）。
**解答**：

- 在受限的统一问题中，所有的行变量都是匿名的，我们需要设计简化规则，使得在统一过程中不会引入新的命名行变量，并保持所有行变量匿名。
### **替代表示**

匿名行变量的另一种表示是使用 **具化类型（kinded types）**：

- 方程 `α ⋍ ⟨m : τ ; 1⟩` 可以替换为 **种类约束（kind constraint）** `α :: ⟨m : τ ; 1⟩`。
- 类似地，`α ⋍ ⟨m : τ ; 0⟩` 替换为 `α :: ⟨m : τ ; 0⟩`。
### **递归类型**

**对象类型可能是递归的**。

- **原因**：类返回 self。拥有二元方法的类。能够互相调用的对象的组合。
- **重要性**：递归类型无疑是重要的。
**处理递归类型**：

- **在没有对象类型的情况下**（即在 ML 中），类型是自由代数的项，具有无限项的自由代数的统一是众所周知的：从图 1.5 的重写规则中删除规则 Cycle，提供了一个用于递归简单类型的统一算法。
- **在存在对象类型的情况下**，类型不再是自由代数的项，因为行被认为是模左交换公理的。
- **问题**：通常，公理与递归类型不能很好地混合（通常会出现病态解，主统一子可能会丢失）。不受限制的左交换公理本身就是有问题的。
**解决方案**：

- **幸运的是**，通过 **排序约束** 限制对象类型的使用，这限制了左交换的使用，使得对象类型在递归类型下表现良好。
- **具体而言**，对象类型可以像简单类型一样扩展为无限项。
- **统一算法**：通过从图 1.5 和 3.2 的重写规则中删除 Cycle 规则，可以获得用于递归对象类型的统一算法。
#### **备注 7**

- **允许递归类型保持了类型健全性**。
- **然而**，它经常将程序员的简单错误（如遗漏参数）转化为具有意外递归类型的良类型程序。
- **例子**：λ-演算的所有项（没有常量）在递归类型下都是良类型的。
- **风险**：这样的错误可能未被检测到，或者只在很晚的时候被检测到，除非程序员仔细检查推断的类型。
**限制递归类型**：

- 可以对递归类型进行限制，例如要求任何递归路径至少跨越一个对象类型构造器。
- **虽然这样的限制看似武断，但在实践中通常比不加任何限制更可取**。
### **类型共享**

**表示递归类型**：

- **有限类型**通常表示为树。
- **递归类型**（即无限正规树）可以用多种方式表示。
- **标准记号**：`μθ.τ`，表示无限展开的树 `τ[τ[...]/θ]/θ`。
- **另一种表示**：将正规树表示为一个项 `τ` 和一组处于规范形式的方程 `U` 的对 `τ | U`。**优点**：这种解决方案还可以表示共享的子项。
- **例子**：类型 α → α | α ⋍ τ 与类型 τ → τ 不同（考虑共享时）。
- **共享的来源**：共享可能存在于源程序中（例如，如果用户指定了类型约束）。它也可能在统一过程中引入。
- **保持共享的好处**：增加效率。在显示类型时，使其保持简洁，通常更易读。
**匿名行变量中的应用**：

- **类型共享也用于保持行变量匿名**。
- **例子**：`⟨m : int; %⟩ → ⟨m : int; %⟩`，表示为 `α → α`，其中 `α ⋍ ⟨m : int; 1⟩`。
- **消除共享**：消除共享要么不正确，要么需要重新引入行变量。
**OCaml 中的类型共享显示**：

- **使用 as 构造**：共享的子项显示为一个变量，其方程显示在树的最左最外层的子项中。
- **例子**：上一个例子显示为 `(⟨m : int; 1⟩ as α) → α`。递归类型 `μα.⟨m : int → α⟩`，表示为 `α`，其中 `α ⋍ ⟨m : int → α⟩`，显示为 `(⟨m : int → α⟩ as α)`。
**注意**：

- as 构造全局绑定（而在 (μα.τ) → α 中，用于命名左分支的递归子项的变量 α 是右分支的自由变量）。
### **类型缩略**

**目的**：

- 虽然对象类型是结构化的，但它们也被命名，以使其简短且可读。
- **实现方式**：使用类型缩略，由类生成，并在获取对象实例时引入。
**类型缩略的透明性**：

- **透明的**：可以随时用它们的定义替换。
- **示例**：
```ocaml
class c = object method m = 1 end;;
class c : object method m : int end

let f x = x#m in let p = new c in f p;;
```
- **解释**：函数 `f` 期望一个类型为 `⟨m : α; 1⟩` 的参数，而 `p` 的类型为 `c`。如果 `c` 是一个常规的类型符号，那么这两个类型的统一将失败。然而，由于它是一个缩略，统一可以继续，将 `c` 替换为其定义 `⟨m : int⟩`，最终返回替换 `α ↦ int`。
## **3.2.2 类的类型检查**

类的类型检查得益于一些设计选择。

### **设计选择**

1. **不需要猜测类的类型**：
- 因为对类的抽象的唯一形式是通过函子（functors），其中类型必须被声明。
2. **字段和方法的区别**：
- 字段在对象类型中从不可见。
- 它们只能通过方法调用间接访问。
3. **self 类型的多态性**：
- 关键点是将类类型化，就好像它们将 self 作为参数一样。
- 因此，self 的类型是一个开放的对象类型，收集了类型化类主体所需的最小约束集。
- 在子类中，可以使用具有更多约束的 self 类型的精炼版本。
### **类类型的定义**

- **总结**：一个基本类的类型是一个三元组 `ζ(τ)(F; M)`，其中：τ 是 self 的类型。F 是字段列表及其类型。M 是方法列表及其类型。
- **类的参数化**：类还可以通过值进行参数化，即从值到类的函数。因此，类类型也包含函数式的类类型。
- **更精确的定义**：类类型由以下语法定义（我们使用字母 `ϕ` 表示类类型）：
```plaintext
ϕ ::= ζ(τ)(F; M) | τ → ϕ
```
### **类体的类型化**

我们可以通过一个小示例来探索类体的类型化。

#### **示例**

考虑在类型环境 `A` 中对类 `object u=au; m=ς(x) am end` 的类型化。

- **类定义**：定义了一个字段 u 和一个方法 m。
- **期望的类类型**：形式为 ζ(τ)(u : τu; m : τm)。
- **字段的计算**：在对象的创建之前进行。**为了防止访问尚未定义的字段**，在字段表达式中，方法和 `self` 都是不可见的。**因此**，表达式 `au` 在环境 `A` 中类型化。我们必须有 A ⊢ au : τu。
- **方法体的类型化**：方法 `m` 的方法体可以看到 `self` 和字段 `u`，类型分别为 `τ` 和 `τu`。**因此**，我们必须有 `A, x : τ, u : τu ⊢ am : τm`。
- **self 类型的约束**：最后，我们检查 `self` 类型中假定的 `m` 方法的类型是否与在类体中推断的 `m` 方法的类型一致。即，我们必须有 `τ = ⟨m : τm; ρ⟩`。
#### **一般情况的处理**

使用辅助判断 `A ⊢ B : ζ(τ)(F; M)` 来类型化类体，增量地，从左到右考虑声明。

#### **类体的类型规则（图 3.3）**

```plaintext
Empty
———————
A ⊢ ∅ : ζ(τ)(∅; ∅)

Field
A ⊢ B : ζ(τ)(F; M)     A ⊢ a : τ'
———————————————————————————
A ⊢ (B, u = a) : ζ(τ)(F ⊕ u : τ'; M)

Method
A ⊢ B : ζ(τ)(F; M)     A, x : τ, F ⊢ a : τ'
———————————————————————————————————
A ⊢ (B, m = ς(x) a) : ζ(τ)(F; M ⊕ m : τ')

Inherit
A ⊢ B : ζ(τ)(F; M)     A ⊢ d : ζ(τ)(F'; M')
——————————————————————————————
A ⊢ B inherit d : ζ(τ)(F ⊕ F'; M ⊕ M')
```

**解释**：

- **Empty 规则**：一个空的类体定义了没有字段和方法，并且使 `self` 的类型不受约束。
- **Field 规则**：在当前环境中类型化字段声明 u = a。将新的字段类型假设添加到类体的类型中。
- **Method 规则**：在扩展了 `self` 的类型假设和所有字段类型假设的当前环境中类型化方法体 `a`。将新的方法类型假设添加到类体的类型中。
- **Inherit 规则**：继承子句将父类的字段和方法类型与当前类的字段和方法类型组合起来。它还确保父类和当前类的 `self` 类型兼容。**符号 ⊕** 表示兼容的并集（compatible union），表示在两边定义的字段或方法应具有兼容的类型。
### **类表达式的类型化**

**类型规则（图 3.4）**

```plaintext
Object
A ⊢ B : ζ(τ)(F; M)     τ = ⟨M; ρ⟩
—————————————————————————
A ⊢ object B end : ζ(τ)(F; M)

Class-Var
d : ∀α. ϕ
—————————
A ⊢ d : ϕ[τ/α]

Class-Fun
A, x : τ ⊢ d : ϕ
—————————————
A ⊢ λx.d : τ → ϕ

Class-App
A ⊢ d : τ → ϕ     A ⊢ a : τ
———————————————
A ⊢ d a : ϕ
```

**解释**：

- **Object 规则**：在类体类型化后，只需检查 `self` 的类型与类的方法类型兼容。
- **Class-Var 规则**：用于类变量的类型化，将类类型中的类型变量替换为具体的类型。
- **Class-Fun 规则**：用于类抽象，类似于核心 ML 中的函数抽象。
- **Class-App 规则**：用于类应用，类似于核心 ML 中的函数应用。
### **表达式的额外类型规则（图 3.5）**

```plaintext
Class
A ⊢ d : ϕ     A, z : ∀(ftv(ϕ) \ ftv(A)). ϕ ⊢ a : τ
——————————————————————————————
A ⊢ class z = d in a : τ

New
A ⊢ d : ζ(τ)(F; M)     τ = ⟨M; 0⟩
———————————————————
A ⊢ new d : τ
```

**解释**：

- **Class 规则**：类绑定 `class z = d in a` 类似于 `let` 绑定。类 `d` 的类型被泛化并赋给类名 `z`，然后在类型环境中用于类型化表达式 `a`。
- **New 规则**：对象的创建通过将 `self` 的类型约束为类的方法的确切类型来类型化。**区别**：在 Object 规则中，`self` 的类型可能包含尚未在类体中定义的方法。这些方法在 OCaml 中将被标记为虚方法。**虚类**：如果类包含未定义的方法，则类本身将是虚的，禁止创建任何实例。在这种情况下，New 规则的右前提将失败。**New 规则的作用**：确保所有递归使用的方法（即在当前 `self` 类型中绑定的）也被定义。
### **可变字段**

**可变字段的扩展与面向对象的方面基本上是正交的**。

- **可以使用类似于第 2.2 节中的带有存储的操作语义**。
**方法类型的变化**：

- **方法类型应该能够看到每个字段的赋值原语（u ←）**。
- **因此，Method 类型规则可以更改为**：
```plaintext
Method
A ⊢ B : ζ(τ)(F; M)     A, x : τ, F, F← ⊢ a : τ'
——————————————————————————————————
A ⊢ (B, m = ς(x) a) : ζ(τ)(F; M ⊕ m : τ')
```
**其中**，F← 表示 {(u ← : F(u) → unit) | u ∈ dom(F)}。
**对象创建的处理**：

- 由于对象的创建现在可以扩展存储，`New` 规则应被视为应用，即防止类型泛化。
- 而对于应用对象（applicative objects），它可以被视为非扩张表达式，允许泛化。
### **重写（Overriding）**

- **重写**：与赋值相反，重写创建一个新的对象副本，其中一些字段的值已被更改。
- **性质**：这是一个原子操作，因此重写操作应该接受一个字段-值对的列表，每个字段都被更新为新的值。
- **形式化**：假设有一组原语 {⟨u1 = ; ... ; un = ⟩}，对于所有 n ∈ ℕ，以及所有大小为 n 的字段集 {u1, ..., un}。
- **在方法体中的可见性**：与赋值一样，规则方法应该通过扩展 **图 3.3** 中的 Method 规则的类型环境，使这些原语在方法体中可见。
- **使用辅助记号**：`{⟨u1 : τ1; ... un : τn⟩}τ` 表示类型假设：
```plaintext
({⟨u1 = ; ... un = ⟩ : τ1 → ... τn → τ})
```
`F ? τ` 表示类型环境：
```plaintext
⋃_{F' ⊆ F} {⟨F'⟩}τ
```
- **新的 Method 规则**：
```plaintext
Method
A ⊢ B : ζ(τ)(F; M)     A, x : τ, F, F ? τ ⊢ a : τ'
——————————————————————————————————
A ⊢ (B, m = ς(x) a) : ζ(τ)(F; M ⊕ m : τ')
```
### **子类型**

**显式使用的子类型不会给类型推断带来任何问题**。

- **子类型转换**可以被类型化为原语的应用。
- **假设**：存在一组原语 `( : τ1 :&gt; τ2)`，具有相应的类型方案 `∀α. τ1 → τ2`，对于所有满足 `τ1 ≤ τ2` 的类型对。**注意**：这里使用的类型 τ1 和 τ2 是给定的，而不是推断的。
**子类型关系 ≤**：

- **性质**：是标准的。
- **特性**：**结构化的**。**对象类型上协变**。**在箭头右侧协变**，在箭头左侧逆变。**对其他类型构造器非变**。
- **形式化定义**：关系 ≤ 可以定义为在正规树上的最大传递关系，满足 **图 3.6** 的闭包和一致性规则。
#### **图 3.6：子类型的闭包和一致性规则**

```plaintext
闭包规则

(1) τ1 → τ2 ≤ τ1' → τ2' ⇒ τ1' ≤ τ1 且 τ2 ≤ τ2'

(2) ⟨τ⟩ ≤ ⟨τ'⟩ ⇒ τ ≤ τ'

(3) (m : τ1; τ2) ≤ (m : τ1'; τ2') ⇒ τ1 ≤ τ1' 且 τ2 ≤ τ2'

一致性规则

(4) τ ≤ τ1 → τ2 ⇒ τ 的形状为 τ1' → τ2'

(5) τ ≤ ⟨τ0⟩ ⇒ τ 的形状为 ⟨τ0'⟩

(6) τ ≤ (m : τ1; τ2) ⇒ τ 的形状为 (m : τ1'; τ2')

(7) τ ≤ Abs ⇒ τ = Abs

(8) τ ≤ α ⇒ τ = α
```

### **子类型与继承的区别**

- **子类型**和**继承**不应混淆。
- **区别**：**两个关系定义在不同的元素集上**：**继承**：关联类。**子类型**：关联对象类型（甚至不是类类型）。**没有明显的对应关系**。**一方面**，如二元方法的示例所示，如果两个类有继承关系，那么它们各自类的对象的类型不一定有子类型关系。**另一方面**，独立实现的两个类没有继承关系；然而，如果它们实现了相同的接口（例如，如果它们是相同的），那么这些类的对象类型将是相等的，因此存在子类型关系。（这两个类将为相同的类型定义两个不同的缩略。）
- **示例**：
```ocaml
class c1 = object end
class c2 = object end;;

fun x -&gt; (x : c1 :&gt; c2);;
```
我们有 c1 ≤ c2，但 c1 没有继承自 c2。
#### **练习 29：对象的类型推断**

**项目**：扩展给定的核心演算的小型类型检查器，以包含对象和类。

**总结**

在本段内容中，我们深入探讨了 OCaml 中对象层的核心概念，特别是对象和类的形式化及其类型检查。首先，我们讨论了对象类型的定义和特点，强调了结构化对象类型和行变量的重要性，以及它们在实现多态性方面的作用。我们了解了如何使用行变量和匿名行变量来简化对象类型的表示，以及如何在类型推断中处理对象类型的统一问题。

接着，我们探讨了递归类型在对象类型中的应用，了解了递归类型的重要性和如何在存在对象类型的情况下处理递归类型的统一。我们还讨论了类型共享的概念，了解了如何表示递归类型，以及类型共享在保持类型简洁和可读性方面的作用。

然后，我们讨论了类型缩略的作用，了解了类型缩略如何使对象类型的表示更简短和可读，以及类型缩略的透明性如何影响类型推断过程。

在类的类型检查部分，我们讨论了类类型的定义，了解了类类型是如何由 self 类型、字段列表和方法列表组成的。我们探讨了类体的类型化规则，详细解释了每个规则的含义和应用。我们还讨论了可变字段和重写的类型检查，了解了如何在类型系统中处理这些特性。

最后，我们讨论了子类型的概念，了解了子类型关系的定义和性质，以及它与继承的区别。我们强调了子类型与继承之间没有直接的对应关系，并通过示例说明了这一点。

通过本段内容的学习，我们对 OCaml 中对象和类的形式化有了深入的理解，了解了对象类型和类类型的定义、类型检查规则，以及类型推断中涉及的复杂问题。这为我们在实际编程中正确使用 OCaml 的对象系统，以及在理论上理解编程语言的设计和类型系统的形式化奠定了坚实的基础。
  



**概览**

本段内容介绍了 **OCaml** 中对象的高级用法，特别是通过一个大型、现实的示例来展示对象和类的许多方面，以及 OCaml 的表达能力。这个示例主要围绕 **窗口管理器（window managers）** 的模块化实现，深入探讨了 **观察者模式（Observer Pattern）**，并展示了如何在 OCaml 中实现和扩展这一设计模式。此外，内容还讨论了组件继承、二元方法，以及如何在面向对象的组件中实现安全和灵活的交互。最后，提供了进一步阅读的参考资料，供读者深入了解相关主题。

## **3.3 对象的高级用法**

### **引言**

本节通过一个大型且现实的示例来展示 OCaml 中对象和类的高级用法。这个示例不仅展示了 OCaml 的强大表达能力，还涵盖了对象和类的许多重要特性。示例的主题是 **窗口管理器的模块化实现**，我们将通过它来探索 **观察者模式（Observer Pattern）** 的实现和应用。

### **窗口管理器与观察者模式**

#### **窗口管理器的任务**

- **选择要执行的操作**：例如移动或重新显示窗口，是管理器的任务。
- **执行操作**：执行这些操作是窗口的任务。
#### **观察者模式的引入**

- **通用化示例**：我们将这个窗口管理器的示例推广为一种称为 **观察者模式** 的设计模式。
- **观察者模式的挑战**：这一设计模式在实现中具有一定的挑战性（参考文献 [10]）。
- **观察者和主题（被观察者）之间的关系**：**观察者（Observers）**：从主题（Subjects）接收信息，并向它们请求操作。**主题（Subjects）**：执行请求的操作，并将任何有用的信息传达给观察者。
#### **信任协议的选择**

- **协议设计**：我们选择了一个基于信任的协议，其中 **主题请求被观察**。
- **管理观察者列表**：因此，主题可以自行管理其观察者列表。
- **反向选择的可能性**：这种选择实际上可以反过来，以一种更有权威性的协议，其中 **观察者（作为主控者）管理其主题列表**。
### **实现观察者模式**

#### **类的实现**

- **实现两个类**：建模主题和观察者的两个类。**subject 类**：管理观察者列表，必须按 **观察者对象的类型 'observer** 进行参数化。**observer 类**：作为观察者的模板，不提供任何特定的服务。
#### **subject 类的详细实现**

```ocaml
class ['observer] subject =
object (self : 'mytype)
  val mutable observers : 'observer list = []
  method add obs = observers &lt;- obs :: observers
  method notify (message : 'observer -&gt; 'mytype -&gt; unit) =
    List.iter (fun obs -&gt; message obs self) observers
end;;
```

##### **解释**：

- **类型参数化**：['observer]，subject 类被参数化，'observer 是观察者的类型。
- **self 类型**：(self : 'mytype)，将 self 的类型定义为 'mytype，以便在类中引用自身时可以精确地使用类型。
- **实例变量**：val mutable observers : 'observer list = []：可变字段，存储观察者列表，初始为空列表。
- **方法**：method add obs：将观察者 obs 添加到观察者列表中。observers &lt;- obs :: observers：将新的观察者添加到列表的头部。method notify (message : 'observer -&gt; 'mytype -&gt; unit)：**参数**：message 是一个函数，接受一个 'observer 类型的观察者和 self，返回 unit。**功能**：对每个观察者调用 message 函数，将观察者和 self 作为参数。List.iter (fun obs -&gt; message obs self) observers：遍历观察者列表，应用 message 函数。
##### **设计理念**：

- **信息表示**：信息被表示为一个以观察者为参数的过程，这个过程会调用观察者的适当方法。
- **隐藏消息细节**：消息的名称和参数被隐藏在过程的闭包中。
- **消息的参数化**：消息也被参数化为发送者（一个主题），notify 方法在广播消息之前将消息应用于其发送者，以便接收者可以回调发送者请求新的操作。
#### **observer 类的实现**

```ocaml
class ['subject] observer = object end;;
```

- **解释**：observer 类是一个空类，不提供任何特定的服务。
- **类型参数化**：['subject]，observer 类被参数化，'subject 是主题的类型。
- **用途**：作为观察者的模板，在具体应用中将被扩展。
### **将模式应用于具体案例**

为了将一般模式适用于具体案例，需要同时扩展 `subject` 类和 `observer` 类，以实现观察者可以调用的操作和主题可以发送的信息。

#### **示例：窗口和管理器**

- **window 类**：作为 subject 类的一个实例，实现了一个 move 方法，并通过调用观察者的 moved 方法来通知所有观察者其移动。
- **manager 类**：继承自 observer 类，实现了一个 moved 方法，以接收和处理窗口发送的相应通知消息。
##### **window 类的实现**

```ocaml
class ['observer] window =
object (self : 'mytype)
  inherit ['observer] subject
  val mutable position = 0
  method move d =
    position &lt;- position + d; self#notify (fun x -&gt; x#moved)
  method draw = Printf.printf "[Position = %d]" position;
end;;
```

###### **解释**：

- **继承**：inherit ['observer] subject，window 类继承自 subject 类。
- **实例变量**：val mutable position = 0：可变字段，表示窗口的位置，初始为 0。
- **方法**：method move d：**参数**：d，移动的距离。**功能**：position &lt;- position + d：更新窗口的位置。self#notify (fun x -&gt; x#moved)：通知所有观察者，调用它们的 moved 方法。method draw：绘制窗口，打印当前位置。Printf.printf "[Position = %d]" position：输出当前位置。
##### **manager 类的实现**

```ocaml
class ['subject] manager =
object
  inherit ['subject] observer
  method moved (s : 'subject) : unit = s#draw
end;;
```

###### **解释**：

- **继承**：inherit ['subject] observer，manager 类继承自 observer 类。
- **方法**：method moved (s : 'subject) : unit：**参数**：s，主题对象。**功能**：调用主题的 draw 方法，即当接收到移动通知时，要求窗口重新绘制。s#draw：调用主题的 draw 方法。
#### **创建并测试实例**

```ocaml
let w = new window in w#add (new manager); w#move 1;;
```

- **解释**：let w = new window：创建一个新的 window 对象 w。w#add (new manager)：将一个新的 manager 对象添加为 w 的观察者。w#move 1：移动窗口 w，距离为 1。
- **结果**：当 w 移动时，manager 的 moved 方法被调用，manager 调用 w 的 draw 方法，输出当前位置。
#### **注意事项**

- **类型安全性**：这个模式的一个实例是良类型的，因为 manager 正确地处理了发送给 window 类对象的所有消息。
- **错误示例**：如果我们忘记在 manager 类中实现 moved 方法，上述代码将无法正常工作，因为 manager 无法响应 moved 消息。
### **模式的模块化与扩展**

#### **扩展：窗口大小调整**

- **进一步精炼**：窗口管理器模式可以进一步精炼，以便在窗口大小调整时通知观察者。
- **实现方法**：**在 window 类中添加 resize 方法**：通知观察者窗口已调整大小。**在 manager 类中添加 resized 方法**：处理来自窗口的大小调整通知。
##### **large_window 类的实现**

```ocaml
class ['observer] large_window =
object (self)
  inherit ['observer] window as super
  val mutable size = 1
  method resize x =
    size &lt;- size + x; self#notify (fun x -&gt; x#resized)
  method draw = super#draw; Printf.printf "[Size = %d]" size;
end;;
```

###### **解释**：

- **继承**：inherit ['observer] window as super，large_window 类继承自 window 类，并将父类命名为 super。
- **实例变量**：val mutable size = 1：可变字段，表示窗口的大小，初始为 1。
- **方法**：method resize x：**参数**：x，调整的大小增量。**功能**：size &lt;- size + x：更新窗口的大小。self#notify (fun x -&gt; x#resized)：通知所有观察者，调用它们的 resized 方法。method draw：**功能**：调用父类的 draw 方法，输出当前位置，然后输出当前大小。super#draw：调用父类的 draw 方法。Printf.printf "[Size = %d]" size：输出当前大小。
##### **big_manager 类的实现**

```ocaml
class ['subject] big_manager =
object
  inherit ['subject] manager as super
  method resized (s:'subject) = s#draw
end;;
```

###### **解释**：

- **继承**：inherit ['subject] manager as super，big_manager 类继承自 manager 类，并将父类命名为 super。
- **方法**：method resized (s:'subject)：**参数**：s，主题对象。**功能**：调用主题的 draw 方法，即当接收到大小调整通知时，要求窗口重新绘制。s#draw：调用主题的 draw 方法。
#### **添加新的观察者类型**

- **灵活性**：该模式非常灵活，可以添加其他类型的观察者。
- **示例**：添加一个用于监视主题的观察者 spy。
##### **spy 类的实现**

```ocaml
class ['subject] spy =
object
  inherit ['subject] observer
  method resized (s:'subject) = print_string ""
  method moved (s:'subject) = print_string ""
end;;
```

###### **解释**：

- **继承**：inherit ['subject] observer，spy 类继承自 observer 类。
- **方法**：method resized (s:'subject)：**功能**：当接收到大小调整通知时，输出 &lt;R&gt;。print_string "&lt;R&gt;"。method moved (s:'subject)：**功能**：当接收到移动通知时，输出 &lt;M&gt;。print_string "&lt;M&gt;"。
#### **测试示例**

```ocaml
let w = new large_window in
  w#add (new big_manager); w#add (new spy);
  w#resize 2; w#move 1;;
```

- **解释**：创建一个新的 large_window 对象 w。将一个新的 big_manager 对象添加为 w 的观察者。将一个新的 spy 对象添加为 w 的观察者。调用 w#resize 2，将窗口大小增加 2。调用 w#move 1，将窗口位置移动 1。
- **输出结果**：
```plaintext
[Position = 0][Size = 3][Position = 1][Size = 3]- : unit = ()
```

- **解释**：&lt;R&gt;：spy 对象在接收到大小调整通知时输出。[Position = 0][Size = 3]：big_manager 对象调用 w 的 draw 方法，输出当前位置和大小。&lt;M&gt;：spy 对象在接收到移动通知时输出。[Position = 1][Size = 3]：big_manager 对象调用 w 的 draw 方法，输出更新后的位置和大小。
### **练习 30：项目——小部件工具包**

**任务**：

- **实现一个小部件（widget）工具包**，从头开始，即使用 Graphics 库。
- **目标**：从矩形区域作为基本小部件开始，可以派生出容器、文本区域、按钮、菜单等对象。继续添加滚动条、滚动矩形等。
- **设计要求**：**多方向的模块化**：库的设计应考虑多方向的模块化。**代码共享**：小部件应尽可能地从彼此派生，以确保代码共享。**可定制性**：用户应该能够定制库中的小部件。**可扩展性**：专家应能够扩展库。
- **附加要求**：**工具包的使用示例**：除了工具包的实现，项目还可以在示例中展示工具包本身的使用。
### **组件继承与二元方法**

#### **组件继承的介绍**

- **观察者模式是组件继承的一个示例**。
- **简单的面向对象编程**：**继承**：与单个类相关。**示例**：图 3.7 描绘了一个常见但高级的情况，其中同一 worker 类的多个对象紧密交互，例如通过二元方法。
#### **图 3.7：传统继承**

- **结构**：worker 类。slave 类继承自 worker。w1 和 w2：worker 类的对象。bw 和 bw'：slave 类的对象。
- **交互**：对象之间通过二元方法进行交互。在继承的 slave 类中，通信模式可以通过在同类对象之间建立更多连接来丰富。
#### **模式的泛化**

- **在面向对象的组件中**，这种模式经常被使用。
- **复杂的交互**：这种紧密连接涉及多个相关但不同的类的对象。**示例**：图 3.8 中，worker 类的对象与 manager 类的对象交互。
- **继承的挑战**：**允许组件的继承**，使得子类的对象可以有更丰富的通信模式，同时仍然能够安全地交互，这是一个常见的难题。**在示例中**：一方面是 slave 类的对象。另一方面是 boss 或 spy 类的对象。它们通过更丰富的接口进行交互。
#### **图 3.8：组件继承**

- **结构**：worker 类。slave 类继承自 worker。manager 类。boss 和 spy 类继承自 manager。w1 和 w2：worker 类的对象。bw：slave 类的对象。m：manager 类的对象。bm：boss 类的对象。sm：spy 类的对象。
#### **观察者模式的实例**

- **观察者模式**确实是这一通用模式的一个实例。
- **成功的类型化**：如上所示，它可以成功地进行类型化。
- **保留的灵活性**：所有预期的灵活性都得以保留，特别是子组件中通信协议的精炼。
#### **关键要素**

- **结构化开放对象类型**：与二元方法一样，这一通用模式的关键要素是使用 **结构化开放对象类型** 及其在子类中的参数化处理。
- **self 类型的抽象**：在每个类中，不仅当前类的 self 类型，而且模式中递归涉及的其他类的 self 类型也被抽象化。
### **进一步阅读**

- **OCaml 中对象和类的引入**：最初在语言 ML-ART [64] 中进行了实验——一种带有抽象类型和记录类型的 ML 扩展，其中对象不是原生的，而是通过编程实现的。尽管 OCaml 中有一些为了简化而施加的限制，以及相反的一些扩展，ML-ART 仍然可以被视为 OCaml 面向对象特性的内省。
- **深入的介绍**：读者可以参考 [66, 72]，获取更详细（且更技术性）的介绍。
- **其他实验**：**Moby [20]**：另一个值得一提的对象实验语言，尽管类型不再被推断，但它具有一些 ML 的风格。**类的集成**：类更紧密地集成到模块系统中，包括一个视图机制 [68]。
- **二元方法的问题**：**简短的综述**：参考 [9]。
- **观察者模式及其解决方案**：在 [10] 中也有描述。
- **其他相关工作**：当然，还有许多不考虑类型推断的工作。**参考书**：一本良好但技术性的参考书是 [1]。
**总结**

本段内容深入探讨了 OCaml 中对象的高级用法，通过一个大型且现实的示例展示了对象和类的多种特性，以及 OCaml 的强大表达能力。示例以 **窗口管理器的模块化实现** 为主题，深入探讨了 **观察者模式（Observer Pattern）** 的实现、扩展和应用。

我们首先了解了观察者模式的基本概念，以及如何在 OCaml 中通过参数化的 `subject` 和 `observer` 类来实现这一模式。详细分析了类的实现，包括如何管理观察者列表，如何通知观察者，以及如何在具体应用中扩展这些类来实现特定的功能。

接着，我们通过将模式应用于窗口和管理器的示例，展示了如何在实际中使用观察者模式。我们讨论了如何扩展模式来添加新的功能，如窗口大小调整，以及如何添加新的观察者类型，如 `spy`。

此外，内容还讨论了组件继承的概念，探讨了在面向对象的组件中实现复杂的交互模式的挑战和解决方案。我们了解了二元方法在这种模式中的作用，以及如何使用结构化开放对象类型和 self 类型的参数化处理来实现安全和灵活的交互。

最后，提供了进一步阅读的参考资料，包括对 OCaml 中对象和类的深入介绍，以及相关的研究和参考书。

通过本段内容的学习，我们对 OCaml 中对象的高级用法有了深入的理解，了解了如何利用观察者模式和组件继承来构建灵活、可扩展和模块化的应用程序。我们也认识到类型系统在实现这些高级特性中的重要作用，以及如何在类型安全的前提下实现复杂的对象交互。这为我们在实践中应用这些概念，以及在理论上深入理解面向对象编程和类型系统奠定了坚实的基础。
  



**概览**

本章介绍了 **OCaml** 中的模块语言，它是一个强大的模块系统，灵感来自于 Standard ML 的模块系统。模块在大型程序中发挥着重要作用，它们通过允许将程序分割成可独立编译的部分，使大型程序可编译、易于理解、可维护和可重用。此外，通过强制抽象，模块通常使程序更安全。

本章将首先介绍模块的基本使用，包括模块的定义、引用和签名。接下来，将探讨参数化模块，即函子的概念，以及如何定义和应用函子。然后，我们将简要提及模块的形式化和实现方面的内容。最后，通过一个银行的示例，深入展示了模块的高级用法，包括模块的不同视图、类型约束和模块化的优势。

## **第 4 章 模块语言**

### **4.1 使用模块**

**模块系统的独特性**

- **OCaml 的模块系统**：是一个功能强大的模块系统，独立于类（classes）。受到 Standard ML 模块系统的启发。具有一个小型的、带类型的函数式语言，位于基础语言之上。可以参数化基础语言，不一定是 ML，这意味着它可以为其他基础语言提供模块语言。
**模块的优势**

- **使大型程序可编译**：通过允许将程序分割成可独立编译的部分。
- **使大型程序易于理解**：通过为程序添加结构。
- **鼓励或强制指定程序组件之间的链接（接口）**：使大型程序可维护和可重用。
- **通过强制抽象**：通常使程序更安全。
#### **4.1.1 基本模块**

**模块的定义**

- **结构（structures）**：基本模块是结构，即短语的集合，写作 struct p1 ... pn end。短语（phrases）是核心语言的短语，加上子模块的定义 module X = M 和模块类型的定义 module type T = S。
**示例：栈的实现**

```ocaml
module Stack =
struct
  type 'a t = {mutable elements : 'a list }
  let create () = { elements = [] }
  let push x s = s.elements &lt;- x :: s.elements
  let pop s =
    match s.elements with
      h::t -&gt; s.elements &lt;- t; h
    | [] -&gt; failwith "Empty stack"
end;;
```

- **解释**：定义了一个模块 Stack，包含了栈的类型和基本操作。type 'a t：定义了一个多态类型 'a t，表示元素类型为 'a 的栈。使用记录 {mutable elements : 'a list }，包含一个可变字段 elements，是一个 'a 类型的列表。let create ()：创建一个空栈。let push x s：将元素 x 压入栈 s。let pop s：弹出栈顶元素，如果栈为空，则抛出异常。
**引用模块的组件**

- **点表示法（dot notation）**：使用 ModuleName.component 的形式引用模块的组件。
- **示例**：
```ocaml
let s = Stack.create () in Stack.push 1 s; Stack.push 2 s; Stack.pop s;;
```
**结果**：
```ocaml
- : int = 2
```
**打开模块**

- **open 指令**：使用 open ModuleName 可以打开一个模块，使得在模块内部可以直接引用其组件，而无需每次都加上模块名和点。
- **示例**：
```ocaml
open Stack;;
let s = create ();;
push 1 s;;
```
**嵌套模块**

- **模块可以是另一个模块的子组件**：
```ocaml
module T =
struct
  module R = struct let x = 0 end
  let y = R.x + 1
end
```
- **点表示法和 open 可以用于子模块**。
- **注意**：在模块 Q 中使用 open T.R，会使 T.R 的所有组件对模块 Q 的其余部分可见，但不会将这些组件添加到模块 Q 中。
**模块的签名**

- **类型推断**：系统会推断模块的签名，就像它推断值的类型一样。
- **签名（signatures）**：基本模块的类型，称为签名，是（类型）规范的序列，写作 `sig s1 ... sn end`。**规范的不同形式**（见 **图 4.1**）：值：val x : σ抽象类型：type t具体类型（显式定义）：type t = τ异常：exception E类：class z : object ... end子模块：module X : S模块类型：module type T [= M]**图 4.1：规范**规范形式描述值val x : σ抽象类型type t具体类型（显式定义）type t = τ异常exception E类class z : object ... end子模块module X : S模块类型module type T [ = M]
- **示例**：系统对 `Stack` 示例的签名推断：
```ocaml
module Stack :
sig
  type 'a t = { mutable elements : 'a list; }
  val create : unit -&gt; 'a t
  val push : 'a -&gt; 'a t -&gt; unit
  val pop : 'a t -&gt; 'a
end
```
**显式的签名约束**

- **用途**：可以使用显式的签名约束来限制系统推断的签名，就像类型约束限制对表达式推断的类型一样。
- **语法**：签名约束写作 (M : S)，其中 M 是一个模块，S 是一个签名。还有语法糖 module X : S = M，表示 module X = (M : S)。
- **作用**：签名约束有两方面的作用：**检查结构是否符合签名**：即，签名 S 中指定的所有组件必须在模块 M 中定义，且它们的类型至少同样一般（即模块的实现必须满足接口的要求）。**使 M 中不在 S 中的组件不可访问**：即，隐藏未在签名中指定的模块内部的组件。
- **示例**：
```ocaml
module S : sig type t val y : t end =
struct type t = int let x = 1 let y = x + 1 end
```
**解释**：模块 S 的签名只暴露了类型 t 和值 y，隐藏了 x。因此，S.x 和 S.y + 1 都会产生错误。S.x：x 对外不可见。S.y + 1：S.y 的类型是抽象的 S.t，无法与 int 类型兼容。
**强制类型抽象**

- **用途**：签名约束常用于强制类型抽象。例如，上述的 `Stack` 模块暴露了其表示（representation），这允许直接创建栈，而无需调用 `Stack.create`。
```ocaml
Stack.pop { Stack.elements = [2; 3] };;
```
**问题**：如果栈的实现假定了某些不适用于任意表示类型元素的不变量，这种直接访问会导致混乱。
- **解决方案**：通过使栈的实现抽象化，强制创建栈时使用专门提供的 Stack.create 函数。
```ocaml
module Astack :
sig
  type 'a t
  val create : unit -&gt; 'a t
  val push : 'a -&gt; 'a t -&gt; unit
  val pop : 'a t -&gt; 'a
end = Stack;;
```
**解释**：在签名中，type 'a t 是抽象的，隐藏了其具体实现。现在，无法直接构造栈，只能通过 create 函数。
**创建同构但不兼容的结构**

- **应用场景**：类型抽象也可用于生成同构但不兼容的同一结构的不同视图。**示例**：所有货币都由浮点数表示，但不同的货币（如欧元和美元）显然不等价，不应混合使用。
- **实现方法**：将货币建模为签名约束下的不兼容结构。
- **代码示例**：
```ocaml
module Float =
struct
  type t = float
  let unit = 1.0
  let plus = (+.)
  let prod = ( *. )
end;;

module type CURRENCY =
sig
  type t
  val unit : t
  val plus : t -&gt; t -&gt; t
  val prod : float -&gt; t -&gt; t
end;;

module Euro = (Float : CURRENCY);;
module Dollar = (Float : CURRENCY);;
```
**解释**：在 Float 中，类型 t 是具体的，可以用作 float。通过签名约束，将 Float 的签名限制为 CURRENCY，使得 Euro.t 和 Dollar.t 都是抽象的。因此，Euro.t 和 Dollar.t 是不兼容的，即使它们实际上都表示 float。
- **使用示例**：
```ocaml
let euro x = Euro.prod x Euro.unit;;
Euro.plus (euro 10.0) (euro 20.0);;
Euro.plus (euro 50.0) Dollar.unit;;  (* 这将导致类型错误 *)
```
**解释**：不能将 Euro.t 与 Dollar.t 混合使用，类型系统会检测并防止这种错误。
- **注意**：这里没有代码的重复（代码复用），Euro 和 Dollar 都是对同一个 Float 模块的不同视图。
**提供模块的多种视图**

- **场景**：可以为同一模块提供多种限制的接口，以便在给定的上下文中限制某些操作（例如，禁止创建新的值）。
- **示例**：
```ocaml
module type PLUS =
sig
  type t
  val plus : t -&gt; t -&gt; t
end;;

module Plus = (Euro : PLUS);;
```
**解释**：Plus 模块的类型 t 是不兼容的，与 Euro.t 不兼容，因为 t 是抽象的。
- **部分抽象的类型****使用 with 语法**：`with` 允许在已定义的签名中添加类型等式。表达式 `PLUS with type t = Euro.t` 是以下签名的简写：
```ocaml
sig
  type t = Euro.t
  val plus: t -&gt; t -&gt; t
end
```
**示例**：
```ocaml
module Plus = (Euro : PLUS with type t = Euro.t);;
Plus.plus Euro.unit Euro.unit;;
```
**解释**：现在，Plus.t 与 Euro.t 兼容，可以使用 Euro 中创建的值。
**独立编译**

- **用途**：模块也用于促进独立编译（Separate Compilation）。
- **实现方式**：通过将顶层模块及其签名与文件匹配。
- **编译单元**：一个编译单元 A 由两个文件组成：**实现文件 a.ml**：是一系列短语，就像在 struct ... end 中的短语。**接口文件 a.mli（可选）**：是一系列规范，就像在 sig ... end 中的规范。
- **访问方式**：另一个编译单元 B 可以将 A 作为一个结构来访问，使用点表示法 A.x 或指令 open A。
- **示例**：假设源文件有：`a.ml`、`a.mli`、`b.ml`。编译步骤：命令编译内容生成文件ocamlc -c a.mli编译 A 的接口a.cmiocamlc -c a.ml编译 A 的实现a.cmoocamlc -c b.ml编译 B 的实现b.cmoocamlc -o myprog a.cmo b.cmo链接生成可执行文件myprog**程序的行为**：等价于以下单一代码：
```ocaml
module A : sig (∗ content of a.mli ∗) end =
  struct (∗ content of a.ml ∗) end
module B = struct (∗ content of b.ml ∗) end
```
**注意**：模块定义的顺序对应于链接命令行中 .cmo 对象文件的顺序。
#### **4.1.2 参数化模块**

**函子（Functor）**

- **定义**：函子是从模块到模块的函数，写作 functor (S : T) -&gt; M。函子体 M 显式地以模块参数 S 为参数，S 的签名为 T。在函子体中，可以使用点表示法访问 S 的组件。
- **示例**：
```ocaml
module M = functor (X : T) -&gt;
struct
  type u = X.t * X.t
  let y = X.g (X.x)
end
```
- **解释**：定义了一个函子 M，它接受一个模块参数 X，其签名为 T。在 M 中，定义了类型 u 和值 y，使用了 X 的组件。
- **应用函子**：
```ocaml
module T1 = M (S1)
module T2 = M (S2)
```
**解释**：需要将函子 M 显式地应用于符合签名 T 的实现模块 S1 和 S2。然后，模块 T1 和 T2 可以像常规结构一样使用。
- **注意**：与函数一样，不可能直接访问 M 的体，必须先将其应用于一个模块参数。
- **代码共享**：T1 和 T2 完全共享它们的代码。
### **4.2 理解模块**

这一节提到了模块的形式化方面，引用了相关文献：

- 参考文献：[27]、[44]、[45]、[69]：有关模块形式化的更多信息。[46]：有关实现方面的信息。
### **4.3 模块的高级用法**

这一节通过一个银行的示例，展示了模块的高级特性，并将它们结合在一起。

#### **示例：银行账户的模块化实现**

**场景**

- **关注点**：银行账户的创建和使用方式，尤其是银行和客户如何（或不能）创建和使用账户。
- **安全目的**：客户和银行显然应该对账户有不同的访问权限。
- **建模方法**：为客户和银行提供账户的不同视图，以模拟不同的访问权限。
**定义客户和银行的接口**

```ocaml
module type CLIENT = (* client’s view *)
sig
  type t
  type currency
  val deposit : t -&gt; currency -&gt; currency
  val retrieve : t -&gt; currency -&gt; currency
end;;

module type BANK = (* banker’s view *)
sig
  include CLIENT
  val create : unit -&gt; t
end;;
```

- **解释**：**CLIENT 模块类型**：类型 t：表示账户类型，对客户而言是抽象的。类型 currency：货币类型。val deposit：存款函数。val retrieve：取款函数。**BANK 模块类型**：包含了 CLIENT 的所有内容。额外添加了 val create：账户创建函数。
**初始模型：银行将账户簿交给客户**

- **实现**：
```ocaml
module Old_Bank (M : CURRENCY) :
BANK with type currency = M.t =
struct
  type currency = M.t
  type t = { mutable balance : currency }
  let zero = M.prod 0.0 M.unit and neg = M.prod (-1.0)
  let create () = { balance = zero }
  let deposit c x =
    if x &gt; zero then c.balance &lt;- M.plus c.balance x; c.balance
  let retrieve c x =
    if c.balance &gt; x then deposit c (neg x) else c.balance
end;;
```
**解释**：Old_Bank 是一个函子，接受一个 CURRENCY 模块 M 作为参数。**类型定义**：type currency = M.t：货币类型。type t = { mutable balance : currency }：账户类型，包含一个可变的余额字段。**函数**：create：创建一个新账户。deposit：存款函数，更新账户余额。retrieve：取款函数，如果余额足够，则从账户中扣除相应金额。
- **客户视图**：
```ocaml
module Post = Old_Bank (Euro);;
module Client :
CLIENT with type currency = Post.currency and type t = Post.t
= Post;;
```
**解释**：使用 Euro 货币创建一个银行 Post。定义 Client 模块，使其视图与 Post 相同，但只暴露 CLIENT 接口。
- **问题**：这个模型是脆弱的，因为所有信息都在账户本身。如果客户丢失了他的账户，他也会丢失他的资金，因为银行不保留任何记录。此外，安全性依赖于类型抽象的不可破坏性。
**模块化的好处**

- **不同的视图**：客户和银行对银行账户有不同的视图。结果是：银行可以创建账户，客户可以存款。客户不能创建新账户。
- **示例**：
```ocaml
let my_account = Post.create ();;
Post.deposit my_account (euro 100.0);;
Client.deposit my_account (euro 100.0);;
```
**解释**：银行和客户都可以对账户进行存款操作。
- **不同货币的账户**：可以创建不同货币的多个账户，无法混合使用，因为类型系统会检测并防止这种错误。
```ocaml
module Citybank = Old_Bank (Dollar);;
let my_dollar_account = Citybank.create ();;
Citybank.deposit my_account;;               (* 错误：账户类型不匹配 *)
Citybank.deposit my_dollar_account (euro 100.0);;  (* 错误：货币类型不匹配 *)
```
**改进模型：银行维护账户簿，客户只有账户号码**

- **实现**：
```ocaml
module Bank (M : CURRENCY) : BANK with type currency = M.t =
struct
  let zero = M.prod 0.0 M.unit and neg = M.prod (-1.0)
  type t = int
  type currency = M.t
  type account = { number : int; mutable balance : currency }
  (* bank database *)
  let all_accounts = Hashtbl.create 10 and last = ref 0
  let account n = Hashtbl.find all_accounts n
  let create () =
    let n = incr last; !last in
    Hashtbl.add all_accounts n { number = n; balance = zero }; n
  let deposit n x =
    let c = account n in
    if x &gt; zero then c.balance &lt;- M.plus c.balance x; c.balance
  let retrieve n x =
    let c = account n in
    if c.balance &gt; x then (c.balance &lt;- M.plus c.balance x; x)
    else zero
end;;
```
**解释**：type t = int：账户类型现在是一个整数，即账户号码。**银行数据库**：使用 Hashtbl（哈希表）来存储所有账户的信息。all_accounts：哈希表，存储账户编号和账户信息的映射。last：用于生成新的账户编号。**账户操作**：create：创建一个新账户，生成一个新的账户编号，并将其添加到 all_accounts 中。account：根据账户编号查找账户信息。deposit 和 retrieve：根据账户编号操作账户余额。
- **生成多个银行**
```ocaml
module Central_Bank = Bank (Euro);;
module Banque_de_France = Bank (Euro);;
```
**解释**：使用函子应用，可以创建多个银行。由于函数应用的生成性（generativity），它们将拥有独立和私有的数据库。
- **混合使用不同的银行实现**
```ocaml
module Old_post = Old_Bank (Euro);;
module Post = Bank (Euro);;
module Citybank = Bank (Dollar);;
```
**解释**：虽然 Old_Bank 和 Bank 模块有相同的接口，但实现不同。用户可以选择不同的银行模型。
- **注意**：所有银行都有相同的接口，无论它们是如何构建的。用户甚至可能无法观察到不同实现之间的差异，尽管这在一般情况下并非如此。这种属性无法通过类型检查器强制执行。
### **练习 31：一元多项式**

1. **实现一个一元多项式的操作库**。
- **要求**：系数构成一个环（ring），该环作为库的参数提供。
2. **使用该库验证恒等式**：
- 例如，验证 (1 + X)(1 - X) = 1 - X^2。
3. **验证等式 (X + Y)(X - Y) = X^2 - Y^2**：
- 通过将两个变量的多项式视为一元多项式，其中系数是单变量 Y 的多项式环。
4. **编写程序**：
- **功能**：读取命令行中的多项式，并在标准输入中给出的每个点（每行一个整数）进行求值。
- **输出**：将结果打印到标准输出。
**总结**

本章深入介绍了 OCaml 的模块语言，展示了模块系统在大型程序中的重要作用和优势。我们了解了如何定义基本模块，如何引用模块的组件，以及如何使用签名约束来限制模块的接口和实现抽象类型。通过签名约束，我们可以强制类型抽象，创建同构但不兼容的结构，为同一模块提供多种视图，从而在不同的上下文中限制某些操作。

我们还探讨了参数化模块（函子）的概念，了解了如何定义和应用函子，以及函子在模块化编程中的作用。函子允许我们定义从模块到模块的函数，实现模块的参数化和代码复用。

在高级用法部分，通过银行账户的示例，我们展示了如何利用模块的特性来实现不同的访问权限，如何为银行和客户提供不同的视图，以及如何利用函子创建多个独立的银行实例。我们还展示了如何通过模块的接口来隐藏实现细节，从而提高程序的安全性和可维护性。

通过本章的学习，我们深入理解了 OCaml 模块系统的强大功能和灵活性，以及它在大型程序的编写、组织、维护和重用中的关键作用。模块系统不仅提供了强类型的模块化机制，还支持抽象、参数化和多态性，使我们能够编写更加安全、高效和可扩展的代码。
  



**概览**

本章讨论了 **OCaml** 中模块和对象的结合使用。模块和类在程序结构中扮演着不同的角色，模块允许嵌入和参数化类型和值，并支持大规模的值和类型抽象；而类提供继承和晚绑定机制，可以通过值进行参数化，但规模较小。尽管模块和类在代码结构上都提供了组织方式，但它们的编程风格实际上是不同的。本章探讨了模块和类的重叠特性和各自的特殊性，并展示了如何和谐地使用它们。

## **第 5 章 混合使用模块和对象**

### **引言**

模块和类在程序结构中扮演着不同的角色。

- **模块**：可以嵌入，并可以通过类型和值进行参数化。允许大规模的值和类型抽象。
- **类**：提供继承和晚绑定机制。可以通过值进行参数化，但规模较小。
最初看来，它们之间似乎没有太多重叠。然而，为了同时受益于两者的特性，模块和类经常被结合使用。

尽管模块和类都提供了组织代码的手段，但模块化和面向对象的编程风格实际上是不同的。一旦选择用模块或对象来表示结构，许多其他选择就被迫做出，这有时会令人烦恼。

本章讨论了模块和类的重叠特性和各自的特殊性，并展示了如何和谐地使用它们。

### **5.1 重叠**

许多抽象数据类型可以使用类或模块来定义。一个具有代表性的例子是 **栈（stack）** 的类型。在第 3.1.2 节中，栈被定义为一个参数化的类，其中对栈的操作是嵌入到栈对象中的方法；而在第 4.1.1 节中，栈被定义为一个模块，定义了栈的抽象类型及其关联的操作。

#### **实现对比**

下表总结了这两种实现之间的紧密对应关系：

|  | 类版本 | 模块版本 |
| ---- | ---- | ---- |
| 栈的类型 | 'a stack | 'a Astack.t |
| 创建一个栈 | new stack | Astack.create () |
| 将 x 压入栈 s | s#push x | Astack.push x s |
| 从栈 s 弹出 | s#pop | Astack.pop s |

#### **讨论**

更一般地，所有可就地修改的代数抽象类型，并且所有关联的操作都是一元的（即它们只接受一个抽象类型的参数），都可以以几乎相同的方式定义为类或模块。

在这里，选择这两种形式主要是一个编程风格的问题：

- 一些程序员更喜欢将抽象类型的操作视为附加到该类型的值上的方法。
- 另一些程序员更喜欢将它们视为抽象类型的值之外的函数。
此外，当用新操作扩展栈的实现时，这两种选择仍然是可比的。例如，在这两种情况下，都可以从旧的实现派生出新的栈实现，添加一个方法 `top`，在不弹出栈的情况下查看栈顶。

这两种实现都很直接，如 **图 5.1** 所示：

- **类方法**：使用继承。
- **模块方法**：使用 include 构造。
（`include Stack` 的效果是在子结构中重新绑定 Stack 结构的所有组件。）

#### **图 5.1：栈的类版本和模块版本**

**类版本**

```ocaml
class ['a] stack_ext =
object (self)
  inherit ['a] stack
  method top =
    let s = self#pop in
    self#push s; s
end;;
```

**模块版本**

```ocaml
module StackExt =
struct
  include Stack
  let top p =
    let s = pop p in
    push s p; s
end;;
```

然而，当考虑 **晚绑定（late binding）** 时，这两种方法确实有所不同，只有类方法才能实现晚绑定。例如，重新定义 `pop` 的实现将自动受益于 `top` 的实现（即方法 `top` 将调用 `pop` 的新定义）。这个机制在 OCaml 的模块中没有对应的实现。

**结论**：

- 如果需要继承，类方法似乎更合适，如果还需要晚绑定，它成为唯一可能的（直接）解决方案。
- 相反，对于使用二元操作的抽象数据类型（例如具有合并操作的集合），只要不使用继承，模块方法将是更可取的。
- 此外，模块方法是唯一允许以抽象方式向用户返回私有数据的方法，以保持其完整性。
- 当然，模块系统也是 **独立编译** 的基础。
### **5.2 组合模块和类**

为了同时受益于对象和模块的优势，一个应用程序可以轻松地将两者结合起来。

- **典型地**：模块将在外部层次使用，以提供独立编译、内部结构和模块边界之外的隐私。类将是模块的组件，提供可扩展性、开放递归和晚绑定机制。
我们首先展示一些典型的模式示例，随着复杂性和表达能力的增加。最后，我们以一个更复杂但真实的示例结束，它以一种不同寻常但有趣的方式结合了许多特性。

#### **5.2.1 将类作为模块组件**

最简单的例子可能是使用模块简单地将相关的类分组在一起。例如，两个使用上相关的类 `nil` 和 `cons`，可以在一个模块中配对在一起。

**代码示例**：

```ocaml
module Cell = struct
  exception Nil
  class ['a] nil =
  object (self : 'alist)
    method hd : 'a = raise Nil
    method tl : 'alist = raise Nil
    method null = true
  end;;
  class ['a] cons h t =
  object (_ : 'alist)
    val hd = h val tl = t
    method hd : 'a = h
    method tl : 'alist = t
    method null = false
  end;;
end;;
```

**解释**：

- 定义了一个模块 Cell，其中包含两个类 nil 和 cons，它们表示链表的基本构造。
- 类 nil 表示空列表，类 cons 表示非空列表。
除了代码的清晰度之外，这种分组很快就能体现出优势。例如，可以同时扩展 `nil` 和 `cons` 类（但这不是强制的），以形成列表的实现：

**代码示例**：

```ocaml
module List = struct
  class ['a] nil =
  object
    inherit ['a] Cell.nil
    method length = 0
  end;;
  class ['a] cons h t =
  object
    inherit ['a] Cell.cons h t
    method length = 1 + t#length
  end;;
end;;
```

**解释**：

- 定义了一个模块 List，继承自模块 Cell 中的类。
- 在 nil 和 cons 类中分别添加了 length 方法，计算列表的长度。
接下来，可以通过添加一个新的“构造器” `append` 来扩展模块 `List`，这相当于添加了一个具有与前两个类相同接口的新类。

**备注 8**：

- 在 OCaml 中，列表更自然地表示为 **和类型（sum data type）**，此外还允许模式匹配。
- 然而，数据类型是不可扩展的。
在这个例子中，分组可以被视为一种结构上的便利，因为所有类的扁平实现也能很好地工作。然而，对于 **友元类（friend classes）**，分组变得必需。

#### **友元类**

对象中的状态封装允许通过隐藏所有实例变量来抽象它们的表示。因此，可以通过仅提供必要的方法来控制读写能力。然而，是否暴露状态的某个给定部分是一个 **全有或全无（all-or-nothing）** 的选择：要么它被限制在对象内，要么向整个世界公开。

通常情况下，一些但不是全部的对象可以访问彼此的状态。一个典型的例子（但不是唯一的）是具有 **二元方法（binary methods）** 的对象。一个对象的二元方法以同一类的另一个对象作为参数，以便与之交互。在大多数情况下，这种交互应该是紧密的，例如，依赖于它们表示的细节，而不仅仅是它们的外部接口。例如，只允许具有相同实现的对象进行交互。

在对象和类中，两个不同对象之间共享表示的唯一方式是将其暴露给整个世界。

**模块** 提供了一种更细粒度的抽象机制，可以帮助确保这种情况，使表示的类型抽象化。然后，所有在同一模块中定义并共享相同抽象视图的友元（类或函数）都知道具体的表示。

**示例**：

在银行的例子中，将货币转换为一个类来说明这一点：

```ocaml
module type CURRENCY = sig
  type t
  class c : float -&gt;
  object ('a)
    method v : t
    method plus : 'a -&gt; 'a
    method prod : float -&gt; 'a
  end
end;;

module Currency = struct
  type t = float
  class c x =
  object (_ : 'a)
    val v = x method v = v
    method plus (z : 'a) = {&lt; v = v +. z#v &gt;}
    method prod x = {&lt; v = x *. v &gt;}
  end
end;;

module Euro = (Currency : CURRENCY);;
```

**解释**：

- 定义了一个模块类型 CURRENCY，其中包含一个抽象类型 t 和一个类 c。
- 在模块 Currency 中，实现了类型 t 和类 c。
- 使用签名约束，将 Currency 的签名限制为 CURRENCY，从而抽象了类型 t。
然后，所有 `Euro.c` 类的对象都可以组合起来，同时仍然隐藏货币的表示。

**类似的情况**：

- 当实现具有 **并集操作（union operation）** 的集合、具有 **合并操作（merge operation）** 的表等时，也会出现类似的情况。
#### **5.2.2 将类作为预模块**

我们以一个有趣地结合了类对象和模块特性示例来结束本章。这个示例取自形式计算系统 FOC 的代数结构库。

**问题背景**：

- 这样的库的组织提出了重要的问题：一方面，代数结构通常通过连续的精化来描述（例如，群是一个带有额外逆运算的幺半群）。代码结构应该反映这种层次结构，以便至少可以共享结构及其派生结构的公共操作的代码。另一方面，类型抽象对于隐藏结构元素的真实表示至关重要（例如，防止在 p 不等于 q 时混合模 p 和模 q 的整数）。此外，库应该保持可扩展性。
**区分通用结构和具体结构**：

- **通用结构（generic structures）**：是抽象的代数结构，可以用来派生更丰富的结构或实例化为具体的结构，但它们本身不包含元素。
- **具体结构（concrete structures）**：可以用于计算。可以通过为基本操作提供实现，从通用结构获得具体结构。
**示意图（图 5.2）**：

- 箭头表示预期的代码共享。
**图 5.2：代数结构**

```sql
          通用结构
          Semi-Group
              ↓
           Monoid
              ↓
            Group
              ↓
            Ring
          /         \
        +             ×
       /               \
  实现                   实现
Z/2Z impl            ...
          \               /
           具体结构
          Z/2Z ring      ...
```

**两种类型的库客户端**：

- **专家**：能够扩展库，提供新的通用结构，丰富现有的结构，并使其可用于最终用户和其他专家。
- **最终用户**：只需要将一些通用结构实例化为具体结构，并使用它们进行计算。
**初始架构**：

- **第一种架构**：完全依赖于模块。模块促进了类型抽象，但未能在派生结构之间提供代码共享。
- **第二种架构**：将代数结构表示为类，其元素表示为对象。继承促进了代码共享，但该解决方案未能提供类型抽象，因为对象表示必须暴露，主要是对二元操作而言。
**最终架构**：

- 将 **类** 和 **模块** 结合起来，将前者的继承机制与后者的类型抽象结合起来。
- 每个代数结构由一个模块表示，具有一个抽象类型 t，即代数结构元素的表示类型（即其“载体”）。
- 收集所有操作的对象 meth 是通过从参数化为载体类型并定义派生操作的虚类继承而获得的。
**示例**：

对于群（group），虚类 `['a] group` 声明了基本的群操作（`equal`、`zero`、`plus`、`opposite`），并一次性地定义了派生操作（`not_equal`、`minus`）。

**代码示例**：

```ocaml
class virtual ['a] group =
object (self)
  method virtual equal : 'a -&gt; 'a -&gt; bool
  method not_equal x y = not (self#equal x y)
  method virtual zero : 'a
  method virtual plus : 'a -&gt; 'a -&gt; 'a
  method virtual opposite : 'a -&gt; 'a
  method minus x y = self#plus x (self#opposite y)
end;;
```

**解释**：

- 定义了一个虚类 ['a] group，包含了基本的群操作的抽象方法，以及派生操作的具体实现。
- 派生操作只需定义一次，供所有继承的类使用。
**类的重用**：

- 可以用于构建更丰富的通用结构，添加其他操作。
- 或者通过用更高效的实现覆盖一些操作，构建同一结构的专门版本。
- 晚绑定机制在这里被本质地使用。
**注**：

- 在群结构的更模块化版本中，所有方法将是私有的，以便在必要时可以稍后忽略它们。
- 例如，群可以用作幺半群的实现。
- 所有私有方法在具体实例化之前被公开，因此变得完全可见。
**群的模块签名**：

```ocaml
module type GROUP =
sig
  type t
  val meth : t group
end;;
```

**构建具体结构的示例**：

为了获得整数模 p 的群的具体结构，我们在类 `z_pz_impl` 中提供基本方法的实现（并可能提供一些派生操作的专门版本）。

类 `z_pz` 继承自定义派生操作的类 `[int] group` 和定义基本操作的类 `z_pz_impl`。

最后，我们在结构中包含该子类的一个实例，以便将模 p 的整数作为 OCaml 整数的表示隐藏起来。

**代码示例**：

```ocaml
class z_pz_impl p =
object
  method equal (x : int) y = (x = y)
  method zero = 0
  method plus x y = (x + y) mod p
  method opposite x = p - 1 - x
end;;

class z_pz p =
object
  inherit [int] group
  inherit z_pz_impl p
end;;

module Z_pZ =
functor (X : sig val p : int end) -&gt;
(struct
  type t = int
  let meth = new z_pz X.p
  let inj x =
    if x &gt;= 0 && x &lt; X.p then x else failwith "Z_pZ.inj"
  let proj x = x
end : sig
  type t
  val meth : t group
  val inj : int -&gt; t
  val proj : t -&gt; int
end);;
```

**解释**：

- z_pz_impl 类实现了模 p 整数的基本操作。
- z_pz 类继承了虚类 [int] group 和 z_pz_impl，结合了派生操作和基本操作。
- Z_pZ 模块是一个函子，接受一个参数 X，其中包含一个整数 p，返回一个模块，其中类型 t 是抽象的。
- meth 是 z_pz 的一个新实例，提供了群的操作。
- inj 和 proj 分别用于将整数注入到类型 t 中和从类型 t 中投射出来。
这种表示优雅地结合了模块（类型抽象）的优势和类（继承和晚绑定）的优势。

#### **练习 32：项目——FOC 库的一个小子集**

**任务**：

- 实现 FOC 库的一个小型原型。
- 该练习分为两个部分：包含更多的通用结构，从集合开始，至少到环和多项式。改进上述模型，发明一个更复杂的设计模式，更接近图 5.2 中勾勒的模型，并且可以系统地使用。
- 例如，库可以为每个通用结构提供 **开放视图（open view）** 和 **抽象函子（abstraction functor）**。开放视图对于编写库的扩展很有用。然后，函子可以用于直接从实现中生成一个抽象的具体结构。
- 该模式也可以改进，以允许更丰富的结构（例如，环）在仅需要子结构的地方被接受（例如，加法群）。
- 系数在 ZZ/2ZZ 中的多项式提供了一个简单但有趣的示例来源。
### **进一步阅读**

FOC 系统的示例说明了一种常见情况，需要用于代码结构的混合机制，以更优雅地结合模块和类的特性。这是一个活跃的研究领域，目前正在探索多种解决方案。

- **Mixin 模块和具有视图的对象**：前者通过继承和晚绑定机制丰富了 ML 模块 [18, 4, 5]。后者提供了更好的对象封装机制，特别是在存在二元操作和“友元”函数的情况下；视图还允许更自由地忘记或重命名方法 [68, 71]。
- **其他面向对象的语言**：如 CLOS，将方法从对象中分离出来，将它们转换为重载函数。这种方法越来越接近传统的函数式编程。此外，它自然地扩展到多方法（multi-methods）[13, 22, 8]，允许恢复同一代数类型的参数之间的对称性。这种方法也更具表现力，因为方法调度可以同时依赖于多个参数，而不是仅仅依赖于处于特权位置的单个参数。然而，这使得对象表示的抽象变得更加复杂。事实上，重载使抽象更加困难，因为需要精确了解参数的类型，以决定应使用方法的哪个版本。
**总结**

本章深入探讨了 OCaml 中模块和对象的结合使用，分析了它们的重叠特性和各自的特殊性。我们了解到，模块和类在程序结构中扮演着不同的角色，模块允许嵌入和参数化类型和值，并支持大规模的值和类型抽象；而类提供继承和晚绑定机制，可以通过值进行参数化，但规模较小。

通过对栈的实现的比较，我们看到了类和模块在定义抽象数据类型方面的相似之处，以及在使用新操作扩展实现时的可比性。然而，当需要继承和晚绑定时，类方法更为适合；而对于使用二元操作的抽象数据类型，模块方法更为可取。

为了同时受益于对象和模块的优势，我们讨论了如何将类作为模块的组件使用。通过将相关的类分组到模块中，我们可以提高代码的清晰度和组织性。此外，模块提供了更细粒度的抽象机制，允许我们在友元类中共享表示，同时保持对外的抽象。

最后，我们通过一个来自 FOC 系统的示例，展示了如何将类和模块结合起来，利用模块的类型抽象和类的继承和晚绑定机制，构建一个灵活且可扩展的代数结构库。这种混合的架构既满足了代码共享的需求，又保持了类型抽象的优势。

本章的讨论表明，在大型系统的设计中，灵活地组合使用模块和对象可以带来更优雅和强大的解决方案。这一领域仍在积极研究中，未来可能会有更多的混合机制和设计模式被提出和应用。
  



**概览**

这段内容提供了深入学习 **OCaml** 及相关函数式编程语言的进一步阅读资源。它包含了关于 OCaml、Standard ML 和 Haskell 的书籍、教程和文档的参考资料。此外，内容还讨论了编程语言的形式化和类型系统，特别是在 ML 语言的上下文中。还提到了对 ML 类型系统的各种扩展以及与之相关的挑战。最后，附录“OCaml 入门”指导初学者完成 OCaml 编程的基本步骤，包括编写、编译和运行简单程序，使用交互式解释器，以及练习用 OCaml 实现 Unix 命令。

**详细解读**

### **进一步阅读**

这一部分为希望深入了解 OCaml 和相关函数式编程语言的读者提供了资源，包括书籍、教程、参考手册和研究论文。

#### **OCaml 资源**

- **OCaml 编译器和文档**：**官方网站**：OCaml 编译器、编程环境和文档可在官方网站获取：[http://caml.inria.fr](http://caml.inria.fr/)。**文档**：包括语言的参考手册和一些教程，帮助用户熟悉 OCaml 的使用。
- **OCaml 书籍**：**Chailloux、Manoury 和 Pagano 的《Le langage Caml》[12]**：一本全面介绍 OCaml 语言及其编程环境的书籍。该书以法语编写，但预计很快会有英文版本以电子形式提供。**其他书籍**：Cousineau 和 Mauny [15]、Paulson [74]、Ullman [26] 的书使用的是 Caml Light 语言，它大致对应于 OCaml 的核心语言，但不包括其模块系统和面向对象特性。
#### **其他 ML 家族语言的资源**

- **Standard ML**：**Paulson 的《ML for the Working Programmer》[58]**：一本关于 Standard ML 的优秀入门书籍。**Milner、Tofte、Harper 和 MacQueen 的《The Definition of Standard ML》[51, 50]**：Standard ML 的权威参考文档。
- **Haskell**：**《A Gentle Introduction to Haskell》[38]**：Haskell 的参考手册。**Bird 和 Wadler 的《Introduction to Functional Programming》[70, 30]**：以渐进的方式介绍 Haskell 语言，适合初学者学习。
#### **形式化和类型系统**

- **核心 ML 的形式化**：核心 ML 的类型检查和语义在多篇文章和书籍章节中被形式化。Rémy 和 Pottier [43, 42, chapter 1] 提供了一个简明且自包含的介绍。Wright 和 Felleisen [77] 提供了使用小步归约和类型完备性的现代语义形式化。一些关于编程语言形式语义的入门书籍将 ML 的子集作为示例：Gunter [25]、Mitchell [52]、Winskel [67]。Cardelli [11] 对类型系统进行了优秀的入门介绍。
- **OCaml 的对象和类层**：在 Rémy 和 Vouillon [66] 中进行了形式化。**Abadi 和 Cardelli 的《A Theory of Objects》[1]**：关于对象演算的参考书。这本书对面向对象语言的基本机制进行了形式化，虽然技术性较强，但对于深入理解对象模型很有帮助。
- **Moby 语言**：一种将对象集成到 ML 家族语言中的实验性语言，描述于 Fisher 和 Reppy [20]。Fisher 和 Reppy [21] 为该语言提出了视图机制（view mechanism）。
#### **模块的形式化**

- 对 Standard ML 和 OCaml 模块的多种形式化方法被提出。
- 一些基于具有唯一名称的演算 [51, 48]，另一些使用类型理论概念 [27, 44]。
- Leroy [45] 和 Harper 与 Lillibridge [69] 对这两种方法进行了比较和关联。
### **超越 ML**

这一部分讨论了对 ML 类型系统的扩展以及在保持其基本属性（如类型推断）的同时增加其表达能力所面临的挑战。

#### **子类型多态性**

- **挑战**：子类型多态性在 ML 语境中长期以来是个问题，尽管它在 Java 等流行语言和一些学术上的高阶语言中使用。Java 和高阶语言的共同点在于它们的抽象类型不是通过类型推断得到的。
- **对 ML 的提议**：提出了一些方案试图在保留类型推断的同时，将子类型添加到 ML 中。这些方案都基于某种形式的子类型约束 [3, 19, 62] 或更广泛的类型约束 [54]，主要区别在于它们的表达方式。然而，这些工作都尚未转化为大规模的实际实现。特别是，如何向用户展示类型仍是需要解决的问题。
#### **特设多态性和重载**

- **定义**：其他形式的多态性被称为特设多态性（ad hoc polymorphism）或重载多态性。重载允许在同一作用域中将多个不相关的定义绑定到同一名称。
- **名称解析**：对于每个重载名称的出现，必须选择一个特定的定义。**静态重载**：名称解析在编译时完成，基于名称使用的类型上下文。在 Standard ML 中用于算术操作和记录访问。**动态重载**：名称解析在运行时完成。类型信息可能用于添加运行时类型信息，以动态地指导名称解析。
- **示例**：**Haskell 类型类（Type Classes）**：一种动态重载的形式，类型信息通过类字典间接携带 [55, 36]。**扩展多态性（Extensional Polymorphism）**：由 Harper 和 Morrisett [17] 提出。允许在运行时对表达式的类型进行模式匹配。与动态值（dynamic values）类似，但也有区别 [47, 2]。
#### **系统 Fω&lt;:**

- **特性**：系统 Fω&lt;: 具有高阶类型和子类型，表达能力很强，因而作为编程语言的核心非常有吸引力。
- **挑战**：该系统的类型推断问题是不可判定的 [75]。
- **部分类型重建**：为了同时保持表达能力和隐式类型，提出了部分类型重建的方案 [60, 56]。程序员必须编写一部分但不是全部的类型信息。目标是尽量减少使类型重建可判定所需的类型注解。挑战在于找到一个简单的规范，指明何时何地必须进行注解，而不会要求过多的明显或繁琐的注解。
- **将高阶类型嵌入到 ML 中**：另一种方法是将高阶类型嵌入到 ML 类型中 [24]。这会引发与部分类型重建类似的困难。
#### **对 ML 扩展的结论**

- 大多数对 ML 的扩展可归入两类：**微不足道的技术改变**：通过巧妙的重新表述，最终简化为对核心 ML 的微小改变。**复杂度增加**：复杂度的增加与表达能力的提升不成比例。
- **ML 类型系统的稳定性**：ML 类型系统可能是一个稳定的平衡点——表达能力和简单性之间的最佳妥协。这种稳定性有助于其（相对）成功，也为其后继者提高了标准。
### **附录：OCaml 入门**

该附录为初学者提供了开始使用 OCaml 的指南，包括编写、编译和执行简单程序，使用交互式解释器，以及进行基本的输入/输出操作。

#### **Hello World 程序**

- **创建程序**：使用编辑器创建一个名为 `hello.ml` 的文件，内容如下：
```ocaml
print_string "Hello world!\n";;
```
- **编译和执行**：编译程序：
```
ocamlc -o hello hello.ml
```
执行程序：
```bash
./hello
```
输出：
```
Hello World
```
- **使用交互式解释器**：在终端中输入 `ocaml` 启动解释器。可以直接输入 OCaml 表达式。示例会话：
```shell
Objective Caml version 3.00
# print_string "hello world!\n";;
hello world!
- : unit = ()
```
退出解释器，输入 `^D`（Control D）或调用 `exit 0;;`。
#### **练习 33：Unix 命令 true 和 false**

- **任务**：用 OCaml 编写 Unix 命令 true 和 false。这些命令不执行任何操作，但分别返回代码 0 和 1。
#### **使用脚本和批处理模式**

- **运行脚本**：解释器可以通过在命令行中传递文件名来运行脚本：
```
ocaml hello.ml
```
输出：
```
Hello World
```
- **批处理交互会话**：或者：
```
ocaml &lt; hello.ml
```
输出包括解释器的提示符和响应。
#### **核心语言短语**

- **短语**：值定义：let x = e函数定义（可递归）：let rec f x = e类型定义：type q = t表达式：e
- **注释**：注释使用 (* 和 *) 包围。注释可以嵌套。
#### **表达式和控制结构**

- **表达式**：局部定义：let x = e1 in e2匿名函数：fun x -&gt; e函数调用：f x变量：x构造值：元组 (e1, e2)模式匹配：match e with ...异常处理：try e with ...抛出异常：raise e循环：For 循环：for i = e1 to e2 do e doneWhile 循环：while e1 do e2 done条件表达式：if e1 then e2 else e3序列表达式：e1; e2括号：(e)
- **没有过程**：OCaml 没有过程（procedure）；所有表达式都返回一个值。unit 类型只有一个值 ()。
- **忽略结果**：使用 ignore e 或 _ = e 来丢弃不需要的结果。
#### **基本类型和操作**

- **类型**：unit、bool、char、int、float、string
- **操作**：算术运算：整数使用 +、-、*、/；浮点数使用 +.、-.、*.、/.。布尔运算：&&、||、not字符串连接：^
- **多态类型和操作**：数组：[| e1; e2; ... |]访问数组元素：a.(i)更新数组元素：a.(i) &lt;- v元组和模式匹配用于访问元组元素。
#### **关于运算符和数组的注意事项**

- **将运算符作为函数**：中缀运算符可以通过用括号括起来作为前缀函数使用：( + ) x y。
- **数组**：数组是同构的，必须初始化。数组索引从 0 开始。
#### **记录**

- 记录类似于元组，但具有命名字段。
- 可变字段必须在定义所属的记录类型时声明为 mutable。
**示例**：

```ocaml
type 'a annotation = { name : string; mutable info : 'a };;
let p = { name = "John"; info = 23 };;
p.info &lt;- p.info + 1;;
```

#### **命令行参数**

- 参数存储在数组 Sys.argv 中。
- 第一个参数是命令的名称。
#### **练习 34：Unix 命令 echo**

- **任务**：用 OCaml 实现 Unix 的 echo 命令。
#### **输入和输出**

- **预定义通道**：stdin、stdout、stderr
- **创建通道**：open_in、open_out、close_in、close_out
- **读取和写入**：读取：read_line、read_int写入：print_string、print_int、print_newline
#### **练习 35：Unix 命令 cat 和 grep**

- **任务**：用 OCaml 实现 Unix 的 cat 命令。接受命令行上的文件名列表，按出现顺序打印其内容。如果没有提供文件，则从 stdin 读取。
- **扩展**：修改 cat 程序，通过过滤匹配正则表达式的行来实现 grep。使用标准库 Str 进行正则表达式处理。
#### **练习 36：Unix 命令 wc**

- **任务**：用 OCaml 实现 Unix 的 wc（字数统计）命令。对于每个文件，统计字符、单词和行数。如果提供了多个文件，则提供一个全局摘要。
**总结**

这段内容为希望深入学习 OCaml 的读者提供了丰富的资源和指导。它列出了关于 OCaml、Standard ML 和 Haskell 的关键书籍、手册和论文，涵盖了语言特性、类型系统、形式语义以及面向对象扩展和模块形式化等高级主题。

内容还深入讨论了扩展 ML 类型系统所面临的挑战，特别是子类型多态性和重载问题，并探讨了在语言设计中表达能力与简单性之间的平衡。提到了在保留类型推断的前提下，将子类型添加到 ML 的提议，以及关于静态和动态重载的考虑。

最后，附录作为初学者的实用指南，帮助他们开始使用 OCaml 进行编程。它通过创建和运行“Hello World”程序，引导读者使用交互式解释器，理解基本的语言构造，并进行输入/输出操作。还提供了练习，要求读者用 OCaml 实现常见的 Unix 命令（`true`、`false`、`echo`、`cat`、`grep` 和 `wc`），鼓励他们应用所学知识，实践 OCaml 编程。

总的来说，这段内容是一个全面的指南，帮助读者加深对 OCaml、其类型系统和函数式编程概念的理解，并通过实用的练习巩固他们的学习成果。
  



**概览**

本附录介绍了 **OCaml** 语言的两个新特性：**变体类型（Variant Types）** 和 **标记参数（Labeled Arguments）**，并演示了它们与类（Classes）的结合使用。这两个特性共同以有趣的方式补充了对象和类：

1. **变体类型** 提供了一个很好的替代方案，用于解决 OCaml 中缺乏多个类构造函数的问题。
2. **变体类型** 也是数据类型定义的轻量级替代方案，特别适合在 OCaml 中模拟简单的类型判断（typecases）。
3. **标记参数** 允许在函数定义和调用中一致地标记参数，提高了安全性和灵活性。
需要注意的是，由于 OCaml 的对象类型系统具有很强的表达能力，因此对类型判断的需求非常罕见，即使通过间接的方式来实现类型判断也是完全可以接受的。

## **附录 B：变体类型和标记参数**

### **B.1 变体类型**

#### **简介**

- **变体类型** 是类似于 ML 数据类型的 **标记联合（tagged unions）**。
- 它们允许将不同类型的值通过标记（variant labels）混合到一个集合中。
- 可以使用模式匹配通过检查它们的标签从集合中检索值。
#### **与数据类型的区别**

- 与数据类型不同，变体可以在 **无需预先类型声明** 的情况下使用。
- 数据类型的构造函数属于一个唯一的数据类型，而 **变体构造器（variant constructor）** 可以属于任何（开放的）变体。
#### **快速概览**

- **变体标签** 必须以大写字母开头，并且必须以反引号（`）作为前缀。
```ocaml
let one = `Int 1 and half = `Float 0.5;;
```
这里，变量 one 被绑定到一个变体，该变体是一个带有标签 Int 的整数值。变量 half 被绑定到一个带有标签 Float 的浮点数值。
- **类型推断**：
```ocaml
val one : [&gt; `Int of int] = `Int 1
val half : [&gt; `Float of float] = `Float 0.5
```
&gt; 符号表示 one 实际上可以赋值给一个更大的类型（super type）。这意味着该类型的值实际上可以有其他标签。但是，如果它们具有标签 Int，那么它们必须携带整数。
#### **将不同类型的值存储在同一集合中**

- **示例**：
```ocaml
let collection = [ one; half ];;
```
**类型**：
```ocaml
val collection : [&gt; `Int of int | `Float of float] list =
[`Int 1; `Float 0.5]
```
`collection` 的类型是一个列表，包含具有标签 `Int` 的整数或具有标签 `Float` 的浮点数，或者具有其他标签的值。
#### **通过模式匹配检索异构集合中的值**

- **定义一个函数，将变体值转换为浮点数**：
```ocaml
let float = function
  | `Int x -&gt; float_of_int x
  | `Float x -&gt; x;;
```
**类型**：
```ocaml
val float : [&lt; `Int of int | `Float of float] -&gt; float = 
```
这里，`[&lt; ... ]` 表示一个 **多态变体类型（polymorphic variant type）**，可以是 `Int` 或 `Float` 标签，且不包含其他标签。
- **计算总和**：
```ocaml
let total =
  List.fold_left (fun x y -&gt; x +. float y) 0. collection ;;
```
使用 List.fold_left 对 collection 中的所有元素求和，先将它们转换为浮点数。
#### **使用变体类型实现类型判断（typecase）**

- **背景**：ML 语言在运行时不保留类型，因此没有 typecase 构造来在运行时测试值的类型。可用的唯一解决方案是使用构造函数显式地标记值。
- **OCaml 数据类型可以用于此目的，但变体类型可能更方便和灵活**：变体类型的构造器不需要预先声明。它们的标记值具有兼容的类型。
- **示例**：考虑一维和二维点的类，并将它们的对象组合到一个容器中。**定义一维点类**：
```ocaml
class point1 x = object method getx = x + 0 end;;
let p1 = new point1 1;;
```
**为使两个类的对象兼容，我们总是对它们进行标记**：
```ocaml
let pp1 = p1, `Point1 p1;;
```
pp1 是一个元组，包含对象 p1 和一个标记为 Point1 的变体，其值也是 p1。
- **提供测试和强制转换函数**：
```ocaml
exception Typecase;;

let is_point1 = function _, `Point1 q -&gt; true | _ -&gt; false;;
let to_point1 = function _, `Point1 q -&gt; q | _ -&gt; raise Typecase;;
```
is_point1：检查元组中的变体标签是否为 Point1。to_point1：将元组中的对象提取为 point1 类型的对象。
- **定义安全（静态类型）的强制转换**：
```ocaml
let as_point1 = function pq -&gt; (pq :&gt; point1 * _);;
```
as_point1 将元组强制转换为 point1 * _ 类型。
- **定义二维点类和辅助函数**：
```ocaml
class point2 x y = object inherit point1 x method gety = y + 0 end;;
let p2 = new point2 2 2;;
let pp2 = (p2 :&gt; point1), `Point2 p2;;

let is_point2 = function _, `Point2 q -&gt; true | _ -&gt; false;;
let to_point2 = function _, `Point2 q -&gt; q | _ -&gt; raise Typecase;;
let as_point2 = function pq -&gt; (pq :&gt; point2 * _);;
```
point2 类继承自 point1，并添加了 gety 方法。pp2 是一个元组，包含对象 p2（强制转换为 point1）和一个标记为 Point2 的变体，其值也是 p2。
- **将对象收集到一个容器中**：
```ocaml
let l =
  let ( @:: ) x y = (as_point1 x) :: y in
  pp1 @:: pp2 @:: [];;
```
使用自定义的 @:: 操作符，将强制转换后的对象添加到列表中。l 是一个 point1 对象的列表。
- **访问集合成员的公共组件**：
```ocaml
let getx p = (fst p)#getx;;
List.map getx l;;
```
直接使用元组的第一个元素（对象）调用 getx 方法。由于所有对象都至少是 point1，因此可以直接调用 getx。
- **有选择地访问其他组件**：
```ocaml
let gety p = if is_point2 p then (to_point2 p)#gety else 0;;
List.map gety l;;
```
通过检查对象是否为 point2，然后调用 gety 方法，否则返回默认值 0。
#### **小结**

- 通过使用变体类型和模式匹配，可以在 OCaml 中实现类型判断，允许将不同类型的对象放入同一个容器中，并根据它们的类型执行不同的操作。
- 变体类型的灵活性使得无需预先声明类型，就可以使用标签对值进行标记和区分。
### **B.2 标记参数**

#### **简介**

- 在核心语言中，与大多数语言一样，函数的参数是匿名的。
- **标记参数（Labeled Arguments）** 是对核心语言的一个方便的扩展，允许在函数的定义和调用中一致地标记参数。
#### **标记参数的优点**

1. **提高安全性**：
- 参数标签在定义和调用时都会被检查，可以避免将两个相同类型的参数交换的错误。
2. **增加灵活性**：
- 参数可以按照与定义顺序不同的顺序传递。
3. **改进代码可读性和文档性**：
- 参数标签可以用于说明参数的含义，提高代码的可读性。
#### **示例**

- **标准库中的 String.sub 函数**：
```ocaml
StdLabels.String.sub;;
- : string -&gt; pos:int -&gt; len:int -&gt; string = 
```
该函数期望三个参数：第一个是匿名的字符串参数。第二个和第三个是标记参数，分别为 pos 和 len。
- **调用带标记参数的函数**：
```ocaml
String.sub "Hello" ~pos:0 ~len:4;;
```
或者参数顺序颠倒：
```ocaml
String.sub "Hello" ~len:4 ~pos:0;;
```
由于标记参数可以按照不同于定义的顺序传递，所以上述两种调用方式都是合法的。
- **标记语法**：标签在 ~ 和 : 之间定义，例如 ~pos:。标签名称紧跟在 ~ 之后，冒号 : 表示标签的结束，后面是参数值。
#### **使用 StdLabels 模块**

- **默认情况下，标准库函数不使用标记参数**。
- `StdLabels` 模块重新定义了一些标准库模块，提供了带标记参数的版本。
- 可以在文件的开头添加：
```ocaml
open StdLabels;;
```
然后可以直接使用带标记参数的库函数，例如 String.sub。
#### **定义带标记参数的函数**

- **示例**：定义一个带标记参数的 `substring` 函数：
```ocaml
let substring s ~pos:x ~length:y = String.sub s x y;;
```
这里，pos 和 length 是参数标签，x 和 y 是对应的变量。
- **简化写法**：可以使用相同的名称作为标签和变量名，省略变量：
```ocaml
let substring s ~pos ~length = String.sub s pos length;;
```
当标签名称和变量名相同时，可以省略冒号后面的变量名。
### **B.3 可选参数**

#### **简介**

- **可选参数（Optional Arguments）** 是带有默认值的标记参数。
- 在函数调用中，可以省略这些参数，对应的默认值将被使用。
#### **快速概览**

- **定义可选参数**：
```ocaml
let substring ?pos:(p=0) ~length:l s = String.sub s p l;;
```
?pos:(p=0) 定义了一个可选参数 pos，默认值为 0，绑定到变量 p。~length:l 是一个标记参数，绑定到变量 l。s 是匿名参数（未标记的参数）。
- **调用函数时省略可选参数**：
```ocaml
substring ~length:4 "Hello";;
```
由于 pos 是可选参数，未提供时将使用默认值 0。
- **注意**：可选参数必须始终跟随一个匿名参数，该参数用于标记可选参数的结束，并替换缺失的参数为其默认值。
#### **将可选参数应用于类构造函数**

- **背景**：在 OCaml 中，对象是使用 new 构造的。这相当于具有一个与类名相同的唯一构造函数，其参数个数与类的参数个数相同。在面向对象语言中，通常需要多个构造函数，以不同的方式创建同一类的对象。
- **使用标记参数和变体类型来实现多个构造函数的效果**：**示例 1：带有可选参数的类**
```ocaml
class point ~x:x0 ?y:(y0=0) () =
object
  method getx = x0 + 0
  method gety = y0 + 0
end;;
```
~x:x0：必需的标记参数 x，绑定到变量 x0。?y:(y0=0)：可选参数 y，默认值为 0，绑定到变量 y0。()：额外的匿名参数，用于标记可选参数的结束。**创建对象**：
```ocaml
let p1 = new point ~x:1 ();;
let p2 = new point ~x:1 ~y:2 ();;
```
p1 只提供了 x 参数，y 使用默认值 0。p2 提供了 x 和 y 参数。**示例 2：使用变体类型**
```ocaml
class point arg =
  let x0, y0 =
    match arg with
    | `Cart (x, y) -&gt; x, y
    | `Polar (r, t) -&gt; r *. cos t, r *. sin t
  in
  object
    method getx = x0
    method gety = y0
  end;;
```
arg 是一个变体类型，可以是 Cart (x, y) 或 Polar (r, t)。根据 arg 的标签，计算 x0 和 y0。**创建对象**：
```ocaml
let p1 = new point (`Cart (1.414, 1.));;
let p2 = new point (`Polar (2., 0.52));;
```
p1 使用笛卡尔坐标创建。p2 使用极坐标创建。**示例 3：结合可选参数和变体类型**
```ocaml
class point ?x ?y ?r ?t () =
  let x0, y0 =
    match x, y, r, t with
    | Some x, Some y, None, None -&gt; x, y
    | None, None, Some r, Some t -&gt; r *. cos t, r *. sin t
    | _, _, _, _ -&gt; failwith "Cart and Polar coordinates can't be mixed"
  in
  object
    method getx = x0
    method gety = y0
  end;;
```
允许使用可选参数 x、y、r、t，并根据提供的参数计算 x0 和 y0。如果同时提供了笛卡尔和极坐标，或提供了不完整的参数，则抛出异常。**创建对象**：
```ocaml
let p1 = new point ~x:2. ~y:0.52 ();;
let p2 = new point ~r:1.414 ~t:0.52 ();;
```
p1 使用笛卡尔坐标创建。p2 使用极坐标创建。
#### **总结**

- 通过使用标记参数和可选参数，可以为类创建更加灵活的构造函数，模拟多个构造函数的效果。
- 标记参数提高了函数和类构造函数的安全性、灵活性和可读性。
- 可选参数允许为参数提供默认值，使函数调用更加方便。
- 结合变体类型，可以根据传入的参数类型执行不同的初始化逻辑。
**总结**

本附录深入探讨了 OCaml 中的两个重要新特性：**变体类型** 和 **标记参数**，并展示了它们与类的结合使用，如何以有趣的方式补充对象和类的功能。

首先，**变体类型** 提供了类似于 ML 数据类型的标记联合，但具有更大的灵活性。变体类型允许在无需预先类型声明的情况下使用，变体构造器可以属于任何开放的变体。这使得我们可以通过标记将不同类型的值混合到一个集合中，并使用模式匹配来检索和处理这些值。

通过详细的示例，我们了解到如何使用变体类型实现类型判断（typecase）。在 OCaml 中，运行时不保留类型信息，因此无法直接测试值的类型。变体类型提供了一种解决方案，通过对值进行标记并使用模式匹配，可以在运行时区分不同类型的对象。这在需要将不同类型的对象放入同一个容器并根据其类型执行不同操作的场景中非常有用。

接下来，**标记参数** 是对核心语言的扩展，允许在函数和类的定义和调用中使用参数标签。这带来了以下优点：

1. **提高安全性**：防止参数顺序错误，特别是当多个参数类型相同时。
2. **增加灵活性**：允许以不同于定义顺序的顺序传递参数。
3. **增强可读性和文档性**：参数标签清晰地表示了参数的含义。
通过示例，我们学习了如何定义和使用带标记参数的函数，以及如何利用 `StdLabels` 模块获得标准库函数的标记版本。

然后，我们讨论了 **可选参数**，即具有默认值的标记参数。可选参数允许在函数调用中省略某些参数，从而使用默认值。这在定义具有多个构造函数效果的类时非常有用。在 OCaml 中，类只能有一个构造函数，但通过结合标记参数、可选参数和变体类型，我们可以模拟多个构造函数，实现更灵活的对象创建方式。

最后，通过具体的类定义示例，我们展示了如何使用标记参数和变体类型为类提供灵活的构造函数，允许使用不同的参数组合来初始化对象。这使得类的使用更加方便，满足了实际编程中对多样化对象创建方式的需求。

总的来说，本附录展示了变体类型和标记参数如何增强 OCaml 的表达能力，使得程序员能够编写更灵活、可读性更高的代码，同时与类和对象系统有机地结合在一起。
  



**概览**

本附录提供了先前章节练习题的详细解答。每个练习都附有解决方案，包括代码示例和解释。练习涵盖了 **OCaml** 编程的各个主题，包括上下文操作、类型推断、统一、面向对象特性，以及实现 Unix 命令等实际编程任务。附录旨在通过提供详尽的解决方案，帮助读者理解相关概念和技术。

**详细解读**

### **练习 1，第 21 页**

**问题描述：**

该练习涉及在一个简单语言的解释器中操作 **评价上下文（evaluation context）**。目标是定义以下函数：

1. 填充一个上下文，以构建完整的表达式。
2. 将一个表达式分解为上下文和子表达式。
3. 通过在适当的上下文中执行归约，实现表达式的求值。
**解决方案解析：**

1. **函数 fill_context：**该函数接受一个上下文 `c` 和一个表达式 `e`，通过将表达式填入上下文的孔位，重新构建整个表达式。
```ocaml
let rec fill_context = function
  | Top, e as ce -&gt; e
  | AppL (c, l), e -&gt; fill_context (c, App (e, l))
  | AppR ((_, e1), c), e2 -&gt; fill_context (c, App (e1, e2))
  | LetL (x, c, e2), e1 -&gt; fill_context (c, Let (x, e1, e2));;
```
**解释：**
- 该函数是递归的，对上下文进行模式匹配。
- Top 上下文表示没有更多的上下文需要填充，因此返回表达式 e。
- 对于左侧的应用（AppL），通过将表达式 e 与右侧的表达式 l 组合，重新构建应用表达式，并递归地填充外部上下文 c。
- 对于右侧的应用（AppR），使用存储的表达式 e1 和新的表达式 e2，填充外部上下文 c。
- 对于左侧的 Let 绑定（LetL），重新构建 Let 表达式，并填充外部上下文 c。
2. **异常定义：**
```ocaml
exception Error of context * expr;;
exception Value of int;;
```
**解释：**
- Error 是一个异常，携带一个上下文和一个表达式，可能用于在求值期间表示错误。
- Value 是一个异常，携带一个整数，用于表示值的 **元数（arity）**（参数数量）。
3. **函数 decompose_down：**
```ocaml
let rec decompose_down (c,e as ce) =
  match e with
  | Var _ -&gt; raise (Error (c, e))
  | Const c when c.constr -&gt; raise (Value (c.arity + 1))
  | Const c -&gt; raise (Value (c.arity))
  | Fun (_, _) -&gt; raise (Value 1)
  | Let (x, e1, e2) -&gt; decompose_down (LetL (x, c, e2), e1)
  | App (e1, e2) as e -&gt;
      try decompose_down (AppL (c, e2), e1) with Value k1 -&gt;
      try decompose_down (AppR ((k1, e1), c), e2) with Value k2 -&gt;
      if k1 &gt; 1 then raise (Value (k1 -1)) else ce;;
```
**解释：**
- 此函数尝试将表达式分解为上下文和一个可归约的子表达式。
- 如果表达式是变量（Var），则抛出 Error，因为变量不能进一步分解。
- 如果表达式是常量（Const c）：如果 c.constr 为真（表示它是一个构造器），则抛出 Value (c.arity + 1)。否则，抛出 Value (c.arity)。
- 如果表达式是函数（Fun），则抛出 Value 1。
- 如果是 Let 表达式，继续分解绑定表达式 e1，将 LetL 添加到上下文中。
- 对于应用（App (e1, e2)），首先尝试分解 e1（函数部分）：如果 e1 是元数为 k1 的值，则尝试分解 e2（参数部分）。如果 e2 也是元数为 k2 的值，且 k1 &gt; 1，则减少 k1，抛出 Value (k1 -1)。如果 k1 &lt;= 1，则返回当前的上下文和表达式 ce。
4. **函数 decompose_up：**
```ocaml
let rec decompose_up k (c, v as cv) =
  if k &gt; 0 then
    match c with
    | Top -&gt; raise Not_found
    | LetL (x, c', e) -&gt;
        (c', (Let (x, v, e)))
    | AppR ((k', v'), c') -&gt;
        decompose_up (k' -1) (c', App (v', v))
    | AppL (c', e) -&gt;
        try decompose_down (AppR ((k, v), c'), e)
        with Value _ -&gt; decompose_up (k -1) (c', App (v, e))
  else cv;;
```
**解释：**
- 该函数在达到一个值后，向上重建上下文。
- 它使用元数 k 来确定需要重建多少层的应用。
- 如果 k &gt; 0，则对上下文进行模式匹配：如果是 Top，则抛出 Not_found（没有更多的上下文可分解）。如果是 LetL，则使用值 v 重建 Let 表达式，并继续处理外部上下文 c'。如果是 AppR，减少 k'，递归地向上分解。如果是 AppL，尝试使用当前值 v 和表达式 e 向下分解应用。
- 如果 k &lt;= 0，则返回当前的上下文和值。
5. **函数 decompose：**
```ocaml
let decompose ce =
  try decompose_down ce with Value k -&gt; decompose_up k ce;;
```
**解释：**
- 该函数尝试分解上下文 c 中的表达式 e。
- 首先尝试使用 decompose_down 进行向下分解。
- 如果捕获到 Value k 异常，则使用 decompose_up 向上重建上下文。
6. **函数 reduce_in：**
```ocaml
let reduce_in ((c : context), e) = (c, top_reduction e);;
```
**解释：**
- 该函数在上下文 c 中对表达式 e 执行顶层归约。
- 返回新的上下文和归约后的表达式。
7. **函数 eval_step：**
```ocaml
let eval_step ce = reduce_in (decompose ce);;
```
**解释：**
- 通过分解表达式，然后进行归约，执行一步求值。
8. **函数 eval_all 和 eval：**
```ocaml
let rec eval_all ce = try eval_all (eval_step ce) with Not_found -&gt; ce;;
let eval e = fill_context (eval_all (Top, e));;
```
**解释：**
- eval_all 递归地应用 eval_step，直到无法进一步归约（抛出 Not_found）。
- eval 使用空的上下文 Top 初始化求值，并填充最终的上下文以重建求值后的表达式。
9. **美化打印函数：**
```ocaml
let hole = Const {name = Name "[]"; arity = 0; constr = true};;
```

- 定义一个特殊的常量 hole，用于表示上下文中的孔位。
```ocaml
let rec expr_with expr_in_hole k out =
  (* 函数主体为美化打印，略去具体实现 *)
```
**解释：**
- 该函数用于打印可能包含孔位的表达式。
- 使用 Format 模块来格式化输出。
- 处理不同类型的表达式，并根据操作符优先级确保正确使用括号。
- 可以打印单独的上下文、表达式，或在上下文中填入表达式。
```ocaml
let print_context_expr (c, e) =
  expr_with e 0 Format.std_formatter (fill_context (c, hole))
let print_expr e = expr_with hole 0 Format.std_formatter e
let print_context c = print_expr (fill_context (c, hole));;
#install_printer print_context_expr;;
```
**解释：**
- 定义了用于打印上下文和表达式的函数，使用 expr_with 函数。
- #install_printer 用于在 OCaml 顶层安装 print_context_expr 函数，方便在交互会话中美观地打印上下文和表达式。
### **练习 3，第 43 页**

**问题描述：**

实现一个函数 `print_type`，能够以可读的格式打印类型，处理类型变量、整数和函数类型。

**解决方案解析：**

```ocaml
let print_type t =
  let rec print k out t =
    let string x = Printf.fprintf out x in
    let paren p f =
      if k &gt; p then string "("; f(); if k &gt; p then string ")" in
    let t = repr t in
    begin match desc t with
    | Tvar n -&gt; string "'a%d" n
    | Tcon (Tint, []) -&gt; string "int"
    | Tcon (Tarrow, [t1; t2]) -&gt;
        paren 0 (fun() -&gt;
          string "%a -&gt; %a" (print 1) t1 (print 0) t2)
    | Tcon (g, l) -&gt; raise (Arity (t, t))
    end in
  acyclic t;
  print 0 stdout t;;
```

**解释：**

- **辅助函数：**string x 是 Printf.fprintf out x 的简写，用于向输出 out 打印格式化字符串。paren p f 是一个函数，如果当前优先级 k 大于 p，则在 f() 的输出周围添加括号。
- **函数结构：**print_type 函数首先使用 acyclic t 确保类型 t 是无环的。然后调用递归函数 print，初始优先级为 0，输出通道为 stdout。
- **递归函数 print：**接受当前优先级 k、输出通道 out 和类型 t。使用 repr t 获取类型的代表（以处理可能已统一的类型变量）。对 desc t 进行模式匹配，描述类型的构成。
- **模式匹配的情况：**Tvar n：类型变量，打印 'a 加上其编号 n。Tcon (Tint, [])：整数类型，打印 "int"。Tcon (Tarrow, [t1; t2])：函数类型 t1 -&gt; t2。使用 paren 0 决定是否需要括号。递归地以优先级 1 打印 t1，以优先级 0 打印 t2。Tcon (g, l)：其他类型构造器，抛出 Arity 异常，在简化版本中未处理。
### **练习 4，第 44 页**

**问题描述：**

实现函数以找到类型中的自由类型变量（`ftv`），并通过替换类型变量来创建类型实例。

**解决方案解析：**

1. **函数 ftv_type：**
- 该函数计算类型 t 中的自由类型变量列表。**函数式版本：**
```ocaml
let ftv_type t =
  let visited = marker() in
  let rec visit ftv t =
    let t = repr t in
    if t.mark = visited then ftv
    else
    begin
      t.mark &lt;- visited;
      match desc t with
      | Tvar _ -&gt; t::ftv
      | Tcon (g, l) -&gt; List.fold_left visit ftv l
    end in
  visit [] t;;
```
**解释：**
- visited 是一个唯一的标记，用于跟踪已访问的类型变量。
- visit ftv t 递归遍历类型 t：如果 t 已被访问过（t.mark = visited），则返回累积的 ftv。如果 t 是类型变量（Tvar _），将 t 添加到列表 ftv。如果 t 是类型构造器（Tcon (g, l)），递归访问列表 l 中的每个类型。**命令式版本：**
```ocaml
let ftv_type t =
  let ftv = ref [] in
  let visited = marker() in
  let rec visit t =
    let t = repr t in
    if t.mark = visited then ()
    else
    begin
      t.mark &lt;- visited;
      match desc t with
      | Tvar _ -&gt; ftv := t::!ftv
      | Tcon (g, l) -&gt; List.iter visit l
    end in
  visit t; !ftv;;
```
**解释：**
- 与函数式版本类似，但使用引用 ftv 来累积自由类型变量。
- visit t 标记 t 已访问，并将其添加到 ftv，或递归访问其组件。
2. **函数 type_instance：**
- 该函数通过将量化类型变量 q 替换为新的类型变量，创建类型方案 (q, t) 的实例。
```ocaml
let type_instance (q, t) =
  acyclic t;
  let copy t = let t = repr t in t, tvar() in
  let copied = List.map copy q in
  let rec visit t =
    let t = repr t in
    try List.assq t copied with Not_found -&gt;
    begin match desc t with
    | Tvar _ | Tcon (_, []) -&gt; t
    | Tcon (g, l) -&gt; texp (Tcon (g, List.map visit l))
    end in
  visit t;;
```
**解释：**
- acyclic t 确保类型 t 无环。
- copy t 创建一个原始类型变量 t 和新类型变量 tvar() 的对。
- copied 是旧类型变量和新类型变量的对的列表。
- visit t 递归遍历类型 t：如果 t 在 copied 中，用新类型变量替换。如果 t 是类型变量或基本类型，返回 t。如果 t 是类型构造器，递归访问其组件。
3. **保持共享的函数：**
- 一个更高级的版本，保持类型结构的共享。**实现可扩展数组模块：**
```ocaml
module Iarray =
struct
  type 'a t = { mutable t : 'a array; v : 'a }
  let create k v = { t = Array.create (max k 3) v; v = v }
  let get a i =
    if Array.length a.t &gt; i then a.t.(i) else a.v
  let set a i v =
    let n = Array.length a.t in
    if n &gt; i then a.t.(i) &lt;- v else
    begin
      let t = Array.create (2 * n) a.v in
      Array.blit a.t 0 t 0 n;
      a.t &lt;- t;
      t.(i) &lt;- v;
    end
end;;
```
**解释：**
- 定义了一个可扩展的数组模块 Iarray，可以动态增长。
- 用于在替换过程中跟踪类型变量，同时保持共享。**修改后的 type_instance 函数：**
```ocaml
let type_instance (q, t) =
  let table = Iarray.create 7 (tvar()) in
  let poly = marker() in
  let copy_var t =
    let t' = tvar() in let p = marker() in
    t.mark &lt;- p; Iarray.set table (p - poly) t'; t' in
  let q' = List.map copy_var q in
  let rec visit t =
    let t = repr t in
    if t.mark &gt; poly then Iarray.get table (t.mark - poly)
    else
    begin match desc t with
    | Tvar _ | Tcon (_ , []) -&gt; t
    | Tcon (g, l) -&gt;
        let t' = copy_var t in
        t'.texp &lt;- Desc (Tcon (g, List.map visit l)); t'
    end in
  visit t;;
```
**解释：**
- 使用 Iarray 模块跟踪已复制的类型变量。
- poly 标记用于标记旧的类型变量。
- copy_var t 为 t 分配一个新的标记 p，并将新类型变量 t' 存储在表中。
- visit 函数使用标记来确定是否复制或重用类型变量，保持共享结构。
### **练习 5，第 46 页**

**问题描述：**

实现一个函数，以确定类型中的哪些类型变量是可泛化的，即不在类型环境 `tenv` 中自由出现。

**解决方案解析：**

1. **函数 visit_type：**
```ocaml
let visit_type exclude visited f t = let rec visit t =
  let t = repr t in
  if t.mark = exclude || t.mark == visited then ()
  else
  begin
    t.mark &lt;- visited; f t;
    match desc t with
    | Tvar _ -&gt; ()
    | Tcon (g, l) -&gt; List.iter visit l
  end in
  visit t;;
```
**解释：**
- visit_type exclude visited f t 访问类型 t 中未标记为 exclude 且未访问过的所有节点。
- 对每个访问的节点，应用函数 f。
2. **函数 generalizable：**
```ocaml
let generalizable tenv t0 =
  let inenv = marker() in
  let mark m t = (repr t).mark &lt;- m in
  let visit_assumption (x, (q, t)) =
    let bound = marker() in
    List.iter (mark bound) q; visit_type bound inenv ignore t in
  List.iter visit_assumption tenv;
  let ftv = ref [] in
  let collect t = match desc t with Tvar _ -&gt; ftv := t::!ftv | _ -&gt; () in
  let free = marker() in
  visit_type inenv free collect t0;
  !ftv;;
```
**解释：**
- 该函数使用 inenv 标记所有在环境 tenv 中自由出现的类型变量。
- 对于环境中的每个假设 (x, (q, t))：使用唯一的 bound 标记标记量化变量 q。然后访问类型 t，排除标记为 bound 的变量，并将其标记为 inenv。
- 然后收集在 t0 中未标记为 inenv 的类型变量（即不在环境中自由出现的变量）。
- 这些变量就是可泛化的类型变量。
### **练习 6，第 48 页**

**问题描述：**

解释为什么术语 `λf.f f` 在简单类型 lambda 演算中无法类型化。

**解决方案解析：**

- 在简单类型 lambda 演算中，每个函数必须具有形式 A -&gt; B 的类型。
- 在术语 λf.f f 中，函数 f 被应用到自身。
- 假设 f 的类型为 A。那么在应用 f f 中，f 必须具有类型 A -&gt; B，以便应用于类型为 A 的参数。
- 因此，我们有类型等式 A = A -&gt; B，这导致无法解决的类型方程，除非使用递归类型。
- 由于简单类型 lambda 演算不允许递归类型，因此术语 λf.f f 是不可类型化的。
### **练习 7，第 48 页**

**问题描述：**

使用不动点组合子 `fix` 定义阶乘函数。

**解决方案解析：**

```ocaml
let fact' fact x = if x = 0 then 1 else x * fact (x -1);;
let fact x = fix fact' x;;
```

**解释：**

- fact' 是一个高阶函数，接受一个函数 fact 和一个整数 x。
- 它使用 fact 递归地定义阶乘。
- 使用 fix 组合子找到 fact' 的不动点，有效地定义了递归的 fact 函数。
- fact x 计算 x 的阶乘。
### **练习 9，第 49 页**

**问题描述：**

提供函数 `f0_1`、`f0_2`、`f0_3` 和 `a` 的定义，以模拟互相递归的函数的行为。

**解决方案解析：**

代码片段：

```ocaml
let rec f0_1 = λf2.λf3.λx. let f1 = f0_1 f2 f3 in a1 in
let rec f0_2 = λf3.λx. let f2 = f0_2 f3 in let f1 = f0_1 f2 f3 in a2 in
let rec f0_3 = λx. let f3 = f0_3 in let f2 = f0_2 f3 in let f1 = f0_1 f2 f3 in a3 in
a
```

**解释：**

- 此练习涉及在没有显式递归的情况下模拟互相递归的函数。
- 函数 f0_1、f0_2 和 f0_3 互相依赖定义。
- 每个函数都定义为一个 lambda 抽象，计算 f1、f2 和 f3，然后用于计算 a1、a2、a3，最终计算 a。
- 具体细节取决于 a1、a2、a3 和 a 的定义。
### **练习 10，第 50 页**

**问题描述：**

使用 OCaml 中的递归类型（`-rectypes` 选项）定义 `fix` 函数。

**解决方案解析：**

```ocaml
let fix =
  (fun f' -&gt;
    ( fun f -&gt; (fun x -&gt; f' (f f) x))
    ( fun f -&gt; (fun x -&gt; f' (f f) x))
  );;
```

**解释：**

- fix 函数使用高阶函数和自应用进行定义。
- 使用 Y 组合子的模式实现递归。
- -rectypes 选项允许 OCaml 中的递归类型，使得该定义成为可能。
**使用阶乘函数测试：**

```ocaml
let fact = fix fact' in fact 5;;
- : int = 120
```

- 阶乘函数 fact 使用 fix 和 fact' 定义。
- fact 5 计算 5! = 120。
**其他练习：**

剩余的练习（11、12、13 等）遵循类似的模式，为各种 OCaml 编程任务提供代码和解释，包括类型打印、类型推断、扑克牌游戏逻辑，以及在 OCaml 中实现 Unix 命令。

例如：

- **练习 13，第 54 页：**问题涉及在一手牌中寻找相似的牌组（例如，四条），考虑到 Joker（鬼牌）可以代表任何牌。解决方案定义了函数来比较牌，考虑到 Joker，并在手牌中搜索相似的牌组。
- **练习 33，第 128 页：**使用 OCaml 实现 Unix 命令 true 和 false。这些命令仅以状态码 0 和 1 退出。
```ocaml
exit 0;;
exit 1;;
```
- **练习 35，第 133 页：**使用 OCaml 实现 Unix cat 命令，读取文件并打印其内容。解决方案从提供的文件名读取，如果未提供文件，则从 stdin 读取。
```ocaml
let echo chan =
  try while true do print_endline (input_line chan) done
  with End_of_file -&gt; ();;
if Array.length Sys.argv &lt;= 1 then echo stdin
else
  for i = 1 to Array.length Sys.argv - 1
  do
    let chan = open_in Sys.argv.(i) in
    echo chan;
    close_in chan
  done;;
```
- **练习 36，第 133 页：**使用 OCaml 实现 Unix wc（字数统计）命令。解决方案定义了一个类型 count 来跟踪字符、单词和行数。处理每个文件，更新计数并打印结果。
**总结**

本附录提供了对练习题的全面解答，涵盖了 OCaml 编程中的广泛主题。练习深入探讨了：

- **求值和上下文操作**：理解如何使用上下文分解和重建表达式，并在解释器中实现求值策略。
- **类型系统和类型推断**：实现操作类型的函数，如打印类型、查找自由类型变量、创建类型实例，以及理解类型推断中的统一和泛化。
- **递归和不动点组合子**：使用不动点组合子定义递归函数，包括处理互相递归和自应用。
- **OCaml 中的面向对象特性**：探索类定义、继承和方法重写，包括处理二元方法和参数化类。
- **实际编程练习**：在 OCaml 中实现常见的 Unix 命令（`true`、`false`、`echo`、`cat`、`grep`、`wc`），展示了文件处理、命令行参数处理和字符串操作。
详细的解释旨在帮助读者掌握解决方案中使用的基本概念和技术。通过逐步讲解每个代码片段并提供背景信息，附录加强了对高级 OCaml 编程实践的理解，包括函数式编程范式、类型理论和实际应用程序开发。
  



**概览**

这段内容是一本书的参考文献列表，列出了与 **编程语言理论**、**类型系统**、**函数式编程**、**面向对象编程** 以及 **OCaml** 等主题相关的关键学术论文、书籍和技术报告。这些参考文献来自知名学者和研究人员，涵盖了从理论基础到实践应用的广泛内容，包括 lambda 演算、类型推断、模块系统、多态性、对象理论、编程语言设计和实现等。

**详细解读**

 **[1] Mart'in Abadi and Luca Cardelli. A theory of objects. Springer, 1997.**

这本书是 **Abadi** 和 **Cardelli** 合著的 **《对象理论》**，由 Springer 于 1997 年出版。它是面向对象编程语言理论的经典著作，深入探讨了对象的类型理论和语义。作者提出了对象计算的形式化模型，提供了对象、类、继承、多态等概念的理论基础，对编程语言的设计和理解有重要影响。

 **[2] Mart'in Abadi, Luca Cardelli, Benjamin C. Pierce, and Didier R'emy. Dynamic typing in polymorphic languages. Journal of Functional Programming, 5(1):111–130, January 1995.**

这篇论文发表在 1995 年 1 月的 **《函数式编程杂志》** 上，讨论了在多态语言中引入动态类型的方式。作者 **Abadi**、**Cardelli**、**Pierce** 和 **Rémy** 探讨了在静态类型的多态语言中支持动态类型检查的机制，提出了在多态类型系统中引入动态类型的理论框架，为在类型安全的前提下实现更灵活的编程提供了方法。

 **[3] Alexander Aiken and Edward L. Wimmers. Type inclusion constraints and type inference. In Conference on Functional Programming Languages and Computer Architecture, pages 31–41. ACM press, 1993.**

这篇论文发表于 1993 年的 **函数式编程语言与计算机体系结构会议**，由 **Aiken** 和 **Wimmers** 撰写。论文探讨了 **类型包含约束**（type inclusion constraints）和 **类型推断**，提出了一种基于类型包含的类型推断算法，对理解类型系统中的子类型关系和类型推断过程具有重要意义。

 **[4] Davide Ancona and Elena Zucca. A theory of mixin modules: Basic and derived operators. Mathematical Structures in Computer Science, 8(4):401–446, August 1998.**

**Ancona** 和 **Zucca** 在 1998 年的 **《计算机科学中的数学结构》** 期刊上发表了这篇论文，提出了 **Mixin 模块** 的理论。Mixin 是一种模块化编程技术，允许模块之间的灵活组合和继承。作者详细讨论了 Mixin 模块的基本和派生操作，为模块系统的设计提供了理论支持。

 **[5] Davide Ancona and Elena Zucca. A primitive calculus for module systems. In Gopalan Nadathur, editor, PPDP’99 - International Conference on Principles and Practice of Declarative Programming, volume 1702 of Lecture Notes in Computer Science, pages 62–79. Springer-Verlag, 1999.**

这篇论文发表于 1999 年的 **声明式编程原理与实践国际会议（PPDP'99）**，作者提出了用于模块系统的基本演算。通过定义模块的原语计算模型，作者为模块系统的理论研究和实际实现提供了基础。

 **[6] Hans P. Barendregt. The Lambda-Calculus. Its Syntax and Semantics, volume 103 of Studies in Logic and The Foundations of Mathematics. North-Holland, 1984.**

**Barendregt** 的这本书是关于 **λ-演算** 的经典著作，全面介绍了 λ-演算的语法和语义，是逻辑和数学基础研究的权威参考。它涵盖了 λ-演算的各种变体、类型系统、语义理论，对计算机科学中的函数式编程和类型理论研究者具有重要价值。

 **[7] Sylvain Boulmé, Thérèse Hardin, and Renaud Rioboo. Modules, objets et calcul formel. In Actes des Journées Francophones des Langages Applicatifs. INRIA, 1999.**

这篇论文发表于 1999 年的 **法语应用语言日（JFLA）** 会议，由 **Boulmé**、**Hardin** 和 **Rioboo** 撰写。论文探讨了 **模块**、**对象** 和 **形式计算** 的结合，研究了在函数式编程中使用模块和对象的方式，以及它们在计算机代数系统中的应用。

 **[8] François Bourdoncle and Stephan Merz. Type checking higher-order polymorphic multi-methods. In Proceedings of the 24th ACM Conference on Principles of Programming Languages, pages 302–315, July 1997.**

这篇论文发表于 1997 年的 **第 24 届编程语言原理会议（POPL）**，作者 **Bourdoncle** 和 **Merz** 研究了高阶多态多方法的类型检查问题。他们提出了一种类型检查算法，能够处理具有复杂多态性的高阶多方法，为面向对象语言的类型系统提供了新思路。

 **[9] Kim B. Bruce, Luca Cardelli, Giuseppe Castagna, the Hopkins Objects Group (Jonathan Eifrig, Scott Smith, Valery Trifonov), Gary T. Leavens, and Benjamin Pierce. On binary methods. Theory and Practice of Object Systems, 1(3):221–242, 1996.**

这篇论文发表在 1996 年的 **《对象系统的理论与实践》** 期刊上，由多个知名学者合作完成。论文深入探讨了 **二元方法（binary methods）** 的类型系统问题，即方法的参数和返回类型依赖于多个对象的类型。作者分析了二元方法在面向对象语言中的挑战，并提出了类型安全的解决方案。

 **[10] Kim B. Bruce, Martin Odersky, and Philip Wadler. A statically safe alternative to virtual types. In European Conference on Object-Oriented Programming (ECOOP), Brussels, July 1998.**

这篇论文发表于 1998 年的 **欧洲面向对象编程会议（ECOOP）**，作者 **Bruce**、**Odersky** 和 **Wadler** 提出了虚拟类型的一种静态安全替代方案。他们研究了在面向对象语言中使用虚拟类型的问题，并提出了基于泛型和类型参数的替代方法，保持了类型系统的静态安全性。

 **[11] Luca Cardelli and Peter Wegner. On understanding types, data abstraction, and polymorphism. Computing Surveys, 17(4):471–522, 1985.**

这篇论文发表在 1985 年的 **《计算调查》** 杂志上，是关于 **类型、数据抽象和多态性** 的重要综述。**Cardelli** 和 **Wegner** 对类型系统的基本概念进行了系统性的阐述，讨论了类型检查、多态性、数据抽象等主题，对编程语言理论的发展产生了深远影响。

 **[12] Emmanuel Chailloux, Pascal Manoury, and Bruno Pagano. Développement d'applications avec Objective Caml. O'Reilly, 2000.**

这本书是由 **Chailloux**、**Manoury** 和 **Pagano** 合著的 **《使用 Objective Caml 开发应用程序》**，由 O'Reilly 于 2000 年出版。该书全面介绍了 **OCaml** 语言及其编程环境，涵盖了函数式、面向对象和模块化编程的概念，是学习 OCaml 的重要参考。

 **[13] Craig Chambers. The Cecil Language: Specification & Rationale. Technical Report 93-03-05, University of Washington, 1993.**

**Chambers** 在 1993 年的技术报告中详细介绍了 **Cecil 语言** 的规范和设计原理。Cecil 是一种面向对象语言，支持多重分派和模块化类型系统。该报告阐述了语言设计背后的理念，为理解高级面向对象语言提供了资料。

 **[14] Dominique Clément, Joëlle Despeyroux, Thierry Despeyroux, and Gilles Kahn. A simple applicative language: Mini-ML. In Proceedings of the Conference Lisp and Functional Programming, LFP'86. ACM Press, August 1986. Also appears as INRIA Research Report RR-529, May 1986.**

这篇论文发表于 1986 年的 **Lisp 与函数式编程会议（LFP'86）**，介绍了一种简单的应用语言 **Mini-ML**。作者 **Clément**、**Despeyroux** 和 **Kahn** 设计了 Mini-ML，作为 ML 的一个子集，用于研究函数式编程语言的基本特性。

 **[15] Guy Cousineau and Michel Mauny. Approche fonctionnelle de la programmation. Ediscience, 1995.**

这本书是 **Cousineau** 和 **Mauny** 合著的 **《编程的函数式方法》**，由 Ediscience 于 1995 年出版。该书以函数式编程的视角介绍了编程的概念和技术，使用了 Caml 语言作为主要示例，对学习函数式编程和 ML 家族语言有重要价值。

 **[16] Luis Damas and Robin Milner. Principal type-schemes for functional programs. In ACM Symposium on Principles of Programming Languages, pages 207–212. ACM Press, 1982.**

这篇论文发表于 1982 年的 **编程语言原理研讨会（POPL）**，作者 **Damas** 和 **Milner** 提出了函数式程序的 **主类型方案**（principal type-schemes）。他们证明了在带有多态类型系统的函数式语言中，任何类型正确的表达式都具有最泛化的类型方案，为 ML 类型系统奠定了理论基础。

 **[17] Catherine Dubois, François Rouaix, and Pierre Weis. Extensional polymorphism. In Proceedings of the 22th ACM Conference on Principles of Programming Languages, January 1995.**

这篇论文发表于 1995 年的 **POPL**，作者 **Dubois**、**Rouaix** 和 **Weis** 讨论了 **外延多态性**（extensional polymorphism）。他们提出了一种在 ML 中引入外延多态性的方法，允许程序在运行时根据类型信息进行模式匹配，提高了语言的表达能力。

 **[18] Dominic Duggan and Constantinos Sourelis. Mixin modules. In International Conference on Functional Programming 96, pages 262–273. ACM Press, 1996.**

这篇论文发表于 1996 年的 **国际函数式编程会议（ICFP'96）**，作者 **Duggan** 和 **Sourelis** 提出了 **Mixin 模块** 的概念。Mixin 模块允许在模块系统中支持增量式的代码复用和组合，提供了比传统模块系统更灵活的特性。

 **[19] J. Eifrig, S. Smith, and V. Trifonov. Type inference for recursively constrained types and its application to OOP. In Mathematical Foundations of Programming Semantics, 1995.**

这篇论文发表于 1995 年的 **编程语义的数学基础** 会议，作者 **Eifrig**、**Smith** 和 **Trifonov** 研究了 **递归约束类型** 的类型推断问题，并讨论了其在面向对象编程中的应用。他们的工作为处理复杂类型关系的类型推断提供了理论支持。

 **[20] Kathleen Fisher and John Reppy. The design of a class mechanism for Moby. In Proceedings of the ACM SIGPLAN '99 Conference on Programming Languages, Design and Implementations, pages 37–49, Atlanta, May 1999. ACM SIGPLAN, ACM Press.**

这篇论文发表于 1999 年的 **编程语言设计与实现会议（PLDI'99）**，作者 **Fisher** 和 **Reppy** 介绍了 **Moby 语言** 的类机制设计。Moby 是一种实验性的编程语言，结合了面向对象和函数式编程的特性。论文详细讨论了 Moby 的类系统和类型检查机制。

 **[21] Kathleen Fisher and John Reppy. Extending Moby with inheritance-based subtyping. In Proceedings of the 14th European Conference on Object-Oriented Programming, 2000.**

这篇论文发表于 2000 年的 **欧洲面向对象编程会议（ECOOP'00）**，作者 **Fisher** 和 **Reppy** 讨论了如何通过基于继承的子类型扩展 Moby 语言。他们提出了在 Moby 中引入子类型多态性的方案，增强了语言的表达能力。

 **[22] Alexandre Frey and François Bourdoncle. The Jazz home page. Free software available at http://www.cma.ensmp.fr/jazz/index.html.**

这是一份在线资源，由 **Frey** 和 **Bourdoncle** 提供的 **Jazz** 项目主页。Jazz 是一个免费的软件工具，可能与编程语言或类型系统研究相关（需要访问链接获取更多信息）。

 **[23] Jacques Garrigue. Programming with polymorphic variants. In ML Workshop, September 1998.**

这篇论文发表于 1998 年的 **ML 研讨会**，作者 **Garrigue** 介绍了使用 **多态变体（polymorphic variants）** 进行编程的方法。多态变体是 OCaml 中的一项特性，允许更加灵活地定义和使用变体类型。作者讨论了多态变体的语法、类型系统和应用场景。

 **[24] Jacques Garrigue and Didier Rémy. Extending ML with semi-explicit higher-order polymorphism. In International Symposium on Theoretical Aspects of Computer Software, volume 1281 of Lecture Notes in Computer Science, pages 20–46. Springer, September 1997.**

这篇论文发表于 1997 年的 **计算机软件理论方面国际研讨会（TACS'97）**，作者 **Garrigue** 和 **Rémy** 探讨了将 ML 扩展为具有半显式高阶多态性的方法。他们提出了一种类型系统，允许在保持类型推断的同时，引入更高级的多态特性。

 **[25] Carl A. Gunter. Semantics of Programming Languages: Structures and Techniques. Foundations of Computing. MIT Press, 1992.**

**Gunter** 的这本书是关于 **编程语言语义** 的权威教材，涵盖了语义理论的各种结构和技术，包括操作语义、固定点理论、类型系统等。对于深入理解编程语言的语义基础，这本书是不可或缺的资源。

 **[26] Thérèse Accart Hardin and Véronique Donzeau-Gouge Viguie. Concepts et outils de programmation — Le style fonctionnel, le style impératif avec CAML et Ada. Interéditions, 1992.**

这本书由 **Hardin** 和 **Viguie** 合著，讨论了编程的概念和工具，特别是使用 CAML 和 Ada 语言的函数式和命令式编程风格。该书为理解不同编程范式提供了指导。

 **[27] Robert Harper and Mark Lillibridge. A type-theoretic approach to higher-order modules with sharing. In ACM Symposium on Principles of Programming Languages, pages 123–137. ACM Press, 1994.**

这篇论文发表于 1994 年的 **POPL**，作者 **Harper** 和 **Lillibridge** 提出了处理具有共享的高阶模块的类型理论方法。他们的研究为模块系统的设计和类型检查提供了理论基础。

 **[28] F. Henglein. Polymorphic Type Inference and Semi-Unification. PhD thesis, Courant Institute of Mathematical Sciences, New York University, 1989.**

**Henglein** 的博士论文，研究了 **多态类型推断** 和 **半统一（semi-unification）** 问题。半统一是类型推断中的一种技术，用于处理类型变量之间的复杂关系。

 **[29] J. Roger Hindley and Jonathan P. Seldin. Introduction to Combinators and λ-calculus. Volume 1 of London Mathematical Society Student texts. Cambridge University Press, 1986.**

这本书是 **Hindley** 和 **Seldin** 合著的 **《组合子和 λ-演算导论》**，是 λ-演算和组合子逻辑的经典教材，详细介绍了基础概念、定理和证明，对理论计算机科学的学生和研究者非常有用。

 **[30] Paul Hudak. The Haskell School of Expression: Learning Functional Programming through Multimedia. Cambridge University Press, 2000.**

**Hudak** 的这本书是学习 **Haskell** 语言的入门教材，通过多媒体应用的例子来教授函数式编程概念，适合对多媒体和图形感兴趣的读者。

 **[31] Gérard Huet. Résolution d'équations dans les langages d'ordre 1, 2, ..., ω. Thèse de doctorat d'état, Université Paris 7, 1976.**

**Huet** 的博士论文，研究了 **一阶、二阶直到 ω 阶语言中的方程求解** 问题。他的工作对统一算法和类型推断有重要贡献。

 **[32] Gérard Huet. The zipper. Journal of Functional Programming, 7(5):549–554, 1997.**

这篇论文发表在 1997 年的 **《函数式编程杂志》** 上，作者 **Huet** 提出了 **拉链（zipper）** 数据结构。这是一种用于高效遍历和更新树形结构的技术，在函数式编程中非常有用。

 **[33] Lalita A. Jategaonkar and John C. Mitchell. ML with extended pattern matching and subtypes (preliminary version). In Proceedings of the ACM Conference on Lisp and Functional Programming, pages 198–211, Snowbird, Utah, July 1988.**

这篇论文发表于 1988 年的 **Lisp 与函数式编程会议**，作者 **Jategaonkar** 和 **Mitchell** 讨论了具有扩展模式匹配和子类型的 ML 语言。他们的研究为 ML 语言引入更丰富的类型和模式匹配机制提供了思路。

 **[34] Trevor Jim. Principal typings and type inference. PhD thesis, Massachusetts Institute of Technology, 1996.**

**Jim** 的博士论文，研究了 **主类型（principal typings）** 和 **类型推断** 问题。他探讨了在类型推断过程中如何找到表达式的最泛化类型，为类型系统的理论研究做出了贡献。

 **[35] Trevor Jim. What are principal typings and what are they good for? In Principles of Programming Languages, pages 42–53, 1996.**

这篇论文发表于 1996 年的 **POPL**，作者 **Jim** 继续探讨了 **主类型** 的概念及其用途，解释了主类型在类型推断和编程语言设计中的重要性。

 **[36] Mark P. Jones. Qualified Types: Theory and Practice. Cambridge University Press, November 1994.**

**Jones** 的这本书详细讨论了 **限定类型（qualified types）** 的理论和实践。限定类型是一种类型系统扩展，允许在类型中包含约束条件，如类型类和子类型关系。该书对 Haskell 等语言的类型系统有重要影响。

 **[37] Mark P. Jones and Simon Peyton Jones. Lightweight extensible records for Haskell. In Proceedings of the 1999 Haskell Workshop, number UU-CS-1999-28 in Technical report, 1999.**

这篇论文发表于 1999 年的 **Haskell 研讨会**，作者 **Jones** 和 **Peyton Jones** 提出了 Haskell 中的 **轻量级可扩展记录**。他们的方案允许在 Haskell 中定义灵活的记录类型，支持记录的扩展和子类型化。

 **[38] Simon Peyton Jones and John Hughes. Report on the programming language Haskell 98. Technical report, http://www.haskell.org, 1999.**

这是 **Haskell 98** 语言的官方报告，由 **Peyton Jones** 和 **Hughes** 等人编写。该报告详细定义了 Haskell 98 的语法和语义，是 Haskell 语言的权威参考。

 **[39] Gilles Kahn. Natural semantics. In Symposium on Theoretical Aspects of Computer Science, pages 22–39, 1987.**

这篇论文发表于 1987 年的 **计算机科学理论方面研讨会（STACS）**，作者 **Kahn** 提出了 **自然语义（Natural Semantics）** 的概念。自然语义是一种用于描述编程语言语义的形式化方法，强调语义规则的直观性和简洁性。

 **[40] Claude Kirchner and Jean-Pierre Jouannaud. Solving equations in abstract algebras: a rule-based survey of unification. Research Report 561, Université de Paris Sud, Orsay, France, April 1990.**

这是一份研究报告，作者 **Kirchner** 和 **Jouannaud** 综述了 **抽象代数中方程求解** 的规则化方法，特别是 **统一算法**。他们的工作对逻辑编程和类型推断中的统一过程有重要影响。

 **[41] Konstantin Läufer and Martin Odersky. Polymorphic type inference and abstract data types. ACM Transactions on Programming Languages and Systems, 16(5):1411–1430, September 1994.**

这篇论文发表在 1994 年的 **《ACM 编程语言与系统汇刊》** 上，作者 **Läufer** 和 **Odersky** 研究了 **多态类型推断** 和 **抽象数据类型** 的结合。他们提出了一种在存在抽象数据类型的情况下进行多态类型推断的方法，解决了类型隐藏和多态性的兼容问题。

 **[42] Xavier Leroy. Polymorphic typing of an algorithmic language. Research report 1778, INRIA, 1992.**

这是 **Leroy** 在 1992 年发表的研究报告，讨论了对一种算法语言进行 **多态类型化** 的方法。他的工作为 ML 等语言的类型系统设计提供了理论支持。

 **[43] Xavier Leroy. Typage polymorphe d'un langage algorithmique. Thèse de doctorat, Université Paris 7, 1992.**

这是 **Leroy** 的博士论文，题为 **《一种算法语言的多态类型化》**。他在论文中深入研究了多态类型系统，特别是在编译器实现和类型推断方面的应用。

 **[44] Xavier Leroy. Applicative functors and fully transparent higher-order modules. In ACM Symposium on Principles of Programming Languages, pages 142–153. ACM Press, 1995.**

这篇论文发表于 1995 年的 **POPL**，作者 **Leroy** 讨论了 **应用函子** 和 **完全透明的高阶模块**。他提出了一种模块系统，支持高阶模块和模块间的透明组合，为模块化编程提供了新方法。

 **[45] Xavier Leroy. A syntactic theory of type generativity and sharing. Journal of Functional Programming, 6(5):667–698, 1996.**

这篇论文发表在 1996 年的 **《函数式编程杂志》** 上，作者 **Leroy** 提出了 **类型生成和共享** 的句法理论。他的研究为理解模块系统中的类型生成规则和类型共享机制提供了理论基础。

 **[46] Xavier Leroy. A modular module system. Journal of Functional Programming, 10(3):269–303, 2000.**

这篇论文发表在 2000 年的 **《函数式编程杂志》** 上，作者 **Leroy** 提出了一个 **模块化的模块系统**。他设计的模块系统支持模块的灵活组合和重用，提高了程序的模块化程度。

 **[47] Xavier Leroy and Michel Mauny. Dynamics in ML. Journal of Functional Programming, 3(4):431–463, 1993.**

这篇论文发表在 1993 年的 **《函数式编程杂志》** 上，作者 **Leroy** 和 **Mauny** 研究了 ML 语言中的 **动态性（Dynamics）**。他们探讨了在静态类型语言中引入动态类型的机制，提高了语言的灵活性。

 **[48] David B. MacQueen and Mads Tofte. A semantics for higher-order functors. In D. Sannella, editor, Programming languages and systems – ESOP '94, volume 788 of Lecture Notes in Computer Science, pages 409–423. Springer-Verlag, 1994.**

这篇论文发表于 1994 年的 **欧洲编程语言研讨会（ESOP'94）**，作者 **MacQueen** 和 **Tofte** 为 **高阶函子** 提出了语义描述。他们的工作为理解模块系统中的高阶组合和类型检查提供了理论支持。

 **[49] Alberto Martelli and Ugo Montanari. An efficient unification algorithm. ACM Transactions on Programming Languages and Systems, 4(2):258–282, 1982.**

这篇论文发表在 1982 年的 **《ACM 编程语言与系统汇刊》** 上，作者 **Martelli** 和 **Montanari** 提出了一个 **高效的统一算法**。他们的算法在逻辑编程和类型推断中得到了广泛应用。

 **[50] Robin Milner and Mads Tofte. Commentary on Standard ML. The MIT Press, 1991.**

这是 **Milner** 和 **Tofte** 的 **《Standard ML 注释》**，由 MIT Press 于 1991 年出版。该书对 Standard ML 语言的定义进行了详细的注释和解释，是学习 SML 的重要参考。

 **[51] Robin Milner, Mads Tofte, Robert Harper, and David MacQueen. The definition of Standard ML (revised). The MIT Press, 1997.**

这本书是 **Standard ML** 语言的正式定义，由 **Milner**、**Tofte**、**Harper** 和 **MacQueen** 编写。1997 年的修订版是 SML 的权威规范，详细定义了语言的语法、语义和类型系统。

 **[52] John C. Mitchell. Foundations for Programming Languages. MIT Press, 1996.**

**Mitchell** 的这本书是关于 **编程语言基础** 的教科书，涵盖了类型系统、程序语义、编程语言设计等主题，为计算机科学学生和研究者提供了全面的知识体系。

 **[53] Martin Odersky and Konstantin Läufer. Putting type annotations to work. In Proceedings of the 23th ACM Conference on Principles of Programming Languages, pages 54–67, January 1996.**

这篇论文发表于 1996 年的 **POPL**，作者 **Odersky** 和 **Läufer** 讨论了 **类型注释** 的实际应用。他们研究了如何在程序中有效地使用类型注释，提高类型系统的表达能力和类型推断的效率。

 **[54] Martin Odersky, Martin Sulzmann, and Martin Wehr. Type inference with constrained types. TAPOS, 5(1), 1999.**

这篇论文发表在 1999 年的 **《Theoretical Aspects of Programming Languages》** 上，作者 **Odersky**、**Sulzmann** 和 **Wehr** 研究了具有约束类型的 **类型推断** 问题。他们提出了一种类型推断算法，能够处理类型变量之间的约束条件。

 **[55] Martin Odersky, Philip Wadler, and Martin Wehr. A second look at overloading. In Proc. ACM Conf. on Functional Programming and Computer Architecture, pages 135–146, June 1995.**

这篇论文发表于 1995 年的 **函数式编程与计算机体系结构会议（FPCA'95）**，作者 **Odersky**、**Wadler** 和 **Wehr** 重新审视了 **重载** 的概念。他们提出了在函数式编程语言中实现重载的新方法，解决了类型安全和类型推断的问题。

 **[56] Martin Odersky, Christoph Zenger, and Matthias Zenger. Colored local type inference. In ACM Symposium on Principles of Programming Languages, 2001.**

这篇论文发表于 2001 年的 **POPL**，作者 **Odersky**、**Christoph Zenger** 和 **Matthias Zenger** 提出了 **着色局部类型推断** 的方法。他们的研究改进了类型推断算法，提高了编译器的性能和类型错误定位的准确性。

 **[57] Atsushi Ohori. A polymorphic record calculus and its compilation. ACM Transactions on Programming Languages and Systems, 17(6):844–895, 1996.**

这篇论文发表在 1996 年的 **《ACM 编程语言与系统汇刊》** 上，作者 **Ohori** 提出了 **多态记录演算** 及其编译方法。他的工作为在函数式语言中支持多态记录类型提供了理论和实践支持。

 **[58] Lawrence C. Paulson. ML for the working programmer. Cambridge University Press, 1991.**

**Paulson** 的这本书是 **《为程序员准备的 ML》**，由剑桥大学出版社于 1991 年出版。该书是学习 ML 语言的经典教材，涵盖了语言的各个方面，包括函数式编程、模块化和类型系统。

 **[59] Benjamin C. Pierce. Bounded quantification is undecidable. Information and Computation, 112(1):131–165, July 1994.**

这篇论文发表在 1994 年的 **《信息与计算》** 杂志上，作者 **Pierce** 证明了 **有界量化** 是不可判定的。他的工作对类型系统的研究，特别是涉及子类型多态性的类型系统，具有重要意义。

 **[60] Benjamin C. Pierce and David N. Turner. Local type inference. In Proceedings of the 25th ACM Conference on Principles of Programming Languages, 1998. Full version available as Indiana University CSCI Technical Report 493.**

这篇论文发表于 1998 年的 **POPL**，作者 **Pierce** 和 **Turner** 提出了 **局部类型推断** 的概念。他们的研究旨在在更高级的类型系统中实现类型推断，同时减少对类型注释的需求。

 **[61] G. D. Plotkin. A Structural Approach to Operational Semantics. Technical Report DAIMI FN-19, University of Aarhus, 1981.**

**Plotkin** 的这份技术报告提出了 **操作语义的结构化方法**，是编程语言语义理论的重要贡献。他定义了 **自然操作语义**，提供了一种系统化的方法来描述编程语言的执行行为。

 **[62] François Pottier. Simplifying subtyping constraints: a theory. To appear in Information & Computation, August 2000.**

这篇论文由 **Pottier** 撰写，研究了 **简化子类型约束** 的理论。通过对类型系统中的子类型约束进行简化，提高了类型推断的效率和可理解性。

 **[63] Didier Rémy. Extending ML type system with a sorted equational theory. Research Report 1766, Institut National de Recherche en Informatique et Automatisme, Rocquencourt, BP 105, 78 153 Le Chesnay Cedex, France, 1992.**

**Rémy** 的研究报告，讨论了通过引入排序的等式理论来扩展 ML 的类型系统。他的工作为类型系统增加了更强的表达能力。

 **[64] Didier Rémy. Programming objects with ML-ART: An extension to ML with abstract and record types. In Masami Hagiya and John C. Mitchell, editors, International Symposium on Theoretical Aspects of Computer Software, number 789 in Lecture Notes in Computer Science, pages 321–346, Sendai, Japan, April 1994. Springer-Verlag.**

这篇论文发表于 1994 年的 **计算机软件理论方面国际研讨会（TACS'94）**，作者 **Rémy** 介绍了 **ML-ART**，这是对 ML 的扩展，支持抽象类型和记录类型。他展示了如何在 ML 中编程对象，为 ML 的面向对象扩展提供了基础。

 **[65] Didier Rémy. Type inference for records in a natural extension of ML. In Carl A. Gunter and John C. Mitchell, editors, Theoretical Aspects Of Object-Oriented Programming. Types, Semantics and Language Design. MIT Press, 1994.**

这篇论文收录在 1994 年的 **《面向对象编程的理论方面》** 一书中，作者 **Rémy** 讨论了在 ML 的自然扩展中对记录类型进行类型推断的方法。他的工作为在 ML 中引入记录类型提供了理论支持。

 **[66] Didier Rémy and Jérôme Vouillon. Objective ML: An effective object-oriented extension to ML. Theory And Practice of Object Systems, 4(1):27–50, 1998.**

这篇论文发表在 1998 年的 **《对象系统的理论与实践》** 期刊上，作者 **Rémy** 和 **Vouillon** 介绍了 **Objective ML**，这是 ML 的一种有效的面向对象扩展。他们详细描述了语言的设计、类型系统和实现细节。

 **[67] John C. Reynolds. Theories of Programming Languages. Cambridge University Press, 1998.**

**Reynolds** 的这本书是关于 **编程语言理论** 的权威著作，涵盖了类型系统、程序语义、逻辑和验证等主题，为计算机科学研究者提供了深入的理论基础。

 **[68] Jon G. Riecke and Christopher A. Stone. Privacy via subsumption. Theory and Practice of Object Systems, 1999.**

这篇论文发表在 1999 年的 **《对象系统的理论与实践》** 期刊上，作者 **Riecke** 和 **Stone** 研究了通过 **包含（subsumption）** 来实现 **隐私** 的方法。他们的工作与类型系统和访问控制相关。

 **[69] Claudio V. Russo. Types for modules. PhD thesis, University of Edinburgh, 1998.**

**Russo** 的博士论文，研究了模块系统的类型问题。他提出了模块类型的理论，为模块化编程语言的设计和实现提供了参考。

 **[70] Simon Thompson. Haskell: the craft of functional programming. Addison-Wesley, 1999.**

**Thompson** 的这本书是学习 **Haskell** 的教材，强调函数式编程的实践技巧。该书涵盖了 Haskell 语言的基础和高级特性，适合希望深入掌握 Haskell 的读者。

 **[71] Jérôme Vouillon. Combining subsumption and binary methods: An object calculus with views. In ACM Symposium on Principles of Programming Languages. ACM Press, 2000.**

这篇论文发表于 2000 年的 **POPL**，作者 **Vouillon** 讨论了结合包含和二元方法的对象演算，提出了带有视图（views）的对象模型。他的研究为面向对象语言的类型系统提供了新视角。

 **[72] Jérôme Vouillon. Conception et réalisation d'une extension du langage ML avec des objets. Thèse de doctorat, Université Paris 7, October 2000.**

这是 **Vouillon** 的博士论文，题为 **《具有对象的 ML 语言扩展的设计与实现》**。他在论文中详细介绍了对 ML 语言的面向对象扩展，包括类型系统、语义和编译器实现。

 **[73] Mitchell Wand. Complete type inference for simple objects. In D. Gries, editor, Second Symposium on Logic In Computer Science, pages 207–276, Ithaca, New York, June 1987. IEEE Computer Society Press.**

这篇论文发表于 1987 年的 **第二届计算机科学逻辑研讨会（LICS）**，作者 **Wand** 研究了对简单对象进行完全类型推断的方法。他的工作为面向对象语言的类型系统提供了理论支持。

 **[74] Pierre Weis and Xavier Leroy. Le langage Caml. Dunod, 1999.**

这本书是 **Weis** 和 **Leroy** 合著的 **《Caml 语言》**，由 Dunod 于 1999 年出版。该书全面介绍了 Caml 语言的语法、语义和编程技术，是学习 Caml 的重要参考。

 **[75] Joe B. Wells. Typability and type checking in system F are equivalent and undecidable. Annals of Pure and Applied Logic, 98(1–3):111–156, 1999.**

这篇论文发表在 1999 年的 **《纯粹与应用逻辑年鉴》** 上，作者 **Wells** 证明了在 System F 中，类型化（typability）和类型检查是等价且不可判定的。他的工作对理解高级类型系统的限制具有重要意义。

 **[76] Joe B. Wells. The essence of principal typings. In Proceedings of the 29th International Colloquium on Automata, Languages, and Programming, LNCS. Springer-Verlag, 2002.**

这篇论文发表于 2002 年的 **自动机、语言和编程国际研讨会（ICALP）**，作者 **Wells** 探讨了 **主类型** 的本质。他深入分析了主类型的定义、性质和在类型推断中的作用。

 **[77] Andrew K. Wright and Matthias Felleisen. A syntactic approach to type soundness. Information and Computation, 115(1):38–94, 1994.**

这篇论文发表在 1994 年的 **《信息与计算》** 杂志上，作者 **Wright** 和 **Felleisen** 提出了 **类型健全性** 的句法方法。他们的研究为证明编程语言的类型系统的健全性提供了一种系统化的技术。

**总结**

这份参考文献列表汇集了编程语言理论、类型系统、函数式编程和面向对象编程等领域的经典著作和重要论文。通过对每一项参考文献的详细解读，我们可以看到这些工作在不同方面推动了计算机科学的发展：

- **类型系统和类型推断**：多篇论文和书籍探讨了类型系统的设计、类型推断算法、主类型方案，以及类型系统的限制和不可判定性。
- **λ-演算和语义理论**：多位学者的著作深入研究了 λ-演算、组合子逻辑和编程语言的语义，为函数式编程和程序验证奠定了基础。
- **模块系统和多态性**：关于模块系统、Mixin 模块、多态类型和类型约束的研究为编程语言的模块化和可重用性提供了理论支持。
- **面向对象编程和对象理论**：对对象演算、二元方法、虚拟类型和对象类型系统的研究丰富了面向对象编程语言的理论框架。
- **函数式编程语言的设计与实现**：多本书籍和论文介绍了 Haskell、ML、OCaml 等函数式编程语言的设计原理、类型系统和编程技巧，为学习和使用这些语言提供了重要资源。
总的来说，这些参考文献反映了计算机科学在编程语言理论和实践方面的丰富成果，为研究者和开发者提供了宝贵的知识和启示。通过深入理解这些工作，我们可以更好地掌握编程语言的原理和技术，推动新的语言和工具的开发。
  



**宏观概览**

《Using, Understanding, and Unravelling The OCaml Language — An Introduction》是一部关于 **OCaml 编程语言** 的全面导论。全书旨在带领读者深入了解 OCaml，从核心语言特性到高级概念，逐步揭示其语法、语义和类型系统。该书结构清晰，内容循序渐进，适合对 OCaml 或函数式编程语言感兴趣的读者。

全书共分为五章和两个附录：

1. **引论**：介绍核心 ML 语言的基础，包括语法、动态语义和静态语义，以及递归的概念。
2. **OCaml 核心**：扩展核心 ML，涵盖 OCaml 中的数据类型、模式匹配、可变存储和异常处理。
3. **对象层**：深入探讨 OCaml 的面向对象特性，包括对象、类、多态性、子类型和参数化类。
4. **模块语言**：介绍 OCaml 的模块系统，讨论模块的使用和理解，以及高级用法。
5. **混合模块与对象**：探讨如何将模块和对象结合使用，实现更复杂的程序结构。
此外，书中还提供了两个附录，帮助读者更好地掌握 OCaml 的实践应用：

- **附录 A：OCaml 的第一步**：提供 OCaml 编程的入门指南。
- **附录 B：变体与标签参数**：介绍 OCaml 中的变体类型和带标签的参数。
以下将按照章节和小节，对全书内容进行详细解析，揭示各部分的主要内容及其内在联系。

**第1章 引论**

**整体概述：**

第1章作为全书的引论，旨在引导读者 **发现核心 ML 语言**，这是 OCaml 的基础。该章详细介绍了核心 ML 的语法、动态语义和静态语义，并探讨了递归的概念。通过这一章，读者将理解 ML 语言的基本结构和工作原理，为后续深入学习 OCaml 做好准备。

**1.1 发现核心 ML**

- **内容：** 本节引导读者初识核心 ML，介绍其基本特性和编程范式。
- **作用：** 奠定基础，使读者了解 ML 语言的重要性和在 OCaml 中的地位。
**1.2 核心 ML 的语法**

- **内容：** 详细描述核心 ML 的语法规则，包括表达式、函数、变量绑定等。
- **作用：** 帮助读者掌握 ML 的语法结构，为理解后续的语义和类型系统做准备。
**1.3 核心 ML 的动态语义**

- **内容：** 解释核心 ML 程序的执行方式，即动态语义。
- **1.3.1 归约语义****内容：** 介绍通过归约规则描述程序计算过程的方法。**作用：** 帮助读者理解函数式语言的执行机制。
- **1.3.2 归约的属性****内容：** 讨论归约过程的性质，如终止性和一致性。**作用：** 深化对归约语义的理解，强调其重要特性。
- **1.3.3 大步操作语义****内容：** 引入大步操作语义，作为描述程序执行的另一种方法。**作用：** 为读者提供不同的语义视角，理解程序如何求值。
**1.4 核心 ML 的静态语义**

- **内容：** 探讨核心 ML 的静态语义，即类型系统。
- **1.4.1 类型与程序****内容：** 解释类型在程序中的角色，以及如何为程序中的元素赋予类型。**作用：** 强调类型系统在确保程序正确性方面的作用。
- **1.4.2 类型推断****内容：** 介绍 ML 的类型推断机制，如何自动为无类型注释的程序推断类型。**作用：** 展示 ML 语言的强大之处，减少程序员的负担。
- **1.4.3 简单类型的统一****内容：** 讨论类型推断中的关键技术——统一算法。**作用：** 帮助读者理解类型推断的内部工作原理。
- **1.4.4 多态性****内容：** 介绍多态类型，解释如何编写通用的、多态的函数。**作用：** 扩展类型系统的能力，使程序更具通用性和复用性。
**1.5 递归**

- **内容：** 探讨递归在函数式编程中的重要性。
- **1.5.1 不动点组合子****内容：** 介绍不动点组合子（如 Y 组合子），用于定义递归函数。**作用：** 展示在无显式递归支持的情况下，如何实现递归。
- **1.5.2 递归类型****内容：** 讨论类型系统中支持递归类型的必要性。**作用：** 使读者了解定义自引用数据结构的方法。
- **1.5.3 类型推断与类型检查****内容：** 区分类型推断和类型检查的过程和作用。**作用：** 强调类型系统的不同层面，理解编译器如何处理类型。
**第2章 OCaml核心**

**整体概述：**

第2章在核心 ML 的基础上，介绍了 OCaml 的核心特性，包括数据类型、模式匹配、可变存储和异常处理。通过这一章，读者将学习到 OCaml 特有的语法和功能，以及如何在实际编程中应用这些特性。

**2.1 数据类型与模式匹配**

- **内容：** 详细讨论 OCaml 中的数据类型定义和模式匹配机制。
- **2.1.1 OCaml 中的示例****内容：** 提供具体的 OCaml 代码示例，展示数据类型和模式匹配的用法。**作用：** 通过实践案例，加深对概念的理解。
- **2.1.2 表面模式匹配的形式化****内容：** 从理论角度形式化描述模式匹配的行为和规则。**作用：** 提供对模式匹配机制的深入理解，确保读者不仅会用，还理解其原理。
- **2.1.3 递归数据类型定义****内容：** 介绍如何定义递归的数据类型，如列表和树。**作用：** 帮助读者创建复杂的数据结构，支持递归算法。
- **2.1.4 类型缩写****内容：** 讨论类型别名和类型缩写，简化类型表达。**作用：** 提高代码的可读性和可维护性。
- **2.1.5 记录类型****内容：** 介绍记录类型的定义和使用。**作用：** 教授如何创建带有命名字段的数据结构。
**2.2 可变存储与副作用**

- **内容：** 探讨 OCaml 中的可变存储（如引用、数组）和副作用。
- **2.2.1 存储的形式化****内容：** 从理论上形式化描述存储模型和状态变化。**作用：** 理解可变状态如何影响程序的执行和语义。
- **2.2.2 类型健全性****内容：** 讨论在引入可变存储后，如何保持类型系统的健全性。**作用：** 确保程序的类型安全，防止类型错误。
- **2.2.3 存储与多态性****内容：** 探讨可变存储对多态类型的影响，特别是类型变量的泛化问题。**作用：** 理解为什么某些情况下需要限制多态性，以保证安全。
- **2.2.4 多字段可变记录****内容：** 介绍具有多个可变字段的记录类型的使用。**作用：** 教授如何在数据结构中结合可变性，实现复杂的状态管理。
**2.3 异常**

- **内容：** 介绍 OCaml 的异常处理机制。
- **作用：** 教授如何在程序中使用异常来处理错误和异常情况，提高程序的健壮性。
**第3章 对象层**

**整体概述：**

第3章深入探讨 OCaml 的面向对象特性，介绍对象和类的定义与使用，以及与多态性、子类型和参数化类的关系。通过这一章，读者将学习如何在 OCaml 中应用面向对象的编程范式，理解其类型系统支持。

**3.1 发现对象与类**

- **内容：** 引导读者初步了解 OCaml 中的对象和类。
- **3.1.1 基本示例****内容：** 提供简单的对象和类的示例，展示其基本用法。**作用：** 帮助读者熟悉语法和基本概念。
- **3.1.2 多态性、子类型与参数化类****内容：** 讨论对象系统中的多态性、子类型关系，以及如何定义参数化类。**作用：** 扩展对象系统的能力，使其更灵活和通用。
**3.2 理解对象与类**

- **内容：** 深入探讨对象和类的内部工作原理，特别是类型系统方面。
- **3.2.1 对象的类型检查****内容：** 解释如何对对象进行类型检查，确保方法调用的安全性。**作用：** 理解 OCaml 如何在类型系统中支持对象，多态和子类型。
- **3.2.2 类的类型化****内容：** 讨论类的类型，以及如何为类定义类型签名。**作用：** 确保类的实例化和继承过程中类型的正确性。
**3.3 对象的高级用法**

- **内容：** 探索对象和类的高级特性，如继承、方法重写和多态。
- **作用：** 教授如何利用这些特性构建复杂的对象体系结构，提高代码的可重用性和扩展性。
**第4章 模块语言**

**整体概述：**

第4章介绍 OCaml 的模块系统，这是组织大型程序的关键。模块提供了命名空间和封装机制，支持代码的重用和抽象。该章讨论了模块的使用、理解和高级用法。

**4.1 使用模块**

- **内容：** 教授如何在 OCaml 中定义和使用模块。
- **4.1.1 基本模块****内容：** 介绍模块的基本定义和使用方法。**作用：** 帮助读者掌握模块的基础知识。
- **4.1.2 参数化模块****内容：** 讨论带有参数的模块（函子），允许模块接受其他模块作为参数。**作用：** 提供模块之间的依赖和组合方式，提高代码的灵活性。
**4.2 理解模块**

- **内容：** 深入探讨模块系统的工作原理和类型系统支持。
- **作用：** 理解模块如何实现封装、抽象和类型安全。
**4.3 模块的高级用法**

- **内容：** 探索模块系统的高级特性，如高级的模块签名、抽象和模块级的多态性。
- **作用：** 教授如何利用模块系统构建大型、可维护的代码库。
**第5章 混合模块与对象**

**整体概述：**

第5章探讨了如何将模块和对象结合使用，以充分利用两者的优势。通过讨论模块和对象的重叠，以及如何将类作为模块组件或预模块，读者将学习到在 OCaml 中构建复杂系统的新方法。

**5.1 重叠**

- **内容：** 讨论模块和对象之间的重叠区域，以及如何协调两者的使用。
- **作用：** 理解模块和对象的相似性和差异性，找到最佳的组合方式。
**5.2 组合模块与类**

- **内容：** 探索将模块和类组合的方法。
- **5.2.1 类作为模块组件****内容：** 介绍如何在模块中包含类，模块管理类的集合。**作用：** 利用模块的封装性，组织和管理类。
- **5.2.2 类作为预模块****内容：** 讨论将类视为模块的预定义结构，利用模块的参数化特性。**作用：** 提供更灵活的类定义和复用方式。
**进一步阅读**

- **内容：** 提供相关的参考资料和延伸阅读建议。
- **作用：** 引导读者进一步深入学习 OCaml 及相关理论。
**附录 A：OCaml 的第一步**

- **内容：** 提供 OCaml 编程的入门指南，包括环境配置、基本语法和简单示例。
- **作用：** 帮助新手快速上手 OCaml，为正式学习做好准备。
**附录 B：变体与标签参数**

**整体概述：**

附录 B 介绍了 OCaml 中的两个重要特性：变体类型和标签参数。通过对这些特性的学习，读者可以编写更灵活和可读性更高的代码。

**B.1 变体类型**

- **内容：** 介绍变体类型的定义和使用，包括多态变体和模式匹配。
- **作用：** 教授如何使用变体类型来表示复杂的数据结构和情况。
**B.2 标签参数**

- **内容：** 讨论函数的标签参数，如何在函数定义和调用中使用参数标签。
- **作用：** 提高代码的可读性，防止参数顺序错误。
**B.3 可选参数**

- **内容：** 介绍可选参数的使用，允许函数参数有默认值。
- **作用：** 提供函数调用的灵活性，简化代码。
**总结**

通过以上的详细解析，可以看出全书从基础到高级，循序渐进地介绍了 OCaml 语言的各个方面。每一章都在前一章的基础上，深入探讨新的概念和特性。章节之间有着紧密的联系：

- **第1章** 为全书奠定了理论基础，介绍了核心 ML 语言的语法和语义。
- **第2章** 在此基础上，引入了 OCaml 的特有特性，扩展了读者的视野。
- **第3章** 和 **第4章** 分别深入探讨了 OCaml 的对象系统和模块系统，两者都是组织代码和实现抽象的重要工具。
- **第5章** 将对象和模块结合，展示了如何构建复杂而灵活的程序结构。
- **附录 A** 和 **附录 B** 提供了实用的编程指南和特性介绍，帮助读者在实践中应用所学知识。
整本书的结构设计合理，每一节都承上启下，既巩固了前面的内容，又为后续的学习做好了铺垫。通过对各章节和小节的学习，读者将全面掌握 OCaml 语言的使用、理解和应用，具备在实际项目中使用 OCaml 的能力。
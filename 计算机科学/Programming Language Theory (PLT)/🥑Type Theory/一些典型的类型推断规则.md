

图中展示的是一些典型的类型推断规则，用于形式化程序语言中表达式和语句的类型检查过程。这些规则通常用于设计和实现类型检查器或编译器的类型系统部分。下面是对每个规则的解释：

1. **变量（Variable, [Var]）**:
   - **语法**：`(x : σ) ∈ Γ`
   - **规则**：`Γ ⊢ x : σ`
   - **描述**：如果变量 `x` 的类型 `σ` 存在于环境 `Γ` 中，则 `x` 的类型为 `σ`。

2. **应用（Application, [App]）**:
   - **语法**：`Γ ⊢ e1 : τ1 → τ2` 和 `Γ ⊢ e2 : τ1`
   - **规则**：`Γ ⊢ (e1 e2) : τ2`
   - **描述**：如果表达式 `e1` 是一个函数，它将类型 `τ1` 映射到类型 `τ2`，并且 `e2` 的类型为 `τ1`，则应用函数 `e1` 到 `e2` 的结果类型为 `τ2`。

3. **抽象（Abstraction, [Abs]）**:
   - **语法**：`Γ, x : τ1 ⊢ e : τ2`
   - **规则**：`Γ ⊢ (λx.e) : τ1 → τ2`
   - **描述**：如果在包含 `x:τ1` 的环境中，表达式 `e` 的类型为 `τ2`，则函数定义 `(λx.e)` 的类型为从 `τ1` 到 `τ2` 的函数。

4. **变量声明（Let, [Let]）**:
   - **语法**：`Γ ⊢ e1 : σ` 和 `Γ, x : σ ⊢ e2 : τ`
   - **规则**：`Γ ⊢ (let (x = e1) in e2) : τ`
   - **描述**：如果 `e1` 的类型为 `σ` 并且在添加了 `x : σ` 到环境 `Γ` 后，`e2` 的类型为 `τ`，则 `let` 表达式的类型为 `τ`。

5. **子类型（Subtyping, [Inst]）**:
   - **语法**：`Γ ⊢ e : σ1` 且 `σ1 ⊆ σ2`
   - **规则**：`Γ ⊢ e : σ2`
   - **描述**：如果 `e` 的类型为 `σ1`，并且 `σ1` 是 `σ2` 的子类型，那么 `e` 的类型也可以是 `σ2`。

6. **泛化类型（Type Generalization, [Gen]）**:
   - **语法**：`Γ ⊢ e : σ` 且 `α ∉ free(Γ)`
   - **规则**：`Γ ⊢ e : ∀α.σ`
   - **描述**：如果在环境 `Γ` 中，表达式 `e` 的类型为 `σ`，并且类型变量 `α` 不是 `Γ` 中自由变量的一部分，那么 `e` 的类型可以泛化为 `∀α.σ`。

这些规则是类型系统的核心，帮助确保程序的类型安全性，防止运行时的类型错误，以及支持类型的多态和复用。
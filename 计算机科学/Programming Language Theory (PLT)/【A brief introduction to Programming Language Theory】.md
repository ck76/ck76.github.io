



## ç¼–ç¨‹è¯­è¨€ç†è®ºç®€ä»‹

å¤§å¤šæ•°å¼€å‘äººå‘˜ä¸“æ³¨äºå­¦ä¹ â€œå¦‚ä½•â€ç¼–ç¨‹ï¼Œè€Œä¸æ˜¯æ¶ˆè€—é˜è¿°åº•å±‚ç†è®ºåŸºç¡€çš„ææ–™ã€‚ä»¥ä¸‹å¯¹ PLT çš„ä»‹ç»ä¸åŒ…æ‹¬è¯æ˜æˆ–æ„å»ºæ·±åˆ»çš„æ•°å­¦ç›´è§‰ã€‚ç›¸åï¼Œç›®æ ‡æ˜¯ç†Ÿæ‚‰æ ¸å¿ƒæ¦‚å¿µå’Œç ”ç©¶é¢†åŸŸã€‚

1. **[å›¾çµå®Œå¤‡æ€§](https://en.wikipedia.org/wiki/Turing_completeness)ã€‚**æ­¤å±æ€§å®šä¹‰äº†è¢«è§†ä¸ºçœŸæ­£çš„ç¼–ç¨‹è¯­è¨€æ‰€éœ€çš„æ ‡å‡†ã€‚ç¼–ç¨‹è¯­è¨€æ˜¯ç”±ä¸€ç»„ç”¨äºå°†æŒ‡ä»¤ç¿»è¯‘ç»™è®¡ç®—æœºçš„è§„åˆ™å®šä¹‰çš„[å½¢å¼è¯­è¨€](https://en.wikipedia.org/wiki/Formal_language)ã€‚è¿™äº›è§„åˆ™æŒ‡å®šäº†ä¸è®¡ç®—æœºé€šä¿¡çš„å¯æ¥å—çš„æ–¹å¼ã€‚å›¾çµæœºæ˜¯ä¸€ç§æŠ½è±¡è®¡ç®—æœºçš„æ•°å­¦æ¨¡å‹ï¼Œèƒ½å¤Ÿé€šè¿‡æ¨¡æ‹Ÿå…¶é€»è¾‘æ¥å®ç°ä»»ä½•ç®—æ³•ã€‚å½“ä¸€ä¸ªå¯ä»¥æ¨¡æ‹Ÿå›¾çµæœºçš„ç³»ç»Ÿä¹Ÿå¯ä»¥å®ç°ä»»ä½•ç®—æ³•æ—¶â€”â€”å®ƒè¢«ç§°ä¸ºå›¾çµå®Œå¤‡ã€‚è¿™é€šå¸¸è¦æ±‚è¯­è¨€èƒ½å¤Ÿæ‹¥æœ‰[çŠ¶æ€](https://en.wikipedia.org/wiki/State_(computer_science))ï¼ˆå³å˜é‡ï¼‰å’Œæ¡ä»¶é€»è¾‘ã€‚æ ¹æ®è¿™ä¸ªå®šä¹‰ï¼Œ[ HTML](https://stackoverflow.com/questions/30719221/is-html-turing-complete)ä¸æ˜¯å›¾çµå®Œå¤‡çš„ï¼Œä½†[lambda æ¼”ç®—](https://en.wikipedia.org/wiki/Lambda_calculus)æ˜¯ã€‚
2. **[å¯åˆ¤å®šæ€§å’Œåœæ­¢é—®é¢˜](https://en.wikipedia.org/wiki/Halting_problem)ã€‚**è‰¾ä¼¦Â·å›¾çµåœ¨ä»–çš„å¼€åˆ›æ€§å·¥ä½œä¸­è¯æ˜ï¼Œæ²¡æœ‰é€šç”¨ç®—æ³•å¯ä»¥ç”¨æ¥ç¡®å®šç¨‹åºæ˜¯å¦ä¼šå› æ‰€æœ‰å¯èƒ½çš„è¾“å…¥è€Œç»ˆæ­¢ï¼ˆå°½ç®¡æˆ‘ä»¬å¯ä»¥ä¸ºæŸäº›ç¨‹åºè¾“å…¥å¯¹çš„é¢„æœŸè¡Œä¸ºå»ºæ¨¡ï¼‰ã€‚è¿™ç§°ä¸ºåœæœºé—®é¢˜ã€‚å¯åˆ¤å®šé—®é¢˜æ˜¯å¯ä»¥è§£å†³çš„é—®é¢˜ã€‚å› æ­¤ï¼Œåœæœºé—®é¢˜æ˜¯*ä¸å¯åˆ¤å®šçš„*ã€‚ç›¸åï¼Œå¯åˆ¤å®šçš„é—®é¢˜æ˜¯å¯ä»¥æ„å»ºä¸€ç§å§‹ç»ˆå¾—å‡ºæ­£ç¡®çš„æ˜¯æˆ–å¦ç­”æ¡ˆçš„ç®—æ³•çš„é—®é¢˜ã€‚
3. **[ç±»å‹è®º](https://en.wikipedia.org/wiki/Type_theory)ã€‚**è¿™æ˜¯ç¼–ç¨‹è¯­è¨€ä¸­ç±»å‹ç³»ç»Ÿçš„æ•°å­¦åŸºç¡€ã€‚å®ƒæ„æˆäº†ç¼–è¯‘å™¨ä¸­ç±»å‹æ£€æŸ¥ç®—æ³•çš„å†…éƒ¨é€»è¾‘ã€‚ç±»å‹ç†è®ºæ¡†æ¶å…è®¸æˆ‘ä»¬è¯„ä¼°å’Œè®¡ç®—è¯æ˜ä¸ºä»€ä¹ˆæŸäº›ç±»å‹åº”è¯¥æˆ–ä¸åº”è¯¥å­˜åœ¨äºå¼ºç±»å‹è¯­è¨€ä¸­ã€‚ç±»å‹æ˜¯å®šä¹‰è¯­è¨€ä¸åŒéƒ¨åˆ†ä¹‹é—´æ¥å£å¹¶ç¡®ä¿ç¨‹åºä¸€è‡´è¿æ¥çš„ä¸€ç§æ–¹å¼ã€‚åœ¨å‡½æ•°å¼ç¼–ç¨‹ä¸­ï¼Œç±»å‹ç†è®ºè¡¨æ˜ç±»å‹åº”è¯¥è¡¨è¾¾ç¼–ç¨‹è¯­è¨€è¦åšä»€ä¹ˆï¼ˆä»è¿™äº›ç±»å‹å…·ä½“åŒ–çš„ lambda æ¼”ç®—å°±æ˜¯è¯­è¨€æœ¬èº«ï¼‰ã€‚è¿™æ„å‘³ç€ç†Ÿæ‚‰æŸäº›ç±»å‹ç†è®ºä¸ºæ›´å¥½åœ°ç†è§£å…·æœ‰ä¸°å¯Œç±»å‹ç³»ç»Ÿçš„é™æ€è¯­è¨€ï¼ˆä¾‹å¦‚ Haskellï¼‰å¥ å®šäº†åŸºç¡€ã€‚ç±»å‹ç†è®ºæœ¬è´¨ä¸Šæ˜¯ç ”ç©¶ç±»å‹ç³»ç»Ÿï¼Œå®ƒå®šä¹‰äº†è¯­è¨€çš„ç»„ç»‡è§„åˆ™ã€‚[ Hindley-Milner ç±»å‹](http://dev.stephendiehl.com/fun/006_hindley_milner.html)ç³»ç»Ÿæ˜¯ä¸€ä¸ªæœ‰è¶£çš„ç±»å‹ï¼Œå®ƒä½¿ç”¨[ç»Ÿä¸€](http://dev.stephendiehl.com/fun/006_hindley_milner.html#unification)ä¸ºéç±»å‹åŒ–è¯­æ³•æä¾›ç±»å‹æ¨æ–­åŠŸèƒ½ã€‚
4. **[é›†åˆè®º](https://en.wikipedia.org/wiki/Set_theory)**ã€‚é›†åˆæ˜¯å¯¹è±¡çš„é›†åˆã€‚è¿™äº›é›†åˆå…·æœ‰è¿ç®—ï¼ˆä¾‹å¦‚[äº¤é›†ã€å¹¶é›†å’Œè¡¥é›†](https://www.probabilitycourse.com/chapter1/1_2_2_set_operations.php)ï¼‰ã€‚æ ¹æ®å½¢å¼è¯­è¨€ç†è®ºï¼Œè¯­è¨€æ˜¯ä¸€*ç»„*å­—ç¬¦ä¸²ã€‚æ•°æ®ç»“æ„æœ¬èº«ä¹Ÿå¯ä»¥è¢«è§†ä¸ºå…·æœ‰é›†åˆè¿ç®—çš„å„ç§å®ç°çš„é›†åˆã€‚é›†åˆè®ºåœ¨æ¦‚å¿µä¸Šä¸ç¼–ç¨‹ç›¸å…³çš„ä¸€ç§æ˜ç¡®æ–¹å¼æ˜¯é€šè¿‡å…³ç³»æ•°æ®åº“ï¼ˆå…¶ä¸­æ•°æ®åº“æ˜¯é›†åˆä¸Šçš„å…³ç³»ï¼‰ã€‚
5. **[èŒƒç•´è®º](https://en.wikipedia.org/wiki/Category_theory)**ã€‚èŒƒç•´è®ºæ¦‚æ‹¬äº†æ•°å­¦çš„å‡ ä¸ªåˆ†æ”¯ã€‚å®ƒé€šè¿‡æä¾›é€šç”¨çš„â€œå…ƒâ€è¯­è¨€æ¥æŠ½è±¡åœ°å»ºæ¨¡æ¦‚å¿µæ¥å®ç°è¿™ä¸€ç‚¹ã€‚è¿™æ˜¯éå¸¸æœ‰ç”¨çš„ï¼Œå› ä¸ºå®ƒå…è®¸æˆ‘ä»¬æ¨ç†å…³ç³»ç½‘ç»œï¼Œè€Œä¸æ˜¯å…³å¿ƒç‰¹å®šç³»ç»Ÿçš„ç»†èŠ‚ã€‚ç±»åˆ«*æ˜¯*å¯¹è±¡çš„é›†åˆã€‚è¿™äº›å¯¹è±¡ä¹‹é—´çš„å…³ç³»ï¼ˆä¾‹å¦‚ç»„åˆæˆ–ç»“åˆæ€§ï¼‰ç§°ä¸º*[æ€å°„](https://mathworld.wolfram.com/Morphism.html)*ã€‚ç±»åˆ«ä¹‹é—´çš„å…³ç³»ç§°ä¸º*[å‡½å­](https://en.wikipedia.org/wiki/Functor)*ã€‚èŒƒç•´è®ºæè¿°çš„å‡ ä¸ªæ¦‚å¿µåœ¨è®¡ç®—æœºç§‘å­¦ä¸­ç”¨äºè¯„ä¼°ç¨‹åºçš„æ­£ç¡®æ€§å’Œç®€æ´æ€§ã€‚ç±»åˆ«ç†è®ºæ¦‚å¿µåœ¨çº¯å‡½æ•°èŒƒå¼ä¸­æ›´åŠ æ˜æ˜¾ï¼Œå…¶ä¸­è®¡ç®—ç”±å¯ä»¥ç»„åˆä»¥æ„å»ºå¤æ‚æ€§çš„æ•°å­¦å‡½æ•°ç»„æˆã€‚
6. **[è‡ªåŠ¨æœºç†è®º](https://en.wikipedia.org/wiki/Automata_theory)**ã€‚è®¡ç®—æœºç§‘å­¦çš„è¿™ä¸€é¢†åŸŸå®šä¹‰äº†å½¢å¼è¯­è¨€åˆ†æçš„åŸºç¡€ï¼Œä¸ºç¼–è¯‘å™¨è®¾è®¡ã€è§£æå™¨ã€è¯­æ³•å’Œæ­£åˆ™è¡¨è¾¾å¼å¥ å®šäº†ç†è®ºåŸºç¡€ã€‚æˆ‘ä»¬ä½¿ç”¨è‡ªåŠ¨æœºå¯¹å½¢å¼è¯­è¨€è¿›è¡Œå»ºæ¨¡ï¼Œè‡ªåŠ¨æœºæ˜¯ä»æ— é™é›†åˆä¸­æå–çš„å½¢å¼è¯­è¨€çš„æœ‰é™è¡¨ç¤ºã€‚æœ‰é™è‡ªåŠ¨æœºæ˜¯ä¸€ç§æŠ½è±¡æœºå™¨ï¼Œå®ƒé€šè¿‡çŠ¶æ€ç§»åŠ¨æ¥æ‰§è¡Œè®¡ç®—ï¼Œæ ¹æ®å½¢å¼è¯­è¨€å®šä¹‰çš„ä¸€ç»„è§„åˆ™ç¡®å®šæ˜¯å¦åº”è¯¥æ¥å—æˆ–æ‹’ç»ç»™å®šçš„è¾“å…¥ã€‚[ Chomksy å±‚æ¬¡ç»“æ„](https://en.wikipedia.org/wiki/Chomsky_hierarchy)æä¾›äº†ä¸€ç§å°†å½¢å¼è¯­è¨€åˆ†ç»„ä¸ºè¿ç»­æ›´å¤§çš„ç±»çš„æ–¹æ³•ã€‚





## A brief introduction to Programming Language Theory

Most developers focus on learning the â€œhowâ€ of programming rather than consuming materials that expound on underlying theoretical foundations. The following introduction to PLT does not include proofs or build deep mathematical intuition. The goal instead is to establish familiarity with core concepts and areas of study.

1. **[Turing completeness](https://en.wikipedia.org/wiki/Turing_completeness).** This property defines the criteria necessary for being considered a real programming language. A programming language is a [formal language](https://en.wikipedia.org/wiki/Formal_language) defined by a set of rules used to translate instructions to a computer. These rules specify acceptable ways to communicate with a computer. The Turing machine is a mathematical model of an abstract computer capable of implementing any algorithm by simulating its logic. When a system that can simulate the Turing machine can also implement any algorithmâ€”it is known as Turing complete. This usually requires the language to be able to possess [state](https://en.wikipedia.org/wiki/State_(computer_science)) (i.e., variables) and conditional logic. By this definition, [HTML](https://stackoverflow.com/questions/30719221/is-html-turing-complete) is not Turing completeâ€”but [lambda calculus](https://en.wikipedia.org/wiki/Lambda_calculus) is.
2. **[Decidability and the halting problem](https://en.wikipedia.org/wiki/Halting_problem).** In his seminal work, Alan Turing proved that there is no general algorithm we can use to determine whether a program will terminate for all possible inputs (though we can model expected behaviors for some program-input pairs). This is known as the halting problem. A decidable problem is one that can be solved. Therefore, the halting problem is *undecidable*. Conversely, a decidable problem is one for which it is possible to construct an algorithm that always leads to a correct yes-or-no answer.
3. **[Type theory](https://en.wikipedia.org/wiki/Type_theory).** This is a strand of mathematics underlying type systems in programming languages. It forms the internal logic for type checking algorithms in compilers. A type-theoretic framework allows us to evaluate and computationally justify why certain types should or should not exist in a strongly typed language. Types are one way of defining interfaces between different parts of a language, and ensuring the program is connected consistently. In functional programming, type theory suggests that types should express what the programming language is to do (and the lambda calculus that materializes from these types is the language itself). This means that being acquainted with some type theory provides the foundation to better understand static languages with rich type systems (such as Haskell). Type theory essentially studies type systems, which define a languageâ€™s organizing rules. An interesting type system is the [Hindley-Milner Type System](http://dev.stephendiehl.com/fun/006_hindley_milner.html) which uses [unification](http://dev.stephendiehl.com/fun/006_hindley_milner.html#unification) to provide type inference capabilities for untyped syntax.
4. **[Set theory](https://en.wikipedia.org/wiki/Set_theory)**. Sets are collections of objects. These sets have operations (such as [intersection, union and complement](https://www.probabilitycourse.com/chapter1/1_2_2_set_operations.php)). According to formal language theory, a language is a *set* of strings. Data structures themselves can also be seen as sets with various implementations of set operations. One clear way set theory is notionally relevant to programming is through relational databases (where a database is a relation over sets).
5. **[Category theory](https://en.wikipedia.org/wiki/Category_theory)**. Category theory generalizes several branches of mathematics. It does so by providing a generic â€œmetaâ€ language to be able to model concepts abstractly. This is profoundly useful as it allows us to reason about a network of relationships, instead of being concerned with the details of a particular system. A *category* is a collection of objects. The relations between these objects (such as composition or associativity) are known as *[morphisms](https://mathworld.wolfram.com/Morphism.html)*. Relationships between categories are known as *[functors](https://en.wikipedia.org/wiki/Functor)*. Several concepts described by category theory are used in computer science to assess the correctness and concision of programs. Category theoretical concepts are more visible in pure functional paradigms, where computation comprises of mathematical functions that can be composed to build complexity.
6. **[Automata theory](https://en.wikipedia.org/wiki/Automata_theory)**. This corner of computer science defines the footing for formal language analysis, developing the theoretical basis for compiler design, parsers, grammars, and regular expressions. We model formal languages using an automaton, a finite representation of a formal language that draws from an infinite set. A finite automaton is an abstract machine that moves through states to perform a computation, determining whether a given input should be accepted or rejected based on a set of rules defined by the formal language. The [Chomksy hierarchy](https://en.wikipedia.org/wiki/Chomsky_hierarchy) provides a way to group formal languages into successively larger classes.





---

Type Theory ğŸš§

æ›¸ç±ã€è¬›ç¾©

```
Type Theory and Formal Proof: An Introduction
Homotopy Type Theory: Univalent Foundations of Mathematics
PROGRAM = PROOF
https://www.ps.uni-saarland.de/courses.html
http://www.cs.cmu.edu/~rwh/courses/chtt/
http://www.cs.ru.nl/~freek/courses/tt-2013/
http://www.cs.cornell.edu/courses/cs6180/
https://www.cs.cornell.edu/courses/cs3110/2020sp/lectures.html
```

æˆ‘ä¸æ‰“ç®—æ•´ç†ã€‚æˆ‘åªæ‰¾äº†è³‡æºï¼Œå„ä½è«‹è‡ªä¾¿ã€‚

Category Theory ğŸš§

æ›¸ç±ã€è¬›ç¾©

```
Category Theory for Programmers
Category Theory for Computer Science
Category Theory for the Sciences
The Joy of Abstraction: An Exploration of Math, Category Theory, and Life
An Invitation to Applied Category Theory: Seven Sketches in Compositionality
Introduction to Higher-Order Categorical Logic
category theory = type theory
https://cs.stackexchange.com/questions/3028
```

æˆ‘ä¸æ‰“ç®—æ•´ç†ã€‚æˆ‘åªæ‰¾äº†è³‡æºï¼Œå„ä½è«‹è‡ªä¾¿ã€‚

Mathematical Logic ğŸš§

Mathematical Logic

æ•¸å­¸é‚è¼¯é‡å¡‘é‚è¼¯å­¸æ‰€æœ‰æ¦‚å¿µï¼Œé‡æ–°æ­¸é¡å‘½åï¼Œå½¢æˆå››å¤§é ˜åŸŸï¼š

```
set theory        é›†åˆè«–ï¼ˆä¾†è‡ªpredicateï¼‰
proof theory      è­‰æ˜è«–ï¼ˆä¾†è‡ªderivationï¼‰
model theory      æ¨¡å‹è«–ï¼ˆä¾†è‡ªinterpretationï¼‰
recursion theory  éè¿´è«–ï¼ˆä¾†è‡ªlanguage/automatonï¼‰
```

æ•¸å­¸åè©å…¨é¢ä»¥é‚è¼¯å­¸åè©é‡æ–°å®šç¾©ï¼Œè®Šå¾—åš´è¬¹ã€‚

```
[formal language]
sentence = statement
language = a set of sentences
grammar = a set of rule of inference
substitution = rule of replacement

[formal proof]
theory = a set of sentences
calculi = inference
axiom = a set of premisses
proof = derivation
assumption = argument
hypothesis = premiss
theorem = conclusion

[formal proof with first-order logic]
formula = theorem
valuation = interpretation
structure = (?)
model = a set of satisfiable intepretations for all formulas
        (consistency)
```

Programming Language ğŸš§

Programming Language

```
Programming Language Pragmatics
Types and Programming Languages
Practical Foundations for Programming Languages
The Structure of Typed Programming Languages
Formal Semantics of Programming Languages
Introduction to the Theory of Programming Languages
Software Foundations
Communicating Sequential Processes
https://github.com/steshaw/plt
```

æƒ³è¦ç­è§£ç¨‹å¼èªè¨€ç†è«–ï¼Œå¯ä»¥è®€é€™äº›æ›¸ã€‚

Logic Programming Language

```
Foundations of Logic Programming
Introduction to Logic Programming
```

Prolog æ˜¯çŸ¥åçš„é‚è¼¯å¼ç¨‹å¼èªè¨€ã€‚æˆ‘ä¸€é»èˆˆè¶£éƒ½æ²’æœ‰ã€‚

Functional Programming Language

```
Programming Languages: Functional Programming
Formosan Summer School on Logic, Language, and Computation
Structure and Interpretation of Computer Programs
https://zhuanlan.zhihu.com/p/24648375
https://en.wikipedia.org/wiki/Domain_theory
```

å¦‚æœä½ å–œæ­¡å‡½æ•¸å¼ç¨‹å¼èªè¨€ï¼Œåˆ¥éŒ¯éå°ç£ä¸­ç ”é™¢çš„ç ”ç¿’ç‡Ÿã€‚

Haskell ã€ Clojure ã€ Scala æ˜¯çŸ¥åçš„å‡½æ•¸å¼ç¨‹å¼èªè¨€ã€‚ C++ ã€ Rust ã€ JavaScript åŒ…å±±åŒ…æµ·ï¼Œå¯ä»¥åšåˆ°å‡½æ•¸å¼ç·¨ç¨‹ã€‚

Imperative Programming Language

```
C++ Primer
The C++ Programming Language
A Tour of C++
Discovering Modern C++: An Intensive Course for Scientists, Engineers, and Programmers
Effective C++: 55 Specific Ways to Improve Your Programs and Designs
Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14
```

æŒ‡ä»¤å¼ç¨‹å¼èªè¨€æ˜¯ç•¶ä»Šæœ€æ™®éçš„ç¨‹å¼èªè¨€ã€‚ç”šè‡³ç¾åœ¨å·²ç¶“æˆç‚ºä¸­å­¸èª²ç¨‹çš„ä¸€éƒ¨åˆ†äº†ã€‚ç”Ÿè€Œç‚ºäººï¼Œé€™æ˜¯å¿…é ˆè¦çŸ¥é“çš„åŸºæœ¬å¸¸è­˜ã€‚

ç¡¬é«”éŸŒé«” C ã€æ‡‰ç”¨ç¨‹å¼ C++ ã€è¦–çª—è»Ÿé«” C# ã€æ‰‹æ©Ÿè»Ÿé«” Java èˆ‡ Kotlin ã€å‡½å¼åº«èª¿ç”¨ Python ã€ç€è¦½å™¨æ“ä½œ JavaScript ã€ç¶²é è¨­è¨ˆ PHP ã€ä¼ºæœå™¨ç¨‹å¼ GO ã€ç³»çµ±ç¨‹å¼ Rust ã€å®šä½ä¸æ˜çš„ D ã€æ•¸å­¸å·¥å…· MATLAB ã€çµ±è¨ˆå­¸å·¥å…· R ã€ç§‘å­¸è¨ˆç®— Fortran ã€é‡‘èäº¤æ˜“ COBOL ã€ â€¦â€¦ ï¼Œé€™äº›éƒ½æ˜¯æŒ‡ä»¤å¼ç¨‹å¼èªè¨€ã€‚èªè¨€è¶Šä¾†è¶Šå¤šï¼Œåˆ†å·¥è¶Šä¾†è¶Šç´°ã€‚

é€™é‚Šåªæä¾› C++ çš„æ›¸å–®ï¼Œé›£æ˜“ç¨‹åº¦ä½æ–¼ç¨‹å¼è¨­è¨ˆå¸«ç”Ÿæ¶¯ç¬¬ä¸€å¹´çš„ç¨‹åº¦ã€‚ä¸»è¦åŸå› æ˜¯æˆ‘åªæœ‰é€™ç¨®ç¨‹åº¦ã€‚æ¬¡è¦åŸå› æ˜¯ C++ èŠ±æ¨£å¾ˆå¤šã€‚ C++ æ˜¯ä¸€å€‹å¯¦é©—æ€§èªè¨€ï¼Œä¸€ç›´åœ¨æ·»åŠ æ–°æƒ³æ³•ã€‚é›–ç„¶ä½œç‚ºç‡Ÿç”Ÿå·¥å…·ç®—æ˜¯æŒºç—›è‹¦çš„ï¼Œä½†æ˜¯æ‹¿ä¾†é–‹é–‹çœ¼ç•Œé‚„æ˜¯æŒºä¸è³´çš„ã€‚

Automatic Reasoning ğŸš§

æ›¸ç±ã€è¬›ç¾©

```
Logic in Computer Science: modelling and reasoning about systems
https://web.stanford.edu/class/cs227/
https://lfcps.org/course/constlog-schedule.html
https://www.amazon.science/blog/a-gentle-introduction-to-automated-reasoning
https://symbolaris.com/
```

æˆ‘ä¸æ‰“ç®—æ•´ç†ã€‚æˆ‘åªæ‰¾äº†è³‡æºï¼Œå„ä½è«‹è‡ªä¾¿ã€‚

Automatic Reasoning

è‡ªå‹•æ¨ç†ã€‚å››å€‹ä¸»é¡Œï¼Œç”±æ˜“åˆ°é›£ã€‚

```
Satisfiability Checkingï¼šåˆ¤æ–·é‚è¼¯æ•˜è¿°æ˜¯å¦å¯ä»¥ç‚ºçœŸï¼ˆæ˜¯å¦æ†å‡ï¼‰ã€‚
Proof Verificationï¼šåˆ¤æ–·é‚è¼¯æ¨è«–æ˜¯å¦æ­£ç¢ºï¼ˆæ˜¯å¦æœ‰æ•ˆï¼å¯è¡ç”Ÿï¼‰ã€‚
Theorem Provingï¼šçµ¦å®šå‰æã€çµè«–ï¼Œæ‰¾åˆ°è¡ç”Ÿéç¨‹ã€‚
Logical Reasoningï¼šæ‰¾åˆ°å‰æã€çµè«–ã€è¡ç”Ÿéç¨‹ã€‚
```

Satisfiability Problem ï¼ˆ SAT ï¼‰

```
http://www.satlive.org/
https://sat-smt.codes/
http://www.cs.man.ac.uk/~korovink/
https://homepage.iis.sinica.edu.tw/~bywang/courses/comp-logic/
```

çµ¦å®šé‚è¼¯æ•˜è¿°ï¼Œåˆ¤æ–·æ˜¯å¦å¯ä»¥ç‚ºçœŸï¼ˆåˆ¤æ–·æ˜¯å¦æ†å‡ï¼‰ã€‚

ç°¡æ˜“è§£æ³•ï¼š Interpretation ã€‚

é€²éšè§£æ³•ï¼šé‚è¼¯æ•˜è¿°æ”¹å¯«æˆ CNF ï¼Œè§€å¯Ÿæ¯å€‹æ‹¬è™Ÿæ˜¯å¦çš†çœŸã€‚

å¤§å®¶ç·¨å¯«ç¨‹å¼é€²è¡Œæª¢æŸ¥ï¼Œç¨±ä½œ SAT Solver ã€‚é€™å€‹ç¶²ç«™æ•´ç†äº†ä¸€ä»½è©³ç´°åˆ—è¡¨ï¼š



Conjunctive Normal Form ï¼ˆ CNF ï¼‰

CNF æ˜¯ä¸€ç¨®æ ¼å¼ï¼šè®Šæ•¸é©åº¦åŠ ä¸Š Â¬ ï¼Œæ‹¬è™Ÿè£¡é¢å…¨æ˜¯ âˆ¨ ï¼Œæ‹¬è™Ÿä¹‹é–“å…¨æ˜¯ âˆ§ ï¼Œæ‹¬è™Ÿåªæœ‰ä¸€å±¤ã€‚

ä¾‹å¦‚ (pâˆ¨Â¬q)âˆ§(q)âˆ§(Â¬qâˆ¨Â¬râˆ¨Â¬s)âˆ§(râˆ¨s) ã€‚

è®Šæ•¸é©åº¦åŠ ä¸Š Â¬ ç¨±ä½œã€Œå­—é¢å€¼ literal ã€ã€‚

ä¾‹å¦‚ p ã€ Â¬q ã€ q ã€ Â¬q ã€ Â¬r ã€ Â¬s ã€ r ã€ s æ˜¯å­—é¢å€¼ã€‚

æ‹¬è™Ÿç¨±ä½œã€Œå­å¥ clause ã€ã€‚

ä¾‹å¦‚ (pâˆ¨Â¬q) ã€ (q) ã€ (Â¬qâˆ¨Â¬râˆ¨Â¬s) ã€ (râˆ¨s) æ˜¯å­å¥ã€‚

CNF å®¹æ˜“åˆ¤æ–·çœŸå‡ï¼šæ¯å€‹å­å¥çš†æ˜¯çœŸï¼Œé‚£éº¼æ•´é«”æ˜¯çœŸã€‚å­å¥è£¡é¢ä»»ä½•ä¸€å€‹å­—é¢å€¼æ˜¯çœŸï¼Œé‚£éº¼å­å¥æ˜¯çœŸã€‚

CNF å®¹æ˜“è¨­è¨ˆæ¼”ç®—æ³•ã€‚

é‚è¼¯æ•˜è¿°ç¸½æ˜¯å¯ä»¥æ”¹å¯«æˆ CNF

ä¸€ã€ç§»é™¤ â†’ ã€ â†” ã€‚æ”¹å¯«æˆ Â¬ ã€ âˆ§ ã€ âˆ¨ ã€‚

ä¾‹å¦‚ pâ†’q æ›æˆ Â¬pâˆ¨q ã€‚

ä¾‹å¦‚ pâ†”q æ›æˆ (pâˆ§q)âˆ¨(Â¬pâˆ§Â¬q) ã€‚

äºŒã€ç¬›æ‘©æ ¹å®šå¾‹ï¼šç§»é™¤æ‹¬è™Ÿé™„å¸¶çš„ Â¬ ã€‚

ä¾‹å¦‚ Â¬(pâˆ§q) æ›æˆ Â¬pâˆ¨Â¬q ã€‚

ä¸‰ã€åˆ†é…å¾‹ï¼šç§»é™¤æ‹¬è™Ÿä¹‹é–“çš„ âˆ¨ ã€‚

ä¾‹å¦‚ (pâˆ§q)âˆ¨(râˆ§s) æ›æˆ (pâˆ¨(râˆ§s))âˆ§(qâˆ¨(râˆ§s)) å†æ›æˆ (pâˆ¨r)âˆ§(pâˆ¨s)âˆ§(qâˆ¨r)âˆ§(qâˆ¨s) ã€‚

å››ã€é›™åå¾‹ï¼šç§»é™¤è®Šæ•¸é™„å¸¶çš„å¤šé¤˜ Â¬ ã€‚

ä¾‹å¦‚ Â¬Â¬p æ›æˆ p ã€‚

ä¾‹å¦‚ Â¬Â¬Â¬q æ›æˆ Â¬q ã€‚

k-SAT

SAT æœ‰å€‹é‡è¦ç‰¹ä¾‹æ˜¯ k-SAT ï¼š CNF æ‹¬è™Ÿè£¡é¢è‡³å¤š k å€‹å­—é¢å€¼ã€‚

k=1 æ“æœ‰ä¸€æ¬¡æ–¹æ™‚é–“æ¼”ç®—æ³•ï¼Œæ‰‹æ³•æ˜¯æª¢æŸ¥ x å’Œ Â¬x æ˜¯å¦åŒæ™‚å‡ºç¾ã€‚ k=2 æ“æœ‰ä¸€æ¬¡æ–¹æ™‚é–“æ¼”ç®—æ³•ï¼Œæ‰‹æ³•æ˜¯åŒ–ä½œåœ–è«–å•é¡Œã€‚ kâ‰¥3 æ˜¯ NP-complete å•é¡Œï¼Œåªæœ‰æŒ‡æ•¸æ™‚é–“æ¼”ç®—æ³•ï¼Œæ‰‹æ³•æ˜¯å›æº¯æ³•ã€‚

ç¾å¯¦æ‡‰ç”¨ï¼Œ k éƒ½å¾ˆå¤§ï¼ŒåŸºæœ¬ç„¡æœ›ã€‚ç„¶è€Œå¤§å®¶ä¾èˆŠåŠªåŠ›æ”¹è‰¯æ¼”ç®—æ³•ï¼Œç›¡å¯èƒ½æ¸›å°‘è¨ˆç®—æ™‚é–“ã€‚è©³æƒ…è«‹è¦‹ TAOCP 4B ã€‚

Resolution



ã€Œæª¢æŸ¥å…©å€‹å­å¥æ˜¯çœŸã€ç²¾ç°¡æˆã€Œæª¢æŸ¥ä¸€å€‹å­å¥æ˜¯çœŸã€ã€‚

```
pâˆ¨r , qâˆ¨Â¬r âŠ¨ pâˆ¨q
pâ‚âˆ¨...âˆ¨pâ‚™âˆ¨r , qâ‚âˆ¨...âˆ¨qâ‚˜âˆ¨Â¬r âŠ¨ pâ‚âˆ¨...âˆ¨pâ‚™âˆ¨qâ‚âˆ¨...âˆ¨qâ‚˜
```

è¬›ä¸€ä¸‹æ€è·¯ã€‚ç•¶å‰æç‚ºçœŸï¼Œä»¥ r å’Œ Â¬r ç‚ºä¸»è§’ï¼Œåˆ†æˆå…©ç¨®æƒ…æ³ã€‚ä¸€ã€å¦‚æœ r çœŸï¼Œé‚£éº¼ q çœŸã€‚äºŒã€å¦‚æœ Â¬r çœŸï¼Œé‚£éº¼ p çœŸã€‚ä¹Ÿå°±æ˜¯èªªï¼Œ p q è‡³å°‘æœ‰ä¸€å€‹æ˜¯çœŸã€‚

å»¶ä¼¸é–±è®€ï¼š Semantic Tableaux



æ¨¹ç‹€åœ–ã€‚é‡åˆ° âˆ§ ï¼šåˆ†é…å¾‹å…±å‚¬è½å»ã€‚é‡åˆ° âˆ¨ ï¼šåˆ†æ”¯ã€‚

å¦‚æœä½ ä¸å–œæ­¡ CNF ï¼Œé‚£éº¼å¯ä»¥ç”¨é€™å€‹æ–¹æ³•ã€‚

```
   pâˆ§(pâˆ¨Â¬q)
       |            âŠ™ open
  (pâˆ§p)âˆ¨(qâˆ¨p)       Ã— close
   /       \
(pâˆ§p)     (qâˆ¨p)
  âŠ™        Ã—
```

Satisfiability Modulo Theories ï¼ˆ SMT ï¼‰

SMT æ˜¯ SAT åŠ å¼·ç‰ˆæœ¬ã€‚æ´å¼•é›†åˆã€è¿½åŠ å‡½æ•¸ã€‚



Proof Verification

çµ¦å®šé‚è¼¯æ¨è«–ï¼Œåˆ¤æ–·æ˜¯å¦æœ‰æ•ˆã€‚

è§£æ³•ï¼šå°‡é‚è¼¯æ¨è«–æ”¹å¯«æˆé‚è¼¯æ•˜è¿°ï¼Œåˆ©ç”¨ SAT è§£æ±ºã€‚

é‚è¼¯æ¨è«–ç„¡æ•ˆï¼Œåªæœ‰ä¸€ç¨®æƒ…æ³ï¼šå‰ææ˜¯çœŸã€çµè«–æ˜¯å‡ã€‚

å‰æä¸æ”¹è®Šã€çµè«–è¿½åŠ  Â¬ ï¼Œå…©è€… âˆ§ èµ·ä¾†ï¼Œå½¢æˆé‚è¼¯æ•˜è¿°ã€‚æ•˜è¿°å¯ä»¥ç‚ºçœŸï¼Œæ¨è«–ç„¡æ•ˆã€‚æ•˜è¿°æ˜¯æ†å‡å¥ï¼Œæ¨è«–æœ‰æ•ˆã€‚

```
verify pâ‚ , pâ‚‚ , ... , pâ‚™ âŠ¨ q

if pâ‚ âˆ§ pâ‚‚ âˆ§ ... âˆ§ pâ‚™ âˆ§ Â¬q can be âŠ¤,
then pâ‚ , pâ‚‚ , ... , pâ‚™ âŠ¨ q is invalid.

if pâ‚ âˆ§ pâ‚‚ âˆ§ ... âˆ§ pâ‚™ âˆ§ Â¬q is always âŠ¥,
then pâ‚ , pâ‚‚ , ... , pâ‚™ âŠ¨ q is valid.
```

Theorem Proving

```
https://tpchina.github.io/readings/
http://www.cs.ru.nl/~herman/
https://www.cs.cornell.edu/courses/cs3110/2018sp/a5/coq-tactics-cheatsheet.html
http://www.inf.ed.ac.uk/teaching/courses/ar/
http://logitext.mit.edu/
https://www.tptp.org/CASC/
```

ç°¡æ˜“è§£æ³•ï¼šè¦å‰‡è¡¨è®Šæˆåœ–ï¼Œåˆ©ç”¨ç‹€æ…‹ç©ºé–“æœå°‹æ‰¾åˆ°è¡ç”Ÿéç¨‹ã€‚

é€²éšè§£æ³•ï¼šè¦å‰‡è¡¨è®Šæˆè‡ªå‹•æ©Ÿï¼Œåˆ©ç”¨è‡ªå‹•æ©Ÿéæ­·æ‰¾åˆ°è¡ç”Ÿéç¨‹ã€‚

å¤§å®¶ç·¨å¯«ç¨‹å¼é€²è¡Œæª¢æŸ¥ï¼Œç¨±ä½œ Theorem Prover ã€‚çŸ¥åå·¥å…· Coq ã€ Isabelle ã€ Lean ã€ ACL2 ã€‚ç¶­åŸºç™¾ç§‘æ•´ç†äº†ä¸€ä»½è©³ç´°åˆ—è¡¨ï¼š



Reasoning



å¤§å®¶ç·¨å¯«ç¨‹å¼é€²è¡Œæª¢æŸ¥ï¼Œç¨±ä½œ Reasoning System ã€‚ç›®å‰æ²’æœ‰çŸ¥åå·¥å…·ã€‚ç¶­åŸºç™¾ç§‘æ•´ç†äº†ä¸€ä»½è©³ç´°åˆ—è¡¨ï¼š



Formal Verification ğŸš§

æ›¸ç±ã€è¬›ç¾©

```
Principles of Model Checking
Model Checking
Systems and Software Verification: Model-Checking Techniques and Tools
http://im.ntu.edu.tw/~tsay/dokuwiki/doku.php?id=courses:ssv2022:main
http://www.cs.cmu.edu/~15414/
Formosan Summer School on Logic, Language, and Computation
SRI: Summer School on Formal Techniques
```

æˆ‘ä¸æ‰“ç®—æ•´ç†ã€‚æˆ‘åªæ‰¾äº†è³‡æºï¼Œå„ä½è«‹è‡ªä¾¿ã€‚

Formal Verification

```
https://www.cis.upenn.edu/~stevez/vellvm/
https://nfm2022.caltech.edu/
Formal Verification: An Essential Toolkit for Modern VLSI Design
```

å½¢å¼é©—è­‰ã€‚æ¨¡æ“¬é©—ç®—ã€‚

å½¢å¼ Formal æ˜¯ä¸€å€‹å½¢å®¹è©ï¼Œæ„æ€æ˜¯åœ¨æ¶ç©ºä¸–ç•Œå»ºç«‹è¦å¾‹ã€‚

ç¾å¯¦ä¸–ç•Œçš„è©å½™ï¼Œé–‹é ­å† ä¸Š Formal ï¼Œä¾¿å¾—åˆ°æ¶ç©ºä¸–ç•Œçš„è©å½™ã€‚ä¾‹å¦‚å½¢å¼ç§‘å­¸ã€å½¢å¼è­‰æ˜ã€å½¢å¼è¬¬èª¤ã€å½¢å¼é©—è­‰ã€å½¢å¼èªè¨€ã€ â€¦â€¦ ã€‚

å·¥ç¨‹ç•¶ä¸­ï¼Œå‰µæ–°äº‹ç‰©ï¼Œæ”¹é€ ç¾å¯¦ã€‚æƒ³è¦æª¢æŸ¥å‰µæ–°äº‹ç‰©æ˜¯å¦åˆç†ï¼Œé‚£å°±å»ºç«‹ä¸€å€‹æ¶ç©ºä¸–ç•Œï¼Œä»¤å‰µæ–°äº‹ç‰©åª’åˆè™›æ“¬è¦å‰‡ï¼Œæ”¹ç‚ºæª¢æŸ¥è™›æ“¬è¦å‰‡æ˜¯å¦åˆç†ã€‚

è¨ˆç®—æ©Ÿå·¥ç¨‹ç•¶ä¸­ï¼Œç·¨è­¯å™¨é ˜åŸŸçš„ LLVM ã€ç¶²è·¯é ˜åŸŸçš„åŠ å¯†æ¼”ç®—æ³•ï¼Œä½¿ç”¨äº†å½¢å¼é©—è­‰ã€‚è‡³æ–¼é›»å­ã€èˆªå¤ªã€é‡‘èã€è£½é€ ã€é†«ç™‚ï¼Œæˆ‘åªæœ‰è½èªªä¼¼ä¹æœ‰åœ¨ä½¿ç”¨ï¼Œè©³æƒ…æˆ‘å°±ä¸æ¸…æ¥šäº†ã€‚

è¨­è¨ˆè¦å‰‡ï¼Œç„¶å¾Œåˆè¨­è¨ˆè¦å‰‡ä»¥é©—è­‰é€™äº›è¦å‰‡ï¼Œä¹çœ‹è‡ªè¨è‹¦åƒã€‚ç„¶è€Œé€™äº›é ˜åŸŸä¸€æ—¦çŠ¯éŒ¯ï¼Œå°‡æœƒæ¶ˆè€—å·¨å¤§æˆæœ¬ï¼Œç”šè‡³æ¶ˆè€—äººå‘½ã€‚è€Œé©—è­‰æˆæœ¬ç›¸å°è¼ƒå°‘ã€‚å³ä¾¿æ˜¯çœ‹ä¼¼ç„¡è¬‚çš„è‹¦å·¥ï¼Œä¹Ÿå€¼å¾—ä¸€åšå†åšã€‚

Model Checking = Theorem Proving

```
https://www.cs.cornell.edu/courses/cs6480/2020sp/schedule/
http://spinroot.com/cs118/
https://saw.galois.com/
https://www.prismmodelchecker.org/
https://www.stormchecker.org/about.html
```

æ¨¡å‹æª¢æ¸¬ã€‚

åˆ©ç”¨é‚è¼¯å­¸é€²è¡Œå½¢å¼é©—è­‰ã€‚å‰µæ–°äº‹ç‰©æ”¹å¯«æˆé‚è¼¯æ•˜è¿°ã€é‚è¼¯æ¨è«–ã€‚æª¢æŸ¥é‚è¼¯æ•˜è¿°æ˜¯å¦æ†å‡ã€é‚è¼¯æ¨è«–æ˜¯å¦ç„¡æ•ˆã€‚

å¤§å®¶ç·¨å¯«ç¨‹å¼é€²è¡Œæª¢æŸ¥ï¼Œç¨±ä½œ Model Checker ã€‚å·²æœ‰å„å¼å„æ¨£çš„å·¥å…·ï¼Œç”¨æ–¼å„å¼å„æ¨£çš„ç”¨é€”ã€‚ä¾‹å¦‚ [Infer](https://github.com/facebook/infer) å’Œ [TLA+](https://github.com/tlaplus) ç”¨ä¾†æª¢æŸ¥ç¨‹å¼é‹ä½œï¼ˆç·¨å¯«ç¨‹å¼ç¢¼æª¢æŸ¥ç¨‹å¼ç¢¼ï¼‰ã€ Spin ç”¨ä¾†æª¢æŸ¥å¤šåŸ·è¡Œç·’è»Ÿé«”ã€ SAW ç”¨ä¾†æª¢æŸ¥åŠ å¯†æ¼”ç®—æ³•ã€‚ç¶­åŸºç™¾ç§‘æ•´ç†äº†ä¸€ä»½è©³ç´°åˆ—è¡¨ï¼š



Modal Logic ğŸš§

Modal Logic



Temporal Logic ğŸš§

Temporal Logic

```
https://en.wikipedia.org/wiki/Linear_temporal_logic
https://en.wikipedia.org/wiki/BÃ¼chi_automaton
https://en.wikipedia.org/wiki/Computation_tree_logic
https://5nizza.github.io/2016/08/11/ctl-to-haa/
```
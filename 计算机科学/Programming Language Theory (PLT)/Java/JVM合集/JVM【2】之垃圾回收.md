[TOC]

> 看TOC目录吧

## 概述

垃圾收集 Garbage Collection 通常被称为“GC”，它诞生于1960年 MIT 的 Lisp 语言，经过半个多世纪，目前已经十分成熟了。 jvm 中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收**主要集中于 java 堆和方法区中**，在程序运行期间，这部分内存的分配和使用都是动态的.



## 一、对象存活判断

判断对象是否存活一般有两种方式：

### 1.引用计数

每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。 

```java
<-- 背景 -->
// 对象objA 和 objB 都有字段 name
// 两个对象相互进行引用，除此之外这两个人对象没有任何引用
objA.name = objB；
objB.name = objA；

<-- 问题 -->
// 实际上这两个对象已经不可能再被访问，应该要被垃圾收集器进行回收
//正由于该算法存在判断逻辑漏洞，所以 Java虚拟机没有采用该算法判断Java是否存活。
```



### 2.可达性分析（Reachability Analysis）

从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。

很多主流商用语言（如`Java`、`C#`）都采用 **引用链法** 判断 `Java`对象是否存活。

含有三个步骤：

1. 可达性分析
2. 第一次标记 & 筛选
3. 第二次标记 & 筛选

在**Java**语言中，GC Roots包括：

- `Java`虚拟机栈（栈帧的**本地变量表**）中引用的对象 
- 方法区中类**静态属性**实体引用的对象。
- 方法区中**常量**引用的对象。
- 本地方法栈中**JNI**引用的对象。



### 3.特别注意

- **可达性分析 仅仅只是判断对象是否可达，但还不足以判断对象是否存活 / 死亡**
- 当在 可达性分析 中判断不可达的对象，只是“被判刑” = 还没真正死亡

> 不可达对象会被放在”即将回收“的集合里。 

要判断一个对象真正死亡，还需要经历两个阶段：

1. 第一次标记 & 筛选
2. 第二次标记 & 筛选



#### 3.1第一次标记 & 筛选

> 对象 在 可达性分析中 被判断为**不可达**后，**会被第一次标记 & 准备被筛选**

a. 不筛选：继续留在 ”即将回收“的集合里，等待回收； 

b. 筛选：从 ”即将回收“的集合取出 

**筛选的标准**：该对象是否有必要执行 `finalize()`方法 

1. 若有必要执行（人为设置），则筛选出来，进入下一阶段（第二次标记 & 筛选）；
2. **若没必要执行，判断该对象死亡，不筛选 并等待回收**

> 当对象无 `finalize()`方法 或 `finalize()`已被虚拟机调用过，则视为“没必要执行” ,即不可二次唤醒。



#### 3.2第二次标记 & 筛选

> 当对象经过了第一次的标记 & 筛选，会被进行**第二次标记 & 准备被进行 筛选** 

##### 3.2.1方式描述

该对象会被放到一个 `F-Queue` 队列中，并由 虚拟机自动建立、优先级低的`Finalizer` 线程去执行 队列中该对象的`finalize()`

> 1.  `finalize()`只会被执行一次
> 2. 但并不承诺等待`finalize()`运行结束。这是为了防止 `finalize()`执行缓慢 / 停止  使得 `F-Queue`队列其他对象永久等待。

##### 3.2.2筛选标准

在执行`finalize()`过程中，**若对象依然没与引用链上的GC Roots 直接关联 或 间接关联（即关联上与GC Roots 关联的对象）**，那么该对象将被判断死亡，不筛选（留在”即将回收“集合里） 并 等待回收



### 4.总结(流程图)

![JVM垃圾回收1](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/2iqFfzgUIDbhzi2nsrDoTOnMp*PofGjKGDK0*rh*IpI!/r/dEgBAAAAAAAA)





## 二、垃圾收集算法

### 1.标记 -清除算法(老年代)

“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。

#### 1.1优点

算法简单、实现简单

#### 1.2缺点

- 效率问题：即 标记和清除 两个过程效率不高
- 空间问题：标记 - 清除后，会产生大量不连续的内存碎片。

这导致 以后程序 需要分配**较大空间对象**时 无法找到足够大的连续内存 而被迫 触发另外一次垃圾收集行为，这导致非常浪费资源*

![JVM垃圾回收2](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/wgPsEmYeQfKZDRRY*OX0L6k552t1DdWbbJKoKD9iFqY!/r/dDABAAAAAAAA)

#### 1.3应用场景

对象存活率较低 & 垃圾回收行为频率低 的场景

> 如老年代区域，因为老年代区域回收频次少、回收数量少，所以对于效率问题 & 空间问题不会很明显。



### 2.复制算法(新生代)

> 该算法的出现是为了解决 标记-清除算法中 效率 & 空间问题的。 

“复制”（Copying）的收集算法，它将可用内存按容量划分为**大小相等**的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动**堆顶指针**，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，持续复制长生存期的对象则导致效率降低。

![JVM垃圾回收3](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/TQJBFuxUkYv6AA8d*ETFYZohAU0trp07wN0Bohtk2mA!/r/dFMBAAAAAAAA)

#### 2.1优点

1. 解决了标记-清除算法中 清除效率低的问题

> 每次仅回收内存的一半区域

1. 解决了标记-清除算法中 空间产生不连续内存碎片的问题

> 将已使用内存上的存活对象 移动到栈顶的指针，按顺序分配内存即可。

#### 2.2 缺点

1. 每次使用的内存缩小为原来的一半。
2. 当对象存活率较高的情况下需要做很多复制操作，即效率会变低

#### 2.3应用场景

对象存活率较低 & 需要频繁进行垃圾回收 的区域

> 如新生代区域

#### 2.4特别注意

**a. 背景**

> 新生代区域在进行垃圾回收时，98%对象都必须得回收

**b. 问题**
 复制算法中 **每次使用的内存缩小为原来的一半** 利用率低 & 代价太高

**c. 解决方案**

- 不 按 `1：1`的比例 划分内存，而是 按`8：1：1`比例 将内存划分为一块较大的 `Eden` 和两块较小的 `Survivor` 区域（`From Survivor`、`To Survivor`

![JVM垃圾回收4](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/fFh4dtptjmNLFD1lE5y*klN1ObzNz9499Fkdo0h05wk!/r/dD4BAAAAAAAA)

再看下JVM的内存结构划分

![JVM内存结构1](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/fPxZjFaylPVQiesRoBRIOMTnvmZNwrDY.QcGjFk6gi0!/r/dD4BAAAAAAAA)

- **每次使用`Eden`、`From Survivor`区域；**
- **用完后就 将上述两块区域存活的对象 复制到`To Survivor`区域上**
- **最终一次清理掉`Eden`、`From Survivor`区域**

很多同学会问，假如 `Eden`、`From Survivor`区域上存活对象所需内存大小 > `To Survivor`区域怎么办？

解决方案：**依赖老年代内存区域 做 内存分配担保。**

> 即`To Survivor`区域 存不下来的对象 会通过 **内存分配担保机制** 暂时保存在老年代



### 3.标记-整理算法(老年代)

> 此算法类似于第一种标记 - 清除 算法，只是在中间加多了一步：整理内存。 

#### 3.1步骤：

1. 标记阶段：标记出所有**需要回收**的对象；
2. 整理阶段：让所有**存活**的对象都向一端移动
3. 清除阶段：统一清除（回收）**端以外**的对象。

复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。

根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

![JVM垃圾回收5](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/2Qx04Qcx*oGW*.bbckIuviXpxeCd2HXnX5r429Uz*Mc!/r/dFIBAAAAAAAA)

#### 3.2优点

- 解决了标记-清除算法中 清除效率低的问题：一次清楚端外区域
- 解决了标记-清除算法中 空间产生不连续内存碎片的问题：将已使用内存上的存活对象 移动到栈顶的指针，按顺序分配内存即可。

#### 3.2使用场景

象存活率较低 & 垃圾回收行为频率低 的场景

> 如老年代区域，因为老年代区域回收频次少、回收数量少，所以对于效率问题 & 空间问题不会很明显。



### 4.分代收集算法

> 主流的虚拟机基本都采用该算法，下面会着重讲解。 

GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。

#### 4.1算法思路

> 根据 **对象存活周期的不同** 将 `Java`堆内存 分为：新生代 & 老年代 。

“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。

![JVM垃圾回收6](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/1NxTJt8K3Vy.YS8KWcFQVTaYzF8ie2uPTGYzi1zFwpc!/r/dD4BAAAAAAAA)

- 根据 两块区域特点 选择 对应的垃圾收集算法（即上面介绍的算法），具体细节请看下图

![JVM垃圾回收7](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/uWkmUtdmDTey2db.wplPVEVRcWuMDequNl5UQSBsE6M!/r/dEgBAAAAAAAA)

#### 4.2具体存储过程

1. 新建的对象 一般会被优先分配到新生代的`Eden`区、`From Survivor`区
   - **大对象（如很长的字符串以及数组）会直接分配到老年代**，这是为了避免在 `Eden` 区 和  `Survivor`区之间发生大量的内存复制（因为新生代会采用复制算法进行垃圾收集）
2. 这些对象经过第一次 `Minor GC`后，若仍然存活，将会被移到`To Survivor`区
3. 一次清理掉`Eden`、`From Survivor`区域
4. 在 `To Survivor` 区每经过一轮 `Minor GC` ，该对象的年龄就+1
5. 当对象年龄达到一定时(阈值默认=15)，就会被移动到老年代。
   - 即新生代的对象在存活一定时间后，会被移动存储到老年代区域。
   - 还有一种 新生代对象被移懂到老年代区域 的情况是：**动态对象年龄判定**。即如果在`Survivor`区中 所有相同年龄对象的大小总和 大于
   -  `Survivor`区内存大小一半时，所有大于或等于该年龄的对象都会直接进入老年代。

#### 4.3特别注意

`From Survivor` 和 `To Survivor`之间会经常互换角色。

每次发生GC时，把`Eden`区和 `From Survivor`区中 存活且没超过年龄阈值的对象 复制到`To Survivor`区中（此时`To Survivor`变成了`From Survivor`），然后`From Survivor`清空（此时`From Survivor`变成了`To Survivor`）

####  4.4优点

效率高、空间利用率高

> 根据不同区域特点 选择 不同的垃圾收集算法

#### 4.5应用场景

现在主流的虚拟机基本都采用 **分代收集算法** ，即根据不同区域特点选择不同垃圾收集算法。

> 1. 新生代 区域：采用 复制算法
> 2. 老年代 区域：采用 标记-清除 算法、标记 - 整理 算法



### 5.总结

#### 5.1上图

![JVM垃圾回收8](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/HQN07fypMrKA7Smk2wAg*J1h57h3eXtjUJXQTQgJGh4!/r/dDABAAAAAAAA)

 

## 三、垃圾收集器

> 如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现

### Serial收集器

串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用**一个线程**去回收。

- 新生代串**行**	新生代复制算法
- 老年代**串行**     老年代标记-整理

垃圾收集的过程中会**Stop The World（服务暂停）**

参数控制：`-XX:+UseSerialGC` 串行收集器

![垃圾回收器1](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/ai2RwDfFZ.34A4bLIliCdlTdWGw6RL2we79YxXR4GvA!/r/dDUBAAAAAAAA)

### ParNew收集器

ParNew收集器其实就是Serial收集器的**多线程版本**。

- 新生代**并行**	新生代复制算法
- 老年代**串行**     老年代标记-整理

参数控制：

`-XX:+UseParNewGC` ParNew收集器
`-XX:ParallelGCThreads` 限制线程数量

![垃圾回收器2](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/.Cwe6O9kbfFza4gtx56lGmlzTXZDoLpVmnujlofIUIo!/r/dDcBAAAAAAAA)

### Parallel收集器

Parallel Scavenge收集器类似ParNew收集器，Parallel收集器**更关注系统的吞吐量**。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，**动态调整这些参数以提供最合适的停顿时间或最大的吞吐量**；也可以通过参数控制GC的时间不大于多少毫秒或者比例；

- 新生代复制算法
- 老年代标记-整理

参数控制：`-XX:+UseParallelGC` 使用Parallel收集器+ 老年代串行

### Parallel Old 收集器

Parallel Old是Parallel Scavenge收集器的老年代版本，使用**多线程**和“**标记－整理**”算法。这个收集器是在JDK 1.6中才开始提供

参数控制： `-XX:+UseParallelOldGC` 使用Parallel收集器+ 老年代并行

### CMS收集器

CMS（Concurrent Mark Sweep）收集器是一种以获取**最短回收停顿时间**为目标的收集器。目前很大一部分的Java应用都集中在互联网站或**B/S系统**的服务端上，这类应用尤其**重视服务的响应速度**，希望系统停顿时间最短，以给用户带来较好的体验。

从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“**标记-清除**”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括：

- 初始标记（CMS initial mark）		Stop The World
- 并发标记（CMS concurrent mark）
- 重新标记（CMS remark）                   Stop The World
- 并发清除（CMS concurrent sweep）

**其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。**初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。

由于整个过程中**耗时最长**的**并发**标记和**并发**清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew）

**优点**: 并发收集、低停顿 
**缺点**: 产生大量空间碎片、并发阶段会降低吞吐量

参数控制：

`-XX:+UseConcMarkSweepGC` 使用CMS收集器
`-XX:+ UseCMSCompactAtFullCollection` Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长
`-XX:+CMSFullGCsBeforeCompaction` 设置进行几次Full GC后，进行一次碎片整理
`-XX:ParallelCMSThreads` 设定CMS的线程数量（一般情况约等于可用CPU数量）

![垃圾回收器3](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/.Cwe6O9kbfFza4gtx56lGmlzTXZDoLpVmnujlofIUIo!/r/dDcBAAAAAAAA)

### G1收集器

G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与CMS收集器相比G1收集器有以下特点：

1. **空间整合**，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。
2. **可预测停顿**，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。

上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。

![垃圾回收器4](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/S4CwxjY7T2gxvDQ8hgvgexTSwRdgNqfa4ykBKPE1nr0!/r/dDYBAAAAAAAA)

G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿。

收集步骤：

- 1、标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)
- 2、Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。
- 3、Concurrent Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。

![垃圾回收器5](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/SEDwWmvlC8Ft43iavGhBLit6NI8mw1FHbD88JCxx16M!/r/dAgBAAAAAAAA)

- 4、Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。
- 5、Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。

![垃圾回收器6](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/TtOz.EVIalLxmPdy4a44rCM*6eFsNmnSbqI8gjAmhDY!/r/dDcBAAAAAAAA)

- 6、复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。

![垃圾回收器7](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/8VLpAAERsg.l4WwUAYBt.o7XzdnOg2juhc8gkfDWPbM!/r/dDYBAAAAAAAA)

### 常用的收集器组合

| 服务器31 | 新生代GC策略      | 老年老代GC策略 | 说明                                                         |
| -------- | ----------------- | -------------- | ------------------------------------------------------------ |
| 组合1    | Serial            | Serial Old     | Serial和Serial Old都是单线程进行GC，特点就是GC时暂停所有应用线程。 |
| 组合2    | Serial            | CMS+Serial Old | CMS（Concurrent Mark Sweep）是并发GC，实现GC线程和应用线程并发工作，不需要暂停所有应用线程。另外，当CMS进行GC失败时，会自动使用Serial Old策略进行GC。 |
| 组合3    | ParNew            | CMS            | 使用`-XX:+UseParNewGC`选项来开启。ParNew是Serial的并行版本，可以指定GC线程数，默认GC线程数为CPU的数量。可以使用-XX:ParallelGCThreads选项指定GC的线程数。如果指定了选项`-XX:+UseConcMarkSweepGC`选项，则新生代默认使用ParNew GC策略。 |
| 组合4    | ParNew            | Serial Old     | 使用`-XX:+UseParNewGC`选项来开启。新生代使用ParNew GC策略，年老代默认使用Serial Old GC策略。 |
| 组合5    | Parallel Scavenge | Serial Old     | Parallel Scavenge策略主要是关注一个可控的吞吐量：应用程序运行时间 / (应用程序运行时间 + GC时间)，可见这会使得CPU的利用率尽可能的高，适用于后台持久运行的应用程序，而不适用于交互较多的应用程序。 |
| 组合6    | Parallel Scavenge | Parallel Old   | Parallel Old是Serial Old的并行版本                           |
| 组合7    | G1GC              | G1GC           | `-XX:+UnlockExperimentalVMOptions` `-XX:+UseG1GC` #开启；`-XX:MaxGCPauseMillis =50` #暂停时间目标；`-XX:GCPauseIntervalMillis =200` #暂停间隔目标；`-XX:+G1YoungGenSize=512m` #年轻代大小；`-XX:SurvivorRatio=6` #幸存区比例 |

## 四、一次文字介绍

Java虚拟机)的内存区域中，程序计数器、虚拟机栈和本地方法栈三个区域是线程私有的，随线程生而生，随线程灭而灭；栈中的栈帧随着方法的进入和退出而进行入栈和出栈操作，每个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这三个区域的内存分配和回收都具有确定性。垃圾回收重点关注的是堆和方法区部分的内存。

常用的垃圾回收算法有：

(1).引用计数算法：

给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不再被使用的，垃圾收集器将回收该对象使用的内存。

引用计数算法实现简单，效率很高，微软的COM技术、ActionScript、Python等都使用了引用计数算法进行内存管理，但是引用计数算法对于对象之间相互循环引用问题难以解决，因此java并没有使用引用计数算法。

(2).根搜索算法：

通过一系列的名为“GC Root”的对象作为起点，从这些节点向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Root没有任何引用链相连时，则该对象不可达，该对象是不可使用的，垃圾收集器将回收其所占的内存。

主流的商用程序语言C#、java和Lisp都使用根搜素算法进行内存管理。

在java语言中，可作为GC Root的对象包括以下几种对象：

a. java虚拟机栈(栈帧中的本地变量表)中的引用的对象。

b.方法区中的类静态属性引用的对象。

c.方法区中的常量引用的对象。

d.本地方法栈中JNI本地方法的引用对象。

java方法区在Sun HotSpot虚拟机中被称为永久代，很多人认为该部分的内存是不用回收的，java虚拟机规范也没有对该部分内存的垃圾收集做规定，但是方法区中的废弃常量和无用的类还是需要回收以保证永久代不会发生内存溢出。

判断废弃常量的方法：如果常量池中的某个常量没有被任何引用所引用，则该常量是废弃常量。

判断无用的类：

(1).该类的所有实例都已经被回收，即java堆中不存在该类的实例对象。

(2).加载该类的类加载器已经被回收。

(3).该类所对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射机制访问该类的方法。

Java中常用的垃圾收集算法：

(1).标记-清除算法：

最基础的垃圾收集算法，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成之后统一回收掉所有被标记的对象。

标记-清除算法的缺点有两个：首先，效率问题，标记和清除效率都不高。其次，标记清除之后会产生大量的不连续的内存碎片，空间碎片太多会导致当程序需要为较大对象分配内存时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

(2).复制算法：

将可用内存按容量分成大小相等的两块，每次只使用其中一块，当这块内存使用完了，就将还存活的对象复制到另一块内存上去，然后把使用过的内存空间一次清理掉。这样使得每次都是对其中一块内存进行回收，内存分配时不用考虑内存碎片等复杂情况，只需要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。

复制算法的缺点显而易见，可使用的内存降为原来一半。

(3).标记-整理算法：

标记-整理算法在标记-清除算法基础上做了改进，标记阶段是相同的标记出所有需要回收的对象，在标记完成之后不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，在移动过程中清理掉可回收的对象，这个过程叫做整理。

标记-整理算法相比标记-清除算法的优点是内存被整理以后不会产生大量不连续内存碎片问题。

复制算法在对象存活率高的情况下就要执行较多的复制操作，效率将会变低，而在对象存活率高的情况下使用标记-整理算法效率会大大提高。

(4).分代收集算法：

根据内存中对象的存活周期不同，将内存划分为几块，java的虚拟机中一般把内存划分为新生代和年老代，当新创建对象时一般在新生代中分配内存空间，当新生代垃圾收集器回收几次之后仍然存活的对象会被移动到年老代内存中，当大对象在新生代中无法找到足够的连续内存时也直接在年老代中创建。

现在的Java虚拟机就联合使用了分代复制、标记-清除和标记-整理算法，java虚拟机垃圾收集器关注的内存结构如下：

堆内存被分成新生代和年老代两个部分，整个堆内存使用分代复制垃圾收集算法。

(1).新生代：

新生代使用复制和标记-清除垃圾收集算法，研究表明，新生代中98%的对象是朝生夕死的短生命周期对象，所以不需要将新生代划分为容量大小相等的两部分内存，而是将新生代分为Eden区，Survivor from和Survivor to三部分，其占新生代内存容量默认比例分别为8：1：1，其中Survivor from和Survivor to总有一个区域是空白，只有Eden和其中一个Survivor总共90%的新生代容量用于为新创建的对象分配内存，只有10%的Survivor内存浪费，当新生代内存空间不足需要进行垃圾回收时，仍然存活的对象被复制到空白的Survivor内存区域中，Eden和非空白的Survivor进行标记-清理回收，两个Survivor区域是轮换的。

新生代中98%情况下空白Survivor都可以存放垃圾回收时仍然存活的对象，2%的极端情况下，如果空白Survivor空间无法存放下仍然存活的对象时，使用内存分配担保机制，直接将新生代依然存活的对象复制到年老代内存中，同时对于创建大对象时，如果新生代中无足够的连续内存时，也直接在年老代中分配内存空间。

Java虚拟机对新生代的垃圾回收称为Minor GC，次数比较频繁，每次回收时间也比较短。

使用java虚拟机-Xmn参数可以指定新生代内存大小。

(2).年老代：

年老代中的对象一般都是长生命周期对象，对象的存活率比较高，因此在年老代中使用标记-整理垃圾回收算法。

Java虚拟机对年老代的垃圾回收称为MajorGC/Full GC，次数相对比较少，每次回收的时间也比较长。

当新生代中无足够空间为对象创建分配内存，年老代中内存回收也无法回收到足够的内存空间，并且新生代和年老代空间无法在扩展时，堆就会产生OutOfMemoryError异常。

java虚拟机-Xms参数可以指定最小内存大小，-Xmx参数可以指定最大内存大小，这两个参数分别减去Xmn参数指定的新生代内存大小，可以计算出年老代最小和最大内存容量。

(3).永久代：

java虚拟机内存中的方法区在Sun HotSpot虚拟机中被称为永久代，是被各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。永久代垃圾回收比较少，效率也比较低，但是也必须进行垃圾回收，否则会永久代内存不够用时仍然会抛出OutOfMemoryError异常。

永久代也使用标记-整理算法进行垃圾回收，java虚拟机参数-XX:PermSize和-XX:MaxPermSize可以设置永久代的初始大小和最大容量。
### C++类的对象和类的指针的区别

```c++
#include <iostream> 
#include <string> 
using namespace std; 
class Student 
{ 
public: 
static int number;  
string name; 

public: 
Student() { } 
void set(string str) 
{ 
name = str; 
number++;    // 调用静态数据成员 
} 

void print()  // 态成员函数 print() 
{ 
std::cout < < name < <" : The number of the students is " < < number < < " numbers." < < std::endl; // 调用静态数据成员 
} 
}; 

int Student::number = 0;  // 静态数据成员初始化 

int main(int argc, char** argv) 
{ 
Student* s1; 
s1 = new Student(); 
s1->set("111"); 

Student s2; 
s2.set("222"); 

s1->print(); 
s2.print(); 

return 0; 
}
```

**对于类student ，定义了一个对象和一个指针。**

**类的指针:**他是一个内存地址值,他指向内存中存放的类对象(包括一些成员变量所赋的值).
**对象:**他是利用类的构造函数在内存中分配一块内存(包括一些成员变量所赋的值).
**在应用时:**
1.引用成员: 对象用" . "操作符; 指针用" -> "操作符.
2.生命期: 若是成员变量,则是类的析构函数来释放空间;若是函数中的临时变量,则作用域是该函数体内;而指针,则需利用delete 在相应的地方释放分配的内存块.
注意:用new ,一定要delete..

**类的对象:用的是内存栈,是个局部的临时变量.**
**类的指针:用的是内存堆,是个永久变量,除非你释放它.**


当类是有虚函数的基类,Func是它的一个虚函数,则调用Func时:
类的对象:调用的是它自己的Func;
类的指针:调用的是分配给它空间时那种类的Func;

对于一个类的对象和这个类的指针（用new运算符分配内存）在应用时有何区别
**1.类和对象是两回事,对象是类的实例;**
**2.对象是在栈中分配的,使用new生成的对象是在堆中分配的;**
**3.要发挥虚函数的强大作用,必须使用指针来访问对象.**

指针可以实现多态，直接用对象不行
执行定义对象，在栈空间
new处的在堆

注意名字的类型.
一个是Student
一个是Student*
**Student是直接访问一个对象**
**Student\*是间接访问一个对象,因为通过了一个指针作媒介.**
类型决定了你能做什么.

其实作用基本一样 都是为了调用类的成员变量 和成员函数用的
当你希望明确使用这个类的时候，最好使用对象，如果你希望使用C++中的动态绑定，则最好使用指针或者引用
指针和引用用起来更灵活，容易实现多态等

类的指针:他是一个内存地址值,他指向内存中存放的类对象(包括一些成员变量所赋的值).
对象,他是利用类的构造函数在内存中分配一块内存(包括一些成员变量所赋的值).
在应用时:
1.引用成员: 对象用" . "操作符; 指针用" -> "操作符.
2.生命期: 若是成员变量,则是类的析构函数来释放空间;若是函数中的临时变量,则作用域是该函数体内.而指针,则需利用delete 在相应的地方释放分配的内存块.
注意:用new 一定要delete..
当类是有虚函数的基类,f是它的一个虚函数,则调用f时:
类的对象:调用的是它自己的Func;
类的指针:调用的是分配给它空间时那种类的Func;

1.在类的声明尚未完成的情况下，可以声明指向该类的指针，但是不可声明该类的对象...
2.父类的指针可以指向子类的对象..

定义对象实例时，分配了内存。指针变量则未分配类对象所需内存
指针变量是间接访问，但可实现多态（通过父类指针可调用子类对象），并且没有调用构造函数。
直接声明可直接访问，但不能实现多态，声明即调用了构造函数（已分配了内存）。
至于那个效率高要看程序调用过程而定。

C++的精髓之一就是多态性，只有指针或者引用可以达到多态。对象不行

**用指针：**
第一实现多态。
第二，在函数调用，传指针参数。不管你的对象或结构参数多么庞大，你用指针，传过去的就是4个字节。如果用对象，参数传递占用的资源就太大了
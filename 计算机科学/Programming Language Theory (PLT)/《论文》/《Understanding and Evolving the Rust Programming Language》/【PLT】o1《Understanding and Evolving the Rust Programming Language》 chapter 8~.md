
 #  
 Thought for 16 seconds
**概览：**

这段内容是关于Rust编程语言的基本概念，特别是其类型系统的核心特性。Rust以其独特的所有权和借用机制而闻名，这些机制确保了内存安全和数据竞争的预防。本文详细讨论了Rust的排他性原则（又称为“可变性 XOR 别名”原则），并深入解释了所有权、可变引用、共享引用以及内部指针等概念，以及它们如何协同工作来确保程序的安全性和高效性。

**详细解读：**

**第8章：Rust入门**

在这一章中，作者旨在介绍Rust类型系统的一些核心特性，以帮助理解RustBelt和Stacked Borrows等高级主题。即使你之前对Rust并不熟悉，这一章也会带你逐步了解关键概念。

**排他性原则（Mutability XOR Aliasing）：**

Rust类型系统的关键原则是排他性原则，也被称为“可变性 XOR 别名”原则。这个原则的核心是：

- **数据要么被唯一的指针独占地可变访问；**
- **要么被多个参与者不可变地共享；**
- **但不能同时兼有这两种情况。**
这个原则的主要目的是防止数据竞争（data race），即跨线程边界共享的可变状态。同时，它也防止了在低级指针操作程序中常见的错误，如使用已释放的内存（use-after-free）和重复释放内存（double-free）。

**所有权和借用机制：**

Rust通过所有权和借用这两个关键机制来实现排他性原则。

**8.1 所有权和所有权转移**

在Rust中，变量的类型不仅表示它可以取的值，还表示与该变量相关的资源（如内存或文件描述符）的所有权。当一个变量在函数或线程之间传递时，相关的所有权会被转移或“移动”。

**示例分析：**

```rust
let (snd, rcv) = channel();
join(
    move || {
        let mut v = Vec::new(); v.push(0); // v: Vec
        snd.send(v);
        // v.push(1); // 编译器错误：v 已被移动
    },
    move || {
        let v = rcv.recv().unwrap(); // v: Vec
        println!("Received: {:?}", v);
    }
);
```

- **解释：**使用 channel() 创建一个多生产者单消费者的通道，返回发送端 snd 和接收端 rcv。join 函数用于并行执行两个闭包。第一个闭包：创建一个新的可变向量 v，并推入一个元素 0。使用 snd.send(v) 发送向量 v。试图再次使用 v.push(1) 会导致编译错误，因为 v 的所有权已被移动。第二个闭包：使用 rcv.recv().unwrap() 接收向量 v。打印接收到的向量。
- **所有权转移：**当 v 被传递给 send 函数时，所有权被移动到函数内部，调用者不再拥有 v。因此，在 v 被发送后，尝试再次使用它会导致编译错误。
- **内存管理：**Rust 自动管理内存。当变量超出作用域且未被移动时，编译器会自动调用析构函数 drop。在示例中，接收端的 v 在打印后超出作用域，Rust 自动释放其内存。
**8.2 可变引用**

独占所有权虽然安全，但过于严格。为了更方便地操作数据，Rust引入了借用机制，特别是可变引用。

- **可变引用的特点：**通过 &mut 创建，可暂时借用数据的可变访问权。可变引用是唯一的，不能有其他别名访问相同的数据。在借用期间，原始数据的所有权仍然在借出方，但只能通过引用访问。
- **示例：**
```rust
let mut v = Vec::new();
v.push(1);
```

- **解释：**v.push(1) 等价于 Vec::push(&mut v, 1)。&mut v 创建了对 v 的可变引用，允许在函数内部修改 v。
**8.3 共享引用**

共享引用是可变引用的对偶，允许数据的别名但禁止修改。

- **共享引用的特点：**通过 & 创建，可读取但不可修改数据。可以被复制，允许多个别名存在。保证在持有共享引用期间，数据不会被修改。
- **示例：**
```rust
let mut v = vec![10, 11];
join(
    || println!("Thread 1: {:?}", &v),
    || println!("Thread 2: {:?}", &v)
);
v.push(2);
```

- **解释：**在两个线程中，分别持有对 v 的共享引用 &v，并打印其内容。由于共享引用是只读的，且 &v 可以被复制，两个线程可以安全地并发读取 v。在 join 返回后，主线程重新获得对 v 的独占访问权，可以继续修改 v。
**复制类型和Copy Trait**

- **Copy Trait：**Rust使用标记trait来表示类型的特性，如“可复制”。实现了 Copy trait 的类型可以通过浅拷贝进行复制。基本类型如 i32、&T（任意类型的引用）都实现了 Copy。像 Vec<i32> 这样的类型没有实现 Copy，因为浅拷贝不会复制堆上的数据。
**8.4 内部指针**

即使在单线程程序中，排他性原则仍然至关重要，特别是涉及内部指针时。

- **内部指针的定义：**指向另一个数据结构内部的指针。常见于需要高效存储和访问的数据结构中。
- **问题示例：**
```rust
let mut v = vec![10, 11];
let vptr = &mut v[1]; // 指向 v 内部的元素
v.push(12); // 可能导致 v 的底层存储重新分配
println!("v[1] = {}", *vptr); // 编译错误！
```

- **解释：**vptr 是一个可变引用，指向 v 的第二个元素。v.push(12) 可能会导致 v 的底层数组在堆上重新分配，旧的内存被释放。vptr 现在指向已释放的内存，导致悬空指针，这是内存安全问题。Rust 编译器会在编译时检测到这一问题，拒绝编译该程序。
- **排他性原则的作用：**在持有对 v 内部元素的可变引用期间，不能对 v 本身进行可变操作。这确保了在内部指针存在时，数据的完整性和安全性。
**全面总结：**

本文详细介绍了Rust编程语言中类型系统的核心特性，重点阐述了排他性原则及其在防止数据竞争和内存安全问题中的作用。通过所有权和借用机制，Rust能够在编译时确保数据的安全访问：

- **所有权：** 每个值都有一个所有者，当所有者离开作用域时，值被丢弃。
- **所有权转移：** 当值被移动时，所有权被转移，原所有者不再拥有该值。
- **可变引用：** 允许临时的、独占的可变访问，确保在借用期间没有其他访问者。
- **共享引用：** 允许多个不可变的别名访问，确保数据在借用期间不被修改。
- **Copy Trait：** 标记类型是否可以被浅拷贝，以控制数据的复制行为。
- **内部指针：** 指向数据结构内部的指针，需要严格遵守排他性原则以防止悬空指针和内存安全问题。
通过这些机制，Rust在保证内存安全的同时，提供了高效的内存管理和数据操作方式。即使在涉及复杂的指针操作和多线程并发的情况下，Rust的类型系统也能在编译时捕获潜在的问题，减少运行时错误的发生。这使得Rust成为一个既高性能又安全可靠的系统编程语言。
 #  
 Thought for 15 seconds
**概览：**

这段内容详细介绍了 Rust 编程语言的核心特性，特别是其类型系统如何通过所有权和借用机制来保证内存安全和数据竞争的预防。主要讨论了以下关键概念：

- **排他性原则（Mutability XOR Aliasing）**：数据要么被唯一地可变访问，要么被多个地方不可变地共享，但不能同时发生。
- **所有权和所有权转移**：变量的所有权可以在函数或线程之间移动，所有权的转移会影响变量的使用权限。
- **可变引用和共享引用**：通过借用机制，Rust 提供了安全的方式来临时访问或共享数据。
- **内部指针**：指向数据结构内部的指针，强调了在单线程环境中排他性原则的重要性。
**详细解读：**

### **8. Rust 入门**

本章旨在介绍 Rust 类型系统的核心特性，特别关注所有权、借用和引用等机制，这些机制对于理解 RustBelt 和 Stacked Borrows 至关重要。

#### **排他性原则（Mutability XOR Aliasing）**

- **定义**：数据可以被独占地可变访问，或者被不可变地共享，但不能同时具备这两种特性。
- **目的**：防止数据竞争和内存安全问题，如使用已释放的内存和重复释放内存。
- **影响**：这个原则不仅在多线程环境中防止数据竞争，还在单线程环境中防止内存安全错误。
#### **8.1 所有权和所有权转移**

**所有权概念：**

- **所有权表示**：在 Rust 中，变量的类型不仅表示其值类型，还表示其对相关资源（如内存、文件描述符等）的所有权。
- **所有权转移**：当变量在函数或线程之间传递时，所有权会被移动，称为“移动语义”。
**示例分析：**

考虑以下代码片段：

```rust
let (sender, receiver) = channel();

join(
    move || {
        let mut v = Vec::new();
        v.push(0);
        sender.send(v);
        // 此处不能再使用 v，例如 v.push(1); 会导致编译错误
    },
    move || {
        let v = receiver.recv().unwrap();
        println!("Received: {:?}", v);
    }
);
```

**解释：**

- **通道创建**：channel() 函数创建一个多生产者、单消费者的通道，返回发送端和接收端。
- **并行执行**：join() 函数并行执行两个闭包，每个闭包在自己的线程中运行。
- **所有权移动**：**发送端闭包**：创建一个可变向量 v，并添加元素。使用 sender.send(v) 发送向量 v。此时，v 的所有权被移动到通道中。之后尝试再次使用 v（例如 v.push(1);）会导致编译错误，因为 v 的所有权已被移动。**接收端闭包**：使用 receiver.recv().unwrap() 接收向量 v。recv() 可能会失败，所以使用 unwrap() 来处理错误。打印接收到的向量。
**所有权机制的作用：**

- **防止数据竞争**：通过所有权的移动，确保同一资源不会在多个线程中同时被访问。
- **内存管理**：Rust 编译器在变量超出作用域且未被移动时，会自动调用 drop 函数来释放资源，无需显式管理内存。
#### **8.2 可变引用**

**借用概念：**

- **可变引用 (&mut)**：允许函数在不获取所有权的情况下，暂时获得对数据的可变访问权。
- **独占性**：可变引用是独占的，在借用期间，不能有其他引用访问同一数据。
**示例分析：**

```rust
let mut v = Vec::new();
v.push(1);
```

- **等价写法**：v.push(1); 等价于 Vec::push(&mut v, 1);，其中 &mut v 创建了对 v 的可变引用。
- **机制**：在 push 函数内部，v 被可变借用，可以安全地修改。借用结束后，v 可以再次被使用。
**可变引用的作用：**

- **提高效率**：避免了所有权的频繁移动，提高了代码的简洁性和执行效率。
- **安全性**：通过独占性，防止了同时存在多个可变引用导致的数据竞争。
#### **8.3 共享引用**

**共享引用 (&)：**

- **特点**：允许对数据的只读访问。可以被复制，允许多个引用同时存在。
- **限制**：在持有共享引用期间，数据不能被修改。共享引用本身是不可变的，但如果引用的是可变引用的引用，则可以间接修改。
**示例分析：**

```rust
let mut v = vec![1, 2, 3];

join(
    || {
        println!("Thread 1: {:?}", &v);
    },
    || {
        println!("Thread 2: {:?}", &v);
    }
);

v.push(4);
```

**解释：**

- **并发读取**：两个线程分别持有对 v 的共享引用，可以安全地并发读取数据。
- **借用规则**：在 join 执行期间，v 被共享借用，主线程无法修改 v。join 返回后，主线程重新获得对 v 的可变访问权，可以继续修改。
**共享引用的作用：**

- **灵活性**：允许在不复制数据的情况下，在多个地方读取同一数据。
- **安全性**：通过禁止修改，防止了数据竞争和不一致性。
**复制类型和 Copy Trait：**

- **Copy Trait**：表示类型可以通过位复制来复制（浅拷贝）。实现了 Copy 的类型可以在赋值或传递时被复制，而不是移动。
- **示例**：基本类型如 i32、f64 实现了 Copy。复合类型如 Vec<T> 没有实现 Copy，因为浅拷贝不会复制堆上的数据。
**Copy Trait 的作用：**

- **控制数据复制行为**：防止意外的深度复制导致的性能问题。
- **类型安全**：确保只有适合被复制的类型才能被复制，防止不安全的内存操作。
#### **8.4 内部指针**

**内部指针概念：**

- **定义**：指向数据结构内部某个位置的指针，例如指向向量中的某个元素。
- **风险**：如果数据结构发生变化，内部指针可能变为悬空指针，导致内存安全问题。
**示例分析：**

```rust
let mut v = vec![1, 2, 3];
let elem_ref = &mut v[1];

v.push(4); // 可能导致 v 的底层存储重新分配

println!("Element: {}", elem_ref);
```

**解释：**

- **问题**：elem_ref 是指向 v 内部元素的可变引用。v.push(4) 可能会导致 v 的底层数组重新分配到新的内存位置。elem_ref 仍然指向旧的内存位置，导致悬空指针。
- **编译器检测**：Rust 编译器会在编译时检测到这种情况，防止内存安全错误。错误信息通常是“同时存在可变借用和不可变借用”或“可变借用在不可变借用之前未结束”。
**排他性原则在内部指针中的作用：**

- **防止同时修改和访问**：在持有内部指针的可变引用期间，不能对原数据结构进行修改。
- **保证内存安全**：避免悬空指针、数据竞争等内存安全问题。
**全面总结：**

本段内容深入探讨了 Rust 编程语言的核心特性，特别是其类型系统如何通过所有权和借用机制来保证内存安全和数据竞争的预防。主要结论如下：

1. **排他性原则的重要性**：
- 通过严格的类型系统，Rust 确保了数据要么被独占地可变访问，要么被不可变地共享，防止了数据竞争和内存安全问题。
- 这个原则在多线程和单线程环境中都至关重要，尤其是在涉及内部指针的情况下。
2. **所有权和所有权转移**：
- 所有权是 Rust 类型系统的核心概念，每个值都有唯一的所有者。
- 所有权可以在函数或线程之间移动，移动后原所有者不再拥有该值，防止了重复使用已释放的资源。
3. **借用机制（可变引用和共享引用）**：
- **可变引用**允许临时地独占地可变访问数据，期间其他引用不能访问该数据。
- **共享引用**允许同时存在多个只读访问，数据在共享借用期间不能被修改。
- 借用机制使得函数可以在不获取所有权的情况下访问数据，提高了代码的灵活性和性能。
4. **Copy Trait 和类型复制**：
- Copy trait 用于标记可以被浅拷贝的类型，防止了意外的深度复制导致的性能问题。
- Rust 通过类型系统控制数据的复制行为，确保只有适合被复制的类型才能被复制。
5. **内部指针和内存安全**：
- 内部指针指向数据结构内部的元素，容易在数据结构变化时导致悬空指针。
- Rust 的类型系统通过排他性原则，防止在持有内部指针的情况下对数据结构进行修改，保证了内存安全。
**结论：**

Rust 通过其独特的所有权和借用机制，实现了在编译时保证内存安全和数据竞争预防。这使得开发者可以编写高性能的系统级代码，而不必担心传统的内存安全问题。Rust 的类型系统严格但灵活，提供了丰富的工具来管理资源和数据访问，同时保持了代码的高效性和可读性。
 #  
 Thought for 1m 32s
**概览：**

这段内容深入介绍了 Rust 编程语言中关于**生命周期（lifetimes）**的概念，特别是它们在所有权和借用机制中的作用。Rust 使用生命周期来管理引用的有效期，确保引用在使用时指向有效的内存，防止悬垂引用和内存安全问题。文章还讨论了借用检查器（borrow checker）如何通过生命周期来强制执行借用规则，以及生命周期之间的包含关系。此外，文中介绍了可变引用的重借用、原始指针的使用、内部可变性（interior mutability）以及线程安全特性（如 `Send` 和 `Sync`）在 Rust 中的实现方式。

**详细解读：**

### **8.5 生命周期（Lifetimes）**

#### **1. 引入生命周期的必要性**

在前面的章节中，我们了解了可变引用（`&mut T`）和共享引用（`&T`）如何借用所有权，从而临时访问数据结构。然而，一个关键问题是：**这个“临时”到底有多长？**

- **生命周期的作用**：生命周期回答了引用可以安全使用的时间范围。它确保引用在使用时，其所指向的数据仍然有效，避免悬垂引用（dangling references）的问题。
#### **2. 引用类型的完整形式**

- **完整的引用类型**：`&'a mut T` 或 `&'a T`，其中 `'a` 是引用的生命周期参数。&'a mut T：具有生命周期 'a 的可变引用。&'a T：具有生命周期 'a 的共享引用。
- **生命周期省略**：Rust 使用了生命周期省略规则（lifetime elision），使得在大多数情况下可以省略生命周期参数。这就是为什么在之前的代码示例中，没有看到显式的生命周期标注。
#### **3. 借用检查器的两个关键约束**

为了确保引用的正确使用，Rust 编译器的借用检查器强制执行以下两个约束条件：

1. **引用的使用期限**
- **约束（1）**：引用只能在其生命周期 'a 内使用。
- **意义**：防止引用在其所指向的数据失效后继续被使用，避免悬垂引用。
2. **原始被引用对象的使用限制**
- **约束（2）**：**对于可变引用**：在引用的生命周期 'a 结束之前，原始被引用的对象不能被使用。**对于共享引用**：在引用的生命周期 'a 结束之前，原始被引用的对象不能被修改。
- **意义**：确保在借用期间，原始对象的状态不会发生变化，从而保证引用的有效性和安全性。
#### **4. 借用检查器的工作原理**

- **借用和贷款（loans）**：当创建一个引用时，借用检查器会在原始被引用对象上附加一个“贷款”（loan）。这个贷款的生命周期与引用的生命周期相同，表示在此期间，原始对象受到一定的使用限制。
- **使用原始对象时的检查**：**可变使用**：当尝试对原始对象进行可变操作时，编译器会检查是否存在任何未结束的贷款。如果有，则操作被拒绝。**只读使用**：对于只读操作，编译器只需确保没有未结束的可变贷款。
- **生命周期的推断和检查**：借用检查器会收集所有的借用约束，并尝试为引用分配合适的生命周期，使得所有约束都得到满足。如果无法找到符合条件的生命周期分配，编译器会给出错误提示。
#### **5. 示例分析：借用检查器如何拒绝不安全的代码**

**示例代码**（稍作简化并添加生命周期标注）：

```rust
let mut v = vec![10, 11];
let vptr = &'a mut v[1];
Vec::push(&'b mut v, 12);
println!("v[1] = {}", *vptr);
```

**解释**：

- **第 1 行**：创建一个可变向量 v，包含元素 [10, 11]。
- **第 2 行**：创建对 v[1] 的可变引用 vptr，生命周期为 'a。
- **第 3 行**：对 v 进行可变借用，调用 push 方法，生命周期为 'b。
- **第 4 行**：使用可变引用 vptr，需要其生命周期 'a 仍然有效。
**借用检查器的分析**：

- **约束（1）**：vptr 在其生命周期 'a 内使用，这是允许的。
- **约束（2）**：在 vptr 的生命周期 'a 结束之前，不能对 v 进行任何使用（因为 vptr 是对 v 内部元素的可变引用）。
**问题出现的原因**：

- **生命周期重叠**：'a 和 'b 的生命周期存在重叠，而且在 'a 未结束时，对 v 进行了可变借用。
- **违反约束（2）**：在 vptr 的生命周期 'a 内，对 v 进行了可变借用，这违反了对 v 的使用限制。
**结果**：

- 编译器拒绝编译该代码，提示存在借用冲突。
#### **6. 解决方法：调整代码顺序**

通过重新排列代码，可以避免借用冲突：

```rust
let mut v = vec![10, 11];
Vec::push(&'b mut v, 12);
let vptr = &'a mut v[1];
println!("v[1] = {}", *vptr);
```

**分析**：

- **第 2 行**：首先对 v 进行可变借用，调用 push 方法，生命周期为 'b。
- **第 3 行**：在 'b 生命周期结束后，创建对 v[1] 的可变引用 vptr，生命周期为 'a。
- **借用检查器的检查**：在创建 vptr 时，没有未结束的对 v 的可变借用，因此约束得到满足。
- **结果**：编译器接受该代码，因为所有的借用约束都得到了满足。
#### **7. 重借用（Reborrowing）**

**概念**：

- **重借用**：从一个已有的引用创建另一个引用的过程，通常发生在可变引用之间。
- **生命周期的嵌套**：在重借用中，新引用的生命周期必须包含在原引用的生命周期内。
**示例代码**：

```rust
let mut v = vec![10, 11];
let v2 = &'a mut v;
let vptr = &'b mut (*v2)[1];
println!("v[1] = {}", *vptr);
Vec::push(v2, 12);
```

**分析**：

- **第 2 行**：创建对 v 的可变引用 v2，生命周期为 'a。
- **第 3 行**：从 v2 重借用，对 v[1] 的可变引用 vptr，生命周期为 'b。
- **生命周期关系**：'b 必须包含在 'a 中，即 'b 的生命周期不能超过 'a。
**借用检查器的检查**：

- **在 'b 生命周期内**：vptr 可以被使用。v2 被借出，不能被使用（有一个未结束的借用）。
- **在 'b 生命周期结束后**：v2 可以重新被使用。
**结果**：

- 编译器接受该代码，因为借用约束得到了满足。
**注意**：

- 如果在 'b 生命周期内再次使用 v2，例如调用 Vec::push(v2, 12);，会违反借用约束，编译器会拒绝编译。
#### **8. 生命周期的包含关系**

- **包含关系定义**：如果生命周期 'b 包含在 'a 中，表示 'b 的生命周期必须在 'a 内结束。
- **重要性**：确保重借用的引用不会在原引用失效后继续存在，防止悬垂引用。
#### **9. 共享引用的生命周期**

**特点**：

- 共享引用允许多个引用同时存在，生命周期可以重叠，而不必嵌套。
- 共享引用的借用检查器规则有所不同。
**示例代码**：

```rust
let mut v = vec![10, 11];
let vptr = &'a v[1];
let vptr2 = &'b v[1];
println!("v[1] = {}", *vptr);
println!("v[1] = {}", *vptr2);
```

**分析**：

- **第 2 行和第 3 行**：创建了两个对 v[1] 的共享引用，生命周期分别为 'a 和 'b。
- **生命周期可以重叠**：共享引用的生命周期不需要嵌套，可以同时存在。
- **借用检查器的检查**：允许多个共享引用同时存在。在共享引用的生命周期内，原始对象 v 不能被修改。
**注意**：

- 如果在共享引用的生命周期内对 v 进行修改，例如 v.push(12);，编译器会拒绝编译，提示借用冲突。
#### **10. 原始指针（Raw Pointers）**

**动机**：

- 有时，借用检查器的规则可能过于严格，限制了程序的实现，例如需要在数据结构中形成循环引用。
- 原始指针允许程序员绕过借用检查器，但需要手动保证安全性。
**特点**：

- **类型**：*const T（不可变原始指针），*mut T（可变原始指针）。
- **没有借用和生命周期检查**：编译器不会对原始指针进行借用检查。
- **需要在 unsafe 块中使用**：表示程序员需要手动保证操作的安全性。
**示例代码**：

```rust
let mut x = 42;
let ptr1 = &mut x as *mut i32; // 创建原始指针
let ptr2 = ptr1;               // 创建别名的原始指针
unsafe {
    *ptr1 = 13;                // 通过 ptr1 修改值
}
unsafe {
    println!("{}", *ptr2);     // 通过 ptr2 读取值，输出 13
}
```

**分析**：

- **第 2 行**：将可变引用转换为可变原始指针。
- **第 3 行**：复制原始指针，形成别名。
- **unsafe 块**：对原始指针的读写操作需要在 unsafe 块中进行。
**注意**：

- 使用原始指针需要非常谨慎，确保不会违反内存安全。
- 原始指针可以绕过借用检查器，但也因此可能引入未定义行为。
#### **11. 内部可变性（Interior Mutability）**

**动机**：

- 有时需要在多个地方共享数据并进行修改，这与借用检查器的规则相冲突。
- Rust 提供了内部可变性机制，允许通过共享引用对数据进行修改。
**实现方式**：

- **类型**：Cell<T>、RefCell<T>、Mutex<T> 等。
- **特点**：通过特殊的 API，实现了对借用检查器规则的安全绕过。
##### **Cell 类型**

**特点**：

- 允许在单线程环境下，通过共享引用对数据进行修改。
- **限制**：只能存储实现了 Copy trait 的类型，无法获取对内部值的引用。
**示例代码**：

```rust
let c1: &Cell = &Cell::new(0);
let c2: &Cell = c1; // 创建共享引用
c1.set(2);
println!("{:?}", c2.get()); // 输出 2
```

**分析**：

- **共享引用**：c1 和 c2 都是对同一个 Cell<i32> 的共享引用。
- **内部可变性**：可以通过 set 方法修改内部值，即使是通过共享引用。
- **安全性**：**限制**：Cell<T> 只能存储实现了 Copy 的类型，防止了数据竞争和内存安全问题。**不能获取内部值的引用**：避免了悬垂引用的问题。
**线程安全性**：

- Cell<T> 不实现 Sync，因此共享引用不能跨线程传递，防止了数据竞争。
##### **Send 和 Sync 特质**

- **Send**：表示类型可以安全地在线程间传递所有权。
- **Sync**：表示类型的共享引用可以安全地在多个线程中使用。
**关系**：

- 如果 T 实现了 Sync，则 &T 实现了 Send。
**在 Cell<T> 中**：

- Cell<T> 实现了 Send，但不实现 Sync。
- 因此，&Cell<T> 不实现 Send，不能在多线程环境中共享。
**示例代码（线程安全性问题）**：

```rust
let c = &Cell::new(0);
join(|| c.set(1), || println!("{:?}", c.get()));
```

- **分析**：尝试在两个线程中共享对 Cell 的引用，会导致数据竞争。
- **结果**：编译器拒绝编译，提示 &Cell<T> 不实现 Send。
##### **Mutex 类型**

**特点**：

- 允许在多线程环境下安全地共享和修改数据。
- 通过互斥锁（mutex）机制，确保同时只有一个线程可以访问数据。
**示例代码**：

```rust
let mutex = Mutex::new(Vec::new());
join(
    || {
        let mut guard = mutex.lock().unwrap();
        guard.push(0);
    },
    || {
        let mut guard = mutex.lock().unwrap();
        println!("{:?}", guard);
    }
);
```

**分析**：

- **Mutex 的作用**：保护内部数据，防止数据竞争。
- **MutexGuard**：表示对互斥锁的持有，离开作用域时自动释放锁。
- **内部可变性**：通过 Mutex，可以在共享引用的情况下，对内部数据进行修改。
**线程安全性**：

- Mutex<T> 实现了 Sync，因此可以安全地在多个线程中共享。
- 互斥锁机制确保了数据的访问是互斥的，防止了数据竞争。
#### **12. 总结**

- **生命周期**：用于管理引用的有效期，防止悬垂引用和内存安全问题。
- **借用检查器**：通过借用和贷款机制，强制执行借用规则，确保引用的安全使用。
- **重借用**：允许从已有引用创建新的引用，生命周期必须包含在原引用的生命周期内。
- **共享引用的生命周期**：可以重叠，允许多个共享引用同时存在，但在此期间数据不能被修改。
- **原始指针**：允许绕过借用检查器，但需要在 unsafe 块中使用，程序员需手动保证安全性。
- **内部可变性**：通过特殊类型（如 Cell、Mutex），在安全的前提下，允许在共享引用的情况下修改数据。
- **线程安全特性**：Send 和 Sync 特质用于标记类型的线程安全性，编译器根据这些特质决定类型能否在线程间传递或共享。
**全面总结：**

本文深入探讨了 Rust 编程语言中的生命周期概念，以及它们在所有权和借用机制中的关键作用。通过引入生命周期，Rust 能够在编译时准确地管理引用的有效期，防止悬垂引用和内存安全问题。借用检查器通过对借用和贷款的跟踪，确保引用在其生命周期内安全地使用，避免了数据竞争和未定义行为。

重借用和生命周期的包含关系，使得开发者可以灵活地从已有引用创建新的引用，同时保持内存安全。共享引用的生命周期可以重叠，允许多个共享引用同时存在，但在此期间禁止对数据进行修改，保证了数据的一致性和安全性。

对于借用检查器过于严格的情况，Rust 提供了原始指针和内部可变性机制。原始指针允许开发者在需要时绕过借用检查器，但要求在 `unsafe` 块中使用，由开发者手动保证安全性。内部可变性类型（如 `Cell`、`Mutex`）提供了安全的 API，使得在特定情况下，可以在共享引用的情况下修改数据。

线程安全特性 `Send` 和 `Sync` 使得 Rust 能够在编译时检查类型的线程安全性，防止数据竞争和内存安全问题。通过这些机制，Rust 实现了内存安全和线程安全的保证，同时保持了高性能和灵活性。

总的来说，Rust 的生命周期和借用机制提供了强大的内存安全保障，帮助开发者在编写高性能系统级代码的同时，避免常见的内存错误和数据竞争问题。这些特性使得 Rust 成为一个既安全又高效的编程语言，适用于对性能和安全性要求极高的领域。
 #  
 Thought for 1m 40s
**概览：**

这段内容介绍了 **λRust**，这是一个对 Rust 编程语言进行形式化建模的语言。为了简化形式化过程，λRust 仅使用一小部分基本构造，并要求将 Rust 表面语言中的高级语法糖解构为这些基本原语。λRust 更接近于 Rust 编译器中的中级中间表示（MIR），使得对 Rust 的类型系统和语义进行形式化分析更加可行。文章首先概述了 λRust 的关键特性，然后详细介绍了其语法，包括值、路径、函数体和指令等部分，旨在为理解 λRust 的操作语义和类型系统奠定基础。

**详细解读：**

### **第9章 λRust语言和类型系统**

#### **引言**

本章旨在介绍 **λRust**，这是 Rust 编程语言的一个形式化版本。Rust 的表面语言包含大量的 **语法糖**（syntactic sugar），为了简化形式化，我们需要将这些高级语法糖 **解糖**（desugared）为 λRust 的基本原语。这与 Rust 编译器的处理方式类似，编译器将表面 Rust 降低为中级中间表示（**MIR**）。因此，λRust 与 MIR 更加接近，而不是直接对应于表面 Rust。

#### **λRust 的关键特性**

在介绍 λRust 的语法、操作语义和类型系统之前，先强调其几个关键特性：

1. **使用 Continuation-Passing Style（CPS） 表示程序**
- **定义**：CPS 是一种编程范式，程序被转换为显式传递控制流的形式，其中函数接受一个额外的参数，即 **continuation**，表示程序剩余的执行部分。
- **优势**：这种表示方法使我们能够更自然地表示复杂的控制流结构，如 Rust 中的 **带标签的 break 和提前返回**。
- **关联**：CPS 与 **控制流图（Control-Flow Graphs，CFG）** 之间存在对应关系，这使得 λRust 更容易与 MIR 关联。
2. **简化的指令集**
- **特点**：λRust 中的指令执行单一操作，避免了大型的复合表达式。
- **好处**：保持指令的简单性，使得类型系统的描述更加简洁，易于理解和形式化。
3. **支持指针运算的内存模型**
- **功能**：λRust 的内存模型支持 **指针算术**，并确保具有数据竞争或非法内存访问的程序在操作语义中会进入 **卡住状态（stuck state）**。
- **意义**：通过类型系统的充分性定理（Theorem 5），保证了在任何执行中都不会卡住的程序是 **数据竞争自由** 的。
#### **字体约定**

- **打字机字体（typewriter font）**：表示 **语言层面的术语**。
- **无衬线字体（sans-serif font）**：表示 **逻辑和类型系统中的术语**。
- **斜体字体（italic font）**：表示 **域（domains）**，对应于 Coq 形式化中的类型。
- **小型大写字体（small-caps font）**：表示 **记录的字段**，在后续的语义类型部分会涉及。
### **9.1 语法**

λRust 的语法定义如下：

#### **基本符号**

- **路径偏移量（path offsets）n** 和 **整数字面量（integer literals）z**：取值范围为整数。
- **和类型的索引（sum indices）i**：取值范围为自然数。
- **变量类型**：**程序变量**：用 x 或 f 表示。**Continuation 变量**：用 k 表示。
#### **表达式分类**

λRust 中的表达式分为四类：**值（Values）**、**路径（Paths）**、**指令（Instructions）** 和 **函数体（Function Bodies）**。

##### **1. 值（Values）**

- 包含最基本的数据类型：**布尔值**：false、true。**整数**：z。**位置（locations）**：⨯（这表示内存位置，具体在 §9.2 中详细讨论）。**函数**：funrec f(x) ret k := F，表示递归函数定义。
- **注意**：没有直接的产品类型（如元组）或和类型（如枚举）的字面量。这些复杂类型在内存中表示为 **值的序列** 或 **带标签的联合体**。
##### **2. 路径（Paths）**

- 用于表示指令操作的值。
- **基本形式**：直接引用局部变量 x。
- **复杂形式**：通过偏移引用复合数据结构的部分：**偏移操作**：p.n，对路径 p 执行指针算术，将指针增加 n 个内存单元。
##### **3. 函数体（Function Bodies）**

- 用于连接指令并管理控制流，主要通过 **continuations** 实现。
- **Continuation 声明**：letcont k(x) := F1 in F2，声明一个 continuation k，参数为 x，主体为 F1，然后在 F2 中可以使用 k。
- **Continuation 调用**：jump k(x)，调用 continuation k，传入参数 x。
- **递归 Continuation**：允许 continuation 是递归的，以模拟循环结构（如 while、for 等）。
- **特殊指令**：**生命周期管理**：newlft 和 endlft，用于开始和结束生命周期。这些指令在类型系统中有特殊的规则，但在操作语义中不执行任何操作（因此被称为“**幽灵指令**”）。
##### **4. 指令（Instructions）**

- **算术操作**：包括加法、减法、小于等于、相等性比较等基本运算。
- **内存操作**：**分配内存**：new(n)，分配 n 个内存单元。**释放内存**：delete(n, p)，释放从指针 p 开始的 n 个内存单元。**读取内存**：*p，从指针 p 指向的内存位置读取值。**写入内存**：p1 := p2，将值 p2 写入到 p1 指向的内存位置。**内存拷贝**：p1 :=n *p2，将从 p2 开始的 n 个内存单元的内容复制到从 p1 开始的内存位置。
- **和类型处理**：**注入（injection）**：p1 inj i := p2，将值 p2 注入到和类型的第 i 个变体，存储在 p1。p1 inj i :=n *p2，将从 p2 开始的 n 个内存单元注入到第 i 个变体，存储在 p1。p1 inj i := ()，用于没有关联数据的变体（如 None）。**匹配（case）**：case *p of F，根据存储在 p 位置的标签，执行对应的分支。**行为**：如果没有匹配的标签，程序会进入 **卡住状态**。
#### **函数声明和调用**

- **函数声明**：funrec f(x) ret k := F，定义了一个递归函数 f，参数为 x，返回时调用 continuation k，函数体为 F。**组成部分**：f：递归调用的绑定符。x：参数列表。k：返回 continuation 的名称。
- **函数调用**：call f(x) ret k，调用函数 f，参数为 x，返回时调用 continuation k。
#### **局部变量的处理**

- **特点**：在 λRust 中，局部变量通过 let 绑定表示，是 **纯值（pure values）**。
- **区别**：这与 Rust（和 MIR）中的局部变量不同，后者是 **可变的** 且 **可寻址的**。
- **解决方案**：为了正确模拟 Rust 的局部变量，我们在 **堆上分配它们**，并以“装箱”（boxed）的方式传递参数，即作为指向内存中值的 **指针**。
#### **示例分析：option_as_mut 函数**

**Rust 代码：**

```rust
fn option_as_mut<'a>(x: &'a mut Option) -> Option<&'a mut i32> {
    match *x {
        None => None,
        Some(ref mut t) => Some(t),
    }
}
```

**λRust 代码：**

```csharp
funrec option_as_mut(x) ret ret :=
    let r = new(2) in
    letcont k() := delete(1, x); jump ret(r) in
    let y = *x in case *y of
        - r inj 0 := (); jump k()
        - r inj 1 := y.1; jump k()
```

**解释：**

- **参数处理**：在 λRust 中，函数参数 x 是一个 **指针**，需要通过 *x 进行解引用才能使用。因为 Rust 函数接受的是一个引用（&mut Option<i32>），所以在 λRust 中，x 实际上是一个指向指针的指针。
- **内存管理**：使用 new(2) 分配了一个新的指针 r，用于存储返回值。在函数返回之前，显式地释放了 x 所指向的内存（delete(1, x)），模拟了栈上变量在作用域结束时被自动释放的行为。
- **控制流**：使用 letcont k() 声明了一个 continuation k，在处理完匹配的分支后跳转到 k。通过 case *y of 对解引用后的值进行模式匹配，根据标签执行不同的分支。
#### **指令的详细说明**

- **算术运算**：支持基本的算术操作，如加法（+）、减法（-）、小于等于（≤）、相等比较（==）等。
- **内存操作**：**分配内存**：new(n)，分配 n 个内存单元。**释放内存**：delete(n, p)，释放从指针 p 开始的 n 个内存单元。**读取内存**：*p，从指针 p 指向的内存位置读取值。**写入内存**：p1 := p2，将值 p2 写入到 p1 指向的内存位置。**内存拷贝**：p1 :=n *p2，将从 p2 开始的 n 个内存单元复制到从 p1 开始的内存位置。
- **线程安全性**：所有这些内存访问都是 **非原子的（non-atomic）**，即 **不** 是线程安全的。在 §9.2 中将进一步讨论这一点。
#### **和类型的处理**

- **表示方式**：Option<i32> 类型的值在内存中表示为 **两个基本值的序列**：**标签（tag）**：一个整数值，表示变体（0 表示 None，1 表示 Some）。**数据**：如果标签为 1，则存储 i32 类型的值；如果标签为 0，第二个值可以是任何内容。
- **指令**：**注入（injection）**：p1 inj i := p2：将值 p2 注入到第 i 个变体，存储在 p1。p1 inj i :=n *p2：将从 p2 开始的 n 个内存单元注入到第 i 个变体，存储在 p1。p1 inj i := ()：用于没有关联数据的变体（如 None）。**匹配（case）**：case *p of F：根据存储在 p 位置的标签，执行对应的分支。**行为**：如果没有匹配的标签，程序会进入 **卡住状态（stuck state）**。
- **布尔值处理**：if p then F1 else F2：用于对存储在 p 中的布尔值进行条件判断。
**全面总结：**

本文详细介绍了 **λRust**，这是对 Rust 编程语言进行形式化建模的语言。为了简化形式化过程，λRust 仅使用一小部分基本构造，需要将 Rust 表面语言中的高级语法糖解构为这些基本原语。这与 Rust 编译器中将表面语言降低为中级中间表示（MIR）的过程类似。λRust 的设计使得我们能够更容易地理解和验证 Rust 的类型系统和语义。

λRust 的关键特性包括：

1. **使用 Continuation-Passing Style（CPS） 表示程序**
- 使得复杂的控制流结构（如带标签的 break 和提前返回）能够自然地表示。
- 与控制流图（CFG）之间的对应关系使得 λRust 更容易与 MIR 关联。
2. **简化的指令集**
- 指令执行单一操作，避免了复杂的复合表达式。
- 这种简化有助于类型系统的清晰描述和形式化验证。
3. **支持指针运算的内存模型**
- 内存模型支持指针算术，并确保具有数据竞争或非法内存访问的程序会进入 **卡住状态**。
- 类型系统的充分性定理保证了在任何执行中都不会卡住的程序是 **数据竞争自由** 的。
λRust 的语法包括值、路径、指令和函数体等部分：

- **值**：包含基本数据类型和函数，没有直接的产品类型或和类型字面量。
- **路径**：用于表示指令操作的值，支持指针算术操作。
- **指令**：包括算术运算、内存操作和和类型的处理指令。
- **函数体**：用于连接指令和管理控制流，主要通过 continuations 实现。
为了正确模拟 Rust 的局部变量，λRust 将它们在堆上分配，并以指针的方式传递参数。这与 Rust 中的局部变量是可变且可寻址的特性一致，但在 λRust 中需要显式地管理内存分配和释放。

通过对 `option_as_mut` 函数的示例分析，我们看到了 λRust 如何表示 Rust 中的函数、控制流和内存管理。λRust 的设计使我们能够形式化地研究 Rust 的类型系统和语义，为 Rust 的安全性和正确性提供了理论基础。

总之，λRust 是对 Rust 进行形式化建模的重要工具，其简化的语法和明确的内存模型使得对 Rust 的类型系统和操作语义进行深入的研究和验证成为可能。这有助于确保 Rust 程序的安全性和可靠性，同时为编程语言理论的发展提供了宝贵的实践案例。
 #  
 Thought for 2m 8s
**概览：**

这段内容深入介绍了 **λRust** 的操作语义，特别是如何将 λRust 转换为一个核心语言 **λRust-core**。核心语言是一个带有基本值、多元函数调用、指针运算和并发特性的 lambda 演算，能够区分原子和非原子访问。文章详细解释了为什么要这样定义语义，以及如何通过核心语言来更容易地推理程序的行为。重点讨论了指针相等性、指针运算、数据竞争和未初始化内存的处理方式，以及 λRust 中的一些构造如何被翻译为核心语言。

**详细解读：**

### **9.2 操作语义（Operational Semantics）**

#### **引言**

- **操作语义的定义**：λRust 的操作语义是通过翻译成一个核心语言 **λRust-core** 来给出的。
- **核心语言的特征**：**lambda 演算**：核心语言是一个 lambda 演算，具有函数抽象和应用的特性。**基本值**：支持基本数据类型，如整数、布尔值、位置等。**多元函数调用**：支持多参数的函数调用。**指针运算**：支持指针的算术运算（例如 e1.e2 表示对指针 e1 进行偏移 e2）。**并发**：包括两个不同的“内存顺序”（memory orders），用于区分 **原子（atomic）** 和 **非原子（non-atomic）** 访问。
#### **为什么这样定义语义**

定义 λRust-core 的原因有三个：

1. **简化推理**：
- 一些 λRust 的构造（例如 p1 :=n *p2）可以被建模为核心语言中的一系列更简单的指令。
- 这使得对程序行为的推理更容易，因为我们可以在更基本的层面上理解程序的执行。
2. **统一处理 Continuations 和函数**：
- 我们可以将 Continuations 和函数都简化为普通的 lambda 项，使用相同的推理原则。
- 这简化了语言的结构，使得理论分析更加一致。
3. **方便替换推理**：
- 核心语言支持基于替换的语义（参考 §7.3），这使得推理更方便。
- 相比之下，上文给出的 CPS 语法并不在替换操作下封闭（即，替换可能会引入新的语法结构），这增加了推理的复杂性。
#### **操作语义的形式定义**

- **Figure 9.3**：操作语义在图 9.3 中被正式定义。
- **评价上下文（Evaluation Contexts）K**：我们使用评价上下文 K 来定义当前表达式中下一个将发生简化的位置（规则 O-ectx）。剩下的规则定义了可能的 **头部化简（head reductions）**。
#### **关键方面的讨论**

以下我们将讨论该语言的一些关键方面，以及 λRust 如何被翻译为核心语言。

#### **1. 指针相等性（Pointer Equality）**

**背景**：

- 在 Rust 中，安全代码可以执行指针相等性测试。
- 但是，在非垃圾回收的语言中（如 C、C++、Rust），指针相等性的处理非常微妙。
**挑战**：

- **内存复用的问题**：为了在编译器中实现语言语义时有最大的自由度，我们通常希望程序无法观察到一个新分配的对象是否重用了之前分配给其他对象的内存。
- **悬空指针比较**：安全代码可以比较任意指针，包括 **悬空指针（dangling pointers）**，即指向已释放内存的指针。
**解决方案**：

- **避免程序观察到分配器的细节**：为了防止程序通过指针比较来推断内存分配的细节，我们采取了不同的方法。
- **非确定性的比较结果**：当比较两个不同的位置 ℓ1 ≠ ℓ2，其中至少有一个是悬空指针时，比较结果是 **非确定性的**：可能是 true（表示为 1），也可能是 false（表示为 0）。这意味着程序无法通过比较结果来推断内存是否被重用了。
**实现方式**：

- **语义定义**：通过规则 O-eq-true 和 O-eq-false，以及辅助判断 h ⊢ v1 = v2 和 h ⊢ v1 ≠ v2，定义了相等性的语义。这些辅助判断根据当前内存状态 h 来确定两个值何时可以被认为是相等或不相等。
- **非互斥性**：需要注意的是，这两个判断并不是互斥的，即在某些情况下，两个值可以同时被认为是相等和不相等。这种设计允许我们在语义上表达比较结果的非确定性。
#### **2. 指针运算（Pointer Arithmetic）**

**背景**：

- λRust 的内存模型受到了 **CompCert** 项目的启发，特别是在如何支持指针运算方面。
- **CompCert** 是一个经过验证的 C 编译器，其内存模型在形式化验证中被广泛使用。
**内存模型的设计**：

- **位置表示**：内存位置 ℓ 被表示为一个 **块索引（block index）** i 和该块内的偏移量 n，即 ℓ = (i, n)。
- **内存表示**：内存 h 是一个从位置到值的 **部分函数**。在我们的模型中，内存位置还包含一个 **锁状态（lock state）**，将在后续讨论。
**指针运算的处理**：

- **偏移操作**：指针运算（规则 O-proj）只作用于偏移量 n，即在同一个块内移动。这反映了无法跨内存块执行算术运算的事实。
**块组织的优势**：

- **内存分配和释放的管理**：将内存组织成块有助于确保内存的正确释放。**释放操作**（free）只能一次性地释放整个块（规则 O-free），防止部分释放导致的问题。
#### **3. 数据竞争（Data Races）**

**目标**：

- 我们希望内存模型能够检测并排除数据竞争。
**参考标准**：

- 我们遵循了 **C++11** 的内存模型，其中区分了原子和非原子内存访问。
**内存访问类型**：

- **非原子访问（non-atomic access）**：数据竞争被视为未定义行为（undefined behavior）。
- **原子访问（atomic access）**：可以是有数据竞争的，但程序员需要显式地使用同步原语。
**简化**：

- 为了简化，我们只提供 **顺序一致性（Sequentially Consistent，SC）** 的原子操作。
- 避免了讨论 C++11 中的 **松弛原子操作（relaxed atomics）**。
**数据竞争的定义**：

- 如果程序中存在两个并发访问同一位置的操作，且至少有一个是写操作，并且至少有一个是非原子访问，则认为程序存在数据竞争。
**证明数据竞争的消除**：

- **操作语义的设计**：我们精心设计了操作语义，使得具有数据竞争的程序在至少一个执行中会进入 **卡住状态（stuck state）**。
- **定理 3（数据竞争自由）**：**陈述**：给定初始内存 h 下的程序 e，如果程序和内存的组合是安全的（即，没有线程会进入卡住状态），那么该程序是数据竞争自由的。**意义**：这意味着我们可以像处理其他安全性问题（如使用已释放的内存）一样处理数据竞争。**方法**：通过为所考虑的代码证明 **Hoare 三元组**。
**实现细节**：

- **锁状态（LockSt）**：每个内存位置都配备了一个额外的状态 π ∈ LockSt，类似于读者-写者锁（reader-writer lock）。**状态解释**：reading 0（“有 0 个读者”）：对应于锁未被占用的情况。**非原子访问的处理**：非原子访问分为两个独立的步骤。**第一步**：获取锁（读操作获取读锁，规则 O-deref-na；写操作获取写锁，规则 O-assign-na）。在执行的表达式中，将访问顺序参数 na 替换为 na'，表示已获取锁，下一步将完成内存访问。**第二步**：执行实际的内存访问，并释放锁（规则 O-deref-na' 和 O-assign-na'）。
- **关键点**：这些步骤 **分别** 可能受到干扰（interference），即其他线程可能在它们之间插入执行。如果第一步无法进行（因为锁已被其他线程持有），程序会进入 **卡住状态**。
- **原子访问的处理**：顺序一致性的原子访问在 **单个执行步骤** 中完成，不修改锁状态。但它们仍然检查锁，以确保没有冲突的非原子访问正在进行（规则 O-deref-sc，O-assign-sc）。如果存在冲突访问，程序同样会进入卡住状态。
**数据竞争示例**：

- **情景描述**：假设一个线程执行非原子读，而另一个线程对同一位置执行原子写。存在一种线程交织（interleaving），其中第一个线程开始执行 O-deref-na，将位置的锁状态更改为 reading 1。然后该线程被调度器暂停，第二个线程开始执行原子写。
- **问题发生**：第二个线程尝试执行规则 O-assign-sc，但发现锁状态不是 reading 0，无法进行。由于无法满足规则前提，程序进入 **卡住状态**。
- **类似情况**：其他形式的数据竞争（如非原子读与非原子写、原子读与非原子写、非原子写与原子写、非原子写与非原子写）都会导致类似的问题。
**特殊情况：CAS 操作**：

- **CAS（Compare-And-Swap）操作**：CAS(ℓ, v1, v2)：原子地比较位置 ℓ 处的当前值与 v1，如果相等，则将 v2 存储到 ℓ。这意味着，根据比较结果，可能发生读或写操作，这会影响与锁的交互（规则 O-cas-fail 和 O-cas-suc）。
- **非确定性比较**：由于我们的相等性测试是非确定性的，两个值有时可以同时被认为相等和不相等。
- **复杂情况**：假设 CAS 执行了非确定性的比较，且位置 ℓ 当前被读锁定。**比较失败的情况**：CAS 只尝试获取读锁，这是可以的。**比较成功的情况**：CAS 需要获取写锁，但由于位置已被读锁定，获取失败。这样的程序存在数据竞争（因为 CAS 可能写入），但程序不会卡住，因为它可以通过 O-cas-fail 规则继续执行。
- **解决方案**：为了确保定理 3 的成立，我们必须确保程序仍然可以进入卡住状态。这通过规则 O-cas-stuck 实现，它正好适用于比较可能成功，但锁已被读锁定的情况。在这种情况下，我们将程序简化为 0()；任何卡住的项都可以。
#### **4. 未初始化内存（Uninitialized Memory）**

**处理方式**：

- 我们遵循了论文 “Taming undefined behavior in LLVM” 的方法。
- **基本思想**：在分配内存时，内存包含一个 **毒值（poison value）** h。如果程序尝试使用这个值进行计算或条件分支，程序将进入 **卡住状态**。
**安全操作**：

- 对于毒值 h，唯一安全的操作是从内存中加载和存储。
- 这确保了在安全（不会卡住）的程序中，未初始化的内存不会影响程序的执行。
#### **5. 从 λRust 到核心语言的翻译**

**基本原则**：

- 一些 λRust 的构造（如基本的算术操作）是核心语言的一部分，不需要翻译。
- 其余的被视为 **语法糖**，按照图 9.4 中的定义进行处理。
**具体实现**：

- **变量绑定和序列化**：我们按照惯例，将 let 绑定的变量和序列化（sequencing）定义为立即应用的函数。
- **定义 skip 操作**：skip 被定义为一个执行一步操作的操作，然后简化为无用的值 h。**技术原因**：endlft 的证明仅在程序执行了一些计算步骤时才有效。
- **布尔值和条件分支**：我们基于整数和 case 来定义布尔值和条件分支，这是直接的方法。注意，规则 O-le-true 等都是专门为这种整数作为布尔值的解释而编写的。
- **Continuations 和函数的区别**：**Continuations**：在 λRust-core 中，continuations 只是普通函数的语法糖。因此，“跳转”到一个 continuation 就是一个函数调用。**函数**：λRust 的函数被建模为核心语言中的函数，其第一个参数用作返回 continuation。调用一个具有给定返回 continuation 的函数，相当于将该 continuation 作为第一个参数传递给函数。
- **内存操作的实现**：**分配和释放**：直接使用底层核心语言的原语（alloc 和 free），但这些原语不允许空的分配（规则 O-alloc，O-free）。因此，我们需要对大小为 0 的情况进行特殊处理：在这种情况下，new 返回一个“**虚拟**”位置 (42, 1337) ∈ Loc。任何位置都可以，这个地址实际上永远不会被访问。我们只需要一个在语法上是位置的值，以后这将有助于简化我们的类型系统证明。**内存访问**：λRust 的内存访问被建模为非原子访问。为了实现 e1 :=n *e2，即将 e2 指向的内存范围复制到 e1，我们使用了一个由简单循环实现的 memcpy 函数。**和类型的初始化**：初始化和类型的操作将给定的索引写入内存的偏移量 0，然后将剩余的数据放在偏移量 1。
**全面总结：**

本文详细探讨了 λRust 的操作语义，特别是如何将 λRust 转换为核心语言 λRust-core，以便更深入地理解和推理程序的行为。通过将 λRust 的构造映射到核心语言，我们可以利用 lambda 演算的强大理论基础，统一处理 continuations 和函数，简化了推理过程。

在指针相等性的处理上，我们采用了非确定性的比较结果，避免了程序通过指针比较来推断内存分配的细节。这种设计确保了编译器在实现语言语义时有最大的自由度，同时保持了程序的安全性。

内存模型的设计受到了 CompCert 的启发，通过将内存组织成块，方便了内存的分配和释放管理。对于数据竞争，我们精心设计了操作语义，使得具有数据竞争的程序在至少一个执行中会进入卡住状态。这使得我们能够像处理其他安全性问题一样，通过证明 Hoare 三元组来确保程序的安全性和数据竞争自由。

在处理未初始化内存时，我们使用了毒值的概念，确保未初始化的内存不会影响安全程序的执行。这与 LLVM 中对未定义行为的处理方法一致。

最后，我们详细解释了 λRust 的一些构造如何被翻译为核心语言，包括变量绑定、序列化、内存操作和和类型的初始化等。这种翻译过程不仅使得语言的形式化更为严谨，也为类型系统的证明提供了坚实的基础。

总的来说，通过将 λRust 转换为 λRust-core，我们能够更深入地理解 Rust 的语义特性，特别是关于并发、安全性和内存管理方面的特性。这为 Rust 的形式化验证和编译器实现提供了重要的理论支持。
 #  
 Thought for 1m 7s
**概览：**

本段内容介绍了 **λRust** 的类型系统，这是对 Rust 编程语言进行形式化建模的核心部分。重点强调了 **所有权（ownership）**、**借用（borrowing）** 和 **生命周期（lifetimes）** 在类型系统中的关键作用。通过定义各种类型和上下文，λRust 精确地捕捉了 Rust 类型系统的本质，包括所有权类型、引用类型、函数类型和递归类型等。此外，详细解释了类型判断中涉及的五种不同的上下文，以及它们在类型检查过程中的作用。

**详细解读：**

### **1. 引言**

在之前的章节中，我们了解到 Rust 类型系统的核心原则是 **类型表示所有权**。这意味着类型系统需要跟踪哪些数据被谁拥有，以及如何安全地共享或借用这些数据。在所有权类型系统中，类型上下文具有 **亚结构性（substructural）**，即上下文不支持通常的结构性规则，如假设的复制。这种亚结构性反映了所有权的独占性：一个资源只能被一个所有者拥有。

然而，Rust 类型系统不仅仅是所有权。在函数调用中，为了避免在所有权和数据之间传递所有权，Rust 引入了 **引用** 和 **借用** 的概念。这允许函数临时访问数据结构，而不需要转移所有权。**生命周期** 则用于描述这种临时访问的持续时间。

### **2. λRust 的类型和上下文**

为了形式化地表示这些概念，λRust 定义了以下类型和上下文：

#### **2.1 类型（Types）**

- **基本类型符号：**`Lft`（生命周期）：`κ ::= α | static`α：生命周期变量。static：特殊的生命周期，表示程序的整个执行期间。`Mod`（修饰符）：`μ ::= mut | shr`mut：可变引用。shr：共享引用。`Sort`（种类）：`σ ::= val | lft | type`用于类型系统中不同种类的符号分类。
- **类型定义：****所有权指针类型**：`ownⁿ τ`表示对堆分配的内存块的完全所有权。τ：指向的值的类型。n：整个分配的大小（以内存单元计）。在 λRust 中，堆分配也用于模拟栈上的局部变量，因此所有权指针也代表了 Rust 中的局部变量。**引用类型**：`&⁽κ⁾₍μ₎ τ`&：引用符号。κ：生命周期，表示引用有效的时间范围。μ：修饰符，mut 表示可变引用，shr 表示共享引用。τ：引用所指向的数据的类型。引用是借用而来的，因此只能在其生命周期 κ 存在期间使用。**未初始化内存类型**：`n`表示长度为 n 的基本值序列。用于表示未初始化的内存块。例如，当分配一个所有权指针时，其初始类型为 own n，表示持有未初始化的内存。**乘积类型和和类型**：**乘积类型（Product Type）**：Πτ，表示一个 n 元组（n-ary product）。特殊情况下，空乘积 Π[] 表示 **单元类型（unit type）**，即 ()。**和类型（Sum Type）**：Στ，表示一个 n 元和类型（n-ary sum）。特殊情况下，空和 Σ[] 表示 **空类型（empty type）**，即 !。二元乘积和和类型的简写：τ₁ × τ₂：表示 Π[τ₁, τ₂]。τ₁ + τ₂：表示 Σ[τ₁, τ₂]。**函数类型**：`∀α. fn(ϝ : E; τ) → τ'`∀α：对生命周期变量 α 的全称量化，表示函数可以泛化地适用于任何生命周期。ϝ：函数自身的生命周期，用作绑定变量。E：外部生命周期上下文，包含生命周期之间的包含关系。τ：函数参数的类型。τ'：函数返回值的类型。这个函数类型表示一个可能多态于生命周期的函数，允许指定生命周期之间的包含关系。**递归类型**：`μT. τ`μT：类型变量 T 的递归定义。τ：类型表达式，其中 T 可以在某些位置出现。**限制**：为了确保类型的良构性，T 只能出现在指针类型或函数类型的内部。这与 Rust 对递归类型的限制一致，避免了无法确定大小的类型。
#### **2.2 上下文（Contexts）**

λRust 的类型判断涉及五种不同的上下文：

1. **变量上下文（Γ）**
- 唯一的绑定上下文。
- 引入类型判断中自由出现的所有变量。
- 跟踪变量的类型，包括：程序变量（x : val）：包括函数和 continuations。生命周期变量（α : lft）。类型变量（T : type）：仅在递归类型的定义中出现。
2. **外部生命周期上下文（E）**
- 包含生命周期之间的包含信息，形式为 κ ve κ'。
- 描述当前函数无法控制的生命周期（即函数多态于的生命周期）之间的关系。
3. **本地生命周期上下文（L）**
- 包含形式为 κ vl κ 的条目。
- 跟踪当前函数可以完全控制的生命周期，即左侧的生命周期 κ 可以随时结束。
- 右侧的生命周期列表表示所有比 κ 更长的生命周期；结束其中任何一个都会隐式结束 κ。
4. **Continuation 上下文（K）**
- 用于类型化 continuations。
- 条目形式为 k C cont(L; x. T)，表示 continuation k 可以在满足类型信息 T 和生命周期信息 L 的情况下，使用参数 x 调用。
- 在类型检查函数时，通常至少包含返回 continuation。
5. **类型上下文（T）**
- 描述了局部变量的所有权信息。
- 主要包含类型分配 p C τ，其中 p 是路径，τ 是类型。
- **亚结构性**：类型上下文是亚结构性的，即类型分配只能在类型满足 Γ ⊢ τ copy 时被复制。这对应于 Rust 中的 Copy trait。
- 在指令的类型判断中，实际上涉及两个类型上下文：执行指令前的类型上下文 T1。执行指令后的类型上下文 T2。这用于表示指令可能会“耗尽”变量或改变它们的类型。
#### **2.3 路径（Paths）**

- 在类型上下文中，类型分配是对路径 p 而不是变量 x 进行的。
- **概念上**，路径表示复合数据结构的单个字段或部分。
- 在 Rust 中，对结构体的所有权和借用跟踪是针对每个字段分别进行的。
- 因此，为了准确模拟这种行为，λRust 的类型上下文也使用路径来分别跟踪字段。
- 规则如 C-split-own 可以在整体数据结构和其各个字段之间进行转换。
### **3. 类型系统的关键规则**

由于完整的类型规则数量庞大，作者选择在本节仅展示了一些重要的辅助判断规则和部分指令及函数体的类型规则（详见图 9.5 和图 9.6）。其余的规则被移至后续章节，以简化本节的解释。

#### **3.1 类型 τ 的解释**

- **所有权指针（ownⁿ τ）**：表示对堆分配的某部分的完全所有权。n 表示整个分配的大小，可能与 τ 的大小不同。例如，内部指针可能指向更大数据结构中的一部分。在大多数情况下，n 等于 τ 的大小，此时可以省略下标。
- **引用（&⁽κ⁾₍μ₎ τ）**：具有修饰符 μ，可以是 mut（可变引用）或 shr（共享引用）。具有生命周期 κ，表示引用的有效期。引用是借用而来的，只能在生命周期 κ 存在期间使用。生命周期在 newlft 和 endlft 指令中开始和结束，对应于类型规则 F-newlft 和 F-endlft。特殊生命周期 static 表示整个程序执行期间有效。
- **未初始化内存（n）**：表示长度为 n 的基本值序列。代表未初始化的内存。例如，在使用规则 S-new 分配所有权指针时，其初始类型为 own n。所有权指针允许 **强更新（strong updates）**，即它们的类型可以在指向的内存被（重新）初始化时更改。当数据从所有权指针中移出时，其类型也会变回 own n（规则 Tread-own-move）。
- **乘积类型和和类型（Πτ 和 Στ）**：**乘积类型**：表示多个类型的元组。例如，二元乘积 τ₁ × τ₂ 表示类型 Π[τ₁, τ₂]。**和类型**：表示多个类型的选择。例如，二元和 τ₁ + τ₂ 表示类型 Σ[τ₁, τ₂]。**特殊类型**：**单元类型**：()，对应于空乘积 Π[]。**空类型**：!，对应于空和 Σ[]。
- **函数类型（∀α. fn(ϝ : E; τ) → τ'）**：允许对生命周期变量 α 进行多态化。外部生命周期上下文 E 可用于要求一个生命周期参数包含在另一个生命周期中。ϝ 是函数的生命周期绑定变量，可以在 E 中引用。例如，Rust 类型 for<'a> fn(&'a mut i32) 转换为 ∀α. fn(ϝ : ϝ ve α; &⁽α⁾₍mut₎ int) → ()。表示一个函数，接受一个具有任何包含当前函数调用的生命周期的可变引用，返回 ()。在 Rust 中，这种生命周期包含关系是隐式的，但在 λRust 的模型中，我们选择将这些假设显式化。
- **递归类型（μT. τ）**：支持递归类型，但有一些限制。**限制条件**：类型变量 T 只能出现在指针类型（如 own T）或函数类型的内部。这与 Rust 对递归类型的限制一致，防止出现无法确定大小的类型。例如，类型 μT. int × T 在 Rust 中是非法的，因为它没有明确的大小。用户需要显式地引入指针间接层，例如 μT. int × own T，这样类型的大小是已知的。
#### **3.2 上下文的作用**

- **变量上下文（Γ）**：引入所有在类型判断中使用的变量。包含程序变量、生命周期变量和类型变量。其他上下文基于此上下文中的变量声明事实和所有权信息，但不引入新的绑定。
- **外部生命周期上下文（E）**：包含关于当前函数无法控制的生命周期之间的包含关系。这些生命周期是函数多态于的生命周期。
- **本地生命周期上下文（L）**：跟踪当前函数可以控制的生命周期。左侧的生命周期可以随时结束，右侧的生命周期列表表示所有比左侧生命周期更长的生命周期。当结束左侧的生命周期时，右侧的生命周期也会被隐式地结束。
- **Continuation 上下文（K）**：用于类型化 continuations。条目 k C cont(L; x. T) 表示 continuation k 可以在满足类型上下文 T 和生命周期上下文 L 的情况下，以参数 x 调用。在类型检查函数时，通常至少包含返回 continuation。由于使用了 CPS（Continuation-Passing Style），函数的返回类型由返回 continuation 给出，因此函数的类型判断本身不包含返回类型的概念。
- **类型上下文（T）**：负责描述局部变量的所有权。在 continuation 的类型中，它表示 continuation 所需的所有权。主要包含类型分配 p C τ，其中 p 是路径，τ 是类型。**亚结构性**：类型上下文是亚结构性的，类型分配只能在类型满足 Γ ⊢ τ copy 时被复制。这对应于 Rust 中的 Copy trait。对于非 Copy 类型（如所有权指针和可变引用），不能随意复制类型分配。在指令的类型判断中，涉及两个类型上下文，分别表示执行指令前后的类型信息。这用于表示指令可能会消耗变量或改变它们的类型。
### **4. 类型系统的特点**

- **亚结构性类型系统**：类型上下文不支持假设的复制，反映了所有权的独占性。只有当类型满足 Γ ⊢ τ copy 时，类型分配才能被复制。这与 Rust 中的 Copy trait 相对应。
- **使用路径进行类型分配**：类型上下文中的类型分配是针对路径 p 的，而不是直接针对变量 x。路径表示复合数据结构中的某个字段，允许对结构体的字段进行独立的所有权和借用跟踪。这准确地模拟了 Rust 中对结构体字段的所有权和借用行为。
**全面总结：**

本段内容深入探讨了 λRust 的类型系统，重点解释了如何在类型系统中形式化地表示 Rust 中的所有权、借用和生命周期等核心概念。通过定义各种类型，如所有权指针类型、引用类型、未初始化内存类型、乘积类型、和类型、函数类型和递归类型，λRust 能够精确地捕捉 Rust 类型系统的特性。

λRust 的类型系统使用了五种不同的上下文来管理类型判断过程：

1. **变量上下文（Γ）**：引入所有在类型判断中使用的变量，包括程序变量、生命周期变量和类型变量。
2. **外部生命周期上下文（E）**：描述当前函数无法控制的生命周期之间的包含关系，支持函数的生命周期多态性。
3. **本地生命周期上下文（L）**：跟踪当前函数可以控制的生命周期，管理生命周期的开始和结束。
4. **Continuation 上下文（K）**：用于类型化 continuations，描述 continuations 可以被调用的条件。
5. **类型上下文（T）**：描述局部变量的所有权信息，跟踪类型分配，支持类型的亚结构性。
类型上下文中的类型分配是针对路径的，这允许对复合数据结构的字段进行独立的所有权和借用跟踪。这与 Rust 中的行为一致，确保了类型系统能够准确地反映程序的所有权和借用关系。

通过详细解释这些类型和上下文，以及它们在类型系统中的作用，本段内容为理解 λRust 的类型系统奠定了坚实的基础。这对于深入研究 Rust 的类型系统，以及形式化验证 Rust 程序的安全性和正确性，都具有重要意义。
 #  
 Thought for 14 seconds
**概览：**

本段内容通过一个具体的示例 `option_as_mut`，详细演示了 **λRust** 类型系统的上下文和类型规则是如何使用的。作者从 **§9.1** 的示例开始，逐步推导出 `option_as_mut` 函数的类型检查过程。这个示例展示了如何应用类型规则，如 **S-fn**、**F-let**、**S-new**、**F-letcont**、**F-case-bor** 等，以及如何在类型检查过程中更新和管理各种上下文，包括变量上下文（Γ）、外部生命周期上下文（E）、本地生命周期上下文（L）、continuation 上下文（K）和类型上下文（T）。此外，还详细解释了生命周期的检查、所有权的转移和类型上下文的更新。

**详细解读：**

### **9.3.1 对 option_as_mut 的类型检查**

#### **1. 引言**

本节旨在通过具体的代码示例，演示 **λRust** 类型系统的上下文和类型规则是如何在实践中使用的。我们将详细推导 **§9.1** 中的示例 `option_as_mut` 的类型检查过程。

**目标：**

我们希望证明以下类型判断：
\emptyset \; | \; \emptyset ; \emptyset \; | \; \emptyset ; \emptyset \vdash \text{option\_as\_mut} \; \text{a} \; f.\; f \; \mathbf{C} \; \forall \alpha. \text{fn}(\varphi : \varphi \; \text{ve} \; \alpha; \; &^\alpha_{\text{mut}}(() + \text{int})) \rightarrow (() + &^\alpha_{\text{mut}} \text{int})
**解释：**

- **符号说明：**∅：表示空的上下文或集合。Γ、E、L、K、T：分别表示变量上下文、外部生命周期上下文、本地生命周期上下文、continuation 上下文和类型上下文。a：表示类型检查的目标，即 option_as_mut。f：表示函数名称。C：类型分配符号，用于在上下文中分配类型。
- **目标类型**：我们希望证明，在没有任何假设的情况下，函数 `option_as_mut` 具有以下类型（等价于 Rust 中的类型）：\text{for<’a> fn(&’a mut Option<i32>) -> Option<&’a mut i32>}在 λRust 的表示中，该类型被写为：\forall \alpha. \text{fn}(\varphi : \varphi \; \text{ve} \; \alpha; \; &^\alpha_{\text{mut}}(() + \text{int})) \rightarrow (() + &^\alpha_{\text{mut}} \text{int})∀α：对生命周期变量 α 进行全称量化。fn(ϝ : ϝ ve α; &^α_{mut}(() + int)) → (() + &^α_{mut} int)：表示一个函数，接受类型为 &'α mut (() + int) 的参数，返回类型为 (() + &'α mut int)。
#### **2. 类型检查过程概述**

- **应用类型规则 S-fn**：为了推导所需的判断，我们首先应用 **S-fn** 规则，即用于给函数类型的值进行类型检查的规则。该规则虽然看起来冗长，但其主要作用是设置各种上下文。
- **设置初始上下文**：**变量上下文（Γ₁）**：
$$
Γ₁ := x : \text{val}, \; \text{ret} : \text{val}, \; \alpha : \text{lft}, \; ϝ : \text{lft}
$$
x : val：表示函数参数 x 是一个值变量。ret : val：表示返回 continuation ret 是一个值变量。α : lft：生命周期变量 α。ϝ : lft：函数的生命周期。**外部生命周期上下文（E₁）**：
$$
E₁ := ϝ \; \text{ve} \; \alpha
$$
表示函数的生命周期 ϝ 包含于生命周期 α。**本地生命周期上下文（L₁）**：
$$
L₁ := ϝ \; \text{vl} \; []
$$
表示我们对函数生命周期 ϝ 的控制。ϝ vl []：ϝ 没有任何超生命周期，可以随时结束。**Continuation 上下文（K₁）**：K₁ := \text{ret} \; \mathbf{C} \; \text{cont}(ϝ \; \text{vl} \; []; \; r. \; r \; \mathbf{C} \; \text{own} \; (() + &^\alpha_{\text{mut}} \text{int}))ret C cont(L; x. T)：ret 是一个 continuation，具有本地生命周期上下文 L，参数为 r，类型上下文为 r C own (() + &^\alpha_{\text{mut}} int)。这表示 ret 期望一个参数 r，其类型为 own (() + &^\alpha_{\text{mut}} int)。**类型上下文（T₁）**：T₁ := x \; \mathbf{C} \; \text{own} \; &^\alpha_{\text{mut}} (() + \text{int})表示函数参数 x 的类型是 own &^\alpha_{\text{mut}} (() + int)，即对类型为 &'α mut (() + int) 的值的所有权指针。
- **解释上下文**：**外部生命周期上下文 E** 反映了函数类型中的假设，即函数的生命周期 ϝ 包含于 α。**本地生命周期上下文 L** 声明了我们对函数生命周期 ϝ 的控制。在原则上，我们可以随时结束 ϝ，但 **continuation 上下文 K** 表明返回 continuation ret 要求 ϝ 仍然存活。**类型上下文 T** 中，我们有一个变量 x，类型为 own &^\alpha_{\text{mut}} (() + int)，表示对 &'α mut Option<i32> 的所有权指针。
#### **3. 类型推导过程详解**

接下来，我们按照代码的执行顺序，逐步进行类型推导，使用对应的类型规则。

**代码和类型推导步骤：**

1. **分配内存 let r = new(2)**
- **应用规则**：**F-let**：用于类型化 let 绑定。**S-new**：用于类型化 new(n) 指令。
- **类型上下文更新**：T : x \; \mathbf{C} \; \text{own} \; &^\alpha_{\text{mut}} (() + \text{int}), \; r \; \mathbf{C} \; \text{own} \; 2添加了 r C own 2，表示 r 是一个长度为 2 的未初始化内存的所有权指针。
2. **声明 continuation letcont k() := ... in**
- **应用规则**：**F-letcont**：用于类型化 continuation 的声明。
- **Continuation 上下文更新**：K : \text{ret} \; \mathbf{C} \; \text{cont}(...), \; k \; \mathbf{C} \; \text{cont}(ϝ \; \text{vl} \; []; \; r \; \mathbf{C} \; \text{own} \; (() + &^\alpha_{\text{mut}} \text{int}), \; x \; \mathbf{C} \; \text{own} \; 1)k 是一个 continuation，具有本地生命周期上下文 ϝ vl []。参数为 r 和 x，类型上下文为 r C own (() + &^\alpha_{\text{mut}} int), x C own 1。
- **类型上下文说明**：在调用 continuation k 时，我们需要选择一个适当的类型上下文。在这里，我们选择 r C own (() + &^\alpha_{\text{mut}} int), x C own 1，表示在调用 k 时，r 已经初始化为我们的返回类型，x 已经被部分使用。
3. **解引用 let y = *x**
- **应用规则**：**F-let**：用于类型化 let 绑定。**S-deref**：用于类型化解引用指令 *p。**Tread-own-move**：用于处理所有权指针的解引用和移动。
- **类型更新过程**：解引用 x，将其类型从 own &^\alpha_{\text{mut}} (() + int) 转换为 own 1，表示 x 的内容已被移出。新的变量 y 类型为 &^\alpha_{\text{mut}} (() + int)。
- **类型上下文更新**：T : x \; \mathbf{C} \; \text{own} \; 1, \; r \; \mathbf{C} \; \text{own} \; 2, \; y \; \mathbf{C} \; &^\alpha_{\text{mut}} (() + \text{int})
4. **模式匹配 case *y of**
- **应用规则**：**F-case-bor**：用于类型化对引用的模式匹配。
- **生命周期检查**：我们需要证明生命周期 `α` 仍然存活，以便安全地解引用 `y`。**使用外部生命周期上下文 E**：E 包含 ϝ ve α，表示 ϝ 包含于 α。**应用规则 Lalive-incl**：目标是证明 E; L ⊢ α alive。由于 ϝ ve α 且 E; L ⊢ ϝ alive，因此可以推导出 E; L ⊢ α alive。**证明 ϝ 存活**：**本地生命周期上下文 L** 包含 `ϝ vl []`。**应用规则 Lalive-local**：ϝ vl [] 表示 ϝ 存活，且没有超生命周期需要考虑。
- **类型上下文在分支中的更新**：在匹配的分支中，根据标签的不同，y.1（存储在和类型中的数据）类型分别为 &^\alpha_{\text{mut}} () 或 &^\alpha_{\text{mut}} \text{int}。
5. **处理第二个分支（标签为 1）**
- **类型上下文**：T : x \; \mathbf{C} \; \text{own} \; 1, \; r \; \mathbf{C} \; \text{own} \; 2, \; y.1 \; \mathbf{C} \; &^\alpha_{\text{mut}} \text{int}
- **赋值 r \; \text{inj}_1 \; :== \; y.1****应用规则**：**F-let**：用于类型化指令。**S-sum-assgn**：用于类型化对和类型的赋值。**Twrite-own**：用于处理所有权指针的写入。**类型更新过程**：将 y.1 移动到 r 中，改变 r 的类型，从未初始化的 own 2 更新为 own (() + &^\alpha_{\text{mut}} \text{int})。y.1 被消耗，类型上下文中不再包含 y.1。**类型上下文更新**：T : x \; \mathbf{C} \; \text{own} \; 1, \; r \; \mathbf{C} \; \text{own} \; (() + &^\alpha_{\text{mut}} \text{int})
6. **跳转到 continuation k**
- **应用规则**：**F-jump**：用于类型化对 continuation 的调用。
- **类型检查**：验证当前的类型上下文 T 和本地生命周期上下文 L 与 continuation k 所期望的匹配。在调用 k 时，类型上下文为 r C own (() + &^\alpha_{\text{mut}} int), x C own 1，这与之前在 continuation 上下文中为 k 设置的类型一致。
#### **4. 生命周期的检查**

- **证明生命周期 α 和 ϝ 仍然存活**：**第一步**：使用外部生命周期上下文 E 中的 ϝ ve α，应用 **Lalive-incl** 规则，将目标 E; L ⊢ α alive 转换为证明 E; L ⊢ ϝ alive。**第二步**：使用本地生命周期上下文 L 中的 ϝ vl []，应用 **Lalive-local** 规则，证明 ϝ 存活。因为 ϝ 没有超生命周期，所以直接得出 ϝ 存活。**结论**：因此，生命周期 α 也存活，可以安全地使用引用类型 &^\alpha_{\text{mut}} τ。
#### **5. 类型上下文的更新和所有权的转移**

- **所有权的转移和消耗**：在解引用 x 时，我们将其内容移出，类型从 own &^\alpha_{\text{mut}} (() + int) 变为 own 1，表示其内容已被移出。在赋值 r \; \text{inj}_1 \; :== \; y.1 时，y.1 被移动到 r，y.1 从类型上下文中消失，表示所有权已被消耗。
- **类型的强更新**：**强更新**：由于所有权指针的独占性，我们可以对其进行强更新，即改变其类型。在将 r 的类型从 own 2 更新为 own (() + &^\alpha_{\text{mut}} int) 时，应用了 **Twrite-own** 规则，实现了类型的强更新。
#### **6. Continuation 的类型检查**

- **Continuation k 的类型检查**：在调用 k 时，应用 **F-jump** 规则，验证当前的类型上下文和本地生命周期上下文与 k 所期望的匹配。
- **Continuation 上下文中的类型信息**：在声明 `k` 时，我们设置了其类型为：k \; \mathbf{C} \; \text{cont}(ϝ \; \text{vl} \; []; \; r \; \mathbf{C} \; \text{own} \; (() + &^\alpha_{\text{mut}} \text{int}), \; x \; \mathbf{C} \; \text{own} \; 1)因此，在调用 `k` 时，需要确保类型上下文匹配。
**全面总结：**

本段内容通过对 `option_as_mut` 函数的类型检查过程，详细展示了 **λRust** 类型系统的工作方式。我们从目标类型判断开始，逐步应用类型规则，设置初始上下文，并在类型推导过程中更新和管理各种上下文。

主要的关键点包括：

1. **上下文的设置和解释**：
- **变量上下文（Γ）**：引入了函数参数 x、返回 continuation ret、生命周期变量 α 和函数生命周期 ϝ。
- **外部生命周期上下文（E）**：包含了生命周期包含关系 ϝ ve α，表示函数的生命周期包含于 α。
- **本地生命周期上下文（L）**：声明了对函数生命周期 ϝ 的控制，允许我们在需要时结束 ϝ。
- **Continuation 上下文（K）**：包含了返回 continuation ret 的类型信息，指定了其参数和预期的类型上下文。
- **类型上下文（T）**：初始包含函数参数 x 的类型，表示对 &'α mut Option<i32> 的所有权指针。
2. **类型规则的应用**：
- **S-fn**：用于函数类型的值的类型检查，设置了上下文。
- **F-let**、**S-new**：用于类型化内存分配和 let 绑定。
- **F-letcont**：用于类型化 continuation 的声明，更新了 continuation 上下文。
- **S-deref**、**Tread-own-move**：用于处理所有权指针的解引用和移动，更新了类型上下文。
- **F-case-bor**：用于类型化对引用的模式匹配，包括生命周期的检查。
- **S-sum-assgn**、**Twrite-own**：用于处理对和类型的赋值和所有权指针的强更新。
- **F-jump**：用于类型化对 continuation 的调用，验证上下文匹配。
3. **生命周期的管理和检查**：
- 在类型检查过程中，我们需要确保引用类型所涉及的生命周期仍然存活。
- 通过外部生命周期上下文和本地生命周期上下文，应用生命周期包含和存活的规则，证明生命周期 α 和 ϝ 仍然有效。
4. **类型上下文的更新和所有权的转移**：
- 在解引用和赋值操作中，类型上下文发生了变化，反映了所有权的转移和变量的消耗。
- 所有权指针的独占性允许我们对其进行强更新，改变其类型。
5. **Continuation 的类型化**：
- 声明和调用 continuation 时，需要确保类型上下文和本地生命周期上下文与 continuation 上下文中的预期匹配。
- 这确保了程序在类型和生命周期方面的一致性和安全性。
通过这个详细的类型检查示例，我们深入理解了 **λRust** 类型系统中的各种上下文、类型规则和生命周期管理是如何协同工作的。这有助于我们更好地理解 Rust 编程语言的类型系统，以及它在形式化验证中的应用。该示例展示了类型系统如何精确地跟踪所有权、借用和生命周期，确保程序的安全性和正确性。
 #  
 Thought for 2m 17s
**概览：**

这段内容通过一个具体的示例 `bor_demo`，详细演示了 **λRust** 类型系统如何处理 **借用（borrowing）** 和 **生命周期的结束（ending a lifetime）**。首先，作者展示了一个简单的 Rust 函数 `bor_demo`，然后将其翻译为 λRust 代码。接着，他们逐步进行类型检查，解释了每一步中涉及的类型上下文的更新和类型规则的应用。最后，他们讨论了 λRust 类型系统的一些进一步特性，包括外部生命周期上下文的满足、子类型、多态性和类型上下文级别的类型提升等。

**详细解读：**

### **9.3.2 借用的类型检查**

#### **1. 引言**

本节通过一个简单的函数 `bor_demo`，演示了 **λRust** 类型系统是如何处理 **借用** 和 **生命周期的结束** 的。这有助于理解在 λRust 中，借用是如何影响类型上下文的，以及生命周期如何控制对数据的访问。

#### **2. Rust 函数和 λRust 翻译**

**Rust 代码：**

```rust
fn bor_demo() -> i32 {
    let mut x = 0;
    let p = &mut x;
    *p = 42;
    x
}
```

**解释：**

- **定义函数**：bor_demo，返回类型为 i32。
- **创建变量**：let mut x = 0;，声明一个可变的局部变量 x，初始值为 0。
- **创建引用**：let p = &mut x;，创建一个可变引用 p，指向 x。
- **通过引用修改值**：*p = 42;，通过引用 p 修改 x 的值为 42。
- **返回值**：x，返回变量 x 的值。
**λRust 翻译：**

```plaintext
funrec bor_demo() ret ret :=
    let x = new(1) in
    let v = 0 in x := v;
    newlft;
    let p = x in
    let v = 42 in p := v;
    endlft;
    jump ret(r)
```

**解释：**

- **函数定义**：funrec bor_demo() ret ret :=，定义一个递归函数 bor_demo，没有参数，返回 continuation 为 ret。
- **分配内存**：let x = new(1) in，分配一个大小为 1 的新内存块，绑定到 x。
- **初始化变量**：let v = 0 in x := v;，将值 0 赋给 x，初始化变量。
- **开始新生命周期**：newlft;，开始一个新的生命周期。
- **借用变量**：let p = x in，将 x 赋给 p，模拟借用。
- **修改值**：let v = 42 in p := v;，通过 p 将值 42 写入到 x 中。
- **结束生命周期**：endlft;，结束之前开始的生命周期。
- **返回结果**：jump ret(r)，跳转到返回 continuation ret。
**注意：**

- 在 λRust 中，x 被表示为一个指向整数的指针，以模拟可变性。
- p 和 x 被表示为相同的方式，因为在这个例子中，p 没有被修改，也没有被取地址。
- 借用在 λRust 的类型系统中是可见的，但在操作语义上没有直接的对应物。
#### **3. 目标类型判断**

我们希望推导以下 λRust 的类型判断：

$$
\emptyset \; | \; \emptyset ; \emptyset \; | \; \emptyset ; \emptyset \vdash \text{bor\_demo} \; \text{a} \; f. \; f \; \mathbf{C} \; \text{fn}(ϝ : \emptyset; \emptyset) \rightarrow \text{int}
$$

**解释：**

- **上下文**：所有的上下文都是空的（∅），因为函数没有参数，也没有外部生命周期约束。
- **类型判断**：在空的上下文下，函数 bor_demo 被类型化为一个函数，类型为 fn(ϝ : ∅; ∅) → int。ϝ 是函数的生命周期，没有任何外部或本地生命周期约束。函数返回类型为 int。
#### **4. 初始上下文设置**

**应用类型规则 S-fn**

根据规则 **S-fn**，我们需要设置初始的上下文来进行函数体的类型推导：

- **变量上下文（Γ₁）**：
$$
Γ₁ := \text{ret} : \text{val}, \; ϝ : \text{lft}
$$
ret : val：返回 continuation ret 是一个值变量。ϝ : lft：函数的生命周期。
- **外部生命周期上下文（E₁）**：
$$
E₁ := \emptyset
$$
没有外部生命周期约束。
- **本地生命周期上下文（L₁）**：
$$
L₁ := ϝ \; \text{vl} \; []
$$
ϝ vl []：我们对函数生命周期 ϝ 有控制权，没有超生命周期。
- **Continuation 上下文（K₁）**：
$$
K₁ := \text{ret} \; \mathbf{C} \; \text{cont}(ϝ \; \text{vl} \; []; \; r. \; r \; \mathbf{C} \; \text{own} \; \text{int})
$$
ret C cont(L; r. r C own int)：返回 continuation ret 需要参数 r，类型为 own int，在生命周期 ϝ vl [] 内。
- **类型上下文（T₁）**：
$$
T₁ := \emptyset
$$
初始时没有类型分配。
#### **5. 类型检查过程**

我们将代码与类型上下文的更新过程展示在 **图 9.9** 中。由于此示例中没有定义 continuations，continuation 上下文 `K` 在整个推导过程中保持不变。

**步骤 1：分配内存 let x = new(1) in**

- **应用规则**：**F-let**：用于类型化 let 绑定。**S-new**：用于类型化 new(n) 指令。
- **类型上下文更新**：
$$
T : x \; \mathbf{C} \; \text{own} \; 1
$$
x 是一个未初始化的所有权指针，大小为 1。
**步骤 2：赋值 let v = 0 in x := v;**

- **给 0 命名为 v****应用规则**：**F-let**：用于类型化 let 绑定。**S-num**：用于类型化数值常量。**类型上下文更新**：
$$
T : x \; \mathbf{C} \; \text{own} \; 1, \; v \; \mathbf{C} \; \text{int}
$$
- **赋值 x := v;****应用规则**：**F-let**：用于类型化指令。**S-assgn**：用于类型化赋值指令。**Twrite-own**：用于处理所有权指针的写入。**类型更新过程**：我们有 own 1（未初始化的所有权指针），写入 int 后，类型更新为 own int。变量 v 被使用后，可以从类型上下文中移除（如果我们不再需要它）。**类型上下文更新**：
$$
T : x \; \mathbf{C} \; \text{own} \; \text{int}
$$
**步骤 3：开始新生命周期 newlft;**

- **应用规则**：**F-newlft**：用于类型化 newlft 指令。
- **选择超生命周期列表****超生命周期（superlifetimes）**：指那些将比新生命周期 α 存活更久的生命周期。在此例中，我们选择将函数的生命周期 ϝ 作为 α 的超生命周期。
- **本地生命周期上下文更新**：
$$
L : α \; \text{vl} \; [ϝ]
$$
表示新创建的生命周期 α 的超生命周期列表为 [ϝ]。
**步骤 4：借用 let p = x in**

- **问题分析**：如果直接使用 **S-path** 规则，会将 x 从类型上下文中移除，但我们之后还需要使用 x 作为返回值。
- **解决方案**：**借用 x**：我们需要借用 x，这在 λRust 中是一个“幽灵步骤”（ghost step），只影响类型上下文，没有直接的操作等价物。
- **应用规则**：**C-borrow**：用于类型化借用操作。
- **类型上下文更新**：**借用后**：T : x \; \mathbf{C} \; &^\alpha_{\text{mut}} \text{int}, \; x \; \mathbf{C}^{†α} \text{own} \; \text{int}x C &^\alpha_{\text{mut}} \text{int}：表示 x 现在被视为一个借用了生命周期 α 的可变引用。x C^{†α} \text{own} \; \text{int}：表示 x 的所有权类型被 α 阻塞，直到 α 生命周期结束后才能恢复。
- **绑定 p****应用规则**：**F-let**：用于类型化 let 绑定。**S-path**：用于类型化路径。**类型上下文更新**：T : p \; \mathbf{C} \; &^\alpha_{\text{mut}} \text{int}, \; x \; \mathbf{C}^{†α} \text{own} \; \text{int}
**步骤 5：赋值 let v = 42 in p := v;**

- **给 42 命名为 v****应用规则**：**F-let**：用于类型化 let 绑定。**S-num**：用于类型化数值常量。**类型上下文更新**：T : p \; \mathbf{C} \; &^\alpha_{\text{mut}} \text{int}, \; x \; \mathbf{C}^{†α} \text{own} \; \text{int}, \; v \; \mathbf{C} \; \text{int}
- **赋值 p := v;****应用规则**：**F-let**：用于类型化指令。**S-assgn**：用于类型化赋值指令。**Twrite-bor**：用于处理引用的写入。**类型更新过程**：我们在类型为 &^\alpha_{\text{mut}} \text{int} 的指针 p 上写入 int 值 v。根据 **Twrite-bor** 规则，写入后，p 的类型保持不变。**生命周期检查**：需要证明生命周期 α 仍然存活。
- **生命周期 α 的存活性证明****应用规则 Lalive-local**：α \; \text{vl} \; [ϝ]，所以需要证明其超生命周期 ϝ 仍然存活。**证明 ϝ 存活**：ϝ \; \text{vl} \; []，即 ϝ 没有超生命周期，直接得出 ϝ 存活。**结论**：因此，`α` 也存活，可以安全地使用引用 `&^\alpha_{\text{mut}} \text{int}`。
**步骤 6：结束生命周期 endlft;**

- **应用规则**：**F-endlft**：用于类型化 endlft 指令。
- **类型上下文更新**：**解除被阻塞的类型分配****应用类型上下文解除阻塞的判断** `T ⇒^{†κ} T'`。将所有被 `κ` 阻塞的类型分配 `C^{†κ}` 替换为正常的类型分配 `C`。**更新后的类型上下文**：
$$
T : x \; \mathbf{C} \; \text{own} \; \text{int}
$$
我们重新获得了 x 的完全所有权，就像借用到期后预期的那样。
- **处理 p**虽然可以保留对 `p` 的所有权，但由于无法证明 `α` 仍然存活，`p` 将变得无用。**应用规则 C-weaken**：简单地从类型上下文中移除 `p`。
**步骤 7：跳转到返回 continuation jump ret(x)**

- **应用规则**：**F-jump**：用于类型化对 continuation 的调用。
- **类型检查**：验证当前的类型上下文和本地生命周期上下文与 `ret` 所期望的匹配。`ret` 需要参数 `x`，类型为 `own int`。
#### **6. 总结类型检查过程**

- **借用过程**：借用通过 **C-borrow** 规则实现，将变量的类型分配拆分为一个借用的引用类型和一个被阻塞的所有权类型。
- **生命周期的管理**：开始新生命周期时，通过 **F-newlft** 规则，将新生命周期 `α` 添加到本地生命周期上下文，并指定其超生命周期。在使用引用时，需要证明引用的生命周期 `α` 仍然存活，通过 **Lalive-local** 规则完成。
- **结束生命周期**：通过 **F-endlft** 规则，结束生命周期 α，并解除所有被 α 阻塞的类型分配。
- **类型上下文的更新**：在借用过程中，`x` 的所有权被阻塞，借用结束后，所有权被恢复。不再需要的变量（如 `p`），可以通过 **C-weaken** 规则从类型上下文中移除。
### **9.3.3 类型系统的进一步特性**

在这一节中，作者建议读者回顾 **图 9.5** 和 **图 9.6** 中的所有类型规则，接下来讨论之前示例中未涉及的一些规则。

#### **1. 外部生命周期上下文的满足**

- **用途**：在函数调用时，检查被调用函数（callee）所做的假设。
- **规则**：**外部生命周期上下文满足判断**：`Γ | E; L ⊢ E₀`在规则 **F-call** 中使用。**原理**：使用 **生命周期包含判断**，检查 E₀ 中的每个包含关系是否可以从当前的 E 和 L 中推导出来。
#### **2. 子类型**

- **描述**：子类型关系表示为 Γ | E; L ⊢ τ₁ ⇒ τ₂。
- **主要形式**：**生命周期包含（T-bor-lft）**：处理引用类型中生命周期的包含关系。**递归类型的（非）展开（T-rec-unfold）**：处理递归类型的展开和折叠。
- **其他规则**：**结构性规则**：体现类型构造子的协变性和逆变性。**T-own** 是一个代表性的例子，表示所有权指针类型在类型参数上的协变性。
- **类型上下文级别的类型提升****规则**：`Γ | E; L ⊢ T₁ ⇒ T₂`**C-subtype**：在类型上下文中提升子类型关系（这是“**吸收（subsumption）**”规则）。**额外的类型转换（coercions）**：只能应用于顶层类型。**C-share**：可变引用可以被强制转换为共享引用。**C-borrow**：所有权指针可以被借用，创建一个可变引用。**C-reborrow**：可变引用可以被重新借用，具有不同的生命周期。
**全面总结：**

这段内容通过对 `bor_demo` 函数的类型检查，深入展示了 **λRust** 类型系统如何处理借用和生命周期的结束。在类型检查过程中，我们看到了类型上下文、变量上下文、生命周期上下文和 continuation 上下文的设置和更新，以及类型规则的应用。

主要的关键点包括：

1. **借用的处理**：
- 借用通过 **C-borrow** 规则实现，将变量的类型分配拆分为一个借用的引用和一个被阻塞的所有权类型。
- 借用是一个“幽灵步骤”，只影响类型上下文，没有直接的操作等价物。
2. **生命周期的管理**：
- 通过 **F-newlft** 和 **F-endlft** 规则，开始和结束生命周期。
- 生命周期的包含关系和存活性通过 **Lalive-local** 等规则进行证明。
3. **类型上下文的更新和所有权的恢复**：
- 在借用期间，所有权被阻塞，无法访问。
- 当生命周期结束时，被阻塞的所有权类型分配被解除，所有权得以恢复。
4. **类型规则的应用**：
- **S-new**、**S-num**、**S-assgn**、**Twrite-own**、**Twrite-bor** 等规则用于类型化各个指令。
- **F-let**、**F-jump** 等规则用于类型化函数体和跳转。
5. **类型系统的进一步特性**：
- 讨论了外部生命周期上下文的满足、子类型关系、类型上下文级别的类型提升等。
通过这个示例，我们深入理解了 λRust 类型系统中借用和生命周期的工作机制。这对于理解 Rust 编程语言中的借用检查器和生命周期管理，以及形式化地验证 Rust 程序的安全性和正确性，都具有重要意义。

- **借用的安全性**：类型系统确保了在借用期间，所有权被正确地管理，防止数据竞争和未定义行为。
- **生命周期的作用**：生命周期用于跟踪引用的有效期，确保在引用仍然被使用时，数据不会被释放或移动。
总的来说，这段内容详细展示了 λRust 类型系统如何精确地模拟 Rust 的所有权和借用机制，为形式化验证 Rust 程序提供了坚实的理论基础。
 #  
 Thought for 1m 27s
**概览：**

本段内容是对 **λRust** 类型系统的补充和深入解释。之前的章节（图 9.5 和图 9.6）仅给出了用于类型检查示例的必要类型规则，省略了一些琐碎的定义，如类型的良构性（well-formedness）和类型的大小（size）。在本节中，作者提供了所有剩余的定义，并对任何不寻常的部分进行了简要解释。

主要内容包括：

1. **类型的良构性判断**：定义了各种类型系统组件的绑定结构，特别关注了递归类型的良构性。
2. **类型的大小**：解释了如何计算类型占用的内存大小。
3. **Rust 特征对应的判断**：定义了对应于 Rust 中 `Copy`、`Send` 和 `Sync` 特征的简单判断。
4. **生命周期包含和上下文满足性**：补充了生命周期包含的传递性规则和外部生命周期上下文的满足性判断。
5. **子类型规则**：讨论了主要的子类型规则，包括结构性规则、递归类型的协变性、可变引用的协变性和不变性等。
6. **类型强制（Type Coercion）**：提供了类型强制规则，特别是对于引用的类型分解。
7. **指令的类型规则**：介绍了剩余的指令类型规则，特别是 `S-deref-bor-own` 和 `S-deref-bor-mut` 规则，解决了之前规则的局限性。
8. **函数体的类型规则**：讨论了 `F-equalize` 规则，以及它在处理生命周期时的作用。
**详细解读：**

### **1. 引言**

在之前的图 9.5 和图 9.6 中，作者仅给出了用于类型检查示例的必要类型规则，省略了一些琐碎的定义，如类型的良构性和类型的大小。在本节中，作者提供了所有剩余的定义，并对任何不寻常的部分进行了简要解释。

**目的：**

- 提供完整的类型系统定义，以便读者更深入地理解 λRust 的类型系统。
- 解释任何不寻常或需要特别注意的部分。
### **2. 类型的良构性判断**

类型的良构性判断主要关注定义各种类型系统组件的绑定结构。唯一需要注意的是递归类型的良构性，它要求递归出现必须位于指针或函数类型的下方。

在本节的其余部分，作者隐含地仅处理良构的对象。

#### **2.1 良构路径（Well-formed Paths）**

良构路径是指在上下文 `Γ` 中，一个路径 `p` 是良构的，记为 `Γ ⊢_{wf} p`。

**规则：**

1. **变量作为路径：**
- 如果 x : val ∈ Γ，则 Γ ⊢_{wf} x。
2. **路径的拓展：**
- 如果 `Γ ⊢_{wf} p`，则 `Γ ⊢_{wf} p.n`。
- 这表示从一个路径 `p` 拓展到 `p.n`，例如访问结构体的第 `n` 个字段。
#### **2.2 良构生命周期（Well-formed Lifetimes）**

良构生命周期表示在上下文 `Γ` 中，一个生命周期 `κ` 是良构的，记为 `Γ ⊢_{wf} κ`。

**规则：**

1. **生命周期变量：**
- 如果 α : lft ∈ Γ，则 Γ ⊢_{wf} α。
2. **特殊生命周期：**
- `Γ ⊢_{wf} static`。
- `static` 是一个特殊的生命周期，表示整个程序的执行期间。
#### **2.3 良构外部生命周期上下文（Well-formed External Lifetime Contexts）**

外部生命周期上下文 `E` 是良构的，记为 `Γ ⊢_{wf} E`。

**规则：**

1. **空上下文：**
- Γ ⊢_{wf} ∅。
2. **包含关系：**
- 如果 `Γ ⊢_{wf} L`，`Γ ⊢_{wf} κ`，`Γ ⊢_{wf} κ'`，则 `Γ ⊢_{wf} L, κ \; \text{ve} \; κ'`。
- `κ \; \text{ve} \; κ'` 表示生命周期 `κ` 包含于生命周期 `κ'`。
#### **2.4 良构本地生命周期上下文（Well-formed Local Lifetime Contexts）**

本地生命周期上下文 `L` 是良构的，记为 `Γ ⊢_{wf} L`。

**规则：**

1. **空上下文：**
- Γ ⊢_{wf} ∅。
2. **包含关系：**
- 如果 `Γ ⊢_{wf} L`，`Γ ⊢_{wf} κ`，并且对于所有 `κ' ∈ κ`，有 `Γ ⊢_{wf} κ'`，则 `Γ ⊢_{wf} L, κ \; \text{vl} \; κ`。
- `κ \; \text{vl} \; κ` 表示生命周期 `κ` 的超生命周期是 `κ`。
#### **2.5 良构类型（Well-formed Types）**

在上下文 `Γ` 中，类型 `τ` 是良构的，记为 `Γ ⊢_{wf} τ`。

**规则：**

1. **类型变量：**
- 如果 T : type ∈ Γ，则 Γ ⊢_{wf} T。
2. **基本类型：**
- Γ ⊢_{wf} \text{bool}，Γ ⊢_{wf} \text{int}，Γ ⊢_{wf} n（未初始化内存类型）。
3. **所有权指针类型：**
- 如果 Γ ⊢_{wf} τ，则 Γ ⊢_{wf} \text{own}^{n} τ。
4. **引用类型：**
- 如果 `Γ ⊢_{wf} κ`，`Γ ⊢_{wf} τ`，则 `Γ ⊢_{wf} &^{κ}_{μ} τ`。
- `μ` 是修饰符，可以是 `mut`（可变）或 `shr`（共享）。
5. **乘积类型和和类型：**
- 如果对于所有 i，有 Γ ⊢_{wf} τ_i，则 Γ ⊢_{wf} Πτ（乘积类型），Γ ⊢_{wf} Στ（和类型）。
6. **函数类型：**
- 如果 Γ, α, ϝ : lft ⊢_{wf} E，并且对于所有 i，Γ, α : lft ⊢_{wf} τ_i，Γ, α : lft ⊢_{wf} τ，则 Γ ⊢_{wf} ∀α. \text{fn}(ϝ : E; τ) → τ。
7. **递归类型：**
- 如果 Γ, T : type ⊢_{wf} τ，并且 T 仅在 τ 中出现在指针或函数类型的下方，则 Γ ⊢_{wf} μT. τ。
#### **2.6 良构类型上下文（Well-formed Type Contexts）**

类型上下文 `T` 是良构的，记为 `Γ ⊢_{wf} T`。

**规则：**

1. **空上下文：**
- Γ ⊢_{wf} ∅。
2. **类型分配：**
- 如果 Γ ⊢_{wf} T，Γ ⊢_{wf} p，Γ ⊢_{wf} τ，则 Γ ⊢_{wf} T, p \; \mathbf{C} \; τ。
3. **被阻塞的类型分配：**
- 如果 Γ ⊢_{wf} T，Γ ⊢_{wf} p，Γ ⊢_{wf} κ，Γ ⊢_{wf} τ，则 Γ ⊢_{wf} T, p \; \mathbf{C}^{†κ} \; τ。
### **3. 类型的大小**

正如之前提到的，所有类型都有一个大小，表示该类型的实例占用的内存位置数量。`size(τ)` 是一个计算给定类型 `τ` 的大小的函数。

**规则：**

- size(\text{bool}) := 1
- size(\text{int}) := 1
- size(\text{own}^{n} τ) := 1
- size(&^{κ}_{μ} τ) := 1
- size(n) := n（未初始化内存类型的大小就是 n）
- size(Πτ) := \sum_{i} size(τ_i)（乘积类型的大小是其所有组件大小之和）
- size(Στ) := 1 + \max_i size(τ_i)（和类型的大小是 1 加上其所有组件大小的最大值）这里的 1 表示用于存储标签的额外空间。
- size(μT. τ) := size(τ)
- size(∀α. \text{fn}(ϝ : E; τ) → τ) := 1（函数类型的大小为 1）
### **4. 对应于 Rust 特征的判断**

作者定义了一些简单的判断，对应于 Rust 中的 `Copy`、`Send` 和 `Sync` 特征。

#### **4.1 Copy 类型**

判断 `Γ ⊢ τ \; \text{copy}` 表示类型 `τ` 是 `Copy` 的，即可以被自由复制。

**规则：**

- 基本类型 \text{bool}、\text{int}、n（未初始化内存）都是 Copy 的。
- 共享引用 &^{κ}_{\text{shr}} τ 是 Copy 的。
- 乘积类型和和类型，如果其所有组件都是 Copy 的，则它们也是 Copy 的。
- 函数类型 ∀α. \text{fn}(ϝ : E; τ) → τ 是 Copy 的。
- 类型变量 T 是 Copy 的。
- 递归类型 μT. τ 是 Copy 的。
**注意：**

- 所有权指针（own^{n} τ）和可变引用（&^{κ}_{\text{mut}} τ）不是 Copy 的，因为它们的所有权或可变性要求它们不能被自由复制。
#### **4.2 Send 和 Sync 类型**

- **Send 类型**：判断 `Γ ⊢ τ \; \text{send}` 表示类型 `τ` 可以安全地发送到另一个线程。
- **Sync 类型**：判断 `Γ ⊢ τ \; \text{sync}` 表示类型 `τ` 可以安全地跨线程共享。
**规则：**

- 基本类型 `\text{bool}`、`\text{int}`、`n` 都是 `Send` 和 `Sync` 的。
- 所有权指针 `\text{own}^{n} τ` 是 `Send` 和 `Sync` 的。
- 共享引用 `&^{κ}_{\text{shr}} τ` 是 `Send` 和 `Sync` 的。
- 可变引用 `&^{κ}_{\text{mut}} τ`：如果 `τ` 是 `Sync` 的，则 `&^{κ}_{\text{mut}} τ` 是 `Send` 的。如果 `τ` 是 `Sync` 的，则 `&^{κ}_{\text{mut}} τ` 是 `Sync` 的。
- 乘积类型和和类型，如果其所有组件都是 `Send` 或 `Sync` 的，则它们也是 `Send` 或 `Sync` 的。
- 函数类型 `∀α. \text{fn}(ϝ : E; τ) → τ` 是 `Send` 和 `Sync` 的。
- 类型变量 `T` 和递归类型 `μT. τ` 也是 `Send` 和 `Sync` 的。
**注意：**

- 在目前的 λRust 语法类型系统中，所有类型都是 Send 和 Sync 的，但在后续章节（§13）中讨论的一些不安全实现的类型将不再是 Send 或 Sync 的。
### **5. 生命周期包含和上下文满足性**

由于篇幅原因，作者在图 9.5 中省略了生命周期包含的传递性规则和类型上下文解除阻塞空上下文的规则，现在将它们补充在此。

#### **5.1 生命周期包含的传递性**

**规则 Lincl-trans：**

如果 `Γ | E; L ⊢ κ \; \text{v} \; κ'`，并且 `Γ | E; L ⊢ κ' \; \text{v} \; κ''`，则 `Γ | E; L ⊢ κ \; \text{v} \; κ''`。

这表示生命周期包含关系是传递的。

#### **5.2 外部生命周期上下文满足性**

**定义：**

判断 `Γ | E_1; L_1 ⊢ E_2` 表示外部生命周期上下文 `E_2` 在上下文 `E_1` 和 `L_1` 下是可满足的。

**规则：**

1. **空上下文：**
- Γ | E_1; L_1 ⊢ ∅。
2. **包含关系：**
- 如果 Γ | E_1; L_1 ⊢ κ \; \text{v} \; κ'，并且 Γ | E_1; L_1 ⊢ E_2，则 Γ | E_1; L_1 ⊢ E_2, κ \; \text{ve} \; κ'。
### **6. 类型上下文解除阻塞**

**规则 Tunblock-empty：**

- 对于空的类型上下文，有 Γ | ∅ ⇒^{†κ} ∅。
这表示在解除阻塞过程中，空的类型上下文仍然是空的。

### **7. 子类型规则**

剩余的子类型规则主要是结构性的：

- **共享引用**、**乘积类型**和**和类型**是协变的，就像之前定义的所有权指针一样。
- **可变引用**是 **不变** 的。
- **函数类型**在返回类型上是协变的，在参数类型上是逆变的。
#### **7.1 递归类型的协变性**

递归类型是协变的，但其规则使用了元级别的蕴涵（meta-level implication），这通常不在语法类型系统中出现。该规则类似于我们在语义上证明的内容，但要在语法上正确表达，需要引入“子类型假设”的上下文。

**规则 T-rec：**

- 对于所有 `τ'_1` 和 `τ'_2`，如果 `(Γ | E; L ⊢ τ'_1 ⇒ τ'_2)`，则 `(Γ | E; L ⊢ τ_1[τ'_1 / T_1] ⇒ τ_2[τ'_2 / T_2])`。
- 因此，可以得出 `Γ | E; L ⊢ μT_1. τ_1 ⇒ μT_2. τ_2`。
#### **7.2 子类型规则的其他部分**

- **反身性（T-refl）**：`Γ | E; L ⊢ τ ⇒ τ`。
- **传递性（T-trans）**：如果 `Γ | E; L ⊢ τ ⇒ τ'`，并且 `Γ | E; L ⊢ τ' ⇒ τ''`，则 `Γ | E; L ⊢ τ ⇒ τ''`。
- **未初始化乘积类型的等价（T-uninit-prod）**：`Γ | E; L ⊢ Σ^n ⇔ Π^n`。表示大小为 `n` 的未初始化内存块等价于一个每个组件都是未初始化的乘积类型。
- **共享引用的协变性（T-bor-shr）**：如果 Γ | E; L ⊢ τ_1 ⇒ τ_2，则 Γ | E; L ⊢ &^{κ}_{\text{shr}} τ_1 ⇒ &^{κ}_{\text{shr}} τ_2。
- **可变引用的不变性（T-bor-mut）**：如果 Γ | E; L ⊢ τ_1 ⇔ τ_2（双向的等价），则 Γ | E; L ⊢ &^{κ}_{\text{mut}} τ_1 ⇔ &^{κ}_{\text{mut}} τ_2。
- **乘积类型的协变性（T-prod）**：如果对于所有 i，Γ | E; L ⊢ τ_i ⇒ τ'_i，则 Γ | E; L ⊢ Πτ ⇒ Πτ'。
- **和类型的协变性（T-sum）**：同样地，对于和类型。
- **函数类型的协变和逆变性（T-fn）**：函数类型在返回类型上是协变的，在参数类型上是逆变的。具体规则比较复杂，但核心思想是遵循函数类型的变型性。
#### **7.3 可变引用的不变性**

需要注意的是，与典型的独占指针不同，可变引用必须是不变的，因为它们是被借用的：当生命周期结束时，借出者期望数据的类型仍然是原始类型 `τ`，而不是其某个超类型 `τ'`。

可变引用的不变性源于它们的借用性质，而独占指针由于完全拥有，可以是协变的。

### **8. 类型强制（Type Coercion）**

**类型强制**（Type Coercion）规则允许在类型上下文中进行类型转换。

#### **8.1 C-split-bor 规则**

- 这个规则是针对引用类型的类型分解（类似于之前的 `C-split-own`）。
- 条件是乘积类型的类型列表 `τ` 必须是非空的，否则右侧的双向类型强制将是空的。
- 偏移量 `m_i` 是第 `i` 个字段的偏移量，必须等于之前所有字段大小的总和。
- 规则形式：τ ≠ [ ] \quad ∀i. \; m_i = \sum_{j<i} size(τ_j) \quad \Longrightarrow \quad Γ | E; L ⊢ p \; \mathbf{C} \; &^{κ}_{μ} Πτ ⇔ p.m \; \mathbf{C} \; &^{κ}_{μ} τ
#### **8.2 其他类型强制规则**

- **C-perm**：类型上下文的排列。如果 T' 是 T 的一个排列，则 Γ | E; L ⊢ T ⇒ T'。
- **C-frame**：类型上下文的扩展。如果 Γ | E; L ⊢ T_1 ⇒ T_2，则对于任何 T'，Γ | E; L ⊢ T', T_1 ⇒ T', T_2。
#### **8.3 Continuation 的类型强制**

- Continuation 没有任何有趣的类型强制。
- 判断表达了上下文可以被重新排列、弱化，并且类型上下文中假设的行为是逆变的。
### **9. 指令的类型规则**

剩余的指令类型规则没有引入新的内容。我们可以类型化布尔值和整数算术，以及各种赋值操作。

#### **9.1 重要的指令类型规则**

- **S-memcpy 和 S-sum-memcpy**：这些规则执行读和写操作，使用之前在 `S-deref` 中见过的读助手判断。`S-memcpy` 用于内存拷贝，`S-sum-memcpy` 用于和类型的内存拷贝。
#### **9.2 S-deref-bor-own 和 S-deref-bor-mut**

- **问题背景**：之前的 `S-deref` 规则只能解引用指向 `Copy` 类型的指针，因为它创建了指针后面数据的副本。这对于类型检查那些执行（重新）借用嵌套指针的 Rust 程序是不够的。
- **解决方案**：引入 S-deref-bor-own 和 S-deref-bor-mut 规则，解决了 S-deref 的局限性。
- **规则解释**：**S-deref-bor-own**：用于解引用类型为 `&^{κ}_{μ} \text{own}^{n} τ` 的指针。解引用后得到一个类型为 `&^{κ}_{μ} τ` 的变量。**S-deref-bor-mut**：用于解引用嵌套的可变引用，如 `&^{κ}_{μ} &^{κ'}_{\text{mut}} τ`。需要证明 `Γ | E; L ⊢ κ \; \text{alive}`，并且 `Γ | E; L ⊢ κ \; \text{v} \; κ'`。解引用后得到一个类型为 `&^{κ}_{μ} τ` 的变量。
- **意义**：这些规则允许我们在类型检查中处理嵌套的借用和引用，符合 Rust 的借用规则。
### **10. 剩余的嵌套指针情况**

- 如果外部指针是所有权指针（如 `\text{own} \; \text{own} \; τ`），我们可以使用 `C-borrow` 将其转换为引用，然后应用 `S-deref-bor-own` 或 `S-deref-bor-mut`。
- 如果内部指针是共享引用，我们可以使用 `S-deref`，在这种情况下，我们获得的是内部引用的副本，具有完整的生命周期。
### **11. 函数体的类型规则**

#### **11.1 F-equalize**

- **作用**：当我们有一个本地生命周期 `α`，它是恰好一个其他生命周期 `κ` 的子生命周期时，我们可以“等化”这两个生命周期。这意味着我们可以声明 `α` 将尽可能长地持续，由于 `α` 是 `κ` 的子生命周期，这意味着它与 `κ` 一样长。因此，我们获得了 `α` 和 `κ` 之间的相互生命周期包含，并且从本地生命周期上下文中移除 `α`，因为我们不再控制它何时结束。
- **规则形式**：
$$
Γ | E, α \; \text{ve} \; κ, κ \; \text{ve} \; α; L | K; T ⊢ F \quad \Longleftarrow \quad Γ | E; L, α \; \text{vl} \; [κ] | K; T ⊢ F
$$
- **应用场景**：该规则用于类型检查关于非词法生命周期的复杂情况。
- **背景**：在 Rust 中，非词法生命周期（non-lexical lifetimes）允许更灵活的生命周期推断。作者提到该规则用于类型检查早期关于非词法生命周期的博客文章中的“问题案例 #3”。虽然目前的编译器仍然拒绝这种代码，但新的借用检查器（称为“Polonius”）正在开发中，支持这种代码是其设计目标之一。
#### **11.2 F-if 和 F-case-own**

- **F-if**：用于类型化条件分支语句 `if p then F1 else F2`。要求在相同的上下文下类型化 `F1` 和 `F2`。
- **F-case-own**：与 F-case-bor 类似，用于类型化对所有权指针的模式匹配。
**全面总结：**

本段内容对 **λRust** 类型系统进行了全面的补充和解释，填补了之前章节中省略的细节。作者详细定义了类型的良构性、类型的大小，以及对应于 Rust 中 `Copy`、`Send` 和 `Sync` 特征的判断。这些定义确保了类型系统的完整性和精确性。

此外，作者补充了生命周期包含的传递性规则和外部生命周期上下文的满足性判断，完善了生命周期管理的理论基础。子类型规则的详细讨论，包括结构性规则、递归类型的协变性和可变引用的不变性，深入揭示了类型系统的变型性原则。

类型强制规则的引入，特别是对于引用类型的类型分解，增强了类型系统的表达能力。新的指令类型规则 `S-deref-bor-own` 和 `S-deref-bor-mut` 解决了之前规则的局限性，使得类型系统能够准确地类型化嵌套的借用和引用操作，符合 Rust 的借用和生命周期规则。

最后，作者讨论了函数体的类型规则，特别是 `F-equalize` 规则，它在处理复杂的生命周期情况下发挥了重要作用。这个规则与 Rust 中非词法生命周期的概念相关，预示了未来 Rust 编译器在借用检查器方面的发展方向。

总体而言，本段内容完善了 λRust 类型系统的理论框架，使之能够更准确地模拟和验证 Rust 编程语言的类型系统和内存安全性。这为进一步研究 Rust 的形式化验证和安全性证明提供了坚实的基础。
 #  
 Thought for 1m 17s
**概览：**

本段内容来自 **第 10 章：在 Iris 中构建 λRust 类型的语义模型**。作者旨在通过定义 **逻辑关系（logical relation）**，将 **λRust** 的类型和类型判断解释为适当语义域中的逻辑谓词，以证明 **λRust** 类型系统的 **健全性（soundness）**。本章主要聚焦于类型的解释，暂时搁置类型判断的解释和主要健全性定理的陈述（将在第 12 章讨论）。首先，作者在 **§10.1** 中给出了类型语义域的简化版本。接着，为了对 λRust 程序进行推理，他们需要合适的程序逻辑，其具体特性在 **§10.2** 中介绍。在此基础上，他们将给出一些典型 λRust 类型的语义解释（将在 **§10.3** 中讨论）。最后，他们在 **§10.4** 中专注于共享引用类型的解释，发现需要对类型的语义域进行泛化。

**详细解读：**

### **第 10 章：在 Iris 中构建 λRust 类型的语义模型**

**背景：**

- **λRust** 是对 Rust 编程语言的一种简化形式，旨在捕获 Rust 的核心特性，如所有权、借用和生命周期。
- **Iris** 是一个用于构建并发程序逻辑的框架，支持高阶逻辑和资源的所有权推理，非常适合于描述像 Rust 这样具有所有权模型的语言。
**目标：**

- 证明 λRust 类型系统的 **健全性**，即类型系统的规则能够确保程序的正确性和内存安全。
- 通过定义 **逻辑关系（logical relation）**，将 λRust 的类型和类型判断解释为 Iris 中的逻辑谓词。
**内容结构：**

1. **§10.1 简化的类型语义域**
- 回答“什么是类型？”这个问题，建立类型的语义模型。
- 讨论如何在 Iris 中表示类型，以及为什么需要一个复杂的语义模型。
2. **§10.2 程序逻辑**
- 为了使用 Iris 构建 λRust 的语义模型，需要为 λRust 实例化 Iris。
- 引入 λRust 特有的推理原则，包括对递归函数和内存操作的证明规则。
3. **§10.3 典型 λRust 类型的语义解释**
- 基于之前建立的语义域和程序逻辑，给出一些代表性类型的语义解释。
4. **§10.4 共享引用类型的解释**
- 针对共享引用类型，发现需要对类型的语义域进行泛化。
### **§10.1 简化的类型语义域**

**什么是类型？**

- 通常，类型被认为是值的集合，或者等价地，值上的谓词。
- 在 λRust 中，类型也是值上的谓词，但由于需要处理所有权等概念，细节更加复杂。
**在 Iris 中表示类型：**

- **Iris** 是一个基于分离逻辑的框架，适用于推理并发程序和所有权。
- 使用 Iris 来表示类型的优点：**所有权（ownership）** 等概念已经内置在框架中。模型本身不需要额外处理所有权的细节。
**类型的语义模型：**

- **类型不是简单的值上的谓词**：在 λRust 中，类型与每个类型 τ 关联了一个 **Iris 谓词**，记为 ⟦τ⟧.own ∈ TId × List(Val) → iProp。TId：线程标识符类型。List(Val)：值的列表，表示类型实例对应的值列表。iProp：Iris 中的谓词类型，表示逻辑断言。
**类型语义模型的细节：**

- **为什么需要值的列表？**在 λRust 中，类型描述了内存中布局的数据，可能跨越多个位置（内存单元）。例如，乘积类型（类似结构体）需要多个内存位置来存储其字段。
- **类型的固定大小（size）：**我们需要对类型接受的值列表施加一些限制：要求每个类型都有一个固定的大小 ⟦τ⟧.size。大小用于计算复合数据结构的内存布局。
- **大小的约束：**我们要求类型只接受长度与其大小匹配的值列表：

$$
⟦τ⟧.\text{own}(t, v) ⊢ |v| = ⟦τ⟧.\text{size} \quad (\text{ty-size})
$$
|v| 表示值列表 v 的长度。
- **Copy 类型的持久性（persistence）：**对于 **Copy** 类型，我们要求 ⟦τ⟧.own(t, v) 是 **持久的（persistent）**。**持久性**：在 Iris 中，持久的断言可以被自由复制和共享，不涉及独占的所有权。
- **线程标识符的作用：**谓词的第一个参数 t（类型为 TId）允许类型依赖于声明所有权的线程的标识符。这在处理类似 &Cell 这样的类型时很重要，后者不能被发送到另一个线程。**所有权通常是相对于线程的（thread-relative）**。
- **Send 类型的自然建模：**通过这种方式，我们可以自然地建模 **Send** 特性。语义上，如果类型 τ 的 ⟦τ⟧.own 不依赖于线程标识符 t，则类型 τ 是 **Send** 的。这将在 **§12.4** 中正式定义，在 **§13.1** 中，我们将看到 Cell 如何关键地使用线程标识符。
**语义类型的定义：**

- **初步形式：**
$$
\text{PreSemType} := (\text{size} : \mathbb{N}, \; \text{own} : TId × \text{List(Val)} → \text{iProp})
$$
- **语义类型集合：**
$$
\text{SemType} := \{ T ∈ \text{PreSemType} \; | \; ∀t, v. \; T.\text{own}(t, v) ⊢ |v| = T.\text{size} \}
$$
SemType 是所有满足大小约束的初步语义类型的集合。
### **§10.2 程序逻辑**

**Iris 的实例化：**

- 为了在 Iris 中为 λRust 构建语义模型，我们需要为 λRust 实例化 Iris。
- Iris 中的大部分证明规则（如 **图 5.6，第 75 页**）都可以直接使用。
- 但是，λRust 与 HeapLang（Iris 中的简单示例语言）在推理原则上略有不同。
**主要区别：**

1. **递归函数：**
- λRust 有递归函数，而我们之前使用的 HeapLang 的简化版本没有。
- 因此，我们需要一个适合递归函数的推理原则。
2. **内存模型：**
- λRust 的内存模型与 HeapLang 不同，需要专门的证明规则。
#### **递归函数**

**递归函数的证明规则（hoare-rec）：**

- **位置：** **图 10.1** 的顶部。
- **规则解释：****目标：** 验证递归函数 rec f(x) := e 应用于某些参数时的正确性。**方法：** 只需在假设所有递归调用（经过适当的替换后，将是对 rec f(x) := e 的调用）已经被验证的情况下，验证函数体 e。**细节：**递归假设包含对所有参数 v 的全称量化（∀v），这对于允许递归调用使用与原始调用不同的参数至关重要。**前置条件 P** 可以依赖于参数 v，因此可以作为循环不变式（loop invariant）。整个假设被包含在 **持久性模态（persistence modality）**  中，以确保验证结果可以根据需要多次应用。**持久性模态 ：** 确保断言可以被重复使用，不会消耗资源。
- **规则形式：**\begin{align*}
& \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad
 \left( ∀v. \{ P \} \; (\text{rec} \; f(x) := e)(v) \; \{ w. Q \} \right) \\
& \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad
⊢ ∀v. \{ P \} \; e[\text{rec} \; f(x) := e / f, \; v / x] \; \{ w. Q \} \\
& \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad
⊢ ∀v. \{ P \} \; (\text{rec} \; f(x) := e)(v) \; \{ w. Q \}
\end{align*}
- **理解：**上述规则表示，如果我们能够在递归假设下验证函数体 e，那么我们就可以验证整个递归函数应用于任何参数 v 的正确性。
- **推导方法：**可以使用 **Löb 归纳法（Löb induction）** 来推导 **hoare-rec** 规则。使用 **O-app** 简化步骤来去除在归纳过程中出现的 **later（稍后）**。
- **注释：****注释 2：** 全面的 HeapLang（在 Coq 中形式化）也支持递归函数，但我们在第一部分中使用的简化版本没有。**注释 3：** 即使使用最弱前置条件版本的规则，也需要这样的循环不变式，这使得 **hoare-rec** 成为少数在使用最弱前置条件而不是 Hoare 三元组时不会变得更简单的证明规则之一。
#### **内存操作**

**关键断言：**

- 我们用于推理内存的两个关键断言是：**ℓ^q ↦ v**：表示 **fractional points-to** 断言的变体，适用于值的列表。断言从位置 ℓ 开始，接下来的 |v| 个内存位置包含值列表 v 中的值。声明我们拥有该内存区域 **q 份（fraction q）** 的所有权。**q**：所有权的份额，可以是小数，用于支持 **fractional ownership（部分所有权）**。**当 q = 1 时，表示完全所有权。****Dealloc(ℓ, n, m)**：与内存的分配和释放相关的断言。断言我们拥有部分释放内存块的权利，具体来说，我们拥有从位置 ℓ 开始，大小为 n 的内存块的释放权利。整个块的大小为 m。
- **这两个断言都是 无时效性的（timeless）。**
**证明规则：**

- **定义：** **图 10.1** 中定义了这些断言的规则。
- **ℓ^q ↦ v 的性质：****分割所有权的两个维度：****份额分割（Fractional Splitting）：** 可以减少整个区域的所有权份额（规则 `lrust-heap-add`）。如果我们拥有 q 份和 q' 份，则可以组合为 q + q' 份，前提是值列表相同。**区域分割（Spatial Splitting）：** 可以将块分割为两个部分，每个部分我们都以原始份额拥有（规则 `lrust-heap-app`）。这里，第二个 points-to 断言在左侧被偏移了第一个值列表的大小。**空列表的所有权（lrust-heap-nil）：**在某个位置拥有空列表的所有权是平凡的，断言 True。
- **内存位置的状态：**拥有某些内存，断言这些位置当前是 **未锁定的（unlocked）**，即它们的锁状态为读取 0。这使我们可以为 **原子（atomic）** 和 **非原子（non-atomic）** 的加载和存储操作提供完全标准的规则（如 lrust-deref-na、lrust-assign-sc 等）。
- **原子和非原子操作的区别：**从推理的角度来看，原子操作和非原子操作的区别在于原子操作是物理上的原子操作，这使我们可以使用类似 **wp-fup-atomic** 和 **hoare-inv** 的规则。**原子操作可以打开不变量（invariant）**，但非原子操作不能。**原因：**当我们拥有该内存的独占本地所有权时，两种操作的行为没有区别。区别在于当所有权被共享，多个线程访问由某些协议（由不变量强制执行）管理的相同位置时，它们的行为不同，不变量拥有内存。对于非原子操作，这种协调是不可能的，因为我们无法访问由不变量拥有的位置。
- **比较与同步：**我们仅展示了针对整数的 **CAS（Compare-And-Swap）** 规则（lrust-cas-int）。注意，该规则仅适用于整数 n、m，不适用于任意值 v。也可以对位置进行 CAS 操作，但由于位置相等的非确定性以及它如何依赖于堆中仍然分配的哪些位置，规则变得更加复杂。**注释 8：** 针对位置的 CAS 规则可以在 Coq 开发的 theories/lang/lifting.v 中找到。对于本文的示例，整数 CAS 足够了。
**Dealloc(ℓ, n, m) 的作用：**

- 该断言仅与内存的分配和释放相关。
- 表示我们拥有部分释放内存块的权利，具体来说，我们拥有从位置 `ℓ` 开始，大小为 `n` 的内存块的释放权利。
- 整个块的大小为 `m`。
- **证明规则：****lrust-dealloc-split：** 可以用于拆分和组合该权限，类似于 lrust-heap-app。**lrust-alloc：** 分配最初为整个块提供权限。**lrust-free：** 释放要求 n = m，以确保我们确实一次释放了整个块，而不仅仅是其中的一部分。
**派生的内存操作证明规则：**

- **lrust-new：**用于 new(n) 操作，类似于 alloc(n)，但没有侧条件 n > 0。规格与 lrust-alloc 类似。
- **lrust-delete：**用于 delete(|v|, ℓ) 操作，类似于 free，释放内存。
- **lrust-memcpy：**用于 memcpy(ℓ_d, n, ℓ_s) 操作。要求拥有两个大小相等的内存区域的所有权，对于源区域，只需拥有任何份额 q 即可（因为它只是被读取）。在后置条件中，目标区域 ℓ_d 包含源区域 ℓ_s 中原本的值 vs。
**注释：**

- **注释 6：** `∗−∗` 是一个 **双向魔杖（two-way magic wand）** 的简写：
$$
P ∗−∗ Q := (P −∗ Q) ∧ (Q −∗ P)
$$
这与我们的 Coq 形式化匹配：当有必要时，我们只使用蕴涵（implication），否则使用魔杖（magic wand）。
- **注释 7：** 注意左侧的第二个 `points-to` 断言偏移量正好是第一个值列表的大小。
**全面总结：**

本段内容深入探讨了在 Iris 框架中构建 λRust 类型的语义模型，旨在证明 λRust 类型系统的健全性。作者首先解释了类型在 λRust 中的语义模型，即类型与一个 Iris 谓词关联，该谓词取线程标识符和值列表作为参数。由于类型描述了跨多个内存位置的数据布局，必须对值列表的长度施加限制，确保其与类型的固定大小匹配。此外，针对 Copy 类型，需要保证其所有权谓词是持久的。

为了在 Iris 中使用 λRust 的语义模型，作者需要为 λRust 实例化 Iris，并引入了适用于 λRust 的程序逻辑，特别是递归函数和内存操作的证明规则。递归函数的证明规则（`hoare-rec`）允许在递归假设下验证函数体，从而验证整个递归函数的正确性。内存操作的证明规则涉及到关键的断言，如 `ℓ^q ↦ v` 和 `Dealloc(ℓ, n, m)`，用于表示内存所有权和释放权限。这些规则支持对内存的部分所有权和区域分割，以及对原子和非原子操作的推理。

通过这些定义和规则，作者为 λRust 类型系统的健全性证明奠定了坚实的基础。类型的语义模型精确地捕捉了所有权、线程相对性和类型大小等关键概念，而程序逻辑则提供了推理递归函数和内存操作的必要工具。这些工作将为后续章节中类型判断的解释和健全性定理的证明提供支持。
Thought for 1m 45s
**概览：**

这段文字来自《Understanding and Evolving the Rust Programming Language》（理解和发展 Rust 编程语言）一书的第 10 章，重点讨论了 **λRust** 中类型的解释。λRust 是 Rust 语言的一个简化版本，用于形式化地验证 Rust 的类型系统和内存安全性。

作者介绍了如何将 **λRust** 的 **语法类型（syntactic types）** 映射到 **语义域（semantic domain）**，这是一种在 **Iris** 框架中描述类型含义的数学结构。Iris 是一个用于并发程序和资源所有权推理的强大工具。

在这段内容中，作者主要解释了几种具有代表性的类型，包括布尔值（`bool`）、乘积类型（类似于元组）、所有权指针（`ownn τ`）和可变引用（`&^{κ}_{\text{mut}} τ`）。他们详细讨论了每种类型在语义域中的表示方式、大小计算，以及所有权和借用如何在递归类型和生命周期的上下文中处理。

**详细解读：**

### **引言：类型的语义解释**

**语义域的作用：**

- **语义域**是一个数学结构，用于表示编程语言构造的含义。
- 在本节中，作者将 **语法类型**（程序中书写的类型）映射到 **语义类型**，以便在 Iris 中对程序的行为进行形式化推理。
**目标：**

- 定义一个函数，将语法类型 τ 转换为其在语义域中的表示 ⟦τ⟧。
- 这个语义解释提供了一种方式，理解值属于某种类型在逻辑上的含义。
**逻辑关系：**

- 传统上，类型可以被视为值上的谓词（即，它们定义了属于该类型的值的集合）。
- 这种映射有时被称为 **逻辑关系**，因为它将类型与其对应的值联系起来。
**复杂性说明：**

- 由于涉及所有权、借用和并发等概念，λRust 的语义域比简单的值到命题的映射（如 Val → Prop）更复杂。
- 因此，作者使用 **语义解释** 一词，而不是逻辑关系。
### **具体类型的解释**

#### **1. 布尔类型（Booleans）**

**大小（Size）：**

- 布尔类型的大小被定义为 1：

$$
\⟦\text{bool}\⟧.\text{size} := 1
$$
- 这表示一个布尔值在内存中占用一个单位的空间。
**语义谓词（Semantic Predicate）：**

- 布尔类型的语义谓词定义为：

$$
\⟦\text{bool}\⟧.\text{own}(t, v) := v = [\text{true}] \lor v = [\text{false}]
$$
t：线程标识符（在布尔类型中不太重要，但在并发场景中有用）。v：值的列表。
**解释：**

- 布尔值表示为一个包含单个元素的列表，该元素要么是 true，要么是 false。
- 由于大小为 1，因此列表长度必须为 1。
**整数类型的相似性：**

- 整数类型的语义解释与布尔类型类似，但需要考虑整数的值域。
#### **2. 乘积类型（Products）**

**定义：**

- 给定两个类型 τ₁ 和 τ₂，它们的乘积类型 τ₁ × τ₂ 表示一个复合类型，其值由两个部分组成，分别属于 τ₁ 和 τ₂。
**大小计算：**

- 乘积类型的大小是其组成部分大小之和：

$$
\⟦τ₁ × τ₂\⟧.\text{size} := \⟦τ₁\⟧.\text{size} + \⟦τ₂\⟧.\text{size}
$$
- 这反映了它们在内存中的布局——一个接一个地排列。
**语义谓词：**

- 乘积类型的语义谓词为：

$$
\⟦τ₁ × τ₂\⟧.\text{own}(t, v) := \exists v₁, v₂.\ v = v₁ ++ v₂ \land \⟦τ₁\⟧.\text{own}(t, v₁) \ast \⟦τ₂\⟧.\text{own}(t, v₂)
$$
v₁ 和 v₂：分别对应 τ₁ 和 τ₂ 的值列表。v = v₁ ++ v₂：表示值列表 v 是 v₁ 和 v₂ 的连接（++ 表示列表连接）。∗：分离合取（separating conjunction），表示对不同资源的所有权。
**解释：**

- 语义谓词表明，值列表 v 可以拆分为 v₁ 和 v₂，分别对应 τ₁ 和 τ₂。
- 分离合取确保我们可以独立地处理 v₁ 和 v₂，它们对应的资源是分开的。
**扩展到 n 元组：**

- 这个定义可以迭代应用于多个类型，以解释 n 元乘积类型。
#### **3. 所有权指针（Owned Pointers）**

**定义：**

- 类型 \text{own}^{n} τ 表示一个指向类型 τ 的所有权指针，分配的内存块大小为 n。
**大小计算：**

- 所有权指针的大小为 1：

$$
\⟦\text{own}^{n} τ\⟧.\text{size} := 1
$$
- 这反映了指针本身（地址）在内存中占用一个单位的空间。
**语义谓词：**

- 所有权指针的语义谓词为：

$$
\⟦\text{own}^{n} τ\⟧.\text{own}(t, v) := \exists \ell.\ v = [\ell] \land .\left(\exists w.\ \ell \mapsto w \ast \⟦τ\⟧.\text{own}(t, w) \ast \text{Dealloc}(\ell, \⟦τ\⟧.\text{size}, n)\right)
$$
\ell：内存位置（地址）。v = [\ell]：值列表 v 是一个包含地址 \ell 的单元素列表。.：**later 模态**，来自 Iris，用于处理递归定义。\ell \mapsto w：断言地址 \ell 存储值 w。\text{Dealloc}(\ell, \⟦τ\⟧.\text{size}, n)：表示有权释放从 \ell 开始、大小为 \⟦τ\⟧.\text{size} 的内存块，总的分配大小为 n。
**解释：**

- 一个所有权指针指向某个地址 \ell，该地址存储一个类型为 τ 的值 w。
- 我们对指针的所有权包括：知道地址 \ell。拥有地址 \ell 处的内存，存储值 w。有权在适当的时候释放内存（通过 \text{Dealloc} 表示）。
**later 模态的使用：**

- 整个断言被 .（later 模态）包裹，这是 Iris 中用于 **守护递归（guarded recursion）** 的机制。
**为什么使用 later 模态？**

- **递归类型：**在 λRust 中，递归类型如果递归出现位于指针或函数类型的下方，则是良构的。这意味着指针类型和函数类型在处理递归时有特殊的作用。
- **守护递归：**守护递归允许我们定义递归谓词，但只能在 . 模态的下方引用自身。这确保了递归定义是可解的，即使递归引用在正向、负向或两者中出现。使用 **步索引（step-indexing）** 技术来解决循环定义（参见脚注 12，引用了 Appel 和 McAllester 的工作）。
- **实际效果：**通过在递归出现处添加 .，我们确保语义定义是良构的，并且可以在 Iris 中处理。
**对类型系统证明的影响：**

- 当我们需要 **使用** 指针后面的所有权时，需要去除 . 模态。
- 这与程序中的计算步骤对应（例如解引用指针），正好符合需要去除 . 的情形。
**关于 Dealloc：**

- **作用：**表示有权释放某个内存块。如果 n = \⟦τ\⟧.\text{size}，我们可以释放正好存储 τ 的内存块。
- **当 n 较大时：**如果 n > \⟦τ\⟧.\text{size}，表示分配的内存块比 τ 的大小更大。我们只拥有该内存块的一部分，这考虑了指针指向更大数据结构一部分的情况。
#### **4. 可变引用（Mutable References）**

**定义：**

- 可变引用 &^{κ}_{\text{mut}} τ 是一个指向类型 τ 的独占（唯一）指针，借用（borrowed）了一个生命周期 κ。
**大小计算：**

- 可变引用的大小为 1：
\⟦&^{κ}_{\text{mut}} τ\⟧.\text{size} := 1
- 这表示引用本身在内存中占用一个单位的空间。
**带有到期日期的所有权：**

- 在标准的分离逻辑中，断言通常表示对堆中资源的无限期所有权，或直到所有者主动转移所有权。
- 然而，在 Rust 中，可变引用表示 **有限时间内的所有权**。当引用的生命周期 κ 结束后，可变引用变得无用，原始所有者重新获得完整的所有权。
**生命周期逻辑：**

- 为了处理这种带有到期日期的所有权，作者开发了一个用于推理生命周期和借用的自定义逻辑，称为 **生命周期逻辑**（将在第 11 章详细描述）。
- **完整借用断言（Full Borrow Assertion）：**对于一个 Iris 断言 P 和一个生命周期 κ，生命周期逻辑定义了一个断言 &^{κ}_{\text{full}} P。这表示在生命周期 κ 内对 P 的所有权。
**语义谓词：**

- 可变引用的语义谓词为：
\⟦&^{κ}_{\text{mut}} τ\⟧.\text{own}(t, v) := \exists \ell.\ v = [\ell] \land &^{\⟦κ\⟧}_{\text{full}} \left(\exists w.\ \ell \mapsto w \ast \⟦τ\⟧.\text{own}(t, w)\right)\ell：内存位置。v = [\ell]：值列表 v 是一个包含地址 \ell 的单元素列表。&^{\⟦κ\⟧}_{\text{full}}：生命周期 κ 上的完整借用断言。断言内部类似于所有权指针的情况，但没有 . 模态。
**解释：**

- 可变引用表示为一个地址 \ell，并关联了一个生命周期 κ。
- 我们对可变引用的所有权包括：知道地址 \ell。在生命周期 κ 内临时拥有地址 \ell 处的内存，存储值 w，类型为 τ。
- 当生命周期 κ 结束后，完整借用断言 &^{\⟦κ\⟧}_{\text{full}} 失效，所有权回到原始所有者。
**与所有权指针的比较：**

- **相似之处：**两者都涉及指向类型 τ 的值的地址 \ell。
- **差异：**所有权指针表示无限期的所有权（通过 . 模态处理递归）。可变引用表示临时所有权（通过完整借用断言和生命周期 κ 限制）。
**不需要 . 模态：**

- 完整借用断言 &^{\⟦κ\⟧}_{\text{full}} 已经作为递归定义的守护，因此不需要额外的 . 模态。
**没有 Dealloc：**

- 由于可变引用不能用于释放内存（见脚注 13），因此在其语义谓词中不需要包含 \text{Dealloc}。
### **脚注解释**

**脚注 9：**

- **逻辑关系与语义解释：**在更传统的语义域（如 Val → Prop）中，类型可以被解释为从值到命题的函数。这形成了类型与值之间的逻辑关系。
- **复杂域：**在 λRust 和 Iris 中，语义域更复杂，涉及所有权、生命周期等概念。因此，作者更倾向于使用 **语义解释** 一词。
**脚注 10：**

- **n 在 \text{own}^{n} τ 中的含义：**n 表示分配的内存块的大小，可能大于 τ 的大小。这允许指针指向更大的内存块中的一部分。
**脚注 11：**

- **new 函数的行为：**new 是 alloc 的包装器，即使对于大小为 0 的情况，也始终返回一个位置（地址）。如果 new 返回其他内容（如整数 0），我们需要在 \text{own-ptr-own} 中考虑这种情况。
**脚注 12：**

- **引用步索引技术：****步索引（step-indexing）** 技术用于解决递归类型中的循环定义。作者引用了 Appel 和 McAllester 在 2001 年的工作。
**脚注 13：**

- **关于可变引用没有 Dealloc：**可变引用不能用于释放内存，因此在其语义谓词中不需要 \text{Dealloc}。
**全面总结：**

在这段内容中，作者详细讨论了如何在 Iris 框架中解释 λRust 的类型。他们定义了一个从语法类型到语义域的映射，为类型赋予了形式化的含义，特别关注所有权、内存布局和生命周期等关键概念。

首先，他们解释了简单的类型，如布尔类型，展示了如何定义其大小和语义谓词。这为后续更复杂类型的解释奠定了基础。

接着，他们讨论了乘积类型，解释了如何计算其大小，以及如何使用分离合取来组合其组成部分的所有权。这反映了复合数据结构在内存中的布局和管理方式。

对于所有权指针，他们深入解释了其语义谓词，包括如何表示指向某类型值的地址，以及如何处理递归类型。他们引入了 Iris 中的 `.` 模态（later 模态），用于实现守护递归，确保递归定义的正确性。

最后，他们讨论了可变引用，强调了其与所有权指针的区别。可变引用是临时的、借用的，需要考虑生命周期。他们使用了生命周期逻辑和完整借用断言 `&^{κ}_{\text{full}}`，准确地建模了 Rust 中的借用语义。

通过这些解释，作者展示了如何在 Iris 中形式化地建模 λRust 的类型系统，为证明其健全性和 Rust 程序的内存安全性奠定了基础。他们强调了递归类型、所有权和生命周期等核心概念的重要性，以及如何利用 Iris 的强大工具来处理这些复杂性。

总的来说，这段内容提供了对 λRust 类型在 Iris 中语义解释的深入理解，展示了如何在形式化框架中处理所有权、借用和生命周期等关键概念。这对于理解 Rust 编程语言的底层原理，以及形式化地验证其类型系统和内存安全性，都具有重要意义。
 #  
 Thought for 1m 4s
**概览：**

这段文字来自《Understanding and Evolving the Rust Programming Language》（理解和发展 Rust 编程语言）论文的第 10 章第 4 节，重点讨论了 **共享引用（Shared References）** 在 λRust 类型的语义模型中的解释。作者阐述了为什么共享引用的解释比之前讨论的类型更复杂，并介绍了如何在 Iris 框架中为每个类型定义自己的 **共享谓词（sharing predicate）**。这种方法允许不同的类型为其共享引用指定不同的行为，特别是对于像 `Cell` 和 `Mutex` 这样的类型，它们允许通过共享引用进行内部可变性（interior mutability）。文章深入探讨了共享引用的语义定义、需要满足的性质以及如何避免递归定义中的循环问题。

**详细解读：**

### **10.4 解释共享引用**

#### **引言**

- **共享引用的挑战：**在之前的类型中，我们通常通过基于 JτK.own 定义 J&^{κ}_{\text{shr}} τK.own，以满足类型规则的要求。然而，对于共享引用 &^{κ}_{\text{shr}} τ，这种方法并不适用，因为 Rust 中对 &T 几乎没有任何原始操作（primitive operations）。共享引用可以从可变引用创建（规则 **C-share**）。共享引用是 **Copy** 的，意味着它们可以被自由复制。共享引用的大小为 1，其值必须是内存位置（指针）。如果 T 本身是 **Copy** 的，可以从 &T 中复制数据出来（规则 **Tread-bor**）。因此，必须寻找一种新的方法来解释共享引用。
#### **初步模型及其局限**

- **朴素模型：**一个可能的模型是将共享引用解释为指向借用的只读内存，存储一些满足 JτK.own 的值列表 w。这种模型符合直觉，即 Rust 不允许通过共享引用修改数据。
- **问题：**这种只读的解释对于一般情况并不适用，因为像 Cell 或 Mutex 这样的类型允许通过共享引用进行修改操作。如果采用只读模型，我们将无法验证这些类型的操作在不安全代码中被安全地封装。在这种模型下，任何通过共享引用的修改都违反了类型系统的基本假设。
#### **引入共享谓词**

- **解决方案：**为了定义一个普遍适用的共享引用解释，我们允许每个类型定义自己的 **共享谓词（sharing predicate）**。我们使用类型 τ 的共享谓词 JτK.\text{shr} 来定义 J&^{κ}_{\text{shr}} τK.\text{own}。
- **优势：**这种方法允许每个类型对其共享引用定义不同的操作集。例如，基本类型（如 bool）的共享谓词允许任何人进行只读访问，而 Mutex<T> 的共享谓词允许在获取锁后对底层 T 类型的对象进行读写访问。
#### **共享引用的语义定义**

- **共享引用的所有权谓词：**J&^{κ}_{\text{shr}} τK.\text{size} := 1
J&^{κ}_{\text{shr}} τK.\text{own}(t, v) := \exists \ell.\ v = [\ell] \ast JτK.\text{shr}(JκK, t, \ell) \quad (\text{shr-ref-own})t：线程标识符。v：值的列表，表示共享引用的值（必须是一个包含内存位置 \ell 的单元素列表）。JκK：生命周期 κ 的解释。JτK.\text{shr}(JκK, t, \ell)：类型 τ 的共享谓词，参数为生命周期 κ、线程标识符 t 和位置 \ell。
- **共享谓词的参数：****生命周期 κ：** 指定共享引用的有效期。**线程标识符 t：** 用于支持线程相对的所有权，特别是在处理不能被发送到其他线程的类型时（例如 Cell）。**位置 \ell：** 共享引用指向的内存位置。
#### **共享谓词需要满足的性质**

为了支持共享引用的原始操作，确保类型系统的规则（如 **C-share** 和 **T-bor-lft**）能够被证明，共享谓词必须满足以下性质：

1. **持久性（Persistence）：**
$$
\text{persistent}(JτK.\text{shr}(κ, t, \ell)) \quad (\text{ty-shr-persist})
$$

- 共享谓词必须是 **持久的**。在 Iris 中，持久的断言不描述任何独占的权利或资源，因此可以被自由复制和共享。
- 这对应于 Rust 中共享引用始终是 **Copy** 的。
2. **从可变引用创建共享引用（ty-share）：**&^{κ}_{\text{full}} \left( \exists w.\ \ell \mapsto w \ast JτK.\text{own}(t, w) \right) \ast [κ]_q \equiv-\ast_{N_{\text{lft}}} JτK.\text{shr}(κ, t, \ell) \ast [κ]_q \quad (\text{ty-share})
- 表示共享引用可以从可变引用创建。
- **解释：**左侧的前提是对 τ 的所有权指针的 **完整借用（full borrow）**，即 &^{κ}_{\text{mut}} τ 的所有权谓词 J&^{κ}_{\text{mut}} τK.\text{own}(t, [\ell])。[κ]_q 是生命周期令牌，证明生命周期 κ 仍然存活，并允许访问借用。右侧的结论是类型 τ 的共享谓词，以及相同的生命周期令牌。\equiv-\ast_{N_{\text{lft}}} 是 Iris 中的 **视图转换（view shift）**，允许在指定的掩码（mask）N_{\text{lft}} 下安全地转换资源。掩码 N_{\text{lft}} 授予对生命周期逻辑的访问权限。
3. **关于生命周期参数的单调性（Monotonicity）：**
$$
κ' \sqsubseteq κ \ast JτK.\text{shr}(κ, t, \ell) \vdash JτK.\text{shr}(κ', t, \ell) \quad (\text{ty-shr-mono})
$$

- 共享谓词必须对生命周期参数 κ 是 **单调的**。如果 κ' 是 κ 的子生命周期，则从 κ 的共享谓词可以推导出 κ' 的共享谓词。
- 这对于证明类型系统中的子类型规则 **T-bor-lft** 是重要的。
#### **完成类型的语义域**

- **扩展后的语义类型定义：**

$$
\text{PreSemType} := \left\{
\begin{array}{l}
\text{size} : \mathbb{N}, \\
\text{own} : \text{TId} \times \text{List(Val)} \rightarrow \text{iProp}, \\
\text{shr} : \text{Lft} \times \text{TId} \times \text{Loc} \rightarrow \text{iProp}
\end{array}
\right\}
$$


$$
\text{SemType} := \left( T \in \text{PreSemType} \;\middle|\; \text{ty-size}, \text{ty-shr-persist}, \text{ty-share}, \text{ty-shr-mono} \right)
$$
这将共享谓词及其性质添加到类型的语义域中。
#### **为已有类型定义共享谓词**

##### **1. 乘积类型的共享谓词**

- **定义：**

$$
Jτ_1 \times τ_2K.\text{shr}(κ, t, \ell) := Jτ_1K.\text{shr}(κ, t, \ell) \ast Jτ_2K.\text{shr}(κ, t, \ell + Jτ_1K.\text{size})
$$
- **解释：**乘积类型的共享谓词是其两个组件的共享谓词的分离合取（∗）。第二个组件的位置偏移量为 Jτ_1K.\text{size}，反映了内存布局。
##### **2. 简单类型的共享谓词**

- **适用范围：**对于像 bool 这样的简单类型，它们是 **Copy** 的，大小为 1，我们可以为其定义统一的共享谓词。
- **所有权谓词的形式：**
$$
JτK.\text{own}(t, v) = \exists v.\ v = [v] \ast Φ_τ(t, v)
$$
Φ_τ 是特定于类型的持久谓词，例如：对于 bool 类型，Φ_{\text{bool}}(t, v) := v = \text{true} \lor v = \text{false}。
- **共享谓词的定义：**JτK.\text{shr}(κ, t, \ell) := \exists v.\ &^{κ}_{\text{frac}}(\lambda q.\ \ell^{q} \mapsto v) \ast .\ Φ_τ(t, v)&^{κ}_{\text{frac}}：生命周期 κ 上的 **分数借用（fractured borrow）**，允许对内容的部分所有权。\lambda q.\ \ell^{q} \mapsto v：一个函数，提供对位置 \ell 上值 v 的分数所有权 q。.：**稍后模态（later modality）**，用于处理递归类型，确保定义的良构性。
- **解释：**存在一个固定的值 v，共享引用指向的位置 \ell 存储该值。持久谓词 Φ_τ(t, v) 在稍后模态下成立。分数借用表示对内存单元的所有权被分割成多个部分，允许多个共享引用读取同一位置的值。
#### **关于所有权谓词中缺少 . 的解释**

- **观察：**在共享引用的所有权谓词 J&^{κ}_{\text{shr}} τK.\text{own}(t, v) 中，我们没有使用 . 来守护对共享谓词的使用。这可能令人惊讶，因为我们之前提到，为了定义递归类型的语义解释，所有指针类型都必须被守护。
- **解释：****为什么可以不使用 .：**共享谓词 JτK.\text{shr} 被定义为持久的，并且不会未守护地引用类型参数的所有权谓词。我们确保 **任何类型构造子（type constructor）** 的共享谓词都不会未守护地使用其类型参数的所有权谓词。因此，在定义 J&^{κ}_{\text{shr}} τK.\text{own} 时，我们可以未守护地使用 JτK.\text{shr}。**避免循环：**通过这种方式，我们避免了未守护的“循环”，即所有权谓词依赖于共享谓词，后者又（递归地）依赖于所有权谓词。这种循环会导致递归类型定义不良构。**类比：**可以将这种情况类比为互相递归的函数，通过某种顺序（如大小）对它们进行排序。较“大”的函数可以调用较“小”的函数，前提是参数大小不变或减小。在我们的语义类型域中，所有权谓词比共享谓词“更大”，因此允许所有权谓词基于共享谓词定义，但反之则不行。
- **结论：**通过精心设计，我们确保递归类型的定义是良构的。在 Coq 中的形式化证明也验证了共享引用正确地守护了 τ，递归类型是良好定义的。
#### **脚注解释**

- **脚注 14：**提到我们将在本节稍后看到，对于“简单类型”，共享引用的只读模型是我们采用的模型。
- **脚注 15：**解释了 Iris 中的连接词 P \equiv-\ast Q 是 P \vdash \left| \text{V} Q \right| 的简写。“视图转换（view shift）”一词用于 \text{V} 和 \equiv-\ast，但在本文中我们只使用了后者，因此不会有歧义。
- **脚注 16：**定义了 **类型构造子（type constructor）**，即以类型作为参数的类型形成器，如 &^{κ}_{\text{mut}} _ 或 _ \times _。
**全面总结：**

在这段内容中，作者深入探讨了共享引用在 λRust 类型语义模型中的解释。由于 Rust 中共享引用的独特性质，仅仅通过基于所有权谓词 `JτK.\text{own}` 定义共享引用的所有权谓词是不够的，特别是考虑到像 `Cell` 和 `Mutex` 这样的类型，它们允许通过共享引用进行修改操作。

为了解决这一问题，作者引入了 **共享谓词（sharing predicate）** 的概念，允许每个类型 `τ` 定义自己的共享谓词 `JτK.\text{shr}`。共享谓词捕获了类型 `τ` 的共享引用的行为，并且需要满足特定的性质，如持久性、从可变引用创建共享引用的能力，以及对生命周期参数的单调性。

通过为类型语义域添加共享谓词和相关性质，作者能够为共享引用提供一个通用且灵活的语义解释。这使得不同的类型可以指定其共享引用的行为，既支持简单类型的只读共享，也支持具有内部可变性的类型。

此外，作者详细解释了为什么在共享引用的所有权谓词中不需要使用 `.`（稍后模态）来守护对共享谓词的使用。他们通过类比互相递归的函数，说明了如何避免未守护的循环，确保递归类型的定义是良构的。

总的来说，这段内容阐明了共享引用在 λRust 类型语义模型中的复杂性，以及如何通过共享谓词的引入和精心设计来解决这些问题。这为后续在 Iris 中形式化验证 Rust 程序的类型安全性和内存安全性奠定了重要基础。
 #  
 Thought for 8 seconds
**概览：**

这段文字来自《Understanding and Evolving the Rust Programming Language》（理解和发展 Rust 编程语言）一书的 **第 11 章：生命周期逻辑（Lifetime Logic）**。本章旨在深入探讨 **λRust** 中的生命周期逻辑，这是在 Iris 框架中开发的一个库，用于支持与 Rust 中生命周期和借用相关的概念。

在之前的第 10 章中，作者给出了 λRust 类型的语义模型，但留下了一些重要的概念未定义，特别是 **完整借用（full borrows）**、**生命周期令牌（lifetime tokens）** 和 **分数借用（fractured borrows）**。本章通过一个具体的 Rust 示例，详细解释了这些概念，并展示了它们在 Iris 中的实现。

主要内容包括：

1. **完整借用和生命周期令牌（§11.1）**：解释了完整借用的作用，以及如何使用生命周期令牌来跟踪生命周期的开始和结束。
2. **生命周期的比较和交集（§11.2）**：讨论了如何比较生命周期，以及如何处理生命周期的交集。
3. **分数借用和原子借用（§11.3 和 §11.4）**：介绍了两种持久借用形式，分数借用用于定义共享谓词，原子借用用于在并发环境中安全地访问数据。
4. **索引借用（Indexed Borrows）（§11.5）**：解释了如何将所有形式的借用都表示为更底层的索引借用机制。
5. **在 Iris 中实现生命周期逻辑和索引借用（§11.6 和 §11.7）**：概述了如何在 Iris 中实现这些概念。
**详细解读：**

### **第 11 章：生命周期逻辑（Lifetime Logic）**

#### **背景**

- 在第 10 章中，作者构建了 λRust 类型的语义模型，但一些重要概念尚未定义。
- 特别是，**完整借用（&^{κ}_{\text{full}} P）** 用于解释可变引用的语义，反映了所有权是临时的，会在生命周期 `κ` 结束时“过期”。
- **生命周期令牌（[κ]_q）** 用于证明生命周期正在进行中。
- **分数借用（&^{κ}_{\text{frac}} Φ）** 用于简单类型的共享谓词中。
#### **11.1 完整借用和生命周期令牌**

**示例代码**

作者通过以下 Rust 示例来解释生命周期逻辑：

```rust
1 let mut v = vec![10, 11]; v.push(12);
2 let vptr = v.index_mut(1);
3 *vptr = 23;
4 println!("{:?}", v);
```

- **第 1 行**：创建一个可变的向量 `v`，并在其末尾添加元素 `12`。
- **第 2 行**：获取向量 `v` 中索引为 `1` 的元素的可变引用，存储在 `vptr` 中。这里将 &mut v[1] 展开为 v.index_mut(1)，进一步展开为 Vec::index_mut(&mut v, 1)。
- **第 3 行**：通过可变引用 `vptr` 修改该元素的值为 `23`。
- **第 4 行**：打印向量 `v` 的内容。
**index_mut 函数的类型**

```rust
for<'a> fn(&'a mut Vec, usize) -> &'a mut i32
```

- 该函数接受一个生命周期为 `'a` 的可变引用 `&'a mut Vec<i32>`，返回一个同一生命周期的可变引用 `&'a mut i32`。
- 为了调用这个函数，我们需要一个生命周期 `κ` 来实例化 `'a`。
**生命周期的创建**

- **规则 LftL-begin**：用于创建一个新的生命周期 `κ`。它允许我们执行一个 Iris 视图转换（view shift），创建一个新的生命周期 `κ`，并给我们一个完整的生命周期令牌 `[κ]_1`。**生命周期令牌 [κ]_1** 证明生命周期 `κ` 正在进行中。该规则还提供了一个视图转换 `[κ]_1 ≡−. ∗_{N_{\text{lft}}} [†κ]`，用于在稍后结束生命周期时，将完整的生命周期令牌 `[κ]_1` 交换为一个死亡令牌 `[†κ]`，表示生命周期 `κ` 已结束。**N_{\text{lft}}** 是一个掩码（mask），用于控制对生命周期逻辑的访问。
**完整借用的创建**

- **规则 LftL-borrow**：是生命周期逻辑的核心规则，用于创建完整借用。它的形式是：. P ≡−∗_{N_{\text{lft}}} &^{κ}_{\text{full}} P \ast \left( [†κ] ≡−∗_{N_{\text{lft}}} . P \right)左侧的 `. P` 是我们拥有的资源（在本例中是向量 `v`）。右侧得到：**完整借用 &^{κ}_{\text{full}} P**：表示在生命周期 `κ` 内对资源 `P` 的所有权。**继承（inheritance）**：一个视图转换 `[†κ] ≡−∗_{N_{\text{lft}}} . P`，当生命周期 `κ` 结束时，我们可以使用死亡令牌 `[†κ]` 来取回资源 `P`。**≡−∗_{N_{\text{lft}}}** 是 Iris 中的视图转换（view shift），在掩码 `N_{\text{lft}}` 下执行。**解释**：该规则将资源 `. P` 的所有权在时间上进行了分割。**在生命周期 κ 内**，完整借用 `&^{κ}_{\text{full}} P` 允许我们对资源 `P` 进行操作。**在生命周期 κ 结束后**，通过继承视图转换，我们可以取回资源 `P`。**分离合取（∗）** 表示两部分是“分离的”，即它们可以独立使用。这种所有权的时间分割允许我们将资源的借用传递给 `index_mut` 函数，并保留继承以便在生命周期结束后取回资源。
**index_mut 函数的所有权操作**

- 在调用 `index_mut` 时，我们将向量 `v` 的所有权（位于完整借用中）分为两部分：**访问的向量位置的所有权**（即索引为 `1` 的元素）。**向量其余部分的所有权**。
- **规则 LftL-bor-split**：用于将完整借用拆分为针对各部分的完整借用。形式为：&^{κ}_{\text{full}} (P ∗ Q) ≡−∗_{N_{\text{lft}}} &^{κ}_{\text{full}} P ∗ &^{κ}_{\text{full}} Q**解释**：将一个完整借用包含的资源 P ∗ Q 拆分为两个完整借用，分别包含资源 P 和 Q。
- **处理方式**：将部分（1）的完整借用返回给调用者，这与 `index_mut` 的返回类型匹配。将部分（2）的完整借用丢弃（在 Iris 中，我们可以随时放弃资源的所有权，因为 Iris 是一个仿射逻辑）。
- **关键特性**：支持忘记某些借用的资源，并在生命周期结束时通过继承取回它们的所有权。
**对借用的访问**

- **规则 LftL-bor-acc**：用于访问完整借用中包含的资源。形式为：&^{κ}_{\text{full}} P ∗ [κ]_q \propto_{N_{\text{lft}}} . P左侧需要：**完整借用 &^{κ}_{\text{full}} P**。**生命周期令牌 [κ]_q**，证明生命周期 `κ` 仍在进行中。右侧得到资源 `. P`（稍后模态下）。**视图转换**：我们还获得一个视图转换 . P ≡−∗_{N_{\text{lft}}} &^{κ}_{\text{full}} P ∗ [κ]_q，当我们完成对资源 P 的操作后，可以重新构造完整借用并取回生命周期令牌。
- **在示例中**：在第 3 行，我们需要访问完整借用 `&^{κ}_{\text{full}} P` 中的资源，以便对指针 `*vptr` 进行写操作。使用 `LftL-bor-acc`，我们可以获取资源 `. P`（即对元素的所有权），进行修改，然后重新构造完整借用。
**结束生命周期**

- **规则 LftL-end-persist**：死亡令牌 `[†κ]` 是 **持久的（persistent）**。这意味着一旦生命周期结束，我们可以多次使用死亡令牌 [†κ]。
- **在示例中**：在第 3 行之后，我们不再需要 `vptr`，可以结束生命周期 `κ`。使用在创建生命周期时获得的视图转换 `[κ]_1 ≡−. ∗_{N_{\text{lft}}} [†κ]`，我们将完整的生命周期令牌 `[κ]_1` 交换为死亡令牌 `[†κ]`。我们放弃了生命周期令牌 `[κ]_1`，确保所有借用都已关闭。使用死亡令牌 `[†κ]`，通过继承视图转换 `[†κ] ≡−∗_{N_{\text{lft}}} . P`，我们取回了资源 `. P`（即向量 `v` 的所有权）。
- **打印向量**现在我们重新获得了向量 v 的所有权，可以在第 4 行打印它。
**生命周期令牌的分数**

- **参数 q**：生命周期令牌 `[κ]_q` 中的 `q` 是一个 **份额（fraction）**。生命周期令牌可以按照规则 **LftL-tok-fract** 可逆地分割为更小的部分：
$$
[κ]_{q+q'} ∗−∗ [κ]_q ∗ [κ]_{q'}
$$
**用途**：当我们希望同时访问具有相同生命周期的多个完整借用时，需要分割生命周期令牌。当多个线程需要证明生命周期正在进行时，也需要分割生命周期令牌。
- **防止生命周期同时处于死亡和存活状态****规则 LftL-not-own-end**：
$$
[κ]_q ∗ [†κ] −∗ \text{False}
$$
表示生命周期令牌 `[κ]_q` 和死亡令牌 `[†κ]` 不能同时存在。确保生命周期不能同时处于死亡和存活状态。
#### **完整借用的其他特性**

- **规则 LftL-bor-exists**：允许将存在量词从完整借用中“提取”出来。形式为：&^{κ}_{\text{full}} \left( \exists x.\ P \right) ≡−∗_{N_{\text{lft}}} \exists x.\ &^{κ}_{\text{full}} P假设量词的定义域是非空的。**解释**：在 `&^{κ}_{\text{full}} (\exists x.\ P)` 中，每次访问借用时，我们都可以获得一个新的 `x`。通过该规则，我们可以将存在量词提取出来，使得 `x` 被固定。
- **规则 LftL-bor-shorten**：允许缩短完整借用的生命周期。形式为：κ' \sqsubseteq κ −∗ &^{κ}_{\text{full}} P −∗ &^{κ'}_{\text{full}} P如果生命周期 κ' 包含于 κ，则可以将完整借用的生命周期从 κ 缩短到 κ'。
#### **总结**

- **完整借用（&^{κ}_{\text{full}} P）**：表示在生命周期 `κ` 内对资源 `P` 的临时所有权。
- **生命周期令牌（[κ]_q）**：证明生命周期 `κ` 正在进行，可以被分割为更小的份额。
- **死亡令牌（[†κ]）**：表示生命周期 `κ` 已结束，是持久的。
- **继承（Inheritance）**：在生命周期结束后，通过视图转换 `[†κ] ≡−∗_{N_{\text{lft}}} . P` 取回资源的所有权。
- **借用的访问和关闭**：通过 `LftL-bor-acc` 访问完整借用中的资源，需要在完成后重新构造完整借用并取回生命周期令牌。
- **生命周期的结束**：通过视图转换 `[κ]_1 ≡−. ∗_{N_{\text{lft}}} [†κ]` 结束生命周期，放弃生命周期令牌，获得死亡令牌。
**全面总结：**

在这段内容中，作者详细介绍了 **生命周期逻辑（Lifetime Logic）**，这是在 Iris 框架中为 λRust 开发的一个库，用于形式化地处理 Rust 中的生命周期和借用机制。通过一个具体的 Rust 示例，作者解释了完整借用、生命周期令牌和死亡令牌的概念，以及它们在程序中的作用。

首先，作者介绍了如何使用 **LftL-begin** 规则创建一个新的生命周期 `κ`，并获得完整的生命周期令牌 `[κ]_1`，这证明了生命周期的开始。然后，使用 **LftL-borrow** 规则创建了一个 **完整借用 &^{κ}_{\text{full}} P**，表示在生命周期 `κ` 内对资源 `P` 的所有权，同时保留了一个继承，以便在生命周期结束后取回资源的所有权。

接下来，作者解释了如何使用 **LftL-bor-split** 将完整借用分割为针对不同部分的完整借用，这在处理函数内部的所有权转移时非常重要。然后，通过 **LftL-bor-acc** 规则，展示了如何访问完整借用中的资源，以及在操作完成后如何重新构造完整借用并取回生命周期令牌。

在生命周期结束时，使用了创建生命周期时获得的视图转换，将完整的生命周期令牌交换为死亡令牌 `[†κ]`，并通过继承取回资源的所有权。死亡令牌是持久的，可以多次使用，确保了生命周期结束后资源的安全回收。

此外，作者还讨论了生命周期令牌的分数特性，以及如何防止生命周期同时处于死亡和存活状态。通过这些机制，生命周期逻辑能够准确地模拟 Rust 中的借用规则，确保内存安全和资源的正确管理。

最后，作者介绍了完整借用的其他特性，如存在量词的提取和生命周期的缩短。这些规则进一步丰富了生命周期逻辑的表达能力，使其能够处理更复杂的程序模式。

总体而言，这段内容深入解析了生命周期逻辑在 Iris 框架中的实现和应用，展示了如何形式化地验证 Rust 程序的内存安全性和类型安全性。这为后续章节中更高级的借用形式（如分数借用和原子借用）以及生命周期逻辑的实现细节奠定了基础。
 #  
 Thought for 43 seconds
**概览：**

本段内容来自《Understanding and Evolving the Rust Programming Language》（理解和发展 Rust 编程语言）一书的 **第 11 章：生命周期逻辑（Lifetime Logic）**。在上一节中，作者介绍了 **完整借用（full borrows）** 和 **生命周期令牌（lifetime tokens）**，以及它们在 Iris 框架中对可变引用的建模。

本节 **§11.2** 重点讨论 **生命周期包含（lifetime inclusion）** 的概念，这是 Rust 类型系统中非常重要的部分，用于支持子类型（subtyping）和重新借用（reborrowing）。作者详细解释了如何在生命周期逻辑中定义生命周期的包含关系，以及如何使用它来证明类型系统中的规则。随后，作者讨论了 **生命周期的交集（lifetime intersection）**，以及它如何用于创建新的生命周期和处理嵌套借用。最后，他们介绍了 **分数借用（fractured borrows）**，并解释了它们与生命周期包含的交互，这对于处理某些内部可变类型（如 `RefCell<T>` 或 `RwLock<T>`）至关重要。

**详细解读：**

### **11.2 生命周期包含（Lifetime Inclusion）**

#### **背景**

- 在之前的 **§8.5** 和 **§9** 中，作者讨论了 Rust 如何通过 **生命周期包含** 来关联不同的生命周期。
- **生命周期包含** 用于支持 **子类型（subtyping）**（规则 **T-bor-lft**）和 **重新借用（reborrowing）**（规则 **C-reborrow**）。
#### **定义生命周期包含**

- **目标**：在生命周期逻辑中定义一个生命周期 `κ` 被包含在另一个生命周期 `κ'` 中的含义，即 `κ ⊑ κ'`。
- **关键性质**：**当较短的生命周期 κ 仍然存活时，较长的生命周期 κ' 也必须存活**。**从生命周期令牌的角度**：给定 `κ` 的令牌，我们应该能够获得 `κ'` 的令牌。反之，给定 `κ'` 的死亡令牌 `[†κ']`，我们应该能够获得 `κ` 的死亡令牌 `[†κ]`。
- **形式化定义**：κ \sqsubseteq κ' := \quad  \left( \forall q. \; [κ]_q \; \overset{N_{\text{lft}}}{\Longleftrightarrow} \; q'. \; [κ']_{q'} \right) \quad \ast \quad \left( [†κ'] \equiv-\ast_{N_{\text{lft}}} [†κ] \right)**解释**：****：Iris 中的 **持久性模态（persistence modality）**，确保生命周期包含是一个 **持久的断言**，可以根据需要多次使用。**第一个部分**（令牌转换）：对所有份额 `q`，我们可以 **交换** `κ` 的令牌 `[κ]_q` 和 `κ'` 的令牌 `[κ']_{q'}`。**q'** 可以与 `q` 不同。**≡−∗_{N_{\text{lft}}}**：Iris 中的 **视图转换（view shift）**，在掩码 `N_{\text{lft}}` 下执行。**第二个部分**（死亡令牌转换）：给定 κ' 的死亡令牌 [†κ']，我们可以获得 κ 的死亡令牌 [†κ]。
- **对称访问器（Symmetric Accessors）**：定义了带有绑定器的对称访问器：
$$
Q \overset{E_1 \; E_2}{\Longleftrightarrow} x.\; P(x) := Q \; −∗ \; |V_{E_1 \; E_2} \; \exists x.\; P(x) \ast \left( P(x) \; −∗ \; |V_{E_2 \; E_1} Q \right)
$$
**|V_{E_1 \; E_2}**：Iris 中的 **视图转换**，可能涉及掩码的变化。**解释**：当应用访问器时，客户端会了解到某个证据 `x`，用于构造 `P(x)`。在关闭访问器时，必须使用相同的 `x`。
- **令牌转换的解释**：**第一个部分**表示我们可以交换 `κ` 和 `κ'` 的生命周期令牌。**由于访问器是对称的**，我们也可以反向交换，恢复原始的 `κ` 的令牌。**关键点**：在交换回去时，必须 **放弃整个份额 q'**，无法保留 `κ'` 的部分令牌。**第二个部分**是死亡令牌的对应情况。由于死亡令牌是 **持久的**，无需提供恢复传入的死亡令牌的方法。
#### **性质和规则**

- **持久性**：生命周期包含被包装在 **持久性模态** 中，因此可以根据需要多次使用。
- **预序关系**：**反身性（Reflexivity）**：`κ ⊑ κ`（规则 **LftL-incl-refl**）。**传递性（Transitivity）**：如果 `κ₁ ⊑ κ₂` 且 `κ₂ ⊑ κ₃`，则 `κ₁ ⊑ κ₃`（规则 **LftL-incl-trans**）。
- **应用**：**缩短完整借用（LftL-bor-shorten）**：如果一个完整借用对较长的生命周期有效，那么它对较短的生命周期也应有效。这条规则证明了 λRust 中基于生命周期的子类型化。
- **重新借用（Reborrowing）**：**规则 LftL-reborrow**：用于证明类型系统中的重新借用规则 **C-reborrow**。**区别于缩短**：重新借用提供了一个 **继承（inheritance）**，在较短的生命周期结束后，可以重新获得最初的完整借用。**复杂性**：重新借用的正确建模非常微妙，也是生命周期逻辑模型中大部分复杂性的来源。
### **生命周期的交集（Lifetime Intersection）**

#### **定义**

- **交集 κ ∩ κ'**：给定两个生命周期 `κ` 和 `κ'`，它们的交集是一个在任一操作数结束时就结束的生命周期。
- **性质**：**包含关系**：交集是它的操作数的 **最大下界（greatest lower bound）**。即，`κ ∩ κ' ⊑ κ` 和 `κ ∩ κ' ⊑ κ'`（规则 **LftL-incl-isect**）。
- **用途**：**创建新的子生命周期**：使用规则 **LftL-begin** 创建一个辅助生命周期 `α₀`。定义 `α := κ ∩ α₀`，则根据最大下界的性质，`α ⊑ κ`。在类型系统中，在证明规则 **F-newlft** 时使用这一点，创建一个比所有 `κ` 中的生命周期都短的新生命周期 `α`。
- **处理嵌套借用**：在处理嵌套借用（即对借用的借用）时，生命周期交集也会出现。
#### **与生命周期令牌的交互**

- **令牌的组合**：**规则 LftL-tok-inter**：
$$
[κ ∩ κ']_q ∗−∗ [κ]_q ∗ [κ']_q
$$
交集的令牌由两个操作数的令牌组成，且份额相同。**解释**：交集的生命周期 **只有当两个操作数都存活时** 才存活。
- **死亡令牌**：**规则 LftL-end-inter**：
$$
[†(κ ∩ κ')] ∗−∗ [†κ] \lor [†κ']
$$
交集的生命周期 **在任一操作数结束时** 就结束。
- **证明最大下界**：这些规则允许我们进行令牌的交换，证明交集确实是包含关系 ⊑ 的最大下界。
#### **其他性质**

- **交换性、结合性和可消性**：交集是 **交换的（commutative）**、**结合的（associative）** 和 **可消的（cancellative）**。
- **单位元素 ε**：存在一个特殊的生命周期 `ε`，它 **永不结束**（规则 **LftL-end-unit**）。可以自由地获得任意份额的 `ε` 的令牌（规则 **LftL-tok-unit**）。**用途**：`ε` 用于建模 λRust 的 **静态生命周期**，对应于 Rust 中的 `'static`。
### **11.3 分数借用（Fractured Borrows）**

#### **背景**

- **完整借用** 和 **生命周期** 是在 Iris 中建模临时所有权的强大工具，用于定义 λRust 中 **可变引用** 的语义解释。
- **问题**：它们不能直接用于建模 Rust 的 **共享引用**。
- 在 **§10.4** 中，我们引入了 **分数借用** 的概念，作为定义默认的只读共享谓词的关键部分。
#### **分数借用的规则**

- **主要规则（见图 11.2）**：**LftL-bor-fracture**：将完整借用转换为分数借用。&^{κ}_{\text{full}} Φ(1) ≡−∗_{N_{\text{lft}}} &^{κ}_{\text{frac}} Φ**LftL-fract-shorten**：缩短分数借用的生命周期。κ' \sqsubseteq κ \quad ⇒ \quad &^{κ}_{\text{frac}} Φ \; −∗ \; &^{κ'}_{\text{frac}} Φ**LftL-fract-persist**：分数借用是 **持久的**。\text{persistent}(&^{κ}_{\text{frac}} Φ)**LftL-fract-acc**：访问分数借用的内容。 \left( ∀q_1, q_2.\; Φ(q_1 + q_2) ∗−∗ Φ(q_1) ∗ Φ(q_2) \right) \quad ⇒ \quad &^{κ}_{\text{frac}} Φ \; −∗ \; [κ]_q \; \overset{N_{\text{lft}}}{\Longleftrightarrow} \; q'. \; . Φ(q')**LftL-fract-acc-atomic**：以原子方式访问分数借用。&^{κ}_{\text{frac}} Φ \; −∗ \; \text{True} \; \overset{N_{\text{lft}}, \emptyset}{\Longleftrightarrow} \; (b, q). \; \text{ifthenelse}(b, . Φ(q), [†κ])
#### **解释**

- **关键点**：**分数借用是持久的**，因此可以在多个参与者之间共享。**代价**：访问器较弱，与完整借用相比，分数借用只能提供其内容的一部分（某个份额）。
- **兼容性要求**：**Φ** 是一个关于份额的谓词，必须与加法兼容：
$$
Φ(q_1 + q_2) ∗−∗ Φ(q_1) ∗ Φ(q_2)
$$
**解释**：拥有整个份额的借用意味着拥有 `Φ(1)`，而较小的份额通过分割获得。
- **访问分数借用**：**规则 LftL-fract-acc**：使用分数借用 `&^{κ}_{\text{frac}} Φ`，我们可以获得 `Φ(q')`，其中 `q'` 是未知的份额。**原因**：无论有多少线程同时访问相同的分数借用，总是可以分配一些微小的份额。**需要生命周期令牌 [κ]_q**，证明生命周期 `κ` 仍在进行中。**访问器是非掩码变化的**，因此可以在非原子的、扩展的时间段内保持借用打开。
#### **用途**

- **持久性**：分数借用的持久性对于它们作为 **共享谓词** 的使用至关重要（对应于 **ty-shr-persist**）。
- **缩短生命周期**：需要生命周期缩短规则（**LftL-fract-shorten**）来支持 **ty-shr-mono**。
- **创建分数借用**：通过 **LftL-bor-fracture**，可以将完整借用转换为分数借用。这一规则用于证明 **ty-share**。
### **动态生命周期包含**

#### **分数借用与生命周期包含的交互**

- **情境**：假设我们有一个 **分数借用**，其生命周期为 `κ`，借用了另一个生命周期 `κ'` 的生命周期令牌。即，假设 `Φ(1) = [κ']_q`。为了使 `Φ` 与加法兼容，我们定义：
$$
Φ(q') = [κ']_{q' \cdot q}
$$
**解释**：拥有该借用的全部份额意味着拥有 q 份的 κ' 的令牌；较小的份额通过乘法获得。
- **推导生命周期包含**：**结论**：我们可以推导 `κ ⊑ κ'`。**直觉**：由于 `κ'` 的令牌被借用了到 `κ`，当 `κ` 仍在进行时，无法结束 `κ'`。结束 `κ'` 需要完整的令牌，但部分令牌被锁在 `κ` 中，只能在 `κ` 结束后通过继承取回。
- **证明概述**：**第一部分**：从 `κ` 的令牌 `[κ]_q`，可以获得 `κ'` 的令牌 `[κ']_{q''}`。使用 **LftL-fract-acc**，从分数借用中获取 κ' 的令牌的一部分。**第二部分**：从 `κ'` 的死亡令牌 `[†κ']`，可以获得 `κ` 的死亡令牌 `[†κ]`。使用 **LftL-fract-acc-atomic**，在原子瞬间区分两种情况：如果生命周期 `κ` 已结束，直接获得 `[†κ]`。如果生命周期 `κ` 仍在进行，我们从分数借用中获得 `κ'` 的令牌的一部分，与 `[†κ']` 矛盾。
#### **动态建立生命周期包含**

- **意义**：通过从一个生命周期借用另一个生命周期的令牌，我们可以 **动态地建立额外的生命周期包含**。这对于某些内部可变类型（如 `RefCell<T>` 或 `RwLock<T>`）非常重要，它们允许在无法提前建立的生命周期内共享数据结构。
- **优点**：之前，我们只能通过生命周期交集在预先决定的情况下创建子生命周期。使用分数借用，我们可以在涉及的生命周期已经在进行并被积极使用时，动态地建立生命周期包含。
**全面总结：**

本段内容深入探讨了 **生命周期包含** 和 **分数借用** 在 λRust 类型系统和生命周期逻辑中的关键作用。

首先，作者定义了生命周期包含 `κ ⊑ κ'` 的形式化概念，强调了当较短的生命周期 `κ` 存活时，较长的生命周期 `κ'` 也必须存活。这通过生命周期令牌的转换和死亡令牌的关联来实现，并被包装在 Iris 的持久性模态中，确保其可重复使用。

接着，作者讨论了 **生命周期交集**，即两个生命周期的最大下界。交集的生命周期在任一操作数结束时结束，令牌的组合和死亡令牌的性质也被详细阐述。这为创建新的子生命周期和处理嵌套借用提供了强大的工具。

然后，作者介绍了 **分数借用**，一种持久的借用形式，允许在多个参与者之间共享资源，但只能访问内容的一部分。这对于定义共享引用的语义解释至关重要。通过分数借用的规则，作者展示了如何从完整借用创建分数借用，以及如何访问其内容。

最后，作者解释了分数借用与生命周期包含的动态交互。通过在一个生命周期内借用另一个生命周期的令牌，我们可以动态地建立生命周期包含关系。这对于处理无法提前确定生命周期的内部可变类型非常重要。

总体而言，本段内容深入揭示了 Rust 中生命周期和借用机制的复杂性，以及如何在 Iris 框架中形式化地建模和验证这些概念。通过详细的规则和性质说明，作者为读者提供了理解生命周期逻辑和类型系统健全性的坚实基础。
 #  
 Thought for 52 seconds
**概览：**

这段文字来自《Understanding and Evolving the Rust Programming Language》（理解和发展 Rust 编程语言）一书的 **第 11 章：生命周期逻辑（Lifetime Logic）**，具体是第 11.4 和 11.5 节。作者在前面的章节中已经介绍了 **完整借用（full borrows）** 和 **分数借用（fractured borrows）**，并讨论了它们在 Iris 框架中的实现。这些借用形式用于在 λRust 中建模 Rust 的借用机制，特别是可变引用和共享引用。

本段内容主要介绍了 **原子借用（atomic borrows）** 和 **索引借用（indexed borrows）** 的概念，以及它们在生命周期逻辑中的作用。原子借用是一种结合了持久性和对借用资源的完全访问权限的借用形式，但只能在单个原子瞬间（atomic instant）内访问。索引借用则是一种更底层的机制，允许将完整借用分解为一个无时效性的令牌和一个持久的断言，从而支持更高级的借用形式，如分数借用和原子借用。

作者还讨论了如何在 Iris 中利用这些借用形式来验证像 `Mutex<T>` 和 `RwLock<T>` 这样的 Rust 类型，以及如何通过引入索引借用来统一不同的持久借用形式，并构建一个分层的抽象结构。

**详细解读：**

### **11.4 原子借用（Atomic Borrows）**

#### **背景**

- **持久借用的限制：**在前一节中，作者讨论了 **分数借用（fractured borrows）**，这是一种持久的借用形式，可以在多个参与者之间共享。但是，分数借用只能提供对借用资源的一部分（某个份额）的访问。
#### **原子借用的引入**

- **目的：**引入一种新的借用形式，**原子借用（atomic borrows）**，它结合了分数借用的持久性和完整借用的完全访问权限。**限制：** 原子借用只能在 **单个原子瞬间（atomic instant）** 内访问，无法在较长的时间内保持打开状态。
- **与不变式的类比：**原子借用与 Iris 中的 **不变式（invariants）** 非常相似，都是在某个命名空间内共享资源。**区别：** 原子借用集成在生命周期逻辑中，而不变式是 Iris 的核心概念。
- **应用场景：**原子借用主要用于验证像 Mutex<T> 或 RwLock<T> 这样的 Rust 类型。这些类型是并发同步原语，通常使用不变式来管理共享状态。在本节中，作者介绍如何使用原子借用来替代不变式。
#### **原子借用的基本规则**

- **规则定义：****图 11.3**（在文本中提到）给出了原子借用的基本规则。原子借用的形式为 **&^{κ/N}_{\text{at}} P**，其中：κ 是生命周期。N 是一个 **命名空间（namespace）**，用于确保原子借用不能被多次打开，避免重入（reentrancy）。P 是借用的断言（资源）。
- **规则说明：****创建原子借用（LftL-bor-at）**：可以通过完整借用创建原子借用。**生命周期包含（LftL-at-shorten）**：原子借用遵循与生命周期相关的包含关系，可以缩短生命周期。**访问器（LftL-at-acc-tok）**：给定生命周期令牌的一部分 [κ]_q，我们可以访问借用的全部内容 . P。**注意**：在访问时，我们必须从掩码（mask）中移除命名空间 N，确保访问器必须在同一个原子瞬间内关闭。
- **掩码（Mask）**：**掩码 N_{\text{lft}}, N** 表示 N_{\text{lft}} 和 N 的并集。在 Iris 中，掩码用于控制哪些不变式可以被打开。
#### **原子借用的性质**

- **持久性和完整访问：**原子借用是持久的，可以在多个地方使用。与分数借用不同，原子借用提供对借用资源的完全访问权限。
- **限制：**由于原子借用只能在单个原子瞬间内访问，因此无法在较长的时间内保持借用打开。这与 Iris 中不变式的访问方式相似。
- **避免重入：**命名空间 N 确保了原子借用不能被多次打开，避免了重入问题。
### **11.5 索引借用：统一持久借用（Indexed Borrows: Unifying Persistent Borrowing）**

#### **背景**

- **多种持久借用形式：**已经讨论了两种持久借用形式：**分数借用** 和 **原子借用**。在下一章（§12.3），还将引入第三种持久借用形式：**非原子借用（non-atomic borrows）**。
- **问题：**如果这些借用形式都是“原始的”（primitive），即其正确性直接依赖于 Iris 中的借用模型，这将导致重复和不一致。
- **目标：**希望遵循 Iris 的通常方法，建立一个最小的 **基础生命周期逻辑（base lifetime logic）**，从中可以派生更高级的借用形式。这将构建一个层次化的抽象结构，各层次基于前一层次，形成模块化和可复用的体系。
#### **抽象层次结构**

- **图 11.4**（文本中提到）展示了生命周期逻辑的抽象层次结构：**持久借用形式**：**分数借用（Fractured Borrows）**（图 11.2）。**原子借用（Atomic Borrows）**（图 11.3）。**非原子借用（Non-atomic Borrows）**（图 12.7）。**生命周期逻辑**：**基础组件**：**生命周期令牌（lifetime tokens）**。**生命周期包含（lifetime inclusion）**。**完整借用（full borrows）**。**索引借用（indexed borrows）**（将在本节引入）。**盒子（Boxes）**：**图 11.11**（将在 §11.6 中讨论）展示了生命周期逻辑依赖的另一个抽象层次：盒子。
#### **索引借用的引入**

- **问题：**为了建立分数借用和原子借用等派生的借用原则，需要将借用放入 Iris 的不变式中。但将借用放入不变式需要在借用前添加一个 **. 模态（later modality）**，因为借用不是 **无时效性的（timeless）**。这个额外的 . 模态会阻止我们使用生命周期逻辑的证明规则。
- **解决方案：**引入 **索引借用（indexed borrows）**，允许我们将完整借用拆分为两个部分：一个 **无时效性的令牌（timeless token）** [ \text{Bor} : i ]_1。一个 **持久的命题（persistent proposition）** &^{κ}_{i} P。**规则 LftL-bor-idx**：
&^{κ}_{\text{full}} P ∗−∗ ∃i. \; &^{κ}_{i} P ∗ [ \text{Bor} : i ]_1
- **索引 i 的作用：**用于将令牌和持久命题关联起来，确保它们匹配。
- **实现方式：**将无时效性的令牌 [ \text{Bor} : i ]_1 放入不变式中。持久命题 &^{κ}_{i} P 保持在不变式的外部（由于它是持久的，可以在所有相关方之间共享，就像不变式本身一样）。
- **优势：**通过这种方式，我们可以有效地共享对完整借用的访问，而无需添加 . 模态。**无时效性**允许我们使用 Iris 中的 **|V-timeless** 规则移除 . 模态。
#### **索引借用的性质和规则**

- **直观解释：**&^{κ}_{i} P 表示在生命周期 κ 和索引 i 下，P 是或曾经是被借用的命题。令牌 [ \text{Bor} : i ]_1 表示对该借用的所有权，确保借用仍然存在（例如，未被 LftL-bor-split 分割）。
- **规则（见图 11.5）**：**持久性（LftL-idx-persist）**：\text{persistent}( &^{κ}_{i} P )**无时效性（LftL-idx-timeless）**：
$$
\text{timeless}( [ \text{Bor} : i ]_q )
$$
**等价性（LftL-idx-iff）**：. \; ( P ∗−∗ Q ) \quad ⇒ \quad &^{κ}_{i} P −∗ &^{κ}_{i} Q这里，P 和 Q 是 **持久性模态**下的等价。**生命周期缩短（LftL-idx-shorten）**：κ' ⊑ κ \quad ⇒ \quad &^{κ}_{i} P −∗ &^{κ'}_{i} P**令牌分割（LftL-idx-fract）**：
$$
[ \text{Bor} : i ]_{q + q'} ∗−∗ [ \text{Bor} : i ]_q ∗ [ \text{Bor} : i ]_{q'}
$$
**访问（LftL-idx-acc）**：&^{κ}_{i} P −∗ [ \text{Bor} : i ]_1 ∗ [κ]_q \overset{N_{\text{lft}}}{\Longleftrightarrow} . P这里，我们可以非原子地（non-atomically）访问借用，就像完整借用一样。**原子访问（LftL-idx-acc-atomic）**：&^{κ}_{i} P −∗ [ \text{Bor} : i ]_q \overset{N_{\text{lft}}}{\Longleftrightarrow} \emptyset \; b. \; \text{ifthenelse}(b, . P, [†κ])这里，b 是一个布尔值，用于区分生命周期是否已经结束。**嵌套借用解包（LftL-idx-bor-unnest）**：&^{κ}_{i} P ∗ &^{κ'}_{\text{full}} [ \text{Bor} : i ]_1 ≡−∗_{N_{\text{lft}}} &^{κ ∩ κ'}_{\text{full}} P这条规则用于处理嵌套借用。
#### **应用：定义原子借用**

##### **11.5.1 原子借用**

- **定义原子借用**：&^{κ/N}_{\text{at}} P := ∃i. \; ( N \# N_{\text{lft}} ) ∗ &^{κ}_{i} P ∗ [ \text{Bor} : i ]_1^N \quad (\text{at-bor})**解释**：原子借用是将完整借用的令牌 [ \text{Bor} : i ]_1 放入命名空间为 N 的不变式中。索引借用 &^{κ}_{i} P 保持在不变式外部。N \# N_{\text{lft}} 表示命名空间 N 与 N_{\text{lft}} 是不相交的（disjoint）。
- **推导原子借用的规则**：**持久性（LftL-at-persist）**：由于索引借用是持久的，并且不变式也是持久的，因此原子借用也是持久的。**从完整借用创建原子借用（LftL-bor-at）**：直接使用 LftL-bor-idx 将完整借用转换为索引借用，然后将令牌放入不变式中。**生命周期缩短（LftL-at-shorten）**：由 LftL-idx-shorten 推导而来。**访问器（LftL-at-acc-tok）**：给定生命周期令牌的一部分 [κ]_q，我们可以访问借用的全部内容 . P，但必须在同一个原子瞬间内关闭访问器。
- **证明 LftL-at-acc-tok****目标**：&^{κ/N}_{\text{at}} P ∗ [κ]_q ≡−∗_{N_{\text{lft}}, N} N_{\text{lft}} \; . P ∗ \left( . P ≡−∗_{N_{\text{lft}} N_{\text{lft}}, N} [κ]_q ∗ &^{κ/N}_{\text{at}} P \right)这是展开对称访问器后得到的完整目标。**证明思路**：**展开原子借用**，引入我们的假设。**打开不变式**（位于命名空间 `N` 中），获取完整的（无时效性的）借用令牌 `[ \text{Bor} : i ]_1`。**应用 LftL-idx-acc**，使用索引借用 `&^{κ}_{i} P`，得到 `. P`。由于 N \# N_{\text{lft}}，即使在打开了命名空间 N 的不变式后，我们仍然可以使用生命周期逻辑的证明规则。**证明第一个分离合取的部分**（得到 `. P`）。**关闭访问器**，将剩余的资源用于第二个部分。**先关闭借用**，然后关闭不变式，完成证明。
- **注意事项**：**无法使用 LftL-idx-acc-atomic**：因为它会从我们的掩码中移除 N_{\text{lft}}，但我们需要保持这些不变式可用。**掩码管理**：我们在整个过程中需要仔细管理掩码，确保在打开和关闭不变式和借用时，掩码的一致性。
#### **索引借用的其他应用**

- **分数借用和重新借用**：通过索引借用，我们可以定义分数借用，并推导出 `LftL-fract-acc-atomic`。**重新借用（reborrowing）** 可以通过 `LftL-idx-bor-unnest` 从更底层的推理原则中推导出来。
- **优势**：通过将复杂的借用形式建立在索引借用和生命周期逻辑的基础上，我们实现了借用机制的统一和抽象，避免了重复的原始定义。
**全面总结：**

在这段内容中，作者深入探讨了 **原子借用（atomic borrows）** 和 **索引借用（indexed borrows）** 在生命周期逻辑中的作用，以及它们如何帮助统一和抽象不同的持久借用形式。

首先，作者介绍了 **原子借用**，一种结合了分数借用的持久性和完整借用的完全访问权限的借用形式。原子借用只能在单个原子瞬间内访问，类似于 Iris 中的不变式。通过使用命名空间，原子借用避免了重入问题，并在验证像 `Mutex<T>` 和 `RwLock<T>` 这样的同步原语时发挥重要作用。

接下来，作者引入了 **索引借用**，一种新的借用机制，允许将完整借用拆分为无时效性的令牌和持久的断言。这种机制解决了将借用放入不变式时需要添加 `. `模态的问题，因为借用不是无时效性的。索引借用通过将令牌放入不变式中，并保持持久断言在不变式外部，实现了对完整借用的共享访问，而无需添加额外的模态。

作者还展示了如何使用索引借用来定义原子借用，并推导出原子借用的各种规则。通过详细的证明过程，作者解释了如何在 Iris 中利用索引借用的性质，以及如何管理掩码和命名空间。

最后，作者强调了索引借用在统一持久借用形式中的关键作用。通过将分数借用、原子借用和非原子借用等高级借用形式建立在索引借用和生命周期逻辑的基础上，作者实现了一个模块化、可复用的抽象层次结构。这种方法避免了重复的原始定义，提高了借用机制的灵活性和可扩展性。

总的来说，这段内容深入解析了生命周期逻辑中借用机制的高级概念，展示了如何在 Iris 框架中形式化地验证 Rust 程序的内存安全性和类型安全性。通过引入索引借用，作者为统一和扩展持久借用形式提供了强有力的工具，为后续章节中更复杂的借用形式和证明奠定了基础。
 #  
 Thought for 12 seconds
**概览：**

这段内容来自《Understanding and Evolving the Rust Programming Language》（理解和发展 Rust 编程语言）一书的 **第 11 章：生命周期逻辑（Lifetime Logic）**，具体是 **11.5.2 节：分数借用（Fractured Borrows）**。在前面的章节中，作者已经介绍了完整借用、分数借用和原子借用等概念，以及它们在 Iris 框架中的实现。

本节深入探讨了如何使用 **索引借用（Indexed Borrows）** 来推导分数借用的证明规则。作者展示了分数借用的定义，以及如何利用索引借用和生命周期逻辑的原始规则，推导出分数借用的主要性质和证明规则。此外，他们还详细解释了分数借用与生命周期令牌、借用令牌以及自定义的幽灵（ghost）令牌之间的交互。

通过对分数借用的深入分析，作者展示了如何利用底层的借用机制来构建更高级的借用形式。这对于理解 Rust 中的借用和生命周期机制，以及在 Iris 中形式化验证 Rust 程序的安全性，具有重要意义。

**详细解读：**

### **11.5.2 分数借用**

#### **目标**

- **推导分数借用的证明规则**：目标是从之前定义的生命周期逻辑和索引借用的原始规则中，推导出分数借用的证明规则（如图 11.2 中所示）。
- **方法**：通过定义分数借用的所有权，并利用索引借用的性质，来证明分数借用的各项规则。
#### **分数借用的定义**

分数借用的大致定义如下：

- **分数借用的所有权表示**：分数借用 &^{κ}_{\text{frac}} Φ 定义为存在某个生命周期 κ'，索引 i，以及幽灵名称 γ，使得：κ ⊑ κ'：κ 被包含在 κ' 中。存在某个份额 q_i，我们拥有借用令牌 [ \text{Bor} : i ]_{q_i }。我们拥有索引借用 &^{κ'}_{i} I_{Φ}(κ')。这里，I_{Φ}(κ') 是一个定义在 κ' 上的谓词，形式为：存在某个份额 q，使得：我们拥有 Φ(q)。我们拥有自定义的幽灵令牌 q_{γ}。要么 q = 1，要么我们拥有生命周期令牌 [κ']_{1 - q}。
#### **解释**

- **生命周期包含**：实际的借用生命周期是 κ'，它包含 κ。这用于证明分数借用的生命周期缩短规则（LftL-fract-shorten）。
- **幽灵令牌 γ**：分数借用涉及三种令牌：**借用令牌** [ \text{Bor} : i ]_{q}：用于跟踪借用的所有权。**生命周期令牌** [κ]_{q}：用于证明生命周期 κ 仍在进行中。**自定义的幽灵令牌** q_{γ}：用于避免在证明中需要 Φ(q) ⇒ q ≤ 1 的情况。
#### **分数借用的两个关键组成部分**

1. **不变式中存储借用令牌的份额**：
- 在不变式中，总是包含借用令牌的一部分份额。
- 我们可以打开不变式，取出其中的一部分令牌，然后将剩余部分放回去。
- 这相当于一个“分配器”，我们可以从中获得借用令牌的份额。
- 由此可以得到一个引理，表示存在某个 q_i，使得我们拥有 [ \text{Bor} : i ]_{q_i }。
2. **借用了 Φ 的某个份额 q，以及相同份额的幽灵令牌 q_{γ}**：
- 借用还包含份额 1 - q 的生命周期令牌 [κ']_{1 - q}。
- 这意味着我们拥有的 Φ 的份额和幽灵令牌的份额，与我们拥有的生命周期令牌的份额之和始终为 1。
- 这一设置对于在访问借用时获取 Φ 的份额至关重要，因为我们可以在不同的令牌之间“交换”这些份额。
#### **令牌交换机制**

- **交换规则 1**：拥有 I_{Φ}(κ')、幽灵令牌 q_{γ} 和 Φ(q)，可以换取 I_{Φ}(κ') 和生命周期令牌 [κ']_{q}。直观上，我们用 Φ 的份额和幽灵令牌，换取生命周期令牌的份额。
- **交换规则 2**：拥有 I_{Φ}(κ') 和生命周期令牌 [κ']_{q}，可以换取 I_{Φ}(κ')、某个未知份额 q_0 的幽灵令牌 q_0{γ} 和 Φ(q_0)，以及剩余的生命周期令牌 [κ']_{q - q_0}。这确保了在转换过程中，总是有一部分 Φ 的份额保留在 I_{Φ}(κ') 中。
#### **证明分数借用的规则**

##### **证明 LftL-fract-acc**

- **目标**：从分数借用 &^{κ}_{\text{frac}} Φ 和生命周期令牌 [κ]_{q_κ}，推导出存在某个份额 q_0，使得我们可以获取 . Φ(q_0)，并在关闭时归还生命周期令牌。
- **证明步骤**：**展开分数借用的定义**，得到实际的生命周期 `κ'`，以及 `κ ⊑ κ'`。**使用生命周期包含**，将 `[κ]_{q_κ}` 转换为 `[κ']_{q_{κ'}}`。**利用不变式中的借用令牌分配器**，获取借用令牌的一部分份额 `[ \text{Bor} : i ]_{q_i }`。**使用索引借用的原子访问规则（LftL-idx-acc-atomic）**，打开索引借用 `&^{κ'}_{i} I_{Φ}(κ')`，获得 `. I_{Φ}(κ')`。因为我们拥有生命周期令牌 [κ']_{q_{κ'}}，所以可以排除生命周期已结束的情况。**应用令牌交换规则**，用一部分生命周期令牌换取 `Φ(q_0)` 和幽灵令牌 `q_0{γ}`。这使得我们能够获取所需的 Φ(q_0)。**关闭索引借用**，并归还借用令牌。**完成打开阶段**，成功获取 `Φ(q_0)`，满足第一个分离合取的要求。**处理关闭阶段**，需要证明我们可以归还所有资源，并重新获得 `[κ]_{q_κ}`。反向应用令牌交换规则，将幽灵令牌和 `Φ(q_0)` 换回生命周期令牌的份额。关闭索引借用，归还借用令牌。使用生命周期包含的关闭部分，将 `[κ']_{q_{κ'}}` 转换回 `[κ]_{q_κ}`。
##### **证明 LftL-fract-acc-atomic**

- **过程**：直接应用 `LftL-idx-acc-atomic`。由于分数借用总是包含 `Φ` 的一部分份额，我们可以直接给予客户端访问权限。
- **简化**：不需要在借用内部来回交换令牌。证明相对简单。
##### **证明 LftL-bor-fracture**

- **目标**：从完整借用 &^{κ}_{\text{full}} Φ(1)，推导出分数借用 &^{κ}_{\text{frac}} Φ。
- **步骤**：**引入自定义的幽灵令牌 γ**，其初始值为 1，即我们拥有 `1_{γ}`。**使用增强的借用访问规则**：需要一个更强的 `LftL-bor-acc` 变体，允许我们更改借用的内容，并且不需要拥有任何生命周期令牌。使用 `LftL-bor-acc-atomic-strong`，它类似于 `LftL-idx-acc-atomic`。**在借用中替换内容**：将借用的内容从 `Φ(1)` 更改为 `I_{Φ}(κ')`。需要证明：拥有 `. Φ(1)` 和 `1_{γ}`，可以推导出 `. I_{Φ}(κ')`。拥有 `. I_{Φ}(κ')` 和 `[†κ']`，可以推导出 `. Φ(1)`。**完成证明**：应用索引借用的规则 `LftL-bor-idx`，将完整借用转换为索引借用。将借用令牌放入不变式中，构建分数借用的定义。
#### **额外的证明规则**

- **LftL-bor-exists**：可以通过 `LftL-bor-acc-atomic-strong` 推导。当生命周期 `κ` 仍在进行时，我们可以获取存在量词中的当前值，并冻结它。当生命周期已结束时，我们使用 `LftL-bor-fake` 和 `x` 的定义域非空性完成证明。
- **LftL-bor-merge**：证明了 `LftL-bor-split` 的可逆性。在 §11.7 中将展示这个规则。
**全面总结：**

在这段内容中，作者深入探讨了 **分数借用（Fractured Borrows）** 的定义和证明。他们展示了如何使用之前介绍的 **索引借用（Indexed Borrows）**，结合生命周期逻辑的原始规则，推导出分数借用的主要性质和证明规则。

首先，作者定义了分数借用的所有权，涉及到三个主要的令牌：借用令牌、生命周期令牌和自定义的幽灵令牌。通过引入自定义的幽灵令牌，解决了在证明中需要处理份额的问题，避免了对 `Φ(q) ⇒ q ≤ 1` 的要求。

然后，作者详细解释了分数借用的两个关键组成部分：不变式中存储借用令牌的份额，以及借用了 `Φ` 的某个份额和对应的幽灵令牌。通过令牌交换机制，作者展示了如何在不同的令牌之间交换份额，以实现对 `Φ` 的访问和资源的正确管理。

接下来，作者通过详细的证明过程，展示了如何利用索引借用和生命周期逻辑的原始规则，推导出分数借用的主要证明规则，包括 `LftL-fract-acc`、`LftL-fract-acc-atomic` 和 `LftL-bor-fracture`。在这些证明中，他们巧妙地利用了索引借用的性质、令牌交换机制以及增强的借用访问规则，成功地构建了分数借用的证明框架。

最后，作者提到了额外的证明规则，如 `LftL-bor-exists` 和 `LftL-bor-merge`，进一步丰富了借用机制的理论基础。

总体而言，这段内容深入揭示了分数借用在生命周期逻辑中的实现和证明过程。通过利用索引借用和生命周期逻辑的原始规则，作者成功地推导出了分数借用的主要性质和证明规则，为更高级的借用形式的构建奠定了坚实的基础。这对于理解 Rust 中的借用和生命周期机制，以及在 Iris 中形式化验证 Rust 程序的安全性，具有重要的理论和实践意义。
 #  
 Thought for 19 seconds
**概览：**

这段内容来自《Understanding and Evolving the Rust Programming Language》（理解和发展 Rust 编程语言）一书的 **第 11 章：生命周期逻辑（Lifetime Logic）**，具体是 **11.5.3 节：重新借用和其他派生规则（Reborrowing and Other Derived Rules）**。在前面的章节中，作者已经介绍了完整借用、索引借用、分数借用和原子借用等概念，以及它们在 Iris 框架中的实现。

本节的主要目标是展示如何从生命周期逻辑的基本规则推导出一些重要的证明规则，特别是 **重新借用（Reborrowing）** 的规则，以及其他一些派生的规则。作者解释了这些规则的推导过程，展示了如何利用之前定义的索引借用和生命周期包含等概念，来证明这些规则的正确性。

在此过程中，作者提供了详细的证明草图，解释了每个步骤的逻辑和推理。这对于理解 Rust 中的借用和生命周期机制，以及在 Iris 中形式化验证 Rust 程序的安全性，具有重要意义。

**详细解读：**

### **11.5.3 重新借用和其他派生规则（Reborrowing and Other Derived Rules）**

#### **背景**

- **重新借用（Reborrowing）** 是 Rust 类型系统中的一个重要概念，允许在不违反借用规则的情况下，将一个借用再次借用给其他地方使用。
- 在生命周期逻辑中，我们希望从基本的规则推导出重新借用的证明规则，以及其他一些派生的规则。
- **目标**：展示如何从更原始的规则中推导出 **LftL-reborrow** 等证明规则。
#### **推导其他派生规则**

- **图 11.1** 中的一些证明规则可以从更原始的规则中推导出来：**LftL-incl-isect** 和 **LftL-incl-glb**：这两个规则是 **生命周期包含（Lifetime Inclusion）** 定义的简单推论。**LftL-incl-isect** 表示两个生命周期的交集是它们的最大下界。**LftL-incl-glb** 表示生命周期包含是一个预序关系，具有反身性和传递性。**LftL-bor-acc**：可以通过选择 Q := P，从 **LftL-bor-acc-strong** 推导出来。**LftL-bor-acc** 允许在拥有生命周期令牌的情况下，访问完整借用的内容。**LftL-bor-shorten**：可以从 **LftL-idx-shorten** 推导出来。**LftL-bor-shorten** 表示如果一个完整借用对较长的生命周期有效，那么它对较短的生命周期也有效。
#### **推导重新借用规则（LftL-reborrow）**

**重新借用规则的形式**：
κ' ⊑ κ \quad ∗ \quad &^{κ}_{\text{full}} P \quad ≡−∗_{N_{\text{lft}}} \quad &^{κ'}_{\text{full}} P \quad ∗ \quad \left( [†κ'] ≡−∗_{N_{\text{lft}}} &^{κ}_{\text{full}} P \right)
- **解释**：假设生命周期 κ' 被包含在生命周期 κ 中，且我们拥有对 P 的完整借用 &^{κ}_{\text{full}} P。我们可以获得一个针对较短生命周期 κ' 的完整借用 &^{κ'}_{\text{full}} P，并保留一个继承（inheritance），在 κ' 结束后，可以重新获得最初的完整借用 &^{κ}_{\text{full}} P。
**证明思路**：

- **挑战**：我们可能想直接在生命周期 κ' 上借用 &^{κ}_{\text{full}} P，但这行不通，因为借用需要一个前置的 . 模态（类似于不变式），这会阻碍我们使用生命周期逻辑的证明规则。
- **解决方案**：通过利用 **索引借用（Indexed Borrows）**，将完整借用拆分为持久的和无时效性的部分。我们只在生命周期 κ' 上借用无时效性的部分 [ \text{Bor} : i ]_1。由于令牌是无时效性的，我们可以使用 |V_{\text{timeless}} 来消除 . 模态。
**详细证明步骤**：

1. **将完整借用拆分为索引借用和借用令牌**：
- 使用 **LftL-bor-idx**，将 &^{κ}_{\text{full}} P 转换为 &^{κ}_{i} P 和 [ \text{Bor} : i ]_1。
- &^{κ}_{i} P 是持久的，[ \text{Bor} : i ]_1 是无时效性的。
2. **在生命周期 κ' 上借用借用令牌 [ \text{Bor} : i ]_1**：
- 使用 **LftL-borrow**，在生命周期 κ' 上借用 [ \text{Bor} : i ]_1，得到 &^{κ'}_{\text{full}} [ \text{Bor} : i ]_1。
3. **应用索引借用的嵌套解包规则（LftL-idx-bor-unnest）**：
- 有了 &^{κ}_{i} P 和 &^{κ'}_{\text{full}} [ \text{Bor} : i ]_1，我们可以使用 **LftL-idx-bor-unnest**。
- 该规则允许我们将嵌套的借用 "解嵌套"，得到针对交集生命周期 κ ∩ κ' 的完整借用 &^{κ ∩ κ'}_{\text{full}} P。
4. **缩短生命周期**：
- 使用 **LftL-incl-glb**，我们知道 κ' ⊑ κ ∩ κ'。
- 因此，我们可以将完整借用的生命周期从 κ ∩ κ' 缩短到 κ'，得到 &^{κ'}_{\text{full}} P。
5. **处理继承（Inheritance）**：
- 当我们在生命周期 κ' 上借用 [ \text{Bor} : i ]_1 时，我们获得了一个继承：

$$
[†κ'] ≡−∗_{N_{\text{lft}}} . [ \text{Bor} : i ]_1
$$
- 由于 [ \text{Bor} : i ]_1 是无时效性的，我们可以消除 . 模态。
- 此时，&^{κ}_{i} P 仍然是持久的，我们可以使用 **LftL-bor-idx** 将其与 [ \text{Bor} : i ]_1 重新组合，恢复最初的完整借用 &^{κ}_{\text{full}} P。
**证明草图（见图 11.9）**：

- **第一步**：从假设开始，拥有 κ' ⊑ κ 和 &^{κ}_{\text{full}} P。
- **第二步**：使用 **LftL-bor-idx**，将完整借用拆分为 &^{κ}_{i} P 和 [ \text{Bor} : i ]_1。
- **第三步**：在生命周期 κ' 上借用 [ \text{Bor} : i ]_1，得到 &^{κ'}_{\text{full}} [ \text{Bor} : i ]_1。
- **第四步**：应用 **LftL-idx-bor-unnest**，得到 &^{κ ∩ κ'}_{\text{full}} P。
- **第五步**：使用 **LftL-incl-glb**，将生命周期缩短到 κ'，得到 &^{κ'}_{\text{full}} P。
- **第六步**：利用继承 [†κ'] ≡−∗_{N_{\text{lft}}} . [ \text{Bor} : i ]_1，重新组合 &^{κ}_{i} P 和 [ \text{Bor} : i ]_1，恢复 &^{κ}_{\text{full}} P。
#### **推导完整借用的嵌套解包规则（LftL-bor-unnest）**

- **规则形式**：&^{κ'}_{\text{full}} \; &^{κ}_{\text{full}} P \quad ≡−. ∗_{N_{\text{lft}}} \quad &^{κ' ∩ κ}_{\text{full}} P
- **解释**：这是一个完整借用的嵌套解包规则，允许我们将嵌套的完整借用解开，得到一个针对交集生命周期的完整借用。
- **证明思路**：**将内部的完整借用转换为索引借用**：使用 **LftL-bor-idx**，将内部的 &^{κ}_{\text{full}} P 转换为 &^{κ}_{i} P 和 [ \text{Bor} : i ]_1。**处理外部的完整借用**：现在，我们有 &^{κ'}_{\text{full}} &^{κ}_{i} P 和 &^{κ'}_{\text{full}} [ \text{Bor} : i ]_1。**使用 **LftL-bor-exists** 和 **LftL-bor-split**：由于索引借用是持久的，我们可以使用 **LftL-bor-exists** 和 **LftL-bor-split**，将外部的完整借用拆分为两个部分。**打开外部的借用**：我们可以使用 **LftL-bor-acc-atomic-strong**，在不拥有任何生命周期令牌的情况下，打开外部的完整借用。**获取内部的索引借用**：通过上述步骤，我们可以获得 . &^{κ}_{i} P。**应用索引借用的嵌套解包规则**：使用 **LftL-idx-bor-unnest**，将索引借用和借用令牌重新组合，得到针对交集生命周期的完整借用 &^{κ ∩ κ'}_{\text{full}} P。
- **注意事项**：该规则使用了一个需要 “执行一步”（take a step）的视图转换，即该规则只有在程序也执行了一个计算步骤时才有用。这是因为在证明过程中，我们需要打开借用，这通常对应于程序执行的一步。
#### **总结**

- **推导了重新借用规则（LftL-reborrow）**：通过利用索引借用和生命周期逻辑的原始规则，我们成功地从更基础的规则中推导出了重新借用的证明规则。这展示了索引借用在统一和简化生命周期逻辑中的关键作用。
- **推导了完整借用的嵌套解包规则（LftL-bor-unnest）**：通过将完整借用转换为索引借用，并利用持久性和无时效性的性质，我们能够处理嵌套的完整借用。这为处理更复杂的借用情况提供了理论基础。
- **其他派生规则**：通过从更原始的规则中推导出其他证明规则，我们减少了需要直接证明的原始规则的数量，提高了生命周期逻辑的模块化和可复用性。
**全面总结：**

在这段内容中，作者深入探讨了如何从生命周期逻辑的基本规则推导出 **重新借用（Reborrowing）** 和其他派生的证明规则。他们展示了如何利用 **索引借用（Indexed Borrows）**、**生命周期包含（Lifetime Inclusion）** 以及借用的持久性和无时效性等性质，来证明这些规则的正确性。

首先，作者解释了如何推导一些基本的派生规则，例如 **LftL-incl-isect**、**LftL-incl-glb**、**LftL-bor-acc** 和 **LftL-bor-shorten**，这些规则都是生命周期包含定义的简单推论或从更强的规则中推导而来。

接着，作者详细展示了如何推导 **重新借用规则（LftL-reborrow）**。他们通过将完整借用拆分为索引借用和借用令牌，利用索引借用的持久性和无时效性，在较短的生命周期上重新借用资源。通过应用索引借用的嵌套解包规则和生命周期包含的性质，作者成功地证明了重新借用的正确性。

此外，作者还推导了 **完整借用的嵌套解包规则（LftL-bor-unnest）**，展示了如何处理嵌套的完整借用。这涉及到将完整借用转换为索引借用，打开借用并重新组合资源，以及利用视图转换来处理需要执行一步的证明。

最后，作者强调了索引借用在统一和简化生命周期逻辑中的关键作用。通过从更原始的规则中推导出这些派生规则，减少了需要直接证明的原始规则的数量，提高了生命周期逻辑的模块化和可复用性。这对于理解 Rust 中的借用和生命周期机制，以及在 Iris 中形式化验证 Rust 程序的安全性，具有重要的理论和实践意义。

总的来说，这段内容深入解析了生命周期逻辑中借用机制的高级概念，展示了如何利用索引借用和生命周期包含等工具，从基本规则推导出复杂的证明规则。这为进一步研究和应用生命周期逻辑奠定了坚实的基础，有助于读者更深入地理解 Rust 的类型系统和借用模型。
 #  
 Thought for 32 seconds
**概览：**

本段内容来自《Understanding and Evolving the Rust Programming Language》（理解和发展 Rust 编程语言）一书的 **第 11 章：生命周期逻辑（Lifetime Logic）**，具体是 **11.6 节：实现生命周期逻辑（不含重新借用）**。在之前的章节中，作者已经介绍了 **索引借用（Indexed Borrows）**，并展示了它们如何构成所有持久借用形式的基础，以及如何将高级规则（如 **LftL-reborrow**）化简为更低级的原则。

本节的主要目标是深入探讨 **生命周期令牌（lifetime tokens）**、**索引借用** 和 **完整借用（full borrows）** 如何在 Iris 框架中实现，以及如何验证原始的证明规则（如 **Figure 11.8**、**Figure 11.5** 和 **Figure 11.1** 中尚未推导的部分）。作者选择了一些具有代表性的规则进行详细讨论。

在本节中，作者暂时限制自己在没有重新借用/解嵌（reborrowing/unnesting）的情况下讨论生命周期逻辑。这意味着一些规则（如 **LftL-idx-bor-unnest** 和 **LftL-bor-merge**）在当前的模型中不会成立。这样做的目的是简化模型，因为在没有重新借用的情况下，我们可以将每个生命周期视为完全独立的。作者还提到，在下一节将介绍支持这些缺失部分的模型。

接下来，作者提供了关于 **生命周期（lifetimes）** 和它们的 **借用（borrows）** 如何使用 Iris 的幽灵状态（ghost state）来表示和管理的直觉性解释。这包括了什么是生命周期、生命周期如何表示、它们需要的幽灵状态，以及如何使用资源代数（resource algebras，RA）来管理它们。

**详细解读：**

### **引言**

作者在开始时回顾了之前的内容，说明了 **索引借用（Indexed Borrows）** 是所有持久借用形式的基础，并展示了如何将高级规则（如 **LftL-reborrow**）化简为更低级的原则。在 **Figure 11.4** 中，他们已经处理了最顶层的抽象层次。

现在，作者转向讨论 **生命周期令牌** 以及 **索引借用** 和 **完整借用** 如何在 Iris 中实现，以及如何验证原始的证明规则。他们不会详细讨论每一个证明规则的证明，而是选择一些具有代表性的规则进行深入分析。

为了简化讨论，作者暂时限制自己在没有重新借用/解嵌（reborrowing/unnesting）的情况下讨论生命周期逻辑。这意味着 **LftL-idx-bor-unnest** 规则在当前的模型中不会成立。**LftL-bor-merge** 规则内部依赖于重新借用，因此也不会可用。在下一节，他们将介绍一个支持这些缺失部分的模型。

### **理解生命周期的表示**

**1. 什么是生命周期？**

作者首先提出了一个关键问题：**什么是生命周期 κ？** 这涉及到如何在 Iris 中表示和管理生命周期。

- **原子生命周期（Atomic Lifetimes）**：当使用 **LftL-begin** 规则创建一个新的生命周期时，我们称之为 **原子生命周期**。**表示方式**：用一个唯一的标识符表示（类似于幽灵名称 γ，我们从自然数集合 ℕ 中选择标识符）。
- **生命周期的交集**：为了定义生命周期的交集，作者将 **生命周期** 定义为它所包含的 **原子生命周期** 的多重集（multiset）。**多重集的使用**：多重集允许跟踪一个原子生命周期在一个生命周期中出现的次数。这对于验证 **LftL-tok-inter** 规则是必要的，因为需要知道一个原子生命周期被交集了多少次。**举例**：如果我们有 κ ∩ κ = κ，则 **LftL-tok-inter** 可以用于复制令牌，这将违反令牌的唯一性。因此，使用多重集可以防止这种情况。
**2. 管理生命周期的幽灵状态**

每个生命周期都需要一些幽灵状态来管理它。具体而言，对于每个生命周期，我们需要两个幽灵名称来跟踪：

- **在该生命周期上的借用（borrows）**。
- **当生命周期结束时激活的继承（inheritances）**。
**幽灵状态的分配：**

- 这些幽灵名称是在首次使用复合（非原子）生命周期时按需分配的。
- 为了跟踪这些幽灵名称，我们使用了另一个幽灵状态，即资源代数 **ILft**。
**资源代数 ILft：**

- 定义为：`ILft := Auth(Lft_fin ⇀ Ag(ℕ × ℕ))`。**Auth**：授权元素（authoritative element），用于保持某种全局状态。**Lft_fin**：有限的生命周期集合。**Ag(ℕ × ℕ)**：离散的资源代数，表示两个幽灵名称的对。
- **作用**：将每个生命周期权威性地关联到两个幽灵名称（自然数）。
**参数化：**

- 生命周期逻辑被参数化为一个全局的幽灵名称 γ_i，并将在全局不变式中保持该资源代数的权威元素。
- 表达关于特定生命周期的幽灵名称的知识的碎片是持久的，因此可以自由地共享。
**抽象化：**

- **OwnBor 和 OwnInh**：为了抽象这种间接性，我们引入了 **OwnBor** 和 **OwnInh** 来抽象这种间接访问（见 **Figure 11.10**）。**OwnBor(κ, a)**：表示对生命周期 κ 的借用幽灵状态的所有权。**OwnInh(κ, a)**：表示对生命周期 κ 的继承幽灵状态的所有权。
**3. 表示生命周期令牌和死亡令牌的幽灵状态**

我们还需要一些幽灵状态来表示：

- **生命周期令牌（[κ]_q）**。
- **死亡令牌（[†κ]）**。
**规则 LftL-tok-inter 的启示：**

- 该规则表明，一个复合生命周期的令牌由所有涉及的原子生命周期的令牌组成。
- 因此，我们需要为每个原子生命周期跟踪其是否仍然存活。
**资源代数 ALft：**

- 定义为：`ALft := Auth(ALft_fin ⇀ Frac + ())`。**Auth**：授权元素。**ALft_fin**：有限的原子生命周期集合。**Frac + ()**：分数或单位元素的和。
- **解释**：该资源代数类似于 **一次性资源代数（oneshot RA）**，但没有关于何时发生 "shot" 的数据。**inl(q)**：表示我们拥有分数 q 的令牌，生命周期仍然存活。**inr()**：表示生命周期已经结束的证明，一旦转换到 **inr()**，就无法再返回。
**定义生命周期令牌和死亡令牌：**

- **生命周期令牌 [κ]_q**：
$$
[κ]_q := \bigast_{\Lambda \in κ} \circ [\Lambda \mapsto \text{inl}(q)]_{\gamma_a}
$$
**解释**：为了拥有复合生命周期 κ 的分数 q 的令牌，我们需要拥有每个涉及的原子生命周期的该分数的令牌。**注意**：大的分离合取号（∗）会考虑到多重集中的多重性，因此如果一个原子生命周期 Λ 在 κ 中出现多次，我们也需要多次拥有它的令牌。
- **死亡令牌 [†κ]**：
$$
[†κ] := \exists \Lambda \in κ.\; \circ [\Lambda \mapsto \text{inr}()]_{\gamma_a}
$$
**解释**：要证明复合生命周期 κ 已经结束，只需证明其中任何一个涉及的原子生命周期已经结束。
**全局参数 γ_a：**

- γ_a 表示我们用来管理原子生命周期的幽灵名称。
- 生命周期逻辑的参数包括：γ_i：用于管理生命周期幽灵名称的全局幽灵名称。γ_a：用于管理原子生命周期的全局幽灵名称。N_{\text{lft}}：我们在证明规则中已经看到的命名空间。
**4. 命名空间的划分**

- 生命周期逻辑需要多个不变式，因此我们将 N_{\text{lft}} 分成三个不相交的子命名空间：**N_{\text{mgmt}}**：包含主要的管理不变式。**N_{\text{bor}}**：包含用于管理借用资源的不变式。**N_{\text{inh}}**：包含用于管理继承的不变式。
- 这是可能的，因为在 Iris 中，所有命名空间都可以划分为不相交的部分。
### **全局不变式的结构**

到目前为止，我们已经可以展示所有生命周期逻辑证明规则所假设的全局不变式的结构：

$$
\text{LftLInv} := \exists A, I.\; \bullet A_{\gamma_a} ∗ \bullet I_{\gamma_i} ∗ \bigast_{\kappa \in \text{dom}(I)} \text{LftInv}(A, \kappa)
$$

- **解释**：**A**：跟踪原子生命周期的资源代数的权威元素。**I**：跟踪生命周期幽灵名称的资源代数的权威元素。对于每个生命周期 κ，我们都有一个对应的 **LftInv(A, κ)**。
**上下文 LftLCtx：**

$$
\text{LftLCtx} := \text{LftInv}_{N_{\text{mgmt}}}
$$

- **解释**：所有的规则都是在假设 LftLCtx 在它们的上下文中证明的。
- 在该不变式中，我们维护了生命周期幽灵名称和原子生命周期的权威状态的所有权。其余的内容都由每个生命周期的不变式 **LftInv** 捕获，这是事情变得更加复杂的地方。
### **每个生命周期的不变式（LftInv）**

**高层次的描述：**

- 每个生命周期 κ 可能处于两种可能的状态之一：**存活（Alive）**：所有涉及的原子生命周期 Λ ∈ κ 都是存活的。**已结束（Dead）**：某个涉及的原子生命周期已经结束。
**定义：**

- **生命周期存活的条件**：
$$
\text{LftAliveIn}(A, \kappa) := \forall \Lambda \in \kappa.\; \exists q.\; A(\Lambda) = \text{inl}(q)
$$
**解释**：对于 κ 中的每个原子生命周期 Λ，存在一个分数 q，使得 A(Λ) = \text{inl}(q)，即生命周期仍然存活。
- **生命周期已结束的条件**：
$$
\text{LftDeadIn}(A, \kappa) := \exists \Lambda \in \kappa.\; A(\Lambda) = \text{inr}()
$$
**解释**：存在一个原子生命周期 Λ，使得 A(Λ) = \text{inr}()，即生命周期已经结束。
- **每个生命周期的不变式**：
$$
\text{LftInv}(A, \kappa) := \text{LftAlive}(\kappa) ∗ \text{LftAliveIn}(A, \kappa) \quad \lor \quad \text{LftDead}(\kappa) ∗ \text{LftDeadIn}(A, \kappa)
$$
**解释**：**LftAlive(κ)**：表示生命周期 κ 处于存活状态的断言。**LftDead(κ)**：表示生命周期 κ 已经结束的断言。
**但每个生命周期的不变式到底持有什么资源？**

- **概念**：每个生命周期正在管理一定数量的 **被借用的资源（P_B）**。
- **借用资源的管理**：每次使用 **LftL-borrow** 时，借用的命题 P 被添加到该生命周期的 P_B 中。但是，P_B 并不总是完全由生命周期逻辑拥有，因为用户可以使用 **LftL-bor-acc-strong** 打开借用并将资源 "取出" 生命周期逻辑。这是一个 **非掩码变化的访问器（non-mask-changing accessor）**，因此即使用户持有这些资源，不变式也必须保持。
**模型化的策略：**

- 我们将 `P_B` 表示为在该生命周期借用的所有命题 `P_i` 的分离合取：
$$
P_B = P_0 ∗ P_1 ∗ \dots ∗ P_n
$$
- **借用的逻辑表示**：一个借用逻辑上表示对其中一个片段的所有权。
- **片段的管理**：每个片段当前要么保存在不变式中，要么已经被拥有它的客户端取出。
- **片段的分割和合并**：可以使用规则 **LftL-bor-split**（将一个片段分割成两个）、**LftL-bor-merge**（将两个片段合并为一个）来改变 P_B 的分区。当然，**LftL-borrow**（添加一个新片段）也可以改变 P_B。
**引入盒子（Box）的概念：**

- 为了将生命周期和借用的处理与这些片段的处理分开，我们引入了一个单独的抽象来处理后者：**盒子（Box）** 的概念。
- **优势**：这种分离有助于管理大型的生命周期逻辑证明，将其分解为更小的部分。通过引入盒子，我们可以更好地组织和管理借用资源的分配和归还。
**全面总结：**

在本节中，作者深入探讨了 **生命周期逻辑** 在 Iris 框架中的实现，特别是在没有重新借用的情况下。他们首先强调了索引借用如何构成所有持久借用形式的基础，并展示了如何将高级规则化简为更低级的原则。

为了理解生命周期和借用如何在 Iris 中表示和管理，作者详细解释了 **什么是生命周期**，以及如何使用 **原子生命周期** 的多重集来表示复合生命周期。这种表示方式允许我们跟踪原子生命周期被交集的次数，从而验证 **LftL-tok-inter** 等规则。

接下来，作者介绍了管理生命周期所需的幽灵状态，包括用于跟踪借用和继承的幽灵名称，以及用于表示生命周期令牌和死亡令牌的资源代数。他们引入了 **ILft** 和 **ALft** 两个资源代数，用于权威地管理生命周期和原子生命周期的状态。

为了更好地组织证明，作者将全局不变式结构化，展示了所有生命周期逻辑证明规则所假设的全局不变式的形状。在这个不变式中，他们维护了生命周期幽灵名称和原子生命周期的权威状态的所有权。每个生命周期的不变式 **LftInv** 则捕获了生命周期是存活还是已结束的状态，以及它所管理的借用资源。

最后，作者提出了引入 **盒子（Box）** 概念的必要性，以将生命周期和借用的处理与借用资源片段的管理分开。这种分离有助于管理大型的生命周期逻辑证明，将其分解为更小、更可管理的部分。

总体而言，本节深入探讨了生命周期逻辑在 Iris 框架中的实现细节，包括生命周期的表示、幽灵状态的管理、不变式的结构以及借用资源的管理。通过引入盒子和其他抽象，作者为复杂的生命周期逻辑提供了一个可行的实现方案，为后续章节中更高级的模型和证明奠定了基础。这对于理解 Rust 中的借用和生命周期机制，以及在 Iris 中形式化验证 Rust 程序的安全性，具有重要的理论和实践意义。
 #  
 Thought for 7 seconds
**概览：**

这段内容来自《Understanding and Evolving the Rust Programming Language》（理解和发展 Rust 编程语言）一书的 **第 11 章：生命周期逻辑（Lifetime Logic）**，具体涵盖了 **11.6.1 节：盒子（Boxes）**、**11.6.2 节：控制借用和继承（Controlling Borrows and Inheritances）**，以及 **11.6.3 节：每个生命周期的不变式（The Per-Lifetime Invariant）**。这些部分深入探讨了生命周期逻辑在 Iris 框架中的实现，特别是如何使用 **盒子（Boxes）** 这一抽象来管理借用资源和继承。

在之前的章节中，作者介绍了如何使用 **索引借用（Indexed Borrows）** 来实现持久借用形式，并讨论了生命周期令牌和完整借用的实现。在本节中，作者引入了 **盒子** 这一概念，以更好地管理生命周期内的借用资源。通过详细的定义和规则，作者展示了如何使用盒子来跟踪和控制借用资源的分配和归还，以及如何在生命周期结束时处理继承。

**详细解读：**

### **11.6.1 盒子（Boxes）**

#### **盒子的概念**

- **盒子** 是一个逻辑数据结构，用于管理某个命题 P，并将其划分为多个片段 P_i，满足 P = ∗_{i} P_i，其中 ∗ 表示分离合取（separating conjunction）。
- **目的**：允许我们分别取出和放回每个片段的资源，而无需一次性处理整个命题 P。
- **优势**：当盒子的整体内容 P 是更大协议的一部分时，这种片段化的处理方式非常有用。在生命周期逻辑中，我们有两个盒子（一个用于借用，另一个用于继承），它们的整体内容是相关的。我们需要能够单独取出借用盒子中各个片段的资源。
#### **盒子的证明规则（Figure 11.11）**

- **关键断言**：**Box(N, P, f)**：表示在命名空间 N 中，我们拥有一个盒子，其总资源为 P，并且 f ∈ N_{fin} ⇀ {empty, full} 描述了每个片段的当前状态（empty 或 full）。每个片段由其片段名称 ι ∈ N 标识。**BoxSlice(N, Q, ι)**：表示片段名称为 ι 的片段管理着命题 Q。这个断言是持久的。
#### **基本证明规则**

1. **创建盒子（Box-create）**：
- 初始时，盒子为空，没有任何片段。
- 规则：

$$
\text{True} \; \vdash \; \text{Box}(N, \text{True}, \emptyset)
$$
**解释**：从空的事实开始，我们可以创建一个空的盒子。
2. **插入空的片段（Slice-insert-empty）**：
- 我们可以向盒子中添加一个空的片段，内容为待定的命题 Q。
- 这会将盒子的总资源从 P 更改为 P ∗ Q，并将新的片段名称 ι 添加到片段映射 f 中，状态为 empty。
- 规则：

$$
\stackrel{._{b}}{\text{Box}(N, P, f)} \; \vdash \; \exists ι \notin \text{dom}(f).\; \text{BoxSlice}(N, Q, ι) \; ∗ \; \stackrel{._{b}}{\text{Box}(N, P ∗ Q, f[ι \mapsto \text{empty}])}
$$
**._{b}**：条件的 later 模态（conditional later modality），取决于布尔值 b。
3. **填充片段（Slice-fill）**：
- 将一个空的片段填充为满的片段。
- 消耗片段的命题 Q，并将片段的状态从 empty 更改为 full。
- 规则：

$$
f(ι) = \text{empty} \quad \text{BoxSlice}(N, Q, ι) \vdash \stackrel{._{b}}{Q} ∗ \stackrel{.}{\text{Box}(N, P, f)} \vdash \stackrel{._{b}}{\text{Box}(N, P, f[ι \mapsto \text{full}])}
$$
4. **清空片段（Slice-empty）**：
- 将一个满的片段清空，取回其资源 Q。
- 规则：

$$
f(ι) = \text{full} \quad \text{BoxSlice}(N, Q, ι) \vdash \stackrel{.}{\text{Box}(N, P, f)} \vdash \stackrel{.}{Q} ∗ \stackrel{.}{\text{Box}(N, P, f[ι \mapsto \text{empty}])}
$$
5. **删除空的片段（Slice-delete-empty）**：
- 删除一个状态为 empty 的片段。
- 这会影响盒子的总资源 P，需要更新为 P'，满足 P = P' ∗ Q。
- 规则：

$$
f(ι) = \text{empty} \quad \text{BoxSlice}(N, Q, ι) \vdash \stackrel{._{b}}{\text{Box}(N, P, f)} \vdash \exists P'.\; \stackrel{._{b}}{(\stackrel{.}{P = P' ∗ Q})} ∗ \text{Box}(N, P', f[ι \mapsto \bot])
$$
6. **删除满的片段（Slice-delete-full）**（派生规则）：
- 删除一个状态为 full 的片段，取回其资源 Q。
- 类似于删除空的片段，但会获得 Q。
- 规则：

$$
f(ι) = \text{full} \quad \text{BoxSlice}(N, Q, ι) \vdash \stackrel{._{b}}{\text{Box}(N, P, f)} \vdash \stackrel{.}{Q} ∗ \exists P'.\; \stackrel{._{b}}{(\stackrel{.}{P = P' ∗ Q})} ∗ \text{Box}(N, P', f[ι \mapsto \bot])
$$
7. **填充整个盒子（Box-fill）**：
- 当所有片段都是空的，可以填充整个盒子，提供盒子的总资源 P。
- 规则：

$$
\forall ι \in \text{dom}(f).\; f(ι) = \text{empty} \quad \stackrel{.}{P} ∗ \text{Box}(N, P, f) \vdash \text{Box}(N, P, f[ι \mapsto \text{full} \mid ι \in \text{dom}(f)])
$$
8. **清空整个盒子（Box-empty）**：
- 当所有片段都是满的，可以清空整个盒子，取回盒子的总资源 P。
- 规则：

$$
\forall ι \in \text{dom}(f).\; f(ι) = \text{full} \quad \text{Box}(N, P, f) \vdash \stackrel{.}{P} ∗ \text{Box}(N, P, f[ι \mapsto \text{empty} \mid ι \in \text{dom}(f)])
$$
#### **派生的证明规则**

- **插入满的片段（Slice-insert-full）**：将一个已填充的片段添加到盒子中。规则是通过组合 **Slice-insert-empty** 和 **Slice-fill** 推导出来的。
- **分割片段（Slice-split）**：将一个片段分割为两个新的片段，其内容为原片段的子命题 Q1 和 Q2。规则：

$$
f(ι) = s \quad \text{BoxSlice}(N, Q1 ∗ Q2, ι) \vdash \stackrel{._{b}}{\text{Box}(N, P, f)} \vdash \exists ι_1, ι_2.\; ι_1 \neq ι_2 ∗ \text{BoxSlice}(N, Q1, ι_1) ∗ \text{BoxSlice}(N, Q2, ι_2) ∗ \stackrel{._{b}}{\text{Box}(N, P, f[ι \mapsto \bot][ι_1 \mapsto s][ι_2 \mapsto s])}
$$
**解释**：根据原片段的状态 s（empty 或 full），新片段具有相同的状态。
- **合并片段（Slice-merge）**：将两个具有相同状态的片段合并为一个片段，其内容为两个片段的命题之和。规则：

$$
ι_1 \neq ι_2 \quad f(ι_1) = f(ι_2) = s \quad \text{BoxSlice}(N, Q1, ι_1), \text{BoxSlice}(N, Q2, ι_2) \vdash \stackrel{._{b}}{\text{Box}(N, P, f)} \vdash \exists ι.\; \text{BoxSlice}(N, Q1 ∗ Q2, ι) ∗ \stackrel{._{b}}{\text{Box}(N, P, f[ι_1 \mapsto \bot][ι_2 \mapsto \bot][ι \mapsto s])}
$$
#### **盒子的威力**

- **整体与局部视图的转换**：盒子的强大之处在于它们允许我们在片段级别和整体级别查看和操作资源。**Box-empty** 和 **Box-fill** 规则使我们能够在不知道各个片段贡献的情况下，清空或填充整个盒子。这对于管理借用资源和在生命周期结束时处理继承非常有用。
#### **实现细节**

- **高阶幽灵状态（Higher-order Ghost State）**：在 Iris 中，盒子可以使用高阶幽灵状态实现。实现的细节对于生命周期逻辑本身并不重要，因此在这里不做深入讨论。
### **11.6.2 控制借用和继承（Controlling Borrows and Inheritances）**

#### **借用的管理**

- **借用盒子的使用**：在拥有盒子这一工具后，我们可以描述一个存活的生命周期：有一个命题 P_B 描述在该生命周期上借用的所有资源。不变式维护了一个总资源为 P_B 的盒子。使用幽灵状态来跟踪盒子的片段，并将这些幽灵状态分发给客户端。
- **借用的定义**：**借用令牌**和**索引借用**的定义如下：**借用令牌**：

$$
[\text{Bor} : (\kappa_0, ι)]_q := \text{OwnBor}(\kappa_0, \circ (ι \mapsto (\text{in}, q)))
$$
**解释**：借用令牌表示对生命周期 κ_0 的借用状态的所有权，其中片段 ι 的状态为 in，拥有分数 q。**索引借用**：
&^{\kappa}_{(\kappa_0, ι)} P := \kappa \sqsubseteq \kappa_0 ∗ \text{BoxSlice}(N_{\text{bor}}, P, ι)**解释**：索引借用表示片段 ι 管理着命题 P，并且可见的生命周期 κ 是实际存储借用的生命周期 κ_0 的子生命周期。
- **完整借用的定义**：引入了内部的辅助概念 **RawBor**（原始借用）：

$$
\text{RawBor}(\kappa, P) := \exists ι.\; \text{BoxSlice}(N_{\text{bor}}, P, ι) ∗ \text{OwnBor}(\kappa, \circ (ι \mapsto (\text{in}, 1)))
$$
**解释**：原始借用表示存在一个片段 ι，其内容为 P，并且我们完全拥有该片段（分数为 1）。**完整借用**：
&^{\kappa}_{\text{full}} P := \exists \kappa_0.\; \kappa \sqsubseteq \kappa_0 ∗ \text{RawBor}(\kappa_0, P)**解释**：完整借用量化了一个比 κ 更大的生命周期 κ_0，这有助于证明生命周期缩短规则（LftL-bor-shorten）。
#### **继承的管理**

- **继承的定义**：在借用时，规则 **LftL-borrow** 提供了一个继承：

$$
[†\kappa] ≡−∗_{N_{\text{lft}}} . P
$$
**继承盒子**：类似于借用盒子，生命周期还包含一个 **继承盒子**。继承盒子的片段由第二个生命周期幽灵状态 **OwnInh** 管理。**继承盒子的协议**：继承一旦被声明，就不能再被使用。因此，我们只需要一个每个继承的令牌，表示对继承盒子中相应片段的所有权。
- **借用盒子和继承盒子的关系**：初始时，继承盒子的总内容 P_I 与借用盒子的总内容 P_B 相同。由于客户端可以通过 **LftL-bor-acc-strong** 更改借用的命题（即改变借用盒子中的片段），但无法调整继承盒子。因此，我们维护了一个关系 P_B −∗ P_I。
- **生命周期结束时的处理**：当生命周期结束时，我们需要确保借用盒子的所有片段都是满的。使用 **Box-empty** 规则，可以清空整个借用盒子，获得 P_B 的所有权。然后，使用之前的关系，将 P_B 转换为 P_I。最后，使用 **Box-fill** 规则，填充整个继承盒子。之后，继承盒子的片段由 **OwnInh** 控制，而借用盒子则为空。
### **11.6.3 每个生命周期的不变式（The Per-Lifetime Invariant）**

#### **总览**

- **目标**：现在，我们可以详细查看 **每个生命周期的不变式** 的正式定义（见 **Figure 11.12**）。
- **注意**：这是不支持重新借用的简化版本（即 **LftL-idx-bor-unnest** 规则不成立）。
#### **不变式的组成部分**

1. **借用的定义**（重复）：
- **借用令牌**和**索引借用**的定义与前一节相同。
2. **不变式的整体结构**：
- **LftLInv**：全局不变式，包含了所有生命周期的状态。

$$
\text{LftLInv} := \exists A, I.\; \bullet A_{\gamma_a} ∗ \bullet I_{\gamma_i} ∗ \bigast_{\kappa \in \text{dom}(I)} \text{LftInv}(A, \kappa)
$$
**A**：跟踪原子生命周期的状态。**I**：跟踪生命周期的幽灵名称。**LftInv(A, κ)**：每个生命周期的不变式。
#### **生命周期的状态**

1. **已结束的生命周期（Dead Lifetime）**：
- **LftDead**：表示生命周期已结束。

$$
\text{LftDead}(\kappa) := \exists P_I.\; \text{LftBorDead}(\kappa) ∗ \text{LftInh}(\kappa, P_I, \text{full})
$$
- **LftBorDead**：管理借用盒子在生命周期结束时的状态。借用盒子仍然存在，但其片段都是空的，资源已被清空。
- **LftInh**：管理继承盒子，所有片段都是满的，表示继承已被激活。
2. **存活的生命周期（Alive Lifetime）**：
- **LftAlive**：表示生命周期仍然存活。

$$
\text{LftAlive}(\kappa) := \exists P_B, P_I.\; \text{LftBorAlive}(\kappa, P_B) ∗ \text{LftVs}(\kappa, P_B, P_I) ∗ \text{LftInh}(\kappa, P_I, \text{empty})
$$
- **LftBorAlive**：管理借用盒子在生命周期存活时的状态。跟踪每个借用的状态（in 或 open(q)）。使用幽灵状态 **OwnBor** 来同步借用的状态。**LftBorDeposit**：为每个打开的借用声明了一个 "押金"，以对应的生命周期令牌的分数形式表示。
- **LftVs**：管理借用盒子和继承盒子之间的关系。提供了一个视图转换，将所有的借用资源转换为继承资源，前提是生命周期已结束。
- **LftInh**：管理继承盒子，在生命周期存活时，所有片段都是空的。
#### **不变式的定义**

- **LftInv(A, κ)**：根据生命周期的状态，选择相应的组件：

$$
\text{LftInv}(A, \kappa) := \text{LftAlive}(\kappa) ∗ \text{LftAliveIn}(A, \kappa) \quad \lor \quad \text{LftDead}(\kappa) ∗ \text{LftDeadIn}(A, \kappa)
$$
**LftAliveIn(A, κ)**：表示生命周期 κ 的所有原子生命周期都存活。**LftDeadIn(A, κ)**：表示生命周期 κ 的某个原子生命周期已结束。
#### **总结**

- **借用和继承的管理**：借用盒子和继承盒子分别管理借用资源和继承资源。在生命周期存活时，借用盒子的片段可能是满的或空的，取决于借用的状态；继承盒子的片段都是空的。在生命周期结束时，借用盒子的片段都是空的，继承盒子的片段都是满的。
- **幽灵状态的同步**：使用幽灵状态 **OwnBor** 和 **OwnInh** 来同步借用和继承的状态。**LftBorAlive** 和 **LftInh** 通过幽灵状态确保盒子的片段状态与借用和继承的实际情况一致。
- **不变式的维护**：全局不变式 **LftLInv** 保证了生命周期逻辑的正确性。每个生命周期的不变式 **LftInv(A, κ)** 详细描述了生命周期的状态和资源管理。
**全面总结：**

在这段内容中，作者深入探讨了 **盒子（Boxes）** 在生命周期逻辑中的作用，以及如何使用盒子来管理借用资源和继承。他们首先引入了盒子的概念，定义了盒子的关键断言和一系列证明规则。盒子允许我们将资源划分为多个片段，分别进行操作，这对于复杂的借用和资源管理非常有用。

接着，作者详细说明了如何使用盒子来控制借用和继承。借用盒子用于管理生命周期内的借用资源，每个借用对应一个片段。继承盒子用于在生命周期结束时处理继承的资源。通过幽灵状态 **OwnBor** 和 **OwnInh**，我们可以同步借用和继承的状态，确保资源的正确管理。

最后，作者提供了每个生命周期的不变式的正式定义，包括存活和已结束两种状态下的不变式结构。他们解释了如何使用盒子和幽灵状态来维护不变式，以及如何在生命周期结束时从借用盒子转换到继承盒子。全局不变式 **LftLInv** 保证了整个生命周期逻辑的正确性。

总体而言，这段内容深入解析了生命周期逻辑在 Iris 框架中的实现细节，展示了如何使用盒子和幽灵状态来管理复杂的借用和资源分配问题。通过引入盒子这一抽象，作者有效地组织和简化了生命周期逻辑的证明和实现，为理解 Rust 中的借用和生命周期机制，以及在 Iris 中形式化验证 Rust 程序的安全性，提供了重要的理论和实践指导。
 #  
 Thought for 9 seconds
**概览：**

这段内容来自《Understanding and Evolving the Rust Programming Language》（理解和发展 Rust 编程语言）一书的 **第 11 章：生命周期逻辑（Lifetime Logic）**，具体是 **11.6.4 节：生命周期逻辑证明（Lifetime Logic Proofs）**。在之前的章节中，作者已经详细介绍了生命周期逻辑的各种定义，包括生命周期（lifetime）、借用（borrow）、盒子（box）、幽灵状态（ghost state）以及相关的不变式（invariants）。他们构建了一个模型来表示 Rust 中的生命周期和借用机制，但暂时没有支持重新借用（reborrowing）和解嵌（unnesting）。

本节的主要目标是基于之前建立的模型，证明生命周期逻辑中的各种规则。作者提供了对这些规则的证明的高层次直觉，并通过一些关键规则的证明草图，展示了如何利用之前的定义和不变式来证明生命周期逻辑的正确性。这些规则包括处理生命周期令牌的规则（如 **LftL-begin**）、创建借用的规则（如 **LftL-borrow**）、访问借用的规则（如 **LftL-bor-acc-strong**）等。

在此过程中，作者还解释了为什么某些规则（如 **LftL-idx-bor-unnest**）在当前的模型中不成立，并指出需要对模型进行一些基本的更改，以支持这些规则。

**详细解读：**

### **11.6.4 生命周期逻辑证明（Lifetime Logic Proofs）**

#### **引言**

在之前的章节中，作者已经为生命周期逻辑建立了所有的定义和不变式。在本节中，他们将基于这些定义，证明生命周期逻辑中的各种规则。他们将为读者提供对这些证明的高层次直觉，并通过一些关键规则的证明草图，展示证明的具体过程。

#### **处理生命周期令牌的规则**

首先，作者提到了处理生命周期令牌的规则，包括：

- **LftL-tok-timeless**
- **LftL-end-persist**
- **LftL-tok-fract**
- **LftL-tok-inter**
- **LftL-end-inter**
- **LftL-tok-unit**
- **LftL-end-unit**
- **LftL-not-own-end**
**证明难度**：

- 这些规则基于作者为生命周期令牌（lifetime tokens）和死亡令牌（dead tokens）所选择的底层模型，证明起来相对简单，属于“平凡的”证明。
#### **证明 LftL-begin 规则**

**规则形式**：

$$
\text{LftL-begin} \quad \quad \text{True} \; ≡−∗_{N_{\text{lft}}} \; \exists κ.\; [κ]_1 ∗ \left( [κ]_1 ≡−. ∗_{N_{\text{lft}}} [†κ] \right)
$$

**解释**：

- **目标**：分配一个新的原子生命周期，并获得其完整的生命周期令牌 [κ]_1。
- **此外**：还需要证明一个视图转换（view shift），即在执行一步（takes a step）后，可以将生命周期令牌 [κ]_1 转换为死亡令牌 [†κ]。
**证明步骤**：

1. **打开生命周期不变式**：
- 首先，我们打开生命周期逻辑的不变式 LftLInv，以便在证明中使用其中的资源和状态。
2. **选择新的原子生命周期**：
- 选择一个新的原子生命周期 Λ，确保它不在当前的 A 中（即 Λ ∉ A）。
- 将 Λ 添加到权威的幽灵状态中，并获得其完整的生命周期令牌的所有权。
3. **关闭不变式**：
- 在关闭不变式时，需要证明将新的元素添加到 A 不会影响 LftAliveIn(A, _) 或 LftDeadIn(A, _)，这相对简单。
4. **定义生命周期 κ**：
- 将 κ 定义为包含单个原子生命周期 Λ 的集合，即 κ := {Λ}。
- 我们已经拥有了该生命周期的令牌 [κ]_1。
5. **证明视图转换**：
- 需要证明一个在执行一步后（takes a step）的视图转换：
$$
[κ]_1 ≡−. ∗_{N_{\text{lft}}} [†κ]
$$
- 这意味着在执行一步后，我们可以将生命周期令牌转换为死亡令牌。
6. **处理非平凡的部分**：
- 打开生命周期逻辑的不变式 `LftLInv`，利用执行一步的视图转换，可以移除假设中的 `. `模态。
- 需要证明：
$$
\text{LftLInv} ∗ [κ]_1 ≡−∗_{N_{\text{lft}} \setminus N_{\text{mgmt}}} \text{LftLInv} ∗ [†κ]
$$
**解释**：在不变式中，我们需要将 Λ 的状态从 inl(q)（表示生命周期存活）更改为 inr()（表示生命周期结束）。由于我们拥有完整的令牌 [κ]_1，可以执行这个状态转换，并获得死亡令牌 [†κ]。
7. **更新相关的生命周期状态**：
- 我们需要遍历所有注册在 `I` 中的生命周期 `κ`，如果其中任何一个仍然存活且包含 `Λ ∈ κ`，我们需要将其状态从 “存活” 更改为 “已结束”。
- 这个过程需要证明以下引理：
$$
\text{LftAlive}(κ) ∗ [†\{Λ\}] ∗ Λ ∈ κ ≡−∗_{N_{\text{lft}} \setminus N_{\text{mgmt}}} \text{LftDead}(κ)
$$
- **解释**：如果生命周期 `κ` 包含 `Λ`，并且我们已经证明了 `Λ` 已经结束，那么 `κ` 也必须结束。
8. **处理借用盒子（Borrow Box）**：
- 需要清空借用盒子，这是通过以下引理实现的：
$$
\text{LftBorAlive}(κ, P_B) ∗ [†\{Λ\}] ∗ Λ ∈ κ ≡−∗_{N_{\text{lft}} \setminus N_{\text{mgmt}}} \text{LftBorDead}(κ) ∗ . P_B
$$
- **解释**：使用 **Box-empty** 规则，我们可以清空借用盒子，并获得其总资源 . P_B。需要证明借用盒子的所有片段都是满的，即所有借用的状态都是 in。如果有任何借用处于 open(q) 状态，我们会拥有 [κ]_q，但这与我们拥有的死亡令牌 [†κ] 矛盾（根据 **LftL-not-own-end**），因此所有借用必须处于 in 状态。
9. **处理继承盒子（Inheritance Box）**：
- 使用 **LftVs**，我们将 `. P_B` 转换为 `. P_I`，这需要 `[†κ]`。
- 然后，使用以下步骤填充继承盒子：
$$
\text{LftInh}(κ, P_I, \text{empty}) ∗ . P_I ≡−∗_{N_{\text{lft}} \setminus N_{\text{mgmt}}} \text{LftInh}(κ, P_I, \text{full})
$$
- **解释**：使用 **Box-fill** 规则，我们可以填充继承盒子，因为所有片段最初都是空的。
10. **完成证明**：
- 通过上述步骤，我们成功地将生命周期 κ 的状态从 “存活” 转换为 “已结束”，并正确地处理了借用盒子和继承盒子的资源。
- 这完成了 **LftL-begin** 规则的证明。
#### **证明 LftL-borrow 规则**

**规则形式**：
\text{LftL-borrow} \quad \quad . P ≡−∗_{N_{\text{lft}}} &^{κ}_{\text{full}} P ∗ \left( [†κ] ≡−∗_{N_{\text{lft}}} . P \right)
**解释**：

- **目标**：从资源 . P 出发，我们希望创建一个完整的借用 &^{κ}_{\text{full}} P，并获得一个继承（当生命周期结束时，可以取回 . P）。
**证明步骤**：

1. **打开生命周期逻辑不变式**：
- 需要获取 LftInv(A, κ)，但生命周期 κ 可能尚未在 I 中注册。
- 如果 κ 不存在，我们需要创建它。
2. **初始化新的生命周期**：
- 创建一个空的借用盒子和一个空的继承盒子，设置 P_B := \text{True} 和 P_I := \text{True}。
- 借用状态 B 和继承状态 E 初始都是空的。
3. **处理生命周期的状态**：
- 利用以下事实：
$$
∀ A, κ.\; \text{LftAliveIn}(A, κ) ∨ \text{LftDeadIn}(A, κ) ∨ \left( ∃ Λ ∈ κ.\; Λ ∉ \text{dom}(A) \right)
$$
**解释**：每个生命周期 κ 要么是存活的，要么是已结束的，要么包含未被管理的原子生命周期。如果 κ 是存活的或已结束的，我们可以相应地处理。如果 κ 包含未被管理的原子生命周期 Λ，我们可以将 Λ 添加到 A 中，并将其标记为已结束。
4. **假设 κ 是存活的**：
- 我们假设 κ 是存活的，并且 κ ∈ \text{dom}(I)。
5. **引入原始借用（Raw Borrow）**：
- 注意到 `\text{RawBor}(κ, P) ≡−∗ &^{κ}_{\text{full}} P`，因此我们只需证明：
$$
. \text{LftInv}(κ) ∗ . P ≡−∗_{N_{\text{lft}} \setminus N_{\text{mgmt}}} . \text{LftInv}(κ) ∗ \text{RawBor}(κ, P) ∗ \left( [†κ] ≡−∗_{N_{\text{lft}}} . P \right)
$$
6. **处理生命周期已结束的情况**：
- 如果 `κ` 已经结束，我们需要 “伪造” 一个借用，同时保留 `. P`：
$$
. \text{LftBorDead}(κ) ≡−∗_{N_{\text{lft}} \setminus N_{\text{mgmt}}} . \text{LftBorDead}(κ) ∗ \text{RawBor}(κ, P)
$$
**解释**：由于生命周期已结束，我们不能实际创建新的借用，但可以在不改变状态的情况下添加一个空的片段。我们仍然保留 . P，因此继承变得平凡。
7. **处理生命周期存活的情况**：
- 我们需要添加一个新的借用片段到借用盒子中，并相应地更新幽灵状态 `B`。
- **引理**：添加借用片段到借用盒子：
$$
. \text{LftBorAlive}(κ, P_B) ∗ . P ≡−∗_{N_{\text{lft}} \setminus N_{\text{mgmt}}} . \text{LftBorAlive}(κ, P_B ∗ P) ∗ \text{RawBor}(κ, P)
$$
使用 **Slice-insert-full** 规则，将新的片段添加到借用盒子中。更新幽灵状态 B，添加新的借用状态 in。
- **添加继承片段到继承盒子**：
$$
. \text{LftInh}(κ, P_I, \text{empty}) ≡−∗_{N_{\text{lft}} \setminus N_{\text{mgmt}}} . \text{LftInh}(κ, P_I ∗ P, \text{empty}) ∗ \exists ι.\; \text{OwnInh}(κ, \circ \{ι\}) ∗ \text{BoxSlice}(N_{\text{inh}}, P, ι)
$$
使用 **Slice-insert-empty** 规则，添加一个新的空片段到继承盒子中。
- **更新 LftVs**：由于我们更改了 `P_B` 和 `P_I`，需要重新证明 `LftVs`，即借用盒子和继承盒子之间的关系：
$$
. \text{LftVs}(κ, P_B, P_I) −∗ . \text{LftVs}(κ, P_B ∗ P, P_I ∗ P)
$$
8. **完成借用的创建**：
- 重新建立 . \text{LftInv}(κ)，并已经获得了 \text{RawBor}(κ, P)。
- 剩下的任务是证明当生命周期结束时，我们可以取回 . P。
9. **处理继承**：
- 利用我们在添加继承片段时留下的资源，需要证明：
$$
\text{OwnInh}(κ, \circ \{ι\}) ∗ \text{BoxSlice}(N_{\text{inh}}, P, ι) ∗ [†κ] ≡−∗_{N_{\text{lft}}} . P
$$
- **步骤**：打开生命周期逻辑不变式，证明生命周期已结束（因为我们拥有 [†κ]）。展开 . \text{LftInh}(κ, P_I, \text{full})，获得继承盒子的权威所有权。使用 **Slice-delete-full** 规则，删除对应的片段，获得 . P。更新幽灵状态 E，从中删除片段 ι。
10. **完成证明**：
- 通过上述步骤，我们成功地创建了一个完整的借用，并证明了在生命周期结束时，可以取回 . P。
#### **证明 LftL-bor-acc-strong 规则**

**规则形式**：
&^{κ}_{\text{full}} P ∗ [κ]_q ≡−∗_{N_{\text{lft}}} . P ∗ \left( \forall Q.\; . (. Q ∗ [†κ] ≡−∗_{∅} . P) ∗ . Q ≡−∗_{N_{\text{lft}}} &^{κ}_{\text{full}} Q ∗ [κ]_q \right)
**解释**：

- **目标**：打开完整借用 &^{κ}_{\text{full}} P，获取资源 . P，然后在可能修改内容后，重新关闭借用，恢复 &^{κ}_{\text{full}} Q。
**证明步骤**：

1. **引入原始借用的变体**：
- 为了简化，我们证明原始借用的一个变体：
$$
\text{RawBor}(κ, P) ∗ [κ]_q ≡−∗_{N_{\text{lft}}} . P ∗ \left( \forall Q.\; . (. Q ∗ [†κ] ≡−∗_{∅} . P) ∗ . Q ≡−∗_{N_{\text{lft}}} \text{RawBor}(κ, Q) ∗ [κ]_q \right)
$$
- **解释**：打开原始借用，获取 `. P`，然后在提供了一个从 `Q` 到 `P` 的视图转换后，重新关闭借用，可能更改借用的内容。
2. **打开借用（Opening the Borrow）**：
- **引理**：打开原始借用：
$$
\text{BoxSlice}(N_{\text{bor}}, P, ι) ∗ \text{OwnBor}(κ, \circ (ι \mapsto (\text{in}, 1))) ∗ [κ]_q ≡−∗_{N_{\text{lft}}} \text{OwnBor}(κ, \circ (ι \mapsto (\text{open}(q), 1))) ∗ . P
$$
- **解释**：我们改变借用状态，从 `in` 变为 `open(q)`，表示资源已被取出，同时我们放弃 `[κ]_q`。
- **步骤**：打开生命周期逻辑不变式。由于拥有 \text{OwnBor}(κ, \circ (ι \mapsto (\text{in}, 1)))，可以获得借用盒子的状态 B(ι) = \text{in}。使用 **Slice-empty** 规则，取出片段的资源 . P。更新幽灵状态 B，将借用状态更改为 \text{open}(q)。放弃生命周期令牌的分数 [κ]_q，以匹配新的借用状态。
3. **关闭借用（Closing the Borrow）**：
- **引理**：关闭原始借用：
$$
. (. Q ∗ [†κ] ≡−∗_{∅} . P) ∗ . Q ∗ \text{BoxSlice}(N_{\text{bor}}, P, ι) ∗ \text{OwnBor}(κ, \circ (ι \mapsto (\text{open}(q), 1))) ≡−∗_{N_{\text{lft}}} \exists ι'.\; \text{BoxSlice}(N_{\text{bor}}, Q, ι') ∗ \text{OwnBor}(κ, \circ (ι' \mapsto (\text{in}, 1))) ∗ [κ]_q
$$
- **解释**：我们需要将借用的内容从 `P` 更改为 `Q`，并恢复借用状态为 `in`，同时取回生命周期令牌的分数 `[κ]_q`。
- **步骤**：打开生命周期逻辑不变式。确保生命周期 κ 仍然存活，否则会与借用状态矛盾。使用 **Slice-delete-empty**，删除状态为 \text{open}(q) 的片段 ι。使用 **Slice-insert-full**，添加一个新的片段 ι'，内容为 Q，状态为 in。更新幽灵状态 B，移除 ι，添加 ι'，并将借用状态恢复为 in。重新证明 LftBorDeposit，由于我们关闭了一个状态为 \text{open}(q) 的借用，取回生命周期令牌的分数 [κ]_q。
- **处理 LftVs 的更新**：由于更改了借用盒子的内容，需要更新 `LftVs`，即借用盒子和继承盒子之间的关系。需要证明：
$$
. \text{LftVs}(κ, P_B, P_I) ∗ . .(P_B = P_B' ∗ P) ∗ . (. Q ∗ [†κ] ≡−∗_{∅} . P) −∗ . \text{LftVs}(κ, P_B' ∗ Q, P_I)
$$
**解释**：我们将 `P_B` 中的 `P` 替换为 `Q`，并利用提供的视图转换，将 `Q` 转换回 `P`，以保持与 `P_I` 的关系。
- **完成证明**：通过上述步骤，我们成功地关闭了借用，恢复了 \text{RawBor}(κ, Q)，并取回了生命周期令牌的分数 [κ]_q。
#### **其余规则的证明**

- **LftL-bor-fake**：利用之前在证明 **LftL-borrow** 时使用的 “伪造” 技巧，可以轻松证明 **LftL-bor-fake**。
- **LftL-bor-split**：使用 **Slice-split** 规则，将借用盒子中的片段分割成两个新的片段。需要更新管理 B 的权威状态，但我们拥有所有需要的令牌，可以执行此操作。
- **LftL-bor-acc-atomic-strong**：类似于 **LftL-bor-acc-strong**，但由于生命周期逻辑的不变式在打开和关闭借用之间从未关闭，因此不需要留下任何令牌作为押金。
- **LftL-bor-shorten**：由于完整借用的定义方式，证明起来相对简单。
#### **索引借用的证明规则**

- **LftL-bor-idx**、**LftL-idx-persist**、**LftL-idx-timeless**、**LftL-idx-fract**、**LftL-idx-shorten**：这些规则是索引借用和借用令牌定义的直接结果，证明起来比较容易。
- **LftL-idx-acc**：类似于 **LftL-bor-acc-strong**，但在关闭时，我们使用 **Slice-fill** 重新填充现有的片段，而不是删除并添加一个新的片段。
- **LftL-idx-acc-atomic**：是 **LftL-bor-acc-atomic-strong** 的更简单变体。
#### **关键的剩余规则**

- **LftL-idx-bor-unnest**：该规则在当前的模型中并不成立。为了使该规则成立，需要对模型进行一些基本的更改。
**全面总结：**

在本节中，作者详细阐述了生命周期逻辑中各个规则的证明，展示了如何利用之前建立的模型和不变式，证明生命周期令牌、借用和继承的各种操作的正确性。

首先，作者提到了处理生命周期令牌的基本规则，这些规则基于底层模型，证明起来相对简单。接着，作者深入证明了 **LftL-begin** 规则，即如何分配新的原子生命周期，并在执行一步后，将生命周期令牌转换为死亡令牌。在这个过程中，他们展示了如何打开和关闭生命周期逻辑的不变式，以及如何更新生命周期的状态和相关的幽灵状态。

然后，作者详细证明了 **LftL-borrow** 规则，即如何创建一个新的借用，以及如何在生命周期结束时，取回借用的资源。他们展示了在生命周期存活和已结束的情况下，如何分别处理借用的创建，以及如何管理借用盒子和继承盒子的资源。

接下来，作者证明了 **LftL-bor-acc-strong** 规则，即如何打开和关闭一个完整的借用，包括可能更改借用的内容。他们引入了原始借用的变体，并详细解释了在打开和关闭借用时，如何更新借用的状态、幽灵状态和生命周期令牌的所有权。

此外，作者还提到了其他规则的证明，包括 **LftL-bor-fake**、**LftL-bor-split**、**LftL-bor-acc-atomic-strong**、**LftL-bor-shorten**，以及索引借用的规则。这些规则的证明基于之前的定义和规则，证明起来相对简单。

最后，作者指出了一些在当前模型中不成立的规则，如 **LftL-idx-bor-unnest**，并强调需要对模型进行一些基本的更改，以支持这些规则。

总体而言，本节通过详细的证明和解释，展示了生命周期逻辑的强大之处，以及如何利用 Iris 框架中的幽灵状态和不变式，来精确地建模和验证 Rust 中的生命周期和借用机制。这对于理解 Rust 的类型系统和安全性，以及在形式化验证中应用这些概念，具有重要的理论和实践意义。
 #  
 Thought for 16 seconds
**概览：**

这段内容来自论文《Understanding and Evolving the Rust Programming Language》（理解和发展 Rust 编程语言）的 **第 11 章：生命周期逻辑（Lifetime Logic）**，具体是 **11.7 节：实现完整的生命周期逻辑（Implementing the Full Lifetime Logic）**。在之前的章节中，作者已经建立了一个生命周期逻辑的模型，但该模型 **不支持重新借用（reborrowing）**。本节的目标是 **扩展之前的模型**，以支持完整的生命周期逻辑，包括重新借用的功能。

作者首先指出，为了验证完整的生命周期逻辑，需要调整模型以验证一些关键的证明规则，特别是 **LftL-idx-bor-unnest** 规则。为了证明这个规则，作者 **将问题简化** 为证明一个更低级的规则，该规则直接涉及 **原始借用（raw borrows）** 和 **生命周期的多重集结构（multiset structure）**。

接下来，作者通过引入 **LftL-raw-unnest** 和 **LftL-raw-shorten** 两个引理，展示了如何利用这些低级规则来推导更高级的规则，包括 **LftL-idx-bor-unnest** 和 **LftL-bor-merge**。他们解释了在模型中引入新的借用状态（如 `rebor(κ)`），以及如何在证明中利用生命周期的多重集表示和严格包含关系。

**详细解读：**

### **11.7 实现完整的生命周期逻辑（Implementing the Full Lifetime Logic）**

#### **背景与目标**

在之前的模型中，我们构建了一个 **受限的生命周期逻辑模型**，该模型 **不支持重新借用（reborrowing）**。也就是说，某些生命周期逻辑的证明规则在该模型中不成立，特别是 **LftL-idx-bor-unnest** 和 **LftL-bor-merge** 等规则。

为了验证完整的生命周期逻辑，我们需要：

1. **调整模型**，使其支持重新借用。
2. **验证关键的证明规则**，如 **LftL-idx-bor-unnest**。
3. **解释**如何获得 **LftL-bor-merge** 和 **LftL-idx-iff** 等规则。
#### **引入新的借用状态**

为了支持重新借用，我们需要在 **借用盒子（borrow box）** 的管理中 **引入第三种状态**：

- **in**：资源在生命周期不变式中。
- **open(q)**：资源已交给客户端，留下了生命周期令牌的一部分作为押金。
- **rebor(κ)**：资源被重新借用给另一个生命周期 κ。
**rebor(κ) 状态的特点**：

- 类似于 open(q) 状态，对应的借用盒子片段当前是 **空的**。
- 资源 **不归客户端所有**，而是归另一个生命周期 κ 所有。
- 需要引入 **新的押金系统**，确保资源能及时归还。
#### **利用生命周期的多重集表示**

在新的模型中，我们将 **生命周期表示为原子生命周期的有限多重集（finite multiset）**。这在证明中非常重要，因为：

- **多重集的包含关系**可以用来表示生命周期的 **严格包含（strict inclusion）**，这对于重新借用的证明至关重要。
- 可以对多重集的大小进行 **归纳（induction）**，以简化证明过程。
### **11.7.1 问题的简化（Reducing the Problem）**

为了证明 **LftL-idx-bor-unnest** 规则，我们首先将问题简化为证明一个更低级的规则，即 **LftL-raw-unnest**。这样，我们可以专注于 **原始借用** 和 **生命周期的多重集结构**，而不必处理更高级别的生命周期包含关系。

#### **依赖关系图**

作者提供了一个依赖关系图，展示了重新借用规则之间的关系：

- **LftL-raw-unnest** 和 **LftL-raw-shorten** 位于底部，是基本的引理。
- **LftL-idx-bor-unnest** 和 **LftL-bor-merge** 可以从这些引理推导出来。
- **LftL-reborrow** 和 **LftL-bor-unnest** 则依赖于 **LftL-idx-bor-unnest**。
#### **LftL-raw-unnest 引理**

**引理形式**：

$$
κ ⊂ κ_0 ∗ \text{BoxSlice}(N_{\text{bor}}, P, ι) ∗ \text{RawBor}(κ_0, [\text{Bor} : (κ, ι)]_1) ≡−∗_{N_{\text{lft}}} \text{RawBor}(κ_0, P) \quad (\text{LftL-raw-unnest})
$$

**解释**：

- **目标**：将一个借用令牌 [ \text{Bor} : (κ, ι) ]_1，从更短的生命周期 κ_0 **嵌套借用（unnest）** 到更长的生命周期 κ。
- **条件**：生命周期 κ **严格包含** 于 κ_0，即 κ ⊂ κ_0。这里的包含关系是基于多重集的严格包含，意味着 κ 实际上是 **更长的生命周期**，因为它包含 **更少的原子生命周期**。
#### **为何使用多重集的严格包含**

- **严格包含**确保了生命周期之间的 **静态** 和 **内在的（intensional）** 关系。
- **好处**：避免了生命周期包含关系的 **扩展性（extensional）**，即避免了因创建碎裂借用（fractured borrow）而产生的新生命周期包含关系。**简化证明**：因为多重集的严格包含是一个 **良基顺序（well-founded order）**，可以对多重集的大小进行归纳。
#### **LftL-raw-shorten 引理**

在证明 **LftL-idx-bor-unnest** 之前，我们需要另一个引理 **LftL-raw-shorten**。

**引理形式**：

$$
κ \subseteq κ_0 ∗ \text{RawBor}(κ, P) ≡−∗_{N_{\text{lft}}} \text{RawBor}(κ_0, P) \quad (\text{LftL-raw-shorten})
$$

**解释**：

- **目标**：将一个原始借用的生命周期从 κ **缩短** 到 κ_0。
- **条件**：κ_0 **包含** κ，即 κ \subseteq κ_0。在多重集的表示下，κ_0 是 **更短的生命周期**，因为它包含 **更多的原子生命周期**。
#### **证明 LftL-raw-shorten**

1. **情况分析**：
- **如果 κ = κ_0**：直接成立，无需进一步证明。
- **如果 κ ≠ κ_0**：展开 \text{RawBor}(κ, P)，获得借用片段的名称 ι。创建一个新的原始借用 \text{RawBor}(κ_0, [\text{Bor} : (κ, ι)]_1)，即在生命周期 κ_0 上借用借用令牌 [ \text{Bor} : (κ, ι) ]_1。**注意**：我们不需要继承（inheritance），可以将其丢弃。
2. **应用 LftL-raw-unnest**：
- 我们的目标变为：
$$
κ ⊂ κ_0 ∗ \text{BoxSlice}(N_{\text{bor}}, P, ι) ∗ \text{RawBor}(κ_0, [\text{Bor} : (κ, ι)]_1) ≡−∗_{N_{\text{lft}}} \text{RawBor}(κ_0, P)
$$
- 这正是 **LftL-raw-unnest** 的形式，因此可以直接应用。
#### **证明 LftL-idx-bor-unnest**

**规则形式**：
&^{κ_1}_{(κ_1', ι)} P ∗ &^{κ_2}_{\text{full}}([\text{Bor} : (κ_1', ι)]_1) ≡−∗_{N_{\text{lft}}} &^{κ_1 ∪ κ_2}_{\text{full}} P \quad (\text{LftL-idx-bor-unnest})
**解释**：

- **目标**：将一个索引借用 &^{κ_1}_{(κ_1', ι)} P 和一个完整借用 &^{κ_2}_{\text{full}}([\text{Bor} : (κ_1', ι)]_1) 合并，得到一个新的完整借用 &^{κ_1 ∪ κ_2}_{\text{full}} P。
- **注意**：这里的借用索引展开为生命周期和片段名称的对 (κ_1', ι)。
**证明步骤**：

1. **展开借用的定义**：
- 展开索引借用 `&^{κ_1}_{(κ_1', ι)} P` 和完整借用 `&^{κ_2}_{\text{full}}([\text{Bor} : (κ_1', ι)]_1)`，引入隐藏的生命周期 `κ_2'`。
- 目标变为：κ_1 \sqsubseteq κ_1' ∗ \text{BoxSlice}(N_{\text{bor}}, P, ι) ∗ κ_2 \sqsubseteq κ_2' ∗ \text{RawBor}(κ_2', [\text{Bor} : (κ_1', ι)]_1) ≡−∗_{N_{\text{lft}}} &^{κ_1 ∪ κ_2}_{\text{full}} P
2. **特殊情况处理**：
- **当 κ_2' 是静态生命周期 ε（内部表示为 ∅）**：**解释**：借用到静态生命周期基本上相当于不借用，这使得证明相对简单。**步骤**：使用 **LftL-tok-unit** 规则，创建一个生命周期令牌。使用该令牌打开借用，获得 [ \text{Bor} : (κ_1', ι) ]_1 的所有权。由于拥有 \text{BoxSlice}(N_{\text{bor}}, P, ι)，可以组合两者得到 \text{RawBor}(κ_1', P)。证明 κ_1 ∪ κ_2 \sqsubseteq κ_1'，因为 κ_1 \sqsubseteq κ_1'，因此成立。完成证明。
3. **一般情况**（`κ_2'` 非空）：
- **步骤**：使用 **LftL-raw-shorten**，将 `\text{RawBor}(κ_2', [\text{Bor} : (κ_1', ι)]_1)` 的生命周期缩短到 `κ_1' ∪ κ_2'`。**理由**：因为 κ_2' \subseteq κ_1' ∪ κ_2'，所以可以缩短。应用 **LftL-raw-unnest**，使用 `κ = κ_1'`，`κ_0 = κ_1' ∪ κ_2'`。**注意**：由于 κ_2' 非空，满足严格包含 κ ⊂ κ_0。现在的目标变为：κ_1 \sqsubseteq κ_1' ∗ κ_2 \sqsubseteq κ_2' ∗ \text{RawBor}(κ_1' ∪ κ_2', P) ≡−∗_{N_{\text{lft}}} &^{κ_1 ∪ κ_2}_{\text{full}} P使用 **LftL-bor-shorten**，可以从 `\text{RawBor}(κ_1' ∪ κ_2', P)` 得到 `&^{κ_1 ∪ κ_2}_{\text{full}} P`。**理由**：因为生命周期的交集（在多重集表示下是并集）对于生命周期包含是协变的。
- **完成证明**。
#### **推导 LftL-bor-merge**

**规则形式**：
&^{κ}_{\text{full}} P ∗ &^{κ}_{\text{full}} Q ≡−∗_{N_{\text{lft}}} &^{κ}_{\text{full}} (P ∗ Q) \quad (\text{LftL-bor-merge})
**解释**：

- **目标**：将两个在相同生命周期 κ 上的完整借用合并为一个借用，其内容为 P ∗ Q。
**证明步骤**：

1. **展开完整借用**：
- 展开 &^{κ}_{\text{full}} P 和 &^{κ}_{\text{full}} Q，引入可能不同的生命周期 κ_0 和 κ_0'。
2. **使用 LftL-raw-shorten**：
- 将两个原始借用的生命周期缩短到 κ ∪ κ_0 ∪ κ_0'。
3. **合并借用片段**：
- 现在，我们有两个内容为 `P` 和 `Q` 的原始借用，它们在相同的生命周期上。
- 使用 **Slice-merge** 规则，将对应的借用盒子片段合并。
4. **完成证明**：
- 重新构建完整借用 &^{κ}_{\text{full}} (P ∗ Q)。
### **总结**

通过将问题简化为证明 **LftL-raw-unnest** 和 **LftL-raw-shorten** 两个引理，我们成功地将重新借用和解嵌的证明转换为对 **原始借用** 和 **生命周期多重集严格包含** 的操作。这种方法的优势在于：

- **避免了复杂的生命周期包含关系**：只需处理多重集的严格包含，这是一种 **静态** 和 **内在的** 关系。
- **简化了证明过程**：可以对多重集的大小进行 **归纳**，使得证明更加清晰。
通过证明 **LftL-raw-unnest**，我们能够推导出 **LftL-idx-bor-unnest** 和 **LftL-bor-merge** 等更高级的规则，从而实现了对完整生命周期逻辑的支持。

**全面总结：**

在本节中，作者详细解释了如何 **扩展之前的生命周期逻辑模型**，以支持 **重新借用（reborrowing）**。他们首先指出，在之前的模型中，某些关键的生命周期逻辑规则（如 **LftL-idx-bor-unnest**）并不成立。为了验证完整的生命周期逻辑，需要对模型进行调整。

主要的调整包括：

1. **引入新的借用状态**：在借用盒子的管理中添加了第三种状态 `rebor(κ)`，表示资源被重新借用给另一个生命周期 `κ`。
2. **利用生命周期的多重集表示**：将生命周期表示为原子生命周期的有限多重集，这使得可以利用多重集的 **严格包含关系** 来进行证明。
接下来，作者将问题简化为证明两个关键的引理：

- **LftL-raw-unnest**：允许在严格包含关系下，将一个借用令牌从更短的生命周期嵌套借用到更长的生命周期。
- **LftL-raw-shorten**：允许在包含关系下，将原始借用的生命周期从较长的生命周期缩短到较短的生命周期。
通过证明这两个引理，作者成功地推导出了 **LftL-idx-bor-unnest** 和 **LftL-bor-merge** 等更高级的规则。这些规则的证明利用了生命周期的多重集结构和严格包含关系，使得证明过程更加简洁和明了。

最后，作者强调，通过这种方法，我们不再需要处理生命周期包含的扩展性问题，而是可以专注于生命周期的静态和内在关系。这使得证明过程更加可控和直观。

总体而言，本节展示了如何通过调整模型和简化问题，成功地验证了完整的生命周期逻辑，包括重新借用的功能。这对于理解 Rust 中的借用和生命周期机制，以及在形式化验证中应用这些概念，具有重要的理论和实践意义。
 #  
 Thought for 13 seconds
**概览：**

这段内容来自论文《Understanding and Evolving the Rust Programming Language》（理解和发展 Rust 编程语言）的 **第 11 章：生命周期逻辑（Lifetime Logic）**，具体是 **11.7.2 节：调整模型（Adjusting the Model）**。在之前的部分中，作者构建了一个生命周期逻辑的模型，但该模型 **不支持重新借用（reborrowing）**。为了解决这个问题，作者在本节中 **调整了模型**，以支持重新借用，从而验证完整的生命周期逻辑。

调整主要体现在以下几个方面：

1. **引入了新的借用状态**：在借用盒子的管理中增加了第三种状态 rebor(κ)，用于表示资源被重新借用给另一个生命周期 κ。
2. **添加了新的幽灵状态（Ghost State）**：引入了一个计数器，用于跟踪在一个生命周期中有多少未完成的重新借用。
3. **修改了不变式（Invariants）**：特别是 LftVs，其复杂性增加了，用于处理重新借用的资源管理。
4. **调整了相关的辅助函数和定义**，以适应模型的变化。
作者强调，这些调整是为了支持 **LftL-idx-bor-unnest** 规则，并且需要重新考虑 **LftL-begin** 规则，因为生命周期的结束现在变得更加复杂。其他的证明规则基本保持不变，因此在此不再重新证明。

**详细解读：**

### **引言**

在之前的模型中，我们构建了一个 **受限的生命周期逻辑模型**，它 **不支持重新借用（reborrowing）**。这意味着某些生命周期逻辑的规则，如 **LftL-idx-bor-unnest**，在该模型中无法验证。

为了解决这个问题，作者在本节中 **调整了模型**，以支持重新借用。这涉及到对模型中的一些关键部分进行修改，包括 **借用状态、幽灵状态、辅助函数** 以及 **不变式**。

### **模型的调整**

#### **总体概述**

- **保持不变的部分**：**令牌和生命周期包含关系**：这些部分在调整中 **没有改变**，因此作者没有重复它们的定义。**生命周期逻辑的不变式**：关于 LftAlive 和 LftDead 的定义也没有受到重新借用的影响，因此在此不再赘述。
- **改变的部分**：**域（Domains）**：增加了新的借用状态和计数器。**辅助函数**：更新了 OwnBor、OwnInh，并引入了新的 OwnCnt。**借用的定义**：调整了索引借用和原始借用的定义。**不变式**：修改了 LftDead、LftBorDeposit、LftBorAlive 和 LftVs 的定义。
在 **Figure 11.14** 中，作者列出了调整后的模型，使用 **感叹号和蓝色** 标记了与之前的模型相比发生变化的部分。

#### **详细变化**

##### **1. 域（Domains）**

- **新增的借用状态**：**rebor(κ : Lft)**：表示借用被重新借用给生命周期 κ。**完整的借用状态定义**：

$$
\text{BorSt} := \text{in} \mid \text{open}(q : \text{Frac}) \mid \text{rebor}(κ : \text{Lft})
$$
- **新增的计数器幽灵状态**：**Cnt := \text{Auth}(ℕ)**：使用权威资源代数 Auth(N)，用于跟踪在一个生命周期中有多少未完成的重新借用。**用途**：当资源从一个生命周期重新借用给另一个生命周期时，原生命周期需要知道有多少资源被重新借用出去。
##### **2. 辅助函数（Helper Functions）**

- **OwnBor(κ, a)**：表示对生命周期 `κ` 的借用盒子的所有权。**未变**，只是更新了借用状态的定义。
- **OwnInh(κ, a)**：表示对生命周期 `κ` 的继承盒子的所有权。**未变**。
- **新增的 OwnCnt(κ, a)**：**定义**：

$$
\text{OwnCnt}(κ, a) := ∃γ_{\text{cnt}}.\; ◦ [κ \mapsto (\, ,\, , γ_{\text{cnt}})]_{γ_i} ∗ a : \text{Cnt}\; γ_{\text{cnt}}
$$
**解释**：OwnCnt 用于表示对生命周期 κ 的计数器幽灵状态的所有权。
##### **3. 借用的定义（Borrows）**

- **借用令牌**：**未变**：

$$
[\text{Bor} : (κ_0, ι)]_q := \text{OwnBor}(κ_0, ◦ι \mapsto (\text{in}, q))
$$
- **索引借用**：**调整**：
&^{κ}_{(κ_0, ι)} P := ∃P_0.\; .\; (P ∗−∗ P_0) ∗ κ \sqsubseteq κ_0 ∗ \text{BoxSlice}(N_{\text{bor}}, P_0, ι)**解释**：引入了存在的命题 P_0，并添加了一个视图转换 .\; (P ∗−∗ P_0)。这样可以支持 **LftL-idx-iff** 规则，即在命题等价的情况下关闭索引借用和原始借用。
- **原始借用**：**调整**：
\text{RawBor}(κ, P) := ∃ι, P_0.\; .\; (P ∗−∗ P_0) ∗ \text{BoxSlice}(N_{\text{bor}}, P_0, ι) ∗ \text{OwnBor}(κ, ◦(ι \mapsto (\text{in}, 1)))**解释**：与索引借用类似，引入了存在的命题 P_0 和视图转换。
- **完整借用**：**未变**：
&^{κ}_{\text{full}} P := ∃κ_0.\; κ \sqsubseteq κ_0 ∗ \text{RawBor}(κ_0, P)
##### **4. 不变式（Invariant）**

- **LftInh(κ, P_I, s)**：表示生命周期 `κ` 的继承盒子。**未变**。
- **LftBorDead(κ)**：表示生命周期 `κ` 已结束时的借用盒子状态。**未变**。
- **LftDead(κ)**：表示生命周期 `κ` 已结束。**调整**：

$$
\text{LftDead}(κ) := ∃P_I.\; \text{LftBorDead}(κ) ∗ \text{OwnCnt}(κ, •0) ∗ \text{LftInh}(κ, P_I, \text{full})
$$
**解释**：添加了 \text{OwnCnt}(κ, •0)，表示生命周期 κ 在结束时 **没有任何未完成的重新借用**。
- **LftBorDeposit(κ, B)**：管理借用的押金。**调整**：

$$
\text{LftBorDeposit}(κ, B) := \bigast_{ι ∈ \text{dom}(B)} \left\{
\begin{array}{ll}
\text{True} & \text{if } B(ι) = \text{in} \\
[κ]_q & \text{if } B(ι) = \text{open}(q) \\
\text{OwnCnt}(κ_0, ◦1) ∗ κ ⊂ κ_0 & \text{if } B(ι) = \text{rebor}(κ_0)
\end{array}
\right.
$$
**解释**：对于 rebor(κ_0) 状态的借用，我们需要在 κ_0 上声明一个计数器碎片 \text{OwnCnt}(κ_0, ◦1)，并且要求 κ ⊂ κ_0。
- **LftBorAlive(κ, P_B)**：表示生命周期 `κ` 存活时的借用盒子状态。**未变**。
- **LftVs(κ, P_B, P_I, n)**：管理借用盒子和继承盒子之间的关系，以及未完成的重新借用数量。**调整**：

$$
\text{LftVs}(κ, P_B, P_I, n) := ∀I.\; .\; P_B ∗ [†κ] ≡−∗_{\left[ \bullet I_{γ_i} ∗ \bigast_{\kappa' ∈ \text{dom}(I),\; \kappa' ⊂ κ} \text{LftAlive}(\kappa') \right]_{N_{\text{bor}}}} .\; P_I ∗ \text{OwnCnt}(κ, ◦n)
$$
**解释**：添加了参数 n，表示未完成的重新借用数量。引入了对其他生命周期 κ' 的依赖，它们必须是 **严格包含** 于 κ 的生命周期。
- **LftAlive(κ)**：表示生命周期 `κ` 存活。**调整**：

$$
\text{LftAlive}(κ) := ∃P_B, P_I, n.\; \text{LftBorAlive}(κ, P_B) ∗ \text{LftVs}(κ, P_B, P_I, n) ∗ \text{OwnCnt}(κ, •n) ∗ \text{LftInh}(κ, P_I, \text{empty})
$$
**解释**：添加了 n，并增加了对 \text{OwnCnt}(κ, •n) 的所有权。
### **模型调整的原因和影响**

#### **支持 LftL-idx-iff**

- **目的**：为了支持 **LftL-idx-iff** 规则，需要在关闭索引借用和原始借用时 **显式地处理命题的等价关系**。
- **影响**：在证明中可能会增加一些繁琐的细节，但不会带来本质上的困难。
#### **引入计数器幽灵状态**

- **原因**：当资源从一个生命周期重新借用给另一个生命周期时，原生命周期需要跟踪有多少资源被重新借用出去，以确保在生命周期结束时，所有资源都能正确归还。
- **如何实现**：使用权威资源代数 Auth(N)，每个生命周期都有一个计数器幽灵状态 Cnt。**碎片（Fragments）**：当资源被重新借用时，原生命周期的 LftBorDeposit 拥有计数器的碎片。**权威元素**：生命周期本身拥有计数器的权威部分。
#### **修改 LftVs**

- **复杂性增加的原因**：LftVs 需要处理重新借用的情况，当生命周期结束时，需要将资源归还给原来的生命周期。
- **实现方法**：**互递归定义**：LftVs 和 LftAlive 互相递归，但这是 **良定义的**，因为每次递归时，生命周期的多重集表示都会 **严格减少**。**处理依赖的生命周期**：LftVs 中的视图转换需要访问那些被重新借用资源的生命周期（即 **严格包含** 于当前生命周期的其他生命周期）。
#### **调整 LftL-begin**

- **原因**：LftL-begin 规则涉及到生命周期的结束，而由于 LftVs 的复杂性增加，结束一个生命周期的过程也变得更加复杂。
- **影响**：需要重新考虑 LftL-begin 的证明，以适应新的模型。
### **理解模型调整的关键点**

#### **1. 重新借用的管理**

- **押金系统**：为了确保资源能及时归还，需要一个新的押金系统。当资源被重新借用时，原生命周期在 LftBorDeposit 中持有一个计数器碎片。重新借用只能发生在生命周期 κ 到 **严格更大** 的生命周期 κ_0 之间，即 κ ⊂ κ_0。
#### **2. 多重集表示的优势**

- **良基顺序**：由于生命周期表示为有限多重集，且每次递归时多重集大小都会严格减少，因此递归定义是良定义的。
- **严格包含关系**：重新借用只能发生在生命周期之间存在严格包含关系的情况下，这在证明中提供了很大的便利。
#### **3. LftVs 的复杂性**

- **视图转换的框架（Frame）**：在 LftVs 的定义中，视图转换需要访问其他生命周期的不变式，以便在生命周期结束时，正确地归还资源。
- **语法糖**：使用 P ≡−∗[R]_N Q 表示在视图转换中，R 是一个框架，不受视图转换的影响。
#### **4. 递归定义的合理性**

- **互递归定义的可行性**：尽管 LftVs 和 LftAlive 是互递归的，但由于每次递归时多重集大小都会减少，且多重集是有限的，因此递归是终止的。
### **总结**

- **主要调整**：为了支持重新借用，模型引入了新的借用状态 rebor(κ)、计数器幽灵状态 Cnt，并调整了相关的辅助函数和不变式。
- **影响范围**：这些调整主要影响了借用盒子的管理、押金系统以及生命周期结束时的资源归还过程。
- **复杂性增加**：LftVs 的定义变得更加复杂，因为需要处理重新借用的资源管理，以及在生命周期结束时，正确地归还资源给原来的生命周期。
- **证明规则的适应性**：其他的证明规则基本保持不变，或只需要小的调整即可适应新的模型。
**全面总结：**

在这段内容中，作者针对之前的生命周期逻辑模型无法支持重新借用的问题，提出了 **模型的调整方案**。通过引入新的借用状态 `rebor(κ)`，模型现在能够表示资源被重新借用给另一个生命周期的情况。此外，引入计数器幽灵状态 `Cnt`，用于跟踪在一个生命周期中有多少未完成的重新借用，这对于在生命周期结束时确保资源的正确归还至关重要。

作者详细说明了模型中各个部分的变化，包括域、辅助函数、借用的定义和不变式。他们特别强调了 `LftVs` 的复杂性增加，这是因为需要处理重新借用的资源管理，以及在生命周期结束时，将资源归还给原始生命周期的过程。通过互递归的定义，并利用生命周期多重集的严格包含关系，作者确保了模型的良定义性和递归的终止性。

在调整模型后，作者指出需要重新考虑 **LftL-begin** 规则的证明，因为生命周期的结束过程变得更加复杂。然而，其他的证明规则基本保持不变，或者只需进行微小的调整即可适应新的模型。

总体而言，这段内容深入探讨了如何调整生命周期逻辑模型以支持重新借用，展示了在形式化验证中处理复杂资源管理问题的方法。通过引入新的幽灵状态和调整不变式，作者成功地扩展了模型的功能，使其能够验证完整的生命周期逻辑。这对于理解 Rust 中的借用和生命周期机制，以及在 Iris 框架中形式化验证 Rust 程序的安全性，具有重要的理论和实践意义。
 #  
 Thought for 8 seconds
**概览：**

这段内容来自论文《Understanding and Evolving the Rust Programming Language》（理解和发展 Rust 编程语言）的 **第 11 章：生命周期逻辑（Lifetime Logic）**，具体是 **11.7.3 节：原始借用的解嵌（Unnesting of Raw Borrows）**。在之前的章节中，作者构建了一个支持重新借用（reborrowing）的生命周期逻辑模型，并调整了模型以支持完整的生命周期逻辑。

本节的主要目标是 **证明原始借用的解嵌规则（LftL-raw-unnest）**。这个规则允许我们在生命周期之间进行借用的解嵌，即从一个更短的生命周期 `κ_0` 中，将借用的资源转移到一个更长的生命周期 `κ` 中。证明这个规则需要详细分析生命周期的状态、借用盒子的管理、幽灵状态的更新以及不变式的维护。

在证明过程中，作者将整个过程分为四个关键步骤：

1. **移除借用令牌**：从较短的生命周期 κ_0 中移除借用令牌 [ \text{Bor} : (κ, ι) ]_1，以获得对资源的完全所有权。
2. **打开借用片段**：在较长的生命周期 κ 中打开借用片段 ι，将其状态更改为 rebor(κ_0)，表示资源被重新借用给 κ_0。
3. **创建新的借用**：使用获得的资源 . P，在 κ_0 中创建一个新的借用。
4. **修复不变式**：通过在 κ_0 的 LftVs 中进行调整，确保在 κ_0 结束时，资源能够正确地归还到原始的生命周期 κ 中。
此外，作者还讨论了在存在重新借用的情况下，如何结束生命周期，以及需要满足的条件和证明步骤。

**详细解读：**

### **11.7.3 原始借用的解嵌（Unnesting of Raw Borrows）**

#### **目标**

我们的目标是证明 **原始借用的解嵌规则（LftL-raw-unnest）**：

$$
κ ⊂ κ_0 ∗ \text{BoxSlice}(N_{\text{bor}}, P, ι) ∗ \text{RawBor}(κ_0, [\text{Bor} : (κ, ι)]_1) ≡−∗_{N_{\text{lft}}} \text{RawBor}(κ_0, P)
$$

**解释**：

- **前提**：κ ⊂ κ_0：生命周期 κ **严格包含** 于 κ_0，即 κ 是更长的生命周期（包含更少的原子生命周期）。\text{BoxSlice}(N_{\text{bor}}, P, ι)：我们拥有借用盒子中的片段 ι，其内容为 P。\text{RawBor}(κ_0, [\text{Bor} : (κ, ι)]_1)：在较短的生命周期 κ_0 中，我们有一个原始借用，借用了借用令牌 [ \text{Bor} : (κ, ι) ]_1。
- **结论**：我们希望在生命周期 κ_0 中得到 \text{RawBor}(κ_0, P)，即直接借用资源 P，而不是借用借用令牌。
**直观理解**：

- 我们想要 **解嵌（unnest）** 借用，将借用从借用令牌 [ \text{Bor} : (κ, ι) ]_1 转换为直接借用资源 P。
- 这需要我们在生命周期之间调整借用的状态和资源的所有权。
#### **证明步骤**

证明分为以下四个主要步骤：

1. **移除 [ \text{Bor} : (κ, ι) ]_1 的借用**：
- 从生命周期 κ_0 的借用盒子中移除对 [ \text{Bor} : (κ, ι) ]_1 的借用。
- 这使得我们能够完全拥有 \text{RawBor}(κ_0, P)。
- **注意**：这一步可能会暂时破坏借用盒子和继承盒子之间的平衡，但我们会在后续步骤中修复。
2. **在 κ 中打开借用片段 ι**：
- 将生命周期 κ 中的借用片段 ι 的状态从 in 更改为 rebor(κ_0)。
- 这表示资源被重新借用给生命周期 κ_0。
- 我们需要留下一个 **重新借用令牌（reborrow token）**，以确保资源能够被正确归还。
3. **在 κ_0 中创建新的借用**：
- 使用我们现在拥有的资源 . P，在生命周期 κ_0 中创建一个新的原始借用 \text{RawBor}(κ_0, P)。
4. **修复不变式**：
- 重新建立 LftVs(κ_0, P_{B, κ_0}, P_{I, κ_0}, n+1)，其中 n+1 表示生命周期 κ_0 的未完成重新借用数量增加了 1。
- 这样，当 κ_0 结束时，我们可以确保资源 P 被正确地归还到原始的借用片段 ι 中。
#### **详细证明**

##### **前提条件的确认**

- **打开生命周期逻辑不变式**：我们首先打开生命周期逻辑的不变式 LftLInv。
- **生命周期的存在性**：κ 必须已经存在（因为我们有在 κ 上的借用）。如果 κ_0 已经结束，我们可以使用 **伪造（faking）** 技巧来解决问题。如果 κ_0 仍然存活，那么由于 κ ⊂ κ_0，κ 也必须存活。
- **拥有的资源**：我们现在拥有 . \text{LftAlive}(κ) ∗ . \text{LftAlive}(κ_0)。我们可以暂时同时破坏这两个生命周期的不变式。
##### **步骤 1：移除借用令牌**

- **目标**：从 `κ_0` 的借用盒子中移除对 `[ \text{Bor} : (κ, ι) ]_1` 的借用。
- **具体操作**：**展开 \text{RawBor}(κ_0, [ \text{Bor} : (κ, ι) ]_1)**：我们展开原始借用，获得借用片段的名称 ι_0。通过组合我们拥有的借用令牌和 \text{LftBorAlive}(κ_0, P_{B, κ_0}) 中的权威状态，我们知道借用状态 B(ι_0) = \text{in}。**使用 \text{Slice-delete-full}**：我们使用 **Slice-delete-full** 规则，删除借用片段 ι_0，并获得 [ \text{Bor} : (κ, ι) ]_1 的所有权。我们从借用盒子的状态 B 和权威状态中移除 ι_0。**更新 LftBorDeposit**：因为我们删除的是状态为 in 的借用片段，所以 LftBorDeposit 不受影响（因为 in 状态的借用没有押金）。
- **结果**：我们现在拥有 [ \text{Bor} : (κ, ι) ]_1 的所有权。κ_0 的借用盒子总内容变为 P_{B, κ_0}'。
##### **步骤 2：在 κ 中打开借用片段 ι**

- **目标**：将 `κ` 中的借用片段 `ι` 的状态从 `in` 更改为 `rebor(κ_0)`，并留下一个重新借用令牌。
- **具体操作**：**确认借用状态**：通过拥有的借用令牌 [ \text{Bor} : (κ, ι) ]_1，我们知道 B(ι) = \text{in}，即借用片段当前是满的。**使用 \text{Slice-empty}**：我们使用 **Slice-empty** 规则，清空借用片段 ι，获得 . P。将借用片段 ι 的状态更新为 \text{rebor}(κ_0)，表示资源被重新借用给 κ_0。**更新 LftBorDeposit**：我们需要在 LftBorDeposit 中留下一个重新借用押金，即 \text{OwnCnt}(κ_0, ◦1)。这表示 κ_0 有一个未完成的重新借用。
- **结果**：我们现在拥有 . P，以及 \text{OwnBor}(κ, ◦(ι \mapsto (\text{rebor}(κ_0), 1)))。借用片段 ι 的状态已更新为 \text{rebor}(κ_0)。
##### **步骤 3：在 κ_0 中创建新的借用**

- **目标**：使用 `. P` 在 `κ_0` 中创建一个新的原始借用 `\text{RawBor}(κ_0, P)`。
- **具体操作**：**使用之前的引理**：我们可以应用在 **LftL-borrow** 的证明中得到的引理 **Lft-bor'**。这允许我们在 κ_0 的借用盒子中添加一个新的借用片段，内容为 P。**更新借用盒子状态**：借用盒子的总内容更新为 P_{B, κ_0}' ∗ P。我们获得新的原始借用 \text{RawBor}(κ_0, P)。
- **结果**：我们现在拥有 . \text{LftBorAlive}(κ_0, P_{B, κ_0}' ∗ P)。已经在 κ_0 中创建了新的原始借用 \text{RawBor}(κ_0, P)。
##### **步骤 4：修复不变式**

- **目标**：重新建立 `LftVs(κ_0, P_{B, κ_0}' ∗ P, P_{I, κ_0}, n+1)`，确保不变式保持成立。
- **具体操作**：**重新建立 LftVs**：我们需要证明：

$$
. P ∗ \text{OwnBor}(κ, ◦(ι \mapsto (\text{rebor}(κ_0), 1))) ≡−∗_{N_{\text{bor}}} [ \text{Bor} : (κ, ι) ]_1 ∗ \text{OwnCnt}(κ_0, ◦1)
$$
**解释**：我们将 . P 和借用令牌组合起来，重新获得 [ \text{Bor} : (κ, ι) ]_1。通过重新借用押金，我们将 κ_0 的未完成重新借用计数增加了 1（即 n+1）。**利用生命周期的包含关系**：因为 κ ⊂ κ_0，所以在 LftVs(κ_0, P_{B, κ_0}' ∗ P, P_{I, κ_0}, n+1) 的视图转换框架中，我们可以访问 \text{LftAlive}(κ)。**更新借用盒子和幽灵状态**：我们将 κ 中的借用片段 ι 的状态从 \text{rebor}(κ_0) 恢复为 \text{in}。这需要使用 **Slice-fill** 规则。这样，我们重新建立了 \text{LftBorAlive}(κ, P_{B, κ})。**处理押金和计数器**：在恢复借用片段状态的过程中，我们消耗了 . P，但取回了之前留下的重新借用押金 \text{OwnCnt}(κ_0, ◦1)。这确保了 κ_0 的未完成重新借用计数正确更新。
- **结果**：我们成功地重新建立了 LftVs(κ_0, P_{B, κ_0}' ∗ P, P_{I, κ_0}, n+1)。所有的不变式都得到了正确的维护。
#### **总结**

通过上述四个步骤，我们成功地证明了 **原始借用的解嵌规则（LftL-raw-unnest）**。关键在于正确地管理借用盒子的状态、幽灵状态以及不变式的维护，特别是在涉及重新借用和生命周期之间的资源转移时。

### **11.7.4 在存在重新借用的情况下结束生命周期（Ending Lifetimes in the Presence of Reborrowing）**

#### **挑战**

由于引入了重新借用，结束一个生命周期变得更加复杂。特别是，`LftVs` 的定义现在需要访问其他生命周期的资源，这意味着我们需要更仔细地处理生命周期的结束过程。

#### **证明目标**

需要重新证明以下引理，表达结束一个原子生命周期的核心内容：

$$
\text{LftLInv} ∗ [ {Λ} ]_1 ≡−∗_{N_{\text{lft}} \setminus N_{\text{mgmt}}} \text{LftLInv} ∗ [ †{Λ} ] \quad (\text{ALft-end})
$$

#### **证明步骤**

##### **1. 结束单个生命周期的引理（Lft-end）**

**引理形式**：

$$
\left( \forall κ'.\; κ' ∈ \text{dom}(I) ∧ κ' ⊂ κ ⇒ κ' ∈ K_a \right) ∗ \left( \forall κ'.\; κ' ∈ \text{dom}(I) ∧ κ ⊂ κ' ⇒ κ' ∈ K_d \right) ∗ \text{LftAlive}(κ) ∗ [ †κ ] ≡−∗_{N_{\text{lft}} \setminus N_{\text{mgmt}}} \left( \bigast_{κ_a ∈ K_a} \text{LftAlive}(κ_a) ∗ \bigast_{κ_d ∈ K_d} \text{LftDead}(κ_d) \right) ∗ \text{LftDead}(κ) \quad (\text{Lft-end})
$$

**解释**：

- **前提**：K_a：包含所有严格包含于 κ 的存活生命周期（即更长的生命周期）。K_d：包含所有严格包含 κ 的已结束生命周期（即更短的生命周期）。\text{LftAlive}(κ)：生命周期 κ 存活。[ †κ ]：我们拥有生命周期 κ 的死亡令牌。
- **结论**：结束生命周期 κ，并确保所有前提条件得到满足。
**证明要点**：

1. **验证借用片段状态**：
- 确保所有借用片段的状态都是 in。
- 如果存在 \text{open}(q) 状态的借用片段，会与 [ †κ ] 矛盾（因为我们不能同时拥有生命周期令牌和死亡令牌）。
- 如果存在 \text{rebor}(κ_0) 状态的借用片段，我们需要检查：κ ⊂ κ_0，即 κ_0 是一个更短的生命周期。由于 κ_0 必须在 K_d 中（已结束），但我们拥有 \text{OwnCnt}(κ_0, ◦1)，这与 \text{OwnCnt}(κ_0, •0) 矛盾（因为已结束的生命周期计数器为 0）。因此，借用片段状态不能是 \text{rebor}(κ_0)。
2. **清空借用盒子**：
- 使用 **Box-empty** 规则，清空借用盒子，获得 . P_B 和 \text{LftBorDead}(κ)。
3. **应用 LftVs**：
- 我们拥有 .\; P_B、[ †κ ]，以及框架（所有权威的 I 和所有 κ' ⊂ κ 的 \text{LftAlive}(κ')）。
- 通过 LftVs，我们获得 . P_I 和 \text{OwnCnt}(κ, ◦n)。
- 我们还拥有 \text{OwnCnt}(κ, •n)，可以进行帧保持更新，将计数器更新为 0。
4. **填充继承盒子**：
- 使用 **Box-fill** 规则，填充继承盒子，获得 \text{LftInh}(κ, P_I, \text{full})。
- 这完成了 \text{LftDead}(κ) 的证明。
##### **2. 结束一组生命周期的引理（Lfts-end）**

**引理形式**：

$$
K_e ∩ K_a = ∅ ∗ \left( \forall κ ∈ K_e,\; κ' ∈ \text{dom}(I).\; κ' ⊇ κ ⇒ κ' ∈ K_e \right) ∗ \left( \forall κ ∈ \text{dom}(I).\; \text{LftAliveIn}(A, κ) ∧ κ ∉ K_e ⇒ κ ∈ K_a \right) ∗ \left( \bigast_{κ ∈ K_e} \text{LftInv}(A, κ) ∗ [ †κ ] \right) ≡−∗_{-N_{\text{mgmt}}} \left( \bigast_{κ' ∈ K_a} \text{LftAlive}(κ') \right) ∗ \left( \bigast_{κ ∈ K_e} \text{LftDead}(κ) \right) \quad (\text{Lfts-end})
$$

**解释**：

- **前提**：K_e：要结束的生命周期集合，必须对超集封闭（即如果 κ ∈ K_e，且 κ ⊆ κ'，则 κ' ∈ K_e）。K_a：存活的生命周期集合，与 K_e 不相交。\text{LftAliveIn}(A, κ)：生命周期 κ 存活。\text{LftInv}(A, κ) 和 [ †κ ]：我们拥有生命周期 κ 的不变式和死亡令牌。
- **结论**：结束所有在 K_e 中的生命周期，并保持 K_a 中的生命周期存活。
**证明要点**：

1. **归纳证明**：
- 对 K_e 的大小进行归纳。
- 如果 K_e 中没有存活的生命周期，则无需做任何事情。
- 否则，选择 K_e 中的一个最小元素 κ（根据 ⊂ 关系）。
2. **构建新的集合**：
- 定义 K_e' = K_e \ {κ}，K_a' = K_a ∪ {κ}。
- 确保新的集合满足引理的前提条件。
3. **应用归纳假设**：
- 对 K_e' 应用归纳假设，结束所有 K_e' 中的生命周期。
4. **结束生命周期 κ**：
- 使用之前的 Lft-end 引理，结束 κ。
- 确保 K_a 包含所有严格包含于 κ 的存活生命周期（即更长的生命周期）。
- 确保 K_d 包含所有严格包含 κ 的已结束生命周期（即更短的生命周期）。
##### **3. 证明 ALft-end**

- **应用 Lfts-end**：定义：K_e = \{ κ ∈ \text{dom}(I) \mid Λ ∈ κ \}：包含 Λ 的所有生命周期。K_a = \{ κ ∈ \text{dom}(I) \mid κ ∉ K_e ∧ \text{LftAliveIn}(A, κ) \}：不包含 Λ 的所有存活生命周期。确保 K_e 对超集封闭，K_a 包含所有不在 K_e 中的存活生命周期。
- **完成证明**：应用 Lfts-end，结束 K_e 中的所有生命周期。我们获得了 [ †{Λ} ]，完成了 \text{ALft-end} 的证明。
**全面总结：**

在本节中，作者深入探讨了 **原始借用的解嵌（LftL-raw-unnest）** 和 **在存在重新借用的情况下结束生命周期** 的问题。他们首先通过详细的四个步骤，证明了如何在两个生命周期之间调整借用的状态和资源的所有权，以实现解嵌。这涉及到对借用盒子的操作、幽灵状态的更新以及不变式的维护。

接下来，作者讨论了在引入重新借用后，结束一个生命周期变得更加复杂。他们需要重新证明结束生命周期的引理，考虑到重新借用的资源管理和计数器的更新。他们通过构造辅助的集合 `K_a` 和 `K_d`，以及对生命周期集合进行归纳，成功地证明了在存在重新借用的情况下，如何正确地结束生命周期。

总的来说，这段内容展示了在复杂的生命周期和借用管理中，如何精确地操作资源、维护不变式以及保证模型的正确性。通过引入计数器幽灵状态和仔细管理借用状态，作者确保了在生命周期结束时，所有资源都能被正确地归还。这对于理解 Rust 中的借用和生命周期机制，以及在形式化验证中应用这些概念，具有重要的理论和实践意义。
 #  
 Thought for 38 seconds
**概览：**

您提供的内容来自论文《Understanding and Evolving the Rust Programming Language》（理解和发展 Rust 编程语言）的 **第 12 章：语义类型系统的健全性（Semantic Type System Soundness）**，具体是 **12.1 节：对 λRust 生命周期判断的语义建模（Semantically Modeling λRust Lifetime Judgments）**。

在之前的章节中，作者建立了生命周期逻辑和一些关键类型的语义解释。本节的目标是 **完成类型系统的语义模型**，并证明两个关键的定理：

1. **逻辑关系的基本定理（The Fundamental Theorem of Logical Relations）**：它建立了语法类型系统和语义类型系统之间的联系。
2. **充足性定理（The Adequacy Theorem）**：它将语义类型与程序行为联系起来，保证语义良类型的程序是内存和线程安全的。
本节主要讨论 **如何对 λRust 的生命周期上下文和生命周期相关的判断进行语义建模**，并验证它们正确地模拟了语法判断。这包括对生命周期上下文 `E` 和 `L` 以及三个生命周期相关的判断（存活性、生命周期包含和外部生命周期上下文的可满足性）进行语义解释。

**详细解读：**

### **12 章：语义类型系统的健全性**

#### **背景介绍**

- **类型系统的语义解释**：在第 10 章中，作者为一些关键的 λRust 类型定义了语义解释，包括大小（size）、所有权谓词（ownership predicate），以及在某些情况下的共享谓词（sharing predicate）。
- **生命周期逻辑的开发**：为了使这些定义完全精确，作者在第 11 章中开发了生命周期逻辑（lifetime logic）。
- **目标**：现在，作者回到类型系统，完成类型和其他类型系统组件的语义模型。一旦语义模型完成，就可以验证语法类型系统和语义类型系统之间的关键定理。
#### **关键定理**

1. **逻辑关系的基本定理（The Fundamental Theorem of Logical Relations）**：**定理 4**：对于类型系统中给出的任何推理规则，当我们用 `|=` 取代所有的 `⊢`（将语法判断替换为它们的语义解释）时，得到的 Iris 定理成立。
- **解释**：这个定理建立了语法类型系统和语义类型系统之间的联系，说明了语法推导的判断在语义上也成立。
2. **充足性定理（The Adequacy Theorem）**：**定理 5**：设 `f` 是一个满足 `∅; ∅ | ∅ |= f = λx. x ⊢ fn() → Π[]` 的 λRust 函数。当我们使用默认的延续（不执行任何操作）来执行 `f` 时，没有执行会达到卡住状态（stuck state），即没有线程无法继续执行。
- **解释**：充足性定理保证了语义良类型的程序是 **内存和线程安全的**：它们不会执行任何无效的内存访问，也不会发生数据竞争。
#### **定理的意义**

- **综合效果**：这些定理表明，如果一个 λRust 程序中唯一不是语法良类型的代码出现在语义良类型的库中，那么程序是安全的。
- **实际应用**：为了确保整个 Rust 程序的安全性，我们只需要验证其 unsafe 库。
### **12.1 对 λRust 生命周期判断的语义建模**

#### **章节概述**

- **目标**：给出 λRust 生命周期上下文 E 和 L 以及三个生命周期相关的判断的语义解释，并验证它们正确地模拟了语法判断。
- **生命周期相关的判断**：**存活性（liveness）**：判断一个生命周期是否存活。**生命周期包含（lifetime inclusion）**：判断一个生命周期是否包含在另一个生命周期中。**外部生命周期上下文的可满足性（external lifetime context satisfiability）**：判断一个外部生命周期上下文是否可满足。
#### **语义模型的定义（见 Figure 12.1）**

**1. 生命周期的语义模型**

- **JκK**：将 λRust 中的生命周期 `κ` 映射为生命周期逻辑中的生命周期。对于类型变量 α，JαK := α。对于静态生命周期 static，JstaticK := ε，即生命周期逻辑中的 ε，表示静态生命周期永远不会结束。
**2. 生命周期上下文的语义模型**

- **JEK**：外部生命周期上下文 `E` 的语义解释。J∅K := True，空上下文对应于真。JE, κ ve κ'K := JκK v Jκ'K ∗ JEK，将 E 中的每个元素解释为生命周期逻辑中的生命周期包含，并与上下文的其余部分进行分离合取（separating conjunction）。
- **JLK(q)**：局部生命周期上下文 `L` 的语义解释，取决于一个分数 `q`。J∅K(q) := True。JL, κ vl κK(q) := ∃κ'.\; JκK = κ' u (⋂_{κ'' ∈ JκK} κ'') ∗ [κ']_q ∗  \left( [κ']_1 ≡−∗_{∅} [†κ'] \right) ∗ JLK(q)。**解释**：κ 是所有在 κ 中的生命周期的交集，再与另一个生命周期 κ' 的交集。我们拥有生命周期 κ' 的分数 q 的令牌 [κ']_q。我们还有一个视图转换，允许我们在需要时结束生命周期 κ'。
#### **解释生命周期上下文**

**1. 外部生命周期上下文 E**

- **简单解释**：E 中的每个元素 κ ve κ' 直接对应于生命周期逻辑中的生命周期包含 JκK v Jκ'K。
- **分离合取**：整个上下文是这些包含关系的分离合取。
**2. 局部生命周期上下文 L**

- **更复杂的解释**：κ vl κ 表示 κ 是所有在 κ 中的生命周期的交集，再与一个额外的生命周期 κ' 的交集。
- **目的**：引入 κ' 是为了能够结束 κ，因为我们拥有 κ' 的生命周期令牌以及允许我们结束该生命周期的视图转换。
- **分数 q**：我们拥有生命周期 κ' 的分数 q，这是为了允许多个判断同时使用上下文，通过拆分上下文的分数。
**3. 静态生命周期**

- **定义**：将 λRust 中的 static 生命周期对应于生命周期逻辑中的 ε，这确保了静态生命周期永远存在，且不能结束。
#### **解释生命周期判断**

**1. 存活性（E;L |= κ alive）**

- **解释**：一个生命周期 κ 在某个上下文中是存活的，如果我们可以证明一个对称访问器（symmetric accessor），它提供了该生命周期的一部分令牌。
- **形式化**：E;L |= κ alive :=  ∀q.\; JEK −∗ JLK(q) ∝_{N_{\text{lft}}, N_{\text{rust}}} q.\; [JκK]_q
**2. 生命周期包含（E;L |= κ1 v κ2）**

- **解释**：使用生命周期逻辑中的生命周期包含来解释 λRust 中的生命周期包含。
- **细节**：**第二个  模态**：由于局部生命周期上下文 L 的语义解释涉及非持久性的资源（因为我们拥有生命周期令牌的分数），因此在语义模型中，我们在结论周围添加了一个  模态。这确保了只使用上下文中的持久性部分来证明包含关系。
- **形式化**：E;L |= κ1 v κ2 :=  ∀q.\; JLK(q) −∗  (JEK −∗ Jκ1K v Jκ2K)
**3. 外部生命周期上下文的可满足性（E1;L1 |= E2）**

- **解释**：JE2K 可以从 JE1K 推导出来，只使用 JLK(q) 的持久性部分。
- **形式化**：E1;L1 |= E2 :=  ∀q.\; JLK(q) −∗  (JE1K −∗ JE2K)
#### **证明逻辑关系的基本定理（针对生命周期判断）**

- **目标**：对于每个生命周期判断的规则，证明它们的语义解释在 Iris 中的对应蕴涵成立。
- **过程**：**生命周期包含**：我们需要证明 λRust 中生命周期包含的所有规则对应的 Iris 定理（见 Figure 12.2）。**其他判断**：对存活性和外部生命周期上下文的可满足性，同样需要证明对应的定理。
##### **示例：生命周期包含的证明**

**1. Lincl-refl-sem（反身性）**

- **目标**：证明 E;L |= κ v κ。
- **方法**：利用生命周期逻辑中包含关系的反身性（LftL-incl-refl）。
**2. Lincl-static-sem（静态生命周期包含）**

- **目标**：证明 E;L |= κ v static。
- **方法**：使用 LftL-tok-unit（表示我们可以为静态生命周期创建令牌）。使用 LftL-end-unit（表示静态生命周期的死亡令牌会导致矛盾）。
**3. Lincl-extern-sem（外部包含）**

- **目标**：如果 κ ve κ' ∈ E，则 E;L |= κ v κ'。
- **方法**：对上下文 E 进行归纳。
**4. Lincl-local-sem（局部包含）**

- **目标**：如果 κ vl κ ∈ L，且 κ' ∈ κ，则 E;L |= κ v κ'。
- **方法**：对 L 进行归纳。使用  模态，确保只使用上下文中的持久性部分。
**5. Lincl-trans-sem（传递性）**

- **目标**：如果 E;L |= κ v κ'，且 E;L |= κ' v κ''，则 E;L |= κ v κ''。
- **方法**：展开包含的语义模型，得到需要证明的表达式。使用  模态和持久性魔术棒（magic wand）的性质，保持对 JLK(q) 的所有权。最终，使用生命周期逻辑中包含关系的传递性（LftL-incl-trans）。
##### **证明过程中的细节**

- **持久性魔术棒的性质**：通过使用  模态，我们可以在应用魔术棒时保留对资源的所有权。这在证明中非常重要，因为我们需要多次使用 JLK(q)。
- **强调的点**：证明语义版本的所有语法推理规则比仅仅证明“语法包含蕴涵语义包含”更强。这是因为语义规则可能有更弱的前提条件，但结论更强。
#### **小结**

- **完成了生命周期判断的语义建模**：对生命周期上下文和判断给出了语义解释，并证明了逻辑关系的基本定理（针对生命周期判断）。
- **为后续章节奠定基础**：接下来，作者将重新考虑 λRust 的类型和与之相关的判断。
**全面总结：**

在本节中，作者深入探讨了 **λRust 类型系统中生命周期相关的判断的语义建模**，并验证了这些语义模型正确地模拟了语法判断。这是为了证明 **逻辑关系的基本定理（The Fundamental Theorem of Logical Relations）**，该定理建立了语法类型系统和语义类型系统之间的联系。

作者首先给出了生命周期上下文 `E` 和 `L` 的语义解释，将它们映射到生命周期逻辑中的相应概念。特别地，外部生命周期上下文 `E` 中的每个元素直接对应于生命周期包含关系，而局部生命周期上下文 `L` 则更加复杂，因为它涉及到生命周期的交集和生命周期令牌的所有权。

接着，作者解释了三个主要的生命周期判断的语义模型：

1. **存活性（liveness）**：判断一个生命周期在给定的上下文中是否存活。
2. **生命周期包含（lifetime inclusion）**：使用生命周期逻辑中的包含关系来解释 λRust 中的包含判断。
3. **外部生命周期上下文的可满足性（external lifetime context satisfiability）**：判断一个外部生命周期上下文是否可以从另一个上下文推导出来。
在这些语义模型中，作者使用了 **持久性模态（）** 和 **魔术棒（magic wand）** 等概念，确保在证明中正确地管理资源的所有权和持久性。

最后，作者证明了生命周期包含判断的所有规则在语义模型中的对应定理。这些证明展示了如何利用生命周期逻辑中的性质，以及如何处理资源的所有权和持久性，以证明语义判断的正确性。

总体而言，本节为完成类型系统的语义模型奠定了基础，为后续章节中对类型的语义解释和证明提供了必要的工具和方法。这对于理解 Rust 的类型系统的健全性，以及在形式化验证中应用这些概念，具有重要的理论和实践意义。
 #  
 Thought for 5 seconds
**概览：**

您提供的内容来自论文《Understanding and Evolving the Rust Programming Language》（理解和发展 Rust 编程语言）的 **第 12 章：语义类型系统的健全性（Semantic Type System Soundness）**，具体是 **12.2 节：对 λRust 类型的语义建模（Semantically Modeling λRust Types）**。

在之前的章节中，作者已经为一些关键的 λRust 类型定义了语义模型。然而，他们还没有详细讨论拥有指针（owned pointers）和可变引用（mutable references）的共享谓词（sharing predicate），因为这些比预期的要复杂。本节的目标是 **完成 λRust 类型系统的语义模型**，为所有内置类型和类型构造器提供语义解释，并确保这些解释满足类型系统的要求。

本节的主要内容包括：

1. **复习和扩展语义类型的定义**：回顾之前章节中定义的语义类型域（semantic domain of types），并给出所有类型的语义解释。
2. **讨论简单类型（Simple Types）**：介绍简单类型的语义解释，包括它们的所有权谓词（ownership predicate）和共享谓词（sharing predicate）。
3. **拥有指针的延迟共享（Delayed Sharing for Owned Pointers）**：详细讨论拥有指针的共享谓词为何复杂，以及如何通过延迟共享的方式解决问题。
4. **可变引用的延迟共享（Delayed Sharing for Mutable References）**：类似地，讨论可变引用的共享谓词，以及如何使用延迟共享来满足类型系统的要求。
5. **产品类型和和类型（Products and Sums）**：介绍产品类型（如元组）和和类型（如枚举）的语义解释。
6. **未初始化的内存（Uninitialized Memory）**：讨论未初始化内存的类型语义，以及如何证明其满足类型系统的规则。
7. **函数类型（Function Types）**：解释函数类型的语义解释，特别是如何处理函数体的语义。
8. **递归类型（Recursive Types）**：讨论递归类型的语义解释，以及如何确保固定点的存在性。
**详细解读：**

### **语义类型的定义**

#### **语义类型域**

在 **Figure 12.4** 中，作者给出了语义类型的定义域：

- **PreSemType**：初始的语义类型，包括三个部分：size：类型的大小，即在内存中占用的空间，以自然数 $N$ 表示。own：所有权谓词，是一个函数，输入为线程标识和值列表，输出为一个 Iris 逻辑断言（iProp）。shr：共享谓词，是一个函数，输入为生命周期、线程标识和内存地址，输出为一个 Iris 逻辑断言。
- **SemType**：满足特定条件的 `PreSemType`，这些条件确保类型的语义解释符合类型系统的要求。
#### **语义类型需要满足的条件**

- **(ty-size)**：对于任何线程标识 `t` 和值 `v`，`own` 谓词需要保证值的大小与类型的 `size` 相等：
$$
\forall t, v.\; T.\text{own}(t, v) \vdash |v| = T.\text{size}
$$
- **(ty-shr-persist)**：对于任何生命周期 `κ`、线程标识 `t` 和地址 `\ell`，共享谓词需要是 **持久的（persistent）**：
$$
\forall κ, t, \ell.\; \text{persistent}(JτK.\text{shr}(κ, t, \ell))
$$
- **(ty-shr-mono)**：共享谓词对生命周期是 **单调的（monotonic）**，即如果 `κ'` 包含于 `κ`，则共享谓词可以从 `κ` 推广到 `κ'`：
$$
\forall κ, κ', t, \ell.\; κ' \sqsubseteq κ ∗ JτK.\text{shr}(κ, t, \ell) \vdash JτK.\text{shr}(κ', t, \ell)
$$
- **(ty-share)**：类型需要支持 **共享**，即可以将所有权谓词转化为共享谓词：&
κ
\; \text{full}\; \exists w.\; \ell \mapsto w ∗ JτK.\text{own}(t, w) ∗ [κ]_q \equiv−∗_{N_{\text{lft}}} \; JτK.\text{shr}(κ, t, \ell) ∗ [κ]_q其中 `&_{κ}^{\text{full}}` 表示对生命周期 `κ` 的完整借用。
### **语义类型的解释**

在 **Figure 12.5** 中，作者给出了各种类型的语义解释，包括：

1. **简单类型（Simple Types）**：如 `bool`、`int`、共享引用等。
2. **拥有指针（Owned Pointers）**：`ownn τ` 类型。
3. **可变引用（Mutable References）**：`&_{κ}^{\text{mut}} τ` 类型。
4. **共享引用（Shared References）**：`&_{κ}^{\text{shr}} τ` 类型。
5. **产品类型（Products）**：`Π τ` 类型，即元组类型。
6. **和类型（Sums）**：`Σ τ` 类型，即枚举类型。
7. **未初始化的内存（Uninitialized Memory）**：`1` 和 `n` 类型。
8. **函数类型（Function Types）**：`∀α. \text{fn}(ϝ : E; τ) → τ` 类型。
9. **递归类型（Recursive Types）**：`μ T. τ` 类型。
#### **SimpleType 的定义**

`SimpleType` 是一个用于定义简单类型的辅助构造器，其定义如下：

- **Size**：大小为 1。
- **Own**：所有权谓词，表示值 v 满足某个性质 Φ(t, v)。
- **Shr**：共享谓词，使用 **分数借用（fractured borrow）** 来表示共享。
定义如下：

$$
\text{SimpleType}(Φ) := \left\{
\begin{array}{l}
\text{size} := 1, \\
\text{own} := λ t, v.\; \exists v.\; v = [v] ∗ Φ(t, v), \\
\text{shr} := λ κ, t, \ell.\; \exists v.\; &_{κ}^{\text{frac}}(λ q.\; \ell \overset{q}{\mapsto} v) ∗ .\; Φ(t, v)
\end{array}
\right.
$$

其中：

- &_{κ}^{\text{frac}}(λ q.\; \ell \overset{q}{\mapsto} v) 表示对地址 \ell 的分数借用。
- . 表示 **以后（later）** 模态，用于处理递归类型和避免循环。
#### **简单类型的示例**

- **布尔类型（bool）**：
$$
J\text{bool}K := \text{SimpleType}(λ t, v.\; v = \text{true} ∨ v = \text{false})
$$
- **整数类型（int）**：
$$
J\text{int}K := \text{SimpleType}(λ t, v.\; ∃ z.\; v = z)
$$
- **共享引用类型（&_{κ}^{\text{shr}} τ）**：J&_{κ}^{\text{shr}} τ K := \text{SimpleType}(λ t, v.\; ∃ \ell.\; v = \ell ∗ JτK.\text{shr}(JκK, t, \ell))
#### **验证 SimpleType 满足语义类型的条件**

需要验证 `SimpleType` 满足 **ty-share** 等条件。具体而言，我们需要证明：
&
κ
\; \text{full}\; \exists v.\; \ell \mapsto v ∗ Φ(t, v) ∗ [κ]_q \equiv−∗_{N_{\text{lft}}} \; \exists v.\; &_{κ}^{\text{frac}}(λ q.\; \ell \overset{q}{\mapsto} v) ∗ .\; Φ(t, v) ∗ [κ]_q
**证明思路**：

1. **使用冻结（Freezing）**：使用 `LftL-bor-exists` 规则，将存在量词移到完整借用的外部。
2. **分离借用（Splitting Borrows）**：使用 `LftL-bor-split` 规则，将完整借用分割为多个部分。
3. **获得持久性的性质**：因为 `Φ` 是持久的（persistent），我们可以获得 `. Φ(t, v)`。
4. **将完整借用转换为分数借用**：使用 `LftL-bor-fracture` 规则，将完整借用转换为分数借用。
#### **拥有指针的延迟共享**

**问题描述**：

- **直觉上的共享谓词**：对于拥有指针 `ownn τ`，我们可能会想定义其共享谓词为：J\text{ownn } τ K.\text{shr}(κ, t, \ell) := ∃ \ell'.\; &_{κ}^{\text{frac}}(λ q.\; \ell \overset{q}{\mapsto} \ell') ∗ .\; JτK.\text{shr}(κ, t, \ell')这表示共享的拥有指针是一个指向指针的指针，外层指针使用分数借用处理，内层指针指向类型 `τ` 的共享实例。
- **问题出现**：使用上述定义，我们无法证明 **ty-share** 条件，因为在证明过程中，我们需要剥离 `.` 模态，但这是不可能的。
**解决方案：延迟共享（Delayed Sharing）**

- **延迟共享的概念**：将共享的执行延迟到真正需要的时候，而不是立即执行。
- **修改后的共享谓词**：J\text{ownn } τ K.\text{shr}(κ, t, \ell) := ∃ \ell'.\; &_{κ}^{\text{frac}}(λ q.\; \ell \overset{q}{\mapsto} \ell') ∗  \left( ∀ q.\; [κ]_q −∗ |V_{N_{\text{shr}} ∪ N_{\text{lft}}} N_{\text{lft}} .\; |V_{N_{\text{lft}}} N_{\text{shr}} ∪ N_{\text{lft}} JτK.\text{shr}(κ, t, \ell') ∗ [κ]_q \right)使用了 **视图转换（view shift）**，表示在需要时可以获取 JτK.\text{shr}(κ, t, \ell')。
**证明思路**：

- **创建不变式（Invariant）**：引入一个不变式 `I`，其内容为：I := JτK.\text{shr}(κ, t, \ell') ∨ &_{κ}^{\text{full}} . \left( ∃ w.\; \ell' \mapsto w ∗ JτK.\text{own}(t, w) \right)
- **两种情况讨论**：**共享已经开始**：如果不变式的左项成立，表示共享已经开始，我们可以直接使用 JτK.\text{shr}(κ, t, \ell')。**共享尚未开始**：如果不变式的右项成立，我们需要负责启动共享。这需要我们执行一些步骤，包括使用 LftL-bor-later 等规则。
- **关键步骤**：在共享尚未开始的情况下，我们需要在持久性的资源中包含完整的借用（full borrow），并使用索引借用（indexed borrows）来避免 `.` 模态的影响。
#### **可变引用的延迟共享**

**类似的问题和解决方案**：

- **共享谓词的定义**：J&_{κ}^{\text{mut}} τ K.\text{shr}(κ', t, \ell) := ∃ \ell'.\; &_{κ'}^{\text{frac}}(λ q.\; \ell \overset{q}{\mapsto} \ell') ∗ .\; JτK.\text{shr}(JκK \cap κ', t, \ell')
- **需要使用延迟共享**：同样地，我们需要使用延迟共享的策略来满足 **ty-share** 条件。
- **引入不变式和证明过程**：与拥有指针的情况类似，我们引入不变式，并在证明中使用索引借用和其他规则。
#### **产品类型和和类型**

- **产品类型（Π τ）**：**所有权谓词**：对每个组件类型 τ_i，我们拥有其所有权谓词。**共享谓词**：对每个组件类型 τ_i，我们拥有其共享谓词。
- **和类型（Σ τ）**：**表示方式**：在内存中表示为一个标记（tag），指示当前活跃的变体，以及对应的数据和可能的填充（padding）。**所有权谓词**：包括标记和活跃变体的数据的所有权。**共享谓词**：对标记使用分数借用，对活跃变体的数据使用共享谓词，对填充部分也需要处理，以确保类型的大小一致。
#### **未初始化的内存**

- **类型定义**：**1 类型**：表示大小为 1 的未初始化内存。**n 类型**：表示大小为 n 的未初始化内存，可以定义为 n 个 1 类型的组合。
- **所有权谓词**：未初始化的内存只需要保证有正确大小的内存，而不关心其内容。
- **定理**：证明未初始化内存的所有权谓词对应于正确大小的值。
#### **函数类型**

- **语义解释**：**函数类型**：∀α.\; \text{fn}(ϝ : E; τ) → τ**所有权谓词**：函数值 v 是一个函数定义，满足在给定语义良类型的参数时，可以安全调用并返回语义良类型的结果。
- **处理函数体的语义**：需要定义函数体的语义，确保在替换语义良类型的参数后，函数体是语义良类型的。
#### **递归类型**

- **解释**：对于递归类型 `μ T.\; τ`，我们需要找到一个固定点，使得类型的语义解释满足递归定义。
- **处理方法**：利用 Iris 的特性，确保递归类型的固定点存在。这需要类型系统中的递归使用被指针类型所保护，并在语义解释中使用 `.` 模态来处理递归。
**全面总结：**

在本节中，作者完成了 λRust 类型系统的语义模型，为所有内置类型和类型构造器提供了详细的语义解释。他们讨论了简单类型的语义解释，以及如何验证这些类型满足类型系统的条件。

特别地，作者深入分析了拥有指针和可变引用的共享谓词，发现简单的定义无法满足类型系统的要求。为了解决这个问题，他们引入了 **延迟共享（Delayed Sharing）** 的概念，通过引入不变式和延迟执行共享操作，确保共享谓词满足类型系统的条件。

此外，作者还讨论了产品类型和和类型的语义解释，解释了未初始化内存的类型语义，以及如何处理函数类型和递归类型的语义解释。

通过对所有类型的语义建模，作者为后续章节中的类型判断的语义解释奠定了基础。这对于验证 Rust 程序的安全性，以及理解 Rust 类型系统的健全性具有重要意义。
 #  
 Thought for 1m 2s
**概览：**

您提供的内容来自论文《Understanding and Evolving the Rust Programming Language》（理解和发展 Rust 编程语言）的 **第 12 章：语义类型系统的健全性（Semantic Type System Soundness）**，具体是 **12.3 节：插曲：非原子不变式和借用（Interlude: Non-atomic invariants and borrowing）** 和 **12.4 节：对 λRust 类型判断的语义建模（Semantically modeling λRust typing judgments）**。

在之前的章节中，作者建立了一个用于证明 Rust 程序安全性的语义模型，并讨论了生命周期逻辑、类型的语义解释等。然而，为了验证像 `Cell` 这样的类型，我们需要引入 **非原子不变式（Non-atomic Invariants）**，以及将其与 **借用（Borrowing）** 相结合。

本节的主要目标是：

1. **引入非原子不变式**：解释非原子不变式的概念，以及如何在 Iris 逻辑中使用它们。
2. **将非原子不变式与生命周期逻辑相结合**：定义 **非原子借用（Non-atomic Borrows）**，并给出其证明规则。
3. **对 λRust 类型判断进行语义建模**：在有了所有必要的组件后，定义 λRust 类型判断的语义解释，并验证语法规则与该语义解释的兼容性。
**详细解读：**

### **12.3 插曲：非原子不变式和借用**

#### **背景和动机**

- **问题**：我们需要为 Cell 类型定义一个共享谓词，使得每个人都可以对某个内存区域进行可变访问。
- **挑战**：**原子不变式的局限性**：通常，我们会使用 Iris 的不变式来共享内存的所有权。但是，Cell 使用的是非原子的内存访问，而 Iris 的不变式只能用于推理原子指令。**单线程访问**：我们只需要在单个线程内访问这个状态，而正常的不变式是所有线程都可以访问的。
- **解决方案**：引入 **非原子不变式（Non-atomic Invariants）**，它们允许在不改变当前掩码（mask）的情况下打开不变式，但只能从单个线程中打开。
#### **非原子不变式的介绍**

- **与原子不变式的区别**：**原子不变式**：在 Iris 中，打开不变式会改变当前的掩码，以确保不变式只能在原子操作中被打开。**非原子不变式**：打开不变式不会改变当前的掩码，但需要 **令牌（tokens）** 来确保同一个不变式不会被同时打开多次。
- **视图转换中的掩码**：在 Iris 中，视图转换（view shifts）的掩码实际上是类似的令牌的语法糖：
$$
|V_{E_1}^{E_2} P \approx \text{InvTokens}(E_1) -\!\ast\; \diamond |V_{\text{InvTokens}(E_2)} P
$$
**解释**：一个可能改变掩码的花式更新（fancy update）$|V_{E_1}^{E_2} P$ 实际上是消耗对所有在 $E_1$ 中的不变式的访问权，然后产生对所有在 $E_2$ 中的不变式的访问权。
- **非原子不变式的令牌管理**：使用非原子不变式时，我们需要手动管理这些令牌，没有语法糖的帮助。这意味着我们需要在证明中显式地传递这些令牌，形式如下：
$$
P \ast [\text{NaInv} : p.E_1 ] \equiv-\!\ast_E [\text{NaInv} : p.E_2 ] \ast Q
$$
**符号解释**：$[\text{NaInv} : p.E]$ 表示拥有池（pool）$p$ 中与掩码 $E$ 匹配的所有不变式的令牌。这个视图转换描述了在原子掩码 $E$ 下的不变式不会改变，但在池 $p$ 的非原子掩码从 $E_1$ 变为 $E_2$。
- **池（Pools）和线程本地性**：类似于并发程序中的每个线程可以有自己的线程本地内存，非原子不变式也支持多个 **池**，它们独立存在，其掩码和命名空间（namespaces）不相互干扰。这使得我们可以在不同的线程中独立管理非原子不变式。
#### **非原子不变式的证明规则（见 Figure 12.6）**

- **关键断言**：$\text{NaInv}_{p.N}(P)$，表示在池 $p$ 的命名空间 $N$ 中，我们维护不变式 $P$。
- **主要规则**：**NAInv-persist**：$\text{NaInv}_{p.N}(P)$ 是持久的（persistent）。**NAInv-tok-timeless**：令牌 $[\text{NaInv} : p.N ]$ 是无时间性的（timeless）。**NAInv-new-pool**：可以创建一个新的池，并返回该池中所有不变式的令牌：
$$
\text{True} \equiv-\!\ast_\bot \exists p.\; [\text{NaInv} : p.>]
$$
**NAInv-tok-split**：同一个池的令牌可以分割：
$$
[\text{NaInv} : p.E_1 \cup E_2 ] \ast-\!\ast [\text{NaInv} : p.E_1] \ast [\text{NaInv} : p.E_2]
$$
**NAInv-new-inv**：可以分配一个新的不变式：
$$
.\; P \equiv-\!\ast_N \text{NaInv}_{p.N}(P)
$$
**NAInv-acc**：可以打开一个非原子不变式：
$$
N \subseteq E \quad \text{NaInv}_{p.E}(P) -\!\ast [\text{NaInv} : p.E] \overset{N}{\longleftrightarrow} [\text{NaInv} : p.(E \setminus N)] \ast .\; P
$$
**解释**：这个访问器对于原子掩码来说是不改变的，这意味着不变式可以保持打开任意长时间，但它确实改变了池 $p$ 的非原子掩码，从 $E$ 变为 $E \setminus N$，这通过令牌反映出来。
#### **在 Iris 中的实现**

- 在 Iris 的技术附录中，作者解释了如何使用不变式和一些幽灵状态（ghost state）在 Iris 中编码非原子不变式。
#### **非原子借用**

- **目的**：为了在 `Cell` 的共享谓词中实际使用非原子不变式，我们需要将它们集成到生命周期逻辑中。
- **定义**：非原子借用（non-atomic borrows）是按照我们在 §11.4 中定义的原子借用的方式来定义的，只是使用了非原子不变式：&^\kappa_{p.N} \!\!\!\!\!\!\! \text{na}\; P := \exists i.\; &^\kappa_i P \ast \text{NaInv}_{p.N}([\text{Bor} : i]_1) \qquad \text{(na-bor)}**解释**：$\exists i$：存在一个索引 $i$。$&^\kappa_i P$：对索引 $i$ 的生命周期 $\kappa$ 进行借用，内容为 $P$。$\text{NaInv}_{p.N}([\text{Bor} : i]_1)$：在池 $p$ 的命名空间 $N$ 中，有一个非原子不变式，内容为借用令牌 $[\text{Bor} : i]_1$。
- **证明规则（见 Figure 12.7）**：**LftL-bor-na**：可以从完整借用创建非原子借用：&^\kappa_{\text{full}} P \equiv-\!\ast_N &^\kappa_{p.N} \!\!\!\!\!\!\! \text{na}\; P**LftL-na-shorten**：非原子借用可以被缩短：\kappa' \sqsubseteq \kappa \quad N \subseteq N' \quad &^\kappa_{p.N} \!\!\!\!\!\!\! \text{na}\; P -\!\ast &^{\kappa'}_{p.N'} \!\!\!\!\!\!\! \text{na}\; P**LftL-na-persist**：非原子借用是持久的：\text{persistent}(&^\kappa_{p.N} \!\!\!\!\!\!\! \text{na}\; P)**LftL-na-acc**：可以打开非原子借用：&^\kappa_{p.N} \!\!\!\!\!\!\! \text{na}\; P -\!\ast [\kappa]_q \ast [\text{NaInv} : p.N ] \overset{N_{\text{lft}}, N}{\longleftrightarrow} .\; P**解释**：打开借用后，原子掩码保持在 $N_{\text{lft}}, N$，但借用的命名空间 $N$ 从非原子掩码中移除。
### **12.4 对 λRust 类型判断的语义建模**

#### **目标**

- **定义 λRust 类型判断的语义解释**，并验证 §9.3 中给出的语法规则与该语义解释的兼容性。
- **语义模型的位置**：见 **Figure 12.8**。
#### **语义解释的简化**

- **省略自由变量的跟踪**：为了简化呈现，作者省略了在语义解释中对自由变量的跟踪。
#### **标记 Trait 的语义解释**

- **需要解释的判断**：$\vdash \tau; \text{copy}$$\vdash \tau; \text{send}$$\vdash \tau; \text{sync}$
- **对应的 Rust 标记 Trait**：Copy、Send 和 Sync。
- **Send 和 Sync 的语义解释**：**Send**：$|! = \tau; \text{send}$，要求所有权谓词独立于线程标识符（$t$）。
$$
|\! = \tau\; \text{send} := \diamond \forall t_1, t_2, v.\; J \tau K.\text{own}(t_1, v) -\!\ast J \tau K.\text{own}(t_2, v)
$$
**Sync**：$|! = \tau; \text{sync}$，要求共享谓词独立于线程标识符。
$$
|\! = \tau\; \text{sync} := \diamond \forall \kappa, t_1, t_2, \ell.\; J \tau K.\text{shr}(\kappa, t_1, \ell) -\!\ast J \tau K.\text{shr}(\kappa, t_2, \ell)
$$
- **Copy 的语义解释**：**第一部分**：要求所有权谓词是持久的。
$$
\forall t, v.\; \text{persistent}(J \tau K.\text{own}(t, v))
$$
**第二部分**：需要能够从共享引用指向的数据中制作一个副本。这是通过一个对称的访问器来表达的。**忽略非原子令牌的情况**：
$$
J \tau K.\text{shr}(\kappa, t, \ell) -\!\ast \left( [\kappa]_q \;\overset{N_{\text{shr}}, N_{\text{lft}}}{\longleftrightarrow}\; q'.\; \exists v.\; \ell^{q'} \mapsto v \ast . J \tau K.\text{own}(t, v) \right)
$$
**解释**：通过放弃一部分对应生命周期的令牌，我们可以临时获得对地址 $\ell$ 后面的内存的非原子、只读访问，并且知道存储的数据满足 $\tau$ 的所有权谓词。
- **处理非原子令牌****问题**：我们希望 `Cell` 是 `Copy` 的，但 `Cell` 的共享谓词使用了非原子借用，需要在访问器中加入非原子令牌。**简单的解决方案**：在访问器的左侧添加 $[\text{NaInv} : t.N_{\text{shr}}]$，让其打开 $N_{\text{shr}}$ 中的所有非原子不变式。**问题**：如果我们这样做，在证明 $\tau_1 \times \tau_2$ 的 `Copy` 时会遇到问题，因为打开第一个访问器会消耗所有的非原子令牌，无法打开第二个。**解决方案**：将命名空间 $N_{\text{shr}}$ 进一步分割，每个位置 $\ell$ 对应一个子命名空间 $N_{\text{shr}}.\ell$。**具体做法**：在访问器的开始掩码中，授予对 $[\geq \ell, < \ell + 1 + J \tau K.\text{size}]$ 中位置的访问权。在访问器的结束掩码中，要求最后一个位置（$\ell + J \tau K.\text{size}$）仍然可用。
- **验证 Copy 的规则**需要验证 §9.4 中给出的 $\vdash \tau; \text{copy}$ 的规则对于 $|! = \tau; \text{copy}$ 成立。
#### **类型上下文的语义解释**

- **类型上下文 T 和延续上下文 K****类型上下文 T**：是类型赋值的分离合取，每个赋值 $p; \mathcal{C}; \tau$ 使用 $J \tau K.\text{own}$ 解释。**延续上下文 K**：每个元素 $k; \mathcal{C}; \text{cont}(L; x.; T)$ 表示一个可以调用的延续，用 Iris 的最弱前置条件（weakest precondition）来表达。
- **路径的解释****路径 p**：表示 λRust 中的某个值。**关键引理**：
$$
\text{wp}\; p\; \{v.\; v = JpK \}
$$
**解释**：路径 p 所表示的值是 p 被求值时所归约到的值。
#### **子类型判断的语义解释**

- **定义****语义类型的子类型关系**：$\tau_1 \sqsubseteq_{\text{ty}} \tau_2$**要求**：两个类型的大小相同：
$$
J \tau_1 K.\text{size} = J \tau_2 K.\text{size}
$$
所有权谓词和共享谓词之间存在蕴涵关系（在分离逻辑中，蕴涵变为魔术棒）：
$$
\diamond \forall t, v.\; J \tau_1 K.\text{own}(t, v) -\!\ast J \tau_2 K.\text{own}(t, v)
$$


$$
\diamond \forall \kappa, t, \ell.\; J \tau_1 K.\text{shr}(\kappa, t, \ell) -\!\ast J \tau_2 K.\text{shr}(\kappa, t, \ell)
$$
- **原因**我们需要这种蕴涵关系来验证共享引用的协变性（如 T-bor-shr）。
- **大小相同的必要性**在证明产品类型的协变性（T-prod）时，需要确保两个类型的大小相同，否则内存布局会不一致。
- **子类型判断的语义解释**
$$
E; L \vdash \tau_1 \Rightarrow \tau_2 := \diamond \forall q.\; J L K(q) -\!\ast \diamond (J E K -\!\ast \tau_1 \sqsubseteq_{\text{ty}} \tau_2)
$$
#### **类型强制（Type Coercion）**

- **类型强制的语义解释****与子类型判断的区别**：类型强制使用了视图转换，而不是魔术棒。**原因**：为了支持 C-share，需要使用视图转换。
- **类型上下文的强制**
$$
E; L \vdash T_1 \Rightarrow T_2 := \diamond \forall t, q.\; J E K \ast J L K(q) \ast J T_1 K(t) \equiv-\!\ast_{N_{\text{lft}}, N_{\text{rust}}} J L K(q) \ast J T_2 K(t)
$$
#### **辅助判断：读和写**

- **写入判断**
$$
E; L \vdash \tau_1 \to_\tau \tau_2
$$
**解释**：给定上下文 $E$ 和 $L$ 以及类型为 $\tau_1$ 的值 $v$ 的所有权，我们可以知道 $v$ 实际上是一个位置 $\ell$，并且可以访问 $\ell$ 指向的内存，以便在其中放置一个 $\tau$ 的实例。**关闭部分**：一旦我们在 $\ell$ 处写入了一个有效的 $\tau$ 类型的实例，我们可以取回局部生命周期上下文 $L$ 以及原始值 $v$ 的所有权，现在类型为 $\tau_2$。
- **读取判断**
$$
E; L \vdash \tau_1 \rightsquigarrow_\tau \tau_2
$$
**解释**：给定生命周期上下文和类型为 $\tau_1$ 的值 $v$ 的所有权，我们可以知道 $v$ 是一个位置 $\ell$，并且可以获得对 $\ell$ 处内存的分数所有权（足以读取）。**注意**：这个更新是非原子掩码变化的，消耗当前线程 $t$ 的所有非原子令牌，并在关闭访问器时归还。
#### **类型指令和函数体的语义解释**

- **顶级类型判断的语义解释****指令**
$$
E; L \mid T_1 \vdash I = |x.\; T_2 \quad \Leftrightarrow \quad \{ J E K \ast J L K(1) \ast J T_1 K(t) \ast [ \text{NaInv} : t.> ] \} \; I \; \{ x.\; J L K(1) \ast J T_2 K(t) \ast [ \text{NaInv} : t.> ] \}
$$
**函数体**
$$
E; L \mid K; T \vdash F \quad \Leftrightarrow \quad \{ J E K \ast J L K(1) \ast J K K(t) \ast J T K(t) \ast [ \text{NaInv} : t.> ] \} \; F \; \{ \text{True} \}
$$
- **解释****前置条件**：通过解释所有相关的上下文给出。**非原子借用的访问**：我们可以访问当前线程 $t$ 的所有非原子借用，这对于解释类型和延续上下文非常重要。**后置条件**：指令返回局部生命周期上下文和非原子令牌，并提供更新后的类型上下文 $T_2$。函数体的后置条件为 $\text{True}$，因为函数体不会返回，而是调用延续。
- **结论**这些定义将验证程序语义良类型性归结为标准的 Iris 程序验证。
**全面总结：**

在本节中，作者引入了 **非原子不变式（Non-atomic Invariants）**，以解决在 `Cell` 类型的共享谓词中需要对非原子内存访问进行推理的问题。由于 Iris 的原子不变式只能用于原子操作，而 `Cell` 的修改是非原子的，因此需要一种新的机制。

非原子不变式允许在不改变当前掩码的情况下打开不变式，但需要使用令牌来确保同一个不变式不会被同时打开多次。作者详细介绍了非原子不变式的证明规则，以及如何在 Iris 中实现这些规则。

接下来，作者将 **非原子不变式与生命周期逻辑相结合**，定义了 **非原子借用（Non-atomic Borrows）**。这使得我们能够在共享谓词中使用非原子不变式，同时遵守生命周期逻辑的规则。

在有了所有必要的组件后，作者定义了 **λRust 类型判断的语义解释**。他们解释了标记 Trait（Copy、Send、Sync）的语义，并讨论了类型上下文和延续上下文的解释。特别地，作者深入探讨了子类型判断的语义解释，强调了大小相同的重要性，以及魔术棒在分离逻辑中的作用。

最后，作者给出了顶级类型判断（指令和函数体）的语义解释，将验证程序语义良类型性归结为标准的 Iris 程序验证。这为整个 λRust 类型系统的健全性证明奠定了基础。

通过引入非原子不变式和非原子借用，作者成功地扩展了 Iris 的能力，使其能够处理 Rust 中的 `Cell` 类型和其他需要非原子操作的场景。这对于验证 Rust 程序的安全性，以及理解 Rust 类型系统的健全性具有重要意义。
 #  
 Thought for 21 seconds
**概览：**

您提供的内容来自论文《Understanding and Evolving the Rust Programming Language》的 **第 12 章：语义类型系统的健全性（Semantic Type System Soundness）**，具体是 **12.4.1 节：充足性（Adequacy）**。

本节的主要目标是 **证明定理 5（充足性定理）**，即 **语义良类型的程序在执行时不会达到卡住状态（stuck state）**。作者通过一个具体的函数 $f$ 的例子，展示了如何使用之前定义的语义模型和证明规则，证明当执行 $f$ 时，不会出现卡住的情况。

在证明过程中，作者展开了函数类型的语义解释，使用了之前定义的语义规则和引理，逐步推导出所需的结果。关键步骤包括对上下文和函数体的语义解释，以及使用 Iris 程序逻辑的充足性来得出结论。

**详细解读：**

### **12.4.1 充足性**

#### **目标**

我们需要证明 **定理 5（充足性定理）**，即对于一个语义良类型的函数 $f$，当我们以一个不执行任何操作的延续（no-op continuation）来执行 $f$ 时，程序不会达到卡住状态。

**定理 5（Adequacy）**：

设 $f$ 是一个满足 $\emptyset; \emptyset \mid \emptyset \vdash f = \mid x. x \mathcal{C}\ \text{fn}() \rightarrow \Pi[]$ 的 $\lambda$Rust 函数。当我们使用默认的延续来执行 $f$ 时，没有执行会达到卡住状态，即任何线程都可以继续执行。

#### **证明思路**

我们需要展示，当执行函数 $f$ 时，不会发生卡住状态。为此，我们需要利用之前定义的 **语义模型** 和 **证明规则**，展开函数 $f$ 的类型解释，应用相应的语义规则，最终证明程序的执行是安全的。

#### **详细证明步骤**

1. **假设**存在函数 $f$，满足以下语义良类型的条件：
$$
\emptyset; \emptyset \mid \emptyset \vdash f = \mid x. x \mathcal{C}\ \text{fn}() \rightarrow \Pi[]
$$

- 这里，$\emptyset$ 表示空的上下文，$\mathcal{C}$ 表示类型约束。
- 函数 $f$ 的类型是一个函数，从空参数列表返回一个空的元组 $\Pi[]$。
2. **展开函数类型的语义解释**根据 **语义指令（sem-instr）** 和 **Figure 12.5** 中的函数类型的语义解释，我们可以将上述判断展开为：
$$
\forall k, \varphi.\ \emptyset; \varphi \vdash \emptyset \mid k \mathcal{C}\ \text{cont}(\varphi;\ x.\ x \mathcal{C}\ \text{own}());\ \emptyset \vdash \text{call}\ f()\ \text{ret}\ k
$$

- 这里，$k$ 是一个延续，$\varphi$ 是一个生命周期。
- 我们需要证明，对于任意的 $k$ 和 $\varphi$，上述判断成立。
3. **进一步展开语义函数体的解释**根据 **语义函数体的解释（sem-fn-body）**，上述判断可以进一步展开为：
$$
\forall k, \varphi, t.\ \{ J \varphi K(1) \ast J k \mathcal{C}\ \text{cont}(\varphi;\ x.\ x \mathcal{C}\ \text{own}()) K(t) \ast [\text{NaInv} : t.>] \}\ F\ \{ \text{True} \}
$$

- 这里，$t$ 是线程标识符。
- $J \varphi K(1)$ 是生命周期上下文的语义解释，表示我们拥有生命周期 $\varphi$ 的令牌。
- $J k \mathcal{C}\ \text{cont}(\varphi;\ x.\ x \mathcal{C}\ \text{own}()) K(t)$ 是延续上下文的语义解释，表示延续 $k$ 可以被安全调用。
- $[\text{NaInv} : t.>]$ 是我们拥有线程 $t$ 的所有非原子令牌。
4. **选择具体的延续 $k$**根据充足性定理的陈述，我们选择：
$$
k := (\text{rec}\ k(x) := h)
$$

- 这里，$h$ 是一个不执行任何操作的函数体，即 no-op continuation。
5. **创建新线程和生命周期**
- 使用 **NAInv-new-pool**，我们可以创建一个新的线程标识符 $t$，并拥有它的所有非原子令牌 $[\text{NaInv} : t.>]$。
- 使用 **LftL-begin**，我们可以创建一个生命周期 $\varphi$ 并拥有它的令牌，这意味着 $J \varphi K(1)$ 成立。
6. **验证延续 $k$ 的类型**
- 我们需要验证 $k$ 满足类型 $\text{cont}(\varphi;\ x.\ x \mathcal{C}\ \text{own}())$。
- 这需要我们证明，当给 $k$ 一个类型为 $\text{own}()$ 的值时，$k$ 可以安全执行，并返回 $\text{True}$。
7. **应用 Iris 程序逻辑的充足性**
- 根据 Iris 程序逻辑的充足性，我们知道，如果程序在给定前置条件下被验证，那么它的执行是安全的，不会卡住。
- 我们已经证明了 $f$ 在给定的前置条件下是语义良类型的，因此它的执行是安全的。
8. **结论**
- 综上所述，我们证明了当执行函数 $f$ 时，程序不会达到卡住状态。
#### **注释**

- 在步骤 2 和 3 中，作者提到了 **“展开”**（unfold），这意味着根据之前定义的语义解释，将类型判断和函数体的语义表示出来。
- 在步骤 4 中，选择具体的延续 $k$ 有助于具体化证明过程，使得后续的验证更加明确。
- 步骤 6 中，验证延续 $k$ 的类型涉及到确保延续在给定的上下文和类型下是安全的，这需要检查类型上下文和延续上下文的语义解释。
- 步骤 7 中，Iris 程序逻辑的充足性是关键，它将程序的语义良类型性与实际的程序执行联系起来。
**全面总结：**

在 **12.4.1 节：充足性** 中，作者证明了 **定理 5（充足性定理）**，即 **语义良类型的程序在执行时不会达到卡住状态**。通过对特定函数 $f$ 的分析，作者展示了如何使用之前建立的语义模型和证明规则，验证程序的执行安全性。

具体来说，作者从假设 $f$ 满足特定的类型判断开始，逐步展开类型和函数体的语义解释，应用语义规则和证明规则，验证延续的类型，并最终应用 Iris 程序逻辑的充足性得出结论。

这证明了 **语义类型系统的健全性**，即只要程序在类型系统中被证明为语义良类型，那么它在实际执行时就是安全的，不会出现运行时错误或卡住的情况。这对于 Rust 语言的安全性保证和类型系统的设计具有重要意义。

通过本节的学习，我们理解了如何从类型系统的语义解释出发，结合程序逻辑的充足性，证明程序的执行安全性。这种方法在形式化验证和编程语言理论中具有广泛的应用，对于确保复杂系统的可靠性和安全性至关重要。
 #  
 Thought for 29 seconds
**概览：**

您提供的内容来自论文《Understanding and Evolving the Rust Programming Language》的 **第 12 章：语义类型系统的健全性**，具体是 **12.5 节：λRust 的基本定理（The fundamental theorem of λRust）**。

在之前的章节中，作者完成了 λRust 类型系统的语义解释。这使得他们准备验证 **定理 4：逻辑关系的基本定理**，即对于类型系统中的每一个推理规则，当我们将所有的语法判断（`⊢`）替换为其语义解释（`|=`）时，我们必须证明由此得到的 Iris 定理。

本节的主要目标是：

1. **验证几个关键的类型规则的语义正确性**：作者选择了一些有趣的类型规则，包括 `C-share`、`Tread-own-move`、`S-deref-bor-mut` 和 `F-newlft`，并详细展示了它们的语义证明。
2. **展示如何在语义模型中进行证明**：通过详细的证明过程，展示如何使用之前定义的语义模型和证明规则，验证类型规则在语义上的正确性。
3. **强调生命周期逻辑的重要性**：在证明过程中，展示生命周期逻辑如何处理复杂的情况，使得类型规则的语义证明得以成立。
**详细解读：**

### **12.5 λRust 的基本定理**

#### **背景**

- **语义解释的完成**：作者已经完成了 λRust 类型系统的语义解释，这意味着他们可以开始验证 **定理 4：逻辑关系的基本定理**。
- **定理 4 的内容**：对于类型系统中的任何推理规则，当我们将所有的 `⊢` 替换为 `|=`（即用语义解释替换语法判断），我们需要证明由此产生的 Iris 定理。
- **目标**：虽然不可能对每一个类型规则都进行详细证明，但作者选择了一些有趣的规则进行验证，展示了证明过程中的关键步骤。
#### **语义正确性的证明**

##### **1. C-share 规则的语义正确性**

**规则描述**：

- **C-share**：负责将一个可变引用（mutable reference）转换为共享引用（shared reference）。
- **目的**：证明在语义上，我们可以从类型 `&_{κ}^{mut} τ` 推导出类型 `&_{κ}^{shr} τ`。
**需要证明的语义定理**：
\text{C-share-sem} \quad E; L |= κ\ \text{alive} \quad E; L |= p\ \mathcal{C}\ &_{κ}^{mut} τ ⇒ p\ \mathcal{C}\ &_{κ}^{shr} τ
- **解释**：在外部生命周期上下文 E 和局部生命周期上下文 L 下，如果生命周期 κ 存活，并且路径 p 具有类型 &_{κ}^{mut} τ，那么我们可以将其类型转换为 &_{κ}^{shr} τ。
**证明大纲**（见 **Figure 12.9**）：

- **目标**：\forall t, q.\ \text{JEK} ∗ \text{JLK}(q) ∗ Jp\ \mathcal{C}\ &_{κ}^{mut} τ K(t) ≡−∗_{N_{\text{lft}}, N_{\text{rust}}} \text{JLK}(q) ∗ Jp\ \mathcal{C}\ &_{κ}^{shr} τ K(t)**解释**：我们需要在 Iris 中证明一个视图转换，从拥有类型 &_{κ}^{mut} τ 的 p，转换为拥有类型 &_{κ}^{shr} τ，在视图转换过程中，我们需要管理生命周期上下文和所有权。
- **证明步骤**：**引入持久性模态**：使用 ``（读作 "later"）模态和视图转换的假设。**实例化 liveness 判断**：使用生命周期存活性的判断，从 `E; L |= κ\ \text{alive}` 中获得生命周期 `κ` 的令牌。**打开访问器**：使用 `JLK(q)`，打开借用，获取关闭视图转换。**展开所有权谓词**：展开 `J&_{α}^{mut} _ K.\text{own}`，根据 `mut-ref-own` 的定义。J&_{α}^{mut} _ K.\text{own}(t, v) = [JκK]_{q'} ∗ &_{JκK}^{\text{full}} \exists w.\ JpK 7→ w ∗ Jτ K.\text{own}(t, w)**应用 ty-share 规则**：使用 `ty-share`，将完整借用转换为共享谓词。&_{JκK}^{\text{full}} \exists w.\ JpK 7→ w ∗ Jτ K.\text{own}(t, w) \equiv−∗_{N_{\text{lft}}} Jτ K.\text{shr}(JκK, t, JpK)**应用关闭视图转换**：将所有内容重新组合，得到目标。**折叠共享引用的所有权谓词**：使用 `shr-ref-own`，将结果表达式折叠为 `Jp\ \mathcal{C}\ &_{κ}^{shr} τ K(t)`。
**总结**：

- 整个证明主要是展开定义，应用已知的规则（如 ty-share），并管理好生命周期和借用的令牌。
##### **2. Tread-own-move 规则的语义正确性**

**规则描述**：

- **Tread-own-move**：允许我们从 `\text{own}_{m} τ` 中移动出 `τ`，留下一个 `\text{own}_{m} n`，其中 `n` 是 `τ` 的大小。
- **目的**：证明在语义上，我们可以从类型 `\text{own}_{m} τ` 转换为 `\text{own}_{m} n`。
**需要证明的语义定理**：

$$
\text{Tread-own-move-sem} \quad n = \text{size}(τ) \quad Γ \mid E; L |= \text{own}_{m} τ ⇒ \text{own}_{m} n
$$

**证明大纲**（见 **Figure 12.10**）：

- **展开所有权谓词**：展开 `J\text{own}_{m} τ K.\text{own}`，根据 `own-ptr-own` 的定义。
$$
J\text{own}_{m} τ K.\text{own}(t, [v]) = v = ` ∗ ` 7→ w ∗ .\ Jτ K.\text{own}(t, w) ∗ \text{Dealloc}(`, Jτ K.\text{size}, n)
$$
- **使用 ty-size**：根据 `ty-size`，我们知道 `w` 的大小为 `\text{size}(τ)`，即 `|w| = n`。
- **目标**：需要证明我们可以将所有权转换为 `\text{own}_{m} n`。
- **使用 uninit-own**：根据 `uninit-own`，对于未初始化的内存，我们只需要证明 `w` 的长度正确。
$$
J n K.\text{own}(t, w) ∗−∗ |w| = n
$$
- **折叠所有权谓词**：将结果表达式折叠为 `J\text{own}_{m} n K.\text{own}(t, v)`。
**总结**：

- 通过展开定义和使用已知的引理，我们可以证明从 \text{own}_{m} τ 到 \text{own}_{m} n 的类型转换是语义正确的。
##### **3. S-deref-bor-mut 规则的语义正确性**

**规则描述**：

- **S-deref-bor-mut**：展示了如何处理可变引用的“延迟共享”，验证从共享引用的可变引用中解引用得到共享引用。
- **目的**：证明在语义上，我们可以从类型 `&_{κ}^{shr} &_{κ'}^{mut} τ` 解引用得到 `&_{κ}^{shr} τ`。
**需要证明的语义定理**：
\text{S-deref-shr-mut-sem} \quad E; L |= κ\ \text{alive} \quad E; L |= κ \sqsubseteq κ' \quad E; L \mid p\ \mathcal{C}\ &_{κ}^{shr} &_{κ'}^{mut} τ |= ∗p = |x.\ x\ \mathcal{C}\ &_{κ}^{shr} τ
- **解释**：在外部生命周期上下文 E 和局部生命周期上下文 L 下，如果生命周期 κ 存活，并且 κ 包含于 κ'，并且路径 p 具有类型 &_{κ}^{shr} &_{κ'}^{mut} τ，那么执行 ∗p 后，我们得到一个类型为 &_{κ}^{shr} τ 的值。
**证明大纲**（见 **Figure 12.11**）：

- **展开共享引用的所有权谓词**：使用 `shr-ref-own` 展开 `J&_{κ}^{shr} _ K.\text{own}`。
- **使用生命周期存活性**：从 `E; L |= κ\ \text{alive}` 中获得生命周期 `κ` 的令牌。
- **需要两个生命周期令牌**：我们需要两个 `κ` 的令牌，因此使用 `LftL-tok-fract` 将令牌分成两份。
- **第一个令牌的用途**：用于获取对 JpK_{q} 7→ \_ 的访问，这来自于展开共享和可变引用时获得的分数借用。
- **第二个令牌的用途**：转换为 `κ ∩ κ'` 的令牌，使用 `LftL-incl-glb` 和我们的假设 `κ \sqsubseteq κ'`。这个令牌用于使用展开可变引用时获得的“延迟共享”断言：\ \forall q.\ [Jκ' ∩ JκK]_q −∗ |V_{N_{\text{shr}} ∪ N_{\text{lft}}} N_{\text{lft}} .\ |V_{N_{\text{lft}}} N_{\text{shr}} ∪ N_{\text{lft}} Jτ K.\text{shr}(Jκ' ∩ JκK, t, `₀) ∗ [Jκ' ∩ JκK]_q
- **消除模态**：使用 `wp-step`（第 75 页），消除“延迟共享”中的三个模态。这意味着在执行 `∗p` 后，我们获得了 `τ` 的共享谓词，并且拿回了之前投入的生命周期令牌。
- **关闭视图转换**：将所有内容重新组合，应用 `ty-shr-mono`，得到目标。
**总结**：

- 这个证明展示了如何在语义模型中处理可变引用的“延迟共享”，以及生命周期逻辑在其中的作用。
##### **4. F-newlft 规则的语义正确性**

**规则描述**：

- **F-newlft**：用于开始一个新的生命周期。
- **目的**：证明在语义上，我们可以在上下文中引入一个新的生命周期。
**需要证明的语义定理**：

$$
\text{F-newlft-sem} \quad \forall α.\ E; L, α\ \text{vl}\ κ \mid K; T |= F \quad E; L \mid K; T |= \text{newlft}; F
$$

- **解释**：在外部生命周期上下文 E、局部生命周期上下文 L，以及延续上下文 K 和类型上下文 T 下，如果对于所有的 α，有 E; L, α\ \text{vl}\ κ \mid K; T |= F，那么我们可以在执行 \text{newlft}; F 时保持语义良类型性。
**证明大纲**（见 **Figure 12.12**）：

- **应用 LftL-begin**：使用生命周期逻辑的规则 `LftL-begin`，创建新的生命周期 `κ`，并拥有其令牌。
- **定义新的生命周期 α**：定义 α := κ ∩ κ，这与我们在 **12.1 节** 中设置的外部生命周期上下文的解释相匹配。
- **折叠生命周期包含关系**：使用 `Jα\ \text{vl}\ κ K`，根据 **Figure 12.1**。
- **应用假设**：使用假设 `∀ α.\ ...`，将证明过程继续下去。
**关键点**：

- **本质**：新的生命周期 `α` 并不等于由生命周期逻辑生成的生命周期 `κ`，而是取 `α := κ ∩ κ`。
- **对应的类型系统规则**：这对应于类型系统中的 `Lalive-local`（第 115 页），它说明了局部生命周期何时存活。
- **重要性**：指出即使是局部生命周期，也可能在其超生命周期结束后死亡，因为局部生命周期上下文只拥有与所有其他生命周期相交的额外生命周期 `κ` 的令牌。
**总结**：

- 这个证明展示了如何在语义模型中处理新的生命周期的引入，以及生命周期逻辑在其中的作用。
#### **结论**

- **整体总结**：通过上述证明，作者展示了如何验证类型系统中的关键规则的语义正确性。
- **逻辑关系的基本定理（定理 4）**：为了获得定理 4，需要对每一个类型规则完成类似的证明。
- **验证的困难**：手动验证所有的类型规则既繁琐又容易出错，因此作者在 Coq 中完成了这些验证。
- **关键挑战**：构建 λRust 的语义模型的关键挑战在于找到正确的定义，使得所有部分都能协调一致。几乎所有复杂的部分都已经在生命周期逻辑中处理了。
**全面总结：**

在本节中，作者验证了 **λRust 类型系统的基本定理（定理 4）**，即对于类型系统中的每一个推理规则，当我们将所有的 `⊢` 替换为 `|=`（即用语义解释替换语法判断），都可以在 Iris 中证明由此产生的定理。

作者选择了几个有趣的类型规则进行详细的语义证明，包括：

1. **C-share**：将可变引用转换为共享引用。
2. **Tread-own-move**：从拥有指针中移动出一个值，留下未初始化的内存。
3. **S-deref-bor-mut**：解引用共享引用的可变引用，得到共享引用。
4. **F-newlft**：开始一个新的生命周期。
在这些证明中，作者展示了如何展开类型的语义解释，应用生命周期逻辑的规则，以及如何使用已知的引理和性质来完成证明。特别地，生命周期逻辑在处理复杂的情况（如延迟共享和生命周期管理）中起到了关键作用。

通过这些证明，作者展示了 λRust 类型系统的语义模型是健全的，类型规则在语义上是正确的。这对于验证 Rust 程序的安全性和类型系统的健全性具有重要意义。

然而，手动验证所有的类型规则既繁琐又容易出错，因此作者在 Coq 中完成了这些验证。构建 λRust 的语义模型的关键挑战在于找到正确的定义，使得所有部分都能协调一致。

总体而言，本节完成了对 λRust 类型系统的语义验证，为证明 Rust 的安全性和类型系统的健全性奠定了坚实的基础。
 #  
 Thought for 57 seconds
**概览：**

您提供的内容来自论文《Understanding and Evolving the Rust Programming Language》的 **第 12 章：语义类型系统的健全性**，具体是 **12.5 节：λRust 的基本定理（The fundamental theorem of λRust）**。

在前面的章节中，作者已经完成了对 λRust 类型系统的语义解释。这意味着他们现在准备验证 **定理 4：逻辑关系的基本定理**。该定理的核心是，对于类型系统中的任何推理规则，当我们将所有的 `⊢`（语法判断）替换为 `|=`（语义解释），需要在 Iris 中证明由此产生的定理。

本节的主要目标是：

1. **验证关键类型规则的语义正确性**：虽然不可能对每个类型规则都进行详细证明，但作者选择了一些有趣且具有代表性的规则进行验证，包括 `C-share`、`Tread-own-move`、`S-deref-bor-mut` 和 `F-newlft` 等。
2. **展示如何在语义模型中进行证明**：通过详细的证明过程，展示如何使用之前定义的语义模型和证明规则，验证类型规则在语义上的正确性。
3. **强调生命周期逻辑的重要性**：在证明过程中，展示生命周期逻辑如何处理复杂的情况，使得类型规则的语义证明得以成立。
**详细解读：**

### **12.5 λRust 的基本定理**

#### **背景**

在完成了 λRust 类型系统的语义解释之后，作者准备验证 **定理 4：逻辑关系的基本定理**。

**定理 4（逻辑关系的基本定理）**：

对于类型系统中给出的任何推理规则，当我们将所有的 `⊢`（语法判断）替换为 `|=`（语义解释），我们需要在 Iris 中证明由此产生的定理。

**目标**：

虽然不可能对每一个类型规则都进行详细证明，但作者选择了一些关键的、具有代表性的类型规则进行验证，展示了如何在语义模型中进行证明。

#### **语义正确性的证明**

##### **1. C-share 规则的语义正确性**

**规则描述**：

- **C-share**：负责将一个可变引用（&_{κ}^{mut} τ）转换为共享引用（&_{κ}^{shr} τ）。
- **动机**：多次提到了 ty-share 的动机，即将可变引用共享给多个使用者。
**需要证明的语义定理**：

我们需要证明以下语义判断：

**C-share-sem**：

给定外部生命周期上下文 `E` 和局部生命周期上下文 `L`，如果生命周期 `κ` 存活，那么：

$$
E; L |= κ\ \text{alive}
$$

并且：
E; L |= p\ \mathcal{C}\ &_{κ}^{mut} τ ⇒ p\ \mathcal{C}\ &_{κ}^{shr} τ
**证明思路**：

- **展开所有内容**：首先展开类型的语义解释，特别是可变引用和共享引用的所有权谓词。
- **应用生命周期存活性判断**：使用 κ 的存活性来获取其生命周期令牌的一部分。
- **应用 ty-share 规则**：利用生命周期令牌，应用 ty-share，将可变引用的所有权转换为共享引用的共享谓词。
- **重新折叠**：将所有展开的内容重新组合，得到目标的语义判断。
**证明步骤**（参见 **Figure 12.9**）：

1. **引入持久性模态**：使用持久性模态 `\diamond`（读作 "later"）引入证明的前提。
2. **实例化 liveness 判断**：使用 `κ` 的存活性判断，从 `E; L |= κ\ \text{alive}` 中获得生命周期 `κ` 的令牌 `[κ]_q`。
3. **打开访问器**：利用局部生命周期上下文 `JLK(q)`，打开借用，获取关闭视图转换。
4. **展开可变引用的所有权谓词**：根据 `mut-ref-own` 的定义，展开 `J&_{κ}^{mut} \_ K.\text{own}`：J&_{κ}^{mut} τ K.\text{own}(t, v) = [κ]_{q'} \ast &_{κ}^{\text{full}} \exists w.\ v = JpK \wedge JpK 7→ w \ast Jτ K.\text{own}(t, w)
5. **应用 ty-share**：使用 `ty-share`，将完整借用 `&_{κ}^{\text{full}}` 转换为共享谓词：&_{κ}^{\text{full}} \exists w.\ JpK 7→ w \ast Jτ K.\text{own}(t, w) \equiv−∗_{N_{\text{lft}}} Jτ K.\text{shr}(κ, t, JpK)
6. **应用关闭视图转换**：将所有内容重新组合，得到目标的语义判断。
7. **折叠共享引用的所有权谓词**：使用 `shr-ref-own`，将结果表达式折叠为 `Jp\ \mathcal{C}\ &_{κ}^{shr} τ K(t)`。
**总结**：

整个证明过程主要是展开类型的语义定义，利用生命周期逻辑和已知的规则，如 `ty-share`，在语义层面上验证类型规则的正确性。

##### **2. Tread-own-move 规则的语义正确性**

**规则描述**：

- **Tread-own-move**：允许我们从一个拥有的指针（ownm τ）中移动出类型为 τ 的值，留下一个未初始化的内存（ownm n），其中 n 是 τ 的大小。
- **动机**：实现对拥有的值的移动语义，同时确保内存安全。
**需要证明的语义定理**：

我们需要证明以下语义判断：

**Tread-own-move-sem**：

设 `n = \text{size}(τ)`，那么：

$$
Γ \mid E; L |= \text{ownm} τ ⇒ \text{ownm} n
$$

**证明思路**：

- **展开所有权谓词**：展开 J\text{ownm} τ K.\text{own} 的定义，得到指针的地址和内容。
- **使用 ty-size**：根据 ty-size，确定类型 τ 的大小，确保内存长度匹配。
- **使用 uninit-own**：对于未初始化的内存，只需要证明内存有正确的大小，而不关心其内容。
- **重新折叠**：将结果表达式折叠为 J\text{ownm} n K.\text{own}。
**证明步骤**（参见 **Figure 12.10**）：

1. **展开 J\text{ownm} τ K.\text{own}**：根据 `own-ptr-own` 的定义，展开所有权谓词：
$$
J\text{ownm} τ K.\text{own}(t, [v]) = v = ` \wedge ` 7→ w \ast .\ Jτ K.\text{own}(t, w) \ast \text{Dealloc}(`, \text{size}(τ), n)
$$
2. **使用 ty-size**：由 `ty-size`，我们知道 `w` 的长度为 `\text{size}(τ)`，即 `|w| = n`。
3. **使用 uninit-own**：根据 `uninit-own` 引理，对于未初始化的内存，只需要证明 `w` 的长度为 `n`。
$$
J n K.\text{own}(t, w) ∗−∗ |w| = n
$$
4. **折叠所有权谓词**：将结果表达式折叠为 `J\text{ownm} n K.\text{own}(t, v)`。
**总结**：

通过展开定义和应用已知的引理，我们证明了从 `\text{ownm} τ` 到 `\text{ownm} n` 的类型转换在语义上是正确的。这确保了移动语义的安全性，同时维护了内存的一致性。

##### **3. S-deref-bor-mut 规则的语义正确性**

**规则描述**：

- **S-deref-bor-mut**：展示了如何从共享引用的可变引用中解引用，得到共享引用。这涉及到可变引用的“延迟共享”机制。
- **动机**：允许在共享上下文中安全地解引用可变引用，获取共享引用。
**需要证明的语义定理**：

我们需要证明以下语义判断：

**S-deref-shr-mut-sem**：

给定外部生命周期上下文 `E` 和局部生命周期上下文 `L`，如果生命周期 `κ` 存活，并且 `κ` 包含于 `κ'`，那么：

$$
E; L |= κ\ \text{alive}
$$


$$
E; L |= κ \sqsubseteq κ'
$$

并且：
E; L \mid p\ \mathcal{C}\ &_{κ}^{shr} &_{κ'}^{mut} τ |= ∗p = |x.\ x\ \mathcal{C}\ &_{κ}^{shr} τ
**证明思路**：

- **展开共享引用的所有权谓词**：展开 J&_{κ}^{shr} \_ K.\text{own}，得到对可变引用的共享谓词。
- **使用生命周期存活性**：从 κ\ \text{alive} 中获得生命周期令牌 [κ]_q。
- **分割生命周期令牌**：因为需要两个 κ 的令牌，使用 LftL-tok-fract 将令牌分成两部分。
- **处理延迟共享**：使用第二个令牌，利用可变引用的“延迟共享”机制，获取 τ 的共享谓词。
- **执行解引用**：在程序执行过程中，使用 wp-step 消除模态，获取所需的共享谓词。
- **重新组合**：将所有资源重新组合，得到目标的语义判断。
**证明步骤**（参见 **Figure 12.11**）：

1. **展开 J&_{κ}^{shr} \_ K.\text{own}**：根据 `shr-ref-own` 的定义，展开共享引用的所有权谓词。
2. **获取生命周期令牌**：使用 `κ\ \text{alive}`，获得生命周期令牌 `[κ]_q`。
3. **分割令牌**：使用 `LftL-tok-fract`，将令牌 `[κ]_q` 分割成两份。
4. **打开分数借用**：利用第一份令牌，打开分数借用，获取指针的地址。
5. **处理延迟共享**：使用第二份令牌，结合 `κ \sqsubseteq κ'`，获取 `κ ∩ κ'` 的令牌，应用延迟共享的断言，获取 `τ` 的共享谓词。
6. **执行解引用**：使用程序逻辑的 `wp-step`，执行解引用操作，消除模态，获取共享谓词。
7. **重新组合**：使用关闭视图转换，将所有资源重新组合。
8. **应用 ty-shr-mono**：使用 `ty-shr-mono`，确保共享谓词的单调性，得到目标的语义判断。
**总结**：

这个证明展示了如何在语义模型中处理可变引用的“延迟共享”机制，以及如何在共享上下文中安全地解引用可变引用，获取共享引用。生命周期逻辑在处理复杂的资源管理和权限转移中起到了关键作用。

##### **4. F-newlft 规则的语义正确性**

**规则描述**：

- **F-newlft**：用于在程序中引入新的生命周期。
- **动机**：管理生命周期的嵌套和作用域，确保资源的正确释放。
**需要证明的语义定理**：

我们需要证明以下语义判断：

**F-newlft-sem**：

如果对于所有的 `α`，都有：

$$
∀α.\ E; L, α\ \text{vl}\ κ \mid K; T |= F
$$

那么：

$$
E; L \mid K; T |= \text{newlft}; F
$$

**证明思路**：

- **应用生命周期逻辑的规则**：使用 LftL-begin，开始一个新的生命周期 κ，并获取其令牌。
- **定义新的生命周期 α**：定义 α := κ ∩ κ，这与之前定义的外部生命周期上下文的解释相一致。
- **折叠生命周期包含关系**：使用 Jα\ \text{vl}\ κ K，根据生命周期逻辑的定义。
- **应用假设**：使用假设，对于新的 α，有 E; L, α\ \text{vl}\ κ \mid K; T |= F，因此可以继续证明。
**证明步骤**（参见 **Figure 12.12**）：

1. **应用 LftL-begin**：开始新的生命周期 `κ`，获得生命周期令牌 `[κ]_1`。
2. **定义 α**：设定 `α := κ ∩ κ`。
3. **折叠生命周期包含关系**：使用生命周期逻辑，得到 `Jα\ \text{vl}\ κ K(1)`。
4. **组合资源**：将新的生命周期令牌和原有的资源组合。
5. **应用假设**：根据假设，对于新的 `α`，有 `E; L, α\ \text{vl}\ κ \mid K; T |= F`，因此可以完成证明。
**关键点**：

- **生命周期的选择**：新的生命周期 `α` 并不等于 `κ`，而是选择 `α := κ ∩ κ`，这与外部生命周期上下文的解释相匹配。
- **对应的类型系统规则**：这对应于类型系统中的 `Lalive-local` 规则，它说明了局部生命周期何时存活。
- **重要性**：指出即使是局部生命周期，也可能在其超生命周期结束后死亡，因为局部生命周期上下文只拥有与所有其他生命周期相交的额外生命周期 `κ` 的令牌。
**总结**：

这个证明展示了如何在语义模型中处理新的生命周期的引入，以及生命周期逻辑在管理生命周期嵌套和资源释放中的作用。

#### **结论**

- **验证定理 4**：通过上述关键类型规则的语义证明，作者展示了 λRust 类型系统的语义模型是健全的，即类型系统中的推理规则在语义上是正确的。
- **验证的复杂性**：手动验证所有的类型规则既繁琐又容易出错，因此作者在 Coq 中完成了这些验证。
- **关键挑战**：构建 λRust 的语义模型的关键挑战在于找到正确的定义，使得所有部分都能协调一致。生命周期逻辑在处理复杂的资源管理、权限转移和类型规则的语义证明中起到了关键作用。
**全面总结：**

在 **12.5 节：λRust 的基本定理** 中，作者验证了 λRust 类型系统的关键类型规则的语义正确性，从而证明了 **定理 4：逻辑关系的基本定理**。该定理表明，对于类型系统中的任何推理规则，当我们将语法判断替换为语义解释，都可以在 Iris 中证明其正确性。

作者选择了几个具有代表性的类型规则，包括 `C-share`、`Tread-own-move`、`S-deref-bor-mut` 和 `F-newlft`，详细展示了它们的语义证明过程。这些证明强调了生命周期逻辑在资源管理、权限转移和类型规则的语义验证中的重要性。

通过展开类型的语义定义，应用生命周期逻辑的规则和已知的引理，作者成功地在语义层面上验证了类型规则的正确性。这确保了 λRust 类型系统的健全性，保证了程序在类型系统中的推理在实际执行中是安全的。

然而，手动验证所有的类型规则既繁琐又容易出错，因此作者在 Coq 中进行了这些验证。构建 λRust 的语义模型的关键挑战在于找到正确的定义，使得所有部分都能协调一致。

总体而言，本节完成了对 λRust 类型系统的语义验证，为证明 Rust 编程语言的安全性和类型系统的健全性奠定了坚实的基础。这对于形式化验证、编程语言理论和安全关键系统的开发具有重要意义。
 #  
 Thought for 8 seconds
**概览：**

您提供的内容来自论文《Understanding and Evolving the Rust Programming Language》的 **第 13 章：对具有内部可变性的类型的建模**，具体是 **13.1 节：Cell**。

本章讨论了 Rust 标准库中提供的具有内部可变性的类型，例如 `Cell`、`RefCell`、`Mutex` 等。这些类型使用了 Rust 的 `unsafe` 特性进行编写，但它们对客户端代码来说是安全的，因为它们通过良类型的抽象封装了不安全的部分。

作者的目标是证明这些类型的安全性，为此需要：

1. **选择这些类型的语义解释**：为这些库导出的抽象类型（例如 `Cell<T>`）选择适当的语义解释（参见第 10 章）。
2. **证明库中每个公开导出的函数都满足其类型的语义解释**。
在建模具有内部可变性的类型时，最困难的部分通常是 **共享谓词 $J\tau K.\text{shr}$ 的定义**。对于这些类型，$J\tau K.\text{shr}$ 不同于简单类型的只读共享谓词（参见第 10.4 节），而且会根据允许的操作而有很大差异。

本节的主要目标是：

- **定义 Cell 的语义解释**：即 $J\text{cell}(\tau)K$，使得 `Cell::get` 和 `Cell::replace` 等操作在语义上是良类型的。
- **探讨共享谓词的定义**：由于 `Cell` 允许通过共享引用进行读写，因此需要一个特殊的共享谓词。
**详细解读：**

### **13.1 Cell**

#### **背景**

在第 8.6 节中，我们已经看到 `Cell<T>` 存储类型为 `T` 的值，并提供了两个核心函数：

- Cell::get：用于从 Cell 中读取值。
- Cell::replace：用于向 Cell 中写入新值，并返回之前存储的旧值。
它们的类型为：

```rust
Cell::get : fn(&Cell) -> T where T: Copy
Cell::replace : fn(&Cell, T) -> T
```

在 λRust 中，它们的类型可以翻译为：

- `get`：\tau\ \text{copy} \Rightarrow \forall \alpha.\ \text{fn}(\varphi : \varphi\ \text{vl}\ \alpha;\ &^{\alpha}_{\text{shr}}\ \text{cell}(\tau)) \rightarrow \tau
- `replace`：\forall \alpha.\ \text{fn}(\varphi : \varphi\ \text{vl}\ \alpha;\ &^{\alpha}_{\text{shr}}\ \text{cell}(\tau),\ \tau) \rightarrow \tau
**目标**：

- 定义 cell(τ) 的语义解释 $J\text{cell}(\tau)K$，使得上述操作在语义上是良类型的。
#### **13.1.1 Cell 的语义解释**

**所有权谓词的定义**

- **结论**：`cell(τ)` 的所有权与 `τ` 相同。
- **具体定义**：**大小**：
$$
J\text{cell}(\tau)K.\text{size} := J\tau K.\text{size}
$$
**所有权谓词**：
$$
J\text{cell}(\tau)K.\text{own}(t, v) := J\tau K.\text{own}(t, v) \quad \text{(cell-own)}
$$
- **解释**：这在 Rust 标准库中也是可观察到的，`Cell::new` 和 `Cell::into_inner` 函数可以在 `T` 和 `Cell<T>` 之间进行转换，实际上就是恒等函数。换句话说，每个拥有的 `τ` 也是拥有的 `cell(τ)`，反之亦然。
**共享谓词的定义**

- **挑战**：`Cell::get` 和 `Cell::replace` 可以在只有 `&Cell<T>` 的情况下调用，即通过共享引用进行读写。这意味着 `Cell<i32>` 的共享谓词必须与 `i32` 的共享谓词不同，后者仅提供只读访问。
- **目标**：为了验证 `replace`，我们需要在函数调用期间获得对内存的完全（读/写）访问。重要的是，所有对 `Cell` 的共享引用都被限制在单个线程内，因为 `get` 和 `replace` 操作不是线程安全的。Rust 通过声明 `Cell` 不是 `Sync` 来强制执行这一点，这等价于说 `&Cell` 不是 `Send`，因此对 `Cell` 的共享引用不能被发送到其他线程。
- **解决方案**：使用 **非原子借用（non-atomic borrows）**，如第 12.3 节所述。
- **共享谓词的定义**：J\text{cell}(\tau)K.\text{shr}(\kappa, t, \ell) := &^{\kappa}_{t.N_{\text{shr}}.\ell}\ \!\!\!\!\!\!\!\!\!\!\text{na}\ \exists v.\ \ell \mapsto v \ast J\tau K.\text{own}(t, v)\quad \text{(cell-shr)}**符号解释**：$&^{\kappa}*{t.N*{\text{shr}}.\ell}\ !!!!!!!!!!\text{na}\ P$：在池（pool）`t` 中的命名空间 `N_{\text{shr}}.\ell` 下的非原子借用。$\exists v.\ \ell \mapsto v \ast J\tau K.\text{own}(t, v)$：存在一个值 `v`，使得地址 `\ell` 存储 `v`，并且 `v` 满足类型 `τ` 的所有权谓词。**解释**：我们在池 `t` 中的命名空间 `N_{\text{shr}}.\ell` 下，借用了 `\ell` 处的内存，并拥有其内容 `v` 的所有权。这确保了共享引用只能在创建它们的线程 `t` 中使用。
- **关于命名空间的说明**：命名空间为非原子不变式使用了 `N_{\text{shr}}.\ell`，并在池 `t` 中。我们之前在定义 `|\! = \tau\ \text{copy}` 时已经看到使用位置来构造命名空间。事实上，`|\! = \tau\ \text{copy}` 的定义是精心选择的，以允许 `cell(τ)` 成为 `Copy`。
**良构性（Well-formedness）**

- **要求**：为了确保 $J\text{cell}(\tau)K$ 是一个良构的语义类型，我们需要验证 **Figure 12.4** 中的条件。
- **验证过程**：**ty-size**：由于 $J\tau K$ 满足 ty-size，因此 $J\text{cell}(\tau)K$ 也满足。**ty-shr-persist**（共享谓词的持久性）：由 LftL-na-persist 得到。**ty-shr-mono**（共享谓词的单调性）：由 LftL-na-shorten 得到。**ty-share**（共享规则）：我们需要证明：&^{\kappa}_{\text{full}}\ \exists w.\ \ell \mapsto w \ast J\tau K.\text{own}(t, w)\quad \ast [\kappa]_q \equiv-\!\ast_{N_{\text{lft}}}\ &^{\kappa}_{t.N_{\text{shr}}.\ell}\ \!\!\!\!\!\!\!\!\!\!\text{na}\ \exists v.\ \ell \mapsto v \ast J\tau K.\text{own}(t, v)\quad \ast [\kappa]_q**解释**：从完整借用开始，我们需要得到共享谓词。**证明**：直接通过 `LftL-bor-na` 得到。我们甚至不需要生命周期令牌（lifetime token）。
**标记 Trait**

- **Copy**：我们需要证明，当 $|! = \tau\ \text{copy}$ 时，有 $|! = \text{cell}(\tau)\ \text{copy}$。**证明大纲**（参见 **Figure 13.1**）：**特殊情况：大小为零的类型**：对于大小为零的 `Copy` 类型，一切都是持久的，因为不需要拥有任何内存来访问它们。我们可以证明：
$$
J\text{cell}(\tau)K.\text{shr}(\kappa, t, \ell) -\!\ast\ \left( [\text{NaInv} : t.N_{\text{shr}}.\ell] \ast [\kappa]_q\ \overset{N_{\text{shr}}, N_{\text{lft}}}{\longleftrightarrow}\ [\text{NaInv} : t.N_{\text{shr}}.\ell] \ast .\ J\tau K.\text{own}(t, \varepsilon) \right)
$$
$\varepsilon$ 表示空值。**证明**：使用 `LftL-na-acc` 打开非原子借用。由于 $|! = \tau\ \text{copy}$，`J\tau K.\text{own}(t, v)` 是持久的，因此我们可以复制它。关闭非原子借用。**结论**：由于 `ty-size`，$v = \varepsilon$，完成了访问器。这个访问器对于非原子“掩码”来说是不改变掩码的。因此，$|! = \text{cell}(\tau)\ \text{copy}$ 成立，因为 `\ell \mapsto \varepsilon` 是平凡的（`lrust-heap-nil`，第 133 页）。**一般情况：大小不为零**：我们需要证明：
$$
J\text{cell}(\tau)K.\text{shr}(\kappa, t, \ell) -\!\ast\ \left( [\text{NaInv} : t.N_{\text{shr}}.\ell] \ast [\kappa]_q\ \overset{N_{\text{shr}}, N_{\text{lft}}}{\longleftrightarrow}\ q'.\ \exists v.\ \ell^{q'} \mapsto v \ast .\ J\tau K.\text{own}(t, v) \right)
$$
**证明**：使用 `LftL-na-acc` 打开非原子借用。访问器确实改变了非原子“掩码”（`N_{\text{shr}}.\ell` 被打开并从掩码中移除）。但是，这在 $|! = \text{cell}(\tau)\ \text{copy}$ 中是允许的，因为我们需要保留的掩码部分是 `N_{\text{shr}}.(\ell + J\tau K.\text{size})`，而由于 `J\tau K.\text{size} \neq 0`，它与我们移除的部分是分离的。**结论**：因此，$|! = \text{cell}(\tau)\ \text{copy}$ 成立。
- **Send**：由于我们定义了 $J\text{cell}(\tau)K.\text{own}$ 是通过 $J\tau K.\text{own}$，因此我们可以轻松证明 $|! = \tau\ \text{send}$ 蕴含 $|! = \text{cell}(\tau)\ \text{send}$。
- **Sync**：**结论**：$|! = \text{cell}(\tau)\ \text{sync}$ 不成立。**原因**：线程标识符 `t` 在我们共享谓词的定义中是关键的。这反映了 `Cell<T>` 从不 `Sync` 的事实。
**全面总结：**

在本节中，作者深入探讨了 `Cell` 类型的语义建模，特别是其共享谓词的定义。`Cell` 允许通过共享引用进行读写，但只在单个线程内。这要求我们在语义上精确地捕获这种行为。

主要内容包括：

1. **所有权谓词的定义**：`cell(τ)` 的所有权与 `τ` 相同。这反映了在 Rust 中，`Cell::new` 和 `Cell::into_inner` 可以在 `T` 和 `Cell<T>` 之间进行转换。
2. **共享谓词的定义**：使用非原子借用来表示 `Cell` 的共享访问。这使得我们能够在单个线程内，通过共享引用对 `Cell` 进行读写。
3. **验证良构性**：确保 `J\text{cell}(\tau)K` 满足语义类型的良构性条件，包括大小、一致性、持久性和共享规则。
4. **标记 Trait 的证明**：
- **Copy**：证明了当 `τ` 是 `Copy` 时，`cell(τ)` 也是 `Copy`。这涉及到处理大小为零和非零的情况，使用非原子借用的访问器。
- **Send**：由于所有权谓词的定义，我们可以轻松证明 `cell(τ)` 的 `Send` 性质。
- **Sync**：由于共享谓词中依赖于线程标识符 `t`，`cell(τ)` 不满足 `Sync` 的条件。这与 `Cell<T>` 在 Rust 中从不 `Sync` 的事实相符。
通过这些定义和证明，我们成功地为 `Cell` 类型建立了语义解释，使得 `Cell` 的操作在语义上是良类型的。这为验证使用 `Cell` 的 Rust 程序的安全性奠定了基础。
 #  
 Thought for 6 seconds
**概览：**

您提供的内容来自论文《Understanding and Evolving the Rust Programming Language》的 **第 13 章：对具有内部可变性的类型的建模**，具体是 **13.1 节：Cell** 的 **13.1.2 子节：公共操作的健全性（Soundness of the public operations）**。

本节的主要目标是 **证明 Cell 类型的公共操作（如 get 和 replace）在语义上是良类型的**，即这些操作在类型系统的语义解释下是安全的。

为了达到这一目标，作者需要：

1. **为 Cell 类型定义语义解释**，包括所有权谓词和共享谓词的定义。
2. **验证 Cell 类型的基本性质**，确保其符合语义类型系统的要求。
3. **对 Cell 的每个公共操作进行验证**，使用语义函数体的证明规则（sem-fn-body），证明运行这些操作符合语义类型系统。
具体来说，本节重点关注 **验证 get 和 replace 函数**，提供了详细的证明过程和证明大纲，展示了如何使用之前定义的语义模型和证明规则，验证这些操作在语义上的正确性。

**详细解读：**

### **13.1.2 公共操作的健全性**

#### **背景和目标**

在上一节 **13.1.1 Cell 的语义解释** 中，作者已经为 `Cell` 类型定义了语义解释，包括所有权谓词和共享谓词，并验证了其基本性质。

现在，作者的目标是：

- **验证 Cell 类型的公共操作在语义上是良类型的**。
- **重点验证 get 和 replace 函数**，确保它们在语义类型系统下是安全的。
为了达到这个目标，我们需要：

1. **使用 sem-fn-body 规则**：证明运行这些操作符合语义类型系统，即满足语义函数体的证明规则。
2. **展开操作的类型解释**：根据操作的类型，展开它们的语义解释，明确它们的前置条件和后置条件。
3. **使用 Iris 程序逻辑进行验证**：在 Iris 程序逻辑中，对操作的实现进行验证，确保它们在语义上是正确的。
#### **验证 get 函数**

**get 函数的实现**

在 λRust 中，`get` 函数的源码如下：

```rust
funrec getn(c) ret ret := 
    let c' = ∗c in
    let r = new(n) in
    r :=n ∗c';
    delete(1, c);
    jump ret(r)
```

- **解释**：c：指向 Cell 的共享引用的指针。∗c：对指针 c 解引用，得到共享引用 c'。new(n)：分配大小为 n 的新内存，返回指针 r。r :=n ∗c'：将 c' 指向的内容复制到 r 指向的内存中，复制 n 个字节。delete(1, c)：释放指针 c 指向的内存。jump ret(r)：调用延续 ret，将指针 r 作为参数。
**get 函数的类型**

在 λRust 中，`get` 的类型为：
\text{get}_{\text{size}(\tau)} : \tau\ \text{copy} \Rightarrow \forall \alpha.\ \text{fn}(\varphi : \varphi\ \text{vl}\ \alpha;\ &^{\alpha}_{\text{shr}}\ \text{cell}(\tau)) \rightarrow \tau
- **解释**：τ copy：τ 是 Copy 类型。∀ α：对于所有的生命周期 α。fn(ϕ : ϕ vl α; &^{α}_{shr} cell(τ)) → τ：一个函数，接受生命周期为 α 的共享引用 &cell(τ)，返回类型为 τ 的值。
**验证目标**

我们需要证明 `get` 在语义上是良类型的。根据 **S-fn** 规则，一个函数在语义上是良类型的，如果它的函数体是良类型的。

根据 **sem-fn-body** 规则，我们需要证明以下 Iris Hoare 三元组：
\left( Jϕ\ \text{ve}\ αK \ast Jϕ\ \text{vl}\ []K(q) \ast J\text{ret}\ \mathcal{C}\ \text{cont}(ϕ\ \text{vl}\ [];\ r.\ r\ \mathcal{C}\ \text{own}\ τ)K(t) \ast Jc\ \mathcal{C}\ \text{own}\ &^{α}_{\text{shr}}\ \text{cell}(τ)K(t) \ast [\text{NaInv} : t.>] \right)\ \text{call get}_{JτK.\text{size}}(c)\ \text{ret}\ \text{ret}\ \{ \text{True} \}
- **解释**：Jϕ ve αK：外部生命周期上下文 E 中的生命周期包含关系。Jϕ vl []K(q)：局部生命周期上下文 L，表示拥有生命周期令牌的数量 q。Jret C cont(ϕ vl []; r. r C own τ)K(t)：延续 ret 的语义解释，表示当延续被调用时，需要提供类型为 own τ 的参数 r。Jc C own &^{α}_{shr} cell(τ)K(t)：指针 c 的所有权，类型为 &^{α}_{shr} cell(τ) 的所有权谓词。[NaInv : t.>]：线程 t 的所有非原子不变式令牌。call get_{JτK.size}(c) ret ret：调用 get 函数，传入参数 c，返回到延续 ret。{ True }：后置条件为 True，因为函数调用结束后不需要额外的保证。
**证明大纲**

证明大纲详见 **Figure 13.2**。

**详细证明步骤**

1. **展开所有权谓词**
- **展开 Jc C own &^{α}_{shr} cell(τ)K(t)**：根据 **own-ptr-own**（第 135 页），我们有：Jc\ \mathcal{C}\ \text{own}\ &^{α}_{\text{shr}}\ \text{cell}(τ)K(t) = \exists v_c.\ c \mapsto v_c \ast .J&^{α}_{\text{shr}}\ \text{cell}(τ)K.\text{own}(t, v_c) \ast \text{Dealloc}(c, 1, 1)c mapsto v_c：c 指向 v_c。J&^{α}_{shr} cell(τ)K.own(t, v_c)：共享引用的所有权谓词。Dealloc(c, 1, 1)：释放 c 指向的内存的权限。
- **展开 J&^{α}_{shr} cell(τ)K.own(t, v_c)**：根据 **shr-ref-own**（第 137 页）和 **cell-shr**（第 206 页），我们有：J&^{α}_{\text{shr}}\ \text{cell}(τ)K.\text{own}(t, v_c) = \exists \ell.\ v_c = \ell \ast . &^{α}_{t.N_{\text{shr}}.\ell}\ \!\!\!\!\!\!\!\!\!\!\text{na}\ \exists v.\ \ell \mapsto v \ast JτK.\text{own}(t, v)v_c = ℓ：v_c 是地址 ℓ。&^{α}_{t.N_{shr}.ℓ} na ∃v. ℓ ↦ v ∗ JτK.own(t, v)：非原子借用，借用的内容是地址 ℓ，包含值 v，并且 v 满足类型 τ 的所有权谓词。
2. **执行 let c' = ∗c**
- 我们需要解引用指针 `c`，得到 `c'`。
- **使用 lrust-deref-na**：需要拥有 `c mapsto v_c`。解引用后，`c'` 变为 `v_c`。更新后，我们有：
$$
c \mapsto c' \ast \text{Dealloc}(c, 1, 1)
$$
3. **分配新的内存 let r = new(JτK.size)**
- **使用 lrust-new**（第 133 页）：分配大小为 `JτK.size` 的新内存，地址为 `r`。获得：
$$
r \mapsto v_r \ast |v_r| = JτK.\text{size} \ast \text{Dealloc}(r, JτK.\text{size}, JτK.\text{size})
$$
`v_r` 是一个长度为 `JτK.size` 的值列表。
4. **获取生命周期令牌**
- **使用 Lalive-sem 引理**：我们有 `ϕ vl []`，即局部生命周期上下文为空。由于 `α` 在类型系统中是活跃的，因此我们可以获得生命周期 `α` 的令牌 `[α]_q'`。**关闭视图转换**：
$$
[α]_{q'} \equiv-\!\ast_{N_{\text{lft}}} Jϕ\ \text{vl}\ []K(q)
$$
5. **打开非原子借用**
- **使用 LftL-na-acc**：打开非原子借用：&^{α}_{t.N_{\text{shr}}.\ell}\ \!\!\!\!\!\!\!\!\!\!\text{na}\ \exists v.\ \ell \mapsto v \ast JτK.\text{own}(t, v)我们获得：
$$
\ell \mapsto v_{c'} \ast JτK.\text{own}(t, v_{c'})
$$
并且需要消耗 `[α]_{q'}` 和 `[NaInv : t.N_{\text{shr}}.\ell]`。
6. **执行内存复制 r := JτK.size ∗ c'**
- **使用 lrust-memcpy**（第 133 页）：需要满足：源地址 `c'`：拥有 `ℓ \mapsto v_{c'} ∗ JτK.own(t, v_{c'})`。目标地址 `r`：拥有 `r \mapsto v_r`。**要求**：`|v_{c'}| = JτK.size`（由 `ty-size` 得到）。`|v_r| = JτK.size`。**结果**：将 `v_{c'}` 的内容复制到 `r` 指向的内存中。我们现在有：
$$
r \mapsto v_{c'} ∗ JτK.own(t, v_{c'})
$$
7. **关闭非原子借用**
- **由于 JτK.own(t, v_{c'}) 是持久的（因为 τ 是 Copy 类型）**，因此我们可以关闭非原子借用，将 `JτK.own(t, v_{c'})` 放回借用中。
- **恢复生命周期令牌和非原子不变式令牌**。
8. **释放指针 c**
- **执行 delete(1, c)**：**使用 lrust-delete**：需要拥有 `Dealloc(c, 1, 1)`。我们已经在之前的步骤中获得了 `Dealloc(c, 1, 1)`。释放 `c` 指向的内存。
9. **调用延续 jump ret(r)**
- **满足延续的前置条件**：我们拥有 `r \mapsto v_{c'} ∗ JτK.own(t, v_{c'})`。**折叠为 Jr C own τ K(t)**，根据 **own-ptr-own**。
- **使用延续的语义解释**：`Jret C cont(ϕ vl []; r. r C own τ )K(t)`。当调用延续 `ret` 时，需要提供类型为 `own τ` 的参数 `r`。
- **消耗所有剩余的资源**，完成证明。
**结论**

- 我们成功地证明了 get 函数在语义上是良类型的，即它的实现符合类型系统的语义解释，确保了程序的安全性。
#### **验证 replace 函数**

**replace 函数的实现**

在 λRust 中，`replace` 函数的源码如下：

```rust
funrec replacen(c, x) ret ret := 
    let c' = ∗c in
    let r = new(n) in
    r :=n ∗c';
    c' :=n ∗x;
    delete(1, c); delete(n, x);
    jump ret(r)
```

- **解释**：c：指向 Cell 的共享引用的指针。x：指向类型为 τ 的值的指针。∗c：解引用指针 c，得到共享引用 c'。r :=n ∗c'：将 c' 指向的内容复制到 r。c' :=n ∗x：将 x 指向的内容复制到 c'，即替换 Cell 中的值。delete(1, c); delete(n, x)：释放指针 c 和 x 指向的内存。jump ret(r)：调用延续 ret，将指针 r 作为参数。
**replace 函数的类型**

在 λRust 中，`replace` 的类型为：
\text{replace}_{\text{size}(τ)} : \forall \alpha.\ \text{fn}(\varphi : \varphi\ \text{ve}\ \alpha;\ &^{\alpha}_{\text{shr}}\ \text{cell}(τ),\ τ) \rightarrow τ
- **解释**：∀ α：对于所有的生命周期 α。fn(ϕ : ϕ ve α; &^{α}_{shr} cell(τ), τ) → τ：一个函数，接受生命周期为 α 的共享引用 &cell(τ) 和类型为 τ 的值，返回类型为 τ 的值。
**验证目标**

根据 **S-fn** 和 **sem-fn-body**，我们需要证明以下 Iris Hoare 三元组：
\left( Jϕ\ \text{ve}\ αK \ast Jϕ\ \text{vl}\ []K(q) \ast J\text{ret}\ \mathcal{C}\ \text{cont}(ϕ\ \text{vl}\ [];\ r.\ r\ \mathcal{C}\ \text{own}\ τ)K(t) \ast Jc\ \mathcal{C}\ \text{own}\ &^{α}_{\text{shr}}\ \text{cell}(τ),\ x\ \mathcal{C}\ \text{own}\ τ K(t) \ast [\text{NaInv} : t.>] \right)\ \text{call replace}_{JτK.\text{size}}(c, x)\ \text{ret}\ \text{ret}\ \{ \text{True} \}
- **解释**：与 get 的验证类似，但现在我们还有一个参数 x，它是类型为 τ 的值。
**证明大纲**

证明大纲详见 **Figure 13.3**。

**详细证明步骤**

1. **展开所有权谓词**
- 与 `get` 的验证类似，我们展开 `c` 和 `x` 的所有权谓词。
- **对于 c**：同 get 的步骤。
- **对于 x**：根据 **own-ptr-own**，我们有：
$$
Jx\ \mathcal{C}\ \text{own}\ τ K(t) = x \mapsto v_x \ast JτK.\text{own}(t, v_x) \ast \text{Dealloc}(x, JτK.\text{size}, JτK.\text{size})
$$
2. **执行 let c' = ∗c 和 let r = new(JτK.size)**
- 与 get 的验证类似。
3. **获取生命周期令牌**
- 使用 Lalive-sem，获得 [α]_{q'}。
4. **打开非原子借用**
- 使用 `LftL-na-acc`，获得：
$$
c' \mapsto v_{c'} \ast JτK.\text{own}(t, v_{c'})
$$
5. **执行内存复制 r := JτK.size ∗ c'**
- 使用 lrust-memcpy，将 c' 指向的内容复制到 r。
6. **执行内存复制 c' := JτK.size ∗ x**
- 我们拥有：`c' \mapsto v_{c'}`。`x \mapsto v_x ∗ JτK.own(t, v_x)`。
- **使用 lrust-memcpy**，将 `x` 指向的内容复制到 `c'`。
7. **关闭非原子借用**
- 我们现在有：`c' \mapsto v_x`。`JτK.own(t, v_x)`。
- 将 `JτK.own(t, v_x)` 放回借用中，关闭非原子借用。
- **注意**：我们失去了对 `JτK.own(t, v_x)` 的所有权，这是预期的，因为我们将 `x` 的内容移动到了 `Cell` 中。
8. **释放指针 c 和 x**
- **执行 delete(1, c) 和 delete(JτK.size, x)**：释放 `c` 和 `x` 指向的内存。我们拥有相应的 `Dealloc` 权限。
9. **调用延续 jump ret(r)**
- **满足延续的前置条件**：我们拥有 `r \mapsto v_{c'} ∗ JτK.own(t, v_{c'})`。折叠为 `Jr C own τ K(t)`。
- **使用延续的语义解释**，完成证明。
**结论**

- 我们成功地证明了 replace 函数在语义上是良类型的，即它的实现符合类型系统的语义解释，确保了程序的安全性。
#### **剩余的 Cell 方法**

除了 `get` 和 `replace`，`Cell` 的完整 API 还包括以下函数：

- Cell::new : fn(T) -> Cell<T>：创建一个新的 Cell，将 T 的所有权转移到 Cell<T> 中。
- Cell::into_inner : fn(Cell<T>) -> T：从 Cell<T> 中取出值，获得 T 的所有权。
- Cell::get_mut : fn(&mut Cell<T>) -> &mut T：从可变引用 &mut Cell<T> 中获取可变引用 &mut T。
- Cell::from_mut : fn(&mut T) -> &Cell<T>：从可变引用 &mut T 创建共享引用 &Cell<T>。
这些函数的验证基于以下事实：

- **Cell<T> 的所有权与 T 的所有权相同**（cell-own），因此它们可以自由地相互转换。
- **&mut Cell<T> 和 &mut T**：由于可变引用具有唯一性和完整所有权，因此它们也可以自由转换。
对于这些函数的验证，由于它们只涉及类型之间的转换，并不涉及复杂的所有权或借用关系，因此相对简单。

#### **最近添加的方法**

- **Cell::swap**：交换两个 `&Cell<T>` 中的内容。验证需要同时打开两个 `Cell` 的非原子借用。
- **Cell::as_slice_of_cells**：将 `&Cell<[T]>` 转换为 `&[Cell<T>]`。由于涉及到动态大小类型（slices），λRust 不支持，因此无法直接验证。对于固定大小的情况，例如将 `&Cell<(T, U)>` 转换为 `&(Cell<T>, Cell<U>)`，也存在问题。**原因**：我们的非原子借用的命名空间依赖于 `Cell` 的位置，无法轻易拆分为多个借用。需要对语义模型进行重大调整才能支持这种操作。**结论**：验证此类转换需要进一步的研究和模型改进，留待未来工作解决。
**全面总结：**

在本节中，作者详细展示了如何验证 `Cell` 类型的公共操作在语义上的正确性，确保它们在类型系统的语义解释下是安全的。

主要内容包括：

1. **验证 get 函数**：
- 展开 `get` 函数的实现和类型解释。
- 使用 Iris 程序逻辑，详细证明了 `get` 函数的每一步操作在语义上是安全的。
- 关键步骤包括展开所有权谓词、打开非原子借用、执行内存复制、关闭借用等。
2. **验证 replace 函数**：
- 展开 `replace` 函数的实现和类型解释。
- 与 `get` 的验证类似，但需要处理更多的所有权转移和内存释放。
- 关键步骤包括处理非 `Copy` 类型的所有权、保持非原子借用打开、移动值的所有权等。
3. **处理剩余的 Cell 方法**：
- 讨论了其他 Cell 方法的验证，说明它们的验证相对简单，因为它们只涉及类型转换和所有权的转移。
4. **挑战和未来工作**：
- 提到了最近添加的方法，如 `Cell::swap` 和 `Cell::as_slice_of_cells`。
- 由于我们的语义模型的限制，无法直接验证这些方法，需要进一步的研究和改进。
通过这些验证，作者成功地证明了 `Cell` 类型的公共操作在语义上是良类型的，确保了使用 `Cell` 的程序在类型系统的语义解释下是安全的。这为验证 Rust 程序的安全性和类型系统的健全性奠定了重要基础。

本节的工作展示了如何在复杂的类型和所有权系统下，使用形式化的语义模型和程序逻辑，验证实际编程语言的关键特性。这对于编程语言理论、形式化验证和安全关键系统的开发具有重要意义。
 #  
 Thought for 7 seconds
**概览：**

您提供的内容来自论文《Understanding and Evolving the Rust Programming Language》的 **第 13 章：对具有内部可变性的类型的建模**，具体是 **13.2 节：Mutex**。

本节讨论了 Rust 标准库中另一个具有内部可变性的类型：`Mutex<T>`。`Mutex` 提供了一种安全的方式，允许多个线程对共享对象进行读写访问。虽然实际的 `Mutex` 使用了平台特定的同步原语，但在模型中，我们使用一个简单的自旋锁（spinlock）来模拟其行为。

本节的主要目标是：

1. **定义 Mutex 的语义解释**：包括其大小（size）、所有权谓词（ownership predicate）和共享谓词（sharing predicate）的定义。
2. **解释为什么共享谓词需要使用原子借用（atomic borrows）**：因为 `Mutex` 需要支持跨线程的共享，所以需要使用原子借用来确保线程安全。
3. **验证 Mutex 的良构性（well-formedness）**：特别是证明其满足类型系统的共享规则（ty-share），这是验证中最复杂的部分。
4. **讨论标记特征（marker traits）**：分析在什么条件下 `Mutex<T>` 是 `Send` 和 `Sync`，以及如何在语义解释中反映这些条件。
**详细解读：**

### **13.2 Mutex**

#### **背景**

在第 8.6 节中，我们介绍了 `Mutex<T>` 作为内部可变性的另一个例子。`Mutex<T>` 使用锁机制来安全地授予多个线程对共享对象 `T` 的读写访问权限。虽然实际的 `Mutex` 使用了平台特定的同步原语，但在我们的模型中，我们使用一个简单的自旋锁来模拟其行为。

#### **13.2.1 Mutex 的语义解释**

**所有权谓词的定义**

首先，我们按照惯例定义 `Mutex` 的大小和所有权谓词：

- **大小**：
$$
J\text{mutex}(\tau)K.\text{size} := 1 + J\tau K.\text{size}
$$
- **所有权谓词**：
$$
J\text{mutex}(\tau)K.\text{own}(t, v) := J\text{bool} \times \tau K.\text{own}(t, v) \quad \text{(mutex-own)}
$$
这里，v 是一个值，其类型为 bool × τ，表示一个布尔值（用于自旋锁的状态）和一个类型为 τ 的对象（即 Mutex 的内容）。
- **解释**：当 Mutex 没有被共享时，mutex(τ) 与一个布尔值和一个类型为 τ 的对象的对（pair）完全相同。ty-size 条件可以直接满足，因为我们已经定义了 J\text{mutex}(\tau)K.\text{size}。
**共享谓词的定义**

共享谓词比较复杂，因为我们需要考虑以下因素：

- **不能使用分数借用（fractured borrows）**：因为我们不能只获得所有权的一部分（fraction of ownership）。
- **不能使用非原子借用（non-atomic borrows）**：因为 `Mutex` 是 `Sync` 的，允许跨线程共享。使用非原子借用会将谓词绑定到特定的线程标识符 `t`，这与 `cell(τ)` 的情况类似，但在 `Mutex` 中不合适。
- **解决方案**：使用 **原子借用（atomic borrows）**，如第 11.4 节（第 148 页）所述。原子借用基本上是标准的 Iris 不变式（invariants），它们提供对其内容的完整访问，允许在任何线程中进行原子操作。这些不变式还与一个生命周期相关联，这样当生命周期结束时，不变式会自动取消（"canceled automatically"）。
**共享谓词的具体定义**

对于 `Mutex` 的共享谓词，我们定义如下：

- **共享谓词**：J\text{mutex}(\tau)K.\text{shr}(\kappa, t, \ell) := \exists \kappa'.\ \kappa \sqsubseteq \kappa' \ast &^{\kappa}_{N_{\text{rust}}}\ \!\!\!\!\!\!\!\!\!\!\text{at}\ M_{\tau}(\kappa', \ell, t) \quad \text{(mutex-shr)}**解释**：我们使用了一个存在量化（$\exists \kappa'$）来对生命周期进行抽象，以满足 `ty-shr-mono` 条件（共享谓词的单调性）。使用原子借用（`&^{\kappa}_{N_{\text{rust}}}\ \text{at}\ M_{\tau}(\kappa', \ell, t)`）来共享位于地址 `\ell` 的锁标志（status flag）的所有权。该原子借用定义了一个在生命周期 `\kappa` 内维持的不变式（invariant），位于命名空间 `N_{\text{rust}}` 下。我们引入了一个名称 `M_{\tau}(\kappa', \ell, t)`，表示在线程 `t` 中，位于地址 `\ell` 处，针对类型 `τ`，共享生命周期为 `\kappa'` 的互斥锁（mutex）的不变式。
- **互斥锁的不变式**：M_{\tau}(\kappa', \ell, t) := \ell \mapsto \text{true} \lor \left( \ell \mapsto \text{false} \ast &^{\kappa'}_{\text{full}}\ \exists v.\ (\ell + 1) \mapsto v \ast J\tau K.\text{own}(t, v) \right) \quad \text{(mutex-inv)}**解释**：不变式可以有两种状态：**锁定状态（Locked）**：`\ell \mapsto \text{true}`：表示锁标志为 `true`，即锁已被持有。在这种情况下，锁的内容（类型为 `τ` 的对象）不在不变式中，由持有锁的线程拥有。**解锁状态（Unlocked）**：`\ell \mapsto \text{false}`：表示锁标志为 `false`，即锁未被持有。此时，不变式还包含对锁内容的所有权：&^{\kappa'}_{\text{full}}\ \exists v.\ (\ell + 1) \mapsto v \ast J\tau K.\text{own}(t, v)这里，我们使用了一个完整借用（full borrow），生命周期为 \kappa'，以保证当生命周期结束时，所有权能够正确返回。
- **为什么需要完整借用（full borrow）**：如果我们直接在外部原子借用中包含内容的所有权，那么在持有锁时，我们会获得内容的完整（未借用的）所有权。然而，这会导致无法证明 `ty-share`（共享规则），因为在生命周期结束时，我们需要能够将不变式恢复到其原始状态，但在锁定状态下，我们无法满足这一点。使用完整借用，确保当持有锁时，对内容的所有权仍然受到生命周期 `\kappa'` 的限制，保证在生命周期结束时，所有权能够正确归还。
**良构性（Well-formedness）**

我们需要验证 `J\text{mutex}(\tau)K` 满足语义类型的良构性条件，特别是证明其满足共享规则 `ty-share`。

- **共享规则 ty-share 的证明**我们需要证明：&^{\kappa}_{\text{full}}\ \exists w.\ \ell \mapsto w \ast J\text{bool} \times \tau K.\text{own}(t, w) \quad \ast [\kappa]_q \equiv-\!\ast_{N_{\text{lft}}} [\kappa]_q \ast \exists \kappa'.\ \kappa \sqsubseteq \kappa' \ast &^{\kappa}_{N_{\text{rust}}}\ \!\!\!\!\!\!\!\!\!\!\text{at}\ M_{\tau}(\kappa', \ell, t)**解释**：从完整借用开始，拥有地址 `\ell` 处的值 `w`，其中 `w` 满足类型 `\text{bool} \times \tau` 的所有权谓词。我们需要通过视图转换（view shift），在不变式命名空间 `N_{\text{lft}}` 下，将其转换为共享谓词，并保持生命周期令牌 `[\kappa]_q`。**证明步骤**：**拆分所有权**首先，我们将 `\text{bool} \times \tau` 拆分为两个组件（布尔值和内容）：&^{\kappa}_{\text{full}}\ \exists w.\ \ell \mapsto w \ast J\text{bool} \times \tau K.\text{own}(t, w) \quad \ast [\kappa]_q \equiv-\!\ast_{N_{\text{lft}}}等价于：&^{\kappa}_{\text{full}}\ \exists b.\ \ell \mapsto b \ast (b = \text{true} \lor b = \text{false}) \quad \ast &^{\kappa}_{\text{full}}\ \exists v.\ (\ell + 1) \mapsto v \ast J\tau K.\text{own}(t, v) \quad \ast [\kappa]_q这里，我们使用了 `LftL-bor-split`（第 142 页）将借用拆分为两个独立的借用。使用 `bool-own`（第 135 页）和 `pair-own`（第 135 页）来处理所有权谓词的拆分。**构建原子借用**我们使用 `LftL-bor-acc-strong`（第 155 页）再次打开布尔值的借用，将其内容替换为我们的互斥锁不变式 `M_{\tau}(\kappa', \ell, t)`。**向后方向（backwards direction）**：从新的借用内容 `Q = M_{\tau}(\kappa', \ell, t)`，我们需要证明能够视图转换回原始借用内容 `\exists b.\ \ell \mapsto b \ast (b = \text{true} \lor b = \text{false})`。这很容易，因为在不变式中，我们拥有 `\ell \mapsto \text{true}` 或 `\ell \mapsto \text{false}`。**向前方向（forwards direction）**：我们需要将内容的借用移入布尔值的借用中。当 `b = \text{false}` 时，我们确实拥有对内容的借用，可以将其移入新的借用中。当 `b = \text{true}` 时，我们不需要对内容的借用，可以直接丢弃。**完成证明**通过上述步骤，我们成功地将完整借用转换为共享谓词，满足 `ty-share`。在证明中，我们可以选择 `\kappa' := \kappa`，满足生命周期的包含关系 `\kappa \sqsubseteq \kappa'`。
**标记特征（Marker Traits）**

- **Copy**Mutex<T> 永远不是 Copy 的，因此我们不需要证明任何东西。
- **Send 和 Sync**`Mutex<T>` 在 `T` 是 `Send` 的情况下，既是 `Send`，又是 `Sync`。**对应的语义解释**：因为 `mutex(τ)` 的所有权和共享谓词只在 `τ` 的所有权谓词中使用了线程标识符 `t`。如果我们有 `|\! = τ\ \text{send}`，并且其所有权谓词不依赖于 `t`，那么我们很容易得到 `|\! = \text{mutex}(τ)\ \text{send}` 和 `|\! = \text{mutex}(τ)\ \text{sync}`。
**全面总结：**

在 **13.2 节：Mutex** 中，作者详细探讨了如何对 `Mutex` 类型进行语义建模，特别是其共享谓词的定义和验证。`Mutex` 允许多个线程安全地对共享对象进行读写访问，这要求在语义上精确地捕获其并发行为和同步机制。

主要内容包括：

1. **所有权谓词的定义**：
- 定义了 J\text{mutex}(\tau)K 的大小和所有权谓词，将 Mutex 视为一个布尔值（表示锁的状态）和一个类型为 τ 的对象的对（pair）。
2. **共享谓词的定义**：
- 使用 **原子借用（atomic borrows）** 来定义共享谓词，避免了非原子借用中线程标识符的绑定，以及分数借用中所有权部分化的问题。
- 定义了互斥锁的不变式 `M_{\tau}(\kappa', \ell, t)`，描述了锁的两种状态（锁定和解锁）及其对应的所有权。
- 解释了为什么需要在不变式中使用完整借用，以确保生命周期结束时所有权能够正确归还。
3. **良构性的验证**：
- 重点验证了共享规则 `ty-share`，这是验证中最复杂的部分。
- 通过拆分所有权、构建原子借用、以及视图转换等步骤，成功地证明了 `J\text{mutex}(\tau)K` 满足 `ty-share`，从而确保其良构性。
4. **标记特征的讨论**：
- 解释了在什么条件下 `Mutex<T>` 是 `Send` 和 `Sync` 的，以及如何在语义解释中反映这些条件。
- 由于 `mutex(τ)` 的所有权和共享谓词只在 `τ` 的所有权谓词中使用了线程标识符 `t`，如果 `τ` 是 `Send` 的，我们可以证明 `mutex(τ)` 也是 `Send` 和 `Sync` 的。
通过这些定义和证明，我们成功地为 `Mutex` 类型建立了语义解释，使得 `Mutex` 的操作在语义上是良类型的。这为验证使用 `Mutex` 的 Rust 程序的安全性奠定了基础。

本节的工作展示了如何在复杂的并发和同步场景下，使用形式化的语义模型和程序逻辑，验证实际编程语言的关键特性。这对于编程语言理论、形式化验证和安全关键系统的开发具有重要意义。
 #  
 Thought for 6 seconds
**概览：**

您提供的内容来自论文《Understanding and Evolving the Rust Programming Language》的 **第 13 章：对具有内部可变性的类型的建模**，具体是 **13.2 节：Mutex** 的 **13.2.2 子节：MutexGuard 的语义解释（Semantic interpretation of MutexGuard）**。

本节讨论了 Rust 标准库中 `Mutex` 类型的另一个关键部分——`MutexGuard`。在 Rust 中，`Mutex<T>` 和 `MutexGuard<'a, T>` 是两个密切相关的类型：

- **Mutex<T>**：表示一个容器，保证对类型 T 的数据进行互斥访问。
- **MutexGuard<'a, T>**：由 Mutex::lock 方法返回的类型，表示在生命周期 'a 内对被 Mutex<T> 保护的数据 T 的可变访问。拥有 MutexGuard 相当于持有锁，且在 MutexGuard<'a, T> 超出作用域时，隐式析构函数会释放关联的锁。
本节的主要目标是：

1. **定义 MutexGuard 的语义模型**：即 `J\text{mutex\_guard}(\kappa, \tau)K`，并在验证 `Mutex::lock` 时使用该模型。
2. **解释 MutexGuard 的所有权谓词和共享谓词的定义**：详细说明如何在语义上表示 `MutexGuard`，以及如何处理其与生命周期和锁的不变式的关系。
3. **讨论 MutexGuard 的标记特征（Marker Traits）**：分析 `MutexGuard` 何时是 `Send` 和 `Sync`，以及在语义模型中如何反映这些特性。
**详细解读：**

### **13.2.2 MutexGuard 的语义解释**

#### **背景**

- **Mutex<T>**：提供对类型 T 的数据的互斥访问。
- **MutexGuard<'a, T>**：当我们调用 Mutex::lock 方法时，返回一个 MutexGuard<'a, T>，表示我们在生命周期 'a 内持有锁，并可以对 T 进行可变访问。
**目标**：

- 除了定义 mutex(\tau) 的语义模型外，我们还需要定义 mutex\_guard(\kappa, \tau) 的语义模型，并在验证 Mutex::lock 时使用该模型。
- **操作上**，MutexGuard<'a, T> 是指向它所锁定的 Mutex<T> 的指针。因此，在 λRust 中，它的大小为 1。
#### **MutexGuard 的语义解释**

**所有权谓词的定义**

- **大小**：
$$
J\text{mutex\_guard}(\kappa, \tau)K.\text{size} := 1
$$
- **所有权谓词**：J\text{mutex\_guard}(\kappa, \tau)K.\text{own}(t, [\ell]) := \exists \kappa'.\ \kappa \sqsubseteq \kappa' \ast &^{\kappa}_{N_{\text{rust}}}\ \!\!\!\!\!\!\!\!\!\!\text{at}\ M_{\tau}(\kappa', \ell, t) \ast &^{\kappa'}_{\text{full}} \left( \exists v.\ (\ell + 1) \mapsto v \ast J\tau K.\text{own}(t, v) \right) \quad \text{(mutexguard-own)}**解释**：**存在量化**：存在一个生命周期 \kappa'，满足 \kappa \sqsubseteq \kappa'。**原子借用**：&^{\kappa}_{N_{\text{rust}}}\ \text{at}\ M_{\tau}(\kappa', \ell, t)，即在命名空间 N_{\text{rust}} 下的原子借用，维持不变式 M_{\tau}(\kappa', \ell, t)。**完整借用**：&^{\kappa'}_{\text{full}} \left( \exists v.\ (\ell + 1) \mapsto v \ast J\tau K.\text{own}(t, v) \right)，表示对内容的完整借用，生命周期为 \kappa'。**意义**：拥有 MutexGuard<'a, T> 表示我们已经成功获取了锁，即我们拥有它所保护的完整借用。我们还将锁的不变式（即原子借用）包含在这里，因为当 MutexGuard 被销毁时，需要访问该不变式来释放锁。
- **对比**：MutexGuard<'a, T> 与 &'a mut T 基本上是相同的，它们都包含了对内容的可变（独占）访问。
**共享谓词的定义**

- **挑战**：类型 `&'b \text{MutexGuard}<'a, T>` 类似于 `&'b\ &\!'a\ \text{mut}\ T`，需要处理可变引用的共享复杂性。**问题**：MutexGuard<'a, T> 本身是指向 Mutex<T> 的指针，因此当我们共享该指针时，需要确保仍然可以对其进行解引用。
- **解决方案**：当共享 `MutexGuard` 时，指针变为只读，我们使用类似于第 10.4 节中“简单类型”的共享谓词：J\text{mutex\_guard}(\kappa, \tau)K.\text{shr}(\kappa', t, \ell_0) := \exists \ell.\ &^{\kappa}_{\text{frac}}(\lambda q.\ \ell_0^{q} \mapsto \ell) \ast \ldots\ell_0：存储共享 MutexGuard 的位置，即一个指向指针的指针。\ell：Mutex 的位置，与所有权谓词中的 \ell 相同。
- **完成共享谓词的定义****直觉**：在位置 `\ell + 1`，我们可以找到一个共享的 `τ`。**尝试**：我们可能会尝试定义：
$$
.\ JτK.\text{shr}(\kappa \sqcap \kappa', t, \ell + 1)
$$
使用生命周期 \kappa \sqcap \kappa'（κ 和 κ' 的交集）来涵盖 MutexGuard<'a, T> 自身的有效期（'a）和对该守护的共享引用的生命周期。**问题**：类似于第 12.2 节中拥有指针和可变引用的情况，这个定义无法满足 ty-share（共享规则）。**解决方案**：使用 **延迟共享（delayed sharing）**。**方法**：不在共享 `mutex\_guard(\kappa, \tau)` 时立即共享 `τ` 的实例。让 `mutex\_guard` 的共享谓词成为一个需要一步才能完成的视图转换（view shift），完成视图转换后才能得到 `τ` 的共享谓词。**共享谓词的完整定义**：J\text{mutex\_guard}(\kappa, \tau)K.\text{shr}(\kappa', t, \ell_0) := \exists \ell.\ &^{\kappa}_{\text{frac}}(\lambda q.\ \ell_0^{q} \mapsto \ell) \ast \diamond\ \forall q.\ [J\kappa K \sqcap \kappa']^{q} -\!\ast\ |V_{N_{\text{shr}} \cup N_{\text{lft}}} N_{\text{lft}}.\ |V_{N_{\text{lft}}} N_{\text{shr}} \cup N_{\text{lft}}.\ JτK.\text{shr}(J\kappa K \sqcap \kappa', t, \ell + 1) \ast [J\kappa K \sqcap \kappa']^{q} \quad \text{(mutexguard-shr)}`\diamond`：表示 “稍后”（later）模态，允许我们推迟共享谓词的应用。`\forall q.\ [J\kappa K \sqcap \kappa']^{q} -\!\ast \ldots`：表示对于所有的分数 `q`，从生命周期令牌 `[J\kappa K \sqcap \kappa']^{q}` 开始，进行视图转换。`|V_{N_{\text{shr}} \cup N_{\text{lft}}} N_{\text{lft}}`：表示在不变式命名空间之间进行视图转换。**最终得到**：`JτK.\text{shr}(J\kappa K \sqcap \kappa', t, \ell + 1)`，即对内容 `τ` 的共享谓词。
**良构性（Well-formedness）**

- **共享规则 ty-share 的证明**证明过程与第 12.2 节中可变引用的情况类似，需要处理延迟共享和视图转换。
- **其他性质**语义类型要求的其他性质没有困难，可以满足。
**标记特征（Marker Traits）**

- **Copy**MutexGuard<'a, T> 不是 Copy，因此不需要证明。
- **Send 和 Sync****Send**虽然我们的所有权谓词继承了 `τ` 的“可发送性”（sendability），因此我们可以证明 `|\! = τ\ \text{send}` 蕴含 `|\! = \text{mutex\_guard}(\kappa, \tau)\ \text{send}`。**然而**，实际的 `MutexGuard<'a, T>` 永远不是 `Send`，因为某些平台特定的锁定 API 不允许从获取锁的线程之外的线程释放锁。**Sync**`MutexGuard<'a, T>` 在某些条件下是 `Sync` 的。**实际情况**：当我们进行验证时，`MutexGuard` 总是 `Sync`，无论 `T` 是否是 `Sync`。**问题**：如果我们尝试证明 `|\! = \text{mutex\_guard}(\kappa, \tau)\ \text{sync}`，会发现这需要 `|\! = τ\ \text{sync}`。这并不是我们的模型的限制，而是 Rust 中的一个漏洞！**解决方案**：我们向 Rust 项目提交了一个修复，使得 `MutexGuard<'a, T>` 只有在 `T` 是 `Sync` 时才是 `Sync`。对于我们上面定义的语义模型，很容易证明相应的蕴含关系。
**全面总结：**

在 **13.2.2 节：MutexGuard 的语义解释** 中，作者详细探讨了如何对 `MutexGuard` 类型进行语义建模，特别是其所有权谓词和共享谓词的定义，以及如何处理与生命周期和锁的不变式的关系。

主要内容包括：

1. **所有权谓词的定义**：
- 定义了 `J\text{mutex\_guard}(\kappa, \tau)K` 的大小和所有权谓词。
- **所有权谓词**包含了：一个与 `\kappa` 相关的原子借用，维持互斥锁的不变式 `M_{\tau}(\kappa', \ell, t)`。一个生命周期为 `\kappa'` 的完整借用，表示对内容的独占访问。
- 这反映了 `MutexGuard<'a, T>` 与 `&'a mut T` 基本上相同，它们都提供对内容的独占访问。
2. **共享谓词的定义**：
- 由于 `MutexGuard` 本身是一个指向 `Mutex<T>` 的指针，当我们共享它时，需要确保仍然可以解引用。
- 直接共享内容的尝试无法满足 `ty-share`，因此使用 **延迟共享（delayed sharing）** 的方法。
- 共享谓词被定义为一个视图转换，需要一步才能完成，完成后才能获得内容 `τ` 的共享谓词。
3. **良构性的验证**：
- 重点验证了共享规则 `ty-share`，证明过程与可变引用的情况类似，处理了延迟共享和视图转换的问题。
- 其他性质也得到了满足，确保了 `J\text{mutex\_guard}(\kappa, \tau)K` 是一个良构的语义类型。
4. **标记特征的讨论**：
- `MutexGuard<'a, T>` 不是 `Copy`，无需证明。
- **Send 和 Sync**：实际的 `MutexGuard<'a, T>` 永远不是 `Send`，因为锁必须由获取它的线程释放。`MutexGuard<'a, T>` 在某些条件下是 `Sync` 的，但需要 `T` 是 `Sync`。我们的模型反映了这一点，如果尝试证明 `|\! = \text{mutex\_guard}(\kappa, \tau)\ \text{sync}`，需要 `|\! = τ\ \text{sync}`。发现了 Rust 中的一个漏洞，并提交了修复，使得 `MutexGuard<'a, T>` 只有在 `T` 是 `Sync` 时才是 `Sync`。
通过这些定义和证明，我们成功地为 `MutexGuard` 类型建立了语义解释，使得 `MutexGuard` 的操作在语义上是良类型的。这对于验证使用 `Mutex` 和 `MutexGuard` 的 Rust 程序的安全性至关重要。

本节的工作展示了如何在复杂的所有权、借用和并发机制下，使用形式化的语义模型和程序逻辑，验证实际编程语言的关键特性。这对于编程语言理论、形式化验证和安全关键系统的开发具有重要意义。
 #  
 Thought for 7 seconds
**概览：**

您提供的内容来自论文《Understanding and Evolving the Rust Programming Language》的 **第 13 章：对具有内部可变性的类型的建模**，具体是 **13.2 节：Mutex** 的 **13.2.3 子节：公共操作的健全性（Soundness of the public operations）**。

本节的主要目标是 **验证 Mutex 和 MutexGuard 类型的关键公共操作在语义上的正确性**，即确保这些操作在类型系统的语义解释下是安全的。

具体来说，本节重点验证以下方法：

1. **Mutex::lock**：用于获取互斥锁。
2. **MutexGuard::deref_mut**：用于获取对被保护数据的可变引用。
3. **MutexGuard::drop**：当锁不再需要时，用于释放锁。
作者详细展示了如何使用之前定义的语义模型和证明规则，对这些方法进行验证，确保它们在语义上是良类型的。

**详细解读：**

### **13.2.3 公共操作的健全性**

#### **背景和目标**

在前面的子节中，作者已经定义了 `Mutex` 和 `MutexGuard` 的语义解释，包括它们的所有权谓词和共享谓词，并验证了它们的基本性质。

现在，作者的目标是：

- **验证 Mutex 和 MutexGuard 的关键公共操作在语义上是良类型的**。
- **重点验证 Mutex::lock、MutexGuard::deref_mut 和 MutexGuard::drop 方法**，确保它们的实现符合类型系统的语义解释，保证程序的安全性。
#### **验证 Mutex::lock 方法**

**Mutex::lock 方法的实现**

在 λRust 中，`Mutex::lock` 方法的源码如下：

```rust
funrec lock(m) ret ret :=
    let m' = ∗m in
    delete(1, m);
    let r = new(1) in
    r := m' ;
    letcont loop(m', r) :=
        let b = CAS(m', false, true) in
        if b then jump ret(r) else jump loop(m', r)
    in jump loop(m', r)
```

- **解释**：`m`：指向共享引用 `&Mutex<T>` 的指针。`∗m`：对指针 `m` 解引用，得到共享引用 `m'`。`delete(1, m)`：释放指针 `m` 指向的内存。`let r = new(1)`：分配大小为 1 的新内存，返回指针 `r`。`r := m'`：将 `m'` 的值赋给 `r`。`loop`：实现自旋锁的循环。`CAS(m', false, true)`：对地址 `m'` 执行比较并交换操作（Compare-And-Swap），尝试将值从 `false` 改为 `true`。`if b then jump ret(r)`：如果交换成功（`b` 为 `true`），则返回 `r`。`else jump loop(m', r)`：否则，继续循环。
**Mutex::lock 方法的类型**

在 λRust 中，`Mutex::lock` 的类型为：
\text{lock} : \forall \alpha.\ \text{fn}(\varphi : \varphi\ \text{ve}\ \alpha;\ &^{\alpha}_{\text{shr}}\ \text{mutex}(\tau)) \rightarrow \text{mutex\_guard}(\alpha, \tau)
- **解释**：\forall \alpha：对于所有的生命周期 \alpha。\text{fn}(\varphi : \varphi\ \text{ve}\ \alpha;\ &^{\alpha}_{\text{shr}}\ \text{mutex}(\tau)) \rightarrow \text{mutex\_guard}(\alpha, \tau)：一个函数，接受生命周期为 \alpha 的共享引用 &\text{mutex}(\tau)，返回类型为 \text{mutex\_guard}(\alpha, \tau) 的值。
**验证目标**

根据 **S-fn** 规则和 **sem-fn-body** 规则，我们需要证明以下 Iris Hoare 三元组：

$$
\left\{
\begin{array}{l}
J\varphi\ \text{ve}\ \alpha K \ast J\varphi\ \text{vl}\ []K(q) \ast \\
J\text{ret}\ \mathcal{C}\ \text{cont}(\varphi\ \text{vl}\ []; r.\ r\ \mathcal{C}\ \text{own}\ \text{mutex\_guard}(\alpha, \tau))K(t) \ast \\
Jm\ \mathcal{C}\ \text{own}\ &^{\alpha}_{\text{shr}}\ \text{mutex}(\tau)K(t) \ast [\text{NaInv} : t.>]
\end{array}
\right\}
\ \text{call lock}(m)\ \text{ret}\ \text{ret}
\ \{ \text{True} \}
$$

- **解释**：J\varphi\ \text{ve}\ \alpha K：外部生命周期上下文 E 中的生命周期包含关系。J\varphi\ \text{vl}\ []K(q)：局部生命周期上下文 L，表示拥有生命周期令牌的数量 q。J\text{ret}\ \mathcal{C}\ \text{cont}(\varphi\ \text{vl}\ []; r.\ r\ \mathcal{C}\ \text{own}\ \text{mutex\_guard}(\alpha, \tau))K(t)：延续 ret 的语义解释，表示当延续被调用时，需要提供类型为 \text{mutex\_guard}(\alpha, \tau) 的参数 r。Jm\ \mathcal{C}\ \text{own}\ &^{\alpha}_{\text{shr}}\ \text{mutex}(\tau)K(t)：指针 m 的所有权，类型为 &^{\alpha}_{\text{shr}}\ \text{mutex}(\tau) 的所有权谓词。[NaInv : t.>]：线程 t 的所有非原子不变式令牌。
**证明大纲**

证明大纲详见 **Figure 13.4**。

**详细证明步骤**

1. **展开所有权谓词**
- **展开 Jm\ \mathcal{C}\ \text{own}\ &^{\alpha}_{\text{shr}}\ \text{mutex}(\tau)K(t)**：根据 **own-ptr-own**（第 135 页）和 **shr-ref-own**（第 137 页），以及 **mutex-shr**，我们有：Jm\ \mathcal{C}\ \text{own}\ &^{\alpha}_{\text{shr}}\ \text{mutex}(\tau)K(t) = m \mapsto \ell_0 \ast \text{Dealloc}(m, 1, 1) \ast .(\alpha \sqsubseteq \kappa') \ast .\ &^{\alpha}_{N_{\text{rust}}}\ \!\!\!\!\!\!\!\!\!\!\text{at}\ M_{\tau}(\kappa', \ell_0, t)m \mapsto \ell_0：m 指向地址 \ell_0。\text{Dealloc}(m, 1, 1)：释放 m 指向的内存的权限。\alpha \sqsubseteq \kappa'：生命周期的包含关系。&^{\alpha}_{N_{\text{rust}}}\ \text{at}\ M_{\tau}(\kappa', \ell_0, t)：在命名空间 N_{\text{rust}} 下的原子借用，维持不变式 M_{\tau}(\kappa', \ell_0, t)。
2. **解引用指针 m**
- **执行 let m' = ∗m**：**使用 lrust-deref-na**，得到 m'，并更新资源。
- **释放指针 m****执行 delete(1, m)**：**使用 lrust-delete**，消耗 m \mapsto m' 和 \text{Dealloc}(m, 1, 1)。
3. **分配新的内存 let r = new(1)**
- **使用 lrust-new**，得到 r \mapsto v_r，其中 v_r 是未初始化的值。
4. **执行 r := m'**
- **使用 lrust-assign-na**，将 m' 的值赋给 r。
5. **进入循环 loop**
- **循环不变式**需要证明以下循环不变式（详见 **mutex-lock-loop**）：
$$
\left\{
\begin{array}{l}
J\varphi\ \text{ve}\ \alpha K \ast J\varphi\ \text{vl}\ []K(q) \ast \\
J\text{ret}\ \mathcal{C}\ \text{cont}(\varphi\ \text{vl}\ []; r.\ r\ \mathcal{C}\ \text{own}\ \text{mutex\_guard}(\alpha, \tau))K(t) \ast \\
\text{Dealloc}(r, 1, 1) \ast r \mapsto m' \ast \\
\alpha \sqsubseteq \kappa' \ast &^{\alpha}_{N_{\text{rust}}}\ \!\!\!\!\!\!\!\!\!\!\text{at}\ M_{\tau}(\kappa', m', t) \ast [\text{NaInv} : t.>]
\end{array}
\right\}
\ \text{jump loop}(m', r)
\ \{ \text{True} \}
$$
- **证明循环****使用 hoare-rec**（第 133 页），假设循环体已经满足规格，然后在循环体内证明循环不变式的保持。
6. **在循环内执行 CAS 操作**
- **打开原子借用****使用 Lalive-sem**，获取生命周期令牌 `[α]_{q'}`。**使用 LftL-at-acc-tok**，打开原子借用，得到 `M_{\tau}(\kappa', m', t)`。
- **展开互斥锁的不变式 M_{\tau}(\kappa', m', t)**有两种可能性：**锁定状态**：`m' \mapsto \text{true}`。**解锁状态**：`m' \mapsto \text{false} \ast &^{\kappa'}_{\text{full}} \left( \exists v.\ (m' + 1) \mapsto v \ast J\tau K.\text{own}(t, v) \right)`。
- **执行 CAS(m', false, true)****使用 lrust-cas-int**，执行 CAS 操作。如果 `m'` 指向 `false`，CAS 成功，`b = \text{true}`，并将 `m'` 更新为 `\text{true}`。如果 `m'` 指向 `true`，CAS 失败，`b = \text{false}`。
- **更新原子借用****关闭原子借用**，根据 CAS 操作的结果，选择合适的不变式分支。
7. **根据 CAS 结果处理**
- **如果 b = \text{true}**CAS 成功，我们获得了锁的所有权，包括内容的所有权。将所有权资源组合，得到 `Jr\ \mathcal{C}\ \text{own}\ \text{mutex\_guard}(\alpha, \tau)K(t)`。调用延续 `ret(r)`，完成证明。
- **如果 b = \text{false}**CAS 失败，锁被其他线程持有。使用循环不变式，重新进入循环，继续尝试。
**结论**

- 我们成功地证明了 Mutex::lock 方法在语义上是良类型的，即它的实现符合类型系统的语义解释，确保了获取锁的操作是安全的。
#### **验证 MutexGuard::deref_mut 方法**

**MutexGuard::deref_mut 方法的实现**

在 λRust 中，`MutexGuard::deref_mut` 方法的源码如下：

```rust
funrec deref_mut(g) ret ret :=
    let g' = ∗g in
    delete(1, g);
    let m = ∗g' in
    let r = new(1) in
    r := m.1 ;
    jump ret(r)
```

- **解释**：g：指向可变引用 &\text{mut}\ \text{MutexGuard}<'a, T> 的指针。∗g：对指针 g 解引用，得到 g'，即 MutexGuard 的地址。delete(1, g)：释放指针 g 指向的内存。∗g'：对 g' 解引用，得到 m，即 Mutex<T> 的地址。r := m.1：计算 m + 1 的地址，即锁内容的位置，赋给 r。jump ret(r)：调用延续 ret，将指针 r 作为参数。
**MutexGuard::deref_mut 方法的类型**

在 λRust 中，`MutexGuard::deref_mut` 的类型为：
\text{deref\_mut} : \forall \alpha, \beta.\ \text{fn}(\varphi : \varphi\ \text{ve}\ \beta, \beta\ \text{ve}\ \alpha;\ &^{\beta}_{\text{mut}}\ \text{mutex\_guard}(\alpha, \tau)) \rightarrow &^{\beta}_{\text{mut}}\ \tau
- **解释**：\forall \alpha, \beta：对于所有的生命周期 \alpha 和 \beta。\beta\ \text{ve}\ \alpha：表示 \beta \sqsubseteq \alpha，即引用的生命周期必须不超过被引用值的生命周期。\text{fn}(\varphi : \varphi\ \text{ve}\ \beta, \beta\ \text{ve}\ \alpha;\ &^{\beta}_{\text{mut}}\ \text{mutex\_guard}(\alpha, \tau)) \rightarrow &^{\beta}_{\text{mut}}\ \tau：一个函数，接受类型为 &^{\beta}_{\text{mut}}\ \text{mutex\_guard}(\alpha, \tau) 的可变引用，返回类型为 &^{\beta}_{\text{mut}}\ \tau 的可变引用。
**验证目标**

根据 **S-fn** 规则和 **sem-fn-body** 规则，我们需要证明以下 Iris Hoare 三元组：

$$
\left\{
\begin{array}{l}
J\varphi\ \text{ve}\ \beta, \beta\ \text{ve}\ \alpha K \ast J\varphi\ \text{vl}\ []K(q) \ast \\
J\text{ret}\ \mathcal{C}\ \text{cont}(\varphi\ \text{vl}\ []; r.\ r\ \mathcal{C}\ \text{own}\ &^{\beta}_{\text{mut}}\ \tau)K(t) \ast \\
Jg\ \mathcal{C}\ \text{own}\ &^{\beta}_{\text{mut}}\ \text{mutex\_guard}(\alpha, \tau)K(t) \ast [\text{NaInv} : t.>]
\end{array}
\right\}
\ \text{call deref\_mut}(g)\ \text{ret}\ \text{ret}
\ \{ \text{True} \}
$$

**证明大纲**

证明大纲详见 **Figure 13.5**。

**详细证明步骤**

1. **展开所有权谓词**
- **展开 Jg\ \mathcal{C}\ \text{own}\ &^{\beta}_{\text{mut}}\ \text{mutex\_guard}(\alpha, \tau)K(t)**：根据 **own-ptr-own** 和 **mut-ref-own**，我们有：Jg\ \mathcal{C}\ \text{own}\ &^{\beta}_{\text{mut}}\ \text{mutex\_guard}(\alpha, \tau)K(t) = g \mapsto \ell_0 \ast \text{Dealloc}(g, 1, 1) \ast &^{\beta}_{\text{full}} \left( \exists w.\ \ell_0 \mapsto w \ast J\text{mutex\_guard}(\alpha, \tau)K.\text{own}(t, w) \right)
- **解引用指针 g****执行 let g' = ∗g**，得到 `g'`。**释放指针 g**，执行 `delete(1, g)`。
2. **展开 J\text{mutex\_guard}(\alpha, \tau)K.\text{own}(t, w)**
- **使用 mutexguard-own**，我们有：J\text{mutex\_guard}(\alpha, \tau)K.\text{own}(t, w) = \exists \kappa'.\ \alpha \sqsubseteq \kappa' \ast &^{\alpha}_{N_{\text{rust}}}\ \text{at}\ M_{\tau}(\kappa', w, t) \ast &^{\kappa'}_{\text{full}} \left( \exists v.\ (w + 1) \mapsto v \ast J\tau K.\text{own}(t, v) \right)
3. **处理嵌套的借用**
- **问题**：我们有嵌套的完整借用 `&^{\beta}_{\text{full}} &^{\kappa'}_{\text{full}}`，需要将其合并。
- **使用 LftL-bor-unnest**（第 155 页），将嵌套的借用转换为交叉生命周期的借用 `&^{\beta \sqcap \kappa'}_{\text{full}}`。
- **验证生命周期包含关系**由于 `\beta \sqsubseteq \alpha`，并且 `\alpha \sqsubseteq \kappa'`，因此有 `\beta \sqsubseteq \kappa'`。因此，`\beta \sqsubseteq \beta \sqcap \kappa'`。
4. **获取锁内容的可变引用**
- **计算 m + 1**，得到锁内容的位置。
- **分配新的内存 let r = new(1)**。
- **执行 r := m.1**，将锁内容的地址赋给 `r`。
5. **组合所有权**
- **将资源组合，得到 Jr\ \mathcal{C}\ \text{own}\ &^{\beta}_{\text{mut}}\ \tau K(t)**。
- **调用延续 ret(r)**，完成证明。
**结论**

- 我们成功地证明了 MutexGuard::deref_mut 方法在语义上是良类型的，即它的实现符合类型系统的语义解释，确保了获取锁内容的可变引用的操作是安全的。
#### **验证 MutexGuard::drop 方法**

**MutexGuard::drop 方法的实现**

在 λRust 中，`MutexGuard::drop` 方法的源码如下：

```rust
funrec drop(g) ret ret :=
    let m = ∗g in
    delete(1, g);
    m :=sc false;
    let r = new(0) in
    jump ret(r)
```

- **解释**：g：类型为 \text{mutex\_guard}(\alpha, \tau) 的值。∗g：对 g 解引用，得到 m，即 Mutex<T> 的地址。delete(1, g)：释放 g 指向的内存。m :=sc false：使用原子操作，将 m 的值设为 \text{false}，释放锁。let r = new(0)：分配大小为 0 的新内存，返回指针 r。jump ret(r)：调用延续 ret，将指针 r 作为参数。
**MutexGuard::drop 方法的类型**

在 λRust 中，`MutexGuard::drop` 的类型为：

$$
\text{drop} : \forall \alpha.\ \text{fn}(\varphi : \varphi\ \text{ve}\ \alpha;\ \text{mutex\_guard}(\alpha, \tau)) \rightarrow ()
$$

- **解释**：\forall \alpha：对于所有的生命周期 \alpha。\text{fn}(\varphi : \varphi\ \text{ve}\ \alpha;\ \text{mutex\_guard}(\alpha, \tau)) \rightarrow ()：一个函数，接受类型为 \text{mutex\_guard}(\alpha, \tau) 的值，返回类型为 ()（空元组）。
**验证目标**

根据 **S-fn** 规则和 **sem-fn-body** 规则，我们需要证明以下 Iris Hoare 三元组：

$$
\left(
J\varphi\ \text{ve}\ \alpha K \ast J\varphi\ \text{vl}\ []K(q) \ast J\text{ret}\ \mathcal{C}\ \text{cont}(\varphi\ \text{vl}\ []; r.\ r\ \mathcal{C}\ \text{own}\ ())K(t) \ast Jg\ \mathcal{C}\ \text{own}\ \text{mutex\_guard}(\alpha, \tau)K(t) \ast [\text{NaInv} : t.>]
\right)
\ \text{call drop}(g)\ \text{ret}\ \text{ret}
\ \{ \text{True} \}
$$

**证明大纲**

证明大纲详见 **Figure 13.6**。

**详细证明步骤**

1. **展开所有权谓词**
- **展开 Jg\ \mathcal{C}\ \text{own}\ \text{mutex\_guard}(\alpha, \tau)K(t)**：根据 **own-ptr-own**，我们有：
$$
Jg\ \mathcal{C}\ \text{own}\ \text{mutex\_guard}(\alpha, \tau)K(t) = g \mapsto \ell_0 \ast \text{Dealloc}(g, 1, 1) \ast J\text{mutex\_guard}(\alpha, \tau)K.\text{own}(t, \ell_0)
$$
2. **解引用指针 g**
- **执行 let m = ∗g**，得到 `m`。
- **释放指针 g**，执行 `delete(1, g)`。
3. **展开 J\text{mutex\_guard}(\alpha, \tau)K.\text{own}(t, m)**
- **使用 mutexguard-own**，我们有：J\text{mutex\_guard}(\alpha, \tau)K.\text{own}(t, m) = \exists \kappa'.\ \alpha \sqsubseteq \kappa' \ast &^{\alpha}_{N_{\text{rust}}}\ \text{at}\ M_{\tau}(\kappa', m, t) \ast &^{\kappa'}_{\text{full}} \left( \exists v.\ (m + 1) \mapsto v \ast J\tau K.\text{own}(t, v) \right)
4. **释放锁**
- **使用 Lalive-sem**，获取生命周期令牌 `[α]_{q'}`。
- **打开原子借用**，使用 `LftL-at-acc-tok`，得到 `M_{\tau}(\kappa', m, t)`。
- **执行 m :=sc false**，使用 `lrust-assign-na`，将锁标志设为 `\text{false}`。
- **更新原子借用****重新建立不变式**，根据新的锁状态 `m \mapsto \text{false}`，提供锁内容的所有权。**关闭原子借用**，完成对不变式的更新。
5. **返回**
- **分配大小为 0 的内存 let r = new(0)**。
- **调用延续 ret(r)**，完成证明。
**结论**

- 我们成功地证明了 MutexGuard::drop 方法在语义上是良类型的，即它的实现符合类型系统的语义解释，确保了释放锁的操作是安全的。
#### **总结**

通过对 `Mutex::lock`、`MutexGuard::deref_mut` 和 `MutexGuard::drop` 方法的验证，我们成功地证明了 `Mutex` 和 `MutexGuard` 的关键公共操作在语义上是良类型的。这些验证确保了使用 `Mutex` 和 `MutexGuard` 的程序在类型系统的语义解释下是安全的。

主要内容包括：

1. **验证 Mutex::lock 方法**：
- 展开 `Mutex::lock` 方法的实现和类型解释。
- 详细证明了自旋锁的实现如何安全地获取锁。
- 关键步骤包括展开所有权谓词、处理循环不变式、执行原子比较并交换操作、更新原子借用等。
2. **验证 MutexGuard::deref_mut 方法**：
- 展开 `MutexGuard::deref_mut` 方法的实现和类型解释。
- 处理了嵌套借用的展开和合并，确保获得对锁内容的可变引用。
- 关键步骤包括展开所有权谓词、处理嵌套的完整借用、验证生命周期的包含关系、组合所有权资源等。
3. **验证 MutexGuard::drop 方法**：
- 展开 `MutexGuard::drop` 方法的实现和类型解释。
- 详细证明了如何安全地释放锁，包括更新锁状态和重新建立不变式。
- 关键步骤包括展开所有权谓词、打开和关闭原子借用、执行原子写操作等。
通过这些验证，作者展示了如何在复杂的并发和同步场景下，使用形式化的语义模型和程序逻辑，验证实际编程语言的关键特性。这对于编程语言理论、形式化验证和安全关键系统的开发具有重要意义。

**全面总结：**

在本节中，作者详细展示了如何验证 `Mutex` 和 `MutexGuard` 类型的关键公共操作在语义上的正确性，确保它们在类型系统的语义解释下是安全的。

主要内容包括：

1. **定义 Mutex 和 MutexGuard 的语义模型**：
- 包括所有权谓词和共享谓词的定义。
- 解释了互斥锁的不变式以及原子借用的使用。
2. **验证关键公共操作**：
- **Mutex::lock**：验证了获取锁的操作，详细证明了自旋锁的实现和循环不变式的保持。
- **MutexGuard::deref_mut**：验证了获取锁内容的可变引用的操作，处理了嵌套借用和生命周期的关系。
- **MutexGuard::drop**：验证了释放锁的操作，确保锁的状态和不变式的正确更新。
3. **处理复杂的所有权和借用关系**：
- 使用了 Iris 程序逻辑中的各种规则，如 `LftL-bor-exists`、`LftL-bor-split`、`LftL-bor-unnest` 等。
- 处理了嵌套的完整借用、延迟共享、生命周期的包含关系等复杂问题。
4. **确保类型系统的健全性**：
- 通过详细的证明，展示了这些操作在语义上是良类型的，确保了程序的安全性。
- 这为验证使用 `Mutex` 和 `MutexGuard` 的 Rust 程序的安全性奠定了基础。
本节的工作展示了如何在复杂的并发和同步场景下，使用形式化的语义模型和程序逻辑，验证实际编程语言的关键特性。这对于编程语言理论、形式化验证和安全关键系统的开发具有重要意义。
 #  
 Thought for 11 seconds
**概览：**

您提供的内容来自论文《Understanding and Evolving the Rust Programming Language》的 **第 14 章：相关工作**，具体是 **14.1 节：用于状态的次结构类型系统（Substructural type systems for state）**。

本节主要讨论了与 Rust 有关的其他次结构类型系统（substructural type systems）和它们在管理状态和内存安全方面的相关工作。次结构类型系统是一类类型系统，它们使用线性类型、所有权和/或区域来保证对堆内存操作的安全性。这些系统在过去几十年中得到了广泛的研究和发展，对 Rust 的设计产生了重要影响。

本节重点讨论了以下内容：

1. **与 Rust 的区别**：作者强调了 Rust 与之前的次结构类型系统之间的两个关键区别：
- **unsafe 代码**：Rust 允许使用 unsafe 代码来扩展类型系统的范围，这种特性在之前的次结构类型系统中并不存在。
- **&mut T 可变引用**：Rust 引入了独特的可变引用 &mut T，它们是唯一的（unique pointers），并支持再借用（reborrowing）。这种特性也在之前的系统中很少见。
2. **线性区域（Linear regions）**：讨论了 Fluet、Morrisett 和 Ahmed 的工作，他们的线性区域与 Rust 的生命周期逻辑有许多相似之处，但没有处理可变引用和再借用。
3. **语义次结构健全性证明**：提到了几个使用逻辑关系（logical relations）进行健全性证明的次结构类型系统，例如 L³、λURAL 和 Krishnaswami 等人的“表面次结构”类型系统。作者指出他们的动机与本工作不同。
4. **其他相关工作**：
- **Gordon 等人的并行安全类型系统**：讨论了一个用于安全并行的类型系统，其中的唯一指针类似于 Rust 的可变引用。
- **Cyclone**：一种安全的 C 方言，使用区域来管理内存，但与 Rust 的生命周期有本质区别。
- **Cogent**：一种纯函数、线性类型的语言，旨在实现文件系统并验证其功能正确性。
- **Mezzo**：一种拥有与分离逻辑平行的次结构类型系统的语言，与 Rust 有一些相似之处，但在所有权、借用和共享的处理上有显著差异。
本节的核心是在深入探讨这些相关工作后，突出 Rust 的独特之处，特别是在处理 `unsafe` 代码和独特的可变引用方面。这些特性使得 Rust 能够提供更强的安全保证，同时保持对系统级编程的灵活性。

**详细解读：**

### **第 14 章：相关工作**

在本章中，作者讨论了与 Rust 相关的其他工作，主要分为两大类：

1. **其他次结构类型系统**：这些系统使用线性类型、所有权和/或区域来保证堆操作的安全性。
2. **其他关于 Rust 的工作**：包括对 Rust 本身的研究和扩展。
在 **14.1 节：用于状态的次结构类型系统** 中，作者重点讨论了第一类工作，即其他次结构类型系统。

#### **14.1 次结构类型系统用于状态**

过去几十年中，研究者们开发了各种语言和类型系统，它们使用线性类型、所有权和/或区域来保证对堆内存操作的安全性。这些系统包括：

- **线性类型（Linear types）**：如 Wadler 在 1990 年提出的“线性类型可以改变世界！”（Wadler, 1990）。
- **所有权类型（Ownership types）**：如 Clarke、Potter 和 Noble 在 1998 年提出的用于灵活别名保护的所有权类型（Clarke et al., 1998）。
- **区域（Regions）**：如 Fluet、Morrisett 和 Ahmed 在 2006 年提出的“线性区域”（Fluet et al., 2006）。
这些工作对 Rust 的设计产生了重要影响，但详细讨论这些影响超出了本文的范围。

此外，还有一些不同方向的工作，如 Ynot、FCSL 和 F*，它们将分离逻辑的变体整合到依赖类型理论中。这些系统旨在对低级命令式代码进行完全的功能验证，因此需要大量的手动证明和/或类型注释，而这与 Rust 的自动化安全保证不同。

**作者在本节中关注了两个将 Rust 和本文的证明与先前的次结构语言和它们的健全性证明区分开的关键区别：unsafe 代码和 &mut T 可变引用。**

##### **unsafe 代码**

- **大多数先前的系统是封闭世界（closed-world）的**：它们由一组固定的规则定义，并使用 **句法技术（syntactic techniques）** 证明其健全性（Wright and Felleisen, 1994）。这种方法的限制在于无法扩展类型系统的范围。
- **Rust 的 unsafe 代码**：如 **第 1.2 节** 所述，Rust 使用 unsafe 代码来扩展类型系统的范围，这种特性 **根本不适合** 封闭世界的范式。unsafe 代码允许程序员绕过类型系统的一些限制，以实现底层操作，但要求程序员自己保证安全性。
##### **&mut T 可变引用**

- **Rust 的独特之处在于可变引用是唯一的指针（unique pointers）**，并与生命周期（lifetime）相关联。
- **再借用（Reborrowing）**：可变引用支持再借用，这意味着我们可以在代码的某个点上拥有指向同一目标的多个可变引用，但在任何给定的时刻，只有一个可被使用。
- **先前的工作通常允许所有区域指针被复制**：在这些系统中，区域指针可以自由地复制和共享，没有类似于 Rust 的唯一性约束。
- **历史背景**：值得注意的是，尽管可变引用的唯一性是 Rust 今天的核心特性，但在 Rust 的早期开发阶段（2015 年之前）并非如此。**2012 年**，Matsakis 在博客文章“想象一下再也听不到‘可别名的、可变的’这个短语”中，开始了朝着可变引用唯一性的第一步（Matsakis, 2012）。**2014 年**，通过排除可能别名的读取访问，可变引用成为完全唯一的指针（Matsakis, 2014）。
#### **线性区域（Linear Regions）**

- **Fluet、Morrisett 和 Ahmed** 的工作（Fluet et al., 2006）在许多方面与 **生命周期逻辑（lifetime logic）** 相似。**区域能力（region capabilities）** 对应于生命周期令牌（lifetime tokens）。**引用（references）** 对应于借用（borrows）。
- **差异**：他们的方法允许将变异（mutation）与别名（aliasing）相结合；不存在类似于 &mut T 的概念。这并不是问题，因为他们没有考虑内部指针（写入一个指针可以使别名指针失效）或并发性。
- **推测**：如果要扩展线性区域以处理 Rust 的唯一借用（unique borrows），可能需要类似于本文的生命周期逻辑。
#### **语义次结构健全性证明**

作者提到了几个使用 **逻辑关系（logical relations）** 进行健全性证明的次结构类型系统：

- **L³**（Ahmed et al., 2007）
- **λURAL**（Ahmed et al., 2005）
- **Krishnaswami 等人** 的“表面次结构”类型系统（Krishnaswami et al., 2012）
**动机的差异**：

- **Ahmed 等人** 的动机与本文的动机有所不同。他们的一个动机是为子结构扩展的基础证明代码项目（Foundational Proof-Carrying Code）构建基础（Appel, 2001）。另一个动机是使在增量构建语言特性时能够模块化地扩展健全性证明。
- **Krishnaswami 等人** 的工作重点是构建一个可以扩展的健全性证明，能够验证通过 unsafe 特性扩展 Rust 的核心类型系统的库的健全性。
- **不同之处**：所有先前的语义健全性证明都是直接使用集合论的步指数模型（set-theoretic step-indexed models）完成的。而在本文的工作中，为了建模 Rust 的生命周期和借用的复杂性，我们发现使用 Iris 和我们的生命周期逻辑所提供的更高层次的抽象是必要的。
#### **Gordon 等人的并行安全类型系统**

- **Gordon 等人** 描述了一个用于安全并行的类型系统，基于使用属性限定引用，包括描述唯一指针的 isolated 属性（Gordon et al., 2012）。
- **类似于 Rust**：引用权限是可传递的：当通过一个引用加载一个引用时，两个权限被组合以获得新引用的权限（类似于本文第 128 页的 S-deref-bor-own 和 S-deref-bormut）。
- **区别**：他们特意避免使用区域，以使类型检查不依赖于词法作用域。这使得类型系统显著简化，他们仍然可以通过恢复规则（recovery rules）支持暂时削弱唯一性。然而，恢复比再借用弱：访问 isolated 字段需要破坏性读取（destructive reads）。
- **健全性证明**：他们的系统的健全性在 Views 框架中以语义方式证明，但他们没有明确讨论类似于 unsafe 代码的内容。
#### **Cyclone**

- **Cyclone** 是一种安全的 C 方言，旨在保持程序员对内存管理的控制（Jim et al., 2002；Swamy et al., 2006）。
- **使用区域作为动态内存分配器的模型（“arenas”）**，与 Rust 中生命周期完全是类型系统的虚构概念不同。
- **区别**：Cyclone 支持“幽灵”区域（ghost regions，称为 alias），其目的是允许临时别名化原本线性/唯一的指针。Cyclone 没有 Rust 中的 &mut T 的等价物，它提供对 T 的临时（由“幽灵”区域控制）独占访问。
#### **Cogent**

- **Cogent** 是一种纯函数、线性类型的语言，旨在实现文件系统并验证其功能正确性（O'Connor et al., 2016）。
- **特点**：其线性类型系统允许使用就地更新（in-place updates）来有效地编译为机器代码，而纯函数语义则支持等式推理。
- **与 Rust 的关系**：其设计使得缺失的功能可以在 C 函数中实现（类似于 Rust 中的 unsafe 代码），这些函数被赋予类型以在 Cogent 程序中强制正确使用。然而，Cogent 的语言和类型系统比 Rust 简单得多（例如，不支持递归、迭代、借用或可变状态）。
#### **Mezzo**

- **Mezzo** 可以被视为介于句法方法和语义方法之间（Balabonski et al., 2016）。
- **特点**：它具有一个次结构类型系统，其表达能力与分离逻辑平行。其健全性证明是模块化的，作者首先验证一个核心类型系统，然后添加各种扩展。这依赖于称为 **单调分离代数（monotonic separation algebras）** 的抽象资源概念。
- **与 Rust 的比较**：Mezzo 的类型系统将所有权与数据解耦，比 Rust 提供了更大的灵活性。然而，Rust 中的一些关键模式在 Mezzo 中难以或不可能表示。**借用模式**：作者描述了一种他们称为“借用”的设计模式，其目的是与 Rust 的可变引用（&mut T）非常相似。然而，Mezzo 中的借用在类型系统中被编码，要求程序员处理作为闭包编码的“魔法棒”（magic wands）。一些 Rust 提供的更强大的借用用法（例如对向量 Vec 进行可变迭代，动态地发出对向量每个元素的可变引用）在 Mezzo 中不清楚如何编码。**共享的差异**：在 Mezzo 中，共享需要不可逆地使数据不可变。而在 Rust 中，共享是通过共享引用完成的。这意味着共享是暂时的，由该引用的生命周期控制。这对程序员的便利性来说是一个巨大的胜利，因为这意味着所有在共享只读数据上工作的方法（例如 Vec::len 用于确定向量的长度）也可以在可变引用或完全拥有的向量上使用。
**全面总结：**

在 **14.1 节：用于状态的次结构类型系统** 中，作者详细讨论了与 Rust 相关的其他次结构类型系统，以及它们在状态和内存安全管理方面的相关工作。主要内容和结论包括：

1. **Rust 与先前系统的关键区别**：
- **unsafe 代码**：Rust 允许使用 unsafe 代码来扩展类型系统的范围，这在之前的次结构类型系统中是不常见的。大多数先前的系统是封闭世界的，使用句法技术来证明其健全性，而 Rust 的 unsafe 特性需要不同的方法来验证。
- **&mut T 可变引用**：Rust 引入了唯一的可变引用 &mut T，它们支持再借用（reborrowing）。这种特性允许在代码的某个点上拥有多个指向同一目标的可变引用，但在任何给定的时刻，只有一个可被使用。这在先前的系统中很少见。
2. **线性区域与生命周期逻辑的比较**：
- **Fluet、Morrisett 和 Ahmed** 的工作与 Rust 的生命周期逻辑有许多相似之处，但他们的方法允许将变异与别名相结合，没有处理 &mut T 和再借用的概念。
- 为了扩展线性区域以处理 Rust 的唯一借用，可能需要类似于本文的生命周期逻辑。
3. **语义次结构健全性证明的差异**：
- 先前的一些工作使用逻辑关系来证明次结构类型系统的健全性，但他们的动机与本文不同，且没有处理类似于 Rust 的 unsafe 代码和复杂的借用机制。
- 本文发现，为了建模 Rust 的生命周期和借用的复杂性，需要使用 Iris 和生命周期逻辑所提供的更高层次的抽象。
4. **其他相关工作**：
- **Gordon 等人的并行安全类型系统**：他们的类型系统有一些与 Rust 类似的特性，但在处理唯一性和恢复方面与 Rust 有所不同。
- **Cyclone**：一种安全的 C 方言，使用区域作为动态内存分配器的模型，与 Rust 的生命周期概念不同。
- **Cogent**：一种纯函数、线性类型的语言，设计用于实现文件系统并验证其功能正确性，但其语言和类型系统比 Rust 简单得多。
- **Mezzo**：具有与分离逻辑平行的次结构类型系统，但在所有权、借用和共享的处理上与 Rust 有显著差异。
5. **对 Rust 的独特性和优势的强调**：
- Rust 的共享是通过共享引用完成的，这使得共享是暂时的，由引用的生命周期控制。
- 这种设计对于程序员的便利性来说是一个巨大的胜利，因为它允许在不同所有权和借用情况下使用相同的接口。
**总结而言**，作者通过比较和分析多个先前的次结构类型系统，强调了 Rust 的独特之处，特别是在处理 `unsafe` 代码和独特的可变引用方面。这些特性使得 Rust 能够在保持系统级编程灵活性的同时，提供更强的安全保证。通过深入理解这些相关工作，我们可以更好地理解 Rust 的设计选择和它在类型系统方面的创新。
 #  
 Thought for 17 seconds
**概览：**

您提供的内容来自论文《Understanding and Evolving the Rust Programming Language》的 **第14章：相关工作**，具体是 **14.2节：Rust的验证**。本节主要讨论了对 Rust 程序和库进行形式化验证的相关工作，特别是涉及使用 `unsafe` 代码的情况。

本节涵盖了以下主要内容：

1. **Patina 项目**：对 Rust 类型系统的形式化，但由于其基于语法的方法，无法扩展以处理 `unsafe` 代码。
2. **CRUST**：一种有界模型检测器，旨在验证使用 `unsafe` 代码实现的 Rust 库的安全性。
3. **Lindner、Aparicius 和 Lindgren 的工作**：使用符号执行工具 KLEE 自动验证安全库不会导致程序崩溃（panic）。
4. **其他相关项目**：
- **Prusti**：利用 Rust 的强类型系统，将带有用户定义注释的 Rust 函数转换为 Viper，以进行形式化验证。
- **Ullrich 的工作**：将部分安全的 Rust 程序嵌入到 Lean 定理证明器的纯函数语言中，旨在验证函数正确性。
- **RustHorn**：将 Rust 程序转换为受限的 Horn 子句，提出了一种新的处理可变引用的方法。
本节的核心在于讨论这些项目如何利用 Rust 的类型系统和所有权模型来简化对系统代码的形式化验证，以及它们在处理 `unsafe` 代码时面临的挑战和方法。

**详细解读：**

### **14.2 Rust 的验证**

#### **Patina 项目**

- **简介**：**Patina** 是对 Rust 类型系统的形式化，包含部分的进展和保留证明（progress and preservation proofs）。这些证明是基于 **语法方法（syntactic methods）** 的。
- **局限性**：**无法扩展以处理 unsafe 代码**：由于其基于语法的方法，Patina 的证明无法涵盖 Rust 中使用的 `unsafe` 代码。Rust 中的 `unsafe` 代码允许程序员绕过类型系统的一些限制，以执行底层操作，需要特别的处理和验证。
- **与本文的关系**：为了使我们的形式化可行，我们没有重用 Patina 的语法和类型系统，而是从头开始设计了 **λRust**，以更好地适应 **Iris**（一种用于并发程序验证的框架）。
#### **CRUST**

- **简介**：**CRUST** 是一种 **有界模型检测器（bounded model checker）**，旨在验证使用 `unsafe` 代码实现的 Rust 库的安全性。它检查所有调用最多 **n** 个库方法的客户端是否不会触发内存安全错误。
- **特点**：**自动化验证**：提供了一种易于使用的自动化方式，在尝试完整的形式化证明之前检查 unsafe 代码。**成功发现了标准库中的一些健全性漏洞**：这些漏洞已在 Rust 的标准库中修复，CRUST 成功重新发现了它们。
- **局限性**：**只能一次考虑一个库**：由于只考虑一个库，CRUST 无法发现由于多个库交互而产生的错误。例如，有些错误可能来自于库之间的不兼容或相互作用，这在单独验证时无法检测到。
#### **Lindner、Aparicius 和 Lindgren 的工作**

- **简介**：他们使用 **KLEE** 中的 **符号执行（symbolic execution）** 来自动验证安全库不会导致程序崩溃（panic）。在 Rust 中，panic 是一种类似异常的机制，用于表示严重的意外错误条件。
- **特点**：**检测 unsafe 内部函数的前置条件违规**：例如，检测未检查的除法中的除以零操作（在这种情况下，除以零会导致未定义行为）。**帮助验证 unsafe 代码的安全封装**：通过检测前置条件的违规，确保 unsafe 代码被安全地封装在安全的抽象中。
#### **利用 Rust 类型系统的其他工作**

这些工作关注于 **利用 Rust 强大的类型系统来简化系统代码的形式化验证**。

##### **Prusti**

- **简介**：**Prusti** 将带有用户定义注释的 Rust 函数转换为 **Viper**，后者被用作底层的验证引擎。
- **特点**：**利用所有权信息**：转换过程中利用了编码在 Rust 类型系统中的所有权信息。用户只需指定可变或共享引用背后的值，而无需关注指向关系（points-to facts）。**简化验证过程**：通过利用类型系统的信息，减少了用户在形式化验证中的负担。
##### **Ullrich 的工作**

- **简介**：他展示了如何将一部分安全的 Rust 程序单子化地（monadically）嵌入到 **Lean 定理证明器**的纯函数语言中。
- **目标**：**验证函数正确性**：通过在 Lean 中表示 Rust 程序，利用 Lean 的证明能力来验证程序的函数正确性。
##### **RustHorn**

- **简介**：**RustHorn** 将 Rust 程序转换为 **受限的 Horn 子句（constrained Horn clauses）**。
- **特点**：**依赖所有权系统**：与 Prusti 类似，RustHorn 在转换过程中也依赖于 Rust 的所有权系统。**新颖的可变引用处理**：作者提出了一种新的方法，使用 **预言变量（prophecy variables）** 来处理可变引用。这种方法与我们在 RustBelt 中使用的生命周期逻辑完全不同。
- **未来工作**：**探索两种方法的关系**：由于 RustHorn 的方法与 RustBelt 的生命周期逻辑不同，探索它们之间的可能关系将是有趣的。
**全面总结：**

在 **14.2 节：Rust 的验证** 中，作者讨论了多个与 Rust 程序和库的形式化验证相关的工作。这些工作利用了 Rust 的类型系统和所有权模型，以不同的方式简化和实现对 Rust 代码的验证。

主要内容包括：

1. **Patina 项目**：
- 对 Rust 类型系统的形式化，但由于其基于语法的方法，无法扩展以处理 `unsafe` 代码。
- 为了更好地适应 Iris 框架，作者在本文中从头开始设计了 λRust，而没有重用 Patina 的语法和类型系统。
2. **CRUST**：
- 一种有界模型检测器，旨在验证使用 `unsafe` 代码实现的 Rust 库的安全性。
- 提供了一种自动化的方式，在尝试完整的形式化证明之前检查 `unsafe` 代码。
- 成功重新发现了一些已在 Rust 标准库中修复的健全性漏洞。
- 局限性在于只能一次考虑一个库，无法发现来自多个库交互的错误。
3. **Lindner、Aparicius 和 Lindgren 的工作**：
- 使用 KLEE 中的符号执行，自动验证安全库不会导致程序崩溃。
- 能够检测 `unsafe` 内部函数的前置条件违规，帮助验证 `unsafe` 代码的安全封装。
4. **利用 Rust 类型系统的其他工作**：
- **Prusti**：将带有用户定义注释的 Rust 函数转换为 Viper，以进行形式化验证。利用所有权信息，减少了用户在验证过程中的负担。
- **Ullrich 的工作**：将部分安全的 Rust 程序嵌入到 Lean 定理证明器中，旨在验证函数正确性。
- **RustHorn**：将 Rust 程序转换为受限的 Horn 子句。提出了使用预言变量处理可变引用的新方法，与 RustBelt 中的生命周期逻辑完全不同。作者认为探索两种方法之间的关系是有意义的。
**总结而言**，本节展示了在 Rust 的验证领域的各种努力，这些工作利用了 Rust 的强类型系统和所有权模型，旨在简化对系统代码的形式化验证。特别是，在处理 `unsafe` 代码时，这些工作提出了不同的方法来确保代码的安全性和正确性。

作者强调了这些方法的特点、优势和局限性，以及它们与本文工作的关系。例如，作者指出了 Patina 的局限性，以及为什么需要设计 λRust 来适应 Iris 框架。此外，作者提到了未来可能的研究方向，例如探索 RustHorn 中使用的预言变量方法与 RustBelt 的生命周期逻辑之间的关系。

通过对这些相关工作的深入讨论，作者展示了 Rust 社区在形式化验证方面的积极探索，以及这些工作如何共同推进对 Rust 程序安全性和正确性的理解和保障。
 #  
 Thought for 18 seconds
**概览：**

您提供的内容来自论文《理解和发展 Rust 编程语言》（Understanding and Evolving the Rust Programming Language）的 **第三部分：堆栈借用（Stacked Borrows）**，具体是 **第15章：唯一性和不可变性（Uniqueness and Immutability）**，以及其中的 **15.1节：堆中的可变引用（Mutable references in a stack）**。

本章的主要目标是介绍 **堆栈借用模型（Stacked Borrows）**，这是一个用于 Rust 的别名分析模型，旨在允许编译器基于局部（过程内）类型信息执行强有力的优化。堆栈借用模型通过将 Rust 类型系统中编码的强别名信息（特别是可变引用 `&mut T` 的唯一性和共享引用 `&T` 的只读性）转化为动态分析，从而在不依赖生命周期（lifetimes）的情况下，对包括 `unsafe` 代码在内的程序进行别名限制，确保优化的正确性。

具体来说，本章逐步构建了堆栈借用的语义：

1. **15.1节**：从最简单的情况开始，假设 Rust 只有可变引用 `&mut T`，没有共享引用 `&T` 或原始指针（raw pointers）。讨论在这种受限情况下的动态借用检查器的行为。
2. **15.2节**：介绍这种受限形式的堆栈借用的操作语义，定义了如何跟踪和管理引用的使用，以及如何检测违反别名规则的行为。
3. **15.3节和15.4节**：在模型中添加原始指针，展示操作语义如何排除原始指针的不当使用，并验证之前在 **1.3节** 中提到的优化示例的正确性。
4. **15.5节和15.6节**：扩展模型以处理共享引用 `&T`，并展示这种扩展如何启用新的优化。
本章的核心思想是将 Rust 编译器的静态借用检查器所执行的分析（基于生命周期）转化为动态分析（不依赖生命周期）。这样，即使是包含 `unsafe` 代码的程序也必须满足这个动态分析，从而允许编译器在优化时假设这些别名规则成立。由于生命周期在编译后会被擦除，并且编译器的生命周期推断可能发生变化，因此避免在堆栈借用模型中使用生命周期是一个明智的选择。

**详细解读：**

### **15.1 堆中的可变引用**

在这个简化的语言模型中，我们假设只有可变引用 `&mut T`，没有共享引用 `&T` 或原始指针。这时，动态版本的借用检查器是什么样子的呢？

首先，回顾一下借用检查器确保了两个关键性质：

1. **生命周期内的使用**：引用及其派生的所有引用只能在其生命周期内使用。
2. **独占性**：在引用的借用生命周期结束之前，原始被借用的对象不能被使用。
我们可以不使用生命周期来重新表述这些性质：**引用（及其派生引用）的每次使用都必须先于原始被借用对象的下次使用**。我们称之为 **堆栈原则（stack principle）**。这等价于借用检查器的行为，如果我们认为生命周期在引用的最后一次使用和原始对象的下次使用之间结束。

这个原则可以通过以下示例程序来理解：

```rust
1 let mut local = 0;
2 let x = &mut local;
3 let y = &mut *x; // 从 x 再借用到 y。
4 *x = 1; // 再次使用 x。
5 *y = 2; // 错误！在 x 被使用后又使用了 y。
```

在这个程序中，违反了堆栈原则，因为在第 5 行，对引用 `y` 的使用发生在对引用 `x` 的下次使用（第 4 行）之后（在 `y` 被创建之后的“下次”使用）。因此，借用检查器会拒绝这个程序。

观察变量的使用模式：

- 我们首先创建了 x，然后从 x 创建了 y。
- 然后我们再次使用 x，这应该使之前从 x 派生的引用 y 失效。
- 之后再次使用 y，这就是违反堆栈原则的地方。
这表明堆栈原则强制了引用的 **良好嵌套使用**：派生引用 `y` 的使用必须嵌套在对 `x` 的其他使用之间，不能随意交错。“XYXY”的使用序列（`x`、`y`、`x`、`y`）违反了这种嵌套。正如在良好嵌套的情况下，我们可以用 **堆栈** 来管理这种结构。

因此，堆栈借用模型通过跟踪 **允许访问某个内存位置的引用的堆栈**，来拒绝上述程序。我们称这个堆栈为 **借用堆栈（borrow stack）**，用于区分调用堆栈等其他堆栈。

- **创建新引用时**：将新引用推入堆栈顶端。
- **使用引用时**：需要确保引用在堆栈中，并将其上方的所有引用弹出，使得被使用的引用位于堆栈顶端。
如果引用不在堆栈中，那么使用它就违反了堆栈原则，导致未定义行为。

在上述示例中：

1. **第 2 行**：创建了引用 x，将其对应的标记推入堆栈。
2. **第 3 行**：从 x 再借用创建了 y，将 y 的标记推入堆栈。
3. **第 4 行**：使用了 x，根据规则，需要将 x 上方的所有标记（即 y）弹出，使得 x 位于堆栈顶端。
4. **第 5 行**：尝试使用 y，但此时 y 已经不在堆栈中，因此违反了堆栈原则。
### **15.2 借用检查器的操作模型**

为了精确地描述这个想法，我们需要能够区分指向同一内存位置的不同引用（例如，`x` 和 `y` 都指向 `local`）。为此，我们假设每个引用都带有一个唯一的 **标记（tag）**，在引用创建时生成，并在引用传递和复制时保持不变。

**正式定义**（参见 **Figure 15.1**）：

- **标记集合**：$t \in \text{Tag} := \mathbb{N}$，即自然数。
- **标量值**：$\text{Scalar} := \text{Pointer}(\ell, t) \mid z$，其中 $z \in \mathbb{Z}$ 是整数。
- **指针值**：$\text{Pointer}(\ell, t)$，由内存位置 $\ell$ 和标记 $t$ 组成。
- **堆栈项**：$\text{Item} := \text{Unique}(t) \mid \ldots$，目前只定义了 $\text{Unique}(t)$。
- **堆栈**：$\text{Stack} := \text{List}(\text{Item})$，即堆栈项的列表。
- **内存**：$\text{Mem} := \text{Loc} \rightharpoonup \text{Scalar} \times \text{Stack}$，即从位置到标量值和堆栈的映射。
**操作语义**定义如下：

- **规则（new-mutable-ref）**：每当从现有的指针值 $\text{Pointer}(\ell, t)$ 创建一个新的可变引用（通过 `&mut expr`）时：首先，这被视为对该指针值的使用（因此我们遵循后面的 use-1 规则）。选择一个新的、未使用过的标记 $t'$。新引用的值为 $\text{Pointer}(\ell, t')$。将 $\text{Unique}(t')$ 推入位置 $\ell$ 的借用堆栈顶端。
- **规则（use-1）**：每当使用指针值 $\text{Pointer}(\ell, t)$ 时：标记 $t$ 的项必须在位置 $\ell$ 的堆栈中。如果在其上方还有其他标记，则将它们弹出，使得标记 $t$ 的项位于堆栈顶端。如果 $\text{Unique}(t)$ 不在堆栈中，则程序具有未定义行为。
这些规则反映了 **堆栈原则**：新创建的引用只能在其项仍在堆栈中时使用，即直到下一次使用其被借用的引用（或原始对象）为止。

**示例**：

让我们通过一个带有注释的示例来观察这些规则的作用。我们将显示每个引用的运行时指针值，以及内存中借用堆栈的变化。假设 `local` 存储在位置 $\ell$，`h \in \text{Mem}$ 表示当前的内存状态。直接访问局部变量也使用一个标记，我们假设初始标记为 $0$。

```rust
1 let mut local = 42; // 存储在位置 `\ell`，标记为 0。
2 // 初始堆栈：h(`\ell`) = (42, [\text{Unique}(0)])
3 let x = &mut local; // x = \text{Pointer}(\ell, 1)
4 // 使用 local，将 x 的标记（1）推入堆栈：h(`\ell`) = (42, [\text{Unique}(0), \text{Unique}(1)])。（new-mutable-ref）
5 let y = &mut *x; // y = \text{Pointer}(\ell, 2)
6 // 使用 x，将 y 的标记（2）推入堆栈：h(`\ell`) = (42, [\text{Unique}(0), \text{Unique}(1), \text{Unique}(2)])。（new-mutable-ref）
7 *x += 1;
8 // 弹出 y 的标记（2），使 x 的标记（1）位于堆栈顶端：h(`\ell`) = (43, [\text{Unique}(0), \text{Unique}(1)])。（use-1）
9 *y = 2;
10 // 未定义行为！堆栈原则被违反：y 的标记（2）不在堆栈中。（use-1）
```

**解释**：

- **第 3 行**：创建了新的可变引用 x，生成标记 1，将 \text{Unique}(1) 推入堆栈。
- **第 5 行**：从 *x 创建了新的可变引用 y，生成标记 2，将 \text{Unique}(2) 推入堆栈。
- **第 7 行**：使用了 *x，根据 use-1 规则，x 的标记 1 必须在堆栈中。由于 x 上方有 y 的标记 2，需要将其弹出，使得 \text{Unique}(1) 位于堆栈顶端。
- **第 9 行**：尝试使用 *y，但 y 的标记 2 已经不在堆栈中，因此违反了堆栈原则，导致未定义行为。
**全面总结：**

在 **第15章：唯一性和不可变性** 中，作者介绍了 **堆栈借用模型（Stacked Borrows）** 的基本概念，旨在为 Rust 编译器提供一个别名分析模型，以便在包括 `unsafe` 代码的情况下，基于类型信息执行强有力的优化。堆栈借用模型通过将静态的借用检查（基于生命周期）转化为动态分析（不依赖生命周期），为编译器的优化提供了依据。

主要内容和结论包括：

1. **堆栈原则的提出**：
- 在只有可变引用的简化语言模型中，借用检查器确保引用的使用必须在其生命周期内，且原始被借用对象不能在借用结束前被使用。
- 通过 **堆栈原则**，不依赖生命周期地表述了这一性质：**引用的每次使用必须先于原始对象的下次使用**。
- 这强制了引用的 **良好嵌套使用**，防止了引用的任意交错使用。
2. **借用堆栈的引入**：
- 使用一个 **借用堆栈（borrow stack）** 来跟踪允许访问某个内存位置的引用。
- **新引用的创建**：将新的引用标记推入堆栈顶端。
- **引用的使用**：确保引用的标记在堆栈中，并弹出其上方的所有标记，使其位于堆栈顶端。
3. **操作语义的正式定义**：
- 引入了标记（tags）、指针值（pointers）、堆栈项（items）和内存模型的正式定义。
- 定义了创建新可变引用和使用引用的操作规则（`new-mutable-ref` 和 `use-1`）。
4. **示例的演示**：
- 通过详细的示例，展示了堆栈借用模型如何检测违反堆栈原则的代码。
- 解释了在不同操作下借用堆栈的变化，以及何时会导致未定义行为。
5. **避免依赖生命周期的必要性**：
- 由于生命周期在编译后被擦除，且编译器的生命周期推断可能发生变化，因此在堆栈借用模型中避免使用生命周期是必要的。
- 这使得模型更稳定，不会因为编译器内部实现的变化而影响程序的行为。
**结论**：

堆栈借用模型通过引入标记和借用堆栈，为 Rust 中的别名分析提供了一个动态、不依赖生命周期的机制。它确保了包括 `unsafe` 代码在内的程序遵守一定的别名规则，从而使编译器能够在优化过程中安全地利用类型信息。这个模型既足够灵活，可以兼容真实世界的 `unsafe` Rust 代码，又足够严格，可以防止未定义行为的发生。

通过深入理解堆栈借用模型，我们可以更好地理解 Rust 类型系统的设计理念，以及编译器如何在保持安全性的同时进行高效的优化。这对于编写高性能且安全的 Rust 程序具有重要意义。
 #  
 Thought for 14 seconds
**概览：**

您提供的内容来自论文《理解和发展 Rust 编程语言》（Understanding and Evolving the Rust Programming Language）的 **第三部分：堆栈借用（Stacked Borrows）**，具体是 **第15章：唯一性和不可变性（Uniqueness and Immutability）**，其中的 **15.3节：考虑原始指针（Accounting for raw pointers）** 和部分 **15.4节：重新标记和可变引用优化的证明概述（Retagging, and a proof sketch for the optimization on mutable references）**。

本章的主要目标是 **扩展堆栈借用模型，以包括对原始指针（raw pointers）的处理**。在之前的部分，堆栈借用模型仅处理了可变引用 `&mut T`，现在需要考虑原始指针，因为它们在 Rust 中的使用可能会影响程序的安全性和编译器的优化。

具体来说，作者讨论了以下内容：

1. **引入原始指针**：讨论如何在堆栈借用模型中处理通过类型转换（`expr as *mut T`）创建的原始指针。由于原始指针不受借用检查器的跟踪，因此需要在模型中对其进行特殊处理。
2. **修改操作语义**：引入新的规则来处理原始指针的创建和使用，定义了新的堆栈项（`SharedRW`）和新的标签（`⊥`）来表示未标记的原始指针。
3. **示例分析**：通过重新审视在第1.3节中的示例程序，展示了堆栈借用模型如何检测到程序中的未定义行为，以及为什么该程序违反了堆栈借用的规则。
4. **重新标记（Retagging）**：介绍了重新标记的概念，解释了为什么需要在函数开始时对传入的引用进行重新标记，以确保引用具有唯一的标签，从而使优化和分析能够正确地进行。
5. **优化的证明概述**：提供了一个证明概述，说明在堆栈借用模型下，为什么可以安全地进行某些优化（例如，将返回值优化为常量）。
6. **讨论重新标记的时机**：解释了何时需要插入重新标记，以及它对编译器优化的影响。
通过这些讨论，作者展示了堆栈借用模型如何处理原始指针，以及如何确保编译器在存在 `unsafe` 代码的情况下仍然可以进行安全的优化。

**详细解读：**

### **15.3 考虑原始指针**

#### **背景**

在之前的模型中，堆栈借用仅处理了可变引用 `&mut T`，没有涉及原始指针。然而，在 Rust 中，原始指针可以通过类型转换（`expr as *mut T`）从可变引用创建，并且它们的使用可能导致违反别名规则的情况。因此，我们需要扩展堆栈借用模型，以正确地处理原始指针。

#### **示例程序**

作者首先回到在 **第1.3节** 中介绍的示例程序，该程序展示了可能违反别名规则的情况：

```rust
fn example1(x: &mut i32, y: &mut i32) -> i32 {
    *x = 42;
    *y = 13;
    return *x; // 应该读取 42，因为 x 和 y 不能别名！
}

fn main() {
    let mut local = 5;
    let raw_pointer = &mut local as *mut i32;
    let result = unsafe {
        example1(&mut *raw_pointer, &mut *raw_pointer)
    };
    println!("{}", result); // 输出 "13"。
}
```

**解释**：

- 在 main 函数中，将可变引用 &mut local 转换为原始指针 *mut i32，然后通过不安全代码 unsafe，将两个从原始指针解引用得到的可变引用传递给 example1。
- 按照 Rust 的安全规则，x 和 y 应该指向不同的内存位置（不能别名），因此在 example1 中，*x 应该始终为 42。
- 然而，由于使用了原始指针，x 和 y 实际上指向了同一位置 local，导致 *x 在被 *y 修改后变为 13，违反了预期。
#### **问题**

我们的目标是 **解释该程序如何以及在何处违反了堆栈借用模型（即动态借用检查器）**。我们需要使该程序违反堆栈借用的规则，否则它将构成对我们希望的优化（使 `example1` 始终返回 `42`）的反例。

#### **处理原始指针**

为了处理原始指针，我们需要在模型中进行以下扩展：

1. **未标记的指针**：由于原始指针不受借用检查器的跟踪，堆栈借用模型也不尝试区分指向同一位置的不同原始指针。我们将原始指针视为 **未标记的（untagged）**。
2. **扩展标签集合**：将标签集合 `Tag` 扩展为包含一个特殊值 `⊥`，表示未标记的原始指针：
$$
t \in \text{Tag} := \mathbb{N} \cup \{\bot\}
$$
3. **添加新的堆栈项**：在堆栈项中添加新的类型 `SharedRW`（“共享读写”），表示位置已被共享，所有原始指针都可以读取和写入：
$$
\text{Item} := \text{Unique}(t) \mid \text{SharedRW} \mid \ldots
$$
#### **修改操作语义**

我们需要修改操作语义，以考虑原始指针的创建和使用。

##### **规则（new-mutable-raw-1）**

当通过类型转换（`expr as *mut T`）将可变引用（`expr: &mut T`）转换为原始指针时：

1. 这被视为对可变引用的使用（遵循后面的 use-2 规则）。
2. 新的原始指针的值为 Pointer($\ell$, $\bot$)，即地址为 $\ell$，标签为 $\bot$。
3. 将 SharedRW 推入位置 $\ell$ 的借用堆栈顶端。
##### **规则（use-2）**

当使用指针值 `Pointer(`$\ell$, $t$`)` 时：

1. 如果 $t = \bot$，则 SharedRW 必须在位置 $\ell$ 的堆栈中。
2. 如果 $t \neq \bot$，则 Unique($t$) 必须在堆栈中。
3. 如果在其上方还有其他标签，则将它们弹出，使得所需的项位于堆栈顶端。
4. 如果有多个匹配的项（当堆栈中存在多个相同标签的项时），使用最上面的那个，即尽可能少地弹出项。
5. 如果所需的项不在堆栈中，则程序违反堆栈原则。
**注意**：对于带标签的指针值（即可变引用），`use-2` 与之前的 `use-1` 相同。

#### **示例分析**

现在，我们重新审视示例程序，并按照修改后的规则跟踪其执行过程。为了便于阅读，我们调整了函数的顺序，使其从上到下读取。

```rust
fn main() {
    let mut local = 5; // 存储在位置 `\ell`，标记为 0，h(`\ell`) = (5, [\text{Unique}(0)])。
    let raw_pointer = &mut local as *mut i32; // raw_pointer = \text{Pointer}(\ell, \bot)
    // 临时引用获得标签 1，并被推入堆栈：h(`\ell`) = (5, [\text{Unique}(0), \text{Unique}(1)])。
    // 然后原始指针被推入堆栈：h(`\ell`) = (5, [\text{Unique}(0), \text{Unique}(1), \text{SharedRW}])。
    // （new-mutable-ref，new-mutable-raw-1）
    let result = unsafe { example1(
        &mut *raw_pointer, // x = \text{Pointer}(\ell, 2)
        // 引用被推入原始指针之上：h(`\ell`) = (5, [\ldots, \text{SharedRW}, \text{Unique}(2)])。
        // 这使用了原始指针！（new-mutable-ref）
        &mut *raw_pointer // y = \text{Pointer}(\ell, 3)
        // 在此使用 raw_pointer 弹出了第一个引用：h(`\ell`) = (5, [\ldots, \text{SharedRW}, \text{Unique}(3)])。
        // 这使用了原始指针！（new-mutable-ref）
    ) };
    println!("{}", result); // 输出 "13"。
}

fn example1(x: &mut i32, y: &mut i32) -> i32 {
    // x = \text{Pointer}(\ell, 2)，y = \text{Pointer}(\ell, 3)，h(`\ell`) = (5, [\text{Unique}(0), \text{Unique}(1), \text{SharedRW}, \text{Unique}(3)])
    *x = 42;
    // 分析错误！x 的标签（2）不在堆栈中。程序具有未定义行为。
    *y = 13;
    return *x; // 我们希望将其优化为返回 42。
}
```

**解释**：

- **第 2 行**：`local` 初始化为 5，存储在位置 `$\ell$`，初始标签为 0。堆栈为 `[\text{Unique}(0)]`。
- **第 3 行**：将 `&mut local` 转换为原始指针：创建临时可变引用，获得标签 1，推入堆栈。将原始指针的 SharedRW 推入堆栈。
- **第 7-14 行**：调用 `example1` 函数，传递两个从原始指针创建的可变引用。**第一次创建引用**（`x`）：创建新的可变引用，获得标签 2。根据 new-mutable-ref 规则，这被视为对原始指针的使用，需要确保 SharedRW 在堆栈顶端（use-2 规则）。将 Unique(2) 推入堆栈。**第二次创建引用**（`y`）：创建新的可变引用，获得标签 3。再次使用原始指针，弹出堆栈顶端的 Unique(2)，将 Unique(3) 推入堆栈。这使得之前的引用 x（标签 2）不可用。
- **第 19 行**：在 `example1` 中使用 `*x`，即标签为 2 的引用。由于标签 2 的项不在堆栈中，根据 use-2 规则，程序具有未定义行为。
#### **分析**

关键点在于，当传递给 `example1` 的两个引用被创建时，每次执行 `&mut *raw_pointer`，根据 `new-mutable-ref` 规则，这被视为对原始指针的使用，需要确保 `SharedRW` 在堆栈顶端（`use-2` 规则）。

在创建第二个引用（`y`，标签 3）时，我们必须弹出 `Unique(2)`，这使得第一个引用（`x`，标签 2）不可用。当我们在第 19 行使用 `x` 时，检测到违反了堆栈原则。

**注意**：

- 将引用的创建视为对旧引用的使用（即使没有实际访问内存）是重要的。如果我们不这样做，堆栈会错误地反映引用之间的关系，可能导致错误的分析结果。
- 作者提到，在未来的工作中，他们希望探索其他模型，将指针的继承信息（即引用之间的派生关系）跟踪在树结构中，而不是堆栈。
### **15.4 重新标记和可变引用优化的证明概述**

#### **重新标记（Retagging）的必要性**

接下来，作者讨论了 **重新标记（retagging）** 的概念。

**问题**：

- 如果 `example1` 被调用时，`x` 和 `y` 拥有相同的标签，那么动态分析可能无法检测到它们的别名情况。
- 这是因为 `unsafe` 代码可以复制任何数据，包括可变引用，从而可能产生具有相同标签的引用。
- 在分析未知上下文中的 `example1` 时，我们无法信任 `x` 和 `y` 的标签，因为它们可能被 `unsafe` 代码篡改。
**解决方案**：

- **重新标记**：在函数开始执行时，对所有传入的引用进行重新标记，确保它们拥有新的、唯一的标签。
- 这通过插入 **retag** 指令来实现，`retag` 是一种管理指令，确保引用具有新的标签。
#### **重新标记的实现**

在我们的简化版本中，`retag x` 的行为与 `x = &mut *x` 相同，即：

1. 使用旧的 x，遵循 use-2 规则。
2. 创建新的引用，遵循 new-mutable-ref 规则。
3. x 仍然指向相同的位置，但现在具有新的标签。
修改后的 `example1` 如下：

```rust
fn example1(x: &mut i32, y: &mut i32) -> i32 {
    retag x; // 等价于 x = &mut *x;
    retag y; // 等价于 y = &mut *y;
    *x = 42;
    *y = 13;
    return *x; // 我们希望将其优化为返回 42。
}
```

#### **优化的证明概述**

现在，我们可以证明在堆栈借用模型下，优化是正确的。

**目标**：在函数中，我们希望优化 `return *x;`，使其始终返回 `42`，因为按照别名规则，`x` 和 `y` 不应指向同一位置。

**证明步骤**：

1. **初始化**：
- 经过 retag 后，x 的值为 Pointer($\ell$, $t$)，其中 $t$ 是新的唯一标签。
- 我们知道没有其他指针值具有标签 $t$，并且 $t$ 位于位置 $\ell$ 的借用堆栈顶端。
2. **中间过程**：
- 在第 4 行之前，x 未被使用。
- 如果在此期间有任何代码影响了 $\ell$ 的值或堆栈，它必须通过具有不同标签的指针值来完成。
- 由于 $t$ 在堆栈顶端，任何使用不同标签的访问都会弹出 $t$，使得 *x 在第 4 行无法通过分析。
- 因此，$\ell$ 在第 4 行之前未被访问，$t$ 仍然在堆栈顶端。
3. **结论**：
- 在第 4 行执行后，堆栈保持不变，但我们知道 $\ell$ 的值现在是 42。
- 在第 6 行，我们可以重复相同的论证，得出 $\ell$ 的值仍然是 42，因此可以安全地将 return *x; 优化为 return 42;。
**重要之处**：

- 在证明中，我们没有显式地讨论 x 和 y 是否别名。
- 这种优化可以推广到一个更通用的模式，即在不使用 x 的任何代码之间，我们可以假设 x 所指向的内存未被修改。
#### **关于重新标记的讨论**

**何时需要重新标记？**

- 重新标记在编译器优化中起着关键作用。
- 为了使优化能够正确进行，我们需要对传入的引用进行重新标记，以确保它们的标签是唯一的，并且未被其他指针值使用。
**重新标记的策略**：

- **函数参数**：对所有引用类型的函数参数进行重新标记。
- **从指针读取的引用**：当从指针读取引用时（例如 let z = *y;），对其进行重新标记。
- **函数返回值**：当从函数接收引用返回值时，对其进行重新标记。
**示例**：

```rust
fn retag_demo(x: &mut i32, y: &&i32) {
    retag x; // 对所有引用类型的函数参数进行重新标记
    retag y;
    let z = *y;
    retag z; // 对从指针读取的引用进行重新标记
    let incoming_ref = some_function_returning_a_ref();
    retag incoming_ref; // 对函数返回的引用进行重新标记
}
```

#### **通过指令重排序进行优化**

为了更好地理解堆栈借用模型启用的各种优化，可以将它们表示为对某些指令的重排序。

**示例**：

```rust
// 原始代码
retag x;
g();
*x = 42;
f();
let retval = *x;
return retval;

// 优化后（重排序后）
retag x;
g();
*x = 42;
let retval = *x; // 将读取提前
f();
return retval;
```

**解释**：

- 在优化后的代码中，我们将第 5 行的读取操作提前到第 4 行。
- 由于在 *x = 42; 之后，我们可以确保 *x 的值是 42，并且在此期间没有其他代码修改 x 所指向的内存，我们可以安全地进行这种优化。
**注意事项**：

- 在并发语言中（虽然我们的示例语言不是并发的，但 Rust 是），这假设没有数据竞争（data race）。
- 在 Rust 中，数据竞争是未定义行为，因此这种假设是合理的。
**全面总结：**

在 **第15章：唯一性和不可变性** 的 **15.3节和15.4节** 中，作者扩展了堆栈借用模型，以正确处理 **原始指针（raw pointers）**，并讨论了 **重新标记（retagging）** 对优化的影响。

主要内容和结论包括：

1. **扩展堆栈借用模型以处理原始指针**：
- **引入未标记的标签**：将标签集合扩展为包含特殊值 `⊥`，用于表示未标记的原始指针。
- **添加新的堆栈项**：引入 `SharedRW`，表示位置已被共享，所有原始指针都可以读取和写入。
- **修改操作语义**：定义了新的规则 `new-mutable-raw-1` 和 `use-2`，用于处理原始指针的创建和使用。
2. **分析示例程序，展示堆栈借用模型的作用**：
- 通过详细的执行跟踪，展示了堆栈借用模型如何检测到程序中的未定义行为，即在原始指针的使用下，违反了堆栈原则。
- 解释了为什么需要将引用的创建视为对旧引用的使用，以确保堆栈正确反映引用之间的关系。
3. **引入重新标记（Retagging）**：
- **必要性**：由于 `unsafe` 代码可以复制引用并可能篡改标签，需要重新标记来确保引用具有唯一的标签。
- **实现方式**：通过插入 `retag` 指令，对函数参数、从指针读取的引用、函数返回的引用等进行重新标记。
4. **优化的证明概述**：
- **目标**：证明在堆栈借用模型下，可以安全地进行某些优化，例如将 `return *x;` 优化为 `return 42;`。
- **证明过程**：通过分析堆栈状态，论证在 `*x` 之间没有其他对内存的修改，因此可以安全地进行优化。
- **重要性**：这种证明不依赖于 `x` 和 `y` 是否别名，而是基于堆栈借用模型的规则。
5. **讨论重新标记的时机和对优化的影响**：
- **重新标记的策略**：需要在函数开始时、从指针读取引用时、接收函数返回的引用时进行重新标记。
- **对优化的影响**：只有在引用被“本地”重新标记的情况下，才能进行某些优化，因为这样可以确保对标签和堆栈的必要假设。
6. **通过指令重排序理解优化**：
- 通过将指令重排序，展示了堆栈借用模型如何启用优化，并解释了为什么这种重排序在模型下是安全的。
**总结而言**，作者通过扩展堆栈借用模型，引入对原始指针的处理，解决了在 `unsafe` 代码下可能出现的别名问题。通过重新标记的机制，确保了引用标签的唯一性，使得编译器可以安全地进行基于类型信息的优化。这些工作强化了 Rust 类型系统的别名保证，即可变引用 `&mut T` 应该是唯一的，且共享引用 `&T` 应该是只读的。

通过深入理解这些内容，我们可以更好地理解 Rust 编译器如何在保持内存安全和数据一致性的前提下，利用堆栈借用模型进行优化。特别是在涉及 `unsafe` 代码的情况下，堆栈借用模型提供了一种机制，使编译器可以检测并防止潜在的未定义行为，从而提高程序的可靠性和性能。
 #  
 Thought for 6 seconds
**概览：**

您提供的内容来自论文《理解和发展 Rust 编程语言》（Understanding and Evolving the Rust Programming Language）的 **第三部分：堆栈借用（Stacked Borrows）**，具体是 **第15章：唯一性和不可变性（Uniqueness and Immutability）** 中的 **15.5节：共享引用（Shared references）**、**15.6节：利用共享引用的只读性进行优化（An optimization exploiting read-only shared references）** 和 **15.7节：共享引用优化的证明概述（A proof sketch for the optimization on shared references）**。

本章的主要目标是 **扩展堆栈借用模型以支持共享引用 &T**，并 **探讨利用共享引用的只读特性来进行编译器优化**。之前的堆栈借用模型只处理了可变引用 `&mut T` 和原始指针（raw pointers），现在需要引入共享引用并定义它们在模型中的行为。

具体来说，本章讨论了以下内容：

1. **共享引用的堆栈原则**：将借用检查器对共享引用的要求重新表述为堆栈原则，即 **共享引用（及其派生引用）的每次使用都必须发生在对被引用对象的下一次可变使用之前**，并且共享引用 **不能用于修改（mutation）**。
2. **堆栈借用模型的扩展**：引入新的堆栈项 `SharedRO(t)`，用于表示带有标签 `t` 的共享只读引用。修改操作语义以支持共享引用的创建和使用，定义了新的规则 `new-shared-ref-1` 和 `read-1`。
3. **示例分析**：通过一个涉及共享引用的示例程序，展示了堆栈借用模型如何处理共享引用的读取和写入操作，以及如何检测违反堆栈原则的行为。
4. **利用共享引用的优化**：提出了一个利用共享引用的只读特性进行优化的示例函数 `example2`，并展示了如何在堆栈借用模型下证明该优化的正确性。
5. **反例分析**：提供了一个可能违反优化正确性的反例程序，并说明在堆栈借用模型下，该程序具有未定义行为，因此优化是安全的。
6. **优化的证明概述**：详细阐述了在堆栈借用模型下，为什么可以安全地进行针对共享引用的优化，并提供了证明的关键步骤。
通过这些讨论，作者展示了堆栈借用模型如何扩展以支持共享引用，以及如何利用共享引用的只读性来进行编译器优化，同时确保程序的安全性和正确性。

**详细解读：**

### **15.5 共享引用**

#### **背景**

在之前的堆栈借用模型中，只考虑了可变引用 `&mut T` 和原始指针 `*mut T`。可变引用的别名信息允许编译器进行强有力的优化，因为它们保证了引用的唯一性。然而，为了使模型更完整，我们需要引入 **共享引用 &T**，并定义它们在堆栈借用模型中的行为。

#### **堆栈原则的重新表述**

借用检查器对共享引用的要求可以不提及生命周期，重新表述为堆栈原则：

- **共享引用（及其派生引用）的每次使用都必须发生在对被引用对象的下一次可变使用之后（在引用创建之后）**。
- **共享引用不能用于修改被引用的对象**。
#### **示例程序**

考虑以下涉及共享引用的示例：

```rust
1 let mut local = 42;
2 let x = &mut local;
3 let shared1 = &*x; // 从可变引用 x 派生两个共享引用...
4 let shared2 = &*x; // ...shared1 和 shared2。
5 let val = *x;      // 使用所有三个引用...
6 let val = *shared1; // ...交替使用...
7 let val = *shared2; // ...进行读取操作。
8 *x += 17;          // 再次使用 x 进行写入操作。
9 let val = *shared1; // 错误！在修改 x 之后使用 shared1。
```

**解释**：

- 尽管 x、shared1 和 shared2 都引用了同一个变量 local，但程序在第 8 行之前都是合法的。
- 在第 9 行，使用了 shared1，但之前在第 8 行对 x 进行了可变的写入操作，违反了堆栈原则。
- 因此，借用检查器会拒绝这个程序，因为共享引用在被引用对象被修改后再次使用，这是不允许的。
#### **在堆栈借用模型中建模**

为了在堆栈借用模型中表示共享引用，我们需要引入新的堆栈项和规则。

##### **扩展堆栈项**

我们引入新的堆栈项：

- **SharedRO(t)**：表示带有标签 t 的共享只读引用，允许读取但不允许写入。
- **SharedRW(t)**：带有标签 t 的共享读写引用（将在后续章节使用）。
因此，堆栈项的定义更新为：

$$
\text{Item} := \text{Unique}(t) \mid \text{SharedRO}(t) \mid \text{SharedRW}(t) \mid \ldots
$$

**注意**：我们也将之前的 `SharedRW` 项更新为带有标签的形式 `SharedRW(t)`。目前，`SharedRW` 的标签都是 `\bot`，但在后续章节（例如 **16.4节**）中会发生变化。

##### **修改操作语义**

我们需要修改堆栈借用模型的操作规则，以支持共享引用的创建和读取。

###### **规则（new-shared-ref-1）**

当从现有的指针值 `\text{Pointer}(\ell, t)` 创建一个新的共享引用（通过 `&expr`）时：

1. 首先，这被视为对该指针值的 **读取访问**（遵循后面的 read-1 规则）。
2. 选择一个新的、未使用过的标签 t'。
3. 新的共享引用的值为 \text{Pointer}(\ell, t')。
4. 将 \text{SharedRO}(t') 推入位置 \ell 的堆栈顶端。
###### **规则（read-1）**

当 **读取** 指针值 `\text{Pointer}(\ell, t)` 时：

1. 在位置 \ell 的堆栈中，必须存在带有标签 t 的项（即 \text{Unique}(t)、\text{SharedRO}(t) 或 \text{SharedRW}(t)）。
2. 弹出堆栈中 **位于标签为 t 的项之上的所有非 \text{SharedRO}(_) 项**，直到标签为 t 的项之上仅有 \text{SharedRO}(_) 项为止。
3. 如果在堆栈中不存在标签为 t 的项，则程序违反了堆栈原则。
**注意**：

- **读取操作** 不会弹出位于标签为 t 的项之上的 \text{SharedRO}(_) 项。这反映了共享引用可以同时用于读取，而不会相互干扰。
- **写入操作**（仍由 use-2 规则处理）需要将标签为 t 的项提升到堆栈顶端，这可能会弹出所有位于其之上的 \text{SharedRO}(_) 项。
###### **规则的更新**

- 对于 **写入操作**，规则保持不变，即 `use-2` 规则：当 **写入** 指针值 `\text{Pointer}(\ell, t)` 时：如果 t = \bot，则 \text{SharedRW}(\bot) 必须在位置 \ell 的堆栈中。如果 t \neq \bot，则 \text{Unique}(t) 必须在堆栈中。弹出位于所需项之上的所有项，使得所需项位于堆栈顶端。
- **读取操作** 和 **写入操作** 的区别在于：**读取操作**（read-1）可能会在所需项之上保留其他 \text{SharedRO}(_) 项，反映了共享引用的可并发读取。**写入操作**（use-2）需要将所需项提升到堆栈顶端，弹出所有位于其之上的项，包括 \text{SharedRO}(_) 项。
##### **堆栈的不变量**

- 堆栈中所有的 \text{SharedRO}(_) 项都位于堆栈顶端，并且是相邻的。
- 当创建可变引用或原始指针时，会执行写入操作，弹出堆栈顶端的所有 \text{SharedRO}(_) 项。
- 永远不会将 \text{Unique}(_) 或 \text{SharedRW}(_) 项推入 \text{SharedRO}(_) 项之上。
#### **示例分析**

让我们通过示例程序的执行过程，展示堆栈借用模型如何处理共享引用。

```rust
1 let mut local = 42; // 存储在位置 `\ell`，标签为 0。
2 let x = &mut local; // x = \text{Pointer}(\ell, 1)
3 // 推入 x 的标签：h(\ell) = (42, [\text{Unique}(0), \text{Unique}(1)])。（new-mutable-ref）
4 let shared1 = &*x;  // shared1 = \text{Pointer}(\ell, 2)
5 let shared2 = &*x;  // shared2 = \text{Pointer}(\ell, 3)
6 // 推入新的共享引用标签：h(\ell) = (42, [\text{Unique}(0), \text{Unique}(1), \text{SharedRO}(2), \text{SharedRO}(3)])。（new-shared-ref-1）
7 let val = *x;
8 // 检查：堆栈中存在 \text{Unique}(1)，其上方的项均为 \text{SharedRO}(_)。读取操作。（read-1）
9 let val = *shared1;
10 // 检查：堆栈中存在 \text{SharedRO}(2)，其上方的项均为 \text{SharedRO}(_)。读取操作。（read-1）
11 let val = *shared2;
12 // 检查：堆栈中存在 \text{SharedRO}(3)，其上方的项均为 \text{SharedRO}(_)。读取操作。（read-1）
13 *x += 17;
14 // 弹出直到 \text{Unique}(1) 位于堆栈顶端：h(\ell) = (59, [\text{Unique}(0), \text{Unique}(1)])。（use-2）
15 let val = *shared1;
16 // 分析错误！shared1 的标签不在堆栈中。读取操作失败。（read-1）
```

**解释**：

- **第 2 行**：创建可变引用 `x`，标签为 1，推入堆栈。
- **第 4-5 行**：从 `x` 派生两个共享引用 `shared1` 和 `shared2`，分别获得标签 2 和 3，推入堆栈。
- **第 7-12 行**：读取操作：读取 *x 时，堆栈中存在 \text{Unique}(1)，其上方的项均为 \text{SharedRO}(_)，读取成功。读取 *shared1 和 *shared2 时，堆栈中存在各自的标签，读取成功。
- **第 13 行**：对 `x` 进行写入操作，根据 `use-2` 规则，需要将 `\text{Unique}(1)` 提升到堆栈顶端，弹出所有位于其之上的项（`SharedRO(2)` 和 `SharedRO(3)`）。
- **第 15 行**：尝试读取 `*shared1`，但其标签 `2` 已不在堆栈中，读取操作失败，违反堆栈原则。
**观察**：

- 共享引用 shared1 和 shared2 可以与 x 共存，并且可以交替进行读取操作，不会相互干扰。
- 但是，一旦对 x 进行了写入操作，堆栈顶端的 SharedRO(_) 项被弹出，之前的共享引用不再有效。
### **15.6 利用共享引用的只读性进行优化**

#### **优化目标**

我们希望利用共享引用的只读特性，进行编译器优化。例如，预计算某个共享引用的值，然后在后续代码中重复使用，而无需担心该值被修改。

#### **示例函数**

考虑以下函数 `example2`：

```rust
fn example2(x: &i32, f: impl FnOnce(&i32)) -> i32 {
    retag x;
    let val = *x / 3;
    f(x);
    return *x / 3; // 我们希望将其优化为 return val;
}
```

**解释**：

- 函数接受一个共享引用 x，以及一个闭包 f。
- 在第 3 行，计算 *x / 3 并将结果存储在 val 中。
- 在第 4 行，调用闭包 f，并将 x 传递给它。
- 在第 5 行，再次计算 *x / 3，希望优化为直接返回 val，因为 x 的值在此期间不应被修改。
#### **潜在的反例**

为了验证优化的安全性，我们需要考虑可能违反优化正确性的反例。

##### **反例程序**

```rust
fn main() {
    let mut local = 6;
    let x = &local;
    let result = example2(x, |inner_x| {
        retag inner_x;
        let raw_pointer: *mut i32 =
            unsafe { mem::transmute(inner_x) };
        unsafe { *raw_pointer = 15; }
    });
    println!("{}", result); // 输出 "5"（即 15/3）。
}
```

**解释**：

- 在闭包 f 中，通过不安全代码，将共享引用 inner_x 转换为可变原始指针 raw_pointer，然后修改其指向的值。
- 这样，x 的值被修改为 15，导致 *x / 3 的结果从 2（6/3）变为 5（15/3）。
- 如果编译器进行了优化，直接返回预计算的 val（即 2），将与实际计算结果 5 不一致。
#### **在堆栈借用模型下的分析**

在堆栈借用模型下，该反例程序具有未定义行为，因此优化是安全的。

**分析步骤**：

- **第 7-8 行**：在闭包中，`retag inner_x` 后，`inner_x` 的标签更新为新的标签 `3`。
- **第 9 行**：通过 `mem::transmute`，将 `inner_x` 转换为原始指针 `raw_pointer`，其标签仍为 `3`。
- **第 11 行**：尝试使用 `raw_pointer` 进行写入操作。根据 use-2 规则，写入操作需要堆栈中存在 \text{Unique}(3) 或 \text{SharedRW}(3)。然而，堆栈中只有 \text{SharedRO}(3)，因此写入操作违反了堆栈原则，具有未定义行为。
- **结论**：由于程序具有未定义行为，优化是安全的。
#### **示例执行过程**

完整的执行过程如下（数字表示执行顺序）：

```rust
fn main() {
    let mut local = 6; // [1] 存储在位置 `\ell`，标签为 0。
    let x = &local;    // x = \text{Pointer}(\ell, 1)
    // [2] h(\ell) = (6, [\text{Unique}(0), \text{SharedRO}(1)]) （new-shared-ref-1）
    // 接下来跳转到 example2（行 17）。
    let result = example2(x, |inner_x| {
        retag inner_x;
        // [5] inner_x = \text{Pointer}(\ell, 3)，h(\ell) = (6, [..., \text{SharedRO}(1), \text{SharedRO}(2), \text{SharedRO}(3)])
        let raw_pointer: *mut i32 = unsafe { mem::transmute(inner_x) };
        // [6] raw_pointer = \text{Pointer}(\ell, 3)，堆栈未改变。
        unsafe { *raw_pointer = 15; }
        // [7] 分析错误！写入操作需要 \text{Unique}(3) 或 \text{SharedRW}(3)，但堆栈中不存在。（use-2）
    });
    println!("{}", result); // [8] 输出 "5"（即 15/3）。
}

fn example2(x: &i32, f: impl FnOnce(&i32)) -> i32 {
    retag x;
    // [3] x = \text{Pointer}(\ell, 2)，h(\ell) = (6, [\text{Unique}(0), \text{SharedRO}(1), \text{SharedRO}(2)])
    let val = *x / 3;
    // [4] 读取操作，成功。（read-1）
    f(x); // 跳转到闭包体（行 6）。
    return *x / 3; // 我们希望优化为 return val;
}
```

### **15.7 共享引用优化的证明概述**

#### **优化目标**

我们希望证明，在堆栈借用模型下，可以安全地将函数 `example2` 中的返回值优化为预计算的 `val`，即：

```rust
return *x / 3; // 可以优化为 return val;
```

#### **证明步骤**

1. **初始化**：
- 在 retag x 之后，x 的值为 \text{Pointer}(\ell, t)，其中 t 是新的唯一标签。
- 堆栈中，位置 \ell 的堆栈顶端为 \text{SharedRO}(t)。
- 假设 \ell 处当前存储的标量值为 s。
2. **中间过程**：
- 在 f 执行期间，任何对 \ell 的写入操作都会弹出堆栈顶端的所有 \text{SharedRO}(_) 项，包括 \text{SharedRO}(t)。
- 由于 \text{SharedRO}(t) 在堆栈顶端，我们可以假设只要 \text{SharedRO}(t) 仍在堆栈中，s 的值就不会改变。
3. **结论**：
- 在执行 return *x / 3; 时，如果 \text{SharedRO}(t) 仍在堆栈中，说明 s 的值未被修改。
- 因此，可以安全地使用之前计算的 val，将返回语句优化为 return val;。
**关键点**：

- **假设**：程序遵守堆栈借用模型的规则。
- **结果**：在不违反堆栈借用规则的情况下，s 的值不会被修改，优化是安全的。
#### **通过指令重排序理解优化**

可以将优化表示为指令的重排序：

```rust
// 原始代码
retag x;
let val = *x / 3;
f();
let retval = *x / 3;
return retval;

// 优化后（重排序后）
retag x;
let val = *x / 3;
let retval = *x / 3; // 提前计算
f();
return retval;
```

**解释**：

- 我们将第 4 行的读取操作提前到第 3 行。
- 由于在 retag x 之后，x 的值在调用 f() 期间不应被修改（否则违反堆栈借用规则），因此提前计算是安全的。
- 这样，retval 与 val 相等，可以直接返回 val，实现优化。
**注意事项**：

- 在并发情况下，这种优化依赖于 Rust 保证没有数据竞争（data race），因为数据竞争在 Rust 中是未定义行为。
#### **优化的意义**

- **对于编译器**：堆栈借用模型提供了在不进行跨函数分析（如内联）的情况下，基于类型信息进行优化的能力。
- **与 C/C++ 的区别**：在 C/C++ 中，无法假设在调用未知函数后，某个共享变量的值未被修改，因为无法保证别名和线程安全。
- **对程序员的保证**：只要程序遵守 Rust 的借用规则，编译器就可以进行安全的优化，而不会改变程序的语义。
**全面总结：**

在 **第15章：唯一性和不可变性** 的 **15.5节、15.6节和15.7节** 中，作者扩展了堆栈借用模型，以支持 **共享引用 &T**，并探讨了如何利用共享引用的只读特性来进行编译器优化。

主要内容和结论包括：

1. **引入共享引用的堆栈原则**：
- 共享引用及其派生引用的每次使用都必须发生在被引用对象的下一次可变使用之前。
- 共享引用不能用于修改被引用的对象。
2. **扩展堆栈借用模型**：
- 引入新的堆栈项 \text{SharedRO}(t)，表示带有标签 t 的共享只读引用。
- 修改操作语义，定义了创建共享引用的规则 new-shared-ref-1 和读取操作的规则 read-1。
- 保持堆栈的不变量，确保所有的 \text{SharedRO}(_) 项都位于堆栈顶端。
3. **示例分析**：
- 通过详细的示例，展示了共享引用的创建和使用，以及在写入操作后，共享引用如何失效。
- 强调了共享引用可以并发地进行读取操作，而不会相互干扰。
4. **利用共享引用的优化**：
- 提出了函数 example2，展示了如何利用共享引用的只读特性进行优化。
- 在函数中，预先计算共享引用的值，并在后续代码中重复使用，而无需担心值被修改。
5. **反例分析和未定义行为**：
- 提供了一个反例程序，尝试通过不安全代码修改共享引用指向的值。
- 在堆栈借用模型下，该程序具有未定义行为，因为违反了堆栈原则。
6. **优化的证明概述**：
- 详细阐述了在堆栈借用模型下，为什么可以安全地进行优化。
- 通过分析堆栈状态，证明在不违反堆栈借用规则的情况下，x 的值不会被修改。
7. **通过指令重排序理解优化**：
- 将优化表示为指令的重排序，展示了在堆栈借用模型下，提前计算共享引用的值是安全的。
8. **堆栈借用模型的优势**：
- 为编译器提供了在包括 unsafe 代码的情况下，基于类型信息进行优化的能力。
- 确保了程序的内存安全和数据一致性。
- 与 C/C++ 等语言相比，Rust 的堆栈借用模型提供了更强的别名和线程安全保证。
**结论**：

通过引入共享引用并扩展堆栈借用模型，作者展示了如何在编译器中利用共享引用的只读特性进行优化，同时确保程序的安全性和正确性。堆栈借用模型为编译器提供了基于局部类型信息进行优化的机制，即使在存在 `unsafe` 代码的情况下，也能够检测并防止潜在的未定义行为。

这对于 Rust 编程语言的理解和发展具有重要意义。它不仅强化了 Rust 的类型系统和借用规则，而且为编译器优化提供了坚实的理论基础。通过深入理解堆栈借用模型，程序员可以更好地编写高性能且安全的 Rust 程序，充分利用编译器的优化能力，同时避免未定义行为和安全漏洞。
 #  
 Thought for 40 seconds
**概览：**

您提供的内容来自论文《理解和发展 Rust 编程语言》（Understanding and Evolving the Rust Programming Language）的 **第三部分：堆栈借用（Stacked Borrows）**，具体是 **第16章：保护者和内部可变性（Protectors and Interior Mutability）**，包括 **16.1节：将内存访问下移而非上移（Reordering memory accesses down instead of up）**、**16.2节：保护者（Protectors）** 和 **16.3节：优化的证明概述（Proof sketches for the optimizations）**。

本章的主要目标是 **扩展堆栈借用模型，以支持编译器在未知代码（unknown code）之间进行更灵活的指令重排序**，以及 **支持内部可变性（interior mutability）**。之前的堆栈借用模型主要支持了指令的上移（将指令向前移动），现在作者希望探讨如何支持指令的下移（将指令向后移动），从而给编译器提供更多的优化自由度。

具体来说，本章讨论了以下内容：

1. **指令下移的挑战**：在 **16.1节** 中，作者指出，将内存访问指令下移（即将内存访问延后）可能带来新的挑战，因为这会延长引用的生命周期（liveness range），并可能导致对内存的访问与原程序不同。
2. **引入保护者（Protectors）**：在 **16.2节** 中，为了解决在指令下移时出现的未定义行为，作者引入了 **保护者（protectors）** 的概念。保护者是一种机制，防止在函数调用期间，被保护的借用堆栈项被弹出（即防止引用的生命周期在函数执行期间结束），从而确保指令下移的安全性。
3. **优化的证明概述**：在 **16.3节** 中，作者展示了如何使用保护者来验证之前无法进行的优化，并提供了证明这些优化正确性的概述。这些优化包括将读操作和写操作下移或上移，通过保护者确保程序的行为与原始程序一致。
4. **完整的优化矩阵**：作者还补充了其他几种优化情况，展示了在引入保护者后，如何在未知代码之间上移和下移读写操作，从而完成了对各种引用访问的重排序支持。
通过这些讨论，作者展示了堆栈借用模型如何进一步扩展，以支持更多的编译器优化，同时保持程序的安全性和正确性。

**详细解读：**

### **第16章：保护者和内部可变性**

在前面的章节中，堆栈借用模型允许了某些优化，这些优化基于假设即使在 `unsafe` 代码中也必须遵守堆栈借用规则。具体而言，之前的优化主要涉及 **指令的上移**，即将内存访问指令提前到未知代码（未知函数调用）之前执行。

然而，为了给编译器提供更多的优化自由度，我们希望支持 **指令的下移**，即将内存访问指令延后到未知代码之后执行。这带来了新的挑战，因为这可能会延长引用的生命周期，并可能导致程序行为的变化。

#### **16.1 将内存访问下移而非上移**

##### **背景**

之前讨论的优化遵循了类似的模式：

1. **重新标记（retag）引用**（证明步骤中的第 1 步），这使得引用在堆栈顶部。
2. **进行某些更改或观察**（例如，对可变引用进行写操作，或读取共享引用）。
3. **执行未知代码**（如调用未知函数）。
4. **再次使用原始引用**（证明步骤中的第 3 步）。
这种模式适用于 **指令的上移**，因为我们可以确保在未知代码执行之前，我们的引用在堆栈顶部，且在未知代码执行后，引用仍然有效。

##### **挑战**

然而，当我们希望 **将内存访问下移** 时，会出现新的挑战：

- **延长引用的生命周期**：将内存访问下移意味着引用在未知代码执行期间仍然处于活跃状态，这可能会导致引用被其他代码（包括 `unsafe` 代码）非法地访问或修改。
- **程序行为的改变**：下移内存访问可能导致在函数调用时，内存的状态与原始程序不同，这需要确保程序的行为与原始程序一致，或至少在未定义行为的情况下可以接受。
##### **示例：将读取操作下移**

考虑以下函数：

```rust
// 将读取操作下移穿过 f()。
fn example2_down(x: &i32, f: impl FnOnce(&i32)) -> i32 {
    retag x;
    let val = *x;
    f(x);
    return val; // 可以改为返回 *x。
}
```

**目标**：将第 4 行的读取操作 `*x` 下移到第 6 行，即在调用 `f` 之后再读取 `x`。

**动机**：

- 在更复杂的代码中，这样的重排序可能会减少寄存器压力，因为我们不需要在调用 f 的过程中保持 val 的值。
##### **示例：将写入操作下移**

对于可变引用，我们也可以尝试将写入操作下移：

```rust
// 将写入操作下移穿过 f()。
fn example3_down(x: &mut i32, f: impl FnOnce()) {
    retag x;
    *x = 42; // 这个写操作是多余的。
    f();
    *x = 13;
}
```

**目标**：将第 4 行的写入操作下移到第 6 行，然后我们有两个连续的对 `x` 的写入操作，可以删除第一个写入操作。

**挑战**：

- 这种重排序意味着在调用 f 时，x 中存储的值与原始程序不同。
- 需要确保这种变化不会影响程序的正确性。
#### **16.2 保护者（Protectors）**

##### **问题的出现**

现有的堆栈借用模型不允许上述的优化，因为可能存在反例，使得优化后的程序行为与原始程序不同。

**反例**：

```rust
fn main() {
    let mut local = 42; // 存储在位置 `\ell`，标签为 0。
    let raw_pointer = &mut local as *mut i32;
    let val = example2_down(
        unsafe { &*raw_pointer }, // = \text{Pointer}(\ell, 2)
        |x_inner| unsafe {
            retag x_inner;
            *raw_pointer = 17; // 修改了 *x。
        },
    );
    println!("{}", val); // 输出 42。
}
```

**解释**：

- 在 example2_down 函数中，我们希望将对 x 的读取操作下移到调用 f 之后。
- 在这个反例中，闭包 f 通过 raw_pointer 修改了 x 指向的值。
- 由于 raw_pointer 是 x 的别名，在现有的堆栈借用模型下，这种修改是被允许的。
- 因此，优化后的程序可能会在 return val; 时返回错误的值，导致程序行为与原始程序不一致。
##### **问题的根源**

- **引用的生命周期过早结束**：在上述反例中，x 的生命周期在 example2_down 函数执行期间结束了，因为 SharedRO(3)（x 的标签项）在闭包执行时被弹出了堆栈。
- 这违反了 Rust 的规则，即传递给函数的引用必须至少在函数调用期间有效（即 **引用必须比函数调用活得更久，outlive the function call**）。
##### **引入保护者**

为了解决这个问题，作者引入了 **保护者（protectors）** 的概念：

- **定义**：保护者是关联到借用堆栈项的一个函数调用 ID，当函数调用正在进行时，如果试图弹出带有活跃保护者的堆栈项，将被视为堆栈借用模型的违规，导致未定义行为。
- **目的**：保护者确保引用在函数执行期间不会过早失效（即借用堆栈项不会在函数执行期间被弹出），从而防止类似反例中的情况发生。
##### **形式化定义**

- **借用堆栈项的扩展**：引入可选的调用 ID（call ID），定义为：
$$
\text{CallId} := \mathbb{N} \\
\text{CallId}^{?} := \text{CallId} \cup \{\bot\} \\
\text{Item} := \text{Unique}(t, c) \mid \text{SharedRO}(t, c) \mid \text{SharedRW}(t, c)
$$
其中，$c$ 是可选的调用 ID（可能为 $\bot$），表示保护者。
- **堆栈借用规则的更新**：**规则（retag-fn）**：当在 `retag[fn]` 操作中，向位置的借用堆栈推入新的项时，这些项的保护者被设置为当前函数调用的调用 ID。**规则（protector）**：每当通过 `use-2` 或 `read-1` 弹出堆栈项时，检查该项是否有保护者（即 $c \neq \bot$）。如果有，且该调用 ID 对应的函数调用仍在进行中（即对应的栈帧仍在调用栈中），则称保护者是 **活跃的（active）**，此时弹出该项是堆栈借用模型的违规，导致未定义行为。
##### **修改后的示例**

在 `example2_down` 中，我们需要使用 `retag[fn]` 来对参数 `x` 进行重新标记，以设置保护者：

```rust
// 将读取操作下移穿过 f()。
fn example2_down(x: &i32, f: impl FnOnce(&i32)) -> i32 {
    retag[fn] x;
    let val = *x;
    f(x);
    return val; // 可以改为返回 *x。
}
```

##### **分析反例**

现在，再次分析之前的反例程序：

- 在闭包执行开始时，位置 `\ell` 的借用堆栈为：
$$
[\text{Unique}(0), \text{Unique}(1), \text{SharedRW}(\bot), \text{SharedRO}(2), \text{SharedRO}(3, c)]
$$
其中，$c$ 是 example2_down 函数调用的调用 ID。
- 当闭包尝试通过 `raw_pointer` 进行写入操作时，根据 `use-2` 规则，需要将 `\text{SharedRW}(\bot)` 提升到堆栈顶端，这需要弹出 `\text{SharedRO}(3, c)`。
- 然而，`SharedRO(3, c)` 有一个活跃的保护者 $c$，因为 `example2_down` 函数仍在执行。
- 根据保护者规则（protector），弹出带有活跃保护者的堆栈项是未定义行为，因此程序在此处违反了堆栈借用模型，优化是安全的。
#### **16.3 优化的证明概述**

##### **证明优化的正确性**

有了保护者，我们可以证明之前无法进行的优化是正确的。

**针对 example2_down 的证明**：

1. **初始化**：
- 在第 3 行的 `retag[fn]` 操作后，`x` 的值为 `\text{Pointer}(\ell, t)`，其中 $t$ 是新的唯一标签。
- 堆栈中，位置 `\ell` 的堆栈顶端项为 `\text{SharedRO}(t, c)`，其中 $c$ 是 `example2_down` 函数的调用 ID。
- 假设位置 `\ell` 当前存储的标量值为 $s$。
2. **在 f 执行期间**：
- 任何对位置 `\ell` 的写入操作都会尝试弹出堆栈顶端的 `\text{SharedRO}(_, _ )` 项。
- 由于堆栈顶端的项 `\text{SharedRO}(t, c)` 有一个活跃的保护者 $c$，弹出该项会违反保护者规则，导致未定义行为。
- 因此，在 `f` 执行期间，不可能对 `\ell` 进行写入操作。
3. **结论**：
- 当 `f` 返回后，位置 `\ell` 仍然存储着值 $s$。
- 因此，在第 6 行，可以安全地读取 `*x`，并将返回值优化为 `s`。
**针对 example3_down 的证明**：

- 类似地，我们可以证明将写入操作下移也是安全的。
- 在 `f` 执行期间，`x` 的标签项在堆栈顶端，且具有活跃的保护者。
- 任何对 `x` 的读取或写入尝试都会弹出堆栈项，违反保护者规则。
- 因此，`f` 无法访问或修改 `x`，我们可以安全地在 `f` 之后进行写入操作。
##### **特殊情况**

- **程序行为的改变**：在这些优化中，编译器可能会在调用 `f` 时，`x` 中存储的值与原始程序不同。然而，由于 `f` 无法访问或修改 `x`，程序的行为仍然与原始程序一致。
- **无限循环的情况**：即使 `f` 进入无限循环，永远不返回，保护者仍然有效，优化仍然是安全的。
##### **完成优化矩阵**

为了完整地支持在未知代码之间对各种引用访问的上移和下移，作者还验证了以下优化：

1. **将读取操作下移穿过 f**：
```rust
// 将读取操作下移穿过 f()。
fn example1_down(x: &mut i32, f: impl FnOnce()) {
    retag[fn] x;
    let val = *x;
    f();
    return val; // 可以改为返回 *x。
}
```
2. **将写入操作上移穿过 f**：
```rust
// 将写入操作上移穿过 f()。
fn example3(x: &mut i32, f: impl FnOnce()) {
    retag[fn] x;
    *x = 42; // 我们可以将其改为写入 13...
    f();
    *x = 13; // ...并删除此写入。
}
```
- **证明过程**：这些优化的证明与之前类似，通过使用保护者，确保在 f 执行期间，x 的标签项在堆栈顶端且具有活跃的保护者，防止 f 访问或修改 x。
**全面总结：**

在 **第16章：保护者和内部可变性** 中，作者扩展了堆栈借用模型，以支持 **将内存访问指令下移**，从而为编译器提供更多的优化自由度。为了解决在指令下移时可能出现的引用生命周期过早结束的问题，作者引入了 **保护者（protectors）** 的概念。

主要内容和结论包括：

1. **指令下移的挑战**：
- 将内存访问指令下移会延长引用的生命周期，可能导致在函数执行期间，引用的堆栈项被弹出，违反了引用必须在函数调用期间有效的规则。
- 需要防止引用在函数执行期间过早失效，确保程序的行为与原始程序一致。
2. **引入保护者（Protectors）**：
- **保护者的定义**：借用堆栈项可以由函数调用 ID 进行保护，防止在函数执行期间被弹出。
- **堆栈借用规则的更新**：**retag-fn 规则**：在函数参数的 `retag[fn]` 操作中，向借用堆栈推入的新项被设置了保护者，保护者的值为当前函数调用的调用 ID。**protector 规则**：在弹出堆栈项时，如果该项有活跃的保护者（对应的函数调用仍在进行中），则弹出操作会违反堆栈借用模型，导致未定义行为。
3. **优化的证明概述**：
- **验证优化的正确性**：通过引入保护者，防止在函数执行期间引用的堆栈项被弹出，确保未知代码无法访问或修改引用所指向的内存，从而保证优化的安全性。
- **优化的特殊情况**：即使在程序行为发生变化（如调用函数时内存状态不同）或函数进入无限循环的情况下，优化仍然是安全的。
4. **完整的优化矩阵**：
- **支持的优化**：作者验证了在未知代码之间上移和下移读写操作的各种情况，包括：将读取操作下移或上移穿过未知代码。将写入操作下移或上移穿过未知代码。
- **统一的证明方法**：通过使用保护者，在函数执行期间保护引用的堆栈项，防止未知代码访问或修改引用所指向的内存。
5. **保护者的作用和意义**：
- **确保引用的生命周期**：保护者机制反映了 Rust 中引用的生命周期规则，确保传递给函数的引用在函数执行期间有效。
- **支持编译器优化**：保护者使得编译器可以在未知代码之间更灵活地重排序指令，提高优化的自由度，同时保持程序的安全性和正确性。
- **限制和未来工作**：目前，保护者赋予了函数特殊的地位，这种状态在函数内联时可能会丢失。作者认为这是合理的，但在未来，希望探索更明确的表示方法，以在内联期间保留这些信息。
**结论**：

通过引入保护者，堆栈借用模型进一步扩展，支持了更多的编译器优化，包括指令的上移和下移。保护者机制确保了引用在函数调用期间的有效性，防止了引用生命周期过早结束的问题，从而避免了未定义行为的发生。

这种扩展使得编译器能够在包括 `unsafe` 代码的情况下，更加自由地进行优化，提高程序的性能。同时，保护者机制与 Rust 的引用生命周期规则保持一致，确保了程序的安全性和正确性。

通过深入理解本章内容，读者可以更好地理解 Rust 编译器如何在保持内存安全和数据一致性的前提下，利用堆栈借用模型和保护者机制进行优化。这对于编写高性能且安全的 Rust 程序具有重要意义，也为未来的编译器和程序验证工具提供了理论基础。
 #  
 Thought for 1m 15s
**概览：**

您提供的内容来自论文《理解和发展 Rust 编程语言》（Understanding and Evolving the Rust Programming Language）的 **第三部分：堆栈借用（Stacked Borrows）**，具体是 **第16章：保护者和内部可变性（Protectors and Interior Mutability）** 中的 **16.4节：内部可变性（Interior Mutability）**。

本章的主要目标是 **扩展堆栈借用模型以支持 Rust 中的内部可变性（interior mutability）**，即在共享引用 `&T` 下允许对数据进行修改。这与之前的堆栈借用模型中的共享引用处理方式直接冲突，因为之前模型中的共享引用被视为只读的。

具体来说，作者讨论了以下内容：

1. **内部可变性的问题**：Rust 中的 `Cell<T>` 和 `RefCell<T>` 等类型允许通过共享引用对数据进行修改，这与堆栈借用模型中共享引用的只读性质相矛盾。
2. **引入 UnsafeCell<T> 类型**：Rust 使用特殊的类型 `UnsafeCell<T>` 来标记可能发生内部可变性的内存区域。编译器可以识别 `UnsafeCell<T>`，并在处理共享引用时给予特殊待遇。
3. **调整堆栈借用模型**：为了支持内部可变性，作者对堆栈借用模型进行了调整，包括：
- **引入 SharedRW(t) 项**：用于表示允许通过共享引用进行可变别名的内存区域。
- **处理部分内部可变性**：共享引用可能覆盖同时包含内部可变性和非内部可变性的内存区域，因此需要对不同区域分别处理。
- **修改引用创建和访问规则**：在创建共享引用和执行读写操作时，针对内部可变性进行了规则的调整。
4. **引入 Disabled 项**：为了解决特定的编程模式（如通过可变引用创建原始指针）的合法性，作者引入了 `Disabled` 项，允许在不破坏堆栈结构的情况下禁用特定的堆栈项。
5. **全面考虑语义**：在进行了这些调整后，作者重新审视了堆栈借用模型的语义，以确保它能够支持 Rust 中的内部可变性，同时保持对编译器优化的支持。
通过这些讨论，作者展示了如何调整堆栈借用模型，以支持内部可变性，使其与 Rust 现有的大量代码兼容，并确保编译器在进行别名分析和优化时能够正确地处理共享引用。

**详细解读：**

### **16.4 内部可变性**

#### **背景**

在之前的堆栈借用模型中，**共享引用 &T 被视为只读的**，即无法通过共享引用修改其指向的数据。这一设计允许编译器对共享引用进行强有力的别名分析和优化。然而，Rust 语言中存在 **内部可变性（interior mutability）** 的概念，即允许在某些受控的情况下，通过共享引用对数据进行修改。

**内部可变性** 是 Rust 中的一种设计模式，允许在保持外部不可变性的同时，对内部状态进行修改。这主要通过一些特殊的类型实现，例如：

- **Cell<T>**：允许在单线程上下文中，通过共享引用对数据进行修改。
- **RefCell<T>**：允许在运行时进行借用检查，确保在任意时刻只有一个可变借用或多个共享借用。
这些类型的存在与堆栈借用模型中共享引用的只读性质直接冲突。因此，作者需要调整堆栈借用模型，以支持内部可变性。

#### **问题的出现**

考虑以下示例函数：

```rust
fn cells(x: &Cell, y: &Cell) -> i32 {
    x.set(13);
    y.set(42);
    return x.get(); // 可以返回 13 或 42。
}
```

**解释**：

- `Cell<T>` 允许通过共享引用调用 `set` 方法来修改内部数据。
- 函数的返回值取决于 `x` 和 `y` 是否别名（指向同一内存位置）。如果别名，返回值为 `42`；否则，返回值为 `13`。
- 这种行为在之前的堆栈借用模型中是无法表示的，因为共享引用被视为只读。
#### **引入 UnsafeCell<T>**

为了解决这个问题，Rust 的设计者引入了一个特殊的类型 **UnsafeCell<T>**：

- **定义**：`UnsafeCell<T>` 是一个对 `T` 的包装，表示其内部数据可能在存在多个别名的情况下被修改。
- **作用**：`UnsafeCell<T>` 被编译器特殊对待，允许对其内部的数据进行修改，即使是通过共享引用。
- **实现**：例如，`Cell<T>` 就是基于 `UnsafeCell<T>` 实现的，提供了安全的 API。
**重要性**：

- **标记内部可变性**：通过使用 `UnsafeCell<T>`，程序员显式地标记了哪些数据可能发生内部可变性。
- **编译器识别**：编译器可以识别 `UnsafeCell<T>`，并在处理共享引用时给予特殊待遇。
#### **调整堆栈借用模型**

为了在堆栈借用模型中支持内部可变性，作者进行了以下调整：

##### **1. 引入 SharedRW(t) 项**

- **目的**：表示允许通过共享引用进行 **可变别名（aliasing mutation）** 的内存区域。
- **理由**：由于原始指针（raw pointers）和具有内部可变性的共享引用都允许可变别名，因此可以类似地处理它们。
##### **2. 处理部分内部可变性**

**问题**：

- **部分内部可变性**：共享引用可能覆盖的内存区域既包含内部可变的部分，也包含非内部可变的部分。
- **示例**：考虑类型 `&(i32, Cell<i32>)`，其中包含一个不可变的 `i32` 和一个内部可变的 `Cell<i32>`。
**解决方案**：

- **类型驱动的内存遍历**：在创建共享引用时，需要遍历引用所覆盖的内存区域，基于类型信息识别哪些区域是内部可变的。
- **不同处理**：**对于非内部可变的区域**：按照之前的方式，执行读取操作，将新的只读项 SharedRO(t, c) 推入堆栈顶端。**对于内部可变的区域（位于 UnsafeCell<T> 内）**：不视为读取操作（原因见后文）。在堆栈中找到标签为 `t` 的项，在其上方插入新的可读写项 `SharedRW(t, c)`。
##### **3. 修改引用创建和访问规则**

###### **创建引用不总是一次访问**

- **问题**：对于内部可变的部分，创建共享引用不能视为读取操作。
- **原因**：如果创建共享引用被视为读取操作，会违反可变引用的唯一性。
- **示例**：
```rust
fn nasty_ref_cell(shared: &RefCell, mutable: &mut i32) {
    retag[fn] shared; retag[fn] mutable;
    let more_shared = &*shared;
    *mutable = 23;
}
```
**解释**：在这个函数中，`shared` 和 `mutable` 可能别名。如果在创建 `more_shared` 时视为读取操作，会违反 `mutable` 的唯一性原则。但这是合法的安全代码，不能被视为未定义行为。
- **解决方案**：**在创建共享引用时，不执行读取操作**（对于内部可变的部分）。**在堆栈中插入新的 SharedRW 项，但不弹出任何项**。
###### **规则（new-shared-ref-2）**

- **当从指针值 Pointer(\ell, t) 创建新的共享引用时**：选择一个新的、未使用过的标签 `t'`。新的共享引用的值为 `Pointer(\ell, t')`。**对于引用覆盖的内存区域**：**内部可变的部分（位于 UnsafeCell 内）**：在堆栈中找到标签为 `t` 的项，在其上方插入 `SharedRW(t', c)`。如果没有找到标签为 `t` 的项，程序具有未定义行为。**非内部可变的部分**：视为对旧标签 `t` 的读取操作（遵循 `read-1` 规则）。在堆栈顶端推入 `SharedRO(t', c)`。
###### **调整原始指针的创建规则**

- **规则（new-mutable-raw-2）**：当通过类型转换（`expr as *mut T`）从可变引用 `&mut T` 创建可变原始指针时：在堆栈中找到标签为 `t` 的项，在其上方插入 `SharedRW(\bot)`。新的原始指针的值为 `Pointer(\ell, \bot)`。如果没有找到标签为 `t` 的项，程序具有未定义行为。
##### **4. 调整读写访问规则**

###### **写入操作的规则（write-1）**

- **目标**：允许多个相邻的 `SharedRW` 项，共同支持可变别名。
- **规则**：**对于使用指针值 Pointer(\_, t) 进行的写入操作**，对于受影响的每个位置 `\ell`：弹出堆栈项，直到满足以下条件之一：堆栈顶端的项是 `Unique(t, \_)`。存在 `SharedRW(t, \_)` 位于堆栈顶端的相邻 `SharedRW` 组中（即堆栈中存在 `SharedRW(t, \_)`，且其上方仅有 `SharedRW` 项）。如果无法满足上述条件，或弹出了具有活跃保护者的项，程序具有未定义行为。
###### **读取操作的调整**

- **问题**：在读取操作中，需要考虑带有标签的 `SharedRW` 项。
- **目标**：允许读取 `SharedRW` 项，而不使相邻的 `SharedRW` 或 `SharedRO` 项失效。
- **引入 Disabled 项**：**定义**：`Disabled` 项表示被禁用的堆栈项。**目的**：在读取操作中，不弹出堆栈项，而是将上方的 `Unique` 项标记为 `Disabled`。
###### **规则（read-2）**

- **对于使用指针值 Pointer(\_, t) 进行的读取操作**，对于受影响的每个位置 `\ell`：在堆栈中找到标签为 `t` 的最上方的（非 `Disabled`）项。将其上方的所有 `Unique(\_, \_)` 项替换为 `Disabled`。如果这些 `Unique` 项中有具有活跃保护者的项，程序具有未定义行为。
**原因**：

- **为何不弹出堆栈项**：弹出堆栈项可能会使 `SharedRW` 项被弹出，导致合法的代码被视为未定义行为。
- **通过标记为 Disabled**：避免了弹出 `SharedRW` 项，同时仍然保持堆栈借用模型的正确性。
#### **示例分析**

考虑以下代码片段：

```rust
fn make_raw(y: &mut i32) -> *mut i32 { retag[fn] y; y as *mut i32 }

fn bad_pattern(x: &mut i32) {
    retag[fn] x; // 假设 x = Pointer(\ell, t_x)。
    let raw_ptr = make_raw(x); // 等价于 make_raw(&mut *x)。
    // h(\ell) = [..., Unique(t_x), Unique(t_tmp), Unique(t_y), SharedRW(\bot)]
    let val1 = *x;
    // h(\ell) = [..., Unique(t_x)]
    let val2 = unsafe { *raw_ptr }; // 失败，因为 SharedRW(\bot) 不再在堆栈中！
}
```

**解释**：

- **问题**：在第 7 行，从 `x` 读取时，需要弹出上方的 `Unique` 项。
- **挑战**：如果严格遵守堆栈原则，必须弹出 `SharedRW(\bot)`，导致第 9 行的写入操作非法。
- **解决方案**：使用 `Disabled` 项，在读取操作中，不弹出堆栈项，而是将上方的 `Unique` 项标记为 `Disabled`。
- **结果**：`SharedRW(\bot)` 保持在堆栈中，第 9 行的写入操作合法。
#### **全面考虑语义**

通过引入 `SharedRW(t)` 和 `Disabled` 项，并调整引用创建和访问的规则，堆栈借用模型能够支持 Rust 中的内部可变性。

**优势**：

- **兼容性**：支持了大量现有的 Rust 代码，包括使用 `Cell<T>`、`RefCell<T>` 等类型的代码。
- **优化支持**：编译器仍然可以对共享引用进行别名分析和优化，在可能的情况下利用共享引用的只读特性。
- **一致性**：与原始指针的处理方式一致，简化了模型。
**全面总结：**

在 **第16章：保护者和内部可变性** 的 **16.4节** 中，作者针对 **内部可变性** 对堆栈借用模型进行了扩展和调整，使其能够兼容 Rust 中的内部可变性特性。

主要内容和结论包括：

1. **内部可变性的挑战**：
- **冲突**：之前的堆栈借用模型将共享引用视为只读，这与 Rust 中允许通过共享引用进行内部可变性的设计相矛盾。
- **需求**：需要调整堆栈借用模型，以支持 `Cell<T>`、`RefCell<T>` 等类型，以及大量依赖内部可变性的现有代码。
2. **引入 UnsafeCell<T> 的处理**：
- **作用**：`UnsafeCell<T>` 被编译器识别，用于标记可能发生内部可变性的内存区域。
- **处理方式**：在堆栈借用模型中，对位于 `UnsafeCell<T>` 内的内存区域给予特殊待遇，允许通过共享引用进行修改。
3. **调整堆栈借用模型**：
- **引入 SharedRW(t) 项**：表示允许可变别名的内存区域，适用于内部可变性和原始指针。
- **处理部分内部可变性**：在创建共享引用时，基于类型信息遍历内存区域，分别处理内部可变和非内部可变的部分。
- **修改引用创建规则**：**对于内部可变的部分**：在堆栈中找到原始标签 `t` 的项，在其上方插入 `SharedRW(t', c)`，不视为读取操作。**对于非内部可变的部分**：视为读取操作，推入 `SharedRO(t', c)`。
- **修改访问规则**：**写入操作**：调整规则 `write-1`，允许相邻的 `SharedRW` 项，共同支持可变别名。**读取操作**：引入 `Disabled` 项，在读取操作中，将上方的 `Unique` 项标记为 `Disabled`，而不弹出堆栈项。
4. **引入 Disabled 项的原因**：
- **解决特定的编程模式**：例如，通过可变引用创建原始指针的模式，需要在读取操作中不弹出 `SharedRW` 项。
- **保持堆栈结构**：避免在读取操作中弹出堆栈项，防止合法代码被视为未定义行为。
5. **兼容性和优化**：
- **兼容现有代码**：调整后的模型支持了 Rust 中大量使用内部可变性的代码，确保了向后兼容性。
- **支持编译器优化**：在可能的情况下，编译器仍然可以利用共享引用的只读特性进行优化。
6. **全面考虑语义**：
- **一致性**：调整后的模型在处理共享引用、内部可变性和原始指针时，具有一致的规则和逻辑。
- **完整性**：模型能够准确地描述 Rust 中的别名和借用关系，支持编译器的别名分析和优化。
**结论**：

通过引入 `SharedRW(t)` 和 `Disabled` 项，并对引用创建和访问的规则进行调整，作者成功地扩展了堆栈借用模型，使其能够支持 Rust 中的内部可变性。这一扩展确保了堆栈借用模型与 Rust 语言的设计原则和现有代码库兼容，同时保持了对编译器优化的支持。

调整后的堆栈借用模型能够准确地描述共享引用、可变引用、原始指针和内部可变性之间的关系，为编译器提供了可靠的别名分析基础。通过深入理解这些规则和机制，程序员可以更好地编写高性能且安全的 Rust 程序，充分利用 Rust 的类型系统和编译器优化能力。
 #  
 Thought for 10 seconds
**概览：**

您提供的内容来自论文《理解和发展 Rust 编程语言》（Understanding and Evolving the Rust Programming Language）的 **第三部分：堆栈借用（Stacked Borrows）**，具体是 **第17章：形式操作语义（Formal Operational Semantics）**，包括 **17.1节：高层结构（High-level Structure）**。

本章的主要目标是 **正式地定义堆栈借用模型的操作语义**，将之前章节中非形式的描述转化为严谨的数学定义。这对于验证模型的正确性、与其他形式化工具集成以及为未来的研究和改进提供坚实的基础都非常重要。

具体来说，本章讨论了以下内容：

1. **堆栈借用模型的总体结构**：介绍了模型的高层结构，定义了状态（state）、事件（event）和转换规则（transition rules）。这些定义以数学方式刻画了堆栈借用模型的行为。
2. **形式化的域和事件**：详细定义了模型中使用的各种域（如指针 ID、权限、标签、堆栈项等）和事件类型（如内存访问、重新标记、函数调用等），为模型的精确描述奠定了基础。
3. **状态转换规则**：定义了模型如何根据事件更新状态，包括如何处理内存访问、重新标记操作、（反）分配以及函数调用的开始和结束。这些规则以算法的形式给出，反映了堆栈借用模型的计算性质。
4. **与语言的解耦**：强调了堆栈借用模型与语言的其余部分是解耦的，即模型可以独立于具体的语言特性，只需要在相关事件发生时更新状态。这使得模型具有通用性和可扩展性。
通过这些形式化定义，作者将堆栈借用模型从非形式的描述提升到了严格的数学语义，为进一步的理论分析和工具开发提供了必要的基础。

**详细解读：**

### **第17章：形式操作语义**

在前面的章节中，堆栈借用模型的行为是通过非形式的描述给出的。为了使模型更加严谨，并便于验证和与其他形式化工具的集成，本章旨在 **正式地定义堆栈借用模型的操作语义**。

#### **17.1 高层结构**

##### **总体概述**

堆栈借用模型被定义为一个 **标记转换系统（labeled transition system）**，其中：

- **标签（label）**：表示事件（event），包括内存访问、重新标记、函数调用等。
- **状态（state）**：描述了堆栈借用模型在某一时刻的状态，包括堆栈、函数调用栈和生成新标签的计数器等。
这种结构使得堆栈借用模型与语言的其余部分解耦，即模型可以独立于具体的语言特性，只需要在相关事件发生时更新状态。

##### **状态的定义**

状态被定义为一个记录（record）：

$$
\varsigma \in \text{SState} := \{
\text{stacks} : \text{Stacks}, \\
\text{calls} : \text{List(CallId)}, \\
\text{nextptr} : \text{PtrId}, \\
\text{nextcall} : \text{CallId}
\}
$$

各字段含义如下：

- **stacks**：表示每个位置（location）的堆栈映射，类型为 $\text{Stacks} := \text{Loc} \finmap \text{Stack}$。
- **calls**：表示当前活跃的函数调用 ID 的列表，用于实现保护者（protector）的机制。
- **nextptr**：用于生成新的指针 ID（pointer IDs），即新的标签（tags）。
- **nextcall**：用于生成新的函数调用 ID。
其中，**堆栈（Stack）** 被定义为堆栈项的列表，堆栈项的结构将在后面详细说明。

##### **域的定义**

在 **图17.1** 中，定义了模型中使用的各种域（domains）：

- **指针 ID（PtrId）**：自然数集合，表示指针的唯一标识符。
- **标签（Tag）**：可以是一个指针 ID，或者是特殊值 $\bot$。
- **权限（Permission）**：包括 $\text{Unique}$、$\text{SharedRW}$、$\text{SharedRO}$、$\text{Disabled}$。
- **堆栈项（Item）**：由权限、标签和可选的保护者组成，即：
$$
\iota \in \text{Item} := \text{Permission} \times \text{Tag} \times \text{CallId}^{?}
$$
其中，$\text{CallId}^{?} := \text{CallId} \cup {\bot}$，表示可选的调用 ID。
- **堆栈（Stack）**：堆栈项的列表，表示一个位置的借用堆栈。
##### **事件的定义**

事件（Event）的定义也在 **图17.1** 中给出，包括：

- **内存访问事件（EAccess）**：表示对内存的读取或写入操作。
- **重新标记事件（ERetag）**：表示重新标记操作，即为引用或指针赋予新的标签。
- **分配和释放事件（EAlloc、EDealloc）**：表示内存的分配和释放。
- **函数调用开始和结束事件（EInitCall、EEndCall）**：用于跟踪函数调用的开始和结束，以支持保护者机制。
##### **状态转换规则**

状态转换规则定义了在事件发生时，如何从一个状态转换到下一个状态。这些规则以 **操作语义（operational semantics）** 的形式给出，采用了 **函数式的风格**，即通过函数计算下一个状态，而不是关系式的描述。

在 **图17.1** 中，给出了各个事件对应的状态转换规则。例如：

- **OS-access**：处理内存访问事件，包括读取和写入操作。
- **OS-retag**：处理重新标记事件。
- **OS-alloc** 和 **OS-dealloc**：处理内存的分配和释放。
- **OS-init-call** 和 **OS-end-call**：处理函数调用的开始和结束，更新调用栈 `calls`。
这些规则描述了在事件发生时，如何更新状态中的各个字段。

##### **与语言的解耦**

作者强调，这种定义方式将堆栈借用模型与语言的其余部分解耦：

- **独立性**：堆栈借用模型只需要在相关事件发生时更新状态，而不需要了解语言的其他细节。
- **可扩展性**：这种方式允许堆栈借用模型与其他语言特性或语义模型集成，具有良好的可扩展性。
- **算法化**：由于堆栈借用模型的行为具有很强的算法性质，因此采用函数式的定义比关系式的定义更自然。
#### **深入解释**

接下来，我们详细解释 **图17.1** 中的各个部分和状态转换规则。

##### **域（Domains）**

1. **指针 ID（PtrId）**：
- 定义为自然数集合 $\mathbb{N}$，用于唯一标识指针或标签。
2. **标签（Tag）**：
- 定义为 $\text{Tag} := \text{PtrId}^{?}$，即可以是一个指针 ID 或特殊值 $\bot$。
3. **权限（Permission）**：
- 包含四种可能的值：**Unique**：唯一的，可变的引用。**SharedRW**：共享的读写权限。**SharedRO**：共享的只读权限。**Disabled**：被禁用的权限。
4. **调用 ID（CallId）**：
- 定义为自然数集合 $\mathbb{N}$，用于标识函数调用。
5. **堆栈项（Item）**：
- 定义为三元组 $\iota := \text{Permission} \times \text{Tag} \times \text{CallId}^{?}$。
- 表示在堆栈中的一项，包含权限、标签和可选的保护者（调用 ID）。
6. **堆栈（Stack）**：
- 定义为堆栈项的列表 $\text{Stack} := \text{List(Item)}$。
7. **类型（Type）**：
- 包含多种可能的类型，包括定长类型、指针类型、UnsafeCell、联合类型、乘积类型和和类型等。
8. **事件（Event）**：
- 包含各种可能的事件类型，如内存访问、重新标记、分配、释放、函数调用开始和结束等。
##### **事件的参数**

- **内存访问事件（EAccess）**：**a**：访问类型，可能是读取（AccessRead）或写入（AccessWrite）。**Pointer(\ell, t)**：指向内存位置 `\ell`，标签为 `t` 的指针。**τ**：访问的类型，决定了访问的大小。
- **重新标记事件（ERetag）**：**Pointer(\ell, t_old)**：原始指针。**t_new**：新的标签。**τ**：重新标记的类型。**k**：指针的种类（PtrKind），如可变引用、共享引用、原始指针等。**k'**：重新标记的种类（RetagKind），如默认、原始指针、函数入口等。
##### **状态转换规则**

1. **OS-access（内存访问）**
- **前提条件**：调用函数 `MemAccessed`，传入当前的堆栈映射 `ς.stacks`、调用栈 `ς.calls`、访问类型 `a`、指针 `Pointer(\ell, t)` 和访问大小 `|\tau|`。`MemAccessed` 返回新的堆栈映射 `ξ'`。
- **状态更新**：更新状态中的堆栈映射为 ξ'。
- **表示**：
$$
\varsigma \xrightarrow{\text{EAccess}(a, \text{Pointer}(\ell, t), \tau)} \varsigma'
$$
2. **OS-retag（重新标记）**
- **前提条件**：调用函数 `Retag`，传入当前的堆栈映射 `ς.stacks`、下一个指针 ID `ς.nextptr`、调用栈 `ς.calls`、原始指针 `Pointer(\ell, t_{\text{old}})`、类型 `τ`、指针种类 `k` 和重新标记种类 `k'`。`Retag` 返回新的标签 `t_{\text{new}}`、新的堆栈映射 `ξ'` 和更新后的下一个指针 ID `n_0`。
- **状态更新**：更新状态中的堆栈映射为 ξ'，nextptr 为 n_0。
- **表示**：
$$
\varsigma \xrightarrow{\text{ERetag}(\text{Pointer}(\ell, t_{\text{old}}), t_{\text{new}}, \tau, k, k')} \varsigma'
$$
3. **OS-alloc（分配）**
- **前提条件**：对于内存区域 `[ \ell, \ell + |\tau| )` 中的每个位置 `\ell'`，该位置不在当前的堆栈映射中，即 `\ell' \notin \text{dom}(ς.stacks)`。新的标签 `t` 为 `ς.nextptr`。
- **状态更新**：更新堆栈映射，在内存区域 `[ \ell, \ell + |\tau| )` 的每个位置 `\ell'`，设置堆栈为 `[(\text{Unique}, t, \bot)]`。更新 `nextptr` 为 `ς.nextptr + 1`。
- **表示**：
$$
\varsigma \xrightarrow{\text{EAlloc}(\text{Pointer}(\ell, t), \tau)} \varsigma'
$$
4. **OS-dealloc（释放）**
- **前提条件**：调用函数 `MemDeallocated`，传入当前的堆栈映射 `ς.stacks`、调用栈 `ς.calls`、指针 `Pointer(\ell, t)` 和内存大小 `|\tau|`。`MemDeallocated` 返回新的堆栈映射 `ξ'`。
- **状态更新**：更新状态中的堆栈映射为 ξ'。
- **表示**：
$$
\varsigma \xrightarrow{\text{EDealloc}(\text{Pointer}(\ell, t), \tau)} \varsigma'
$$
5. **OS-init-call（函数调用开始）**
- **前提条件**：新的调用 ID c 为 ς.nextcall。
- **状态更新**：将 `c` 添加到调用栈 `calls` 的末尾，即 `ς.calls ++ [c]`。更新 `nextcall` 为 `c + 1`。
- **表示**：
$$
\varsigma \xrightarrow{\text{EInitCall}(c)} \varsigma'
$$
6. **OS-end-call（函数调用结束）**
- **前提条件**：当前的调用栈为 C ++ [c]，即 c 是调用栈顶端的调用 ID。
- **状态更新**：将调用栈更新为 C，即移除栈顶的调用 ID c。
- **表示**：
$$
\varsigma \xrightarrow{\text{EEndCall}(c)} \varsigma'
$$
##### **函数调用 ID 的跟踪**

- **目的**：为了实现保护者（protector）机制，需要跟踪当前活跃的函数调用 ID。
- **机制**：**OS-init-call**：在函数调用开始时，生成一个新的调用 ID `c`，并将其添加到调用栈 `calls` 中。**OS-end-call**：在函数调用结束时，确保 `c` 是调用栈顶端的调用 ID，并将其从调用栈中移除。
- **应用**：在保护者规则中，需要判断堆栈项的保护者是否活跃，即对应的调用 ID 是否在当前的调用栈中。
#### **与语言的解耦**

作者强调，堆栈借用模型的定义方式将其与语言的其余部分解耦。这意味着：

- **独立性**：堆栈借用模型可以独立地定义和分析，而不依赖于具体的语言特性或语义。
- **灵活性**：这种解耦允许模型与不同的语言或语义模型集成，具有广泛的适用性。
- **实现简化**：在语言的操作语义中，只需要在相关事件发生时更新堆栈借用模型的状态即可，而不需要将其与语言的其他部分紧密耦合。
#### **后续内容预告**

在本节的最后，作者指出：

- 接下来将详细讨论 **内存访问（读取和写入）** 以及 **（反）分配** 的处理（在 **17.2节**）。
- 然后将讨论 **重新标记操作** 的处理（在 **17.3节**）。
**全面总结：**

在 **第17章：形式操作语义** 的 **17.1节：高层结构** 中，作者正式定义了堆栈借用模型的操作语义，将之前非形式的描述转化为严谨的数学定义。主要内容和结论包括：

1. **堆栈借用模型的总体结构**：
- **标记转换系统**：堆栈借用模型被定义为一个标记转换系统，状态由堆栈映射、调用栈和生成新标签的计数器等组成。
- **事件驱动**：模型的状态转换由事件驱动，包括内存访问、重新标记、函数调用等。
2. **形式化的域和事件**：
- **精确定义**：详细定义了模型中使用的各种域，如指针 ID、标签、权限、堆栈项、类型、事件等。
- **堆栈项结构**：堆栈项由权限、标签和可选的保护者组成，精确地表示了借用堆栈的状态。
3. **状态转换规则**：
- **操作语义**：采用函数式的定义方式，明确地描述了在事件发生时，如何从一个状态转换到下一个状态。
- **规则的具体化**：给出了处理内存访问、重新标记、分配、释放、函数调用开始和结束的具体规则。
4. **与语言的解耦**：
- **独立性和可扩展性**：堆栈借用模型的定义与语言的其余部分解耦，使其具有独立性和可扩展性。
- **算法化的定义**：由于模型的行为具有很强的算法性质，采用函数式的定义方式比关系式的定义更自然和直观。
5. **保护者机制的实现**：
- **调用栈的跟踪**：通过在函数调用开始和结束时更新调用栈，实现了保护者机制，确保在函数执行期间，受保护的堆栈项不会被非法弹出。
6. **为后续章节奠定基础**：
- **内存访问和重新标记**：本节为后续详细讨论内存访问和重新标记操作的处理奠定了基础。
- **形式化分析**：通过严格的数学定义，模型可以被用于形式化验证和分析，为进一步的理论研究和工具开发提供了必要的基础。
**结论**：

通过在 **第17章** 中对堆栈借用模型的操作语义进行形式化定义，作者为模型的严谨性和可验证性提供了坚实的基础。模型被定义为一个标记转换系统，状态由堆栈映射、调用栈和生成新标签的计数器等组成。事件驱动的状态转换规则明确地描述了在各种事件发生时，如何更新模型的状态。

这种定义方式将堆栈借用模型与语言的其余部分解耦，具有独立性和可扩展性，允许模型与不同的语言或语义模型集成。同时，函数式的定义方式反映了模型的算法性质，使其更自然和直观。

通过严格的数学定义，堆栈借用模型可以被用于形式化验证和分析，确保模型的正确性和一致性。这为编译器优化、程序验证以及未来的研究和改进提供了必要的基础。
 #  
 Thought for 28 seconds
**概览：**

您提供的内容来自论文《理解和发展 Rust 编程语言》（Understanding and Evolving the Rust Programming Language）的 **第三部分：堆栈借用（Stacked Borrows）**，具体是 **第17章：形式操作语义（Formal Operational Semantics）**，包括 **17.1节：高层结构（High-level Structure）**、**17.2节：内存访问（Memory Accesses）** 和 **17.3节：重新标记（Retagging）**。

本章的主要目标是 **正式地定义堆栈借用模型的操作语义**，将之前章节中非形式的描述转化为严谨的数学定义。这对于验证模型的正确性、与其他形式化工具集成以及为未来的研究和改进提供坚实的基础都非常重要。

具体来说，本章讨论了以下内容：

1. **堆栈借用模型的高层结构**（第17.1节）：
- 定义了堆栈借用模型作为一个 **标记转换系统（labeled transition system）**，其中的标签是事件（events），状态是模型的内部表示。
- 介绍了状态的组成，包括堆栈映射（stacks）、函数调用栈（calls）、用于生成新指针 ID 的计数器（nextptr）和用于生成新调用 ID 的计数器（nextcall）。
- 说明了这种结构如何将堆栈借用模型与语言的其余部分解耦，使其能够独立地描述和分析。
2. **内存访问的形式化定义**（第17.2节）：
- 通过实现 MemAccessed 函数，形式化地定义了内存访问（读取和写入）在堆栈借用模型中的行为。
- 介绍了辅助函数 Access、FindGranting、Grants 等，详细说明了如何确定某个堆栈项是否授权了当前的内存访问，以及如何更新堆栈。
- 讨论了内存分配和释放的处理方式，说明了它们与写入操作的相似之处。
3. **重新标记的形式化定义**（第17.3节）：
- 解释了重新标记（retagging）操作的必要性，以及如何在形式化语义中定义它。
- 介绍了核心的辅助函数 Reborrow，详细描述了重新标记过程的每个步骤，包括计算新权限、创建新的堆栈项、确定对应的内存访问类型、在堆栈中添加新项等。
- 定义了 Retag 函数，说明了如何根据指针种类和重新标记种类，计算新的标签和保护者，并更新状态。
通过这些形式化定义，作者将堆栈借用模型从非形式的描述提升到了严格的数学语义，为进一步的理论分析和工具开发提供了必要的基础。

**详细解读：**

### **第17章：形式操作语义**

在前面的章节中，堆栈借用模型的行为是通过非形式的描述给出的。为了使模型更加严谨，并便于验证和与其他形式化工具的集成，本章旨在 **正式地定义堆栈借用模型的操作语义**。

#### **17.1 高层结构**

##### **总体概述**

堆栈借用模型被定义为一个 **标记转换系统（labeled transition system）**，其中：

- **标签（label）**：表示事件（event），包括内存访问、重新标记、函数调用等。
- **状态（state）**：描述了堆栈借用模型在某一时刻的状态，包括堆栈、函数调用栈和生成新标签的计数器等。
这种结构使得堆栈借用模型与语言的其余部分解耦，即模型可以独立于具体的语言特性，只需要在相关事件发生时更新状态。

##### **状态的定义**

状态被定义为一个记录（record）：

$$
\varsigma \in \text{SState} := \{
\text{stacks} : \text{Stacks}, \\
\text{calls} : \text{List(CallId)}, \\
\text{nextptr} : \text{PtrId}, \\
\text{nextcall} : \text{CallId}
\}
$$

各字段含义如下：

- **stacks**：表示每个位置（location）的堆栈映射，类型为 $\text{Stacks} := \text{Loc} \finmap \text{Stack}$。
- **calls**：表示当前活跃的函数调用 ID 的列表，用于实现保护者（protector）的机制。
- **nextptr**：用于生成新的指针 ID（pointer IDs），即新的标签（tags）。
- **nextcall**：用于生成新的函数调用 ID。
其中，**堆栈（Stack）** 被定义为堆栈项的列表，堆栈项的结构将在后面详细说明。

##### **域的定义**

在 **图17.1** 中，定义了模型中使用的各种域（domains）：

- **指针 ID（PtrId）**：自然数集合，表示指针的唯一标识符。
$$
\text{PtrId} := \mathbb{N}
$$
- **标签（Tag）**：可以是一个指针 ID，或者是特殊值 $\bot$。
$$
t \in \text{Tag} := \text{PtrId}^{?}
$$
- **权限（Permission）**：包括 $\text{Unique}$、$\text{SharedRW}$、$\text{SharedRO}$、$\text{Disabled}$。
$$
p \in \text{Permission} := \text{Unique} \mid \text{SharedRW} \mid \text{SharedRO} \mid \text{Disabled}
$$
- **堆栈项（Item）**：由权限、标签和可选的保护者组成，即：
$$
\iota \in \text{Item} := \text{Permission} \times \text{Tag} \times \text{CallId}^{?}
$$
其中，$\text{CallId}^{?} := \text{CallId} \cup {\bot}$，表示可选的调用 ID。
- **调用 ID（CallId）**：自然数集合，用于标识函数调用。
$$
c \in \text{CallId} := \mathbb{N}
$$
- **堆栈（Stack）**：堆栈项的列表。
$$
S \in \text{Stack} := \text{List(Item)}
$$
- **类型（Type）**：包括定长类型、指针类型、`UnsafeCell`、联合类型、乘积类型和和类型等。
$$
\tau \in \text{Type} := \text{FixedSize}(n) \mid \text{Ptr}(k, \tau) \mid \text{UnsafeCell}(\tau) \mid \text{Union}(\tau^*) \mid \text{Prod}(\tau^*) \mid \text{Sum}(\tau^*)
$$
其中，$n \in \mathbb{N}$，$k$ 是指针种类（PtrKind），$\tau^*$ 表示类型的列表。
##### **事件的定义**

事件（Event）的定义也在 **图17.1** 中给出，包括：

- **内存访问事件（EAccess）**：表示对内存的读取或写入操作。
$$
\varepsilon \in \text{Event} := \text{EAccess}(a, \text{Pointer}(\ell, t), \tau)
$$
其中，$a \in \text{AccessType}$，可能是读取（AccessRead）或写入（AccessWrite）。
- **重新标记事件（ERetag）**：表示重新标记操作，即为引用或指针赋予新的标签。
$$
\varepsilon := \text{ERetag}(\text{Pointer}(\ell, t_{\text{old}}), t_{\text{new}}, \tau, k, k')
$$
其中，$k \in \text{PtrKind}$，$k' \in \text{RetagKind}$。
- **分配和释放事件（EAlloc、EDealloc）**：表示内存的分配和释放。
$$
\varepsilon := \text{EAlloc}(\text{Pointer}(\ell, t), \tau) \mid \text{EDealloc}(\text{Pointer}(\ell, t), \tau)
$$
- **函数调用开始和结束事件（EInitCall、EEndCall）**：用于跟踪函数调用的开始和结束。
$$
\varepsilon := \text{EInitCall}(c) \mid \text{EEndCall}(c)
$$
##### **状态转换规则**

状态转换规则定义了在事件发生时，如何从一个状态转换到下一个状态。这些规则以 **操作语义（operational semantics）** 的形式给出，采用了 **函数式的风格**，即通过函数计算下一个状态，而不是关系式的描述。

在 **图17.1** 中，给出了各个事件对应的状态转换规则。例如：

- **OS-access**（内存访问）：
$$
\text{MemAccessed}(\varsigma.\text{stacks}, \varsigma.\text{calls}, a, \text{Pointer}(\ell, t), |\tau|) = \xi' \\
\varsigma' = \varsigma \text{ with } [\text{stacks} := \xi'] \\
\varsigma \xrightarrow{\text{EAccess}(a, \text{Pointer}(\ell, t), \tau)} \varsigma'
$$
- **OS-retag**（重新标记）：
$$
\text{Retag}(\varsigma.\text{stacks}, \varsigma.\text{nextptr}, \varsigma.\text{calls}, \text{Pointer}(\ell, t_{\text{old}}), \tau, k, k') = (t_{\text{new}}, \xi', n_0) \\
\varsigma' = \varsigma \text{ with } [\text{stacks} := \xi', \text{nextptr} := n_0] \\
\varsigma \xrightarrow{\text{ERetag}(\text{Pointer}(\ell, t_{\text{old}}), t_{\text{new}}, \tau, k, k')} \varsigma'
$$
- **OS-alloc**（分配）：
$$
\forall \ell' \in [\ell, \ell + |\tau|). \ \ell' \notin \text{dom}(\varsigma.\text{stacks}) \\
t = \varsigma.\text{nextptr} \\
\xi' = \varsigma.\text{stacks} \text{ with } \ell' \in [\ell, \ell + |\tau|) [\ell' := [(\text{Unique}, t, \bot)]] \\
\varsigma' = \varsigma \text{ with } [\text{stacks} := \xi', \text{nextptr} := \varsigma.\text{nextptr} + 1] \\
\varsigma \xrightarrow{\text{EAlloc}(\text{Pointer}(\ell, t), \tau)} \varsigma'
$$
- **OS-dealloc**（释放）：
$$
\text{MemDeallocated}(\varsigma.\text{stacks}, \varsigma.\text{calls}, \text{Pointer}(\ell, t), |\tau|) = \xi' \\
\varsigma' = \varsigma \text{ with } [\text{stacks} := \xi'] \\
\varsigma \xrightarrow{\text{EDealloc}(\text{Pointer}(\ell, t), \tau)} \varsigma'
$$
- **OS-init-call**（函数调用开始）：
$$
c = \varsigma.\text{nextcall} \\
\varsigma' = \varsigma \text{ with } [\text{calls} := \varsigma.\text{calls} ++ [c], \text{nextcall} := c + 1] \\
\varsigma \xrightarrow{\text{EInitCall}(c)} \varsigma'
$$
- **OS-end-call**（函数调用结束）：
$$
\varsigma.\text{calls} = C ++ [c] \\
\varsigma' = \varsigma \text{ with } [\text{calls} := C] \\
\varsigma \xrightarrow{\text{EEndCall}(c)} \varsigma'
$$
##### **函数调用 ID 的跟踪**

- **目的**：为了实现保护者（protector）机制，需要跟踪当前活跃的函数调用 ID。
- **机制**：**OS-init-call**：在函数调用开始时，生成一个新的调用 ID c，并将其添加到调用栈 calls 中。**OS-end-call**：在函数调用结束时，确保 c 是调用栈顶端的调用 ID，并将其从调用栈中移除。
- **应用**：在保护者规则中，需要判断堆栈项的保护者是否活跃，即对应的调用 ID 是否在当前的调用栈中。
##### **与语言的解耦**

作者强调，这种定义方式将堆栈借用模型与语言的其余部分解耦。这意味着：

- **独立性**：堆栈借用模型可以独立地定义和分析，而不依赖于具体的语言特性或语义。
- **灵活性**：这种解耦允许模型与不同的语言或语义模型集成，具有广泛的适用性。
- **实现简化**：在语言的操作语义中，只需要在相关事件发生时更新堆栈借用模型的状态即可，而不需要将其与语言的其他部分紧密耦合。
#### **17.2 内存访问**

在 **图17.2** 中，作者形式化地定义了内存访问（读取和写入）在堆栈借用模型中的行为。

##### **MemAccessed 函数**

`MemAccessed` 函数定义了在内存访问事件 `EAccess` 发生时，堆栈借用模型的状态如何更新。

- **输入**：当前的堆栈映射 \xi。调用栈 C。访问类型 a（读取或写入）。指针 \text{Pointer}(\ell, t)。访问的大小 n（由类型 \tau 的大小决定）。
- **处理流程**：对于受影响的每个位置 \ell'，调用辅助函数 Access 来计算新的堆栈。如果在任何位置上 Access 返回 \bot（表示访问非法），则 MemAccessed 也返回 \bot，表示程序在此处违反了堆栈借用模型的规则。
##### **Access 函数**

`Access` 函数定义了在单个位置上进行内存访问时，堆栈如何更新。

- **流程**：**找到授权项**（granting item）：使用 FindGranting 函数，在堆栈 S 中自顶向下搜索，找到具有标签 t 且授权当前访问的堆栈项。如果未找到，则访问非法，返回 \bot。**根据访问类型更新堆栈**：**读取操作（AccessRead）**：将授权项之上的所有 Unique 项标记为 Disabled。如果这些 Unique 项中有具有活跃保护者的项，访问非法，返回 \bot。**写入操作（AccessWrite）**：找到第一个与当前写入操作不兼容的堆栈项的位置 j（使用 FindFirstWIncompat 函数）。弹出位置 j 及其以上的所有堆栈项。如果弹出的堆栈项中有具有活跃保护者的项，访问非法，返回 \bot。
##### **辅助函数**

- **Grants 函数**：确定具有权限 p 的堆栈项是否授权类型为 a 的访问。对于写入操作，只有 Unique 和 SharedRW 授权访问。对于读取操作，Unique、SharedRW 和 SharedRO 授权访问，Disabled 不授权访问。
- **FindGranting 函数**：在堆栈 S 中自顶向下搜索，找到具有标签 t 且授权访问的堆栈项。
- **FindFirstWIncompat 函数**：找到第一个与当前写入操作不兼容的堆栈项的位置。对于 Unique 权限，写入操作与其上的任何堆栈项都不兼容。对于 SharedRW 权限，写入操作与相邻的 SharedRW 项兼容，与其他项不兼容。
##### **内存分配和释放**

- **分配（Allocation）**：在 OS-alloc 中定义。为每个新分配的位置，赋予新的标签 t 和 Unique 权限，堆栈项为 (\text{Unique}, t, \bot)。
- **释放（Deallocation）**：类似于写入操作，但要求释放的内存位置上不存在具有活跃保护者的堆栈项。如果存在，则释放非法，返回 \bot。
#### **17.3 重新标记**

在之前的章节（第15和16章）中，我们讨论了当创建引用或将引用转换为原始指针时，需要对堆栈进行额外的操作，例如在堆栈中推入新的项。这些操作被统称为 **重新标记（retagging）**。

##### **重新标记的必要性**

- **目的**：重新标记为引用或指针赋予新的标签，并在堆栈中添加相应的项，以准确地跟踪引用和指针的使用。
- **简化**：作者提出了一种简化的方式，将引用或指针的创建和转换统一为显式的重新标记操作 retag。例如，在 Rust 中，let x = &mut expr 被视为 let x = &mut expr; retag x。这样，&mut expr 本身保持旧的标签，retag x 负责分配新标签和更新堆栈。
- **优势**：这种方式使得模型更加简洁，所有的堆栈更新操作都集中在 retag 中，而不需要在引用创建或类型转换时进行特殊处理。
##### **Reborrow 函数**

`Reborrow` 函数是 `retag` 的核心辅助函数，定义了重新标记过程的具体步骤。

- **参数**：**旧指针**：Pointer(\ell, t_{\text{old}})。**类型**：τ，指针指向的数据类型。**新标签**：t_{\text{new}}。**指针种类**：k，表示新指针的种类（可变引用、共享引用、原始指针、Box 等）。**保护者**：prot，可选的调用 ID，用于保护新堆栈项。
- **过程**：**遍历指针覆盖的所有位置**（通过 FrozenIter(\ell, τ) 计算）：对于每个位置 \ell'，确定其是否在 UnsafeCell 外部（冻结的，frozen）或内部。**计算新权限**（使用 NewPerm 函数）：**可变引用（&mut T）**：p_{\text{new}} := \text{Unique}。**可变原始指针（*mut T）**：p_{\text{new}} := \text{SharedRW}。**共享引用（&T）或常量原始指针（*const T）**：如果位置 \ell' 冻结（在 UnsafeCell 外部），p_{\text{new}} := \text{SharedRO}。否则，p_{\text{new}} := \text{SharedRW}。**创建新的堆栈项**：ι_{\text{new}} := (p_{\text{new}}, t_{\text{new}}, \text{prot})。**确定对应的内存访问类型**：如果 p_{\text{new}} 允许写入，则访问类型 a := \text{AccessWrite}。否则，a := \text{AccessRead}。**找到授权项**：在堆栈 S 中，使用标签 t_{\text{old}} 和访问类型 a，找到授权项。**更新堆栈**：**如果 p_{\text{new}} = \text{SharedRW}**：将新的堆栈项 ι_{\text{new}} 插入到授权项之后的位置。**否则**：执行一次访问（读取或写入）操作，更新堆栈。将新的堆栈项 ι_{\text{new}} 推入堆栈顶端。
##### **Retag 函数**

`Retag` 函数负责处理重新标记操作，主要步骤如下：

1. **计算新标签和保护者**（使用 NewTagAndProtector 函数）：
- 根据指针种类 k 和重新标记种类 k'，确定新的标签 t_{\text{new}} 和保护者 \text{prot}。
- **规则**：**原始指针（Raw）**：如果是 retag[raw]，则新的标签为 \bot，没有保护者。否则，保持旧的标签和保护者。**Box 指针**：分配新的标签，没有保护者。**引用（Reference）**：分配新的标签。如果是函数入口的 retag[fn]，则保护者为当前调用栈的顶端调用 ID。否则，没有保护者。
2. **调用 Reborrow 函数**：
- 使用计算得到的 t_{\text{new}} 和 \text{prot}，对指针进行重新标记，更新堆栈。
3. **更新状态**：
- 更新堆栈映射和下一个指针 ID。
##### **示例**

- **创建可变引用**：原始代码：let x = &mut expr;转换为：let x = &mut expr; retag x;在 retag x; 中，k = \text{Ref(Mutable)}，k' = \text{Default}。NewTagAndProtector 分配新的标签 t_{\text{new}}，没有保护者。Reborrow 为 x 的位置推入新的堆栈项 (\text{Unique}, t_{\text{new}}, \bot)。
- **将引用转换为原始指针**：原始代码：let p = x as *mut T;转换为：let p = x as *mut T; retag[raw] p;在 retag[raw] p; 中，k = \text{Raw(Mutable)}，k' = \text{Raw}。NewTagAndProtector 使新的标签为 \bot，没有保护者。Reborrow 为 p 的位置推入新的堆栈项 (\text{SharedRW}, \bot, \bot)。
**全面总结：**

在 **第17章：形式操作语义** 中，作者正式定义了堆栈借用模型的操作语义，将之前非形式的描述转化为严谨的数学定义。主要内容和结论包括：

1. **堆栈借用模型的高层结构**（第17.1节）：
- **标记转换系统**：堆栈借用模型被定义为一个标记转换系统，状态由堆栈映射、调用栈和生成新标签的计数器等组成。
- **事件驱动**：模型的状态转换由事件驱动，包括内存访问、重新标记、函数调用等。
- **解耦性**：这种定义方式将堆栈借用模型与语言的其余部分解耦，使其具有独立性和可扩展性。
2. **内存访问的形式化定义**（第17.2节）：
- **MemAccessed 函数**：定义了在内存访问事件发生时，如何根据访问类型、指针、类型等更新堆栈借用模型的状态。
- **辅助函数**：引入了 Access、FindGranting、Grants、FindFirstWIncompat 等辅助函数，详细说明了如何确定某个堆栈项是否授权了当前的内存访问，以及如何更新堆栈。
- **处理非法访问**：通过返回 \bot 表示访问非法，模型能够正确地识别和处理违反堆栈借用规则的情况。
- **内存分配和释放**：将分配和释放视为特殊的写入操作，定义了相应的处理方式。
3. **重新标记的形式化定义**（第17.3节）：
- **重新标记的必要性**：为了准确地跟踪引用和指针的使用，需要在创建引用或转换指针类型时进行重新标记。
- **Reborrow 函数**：详细定义了重新标记过程，包括计算新权限、创建新的堆栈项、确定对应的内存访问类型、在堆栈中添加新项等。
- **Retag 函数**：根据指针种类和重新标记种类，计算新的标签和保护者，并调用 Reborrow 函数更新堆栈。
- **统一处理**：通过将所有的堆栈更新操作集中在 retag 中，模型更加简洁，避免了在引用创建或类型转换时进行特殊处理。
4. **模型的完整性和严谨性**：
- **形式化定义**：通过严格的数学定义，堆栈借用模型可以被用于形式化验证和分析，确保模型的正确性和一致性。
- **可验证性**：模型的定义方式有助于证明编译器优化的合法性，以及验证程序的内存安全性。
5. **与编译器和语言的关系**：
- **独立性**：堆栈借用模型与语言的其余部分解耦，允许模型独立地定义和分析。
- **优化支持**：模型的定义方式支持编译器在保持内存安全的前提下进行优化。
- **灵活性**：模型可以与不同的语言或语义模型集成，具有广泛的适用性。
**结论**：

通过在 **第17章** 中对堆栈借用模型的操作语义进行形式化定义，作者为模型的严谨性和可验证性提供了坚实的基础。模型被定义为一个标记转换系统，状态由堆栈映射、调用栈和生成新标签的计数器等组成。事件驱动的状态转换规则明确地描述了在各种事件发生时，如何更新模型的状态。

在内存访问的形式化定义中，作者详细描述了如何根据访问类型、权限、标签等更新堆栈，确保模型能够准确地反映内存访问的行为。通过处理非法访问和引入辅助函数，模型能够正确地识别和处理违反堆栈借用规则的情况。

在重新标记的形式化定义中，作者通过引入 `Reborrow` 和 `Retag` 函数，将堆栈更新操作集中化，简化了模型的复杂性。这使得模型更加易于理解和分析，同时支持编译器在创建引用或转换指针类型时正确地更新堆栈。

这种形式化的定义为编译器优化、程序验证以及未来的研究和改进提供了必要的基础。通过严格的数学定义，堆栈借用模型可以被用于形式化验证和分析，确保模型的正确性和一致性。这对于 Rust 编程语言的理解和发展具有重要意义，有助于提高程序的内存安全性和性能。
 #  
 Thought for 31 seconds
**概览：**

您提供的内容来自论文《理解和发展 Rust 编程语言》（Understanding and Evolving the Rust Programming Language）的 **第十八章：评估（Evaluation）**，其中包括 **18.1节：Miri** 和 **18.2节：Coq 形式化（Coq formalization）**。

本章的主要目标是 **评估堆栈借用模型（Stacked Borrows）**，以确保其在实践中是可行且有用的。作者通过两种方式进行评估：

1. **在 Miri 中实现堆栈借用模型**：Miri 是一个 Rust 解释器，作者在其中实现了堆栈借用模型，以测试现有的 Rust 代码，特别是涉及不安全（unsafe）代码的部分，确保模型与实际的 Rust 代码编写方式不冲突。
2. **在 Coq 中形式化堆栈借用模型的操作语义**：为了增加对模型语义的信心，作者将之前章节中非形式的证明草图在 Coq 中进行了形式化，证明了所有示例转换的正确性，并构建了一个基于开放模拟的模拟框架。
通过这些评估，作者验证了堆栈借用模型的实用性和正确性，证明了其在 Rust 编程语言中的适用性。

**详细解读：**

### **第十八章：评估**

在本章中，作者旨在评估堆栈借用模型，以确保它在实际应用中是可行的，并且与现有的 Rust 代码兼容。他们采用了两种评估方式：

1. **在 Miri 中实现堆栈借用模型**，以测试实际的 Rust 代码，特别是不安全代码，验证模型与实际编程实践的一致性。
2. **在 Coq 中形式化模型的操作语义**，将之前的非形式证明转化为机械化的正确性证明，以增加对模型的信心。
#### **18.1 Miri**

##### **背景**

**Miri** 是一个 Rust 解释器，它在中间表示（MIR）上运行。MIR 是 Rust 编译器中的一种中间表示，具有以下特点：

- **命令式**：MIR 是一种命令式的语言，适合直接解释执行。
- **非 SSA 形式**：与静态单赋值形式（SSA）不同，MIR 允许变量被多次赋值。
- **基于控制流图**：MIR 使用控制流图（CFG）来表示程序的执行路径。
- **操作集较小**：MIR 的操作集较小，便于解释器实现。
**为什么选择 Miri**：

- **现有基础**：Miri 已经能够运行基本的 Rust 程序，提供了一个良好的基础。
- **可扩展性**：通过在 Miri 中实现堆栈借用模型，作者可以测试大量的实际代码。
##### **实现堆栈借用模型**

**目标**：在 Miri 中实现堆栈借用模型，以测试现有的 Rust 代码，特别是不安全代码，确保模型与实际代码编写方式不冲突。

**实现过程**：

1. **翻译操作规则**：将堆栈借用模型的操作规则翻译为 Rust 代码，以便在程序对内存进行读写时运行。
2. **处理重新标记（retag）**：
- **挑战**：重新标记需要在适当的位置插入，以确保堆栈借用模型的正确性。
- **解决方案**：添加一个新的原始 MIR 语句 `retag`，并实现一个编译器 pass，在构建 MIR 时自动在适当的位置插入 `retag` 语句。
3. **优化存储结构**：
- **问题**：原始的实现会为每个内存位置存储一个借用堆栈，增加了存储和计算开销。
- **解决方案**：对于共享相同堆栈的相邻内存区域，只存储一个堆栈。例如，对于一个从未进行字节级访问的 `i32` 类型的内存，可以只需要一个借用堆栈，而不是 4 个。
- **实现细节**：当相邻位置的堆栈发生分歧或重新统一时，自动拆分和合并这些区域。
**结果**：

- **整合到 Miri 中**：这些更改已经被接受并整合到 Miri 中，因此现在运行 Miri 默认会检查程序是否符合堆栈借用模型。
- **验证优化示例**：特别地，之前在第 15 章和第 16 章中讨论的优化反例（即不符合堆栈借用模型的代码）会被 Miri 适当地标记。
##### **测试和结果**

**测试范围**：

- **Rust 标准库测试套件**：作者在 Miri 中运行了部分 Rust 标准库的测试套件。
- **选择的部分**：由于 Miri 不支持与主机操作系统交互的操作（如网络和文件系统访问），作者没有运行这些部分。
- **测试的内容**：包括关键的数据结构（如 `Vec`、`VecDeque`、`BTreeMap`、`HashMap`）、内部可变性的原语（`Cell`、`RefCell`）、字符串格式化、数组/切片和迭代器组合器等。这些代码涉及大量有趣的不安全代码，使用了大量的原始指针。
**性能**：

- **相对慢速**：Miri 的效率不高，但足以完成测试。
- **性能对比**：与经过优化的编译代码相比，Miri 运行的总慢速约为 1000 倍。与不包含堆栈借用模型检查的 Miri 相比，包含堆栈借用模型的 Miri 慢约 2 倍。
**发现的问题**：

- **总共 7 个不符合堆栈借用模型的不安全代码案例**。
- **具体案例**：**案例一和案例二**：**问题描述**：代码意外地将共享引用转换为了可变引用。**严重性**：这是 Rust 设计者从一开始就明确禁止的模式，没有疑问这些代码是非法的。**处理措施**：及时提交修补程序，修复了这些问题，补丁被迅速接受。**案例三、案例四和案例五**：**问题描述**：代码创建了可变引用，但从未用于访问内存。然而，对于堆栈借用模型，创建可变引用本身就被视为一次写入操作，这可能与现有的指针冲突。**解决方案**：通过调整代码，避免不必要的可变引用，使用更多的原始指针。其中一个案例需要对 `BTreeMap` 进行一些重构，以减少可变引用的使用。**处理措施**：提交了补丁，修复了这些问题，补丁被接受。**启示**：这表明堆栈借用模型的下一个有趣的研究方向是对从未使用的可变引用的唯一性断言进行更少的限制。**案例六**：**问题描述**：类似于前面的案例，但这次仅对 `Vec` 的不安全客户端可见。这些客户端对 `Vec` 做出了文档明确支持的假设，但 `Vec` 内部创建了冲突的可变引用（但未访问），违反了这些假设。**处理措施**：提交了补丁，修复了问题，补丁被接受。**案例七**：**涉及保护者（Protectors）**。**问题描述**：代码在结构体中传递引用，其中一个函数在仍在执行时使这些引用失效，导致具有活跃保护者的堆栈项被弹出。**处理措施**：**调整模型**：作者决定调整堆栈借用模型，以适应这种情况。他们将 `retag` 操作限制为仅作用于“裸露”的引用，而不对复合类型（如结构体）内部的引用进行重新标记。**原因**：当时不清楚该代码是否应该被视为正确，这一选择有助于作者将测试重点放在堆栈借用模型的其他方面。**后续进展**：在完成堆栈借用模型的实现和形式化后，Rust 社区发现了新的证据，表明该代码违反了编译器当前所做的别名假设。**不确定性**：目前尚不清楚是否应该通过更改代码、更改别名分析，或两者兼而有之（并给予程序员更多控制）来修复这一问题。**未来计划**：Miri 将是探索这一权衡的宝贵工具。
**Miri 的使用**：

- **Rust Playground**：Miri 作为 Rust Playground 上的一个“工具”提供，开发者可以直接在浏览器中测试小段代码。地址：[https://play.rust-lang.org/]()
- **社区反馈**：Rust 开发者越来越多地使用 Miri 来检查代码中的未定义行为。如果开发者对结果感到惊讶（例如，他们认为合法的代码违反了堆栈借用模型），他们通常会通过错误报告或社区渠道反馈。**目前为止**：除了上述讨论的案例外，还没有发现任何与堆栈借用模型不兼容的不安全代码模式。
**持续集成和监控**：

- **每日测试**：作者现在每晚在前述的 Rust 测试套件上运行 Miri，持续监控标准库中新的未定义行为和堆栈借用模型违规案例。
- **项目集成**：一些项目（包括 `HashMap`，这是一个单独的库，也作为 Rust 标准库的一部分提供）已经决定将 Miri 纳入其持续集成流程，用于 pull request 的预合并测试。
- **Miri 文档**：包含了一个不断增长的在 Rust 生态系统中发现的错误列表，地址：[https://github.com/rust-lang/miri/#bugs-found-by-miri](https://github.com/rust-lang/miri/#bugs-found-by-miri)
**总体评价**：

- **结论**：作者认为，这一评估证明了堆栈借用模型非常适合 Rust。
- **可能的疑问**：Rust 开发者在混合使用原始指针和可变引用时，会遵循堆栈借用模型所要求的堆栈纪律，这可能看起来令人惊讶。
- **作者的假设**：**原因一**：原始指针当前是未标记的，因此只要可以使用任何原始指针，就可以使用所有原始指针。**原因二**：开发者意识到违反可变引用的唯一性是不允许的，并尽力避免这种情况。
- **进一步目标**：尽管如此，开发者目前并不确切知道他们可以做什么，不能做什么。作者的工作目标是为他们在这方面经常出现的问题提供更清晰的答案。
#### **18.2 Coq 形式化**

##### **背景**

在之前的章节中，作者提供了启发式的证明草图，展示了堆栈借用模型所支持的一些代表性优化。为了进一步增加对模型语义的信心，作者在 Coq 中对其操作规则进行了形式化。

##### **形式化内容**

- **操作规则的形式化**：作者在 Coq 中形式化了堆栈借用模型的操作规则，共计约 6000 行 Coq 代码，包括证明操作语义的一些关键属性。
- **证明草图的机械化**：将之前的证明草图转化为机械化的正确性证明，涵盖了之前章节中提到的所有示例转换。
- **模拟框架**：为了在存在未知代码的情况下推理转换，作者构建了一个基于开放模拟的模拟框架，共计约 5000 行 Coq 代码。**开放模拟（Open Simulations）**：一种用于证明程序等价性的技术，允许在存在未知部分（如未定义函数或外部库）的情况下进行推理。
- **参考资料**：更多详细信息可以参考堆栈借用模型的论文及其技术附录：**论文**：Jung et al., “Stacked Borrows: An aliasing model for Rust”, 2020 [Jun+20a]。**技术附录**：包含了形式化的完整细节。
##### **意义**

- **增加信心**：通过形式化，作者验证了堆栈借用模型的正确性，增强了对模型语义的信心。
- **工具支持**：形式化的模型为未来的工具开发（如验证工具、编译器优化）提供了坚实的理论基础。
**全面总结：**

在 **第十八章：评估** 中，作者通过在 Miri 中实现堆栈借用模型和在 Coq 中形式化模型的操作语义，对堆栈借用模型进行了全面的评估。这一评估验证了堆栈借用模型的实用性、正确性和与实际 Rust 代码的兼容性。

主要内容和结论包括：

1. **在 Miri 中实现堆栈借用模型**：
- **实现目的**：测试现有的 Rust 代码，特别是不安全代码，确保堆栈借用模型与实际编程实践不冲突。
- **实现过程**：翻译操作规则为 Rust 代码。处理重新标记（retag）操作，自动在适当的位置插入 `retag` 语句。优化存储结构，减少借用堆栈的存储开销。
- **测试结果**：运行了 Rust 标准库测试套件的部分内容，发现了 7 个不符合堆栈借用模型的不安全代码案例。修复了这些问题，补丁被接受。这些案例表明，堆栈借用模型与实际的 Rust 代码基本兼容，但在某些情况下需要调整代码或模型。
- **持续集成和社区反馈**：Miri 被集成到 Rust Playground，开发者可以直接在浏览器中测试代码。Rust 社区积极使用 Miri，反馈了相关问题。Miri 被用于持续集成，监控新的未定义行为和堆栈借用模型违规。
- **结论**：评估证明了堆栈借用模型适用于 Rust，尽管开发者可能不完全了解模型的细节，但他们已经在实践中遵循了许多模型的规则。堆栈借用模型可以为他们提供更清晰的指导。
2. **在 Coq 中形式化堆栈借用模型**：
- **形式化内容**：形式化了操作规则，约 6000 行 Coq 代码。将证明草图转化为机械化的正确性证明，涵盖了所有示例转换。构建了基于开放模拟的模拟框架，约 5000 行 Coq 代码。
- **意义**：增加了对模型语义的信心。为未来的工具开发和理论研究提供了坚实的基础。证明了堆栈借用模型在形式化验证方面的可行性。
3. **总体评价和未来工作**：
- **模型的适用性**：堆栈借用模型被证明是适合 Rust 的，可以与现有的代码和编程实践兼容。
- **开发者的需求**：开发者需要更清晰的指导，了解他们可以做什么，不能做什么。堆栈借用模型的形式化和工具支持可以满足这一需求。
- **未来计划**：探索如何在不降低安全性的前提下，使堆栈借用模型对从未使用的可变引用的唯一性断言更少限制，以及解决涉及保护者的复杂问题。
**结论**：

通过在 Miri 中实现堆栈借用模型并在 Coq 中形式化其操作语义，作者对模型进行了全面的评估。这一评估验证了模型的实用性、正确性和与实际 Rust 代码的兼容性，证明了堆栈借用模型是 Rust 的一个良好选择。

Miri 的实现和测试结果显示，尽管开发者可能并不完全了解堆栈借用模型的细节，但他们在实践中已经遵循了许多模型的规则。模型的形式化和工具支持可以为他们提供更清晰的指导，帮助他们编写更安全和高效的代码。

在 Coq 中形式化模型的操作语义，增强了对模型语义的信心，为未来的工具开发和理论研究提供了坚实的基础。基于开放模拟的模拟框架，使得在存在未知代码的情况下进行推理成为可能，进一步证明了模型的可行性和实用性。

总之，堆栈借用模型在实践和理论上都得到了验证，是理解和发展 Rust 编程语言的重要一步。未来的工作将继续完善模型，解决发现的问题，并为开发者提供更好的工具和指导。
 #  
 Thought for 6 seconds
**概览：**

您提供的内容来自论文《理解和发展 Rust 编程语言》（Understanding and Evolving the Rust Programming Language）的 **第十九章：相关工作（Related Work）**。这一章主要讨论了与 **堆栈借用模型（Stacked Borrows）** 密切相关的其他语言的别名分析和语义模型，特别关注了 C 语言的 **严格别名规则（Strict Aliasing Rules）** 和 **restrict 限定符**，以及 Fortran 的别名规则。此外，还探讨了其他对低级语言语义的形式化工作，以及这些工作如何处理指针、别名和指针的来源（provenance）等复杂问题。

具体来说，本章讨论了以下内容：

1. **C 语言的严格别名规则（Strict Aliasing Rules）**：
- 描述了 C 语言中用于支持更好别名分析的严格别名规则，以及这些规则如何允许编译器假设不同类型的指针不会别名。
- 讨论了 C 标准对严格别名规则的描述方式，以及这些规则在实际应用中的模糊性，特别是在与联合（union）交互时的不明确性。
- 回顾了 CompCert 项目对 C 语言内存模型的形式化工作，以及其他研究者对严格别名规则的操作性解释。
- 提到了实际编译器（如 GCC 和 Clang）在利用严格别名规则进行优化时遇到的长期编译器错误，以及实际代码违反严格别名规则的普遍性。
2. **C 语言的 restrict 限定符**：
- 介绍了 C99 中引入的 restrict 限定符，它允许程序员向编译器提供非别名的信息，以支持更好的优化。
- 讨论了 restrict 与堆栈借用模型在概念上的密切关系，以及它们在编译器优化中的应用。
- 探讨了 noalias（LLVM 中的 restrict 等价物）的语义不明确性，以及它在实际应用中的问题，包括 LLVM 中的相关错误。
3. **Fortran 的别名规则**：
- 提到了 Fortran 语言的别名规则，该规则不允许函数参数别名，除非程序员特别标记它们可能别名。
- 讨论了 Fortran 中别名规则的工具支持和动态检查。
4. **低级语言语义的形式化**：
- 综述了对 C 和 LLVM 等低级语言的语义进行形式化的大量工作，特别关注了它们如何处理指针和指针的来源。
- 指出这些工作通常没有考虑严格别名规则和 restrict 限定符，而是专注于其他复杂问题，如整数和指针之间的类型转换，以及防止指针算术跨越对象边界等。
通过这些讨论，作者展示了堆栈借用模型在 Rust 中的独特性，以及它如何在别名分析和编译器优化方面提供更强的支持。同时，也强调了其他语言在处理别名和指针方面的挑战，以及现有模型和工具在实践中遇到的问题。

**详细解读：**

### **第十九章：相关工作**

在这一章中，作者深入探讨了与堆栈借用模型相关的其他语言和研究工作。堆栈借用模型旨在为 Rust 提供更强大的别名分析支持，以实现更有效的编译器优化。为此，作者对比了 C 和 Fortran 等语言的别名规则，以及学术界对低级语言语义的形式化研究。

#### **1. C 语言的严格别名规则（Strict Aliasing Rules）**

##### **1.1 概述**

**严格别名规则**是 C 语言中用于支持更好别名分析的一组规则。总体而言，这些规则允许编译器假设 **不同类型的指针不会别名**。每个内存对象都有一个特定的 **有效类型（effective type）**，编译器利用这一点来排除通过不同类型的指针进行的（大部分）访问。这通常被称为 **基于类型的别名分析（Type-Based Alias Analysis，TBAA）**。

##### **1.2 C 标准的描述方式**

C 标准（ISO/IEC 9899:2018）以公理化的方式描述了严格别名规则。然而，特别是在严格别名规则与联合（`union`）的交互方面，标准并不十分清晰。在某些情况下，C 标准允许通过联合进行 **类型规避（type-punning）**，即使用“错误”类型的读取操作有时是允许的，但具体细节仍然模糊。

例如，标准提到通过联合进行类型规避的读取在某些条件下是允许的，包括“联合的已完成类型的声明是可见的”（§6.5.2.3 第6段）。然而，这到底意味着什么并不明确。

##### **1.3 CompCert 对 C 内存模型的形式化**

**CompCert** 是一个经过形式化验证的 C 编译器项目。在其早期版本中，CompCert 的内存模型对严格别名规则给出了一个非常强的操作性版本，完全不允许通过联合进行类型规避。然而，这并未用于程序分析或转换的目的。后来版本的 CompCert 转向了一个更简单的内存模型，不再强制执行严格别名规则。

CompCert 还包括一个经过形式化验证的别名分析，但该分析并未利用语言提供的额外别名信息。

##### **1.4 Krebbers 的操作性解释**

**Krebbers** 提供了严格别名规则的另一个操作性解释，他基于 GCC 开发者对 C 标准的解释，给出了通过联合进行类型规避的规则。他还展示了一个基本的非别名“健全性”定理，但未涉及编译器转换。

##### **1.5 编译器中的实际问题**

在实际编译器（如 GCC 和 Clang）中，长期存在利用严格别名规则进行优化而导致的编译器错误。这表明利用严格别名规则进行优化是棘手的，容易导致错误编译。

一个问题是 C 确实允许（或者至少标准并未禁止）更改有效类型的写入操作，这与编译器执行的分析不一致。此外，许多现实世界的 C 习惯用法违反了严格别名规则，许多程序员认为严格别名规则过于严格。因此，许多大型项目，包括 Linux 内核，直接禁用基于类型的别名分析，实质上选择了一个具有更少未定义行为和更少优化的 C 版本。

##### **1.6 严格别名规则的局限性**

此外，基于类型的别名分析相对较弱。特别是，它不能用于推理未知代码；编译器必须知道涉及的内存访问的类型才能确定它们是否可能别名。相比之下，堆栈借用模型允许对未知代码进行推理，支持更强大的优化。

##### **1.7 其他形式化工作**

**Hathhorn、Ellison 和 Rosu** 在他们的 K 框架中形式化了 C，包括严格别名规则。由于 K 形式化是可执行的，这也提供了一种通过模型检查真实代码的方法。然而，论文并未详细说明严格别名规则是如何定义的，作者如何解决上述开放问题，以及他们的选择是否与现实世界的 C 代码和编译器兼容。此外，没有定理表明他们的模型允许这些规则所激励的程序转换。

另一个用于检测严格别名规则违规的工具是 **libcrunch**，但它既不健全也不完整。

#### **2. C 语言的 restrict 限定符**

##### **2.1 概述**

自 C99 起，C 语言支持在指针类型上添加 `restrict` 限定符，这是程序员可以用来向编译器提供非别名信息的显式注解。这个限定符表示通过该指针及其派生指针执行的访问不能与其他访问别名。

一个常见的应用是紧密的数值循环，例如矩阵乘法，假设输出矩阵不与任何输入矩阵别名，可以使循环完全矢量化，使用 SIMD（单指令多数据）操作，而非纯标量（非矢量化）代码。

##### **2.2 与堆栈借用模型的关系**

在概念上，`restrict` 与堆栈借用模型密切相关。实际上，Rust 编译器（使用 LLVM 作为后端）旨在为函数参数位置的引用发出 `noalias` 注解，这是 LLVM 中的 `restrict` 等价物。LLVM 认为，当两个指针的访问不冲突时，它们不别名（即，当它们的所有访问可以相互重新排序时）；这意味着即使内存范围重叠，两个只读指针也永远不会“别名”。Rust 利用这一点，即使在存在 `UnsafeCell` 的情况下，也为共享引用发出 `noalias`。

##### **2.3 noalias 和 restrict 的语义不明确性**

然而，`noalias` 和 `restrict` 的确切语义并不清晰，特别是在考虑一般指针而不仅仅是函数参数时。即使对于函数参数，不确定性也导致了多个 LLVM 错误。因此，Rust 目前不为可变引用发出 `noalias` 注解（然而，它们仍然为不含内部可变性的共享引用发出）。

##### **2.4 形式化工作**

前面提到的在 K 框架中对 C 的形式化也包括了一些关于 `restrict` 的语义，以及检查程序符合性的方式。然而，与严格别名规则类似，如何将公理化、非形式的标准解释为形式化的操作语义，论文中并未涉及。

例如，标准以是否修改对象以指向其他地方会改变表达式的值来定义指针表达式是否“基于”一个对象。这一定义在考虑控制流可能因修改对象而改变的情况下相当有问题。因此，K 形式化依赖于使用类似于堆栈借用模型的“标签”来跟踪指针的来源。但是，这种对标准的解释反映了其意图的程度，以及它与程序员和编译器对标准的理解有多一致，仍然不清楚，论文也未讨论。

#### **3. Fortran 的别名规则**

##### **3.1 概述**

与 C 的 `restrict` 类似，Fortran 的别名规则不允许函数参数别名，除非程序员特别标记它们可能别名。事实上，与 Fortran 编译器竞争是将 `restrict` 添加到 C 的主要动机之一。

##### **3.2 工具支持**

**Nguyen 和 Irigoin** 描述了一个在 Fortran 程序中动态检查别名违规的工具，但他们并未验证任何程序转换。

#### **4. 低级语言语义的形式化**

##### **4.1 概述**

有大量工作致力于形式化 C 或 LLVM（作为高度优化的“低级”语言的代表）的语义，特别是它们对指针和指针来源的处理。然而，除了前面提到的内容之外，这些工作并未涉及严格别名规则和 `restrict` 限定符。相反，它们专注于独立的复杂问题，例如整数和指针之间的类型转换，以及使用指针来源防止指针算术跨越对象边界。

##### **4.2 与堆栈借用模型的关系**

我们专门设计了堆栈借用模型，不假设所有指针都有已知的来源（provenance），通过添加“未标记”的指针的概念。这意味着我们基本上可以采用任何现有的整数和指针转换的模型，并为其配备处理未知来源指针（作为未标记指针）的堆栈借用模型变体。

**全面总结：**

在 **第十九章：相关工作** 中，作者详细探讨了与 **堆栈借用模型（Stacked Borrows）** 密切相关的其他语言的别名分析和语义模型，特别关注了 C 语言的 **严格别名规则（Strict Aliasing Rules）** 和 **restrict 限定符**，以及 Fortran 的别名规则。通过对这些语言特性的深入分析，作者展示了堆栈借用模型在处理别名和指针方面的独特性和优势。

主要内容和结论包括：

1. **C 语言的严格别名规则的局限性**：
- **定义模糊**：C 标准以公理化的方式描述了严格别名规则，但在实际应用中存在模糊性，特别是在与联合（union）交互时。
- **编译器实现问题**：实际编译器在利用严格别名规则进行优化时遇到了长期的编译器错误，表明这些规则难以正确实现。
- **程序员实践**：许多现实世界的 C 代码违反了严格别名规则，程序员认为这些规则过于严格，因此许多大型项目禁用了基于类型的别名分析。
- **别名分析的弱点**：基于类型的别名分析相对较弱，无法用于推理未知代码，编译器必须知道所有涉及的内存访问的类型才能确定它们是否可能别名。
2. **C 语言的 restrict 限定符的挑战**：
- **语义不明确**：restrict 的确切语义不清晰，特别是在考虑一般指针而不仅仅是函数参数时。
- **编译器错误**：对于函数参数，语义的不确定性导致了 LLVM 中的多个错误。
- **模型与实现的差距**：形式化工作未能明确解释 restrict 的语义，无法确定其与标准的意图以及程序员和编译器的理解是否一致。
3. **Fortran 别名规则的简要讨论**：
- **类似性**：Fortran 的别名规则与 C 的 restrict 类似，不允许函数参数别名，除非程序员特别标记。
- **工具支持有限**：虽然存在工具可以动态检查别名违规，但缺乏对程序转换的验证。
4. **低级语言语义形式化的局限性**：
- **关注点不同**：大量对 C 和 LLVM 的形式化工作主要关注指针和指针来源的处理，如整数和指针之间的类型转换，防止指针算术跨越对象边界等。
- **缺乏对别名规则的考虑**：这些工作通常未考虑严格别名规则和 restrict 限定符。
5. **堆栈借用模型的独特性和优势**：
- **更强的别名分析**：堆栈借用模型允许对未知代码进行推理，支持更强大的编译器优化。
- **不依赖指针来源**：通过引入“未标记”的指针，堆栈借用模型不假设所有指针都有已知的来源，增强了模型的灵活性。
- **与现有模型的兼容性**：堆栈借用模型可以与现有的整数和指针转换模型相结合，处理未知来源的指针。
**结论**：

通过对 C 和 Fortran 等语言的别名规则以及学术界对低级语言语义的形式化工作的深入分析，作者在 **第十九章** 中强调了堆栈借用模型在处理别名和指针方面的独特性和优势。堆栈借用模型不仅提供了更强大的别名分析支持，允许编译器对未知代码进行优化，而且通过引入“未标记”的指针，增强了模型的灵活性，不依赖于指针的已知来源。

相比之下，C 语言的严格别名规则和 `restrict` 限定符在实际应用中存在模糊性和实现困难，编译器在利用这些规则进行优化时容易出现错误。许多程序员认为这些规则过于严格，导致许多大型项目禁用了相关的别名分析。对于 Fortran，虽然别名规则相对明确，但缺乏对程序转换的验证和工具支持。

在低级语言语义的形式化工作中，虽然对指针和指针来源的处理有大量研究，但通常未考虑严格别名规则和 `restrict` 限定符。堆栈借用模型填补了这一空白，提供了一个更强大、更灵活的模型来处理别名和指针。

总体而言，堆栈借用模型在 Rust 中的应用展示了它在别名分析和编译器优化方面的巨大潜力。通过与其他语言的对比，作者证明了堆栈借用模型在处理别名和指针方面的独特性和优势，为编译器优化和程序验证提供了坚实的基础。这一模型有助于提高程序的安全性和性能，促进了 Rust 编程语言的发展和理解。
 #  
 Thought for 9 seconds
**概览：**

您提供的内容是论文《理解和发展 Rust 编程语言》（Understanding and Evolving the Rust Programming Language）的 **第二十章：结论（Conclusion）**，以及 **20.1 节：未来工作（Future Work）**。这一章总结了整篇论文的主要目标、所取得的成果，以及未来可能的研究方向。

主要内容包括：

1. **论文的主要目标和贡献：**
- 证明像 Rust 这样复杂的现实世界编程语言可以被形式化理解，并且可以在机器验证的证明助手（如 Coq）中证明有意义的定理。
- 展示了形式方法如何促进 Rust 的发展，帮助设计者完善规范的细节。
2. **三大主要工作：**
- **Iris：** 一个用于构建高阶并发分离逻辑的框架，强调从低级原语推导自定义推理原则。
- **RustBelt：** 包含一个核心语言演算 $\lambda_{\text{Rust}}$，以及一些包含不安全代码的关键 Rust 库的形式化模型和安全证明。
- **堆栈借用模型（Stacked Borrows）：** 为 Rust 的引用类型提供精确的别名规则，旨在启用更多基于类型的优化，帮助语言演化。
3. **对社区和语言发展的影响：**
- **Iris：** 成为多个研究项目和论文的基础，社区使用不断增长。
- **RustBelt：** 帮助发现并修复了 Rust 标准库中的错误，影响了 Rust 中新特性的引入，如 “固定”（Pinning）机制。
- **堆栈借用模型：** 与 Rust 语言团队密切合作，尽管还不是官方的别名模型，但已成为讨论别名问题时的事实标准。
4. **未来的研究方向：**
- **Iris 的扩展：** 包括线性逻辑的支持、对活性的推理、更一般化的权威资源代数等。
- **RustBelt 的扩展：** 验证更多使用不安全代码的库，支持更多 Rust 类型系统特性，如非词法生命周期（NLL）、trait（特征）等。
- **堆栈借用模型的改进：** 更好地匹配现实中的不安全代码模式，处理并发情形，将其与 RustBelt 结合等。
通过这些讨论，作者总结了论文的主要成果，并为未来的研究工作提供了展望。

**详细解读：**

### **第二十章：结论**

#### **主要目标**

论文的主要目标是证明像 Rust 这样复杂的现实世界编程语言可以被 **形式化地理解**，并且可以在 **机器验证的证明助手**（如 Coq）中证明有意义的定理。此外，作者还展示了形式方法如何促进 Rust 的发展，帮助设计者完善规范的细节。

#### **三大主要工作**

为支持这一主张，作者介绍了三个主要的工作：Iris、RustBelt 和堆栈借用模型（Stacked Borrows）。

##### **1. Iris**

- **简介**：Iris 是一个用于构建 **高阶并发分离逻辑** 的框架，重点是从低级原语推导自定义的推理原则。
- **作用**：Iris 构成了陈述和证明 RustBelt 定理的基础，并在 Coq 中实现。
- **普适性**：Iris 并非特定于 RustBelt，实际上已经被越来越多的项目使用，相关的论文数量在迅速增长。
- **社区影响**：Iris 作为一个开源项目，参与讨论和提交改进的人数不断增加，定期在 POPL 等顶级会议上举办教程，教授人们如何使用该逻辑。
##### **2. RustBelt**

- **组成**：RustBelt 包含一个核心语言演算 $\lambda_{\text{Rust}}$，以及一些关键 Rust 库（包含不安全代码）的形式化模型和安全证明。
- **功能**：$\lambda_{\text{Rust}}$ 模型了 Rust 类型系统的一些关键方面：所有权、借用和生命周期。
- **安全证明**：通过在 Iris 中构建的语义模型（或逻辑关系）来进行安全证明，引入了 **生命周期逻辑**，为分离逻辑提供了借用和关联生命周期的概念。
- **意义**：这是首次能够验证使用不安全代码实现的 Rust 库，确保其公共 API 能够健全地封装不安全性。
- **实际影响**：帮助发现并修复了 Rust 标准库中的错误，影响了 Rust 新特性的引入，如 **固定（Pinning）** 机制。
- **与社区互动**：当 Rust 团队扩展经过 RustBelt 验证的类型的 API 时，他们有时会推迟新 API 的稳定化，直到相应的健全性证明被扩展。
##### **3. 堆栈借用模型（Stacked Borrows）**

- **目的**：不是描述现有的 Rust，而是通过为 Rust 的引用类型提供一些精确的 **别名规则**，帮助语言演化，启用更多基于类型的优化。
- **与 Rust 语言团队的合作**：他们谨慎地在编译器中引入更激进的优化，直到更好地理解不安全代码的允许和禁止内容。
- **地位**：堆栈借用模型目前还不是 Rust 的官方别名模型，但它是目前最具体的提案，因此在讨论别名问题时，堆栈借用模型被用作事实标准。
- **未来计划**：继续与 Rust 社区和开发团队合作，调整堆栈借用模型以满足他们的需求，最终将堆栈借用模型的某个变体纳入 Rust 的官方语义。
#### **对社区和语言发展的影响**

- **Iris** 已成为多个研究项目的基础，社区对其关注度和使用量不断增长。
- **RustBelt** 不仅提供了对 Rust 类型系统结构的关键见解，还帮助发现并修复了 Rust 标准库中的错误。讨论可能的形式化模型在 Rust 新特性的引入（如 Pinning）中也发挥了作用。
- **堆栈借用模型** 与 Rust 语言团队密切合作，尽管还不是官方的别名模型，但已成为讨论别名问题时的事实标准。
### **20.1 未来工作**

作者指出，每当一个科学问题得到解答时，至少会出现两个新的问题。因此，在本论文的成果基础上，有许多未来的研究方向值得探索。

#### **Iris 的未来扩展**

1. **线性逻辑的支持**：
- **背景**：线性逻辑允许对资源的精确控制，特别是资源的消费和生产。
- **现状**：Iris 当前对线性逻辑的支持有限。
- **研究方向**：通过将 Iris 的资源代数（resource algebras，RAs）推广为 **有序资源代数（ordered resource algebras，oRA）**，可以更直接地支持线性逻辑。
- **挑战**：需要重新定义 Iris 断言必须封闭的关系，以及帧保持更新（frame-preserving updates）的正确概念。
2. **对活性的推理（Liveness）**：
- **背景**：活性是指某些好事情最终会发生的属性。在并发程序中，对活性的推理非常重要。
- **挑战**：在基于步数索引（step-indexed）的逻辑中，对活性的推理 notoriously 困难，因为步数索引限制了逻辑只能涉及有限长度的执行轨迹。
- **研究方向**：**跨有限步数索引**：将步数索引从自然数扩展到（可能是无限的）序数，称为 **跨有限步数索引（transfinite step-indexing）**。**避免步数索引**：探索在不使用步数索引的情况下，Iris 能够支持多少特性。
3. **一般化权威资源代数（Authoritative RA）的进一步推广**：
- **背景**：权威 RA 在 Iris 中用于建模共享状态。
- **研究方向**：进一步推广权威 RA，以支持 **Views** 风格的抽象函数或关系，从而简化证明，使其更普遍适用。
#### **RustBelt 的未来工作**

1. **验证更多使用不安全代码的库**：
- **示例**：**Pin**：用于防止数据在内存中移动，使其他数据结构可以安全地指向它，而无需借用。**基于生成性（generativity）的生命周期**：例如，使用生命周期的生成性实现 **安全的未检查索引**。
2. **支持更多 Rust 类型系统特性**：
- **非词法生命周期（Non-Lexical Lifetimes，NLL）**：**现状**：$\lambda_{\text{Rust}}$ 可以很好地处理 NLL 的许多情况，但仍存在与 Rust 编译器之间的差距。**挑战**：$\lambda_{\text{Rust}}$ 不支持 **两阶段借用（two-phase borrows）**，这是一种特殊的可变借用变体，借用在某段时间内实际上是共享的（只读），然后才变为真正的可变借用。**研究方向**：探索如何在 $\lambda_{\text{Rust}}$ 中支持这些特性，或者将 Rust 编译器的实际分析与 $\lambda_{\text{Rust}}$ 联系起来。
- **Traits（特征）**：**背景**：Rust 的 traits 类似于 Haskell 的类型类，Rust 依赖于 **特征的一致性（coherence）**，即对于给定的特征和类型，不能有多个实现。**挑战**：当前的特征系统存在一些棘手的边缘情况，可能违反一致性。最近还发现了一个与不安全代码和特征系统交互相关的健全性错误。**研究方向**：在 RustBelt 中引入对 traits 的支持，完整地证明像 Pin 这样的类型的健全性。
3. **探索语言的其他未建模方面**：
- **析构函数检查器（Drop Checker）**：确保即使数据结构包含指针循环，析构函数也能被正确执行。
- **恐慌（Panic）**：类似于异常的机制，Rust 方法可以异常返回，但仍通过自动析构函数正确管理资源。
4. **改进生命周期逻辑**：
- **问题**：虽然生命周期逻辑足够强大，可以捕获复杂的借用模式，但在使用时经常相当繁琐，需要不断跟踪生命周期令牌的份额，并显式打开和关闭生命周期包含访问器。
- **研究方向**：采用针对临时只读权限的提议方法，引入可复制的“只读”模态，简化证明过程。
#### **堆栈借用模型的未来工作**

1. **更好地匹配现实中的不安全代码模式**：
- **问题**：评估中发现了两个常见的堆栈借用模型违规模式：创建但不使用的冲突可变引用，以及受保护者保护的私有字段中的引用。
- **研究方向**：引入 **基于树的结构**，可能有助于解决可变引用的问题，但需要研究这对编译器优化的影响。
2. **支持两阶段借用**：
- **现状**：堆栈借用模型目前缺乏对两阶段借用的良好支持，在 Miri 中将它们视为可自由别名的，因此失去了对这些引用的优化。
- **研究方向**：利用基于树的结构，允许对两阶段借用进行适当的优化。
3. **改进保护者的设计**：
- **问题**：目前，保护者的作用域与函数调用绑定，在内联时会丢失。
- **研究方向**：引入更显式的作用域表示，帮助保留这些信息。这与 LLVM 中最近提出的改进内联和作用域 `noalias` 注解交互的建议密切相关。
4. **处理并发情形**：
- **现状**：堆栈借用模型的形式化版本是在顺序语言的上下文中进行的。
- **研究方向**：扩展模型和相应的证明以考虑并发。预期方法可以扩展到并发，只要所有的竞争条件都发生在具有 `SharedRW` 权限的指针上。
5. **与 RustBelt 结合**：
- **目标**：将堆栈借用模型与 RustBelt 结合，证明 $\lambda_{\text{Rust}}$ 的类型安全性和库正确性证明在更严格的操作语义下仍然成立。
- **意义**：如果还能将 $\lambda_{\text{Rust}}$ 类型系统与 Polonius 联系起来，就可以通过形式化验证，证明所有被 Rust 编译器接受的安全代码都符合堆栈借用模型。
**全面总结：**

在 **第二十章：结论** 中，作者总结了论文的主要目标、取得的成果，以及未来的研究方向。

1. **主要目标和贡献**：
- **形式化理解 Rust**：证明了像 Rust 这样复杂的现实世界编程语言可以被形式化理解，并且可以在机器验证的证明助手中证明有意义的定理。
- **促进语言发展**：展示了形式方法如何促进 Rust 的发展，帮助设计者完善规范的细节。
2. **三大主要工作**：
- **Iris**：提供了一个强大的框架，用于构建高阶并发分离逻辑，成为 RustBelt 等多个项目的基础，社区使用不断增长。
- **RustBelt**：通过引入生命周期逻辑，首次能够验证使用不安全代码实现的 Rust 库，确保公共 API 能够健全地封装不安全性，帮助发现并修复了 Rust 标准库中的错误，对 Rust 新特性的引入产生了影响。
- **堆栈借用模型**：为 Rust 的引用类型提供精确的别名规则，帮助语言演化，启用更多基于类型的优化，与 Rust 语言团队密切合作，尽管还不是官方的别名模型，但已成为讨论别名问题时的事实标准。
3. **未来研究方向**：
- **Iris 的扩展**：包括线性逻辑的支持、对活性的推理、更一般化的权威资源代数等。
- **RustBelt 的扩展**：验证更多使用不安全代码的库，支持更多 Rust 类型系统特性，如非词法生命周期、traits 等，探索语言的其他未建模方面，改进生命周期逻辑。
- **堆栈借用模型的改进**：更好地匹配现实中的不安全代码模式，支持两阶段借用，改进保护者的设计，处理并发情形，将其与 RustBelt 结合等。
**结论**：

通过本文的工作，作者证明了形式方法在理解和发展像 Rust 这样复杂的现实世界编程语言中的重要作用。Iris 提供了构建高阶并发分离逻辑的基础，RustBelt 首次验证了使用不安全代码实现的 Rust 库的健全性，堆栈借用模型为 Rust 的引用类型提供了精确的别名规则，帮助语言演化。

这些工作不仅在学术界取得了重要成果，也对 Rust 社区和语言的发展产生了实际影响，帮助发现并修复了标准库中的错误，影响了新特性的引入。

未来的研究工作包括扩展 Iris，以支持线性逻辑和活性推理，改进权威资源代数；扩展 RustBelt，以验证更多的库，支持更多的语言特性，改进生命周期逻辑；改进堆栈借用模型，以更好地匹配现实中的不安全代码模式，支持两阶段借用，处理并发情形，将其与 RustBelt 结合。

通过这些努力，作者希望进一步完善对 Rust 的形式化理解，为语言的发展和程序员的实践提供坚实的理论基础，促进编程语言和形式方法领域的进步。
 #  
 Thought for 9 seconds
**概览：**

您提供的内容是论文《理解和发展 Rust 编程语言》（Understanding and Evolving the Rust Programming Language）的 **参考文献（Bibliography）** 部分。这一部分列出了作者在论文中引用的所有学术文献、技术报告、博文、在线资源等。参考文献的范围广泛，涵盖了编程语言理论、类型系统、形式化验证、并发分离逻辑、Rust 编程语言的设计与实现等多个领域。

具体来说，这些参考文献包括：

- **形式化验证和逻辑**：大量关于 **分离逻辑（Separation Logic）**、**高阶逻辑**、**类型系统**、**逻辑关系** 等方面的研究论文，这些理论工具是作者在形式化 Rust 编程语言时的重要基础。
- **Rust 编程语言相关**：涉及 Rust 的设计、实现、类型系统、借用检查器、并发模型等方面的文献，包括官方的 RFC、博客文章、论坛讨论等。这些资源帮助作者理解 Rust 的细节和演化过程。
- **编程语言理论**：关于 **线性类型（Linear Types）**、**所有权模型（Ownership Models）**、**类型安全性（Type Soundness）**、**并发编程** 等方面的经典论文，为论文的理论基础提供支持。
- **其他编程语言的相关研究**：包括对 **C、C++、Cyclone、Fortran** 等语言的内存模型、类型系统、安全性等方面的研究，帮助作者在对比中理解 Rust 的独特性。
- **工具和框架**：涉及 **Iris**、**Coq** 等形式化验证工具和框架的论文和文档，这些工具在作者的研究中被广泛使用。
- **实际应用和案例研究**：一些关于如何在实际项目中应用形式化方法、验证实际系统的论文，为作者的研究提供了实践经验。
通过参考这些文献，作者在论文中建立了坚实的理论和实践基础，支持了对 Rust 编程语言的形式化理解和演化。

**详细解读：**

### **参考文献的组成**

这份参考文献包含了多种类型的资源，包括：

1. **学术论文和会议论文**：主要来自于顶级编程语言和计算机科学会议，如 POPL（Programming Language Design and Implementation）、PLDI（Programming Language Design and Implementation）、ICFP（International Conference on Functional Programming）、ESOP（European Symposium on Programming）等。这些论文提供了最新的研究成果和理论发展。
2. **技术报告和学位论文**：包括博士论文、硕士论文和技术报告，这些文献通常包含了深入的研究和详细的证明，是理解某个领域的深入资源。
3. **书籍**：一些经典的编程语言理论书籍，如 Robert Harper 的《编程语言的实用基础（Practical Foundations for Programming Languages）》等，为理论研究提供了全面的背景知识。
4. **博客文章和在线资源**：一些专家的博客文章、论坛讨论和在线文档，这些资源通常提供了对某个技术问题的深入解释和最新进展。
5. **标准文档和规范**：如 ISO C 标准、C++ 标准等，为语言的正式定义和规范提供了权威参考。
6. **软件和工具的文档**：如 Coq 证明助手的官方文档、Iris 框架的文档等，为实际使用这些工具提供了指导。
### **主要主题和内容**

参考文献涵盖了多个与论文主题密切相关的领域：

#### **1. 分离逻辑和形式化验证**

- **分离逻辑（Separation Logic）**：大量论文讨论了分离逻辑的发展、扩展和应用，包括并发分离逻辑、高阶分离逻辑、临时读权限等。这些研究为作者在形式化验证 Rust 的类型系统和内存模型时提供了关键的理论工具。
- **Iris 框架**：Iris 是一个用于构建高阶并发分离逻辑的框架，作者在论文中大量使用了 Iris 来建立和验证他们的模型。参考文献中包含了 Iris 的基础论文、最新发展和使用文档。
- **逻辑关系和类型系统**：一些论文讨论了逻辑关系、类型系统的健全性、类型和效果系统等，为理解和证明 Rust 类型系统的性质提供了理论支持。
#### **2. Rust 编程语言**

- **Rust 的设计和实现**：包括 Rust 官方团队的博客文章、RFC（Request for Comments）文档，讨论了 Rust 的设计理念、新特性的引入（如非词法生命周期、两阶段借用等）。
- **Rust 的类型系统和借用检查器**：深入讨论了 Rust 的所有权模型、借用检查器的工作原理、生命周期等，这是理解 Rust 安全性和内存模型的关键。
- **Rust 与形式化验证**：一些论文和报告尝试将形式化验证方法应用于 Rust，包括使用 Coq 进行验证、构建 Rust 的形式化语义等。
#### **3. 其他编程语言和比较**

- **C 和 C++ 的内存模型**：讨论了 C 和 C++ 的内存模型、未定义行为、指针别名分析等，为对比 Rust 的内存安全性提供了背景。
- **Cyclone 等安全语言的研究**：Cyclone 是一种基于 C 的安全语言，研究它的内存管理、类型系统等有助于理解 Rust 的设计选择。
- **Fortran 的别名规则**：了解其他语言如何处理指针和别名，有助于对比和理解 Rust 的别名规则和堆栈借用模型。
#### **4. 编程语言理论和类型系统**

- **线性类型和所有权模型**：如 Wadler 的《线性类型可以改变世界！》等论文，讨论了线性类型的概念，这是 Rust 所有权模型的理论基础。
- **类型安全性和逻辑关系**：经典的类型安全性证明、逻辑关系等论文，为作者在证明 Rust 类型系统的健全性时提供了方法论支持。
- **并发和同步原语**：一些论文讨论了并发编程、同步原语的验证方法，这对于理解 Rust 中的并发模型和安全性至关重要。
#### **5. 工具和框架**

- **Coq 证明助手**：Coq 是用于形式化验证的工具，作者在论文中使用 Coq 来实现和验证他们的模型。参考文献中包含了 Coq 的官方文档和相关论文。
- **Iris 框架**：如前所述，Iris 是作者在论文中大量使用的逻辑框架，参考文献中包含了其基础和扩展论文。
#### **6. 实际应用和案例研究**

- **文件系统的验证**：如 Amani 等人的《Cogent: 验证高可信文件系统的实现》，展示了如何将形式化方法应用于实际系统的验证。
- **其他实际系统的验证**：一些论文讨论了如何验证并发数据结构、分布式系统等，为作者的研究提供了实践经验和参考。
### **参考文献的重要性**

这些参考文献为作者的研究提供了全面的理论和实践支持：

- **理论基础**：编程语言理论、类型系统、逻辑关系等方面的研究，为作者构建形式化模型和证明提供了基础。
- **方法论支持**：分离逻辑、并发验证方法等，为作者设计验证方法和逻辑框架提供了指导。
- **实践经验**：实际系统的验证案例、工具的使用经验，为作者在实践中应用形式化方法提供了借鉴。
- **对比和启发**：其他语言的研究和问题，帮助作者更好地理解 Rust 的设计选择，识别其优势和需要改进的地方。
### **参考文献的组织方式**

参考文献按照作者姓氏的字母顺序排列，每条参考文献包括：

- **作者**：列出了所有作者的姓名，方便读者识别和检索。
- **标题**：给出了论文、报告、书籍等的标题，明确了文献的主题。
- **出版信息**：包括会议名称、卷号、页码、出版年份等，提供了文献的详细出处。
- **数字对象标识符（DOI）**：许多参考文献包含 DOI，方便读者在线访问原文。
- **网址**：对于在线资源，提供了直接的访问链接。
**全面总结：**

在这份论文的 **参考文献** 部分，作者精心收集并引用了大量与其研究主题密切相关的文献资源。这些参考文献涵盖了编程语言理论、形式化验证、类型系统、分离逻辑、并发编程、Rust 编程语言的设计与实现等多个领域。

通过这些文献，作者得以：

1. **构建坚实的理论基础**：深入理解编程语言的核心概念，如所有权模型、类型系统、逻辑关系等，为形式化 Rust 编程语言提供了必要的理论支撑。
2. **设计和应用先进的方法**：利用分离逻辑、Iris 框架等先进的形式化验证方法，作者能够有效地构建和验证他们的模型。
3. **理解 Rust 的独特性**：通过对比其他编程语言（如 C、C++、Cyclone、Fortran）的研究，作者深入理解了 Rust 的设计选择、优势和挑战。
4. **解决实际问题**：借鉴实际系统验证的经验，作者在实践中应用形式化方法，验证了 Rust 中关键库和特性的健全性。
5. **推动社区发展**：通过引用和讨论 Rust 社区的资源（如官方博客、RFC、论坛讨论），作者与社区保持了紧密联系，确保他们的研究与实际需求相契合。
6. **识别未来研究方向**：参考文献中包含的最新研究和未解决的问题，帮助作者识别了未来可能的研究方向，为进一步的发展奠定了基础。
总的来说，这份参考文献体现了作者在研究过程中对前人工作的深入理解和尊重。他们不仅借鉴了大量的理论和方法，还积极参与了社区的讨论和实践。这使得他们的研究既有坚实的理论基础，又有实际的应用价值。

对于读者来说，这份参考文献也是一个宝贵的资源。通过阅读这些文献，读者可以深入了解编程语言理论和形式化验证领域的最新进展，加深对 Rust 编程语言的理解，甚至找到自己感兴趣的研究方向。

**结论**：

论文《理解和发展 Rust 编程语言》的参考文献部分，充分展示了作者在研究过程中对相关领域的全面了解和深入思考。通过精心选择和引用这些文献，作者构建了一个全面而深入的知识体系，支持了他们在论文中提出的观点和结论。

这些参考文献不仅为作者的研究提供了支持，也为读者提供了进一步学习和探索的方向。对于那些希望深入了解 Rust 编程语言、形式化验证、类型系统和编程语言理论的读者来说，这份参考文献是一个不可多得的宝贵资源。

通过对参考文献的分析和总结，我们可以看到作者的研究是建立在坚实的理论和实践基础之上的。他们不仅充分利用了已有的研究成果，还通过自己的工作推动了领域的发展，为未来的研究开辟了新的道路。


### Well-formed paths 详解：

图中展示了路径（paths）的良构性判断规则，主要包含以下两条规则：

#### 1. **变量路径规则（Path for Variables）**
$$
\frac{x : val \in \Gamma}{\Gamma \vdash_{wf} x}
$$
**解释**：如果变量 $x$ 是上下文 $\Gamma$ 中的一个值 ($x : val \in \Gamma$)，则可以判断 $x$ 是一个良构路径 ($\Gamma \vdash_{wf} x$)。这意味着变量路径是良构的，如果它在上下文中存在，并且是一个值类型。

#### 2. **选择器路径规则（Path for Selectors）**
$$
\frac{\Gamma \vdash_{wf} p}{\Gamma \vdash_{wf} p.n}
$$
**解释**：如果路径 $p$ 是良构的路径 ($\Gamma \vdash_{wf} p$)，则路径 $p.n$ 也是一个良构路径 ($\Gamma \vdash_{wf} p.n$)。这里，$n$ 是 $p$ 的一个字段或方法调用，良构性继承自 $p$ 的良构性。

### 总结：

- **变量路径规则**：如果变量在上下文中是一个值类型，则它是良构路径。
- **选择器路径规则**：如果路径 $p$ 是良构路径，那么对 $p$ 进行字段选择或方法调用也是良构路径。

这两个规则定义了如何从基本的良构变量逐步构建更复杂的良构路径，确保路径的语法和语义都保持正确。

### --------------------

### Well-formed lifetimes 详解：

图中展示了生命周期（lifetime）的良构性判断规则，主要包括两条规则：

#### 1. **一般生命周期规则（General Lifetime Rule）**
$$
\frac{\alpha : lft \in \Gamma}{\Gamma \vdash_{wf} \alpha}
$$
**解释**：如果生命周期标识符 $\alpha$ 属于上下文 $\Gamma$，即 $\alpha$ 是上下文中的一个生命周期变量，则可以判断该生命周期 $\alpha$ 是良构的 ($\Gamma \vdash_{wf} \alpha$)。这意味着在上下文 $\Gamma$ 中声明的生命周期是良构的。

#### 2. **静态生命周期规则（Static Lifetime Rule）**
$$
\Gamma \vdash_{wf} static
$$
**解释**：无论上下文 $\Gamma$ 的内容如何，静态生命周期（`static`）总是被认为是良构的 ($\Gamma \vdash_{wf} static$)。静态生命周期通常是指程序运行期间始终有效的生命周期（类似于 Rust 中的 `'static` 生命周期）。

### 总结：

- **一般生命周期规则**：如果生命周期 $\alpha$ 已在上下文中声明为生命周期类型（$lft$），那么它是良构的。
- **静态生命周期规则**：静态生命周期 `static` 总是被视为良构的，无需额外条件。

这两条规则定义了如何判断生命周期是否良构，从而确保生命周期的使用在程序中保持一致性和正确性。

### -------------------------

### Well-formed external lifetime contexts 详解

图中定义了外部生命周期上下文的良构性规则。

#### 1. **空外部上下文规则（Empty External Context Rule）**
$$
\Gamma \vdash_{wf} \emptyset
$$
**解释**：在上下文 $\Gamma$ 中，空的外部上下文 $\emptyset$ 总是良构的。这意味着，如果没有定义任何外部生命周期上下文，则认为该上下文是良构的。

#### 2. **扩展外部上下文规则（Extend External Context Rule）**
$$
\frac{\Gamma \vdash_{wf} \mathbf{L} \quad \Gamma \vdash_{wf} \kappa \quad \Gamma \vdash_{wf} \kappa' }{\Gamma \vdash_{wf} \mathbf{L}, \kappa \subseteq_e \kappa'}
$$
**解释**：若上下文 $\Gamma$ 中的外部上下文 $\mathbf{L}$ 是良构的，同时生命周期 $\kappa$ 和 $\kappa'$ 也分别是良构的，并且 $\kappa \subseteq_e \kappa'$ 成立，则扩展后的外部上下文 $\mathbf{L}, \kappa \subseteq_e \kappa'$ 也是良构的。这表明在外部上下文中，生命周期之间的包含关系需要维持，并且所有的生命周期声明必须是良构的。

### 总结

- **空上下文规则**：空的外部生命周期上下文总是良构的。
- **扩展上下文规则**：要扩展一个良构的外部上下文，必须确保新添加的生命周期和生命周期之间的包含关系是良构的，并且生命周期本身也是良构的。

这些规则确保了外部生命周期上下文在程序中使用时是良构的，维护了生命周期的正确性和一致性。

### -----------------------

### Well-formed Local Lifetime Contexts 详解

图中定义了局部生命周期上下文的良构性规则。

#### 1. **空局部上下文规则（Empty Local Context Rule）**
$$
\Gamma \vdash_{wf} \emptyset
$$
**解释**：在上下文 $\Gamma$ 中，空的局部上下文 $\emptyset$ 是良构的。与外部生命周期上下文类似，当没有局部生命周期上下文时，认为它是良构的。

#### 2. **扩展局部上下文规则（Extend Local Context Rule）**
$$
\frac{\Gamma \vdash_{wf} \mathbf{L} \quad \Gamma \vdash_{wf} \kappa \quad \forall \kappa' \in \bar{\kappa}. \Gamma \vdash_{wf} \kappa' }{\Gamma \vdash_{wf} \mathbf{L}, \kappa \subseteq_l \bar{\kappa}}
$$
**解释**：如果局部上下文 $\mathbf{L}$ 是良构的，并且 $\kappa$ 是良构的，同时 $\bar{\kappa}$ 中的每一个 $\kappa'$ 都是良构的，那么扩展后的局部上下文 $\mathbf{L}, \kappa \subseteq_l \bar{\kappa}$ 也是良构的。这表明，局部上下文中的生命周期可以扩展，但需要确保新引入的生命周期和原有生命周期之间的局部包含关系是良构的。

### 总结

- **空上下文规则**：空的局部生命周期上下文总是良构的。
- **扩展上下文规则**：要扩展一个良构的局部上下文，必须确保新添加的生命周期与其他生命周期的包含关系是良构的，并且所有生命周期本身也必须是良构的。

这些规则确保了局部生命周期上下文在程序中是正确构造的，维护了生命周期的局部包含关系的有效性。

### -------------------------------

### Well-formed Types 详解

图中定义了类型的良构性规则。它为各种类型如何被认为是良构提供了形式化定义。

#### 1. **基本类型的良构性**
- **基本类型：**
  $$
  \frac{T : type \in \Gamma}{\Gamma \vdash_{wf} T}
  $$
  **解释**：在上下文 $\Gamma$ 中，如果 $T$ 是一个类型，则 $T$ 被认为是良构的。
  
- **布尔类型：**
  $$
  \Gamma \vdash_{wf} bool
  $$
  **解释**：布尔类型 $bool$ 在任何上下文 $\Gamma$ 下总是良构的。

- **整数类型：**
  $$
  \Gamma \vdash_{wf} int
  $$
  **解释**：整数类型 $int$ 在任何上下文 $\Gamma$ 下总是良构的。

- **拥有关系类型：**
  $$
  \frac{\Gamma \vdash_{wf} \tau}{\Gamma \vdash_{wf} own_n \tau}
  $$
  **解释**：如果 $\tau$ 是一个良构的类型，那么拥有关系类型 $own_n \tau$ 也是良构的。

#### 2. **引用类型的良构性**
- **生命周期相关的引用类型：**
  $$
  \frac{\Gamma \vdash_{wf} \kappa \quad \Gamma \vdash_{wf} \tau}{\Gamma \vdash_{wf} \&^{\kappa}_{\mu} \tau}
  $$
  **解释**：如果生命周期 $\kappa$ 和类型 $\tau$ 都是良构的，那么 $\kappa$ 和修饰符 $\mu$ （如 `mut` 或 `shr`）组合的引用类型 $\&^{\kappa}_{\mu} \tau$ 也是良构的。这种类型表示受生命周期和可变性修饰的引用类型。

#### 总结

- 基本类型如 $bool$ 和 $int$ 是在任何上下文下都被认为是良构的。
- 拥有类型 $own_n \tau$ 和引用类型 $\&^{\kappa}_{\mu} \tau$ 的良构性依赖于它们内部类型的良构性和生命周期约束的良构性。
- 通过这些规则，可以确保程序中所有类型的有效性和一致性。

这些规则提供了一套形式系统，来验证 Rust 风格类型系统中各类复杂类型的有效性。



这两个推导规则分别描述了 *依赖乘积* ($\Pi$) 和 *依赖和* ($\Sigma$) 类型的良构性规则。我们来分别解释这两个推导规则。

### 1. 依赖乘积（Dependent Product，$\Pi$）类型的良构性规则：

#### 公式：
$$
\frac{\forall i. \Gamma \vdash_{wf} \bar{\tau}_i}{\Gamma \vdash_{wf} \Pi \bar{\tau}}
$$

#### 解释：
- **前提**：对于所有的 $i$，在上下文 $\Gamma$ 中，$\bar{\tau}_i$ 是一个良构的类型。
- **结论**：在上下文 $\Gamma$ 中，依赖乘积类型 $\Pi \bar{\tau}$ 是一个良构的类型。

依赖乘积类型可以类比于函数的类型，描述了返回类型依赖于输入参数类型的情形。在编程语言中，依赖乘积类型常用于表示参数化类型，其中返回的类型可以依据参数而改变。

例如：
$$
\Pi x : \text{nat}. \text{List}(x)
$$
表示一个函数，其输入为自然数 $x$，返回值的类型是长度为 $x$ 的列表。

### 2. 依赖和（Dependent Sum，$\Sigma$）类型的良构性规则：

#### 公式：
$$
\frac{\forall i. \Gamma \vdash_{wf} \bar{\tau}_i}{\Gamma \vdash_{wf} \Sigma \bar{\tau}}
$$

#### 解释：
- **前提**：对于所有的 $i$，在上下文 $\Gamma$ 中，$\bar{\tau}_i$ 是一个良构的类型。
- **结论**：在上下文 $\Gamma$ 中，依赖和类型 $\Sigma \bar{\tau}$ 是一个良构的类型。

依赖和类型描述了一个类型对，其第二个分量依赖于第一个分量的值。在编程语言中，这常用于表示某个数据类型的同时保存某个值及其相关的类型信息。

例如：
$$
\Sigma x : \text{nat}. \text{List}(x)
$$
表示一个数据类型，其中包含一个自然数 $x$，以及长度为 $x$ 的列表。

### 总结：
- **依赖乘积类型** $\Pi \bar{\tau}$：类似于函数类型，表示返回类型依赖于输入参数类型。
- **依赖和类型** $\Sigma \bar{\tau}$：类似于依赖对，表示类型中某些部分依赖于其他部分的值。

这两个规则确保了在上下文 $\Gamma$ 中构造这两种依赖类型是合法且良构的。



此推导规则描述了 *带有生命周期参数的函数类型* 的良构性规则。下面逐步解释各个部分的含义：

### 公式：
$$
\frac{\Gamma, \bar{\alpha}, F : lft \vdash_{wf} \mathbb{E} \quad \forall i. \Gamma, \bar{\alpha} : lft \vdash_{wf} \bar{\tau}_i \quad \Gamma, \bar{\alpha} : lft \vdash_{wf} \tau}{\Gamma \vdash_{wf} \forall \bar{\alpha}. fn(F : \mathbb{E}; \bar{\tau}) \to \tau}
$$

### 解释：

#### 前提部分：
- **$\Gamma, \bar{\alpha}, F : lft \vdash_{wf} \mathbb{E}$**：上下文 $\Gamma$ 和生命周期变量 $\bar{\alpha}$ 构成的环境中，表达式环境 $\mathbb{E}$ 是良构的。
  
- **$\forall i. \Gamma, \bar{\alpha} : lft \vdash_{wf} \bar{\tau}_i$**：对于每个参数类型 $\bar{\tau}_i$，在上下文 $\Gamma$ 和生命周期变量 $\bar{\alpha}$ 的环境中，这些参数类型都是良构的。这表示所有参数类型在指定的生命周期内是合法的。
  
- **$\Gamma, \bar{\alpha} : lft \vdash_{wf} \tau$**：在上下文 $\Gamma$ 和生命周期变量 $\bar{\alpha}$ 的环境中，返回类型 $\tau$ 也是良构的。

#### 结论部分：
- **$\Gamma \vdash_{wf} \forall \bar{\alpha}. fn(F : \mathbb{E}; \bar{\tau}) \to \tau$**：基于前面的前提，我们可以得出结论，在上下文 $\Gamma$ 中，生命周期参数化的函数类型 $\forall \bar{\alpha}. fn(F : \mathbb{E}; \bar{\tau}) \to \tau$ 是良构的。

### 总结：
这个推导规则用于验证在 Rust 或 Lambda-Rust 等语言中，带有生命周期参数的函数类型是否良构。该规则说明了在上下文中，首先需要确保生命周期参数和所有函数参数的类型良构，并且返回类型也需要良构，才能得出整个函数类型的良构性。



这个推导规则描述了递归类型 $\mu T. \tau$ 的良构性规则。它的核心要求是类型 $T$ 必须只出现在 $\tau$ 中的指针或函数类型之下，这样可以确保递归类型的结构是合法的，不会导致不合法的自引用或无穷递归。

### 公式解释
$$
\frac{\Gamma, T : type \vdash_{wf} \tau \quad T \text{ only occurs below pointer or function types in } \tau}{\Gamma \vdash_{wf} \mu T. \tau}
$$

- **前提**：
  - $\Gamma, T : type \vdash_{wf} \tau$：在上下文 $\Gamma$ 中，$\tau$ 是一个良构的类型，其中 $T$ 被引入作为类型。
  - $T$ 仅仅出现在 $\tau$ 的指针或函数类型下：$T$ 的出现位置受到限制，确保它只位于指针类型或函数类型的嵌套结构之内。这通常是为了避免无穷递归的类型结构，例如直接的 $T = T$ 自引用。

- **结论**：
  - 在上下文 $\Gamma$ 中，$\mu T. \tau$ 是一个良构的递归类型。递归类型通常用于定义数据结构，比如树或链表，它们可以递归地引用自身。

### 举例
设 $\tau = \&T \to \text{int}$，那么 $\mu T. \tau = \mu T. (\&T \to \text{int})$ 就是一个合法的递归类型，因为 $T$ 仅出现在一个指针类型之下。

然而，如果 $\tau = T$，则 $\mu T. T$ 就是不合法的递归类型，因为 $T$ 是直接自引用的，这会导致不良构的类型。

### 总结
该规则确保递归类型的定义是安全的，不会导致无穷递归或其他类型不良构的问题。通过限制 $T$ 只出现在指针或函数类型下，保证了递归类型的合理性。

### ----------------------------

这组推导规则描述了良构类型上下文（Well-formed Type Contexts）的规则，确定了在给定上下文下类型上下文是如何构造和验证的。以下逐步解释每条规则的含义：

### 规则 1：
$$
\Gamma \vdash_{wf} \emptyset
$$
#### 解释：
在空上下文 $\Gamma$ 中，空类型上下文 $\emptyset$ 是良构的。这意味着，没有类型变量的上下文显然是良构的。

### 规则 2：
$$
\frac{\Gamma \vdash_{wf} T \quad \Gamma \vdash_{wf} p \quad \Gamma \vdash_{wf} \tau}{\Gamma \vdash_{wf} T, p \triangleleft \tau}
$$
#### 解释：
该规则表明，如果：
- 在上下文 $\Gamma$ 中，类型 $T$ 是良构的；
- 路径 $p$ 是良构的；
- 类型 $\tau$ 是良构的；

那么，类型上下文 $T$ 与路径 $p \triangleleft \tau$ 也是良构的。这表示可以在良构的类型上下文中添加新的类型映射。

### 规则 3：
$$
\frac{\Gamma \vdash_{wf} T \quad \Gamma \vdash_{wf} p \quad \Gamma \vdash_{wf} \kappa \quad \Gamma \vdash_{wf} \tau}{\Gamma \vdash_{wf} T, p \triangleleft^{\dagger\kappa} \tau}
$$
#### 解释：
这条规则是在前一条规则的基础上，添加了生命周期 $\kappa$ 的条件。如果：
- 在上下文 $\Gamma$ 中，类型 $T$ 是良构的；
- 路径 $p$ 是良构的；
- 生命周期 $\kappa$ 是良构的；
- 类型 $\tau$ 是良构的；

那么，类型上下文 $T$ 与路径 $p \triangleleft^{\dagger\kappa} \tau$ 也是良构的。这表示在生命周期约束下，可以将新的类型映射添加到上下文中。

### 总结：
这些推导规则确定了在给定上下文下，如何构造和验证类型上下文的良构性。规则 1 确定空上下文显然是良构的，而规则 2 和规则 3 扩展了这种良构性，允许添加路径和生命周期的约束来构造更加复杂的类型上下文。

### -------------------------

这一组推导定义了不同类型的**大小（Size）**如何计算。我们逐一解析这些规则：

### 1. 基本类型的大小
$$
\text{size(bool)} := 1
$$
$$
\text{size(int)} := 1
$$
这些规则表明，布尔类型和整数类型的大小都被定义为1。也就是说，无论是布尔类型还是整数类型，它们在内存中的表示是固定的，并且被赋予常量大小1。

### 2. 大小为$n$的类型
$$
\text{size}(\varnothing_n) := n
$$
这个规则表示，具有$n$个空值的类型大小是$n$，说明类型的大小与其占据的空值数量成比例。

### 3. 递归类型
$$
\text{size}(\mu T. \tau) := \text{size}(\tau)
$$
对于递归类型$\mu T. \tau$，其大小等同于$\tau$的大小。这反映了递归类型在大小上的自相似性，它只关心其内部类型的大小。

### 4. 拥有类型 (own)
$$
\text{size(own}_n \tau) := 1
$$
拥有类型（own）与其内部类型无关，被定义为1的固定大小。

### 5. 引用类型（借用类型）
$$
\text{size}(\&^{\kappa}_{\mu} \tau) := 1
$$
引用类型（borrowed references）的大小也是固定为1，无论其生命周期或修饰符（如可变性）如何。

### 6. 依赖于多个子类型的类型
$$
\text{size}(\Pi \overline{\tau}) := \sum_i \text{size}(\tau_i)
$$
对于依赖于多个子类型的类型（如$\Pi$类型），其大小是所有子类型大小的总和。这表示它的大小随着子类型的数量而增加。

### 7. 伴随子类型的类型
$$
\text{size}(\Sigma \overline{\tau}) := 1 + \max_i \text{size}(\tau_i)
$$
对于$\Sigma$类型，其大小定义为1加上所有子类型大小中的最大值。它表明这类类型选择其最大子类型的大小，并在此基础上增加固定大小1。

### 8. 函数类型
$$
\text{size}(\forall \overline{\alpha}. \text{fn}(F : \text{E}; \overline{\tau}) \rightarrow \tau) := 1
$$
函数类型的大小被定义为固定的1，说明无论函数内部的参数或返回类型如何，函数类型的大小是常量。

### 总结
- 对于基本类型（如布尔、整数），大小固定为1。
- 对于依赖于多个子类型的类型，如$\Pi$和$\Sigma$，大小与其子类型有关，$\Pi$类型的大小是子类型大小的总和，而$\Sigma$类型的大小取最大子类型大小并加1。
- 引用类型、拥有类型和函数类型的大小都被固定为1，无论内部结构如何。
- 递归类型的大小直接继承其内在类型的大小。

这种定义为不同类型在内存中的占用大小提供了一个推理的基础，并且这些规则可能用于编译器或类型系统中的大小分析与优化。

### ---------------------

好的，以下是基于你提供的例子格式，针对“Copy types”的推导规则公式及详细解释。

---

### 公式 1：
$$
\frac{}{\Gamma \vdash bool \; copy}
$$

### 解释：
此推导规则描述了在上下文 $\Gamma$ 中，`bool` 类型是可复制的。由于布尔类型（`bool`）是一个简单的基本类型，它的值是固定且小规模的，复制操作不涉及复杂的内存管理，因此天然支持复制操作。

---

### 公式 2：
$$
\frac{}{\Gamma \vdash int \; copy}
$$

### 解释：
这一规则表明，在上下文 $\Gamma$ 中，`int` 类型是可复制的。整数类型（`int`）作为基础类型，也不涉及复杂的所有权或引用管理问题，因此其值可以直接复制。这个规则与布尔类型的推导规则相似，整数类型也是天然可复制的。

---

### 公式 3：
$$
\frac{}{\Gamma \vdash \not n \; copy}
$$

### 解释：
该规则表明，对于大小为 $n$ 的标量类型（例如数组或定长字节序列），在上下文 $\Gamma$ 中，这种类型是可复制的。这意味着，如果类型的大小已知且有限，那么复制该类型的值是可行的。`n` 表示的是这种标量类型的大小，复制该类型时会逐字节地进行复制操作。

---

### 公式 4：
$$
\frac{}{\Gamma \vdash \&^{\kappa}_{shr} \; \tau \; copy}
$$

### 解释：
此推导规则说明，在上下文 $\Gamma$ 中，如果某类型 $\tau$ 是可复制的，那么该类型的共享引用（`&^{\kappa}_{shr} \tau`）也是可复制的。这里的 $\kappa$ 代表引用的生命周期（lifetime），而共享引用允许多个所有者同时访问同一内存位置，因此复制该引用并不会导致内存的所有权转移，而是创建了一个额外的指针来共享该内存地址。

---

### 公式 5：
$$
\frac{\forall i. \Gamma \vdash \tau_i \; copy}{\Gamma \vdash \Pi \overline{\tau} \; copy}
$$

### 解释：
该推导规则表明，如果所有参数类型 $\tau_i$ 都是可复制的，那么在上下文 $\Gamma$ 中，参数化类型 $\Pi \overline{\tau}$ 也是可复制的。即，函数类型或多态类型的每个参数都是可复制的情况下，整个类型也是可复制的。

---

### 公式 6：
$$
\frac{\forall i. \Gamma \vdash \tau_i \; copy}{\Gamma \vdash \Sigma \overline{\tau} \; copy}
$$

### 解释：
类似于前一个推导规则，这条规则指出，如果结构类型中的每个字段类型 $\tau_i$ 都是可复制的，那么整体 $\Sigma \overline{\tau}$ 类型也是可复制的。这个规则适用于记录类型、元组类型等复合类型，确保其所有组成部分都是可复制的。

---

### 总结：
这些推导规则展示了在上下文 $\Gamma$ 中，基础类型（如 `bool` 和 `int`）、标量类型、引用类型以及复合类型的复制行为。这些规则为类型系统提供了确保类型安全性和内存管理合理性的基础，通过验证不同类型的可复制性，可以保证程序在执行时避免不必要的内存错误或所有权冲突。



### 公式 1：
$$
\Gamma \vdash (\forall \bar{\alpha}. fn(F : \mathbb{E}; \bar{\tau}) \to \tau) \; copy
$$

### 解释：
这个推导规则描述了一个带有生命周期参数的函数类型的复制性规则。具体含义如下：

#### 前提部分：
- **$\Gamma \vdash (\forall \bar{\alpha}. fn(F : \mathbb{E}; \bar{\tau}) \to \tau) \; copy$**：在上下文 $\Gamma$ 中，带有生命周期参数 $\bar{\alpha}$ 的函数类型 $(fn(F : \mathbb{E}; \bar{\tau}) \to \tau)$ 是可复制的。这表示函数签名包括所有生命周期和类型参数，并且函数类型整体上可以支持复制操作。复制的含义指的是当对该函数类型的实例进行复制时，不涉及改变所有权或内存地址。

#### 结论部分：
- 该推导规则表明，在上下文 $\Gamma$ 中，带有生命周期参数化的函数类型是可以安全复制的，因为其参数和返回类型保证了生命周期的正确性。

---

### 公式 2：
$$
\Gamma \vdash T \; copy
$$

### 解释：
这一规则简单说明了，在上下文 $\Gamma$ 中，类型 $T$ 是可复制的。该类型的可复制性是直接保证的，没有额外的限制或依赖关系。这个规则适用于简单的基础类型或者已知是可复制的类型。

---

### 公式 3：
$$
\frac{\Gamma, T : type \vdash \tau \; copy}{\Gamma \vdash \mu T. \tau \; copy}
$$

### 解释：
这个推导规则涉及递归类型 $\mu T. \tau$ 的复制性判断。

#### 前提部分：
- **$\Gamma, T : type \vdash \tau \; copy$**：在上下文 $\Gamma$ 中，类型变量 $T$ 作为递归类型的类型参数，且类型 $\tau$ 是可复制的。这意味着，$\tau$ 的每个实例化都不涉及复杂的内存管理，因此可以被复制。

#### 结论部分：
- **$\Gamma \vdash \mu T. \tau \; copy$**：基于前提，可以得出结论，在上下文 $\Gamma$ 中，递归类型 $\mu T. \tau$ 是可复制的。这一推导确保了递归类型的结构是良构的，并且可以安全地进行复制操作。

---

### 总结：
这些推导规则展示了函数类型、简单类型和递归类型的复制行为。在类型系统中，确保类型的可复制性是非常重要的，这能避免在复制操作中产生内存错误或所有权冲突。

### --------------------------

### 公式 1：
$$
\Gamma \vdash bool \; send
$$

### 解释：
在上下文 $\Gamma$ 中，布尔类型 $bool$ 是可发送的类型。这意味着布尔值在多线程环境下可以安全地跨线程传递，因为布尔值在内存上占用的空间固定且不涉及复杂的引用或所有权管理问题。

---

### 公式 2：
$$
\Gamma \vdash int \; send
$$

### 解释：
在上下文 $\Gamma$ 中，整数类型 $int$ 是可发送的类型。整数类型具有与布尔类型类似的特性：它占用固定大小的内存，不依赖于引用或所有权管理。因此，整数可以安全地跨线程传递。

---

### 公式 3：
$$
\Gamma \vdash \downarrow_n \; send
$$

### 解释：
在上下文 $\Gamma$ 中，$\downarrow_n$ 类型也是可发送的类型。这可能是一个特殊的类型，代表某种有限的递减类型或在内存中有固定大小的数据结构。由于它不涉及引用或所有权转移，$\downarrow_n$ 也可以安全地在线程间传递。

---

### 总结：
这些公式定义了不同基础类型（如 $bool$, $int$ 和 $\downarrow_n$）在多线程环境中的可发送性。由于这些类型都具有固定的内存占用，并且不依赖复杂的生命周期或所有权管理，因此它们可以被安全地跨线程传递。

### 公式 1：
$$
\frac{\Gamma \vdash \tau \; send}{\Gamma \vdash own_n \tau \; send}
$$

### 解释：
- **前提**：类型 $\tau$ 是可发送的 ($\tau \; send$)。
- **结论**：拥有所有权的类型 $own_n \tau$ 也是可发送的。

#### 说明：
在 Rust 或 Lambda-Rust 中，`own_n \tau` 表示具有所有权的类型。既然 $\tau$ 是可发送的，意味着它的所有权可以安全地从一个线程转移到另一个线程。因此，$own_n \tau$ 也是可发送的类型。

---

### 公式 2：
$$
\frac{\tau \; send}{\&^{\kappa}_{mut} \tau \; send}
$$

### 解释：
- **前提**：类型 $\tau$ 是可发送的 ($\tau \; send$)。
- **结论**：带有可变借用的类型 $\&^{\kappa}_{mut} \tau$ 也是可发送的。

#### 说明：
$\&^{\kappa}_{mut} \tau$ 表示对类型 $\tau$ 的可变引用，带有 $\kappa$ 生命周期。在 Rust 中，如果 $\tau$ 是可发送的，那么对它的可变引用也是可以在线程间安全传递的。这意味着在一个线程中，$\tau$ 的可变引用可以被移动到另一个线程进行修改。

---

### 公式 3：
$$
\frac{\Gamma \vdash \tau \; sync}{\Gamma \vdash \&^{\kappa}_{shr} \tau \; send}
$$

### 解释：
- **前提**：类型 $\tau$ 是同步的 ($\tau \; sync$)。
- **结论**：带有共享引用的类型 $\&^{\kappa}_{shr} \tau$ 是可发送的。

#### 说明：
在 Rust 中，`&^{\kappa}_{shr} \tau` 表示对类型 $\tau$ 的共享引用。如果 $\tau$ 是同步的 ($sync$)，这意味着多个线程可以安全地共享访问该类型的数据。因此，$\&^{\kappa}_{shr} \tau$ 是可以在线程间安全传递的。这表示在多线程环境下，带有共享引用的同步类型是可以安全共享的。

---

### 总结：
这三条规则描述了具有不同引用和所有权的类型在多线程环境中的可发送性。只要基础类型 $\tau$ 是可发送或同步的，那么它的引用形式和拥有所有权形式也可以在线程之间安全传递。这符合 Rust 的借用和所有权模型。

### 公式 1：
$$
\frac{\forall i. \Gamma \vdash \tau_i \; send}{\Gamma \vdash \Pi \bar{\tau} \; send}
$$

### 解释：
- **前提**：对于每一个 $\tau_i$，$\tau_i$ 都是可发送的 ($\tau_i \; send$)。
- **结论**：类型 $\Pi \bar{\tau}$ 也是可发送的。

#### 说明：
该推导规则描述了如果一组类型 $\tau_i$ 都是可发送的，那么它们的笛卡尔积 $\Pi \bar{\tau}$ 也是可发送的。在 Rust 中，这意味着如果每个单独的类型 $\tau_i$ 可以在线程之间安全传递，那么它们的组合 (可能是一个元组) 也可以安全地在线程间传递。

---

### 公式 2：
$$
\frac{\forall i. \Gamma \vdash \tau_i \; send}{\Gamma \vdash \Sigma \bar{\tau} \; send}
$$

### 解释：
- **前提**：对于每一个 $\tau_i$，$\tau_i$ 都是可发送的 ($\tau_i \; send$)。
- **结论**：类型 $\Sigma \bar{\tau}$ 也是可发送的。

#### 说明：
这条规则描述了类似联合类型 $\Sigma \bar{\tau}$ 的发送性。如果每个单独的 $\tau_i$ 都是可发送的，那么它们的选择类型（即联合类型或枚举） $\Sigma \bar{\tau}$ 也是可发送的。这意味着，在多线程环境中，可以安全地选择并传递联合类型中的任意一个分支。

---

### 总结：
这两条规则适用于复合类型的可发送性推导。只要每个单独的类型 $\tau_i$ 是可发送的，那么它们的笛卡尔积或联合类型也都是可发送的。这对于类型的组合体（如元组或枚举）在 Rust 中的线程安全性有直接的影响。

### 公式 1:
$$
\Gamma \vdash (\forall \bar{\alpha}. fn(F : \mathbb{E}; \bar{\tau}) \to \tau) \; send
$$

### 解释：

#### 前提部分：
- **$\Gamma \vdash (\forall \bar{\alpha}. fn(F : \mathbb{E}; \bar{\tau}) \to \tau)$**：函数类型带有生命周期参数 $\bar{\alpha}$，并且参数的类型为 $\mathbb{E}$ 和 $\bar{\tau}$，返回类型为 $\tau$。
  
#### 结论部分：
- **$send$**：该函数类型是可发送的，这意味着它可以在线程间传递。

#### 说明：
该规则表明带有生命周期参数和多个函数参数的函数类型在满足一定条件时是可发送的。通常，这种函数类型要满足它的输入输出类型本身是可发送的。

---

### 公式 2:
$$
\Gamma \vdash T \; send
$$

### 解释：

#### 前提部分：
- **$\Gamma \vdash T$**：在上下文 $\Gamma$ 中，类型 $T$ 是定义好的。
  
#### 结论部分：
- **$send$**：该类型 $T$ 是可发送的。

#### 说明：
此规则表示任意类型 $T$ 若满足上下文中规定的条件，那么该类型是可发送的。在 Rust 中，这意味着类型 $T$ 可以安全地跨线程传递。这一规则适用于简单类型或引用类型等。

---

### 总结：
- 第一个公式描述了带有生命周期参数的函数类型在多线程环境中的可发送性条件。
- 第二个公式说明了类型 $T$ 本身的可发送性，确保了在多线程环境中可以安全传递该类型的值。

### 公式：
$$
\frac{\Gamma, T : type \vdash \tau \; send}{\Gamma \vdash \mu T . \tau \; send}
$$

### 解释：

#### 前提部分：
- **$\Gamma, T : type \vdash \tau \; send$**：在上下文 $\Gamma$ 中，类型 $T$ 被定义为类型变量，且 $\tau$ 类型是可发送的。也就是说，假设 $T$ 是类型，类型 $\tau$ 是可以安全跨线程传递的（即 `Send` 特性满足）。

#### 结论部分：
- **$\Gamma \vdash \mu T . \tau \; send$**：基于前提，可以得出结论 $\mu T . \tau$ 是可发送的。这里 $\mu T . \tau$ 表示递归类型，也就是说，这种递归类型的每次展开仍然是可发送的。

#### 说明：
这一推导规则的目的是说明递归类型（$\mu T . \tau$）的 `Send` 性质。如果类型 $\tau$ 在给定上下文 $\Gamma$ 下是可发送的，并且 $T$ 是类型变量，那么其对应的递归类型 $\mu T . \tau$ 也是可发送的。这在多线程编程中很有用，尤其是在递归结构或递归类型的情况下，可以保证该类型的数据在多线程环境中安全传递。

### --------------------------

### 公式：
$$
\Gamma \vdash bool \; sync \quad \Gamma \vdash int \; sync \quad \Gamma \vdash \downarrow_n \; sync
$$

### 解释：

#### 前提部分：
- **$\Gamma \vdash bool \; sync$**：布尔类型（`bool`）在上下文 $\Gamma$ 中是可同步的，意味着它可以在线程之间安全共享。
- **$\Gamma \vdash int \; sync$**：整型类型（`int`）在上下文 $\Gamma$ 中是可同步的，表明它在线程之间是可以安全共享的。
- **$\Gamma \vdash \downarrow_n \; sync$**：表示有限范围内的类型 $\downarrow_n$（即枚举类型）在上下文 $\Gamma$ 中是可同步的，也意味着它在并发环境下是安全的。

#### 结论部分：
这组规则说明了简单原始类型（如 `bool`、`int` 和有界整数类型 $\downarrow_n$）在上下文 $\Gamma$ 中是可以安全在线程之间共享的，符合同步类型（`Sync`）的要求。这些类型通常在并发编程中被广泛使用，因为它们可以安全地在多个线程中访问，而无需额外的同步机制。

### 总结：
`bool`、`int` 和有限整数类型 $\downarrow_n$ 是 `Sync` 的，这意味着它们可以在多线程环境中安全共享。这对于并发编程中确保数据一致性和线程安全至关重要。



### 公式：
$$
\frac{\Gamma \vdash \tau \; sync}{\Gamma \vdash own_n \tau \; sync} \quad
\frac{\Gamma \vdash \tau \; sync}{\Gamma \vdash \&^\kappa_{mut} \tau \; sync} \quad
\frac{\Gamma \vdash \tau \; sync}{\Gamma \vdash \&^\kappa_{shr} \tau \; sync}
$$

### 解释：

#### 前提部分：
- **$\Gamma \vdash \tau \; sync$**：类型 $\tau$ 在上下文 $\Gamma$ 中是可同步的，这意味着类型 $\tau$ 可以在多线程环境中安全地共享。
  
#### 结论部分：
1. **$\Gamma \vdash own_n \tau \; sync$**：
   - 这个规则表示如果类型 $\tau$ 是可同步的，那么它的拥有指针类型 `own_n \tau` 也是可同步的。即，在拥有该资源时，可以在不同的线程间共享。
  
2. **$\Gamma \vdash \&^\kappa_{mut} \tau \; sync$**：
   - 如果类型 $\tau$ 是可同步的，那么它的可变借用引用 `&^\kappa_{mut} \tau` 也是可同步的。也就是说，允许其他线程通过可变引用修改它时，该类型仍然能安全地在线程间共享。
  
3. **$\Gamma \vdash \&^\kappa_{shr} \tau \; sync$**：
   - 如果类型 $\tau$ 是可同步的，那么它的共享引用 `&^\kappa_{shr} \tau` 也是可同步的。这意味着多个线程可以共享对该资源的访问，而不需要担心数据竞争。

### 总结：
这些规则扩展了类型 $\tau$ 的可同步性，使得通过 `own_n`（拥有指针）或者通过引用类型（可变引用和共享引用）的指针类型依然保持同步性。这表明，无论是通过直接所有权、可变引用，还是共享引用的方式访问数据，只要原始数据类型 $\tau$ 是同步的，那么这些访问方式也是同步的。这些规则对于并发编程非常重要，因为它们确保了不同的访问方式在多线程环境下是安全的。

### 公式 1：
$$
\frac{\Gamma \vdash \tau \; sync}{\Gamma \vdash own_n \tau \; sync}
$$

#### 解释：
- **前提**：$\Gamma \vdash \tau \; sync$，表示在上下文 $\Gamma$ 中，类型 $\tau$ 是可同步的（即可以在线程间安全共享）。
  
- **结论**：$\Gamma \vdash own_n \tau \; sync$，表示如果类型 $\tau$ 是可同步的，那么拥有指针 `own_n \tau` 也同样是可同步的。这意味着，即使是拥有该资源的指针，也可以安全地在线程之间传递而不引发数据竞争。

#### 总结：
此规则说明如果一个类型是可同步的，那么它的拥有指针 `own_n \tau` 也具有同样的同步性质。这对于实现安全的多线程编程至关重要，因为它允许资源在不同的线程之间以拥有指针的形式共享，而不引发安全问题。

---

### 公式 2：
$$
\frac{\Gamma \vdash \tau \; sync}{\Gamma \vdash \&^\kappa_{mut} \tau \; sync}
$$

#### 解释：
- **前提**：$\Gamma \vdash \tau \; sync$，表示在上下文 $\Gamma$ 中，类型 $\tau$ 是可同步的。
  
- **结论**：$\Gamma \vdash \&^\kappa_{mut} \tau \; sync$，表示如果类型 $\tau$ 是可同步的，那么它的可变借用引用 `&^\kappa_{mut} \tau` 也同样是可同步的。这意味着，在多线程环境中，允许多个线程通过可变引用访问该类型，而不会产生数据竞争。

#### 总结：
此规则说明如果一个类型是可同步的，那么它的可变借用引用 `&^\kappa_{mut} \tau` 也同样具备同步性。这确保了即使是允许修改的可变引用，在多线程环境下仍然是安全的。

---

### 公式 3：
$$
\frac{\Gamma \vdash \tau \; sync}{\Gamma \vdash \&^\kappa_{shr} \tau \; sync}
$$

#### 解释：
- **前提**：$\Gamma \vdash \tau \; sync$，表示在上下文 $\Gamma$ 中，类型 $\tau$ 是可同步的。
  
- **结论**：$\Gamma \vdash \&^\kappa_{shr} \tau \; sync$，表示如果类型 $\tau$ 是可同步的，那么它的共享引用 `&^\kappa_{shr} \tau` 也同样是可同步的。这意味着多个线程可以通过共享引用安全地访问该资源，而不会引发竞争条件。

#### 总结：
此规则说明如果一个类型是可同步的，那么它的共享引用 `&^\kappa_{shr} \tau` 也具有同步性。这使得在多线程环境下可以安全地通过共享引用访问同步类型，确保数据的一致性和安全性。

---

### 总结：
以上三条规则共同阐述了如何在多线程编程中处理同步类型。无论是直接拥有指针、可变借用引用，还是共享引用，只要基础类型 $\tau$ 是同步的，那么这些操作方式都是线程安全的，能够避免数据竞争。



### 公式 1：
$$
\frac{\forall i. \Gamma \vdash \tau_i \; sync}{\Gamma \vdash \Pi \bar{\tau} \; sync}
$$

#### 解释：
- **前提**：对于每个索引 $i$，上下文 $\Gamma$ 中的所有类型 $\tau_i$ 都是同步类型（$\Gamma \vdash \tau_i \; sync$）。
  
- **结论**：在这种情况下，依赖类型的笛卡尔积 $\Pi \bar{\tau}$（即函数类型或产品类型）也是同步类型（$\Gamma \vdash \Pi \bar{\tau} \; sync$）。

#### 总结：
该规则表明，如果类型集合中的每个类型 $\tau_i$ 都是同步的，那么它们的依赖类型积（例如函数的参数类型）也是同步的。这适用于多线程编程中的函数类型，确保函数的参数都可以安全在线程间共享，从而函数类型整体也可以同步。

---

### 公式 2：
$$
\frac{\forall i. \Gamma \vdash \tau_i \; sync}{\Gamma \vdash \Sigma \bar{\tau} \; sync}
$$

#### 解释：
- **前提**：对于每个索引 $i$，上下文 $\Gamma$ 中的所有类型 $\tau_i$ 都是同步类型（$\Gamma \vdash \tau_i \; sync$）。
  
- **结论**：在这种情况下，依赖类型的和 $\Sigma \bar{\tau}$（即类型的直和类型或联合类型）也是同步类型（$\Gamma \vdash \Sigma \bar{\tau} \; sync$）。

#### 总结：
该规则表示，如果类型集合中的每个类型 $\tau_i$ 都是同步的，那么它们的依赖类型和（例如联合类型）也是同步的。这确保了联合类型中的每个选项都可以在线程之间安全共享，从而整个联合类型也是同步的。

---

### 总结：
这两个公式说明了如何在多线程编程中处理依赖类型的积（如函数类型）和和（如联合类型）。无论是函数类型的参数还是联合类型的分支，只要它们的组成部分是同步的，那么整个类型也可以在线程之间安全传递和使用。



### 公式 1：
$$
\Gamma \vdash (\forall \bar{\alpha}. fn(F : \mathbb{E}; \bar{\tau}) \to \tau) \; sync
$$

#### 解释：
- **前提**：在上下文 $\Gamma$ 中，带有生命周期参数 $\bar{\alpha}$ 的函数类型 $(\forall \bar{\alpha}. fn(F : \mathbb{E}; \bar{\tau}) \to \tau)$ 是同步类型。这意味着函数类型的所有参数 $\bar{\tau}$ 以及返回值 $\tau$ 都可以在线程之间安全传递。
  
- **结论**：该公式得出结论，这样的函数类型在上下文 $\Gamma$ 中也是同步的，表示这个函数类型可以安全地在多线程环境下共享。

#### 总结：
这个规则说明，在 Rust 等语言中，如果一个函数的参数类型和返回类型可以被安全地在线程间传递，那么整个函数类型也是同步的。这对于并发编程中的函数类型非常重要。

---

### 公式 2：
$$
\Gamma \vdash T \; sync
$$

#### 解释：
- **前提**：在上下文 $\Gamma$ 中，类型 $T$ 是同步的（即，$T$ 可以安全地在线程之间共享）。
  
- **结论**：$T$ 可以在线程之间同步传递，这意味着类型 $T$ 中的所有值都可以安全共享。

#### 总结：
这个规则表明，$T$ 类型如果是同步的，那么它的所有实例都可以安全地在线程之间传递，不会引发数据竞争。这适用于多线程编程中需要保证类型安全的场景。



### 公式：
$$
\frac{\Gamma, T : type \vdash \tau \; sync}{\Gamma \vdash \mu T. \tau \; sync}
$$

### 解释：

#### 前提部分：
- **$\Gamma, T : type \vdash \tau \; sync$**：在上下文 $\Gamma$ 中，假设类型 $T$ 是一个类型（即 $T : type$），并且类型 $\tau$ 是同步类型，这意味着在这种上下文中，类型 $\tau$ 可以在线程之间安全传递。

#### 结论部分：
- **$\Gamma \vdash \mu T. \tau \; sync$**：推导得出，在上下文 $\Gamma$ 中，由类型 $T$ 和 $\tau$ 递归定义的类型 $\mu T. \tau$ 也是同步类型。换句话说，递归类型 $\mu T. \tau$ 也可以安全地在线程之间共享。

### 总结：
该规则表明，如果某个递归类型的体类型 $\tau$ 是同步的，那么整个递归类型 $\mu T. \tau$ 也是同步的。这对于定义复杂的数据结构（如树或图）并在多线程环境中使用非常重要。

### --------------------------

### 公式：
$$
\frac{\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \kappa \subseteq \kappa' \quad \Gamma \mid \mathbb{E}; \mathbb{L} \vdash \kappa' \subseteq \kappa''}{\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \kappa \subseteq \kappa''}
$$

### 解释：

#### 前提部分：
- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \kappa \subseteq \kappa'$**：在上下文 $\Gamma$ 和环境 $\mathbb{E}$ 以及生命周期集合 $\mathbb{L}$ 中，生命周期 $\kappa$ 被包含在 $\kappa'$ 内。也就是说，$\kappa$ 的生命周期完全位于 $\kappa'$ 的范围内。
  
- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \kappa' \subseteq \kappa''$**：在同样的上下文 $\Gamma$、环境 $\mathbb{E}$ 和生命周期集合 $\mathbb{L}$ 中，生命周期 $\kappa'$ 被包含在 $\kappa''$ 中。这意味着 $\kappa'$ 的生命周期也完全位于 $\kappa''$ 的范围内。

#### 结论部分：
- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \kappa \subseteq \kappa''$**：基于前提，我们可以推导出生命周期 $\kappa$ 被包含在 $\kappa''$ 中。即生命周期的包含关系是具有传递性的：如果 $\kappa$ 包含在 $\kappa'$ 中，而 $\kappa'$ 包含在 $\kappa''$ 中，那么 $\kappa$ 也包含在 $\kappa''$ 中。

### 总结：
此规则描述了生命周期包含关系的传递性。如果一个生命周期 $\kappa$ 包含在 $\kappa'$ 中，且 $\kappa'$ 又包含在 $\kappa''$ 中，则可以得出结论 $\kappa$ 也被包含在 $\kappa''$ 中。该规则对推导复杂的生命周期关系非常重要，尤其是在 Rust 等语言中处理生命周期参数时，它确保了生命周期的逻辑一致性。

### ------------------------------

### 公式 1: 空外部生命周期上下文可满足性规则

#### 公式：
$$
\text{Esat-empty} \quad \frac{}{\Gamma \mid \mathbb{E}_1; \mathbb{L}_1 \vdash \emptyset}
$$

#### 解释：
这个规则表示当我们有一个空的外部生命周期上下文时，它是可满足的。也就是说，如果没有外部生命周期约束，那么这种情况下的外部生命周期上下文是 trivially 可满足的。这个公式表示的是一个基本情况，没有任何需要验证的生命周期包含关系。

---

### 公式 2: 包含性外部生命周期上下文可满足性规则

#### 公式：
$$
\text{Esat-incl} \quad \frac{\Gamma \mid \mathbb{E}_1; \mathbb{L}_1 \vdash \kappa \subseteq \kappa' \quad \Gamma \mid \mathbb{E}_1; \mathbb{L}_1 \vdash \mathbb{E}_2}{\Gamma \mid \mathbb{E}_1; \mathbb{L}_1 \vdash \mathbb{E}_2, \kappa \subseteq_e \kappa'}
$$

#### 解释：
该规则描述了如何在已有的外部生命周期上下文 $\mathbb{E}_1$ 中加入新的生命周期包含关系 $\kappa \subseteq_e \kappa'$，并且验证新的上下文仍然是可满足的。

- **$\Gamma \mid \mathbb{E}_1; \mathbb{L}_1 \vdash \kappa \subseteq \kappa'$**：这意味着在上下文 $\Gamma$ 和环境 $\mathbb{E}_1$ 中，$\kappa$ 包含在 $\kappa'$ 中的关系是可满足的。

- **$\Gamma \mid \mathbb{E}_1; \mathbb{L}_1 \vdash \mathbb{E}_2$**：表示环境 $\mathbb{E}_2$ 在相同的上下文和环境下也是可满足的。

**结论部分：**
结合这些前提，我们可以推导出扩展后的生命周期上下文 $\mathbb{E}_2, \kappa \subseteq_e \kappa'$ 也是可满足的。这一规则确保了当我们向现有的生命周期上下文添加新的约束时，整个上下文仍然保持一致性和可满足性。

---

### 总结：
这两条规则定义了在 Rust 等语言中，如何处理外部生命周期上下文的可满足性。第一条规则描述了空上下文的 trivially 可满足性，第二条规则则描述了如何通过添加生命周期包含关系，保证扩展后的上下文仍然是可满足的。这些规则帮助我们确保生命周期约束的一致性，并保证程序的安全性。

### --------------------------

### 公式 1: 空类型上下文解锁规则

#### 公式：
$$
\text{TUnblock-empty} \quad \frac{}{\Gamma \vdash \emptyset \Rightarrow^{\dagger \kappa} \emptyset}
$$

#### 解释：
这个公式描述了在类型上下文中，当没有阻塞时，如何解锁一个空上下文。它表示当我们有一个空的类型上下文时，不存在阻塞的内容，这个空上下文可以被 trivially 解锁。

- **$\Gamma \vdash \emptyset \Rightarrow^{\dagger \kappa} \emptyset$**：在上下文 $\Gamma$ 中，一个空的类型上下文 $\emptyset$ 解锁为空的上下文 $\emptyset$，并且没有任何约束（$\kappa$ 可以是任意的）。

这个公式是关于类型推导中阻塞解除的基本情况：如果没有任何类型待解锁，空上下文自然是已解锁的。

---

### 公式 2: 类型上下文解锁规则

#### 公式：
$$
\Gamma \vdash T_1 \Rightarrow^{\dagger \kappa} T_2
$$

#### 解释：
这个公式表示在上下文 $\Gamma$ 中，类型 $T_1$ 在特定的生命周期约束 $\kappa$ 下能够解锁为类型 $T_2$。解锁类型上下文是编译器在处理类型依赖时的一步，特别是对于某些类型需要解除阻塞才能进一步推导出结果。

- **$\Gamma \vdash T_1$**：上下文 $\Gamma$ 中的初始类型 $T_1$。

- **$\Rightarrow^{\dagger \kappa}$**：表示类型 $T_1$ 在某个生命周期或类型约束 $\kappa$ 的作用下进行解锁。

- **$T_2$**：最终解锁后得到的类型。

这个推导规则用来处理在 Rust 或类似语言中，复杂类型间的依赖关系，特别是当某些类型必须解除阻塞（如等待生命周期或类型推导完成）后才能进一步操作时。

---

### 总结：
这两个推导规则帮助我们理解类型上下文的解锁过程。第一个公式描述了在没有阻塞内容的情况下，空上下文自然是 trivially 可解锁的。第二个公式描述了在特定约束下，类型从一种形式解锁为另一种形式的过程，特别适用于类型系统中存在依赖关系或生命周期限制的情况。

### -------------------------

### 公式：子类型推导规则

#### 公式：
$$
\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau_1 \Rightarrow \tau_2
$$

#### 解释：

这个推导规则描述了在上下文 $\Gamma$ 中，如何判断类型 $\tau_1$ 是类型 $\tau_2$ 的子类型。这是在类型系统中确定一个类型是否可以安全地替换为另一个类型的关键步骤，通常称为*子类型关系*。

### 前提部分：
- **$\Gamma$**：表示类型推导的上下文环境，包含变量及其类型信息。
  
- **$\mathbb{E}$ 和 $\mathbb{L}$**：分别表示外部上下文和局部上下文，可能与生命周期或其他类型相关的约束有关。

- **$\tau_1$ 和 $\tau_2$**：分别表示两个类型，推导的目标是验证 $\tau_1$ 是否可以被认为是 $\tau_2$ 的子类型。

### 结论部分：
- **$\tau_1 \Rightarrow \tau_2$**：表示通过推导，得出 $\tau_1$ 可以被认为是 $\tau_2$ 的子类型，即 $\tau_1$ 的所有实例都可以安全地用 $\tau_2$ 替代。

### 总结：
这个推导规则用于确定在给定上下文中，类型 $\tau_1$ 是否为类型 $\tau_2$ 的子类型。它是类型系统中进行类型替换和保证类型安全的基础。



### 公式：反身性规则

#### 公式：
$$
\text{T-REFL} \quad \frac{}{\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau \Rightarrow \tau}
$$

#### 解释：

这个推导规则 **T-REFL** 表示*类型的反身性*，即任意类型 $\tau$ 都是它自身的子类型。这一规则不需要任何前提条件，因为反身性在任何上下文下都成立。

### 结论部分：
- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau \Rightarrow \tau$**：表示在上下文 $\Gamma$ 和 $\mathbb{E}$ 以及 $\mathbb{L}$ 的环境下，类型 $\tau$ 是它自身的子类型。这意味着类型可以在需要相同类型的地方安全地使用自己。

### 总结：
反身性规则是子类型系统中最基本的规则之一，它保证了任何类型 $\tau$ 都可以安全地用作其自身的替代类型。这种反身性保证了类型系统中的一致性。



### 公式：类型的传递性规则

#### 公式：
$$
\text{T-TRANS} \quad \frac{\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau \Rightarrow \tau' \quad \Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau' \Rightarrow \tau''}{\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau \Rightarrow \tau''}
$$

#### 解释：

这个推导规则 **T-TRANS** 表示*类型的传递性*，即如果类型 $\tau$ 是 $\tau'$ 的子类型，而 $\tau'$ 又是 $\tau''$ 的子类型，那么我们可以推导出 $\tau$ 也是 $\tau''$ 的子类型。

### 前提部分：
- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau \Rightarrow \tau'$**：在上下文 $\Gamma$ 和 $\mathbb{E}$，以及生命周期环境 $\mathbb{L}$ 下，类型 $\tau$ 是类型 $\tau'$ 的子类型。
  
- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau' \Rightarrow \tau''$**：在同样的上下文和环境下，类型 $\tau'$ 是类型 $\tau''$ 的子类型。

### 结论部分：
- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau \Rightarrow \tau''$**：基于传递性规则，我们可以得出类型 $\tau$ 是 $\tau''$ 的子类型。

### 总结：
传递性是子类型系统中的一个重要特性，它保证了如果存在多个子类型关系链条，可以通过传递性推导出更广泛的子类型关系。这对于构造更加灵活和扩展性的类型系统非常重要。



### 公式：类型推导规则 - 未初始化产品类型

#### 公式：
$$
\text{T-UNINIT-PROD} \quad \Gamma \mid \mathbb{E}; \mathbb{L} \vdash \downarrow \Sigma_n \iff \Pi \downarrow_n
$$

#### 解释：

这个推导规则 **T-UNINIT-PROD** 描述了未初始化的乘积类型和未初始化的依赖类型 $\Pi$ 之间的等价关系。

### 前提部分：
- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \downarrow \Sigma_n$**：在上下文 $\Gamma$，环境 $\mathbb{E}$，以及生命周期环境 $\mathbb{L}$ 中，表示未初始化的乘积类型 $\Sigma_n$。
  
### 结论部分：
- **$\Pi \downarrow_n$**：该规则表明未初始化的依赖类型 $\Pi_n$ 可以与未初始化的乘积类型 $\Sigma_n$ 相互转换。

### 总结：
该规则的主要目的是通过将乘积类型 $\Sigma_n$ 和依赖类型 $\Pi_n$ 建立等价关系，从而在类型系统中进行更灵活的转换。未初始化类型的这种规则确保了在构造未初始化数据结构时，可以从产品类型转换为依赖类型，反之亦然。这种推导在类型检查过程中起到了优化和灵活处理类型的作用。



### 公式：递归类型推导规则 (T-REC)

#### 公式：
$$
\frac{
\forall \tau_1', \tau_2'. (\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau_1' \Rightarrow \tau_2') \Rightarrow (\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau_1[\tau_1'/T_1] \Rightarrow \tau_2[\tau_2'/T_2])
}{
\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \mu T_1. \tau_1 \Rightarrow \mu T_2. \tau_2
}
$$

#### 解释：

**T-REC** 规则定义了递归类型的推导过程，这对于处理复杂的数据结构（如树和链表）非常重要。

### 前提部分：
- **$\forall \tau_1', \tau_2'$**：对于任意的类型 $\tau_1'$ 和 $\tau_2'$，我们将类型递归体中的类型变量 $T_1$ 和 $T_2$ 替换为 $\tau_1'$ 和 $\tau_2'$。
  
- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau_1' \Rightarrow \tau_2'$**：在上下文 $\Gamma$、表达式环境 $\mathbb{E}$ 和生命周期环境 $\mathbb{L}$ 下，类型 $\tau_1'$ 可以推导为类型 $\tau_2'$。
  
- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau_1[\tau_1'/T_1] \Rightarrow \tau_2[\tau_2'/T_2]$**：在递归类型 $T_1$ 和 $T_2$ 中，将类型变量替换后，$\tau_1$ 可以推导到 $\tau_2$。

### 结论部分：
- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \mu T_1. \tau_1 \Rightarrow \mu T_2. \tau_2$**：整个递归类型 $\mu T_1. \tau_1$ 和 $\mu T_2. \tau_2$ 可以推导成功，表明这两个递归类型在所有替换下都是一致的。

### 总结：
该规则解释了递归类型在类型系统中的推导方式。递归类型的推导要确保在递归展开的每一步中，递归体的类型推导始终保持一致。通过这种递归替换和推导，可以确保类型的正确性与一致性



### 公式：共享引用推导规则 (T-BOR-SHR)

#### 公式：
$$
\frac{\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau_1 \Rightarrow \tau_2}
{\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \&^{\kappa}_{shr} \tau_1 \Rightarrow \&^{\kappa}_{shr} \tau_2}
$$

### 解释：

该规则用于推导共享引用类型在 Rust 类型系统中的一致性。Rust 中的共享引用通常是不可变的引用，它们可以在多个上下文中共享使用，但不能被修改。

### 前提部分：
- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau_1 \Rightarrow \tau_2$**：在上下文 $\Gamma$、表达式环境 $\mathbb{E}$ 和生命周期环境 $\mathbb{L}$ 中，类型 $\tau_1$ 可以推导为类型 $\tau_2$。这表示在没有引用的情况下，$\tau_1$ 和 $\tau_2$ 是一致的。

### 结论部分：
- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \&^{\kappa}_{shr} \tau_1 \Rightarrow \&^{\kappa}_{shr} \tau_2$**：在同样的上下文和环境下，带有生命周期标记 $\kappa$ 的共享引用 $\&^{\kappa}_{shr} \tau_1$ 可以推导为 $\&^{\kappa}_{shr} \tau_2$，即两个共享引用类型是相容的。

### 总结：
该规则说明了共享引用类型的推导规则。如果两个类型 $\tau_1$ 和 $\tau_2$ 是相容的，那么它们各自的共享引用 $\&^{\kappa}_{shr} \tau_1$ 和 $\&^{\kappa}_{shr} \tau_2$ 也是相容的。共享引用类型的推导涉及生命周期 $\kappa$，但本质上是对引用的类型推导关系进行递归处理。



### 公式：可变引用推导规则 (T-BOR-MUT)

#### 公式：
$$
\frac{\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau_1 \Leftrightarrow \tau_2}
{\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \&^{\kappa}_{mut} \tau_1 \Leftrightarrow \&^{\kappa}_{mut} \tau_2}
$$

### 解释：

该规则用于推导 Rust 中可变引用类型的相容性。在 Rust 中，可变引用允许在某一时间点对数据进行独占修改，因此在类型推导上具有更严格的要求。

### 前提部分：
- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau_1 \Leftrightarrow \tau_2$**：在上下文 $\Gamma$、表达式环境 $\mathbb{E}$ 和生命周期环境 $\mathbb{L}$ 中，类型 $\tau_1$ 和 $\tau_2$ 是可互换的（即双向相容）。这意味着 $\tau_1$ 可以被看作 $\tau_2$，反之亦然。

### 结论部分：
- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \&^{\kappa}_{mut} \tau_1 \Leftrightarrow \&^{\kappa}_{mut} \tau_2$**：在相同的上下文和环境中，带有生命周期标记 $\kappa$ 的可变引用 $\&^{\kappa}_{mut} \tau_1$ 和 $\&^{\kappa}_{mut} \tau_2$ 是相容的。这意味着如果 $\tau_1$ 和 $\tau_2$ 是相容的，那么它们的可变引用类型也是相容的。

### 总结：
该规则说明了 Rust 中可变引用的推导规则。若两个类型 $\tau_1$ 和 $\tau_2$ 是双向相容的，则它们各自的可变引用 $\&^{\kappa}_{mut} \tau_1$ 和 $\&^{\kappa}_{mut} \tau_2$ 也是相容的。这个规则适用于 Rust 中的所有可变引用类型推导，确保了引用类型的一致性和安全性。



### 公式：乘积类型推导规则 (T-PROD)

#### 公式：
$$
\frac{\forall i. \Gamma \mid \mathbb{E}; \mathbb{L} \vdash \bar{\tau}_i \Rightarrow \bar{\tau}'_i}
{\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \Pi \bar{\tau} \Rightarrow \Pi \bar{\tau}'}
$$

### 解释：

该推导规则用于乘积类型的相容性。乘积类型（通常用于元组类型的定义）是由若干个类型的笛卡尔积构成的，它们彼此之间的推导关系会影响到整个乘积类型的相容性。

### 前提部分：
- **$\forall i. \Gamma \mid \mathbb{E}; \mathbb{L} \vdash \bar{\tau}_i \Rightarrow \bar{\tau}'_i$**：对于每个索引 $i$，在上下文 $\Gamma$、表达式环境 $\mathbb{E}$ 和生命周期环境 $\mathbb{L}$ 中，类型 $\bar{\tau}_i$ 和 $\bar{\tau}'_i$ 是相容的。这里的相容性意味着 $\bar{\tau}_i$ 类型可以被看作 $\bar{\tau}'_i$ 类型。

### 结论部分：
- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \Pi \bar{\tau} \Rightarrow \Pi \bar{\tau}'$**：在同一上下文和环境中，乘积类型 $\Pi \bar{\tau}$ 和 $\Pi \bar{\tau}'$ 也是相容的。也就是说，如果每个组成类型 $\bar{\tau}_i$ 和 $\bar{\tau}'_i$ 是相容的，那么由这些类型构成的乘积类型 $\Pi \bar{\tau}$ 和 $\Pi \bar{\tau}'$ 也是相容的。

### 总结：
此规则阐述了乘积类型相容性的推导过程。在 Rust 这类强类型语言中，当多个类型组成元组或结构体时，必须确保每个组成部分的类型相容，才能确保整体类型的相容性。这个规则用于推导出乘积类型的类型安全性。



### 公式：和类型推导规则 (T-SUM)

#### 公式：
$$
\frac{\forall i. \Gamma \mid \mathbb{E}; \mathbb{L} \vdash \bar{\tau}_i \Rightarrow \bar{\tau}'_i}
{\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \Sigma \bar{\tau} \Rightarrow \Sigma \bar{\tau}'}
$$

### 解释：

该推导规则用于 **和类型** 的相容性验证。在类型理论中，和类型（Sum types）通常用于表示一种类型可能是多个类型中的任意一个，类似于枚举或代数数据类型的选择分支。推导和类型的相容性时，需要确保所有组成类型都分别相容。

### 前提部分：
- **$\forall i. \Gamma \mid \mathbb{E}; \mathbb{L} \vdash \bar{\tau}_i \Rightarrow \bar{\tau}'_i$**：在上下文 $\Gamma$，表达式环境 $\mathbb{E}$ 和生命周期环境 $\mathbb{L}$ 中，对于每个索引 $i$，类型 $\bar{\tau}_i$ 和 $\bar{\tau}'_i$ 是相容的。这意味着对于所有可能的选项（构成和类型的各个类型），每一个类型都相容。

### 结论部分：
- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \Sigma \bar{\tau} \Rightarrow \Sigma \bar{\tau}'$**：如果每个组成类型 $\bar{\tau}_i$ 和 $\bar{\tau}'_i$ 是相容的，则整个和类型 $\Sigma \bar{\tau}$ 和 $\Sigma \bar{\tau}'$ 也是相容的。这说明了如果各个选项类型相容，整个和类型也是相容的。

### 总结：
此规则表达了如何验证和类型的相容性。和类型是用于表示类型间的“选择”，例如一个变量可以是整数或者布尔值。这个推导规则确保所有可选类型都相容时，整个和类型的相容性才能成立。这在 Rust 之类的系统语言中经常用于验证代数数据类型的安全性和正确性。



### 公式：带有生命周期的函数类型推导规则

#### 公式：
$$
\frac{
\forall i. \Gamma, \bar{\alpha}', \mathcal{F} : lft \mid \mathbb{E}', \mathbb{E}_0; \mathbb{L}_0 \vdash \bar{\tau}'_i \Rightarrow \bar{\tau}_i \quad \Gamma, \bar{\alpha}', \mathcal{F} : lft \mid \mathbb{E}', \mathbb{E}_0; \mathbb{L}_0 \vdash \tau \Rightarrow \tau'
}{
\Gamma \mid \mathbb{E}_0; \mathbb{L}_0 \vdash \forall \bar{\alpha}. fn(\mathcal{F} : \mathbb{E}; \bar{\tau}) \to \tau \Rightarrow \forall \bar{\alpha}'. fn(\mathcal{F} : \mathbb{E}'; \bar{\tau}') \to \tau'
}
$$

### 解释：

此推导规则描述了 **带有生命周期参数的函数类型** 的相容性验证。带有生命周期的函数类型在许多系统编程语言中都非常重要，尤其是像 Rust 这样的语言，在处理内存生命周期时提供了静态保证。

### 前提部分：
- **$\forall i. \Gamma, \bar{\alpha}', \mathcal{F} : lft \mid \mathbb{E}', \mathbb{E}_0; \mathbb{L}_0 \vdash \bar{\tau}'_i \Rightarrow \bar{\tau}_i$**：对于每个参数类型 $\bar{\tau}_i$，在上下文 $\Gamma$ 和生命周期变量 $\bar{\alpha}'$，函数 $\mathcal{F}$ 的环境 $\mathbb{E}'$ 中， $\bar{\tau}_i$ 和 $\bar{\tau}'_i$ 是相容的。  
- **$\Gamma, \bar{\alpha}', \mathcal{F} : lft \mid \mathbb{E}', \mathbb{E}_0; \mathbb{L}_0 \vdash \tau \Rightarrow \tau'$**：在相同上下文中，返回类型 $\tau$ 和 $\tau'$ 也需要相容。

### 结论部分：
- **$\Gamma \mid \mathbb{E}_0; \mathbb{L}_0 \vdash \forall \bar{\alpha}. fn(\mathcal{F} : \mathbb{E}; \bar{\tau}) \to \tau \Rightarrow \forall \bar{\alpha}'. fn(\mathcal{F} : \mathbb{E}'; \bar{\tau}') \to \tau'$**：基于前面的前提，我们得出结论，带有生命周期参数 $\forall \bar{\alpha}$ 的函数类型 $\forall \bar{\alpha}. fn(\mathcal{F} : \mathbb{E}; \bar{\tau}) \to \tau$ 与带有不同生命周期参数 $\forall \bar{\alpha}'$ 的函数类型 $\forall \bar{\alpha}'. fn(\mathcal{F} : \mathbb{E}'; \bar{\tau}') \to \tau'$ 是相容的。

### 总结：
此推导规则确保了在带有生命周期的系统中，函数类型在不同生命周期参数下仍然是相容的。特别是在 Rust 这样的语言中，生命周期用于管理内存的借用关系，确保内存安全。因此，这个规则帮助验证函数签名在不同生命周期环境下的合法性。

### -------------------------------

### 公式：子类型推导规则

#### 公式：
$$
\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau_1 \Rightarrow \tau_2
$$

### 解释：

此推导规则描述了在上下文 $\Gamma$、表达式环境 $\mathbb{E}$ 和生命周期上下文 $\mathbb{L}$ 中，类型 $\tau_1$ 是否可以作为 $\tau_2$ 的子类型。子类型化规则用于检查两个类型之间是否存在包含关系，从而确定它们的兼容性。

#### 前提部分：
- **$\Gamma \mid \mathbb{E}; \mathbb{L}$**：在上下文 $\Gamma$ 中，结合表达式环境 $\mathbb{E}$ 和生命周期上下文 $\mathbb{L}$，我们定义两个类型的相对关系。
  
- **$\tau_1 \Rightarrow \tau_2$**：表示在给定上下文下，类型 $\tau_1$ 是类型 $\tau_2$ 的子类型。即，$\tau_1$ 可以被用作 $\tau_2$ 的替代品，且可以安全使用。

### 总结：
该推导规则用于验证两个类型之间的子类型关系。在编程语言类型系统中，子类型关系保证了在某些上下文中，较具体的类型（子类型）可以安全替换较抽象的类型（超类型），这种关系确保了灵活性和安全性。



### 公式：反身性推导规则（T-REFL）

#### 公式：
$$
\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau \Rightarrow \tau
$$

### 解释：

此推导规则描述了**类型的反身性**。即，在给定上下文 $\Gamma$、表达式环境 $\mathbb{E}$ 和生命周期上下文 $\mathbb{L}$ 中，类型 $\tau$ 总是它自身的子类型。这是子类型化关系中的一个基本原则。

#### 前提部分：
- **$\Gamma \mid \mathbb{E}; \mathbb{L}$**：表示类型检查的上下文，包括程序的上下文 $\Gamma$、表达式的上下文 $\mathbb{E}$ 和生命周期 $\mathbb{L}$。
  
- **$\tau \Rightarrow \tau$**：表示类型 $\tau$ 自己是自己的子类型，即反身性。

### 结论部分：
- **反身性**：对于任何类型 $\tau$，它总是它自身的子类型。因此，不论在哪种上下文中，只要类型是相同的，它们就具备子类型关系。

### 总结：
此规则反映了类型系统中的反身性原则。在编程语言的类型推导中，反身性是基本的属性，保证了每个类型都可以作为自己类型的子类型。这确保了类型系统的基本一致性。



### 公式：传递性推导规则（T-TRANS）

#### 公式：
$$
\frac{\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau \Rightarrow \tau' \quad \Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau' \Rightarrow \tau''}
{\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau \Rightarrow \tau''}
$$

### 解释：

此推导规则描述了**类型的传递性**。在给定上下文 $\Gamma$、表达式环境 $\mathbb{E}$ 和生命周期上下文 $\mathbb{L}$ 中，如果类型 $\tau$ 是 $\tau'$ 的子类型，并且 $\tau'$ 又是 $\tau''$ 的子类型，那么我们可以得出结论 $\tau$ 也是 $\tau''$ 的子类型。

#### 前提部分：
- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau \Rightarrow \tau'$**：在上下文 $\Gamma$、表达式环境 $\mathbb{E}$ 和生命周期上下文 $\mathbb{L}$ 中，$\tau$ 是 $\tau'$ 的子类型。
  
- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau' \Rightarrow \tau''$**：在相同上下文下，$\tau'$ 是 $\tau''$ 的子类型。

#### 结论部分：
- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau \Rightarrow \tau''$**：基于传递性，可以得出结论，$\tau$ 是 $\tau''$ 的子类型。即，如果 $\tau$ 是 $\tau'$ 的子类型，且 $\tau'$ 是 $\tau''$ 的子类型，那么 $\tau$ 也是 $\tau''$ 的子类型。

### 总结：
此规则说明了类型推导中的传递性原则。传递性是子类型关系中的一个重要性质，保证了类型系统中的推导过程是连续的。如果一个类型链中的每一环都是子类型关系，那么这一链的两端类型也具备子类型关系。



### 公式：未初始化的乘积类型（T-UNINIT-PROD）

#### 公式：
$$
\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \downarrow \Sigma_{\bar{n}} \Leftrightarrow \Pi \downarrow_{\bar{n}}
$$

### 解释：

这个推导规则说明了未初始化的数据结构在乘积类型和其他结构之间的关系，通常用于处理未初始化的内存或数据，确保其类型的一致性。

#### 前提部分：
- **$\downarrow \Sigma_{\bar{n}}$**：这指的是未初始化的和类型（Sum type），可以理解为在不同的分支上没有初始化数据的情形。
  
- **$\Pi \downarrow_{\bar{n}}$**：这指的是未初始化的乘积类型（Product type）。它表明在每个分量 $\bar{n}$ 上未初始化的乘积类型需要满足某些条件。

#### 结论部分：
- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \downarrow \Sigma_{\bar{n}} \Leftrightarrow \Pi \downarrow_{\bar{n}}$**：在给定上下文 $\Gamma$、表达式环境 $\mathbb{E}$ 和生命周期环境 $\mathbb{L}$ 中，如果 $\Sigma_{\bar{n}}$（和类型）是未初始化的，它等价于每个成分 $\bar{n}$ 上的乘积类型 $\Pi \downarrow_{\bar{n}}$ 也是未初始化的。

### 总结：
此规则是关于未初始化状态的数据结构处理，特别是在乘积类型的情形下。未初始化的乘积类型和未初始化的和类型之间的等价关系表明，当处理复杂的数据类型时，所有部分都必须满足未初始化状态的约束。这在低级语言或系统编程中尤其重要，因为它可以防止使用未初始化的数据导致的错误。



### 公式：递归类型的子类型规则（T-REC）

#### 公式：
$$
\frac{\forall \tau_1', \tau_2'. (\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau_1' \Rightarrow \tau_2') \Rightarrow (\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau_1[\tau_1'/T_1] \Rightarrow \tau_2[\tau_2'/T_2])}{\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \mu T_1 . \tau_1 \Rightarrow \mu T_2 . \tau_2}
$$

### 解释：

此推导规则描述了递归类型之间的子类型关系。在涉及递归类型的类型系统中，通常会有类型通过自引用定义自身，这个规则提供了如何处理递归类型之间的子类型关系的方法。

#### 前提部分：
- **$\forall \tau_1', \tau_2'. (\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau_1' \Rightarrow \tau_2')$**：对于任意的两个类型 $\tau_1'$ 和 $\tau_2'$，我们假定在上下文 $\Gamma$，表达式环境 $\mathbb{E}$，和生命周期环境 $\mathbb{L}$ 中，$\tau_1'$ 是 $\tau_2'$ 的子类型。

- **$(\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau_1[\tau_1'/T_1] \Rightarrow \tau_2[\tau_2'/T_2])$**：在 $\tau_1'$ 和 $\tau_2'$ 替换递归类型 $T_1$ 和 $T_2$ 的上下文中，$\tau_1[\tau_1'/T_1]$ 是 $\tau_2[\tau_2'/T_2]$ 的子类型。这一步保证了递归结构中的替换是类型安全的。

#### 结论部分：
- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \mu T_1 . \tau_1 \Rightarrow \mu T_2 . \tau_2$**：递归类型 $\mu T_1 . \tau_1$ 是递归类型 $\mu T_2 . \tau_2$ 的子类型。如果递归的每一层的类型 $\tau_1$ 和 $\tau_2$ 之间满足子类型关系，则整个递归类型也满足子类型关系。

### 总结：
这个规则处理递归类型之间的子类型关系，递归类型是通过自我引用定义的复杂类型。在系统中，为了保证类型安全，递归类型的子类型关系需要递归地验证每一层的子类型关系。这个推导规则使用了替换技巧，以确保递归类型的展开是类型安全的。



### 公式：共享引用的子类型规则（T-BOR-SHR）

#### 公式：
$$
\frac{\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau_1 \Rightarrow \tau_2}{\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \&^{\kappa}_{shr} \tau_1 \Rightarrow \&^{\kappa}_{shr} \tau_2}
$$

### 解释：

此推导规则描述了共享引用（shared borrow）类型之间的子类型关系。在 Rust 类型系统中，引用（borrow）是一种类型系统特性，它通过借用机制控制所有权和生命周期。此规则具体针对共享引用。

#### 前提部分：
- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau_1 \Rightarrow \tau_2$**：在上下文 $\Gamma$ 和表达式环境 $\mathbb{E}$，生命周期环境 $\mathbb{L}$ 中，类型 $\tau_1$ 是 $\tau_2$ 的子类型。

#### 结论部分：
- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \&^{\kappa}_{shr} \tau_1 \Rightarrow \&^{\kappa}_{shr} \tau_2$**：基于前提，如果 $\tau_1$ 是 $\tau_2$ 的子类型，则共享引用类型 $\&^{\kappa}_{shr} \tau_1$ 也是 $\&^{\kappa}_{shr} \tau_2$ 的子类型。这里的 $\&^{\kappa}_{shr}$ 表示共享引用，且 $\kappa$ 是引用的生命周期。

### 总结：
该规则确保在共享引用中保持子类型关系。如果类型 $\tau_1$ 和 $\tau_2$ 具有子类型关系，那么相应的共享引用 $\&^{\kappa}_{shr}$ 也应保留这种子类型关系。这是为了在保证引用安全的同时支持类型多态性。





### 公式：可变引用的双向子类型规则（T-BOR-MUT）

#### 公式：
$$
\frac{\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau_1 \Leftrightarrow \tau_2}{\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \&^{\kappa}_{mut} \tau_1 \Leftrightarrow \&^{\kappa}_{mut} \tau_2}
$$

### 解释：

此推导规则描述了**可变引用**（mutable borrow）类型之间的双向子类型关系。在 Rust 等系统编程语言中，可变引用允许对数据进行修改，而该规则保证了在引用的生命周期内保持类型的双向子类型关系。

#### 前提部分：
- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau_1 \Leftrightarrow \tau_2$**：在上下文 $\Gamma$ 和表达式环境 $\mathbb{E}$，生命周期环境 $\mathbb{L}$ 中，类型 $\tau_1$ 和 $\tau_2$ 之间存在双向子类型关系（即 $\tau_1$ 是 $\tau_2$ 的子类型，且反过来 $\tau_2$ 也是 $\tau_1$ 的子类型）。

#### 结论部分：
- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \&^{\kappa}_{mut} \tau_1 \Leftrightarrow \&^{\kappa}_{mut} \tau_2$**：基于前提，类型 $\tau_1$ 和 $\tau_2$ 的双向子类型关系会扩展到它们的可变引用上。如果 $\tau_1$ 和 $\tau_2$ 是双向子类型，那么 $\&^{\kappa}_{mut} \tau_1$ 和 $\&^{\kappa}_{mut} \tau_2$ 也必须是双向子类型。这里的 $\&^{\kappa}_{mut}$ 表示具有生命周期 $\kappa$ 的可变引用。

### 总结：
该规则用于确保当两个类型之间具有双向子类型关系时，其可变引用也保留该关系。在系统编程中，保证引用类型之间的正确关系对于内存安全和多态性非常重要。





### 公式：乘积类型和和类型的子类型规则（T-PROD 和 T-SUM）

#### 公式：

##### 乘积类型（T-PROD）
$$
\frac{\forall i. \Gamma \mid \mathbb{E}; \mathbb{L} \vdash \bar{\tau}_i \Rightarrow \bar{\tau}'_i}{\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \Pi \bar{\tau} \Rightarrow \Pi \bar{\tau}'}
$$

##### 和类型（T-SUM）
$$
\frac{\forall i. \Gamma \mid \mathbb{E}; \mathbb{L} \vdash \bar{\tau}_i \Rightarrow \bar{\tau}'_i}{\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \Sigma \bar{\tau} \Rightarrow \Sigma \bar{\tau}'}
$$

### 解释：

这两个推导规则分别定义了**乘积类型**和**和类型**的子类型关系。

#### 前提部分：
- **$\forall i. \Gamma \mid \mathbb{E}; \mathbb{L} \vdash \bar{\tau}_i \Rightarrow \bar{\tau}'_i$**：对于所有的索引 $i$，在上下文 $\Gamma$ 和表达式环境 $\mathbb{E}$，生命周期环境 $\mathbb{L}$ 中，类型 $\bar{\tau}_i$ 是 $\bar{\tau}'_i$ 的子类型。这意味着在每一个具体类型 $i$ 上，原类型到目标类型的子类型关系成立。

#### 结论部分：
- **乘积类型（T-PROD）**：$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \Pi \bar{\tau} \Rightarrow \Pi \bar{\tau}'$，如果所有分量类型 $\bar{\tau}_i$ 到 $\bar{\tau}'_i$ 的子类型关系成立，那么乘积类型 $\Pi \bar{\tau}$ 到 $\Pi \bar{\tau}'$ 的子类型关系也成立。
  
- **和类型（T-SUM）**：$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \Sigma \bar{\tau} \Rightarrow \Sigma \bar{\tau}'$，如果所有分量类型 $\bar{\tau}_i$ 到 $\bar{\tau}'_i$ 的子类型关系成立，那么和类型 $\Sigma \bar{\tau}$ 到 $\Sigma \bar{\tau}'$ 的子类型关系也成立。

### 总结：
这两个推导规则分别用于验证乘积类型和和类型在各个分量类型都满足子类型关系的情况下，整个类型也保持子类型关系。在系统编程语言如 Rust 中，乘积类型（如元组）和和类型（如枚举）都是重要的类型构造工具。



### 公式 1：乘积类型的子类型规则 (T-PROD)

#### 公式：
$$
\frac{\forall i. \Gamma \mid \mathbb{E}; \mathbb{L} \vdash \bar{\tau}_i \Rightarrow \bar{\tau}'_i}{\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \Pi \bar{\tau} \Rightarrow \Pi \bar{\tau}'}
$$

### 解释：

#### 前提部分：
- **$\forall i. \Gamma \mid \mathbb{E}; \mathbb{L} \vdash \bar{\tau}_i \Rightarrow \bar{\tau}'_i$**：在上下文 $\Gamma$ 和表达式环境 $\mathbb{E}$，生命周期环境 $\mathbb{L}$ 下，所有的类型 $\bar{\tau}_i$ 都是 $\bar{\tau}'_i$ 的子类型。这意味着每个元素类型 $\bar{\tau}_i$ 到 $\bar{\tau}'_i$ 的子类型关系成立。

#### 结论部分：
- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \Pi \bar{\tau} \Rightarrow \Pi \bar{\tau}'$**：基于前提中对每个分量类型的子类型关系成立，可以得出整个乘积类型 $\Pi \bar{\tau}$ 到 $\Pi \bar{\tau}'$ 的子类型关系也成立。换句话说，乘积类型（如元组类型）是通过其分量类型的子类型关系来推导整体的子类型关系的。

### 总结：
乘积类型的子类型规则表明，如果每个分量类型之间都存在子类型关系，那么乘积类型本身也会保持子类型关系。这适用于诸如元组或结构体类型的场景。


---

### 公式 2：和类型的子类型规则 (T-SUM)

#### 公式：
$$
\frac{\forall i. \Gamma \mid \mathbb{E}; \mathbb{L} \vdash \bar{\tau}_i \Rightarrow \bar{\tau}'_i}{\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \Sigma \bar{\tau} \Rightarrow \Sigma \bar{\tau}'}
$$

### 解释：

#### 前提部分：
- **$\forall i. \Gamma \mid \mathbb{E}; \mathbb{L} \vdash \bar{\tau}_i \Rightarrow \bar{\tau}'_i$**：在上下文 $\Gamma$ 和表达式环境 $\mathbb{E}$，生命周期环境 $\mathbb{L}$ 下，所有的类型 $\bar{\tau}_i$ 都是 $\bar{\tau}'_i$ 的子类型。这意味着每个元素类型 $\bar{\tau}_i$ 到 $\bar{\tau}'_i$ 的子类型关系成立。

#### 结论部分：
- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \Sigma \bar{\tau} \Rightarrow \Sigma \bar{\tau}'$**：基于前提中的每个分量类型的子类型关系成立，可以推导出整个和类型 $\Sigma \bar{\tau}$ 到 $\Sigma \bar{\tau}'$ 的子类型关系成立。和类型通常对应枚举类型，它允许一个值在不同类型的分支之间进行选择。

### 总结：
和类型的子类型规则表明，如果每个分量类型之间存在子类型关系，那么和类型整体也会继承子类型关系。这通常在枚举类型中使用，如果每个分支的类型保持子类型关系，那么枚举类型整体也会保持这种关系。

---

这两个推导规则的核心思想都是基于类型构造中的子类型关系的传递性，分别适用于乘积类型和和类型。



### 公式：带有生命周期参数的函数类型规则 (T-FN)

#### 公式：
$$
\frac{\Gamma, \bar{\alpha}', F : lft \mid \mathbb{E}', \mathbb{E}_0, \mathbb{L}_0 \vdash \mathbb{E}[\bar{\kappa} / \bar{\alpha}]}{\forall i. \Gamma, \bar{\alpha}', F : lft \mid \mathbb{E}', \mathbb{E}_0, \mathbb{L}_0 \vdash \bar{\tau}'_i \Rightarrow \bar{\tau}_i \quad \Gamma, \bar{\alpha}', F : lft \mid \mathbb{E}', \mathbb{E}_0, \mathbb{L}_0 \vdash \tau' \Rightarrow \tau}{\Gamma \mid \mathbb{E}_0, \mathbb{L}_0 \vdash \forall \bar{\alpha}. fn(F : \mathbb{E}; \bar{\tau}) \to \tau \Rightarrow \forall \bar{\alpha}'. fn(F : \mathbb{E}'; \bar{\tau}') \to \tau'}
$$

---

### 解释：

#### 前提部分：

1. **$\Gamma, \bar{\alpha}', F : lft \mid \mathbb{E}', \mathbb{E}_0, \mathbb{L}_0 \vdash \mathbb{E}[\bar{\kappa} / \bar{\alpha}]$**：在上下文 $\Gamma$ 和生命周期变量 $\bar{\alpha}'$ 的环境下，类型环境 $\mathbb{E}$ 经过生命周期替换 $\bar{\kappa} / \bar{\alpha}$ 后，仍然是良构的。

2. **$\forall i. \Gamma, \bar{\alpha}', F : lft \mid \mathbb{E}', \mathbb{E}_0, \mathbb{L}_0 \vdash \bar{\tau}'_i \Rightarrow \bar{\tau}_i$**：对于每个函数参数类型 $\bar{\tau}_i$，其在 $\mathbb{E}', \mathbb{E}_0, \mathbb{L}_0$ 环境下的版本 $\bar{\tau}'_i$ 是 $\bar{\tau}_i$ 的子类型。

3. **$\Gamma, \bar{\alpha}', F : lft \mid \mathbb{E}', \mathbb{E}_0, \mathbb{L}_0 \vdash \tau' \Rightarrow \tau$**：返回类型 $\tau'$ 是 $\tau$ 的子类型。

#### 结论部分：

- **$\Gamma \mid \mathbb{E}_0, \mathbb{L}_0 \vdash \forall \bar{\alpha}. fn(F : \mathbb{E}; \bar{\tau}) \to \tau \Rightarrow \forall \bar{\alpha}'. fn(F : \mathbb{E}'; \bar{\tau}') \to \tau'$**：基于前提条件，我们可以推导出，函数类型 $\forall \bar{\alpha}. fn(F : \mathbb{E}; \bar{\tau}) \to \tau$ 到 $\forall \bar{\alpha}'. fn(F : \mathbb{E}'; \bar{\tau}') \to \tau'$ 之间的子类型关系成立。

---

### 总结：

这个推导规则说明了带有生命周期参数的函数类型如何保持其子类型关系。具体而言，生命周期变量、函数参数类型、返回类型必须满足特定的良构条件和子类型关系，才能得出整个函数类型的子类型关系。

### ------------------------------------

### 公式：类型转换规则 (Type Coercion)

#### 公式：
$$
\Gamma \mid \mathbb{E}, \mathbb{L} \vdash T_1 \Rightarrow T_2
$$

---

### 解释：

1. **$\Gamma$**：上下文 $\Gamma$ 包含了当前作用域下的类型声明和变量绑定。

2. **$\mathbb{E}, \mathbb{L}$**：$\mathbb{E}$ 代表表达式环境，$\mathbb{L}$ 代表生命周期上下文。两者结合表明了类型检查的环境，包括生命周期和作用域的约束条件。

3. **$T_1$ 和 $T_2$**：这是类型之间的关系，$T_1$ 是原始类型，而 $T_2$ 是目标类型。通过这个规则，我们可以得出在上下文 $\Gamma \mid \mathbb{E}, \mathbb{L}$ 中，类型 $T_1$ 可以被强制转换为类型 $T_2$。

---

### 总结：

此推导规则用于说明如何在特定上下文中，基于现有的生命周期和类型环境，完成类型 $T_1$ 向 $T_2$ 的转换。



### C-PERM 规则详解

#### 公式：
$$
\frac{T' \text{ is a permutation of } T}{\Gamma \mid \mathbb{E}, \mathbb{L} \vdash T \Rightarrow T'}
$$

#### 解释：
- **$T' \text{ is a permutation of } T$**：这里表示 $T'$ 是 $T$ 的排列，即 $T'$ 是通过重新排列 $T$ 的元素或组成部分而得到的。
- **$\Gamma \mid \mathbb{E}, \mathbb{L} \vdash T \Rightarrow T'$**：该规则表明，如果 $T'$ 是 $T$ 的排列，那么在给定的上下文 $\Gamma$ 和表达式环境 $\mathbb{E}$、生命周期上下文 $\mathbb{L}$ 中，类型 $T$ 可以被强制转换为 $T'$。

### C-FRAME 规则详解

#### 公式：
$$
\frac{\Gamma \mid \mathbb{E}, \mathbb{L} \vdash T_1 \Rightarrow T_2}{\Gamma \mid \mathbb{E}, \mathbb{L} \vdash T', T_1 \Rightarrow T', T_2}
$$

#### 解释：
- **$\Gamma \mid \mathbb{E}, \mathbb{L} \vdash T_1 \Rightarrow T_2$**：这是前提，表示在上下文 $\Gamma$ 和表达式环境 $\mathbb{E}$、生命周期上下文 $\mathbb{L}$ 中，类型 $T_1$ 可以被强制转换为类型 $T_2$。
- **$\Gamma \mid \mathbb{E}, \mathbb{L} \vdash T', T_1 \Rightarrow T', T_2$**：结论表明，如果在上下文 $\Gamma$ 中存在从 $T_1$ 到 $T_2$ 的转换，那么同样可以在 $T_1$ 前附加任何 $T'$，并且得出 $T', T_1$ 到 $T', T_2$ 的转换。这种规则通常用于保持在复合类型（例如元组）中的转换一致性。

---

### 总结：

- **C-PERM** 规则用于处理类型的排列变化，确保排列后的类型仍然可以相互转换。
- **C-FRAME** 规则用于确保在复合类型中的转换规则可以扩展到更复杂的上下文中，即在不改变主要转换关系的前提下添加额外的类型。



### C-SPLIT-BOR 规则详解

#### 公式：
$$
\frac{\bar{\tau} \neq [] \quad \forall i. m_i = \sum_{j<i} \text{size}(\bar{\tau}_j)}{\Gamma \mid \mathbb{E}, \mathbb{L} \vdash p \triangleleft \&^{\kappa_\mu} \Pi \bar{\tau} \Leftrightarrow p.m \triangleleft \&^{\kappa_\mu} \tau}
$$

#### 解释：

- **$\bar{\tau} \neq []$**：这个条件表明 $\bar{\tau}$ 不是空列表。该条件保证了当前推导规则适用于有内容的类型集合 $\bar{\tau}$。

- **$\forall i. m_i = \sum_{j<i} \text{size}(\bar{\tau}_j)$**：这一部分表示，对于每个索引 $i$，$m_i$ 的值是前 $i$ 个 $\bar{\tau}$ 类型的大小总和。$\text{size}(\bar{\tau}_j)$ 表示第 $j$ 个 $\bar{\tau}$ 类型的大小。这可以看作是处理复合类型中每个类型的内存大小的计算方式。

- **$\Gamma \mid \mathbb{E}, \mathbb{L} \vdash p \triangleleft \&^{\kappa_\mu} \Pi \bar{\tau} \Leftrightarrow p.m \triangleleft \&^{\kappa_\mu} \tau$**：在上下文 $\Gamma$、表达式环境 $\mathbb{E}$ 和生命周期上下文 $\mathbb{L}$ 中，引用类型 $\&^{\kappa_\mu} \Pi \bar{\tau}$ 可以拆分成多个子类型 $\&^{\kappa_\mu} \tau$。具体地，$p$ 的左值指向类型 $\&^{\kappa_\mu} \Pi \bar{\tau}$，其中 $\Pi$ 表示一个复合类型，且可以等价于引用子类型 $\&^{\kappa_\mu} \tau$，但这个过程会根据 $m_i$ 的大小进行相应的偏移处理。

### 总结：

C-SPLIT-BOR 规则解释了复合引用类型 $\&^{\kappa_\mu} \Pi \bar{\tau}$ 是如何分解为较小的类型引用 $\&^{\kappa_\mu} \tau$ 的。它的关键点是使用了类型的大小信息来确保拆分操作的正确性，每个偏移量 $m_i$ 取决于前面类型的大小和相应的索引位置。

### ------------------------------

### Continuation Coercion 规则详解

#### 公式：
$$
\Gamma \mid \mathbb{E} \vdash \mathbf{K}_1 \Rightarrow \mathbf{K}_2
$$

#### 解释：

- **$\Gamma \mid \mathbb{E}$**：这一部分表示在上下文 $\Gamma$ 和表达式环境 $\mathbb{E}$ 中执行推导。$\Gamma$ 包含了类型信息和绑定，$\mathbb{E}$ 则表示当前的表达式状态。

- **$\mathbf{K}_1 \Rightarrow \mathbf{K}_2$**：这是对续延 (continuation) 类型的强制转换，即将类型 $\mathbf{K}_1$ 强制转换为类型 $\mathbf{K}_2$。这类转换通常出现在计算的控制流从一个状态转移到另一个状态的场景中，典型的应用是 CPS (Continuation-Passing Style) 中的类型转换。

#### 续延 (Continuation)：

在函数式编程中，**续延** 是表示某个计算后续步骤的抽象。在某些编程语言（如 Scheme 或 CPS）中，函数的返回值会被传递给一个续延，而不是直接返回。续延实际上是一种捕获程序执行状态的抽象机制，用于控制程序的执行流。

#### 规则的作用：

这个推导规则表明，在给定的上下文和表达式环境下，允许将一个续延类型 $\mathbf{K}_1$ 强制转换为另一个续延类型 $\mathbf{K}_2$。这通常是为了适应不同计算之间的衔接，确保不同的控制流可以顺利切换。

### 总结：

- 此规则用于确保不同的续延类型之间的兼容性，允许从一个续延类型转换为另一个。这对于 CPS 转换中，尤其是涉及到复杂的控制流时尤为重要。



### 左侧公式详解

#### 公式：
$$
\frac{\mathbf{K}' \text{ is a permutation of } \mathbf{K}}{\Gamma \mid \mathbb{E} \vdash \mathbf{K} \Rightarrow \mathbf{K}'}
$$

#### 解释：

- **$\mathbf{K}' \text{ is a permutation of } \mathbf{K}$**：这意味着 $\mathbf{K}'$ 是 $\mathbf{K}$ 的排列。这一前提意味着我们可以通过重新排列 $\mathbf{K}$ 中的元素来得到 $\mathbf{K}'$。在某些情况下，类型、表达式或参数的顺序可能并不影响推导过程，因此不同排列的顺延 $\mathbf{K}$ 和 $\mathbf{K}'$ 之间是可以相互转换的。

- **$\Gamma \mid \mathbb{E} \vdash \mathbf{K} \Rightarrow \mathbf{K}'$**：在上下文 $\Gamma$ 和表达式环境 $\mathbb{E}$ 中，续延 $\mathbf{K}$ 可以被强制转换为排列后的续延 $\mathbf{K}'$。这种排列不会影响推导的正确性。

#### 规则的作用：

这个规则允许我们在续延的排列之间进行转换，而不改变类型的含义或功能。它表示在某些编程场景中，续延的顺序不影响程序的执行。

### 右侧公式详解

#### 公式：
$$
\Gamma \mid \mathbb{E} \vdash \mathbf{K}, \mathbf{K}' \Rightarrow \mathbf{K}
$$

#### 解释：

- **$\mathbf{K}, \mathbf{K}'$**：表示两个续延 $\mathbf{K}$ 和 $\mathbf{K}'$。在此规则中，它们同时出现在表达式的上下文中。

- **$\Gamma \mid \mathbb{E} \vdash \mathbf{K}, \mathbf{K}' \Rightarrow \mathbf{K}$**：表示在上下文 $\Gamma$ 和表达式环境 $\mathbb{E}$ 中，续延 $\mathbf{K}, \mathbf{K}'$ 可以被转换为续延 $\mathbf{K}$。这意味着，在某些场景下，续延 $\mathbf{K}'$ 可以被忽略，或者它可以被看作是 $\mathbf{K}$ 的一部分。

#### 规则的作用：

这个推导规则允许我们在续延的多个实例之间进行合并或简化。在控制流涉及多个续延时，这种合并和简化是常见的操作，尤其是在续延传递风格 (CPS) 中。

### 总结：
- 左侧规则表示不同排列的续延可以相互转换，不影响推导。
- 右侧规则表示多个续延的表达式可以被简化为一个续延。这在某些复杂控制流的情况下很有用。



### 公式详解

#### 公式：
$$
\frac{\Gamma \mid \mathbb{E} \vdash \mathbf{K} \Rightarrow \mathbf{K}' \quad \Gamma, \bar{x} : \text{val} \mid \mathbb{E}; \mathbb{L} \vdash T' \Rightarrow T}{\Gamma \mid \mathbb{E} \vdash \mathbf{K}, k \triangleleft \text{cont}(\mathbb{L}; \bar{x} : T) \Rightarrow \mathbf{K}', k \triangleleft \text{cont}(\mathbb{L}; \bar{x} : T')}
$$

#### 解释：

- **$\Gamma \mid \mathbb{E} \vdash \mathbf{K} \Rightarrow \mathbf{K}'$**：在上下文 $\Gamma$ 和表达式环境 $\mathbb{E}$ 中，续延 $\mathbf{K}$ 可以被强制转换为续延 $\mathbf{K}'$。这一前提类似于我们在前面解释的续延排列规则，表明 $\mathbf{K}$ 与 $\mathbf{K}'$ 可以通过某种方式相互转换。

- **$\Gamma, \bar{x} : \text{val} \mid \mathbb{E}; \mathbb{L} \vdash T' \Rightarrow T$**：在上下文 $\Gamma$ 和 $\bar{x} : \text{val}$（表示 $\bar{x}$ 是一个值）以及表达式环境 $\mathbb{E}$ 和额外的环境 $\mathbb{L}$ 中，类型 $T'$ 可以被转换为类型 $T$。这意味着某个值类型的转换是可能的，具体取决于它在环境中的表现。

- **$\Gamma \mid \mathbb{E} \vdash \mathbf{K}, k \triangleleft \text{cont}(\mathbb{L}; \bar{x} : T) \Rightarrow \mathbf{K}', k \triangleleft \text{cont}(\mathbb{L}; \bar{x} : T')$**：结论部分指出，在上下文 $\Gamma$ 和表达式环境 $\mathbb{E}$ 中，带有续延 $\mathbf{K}$ 和某个控制操作符 $k$ 的表达式可以转换为续延 $\mathbf{K}'$ 和经过转换的控制操作符 $k$。这里的 $\text{cont}(\mathbb{L}; \bar{x} : T)$ 表示一个带有上下文 $\mathbb{L}$ 和类型 $T$ 的控制操作符，而这一转换改变了该操作符的类型 $T$ 为 $T'$。

#### 规则的作用：

这个推导规则描述了控制流中的续延转换以及值类型的强制转换。在带有控制操作符（如函数式编程中的 continuation）的表达式中，该规则允许我们将续延 $\mathbf{K}$ 转换为 $\mathbf{K}'$，同时对值类型进行适当的类型强制转换。这在处理复杂的控制流时非常有用，例如 continuation-passing style (CPS) 中。

### ------------------------------

### Well-typed instructions.公式详解

#### 公式：
$$
\Gamma \mid \mathbb{E}; \mathbb{L} \mid T_1 \vdash I \rightarrow x . T_2
$$

#### 解释：

- **$\Gamma \mid \mathbb{E}; \mathbb{L}$**：这是表示类型上下文 $\Gamma$ 和表达式上下文 $\mathbb{E}$ 以及生命周期上下文 $\mathbb{L}$ 的整体环境。这些上下文共同提供了定义约束和作用域的环境，确保类型在操作中是合法的。

- **$T_1$**：类型 $T_1$ 是操作符 $I$ 的输入类型，表明我们当前处理的数据或表达的值具有类型 $T_1$。

- **$I$**：指代某个操作指令或计算指令。在该推导规则中，指令 $I$ 执行某种操作，在执行过程中可以改变某个值 $x$ 的类型。

- **$x$**：操作执行之后的值。这个值可能是某个变量或某个表达式的结果，其类型可能因操作而改变。

- **$T_2$**：表示指令 $I$ 执行之后，变量 $x$ 被赋予的新类型。换句话说，在执行了指令 $I$ 后，$x$ 的类型从 $T_1$ 变成了 $T_2$。

#### 结论部分：
推导的结论是，在上述上下文环境中，操作 $I$ 将类型 $T_1$ 的变量 $x$ 转换为具有类型 $T_2$ 的变量。这个规则表明了在执行某些操作之后，变量或表达式的类型发生变化时，如何确保类型的正确性。

#### 规则的作用：

此推导规则用于验证给定上下文中的指令是否是类型良构的。这种验证确保了在系统的类型检查过程中，操作在不违反类型安全的前提下进行。



### 公式 $S\text{-}TRUE$ 详解：

#### 公式：
$$
\Gamma \mid \mathbb{E}; \mathbb{L} \mid \emptyset \vdash true \triangleright x . x \triangleleft bool
$$

#### 解释：
- **$\Gamma$**：类型上下文，表示当前的环境中包含的变量和它们的类型。
  
- **$\mathbb{E}; \mathbb{L}$**：表达式和生命周期上下文。这些上下文帮助跟踪变量的作用域、生命周期和表达式的相关性。

- **$\emptyset$**：这是表示空上下文，意味着在当前的推导过程中没有附加的假设或额外的条件。

- **$true$**：表示布尔常量值 `true`。

- **$x$**：表示一个变量，其值由 `true` 来表示。

- **$x \triangleleft bool$**：表示变量 $x$ 的类型是 $bool$。

#### 总结：
这个推导规则说明，在给定的上下文中，布尔值 `true` 可以赋予给变量 $x$，并且该变量具有 `bool` 类型。该规则表明了在类型检查过程中，如何确保常量 `true` 的类型安全性。

---

### 公式 $S\text{-}FALSE$ 详解：

#### 公式：
$$
\Gamma \mid \mathbb{E}; \mathbb{L} \mid \emptyset \vdash false \triangleright x . x \triangleleft bool
$$

#### 解释：
- **$\Gamma$**：类型上下文，表示当前环境中包含的变量和它们的类型。

- **$\mathbb{E}; \mathbb{L}$**：表达式和生命周期上下文。它们帮助确保表达式中的生命周期和作用域被正确追踪。

- **$\emptyset$**：表示当前没有额外的假设或约束。

- **$false$**：表示布尔常量值 `false`。

- **$x$**：表示一个变量，其值由 `false` 来表示。

- **$x \triangleleft bool$**：表示变量 $x$ 的类型是 $bool$。

#### 总结：
此推导规则说明了，在给定的上下文中，布尔值 `false` 可以赋予变量 $x$，并且该变量将拥有 `bool` 类型。这个规则展示了如何在类型检查中确保常量 `false` 的类型安全性。

---

这两个规则的目的都是为了确保布尔类型的常量 `true` 和 `false` 的类型推导正确，保持类型安全性。



### 公式 $S\text{-}NAT\text{-}OP$ 详解

#### 公式：
$$
\Gamma \mid \mathbb{E}; \mathbb{L} \mid p_1 \triangleleft int, p_2 \triangleleft int \vdash p_1 \{+, -\} p_2 \triangleright x . x \triangleleft int
$$

#### 解释：
- **$\Gamma$**：类型上下文，记录了变量及其类型。

- **$\mathbb{E}; \mathbb{L}$**：表达式和生命周期上下文，确保表达式在有效的生命周期内处理。

- **$p_1 \triangleleft int, p_2 \triangleleft int$**：这是前提，表示 $p_1$ 和 $p_2$ 是整数类型。这个部分确保了操作数 $p_1$ 和 $p_2$ 都是 `int` 类型，因为加法或减法运算只对整数有效。

- **$p_1 \{+, -\} p_2$**：表示两个整数 $p_1$ 和 $p_2$ 之间的加法或减法运算。这里的符号 $\{+, -\}$ 表示可以是加法运算也可以是减法运算。

- **$x \triangleleft int$**：表示结果 $x$ 是整数类型。这个部分确保了操作的结果也是 `int` 类型。

#### 总结：
此推导规则说明了如何在表达式中进行整数加法或减法操作，并确保操作数和结果的类型都是整数 (`int`)。在上下文 $\Gamma$ 中，如果两个操作数都是 `int`，那么运算结果也是 `int` 类型。这个规则确保了算术操作的类型安全性。



### 公式 $S\text{-}DEREF\text{-}BOR\text{-}OWN$ 详解

#### 公式：
$$
\frac{\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \kappa \ alive}{\Gamma \mid \mathbb{E}; \mathbb{L} \mid p \triangleleft \&^{\kappa}_{\mu} own_n \ \tau \vdash *p \triangleright x . x \triangleleft \&^{\kappa}_{\mu} \tau}
$$

#### 解释：

- **$\Gamma$**: 类型上下文，记录变量及其类型，确保在当前上下文中类型的合法性。

- **$\mathbb{E}; \mathbb{L}$**: 表达式和生命周期上下文，确保表达式在有效生命周期内处理。

- **$\kappa \ alive$**: 这是前提，表示在上下文 $\Gamma \mid \mathbb{E}; \mathbb{L}$ 下，生命周期 $\kappa$ 仍然是存活的（有效的）。这一条件确保了引用指针在其生命周期范围内是可操作的。

- **$p \triangleleft \&^{\kappa}_{\mu} own_n \ \tau$**: 这是前提，表示指针 $p$ 是一种拥有的（owning）指针，指向类型 $\tau$ 的数据，并且受生命周期 $\kappa$ 的约束。

- **$*p$**: 这是对指针 $p$ 的解引用操作。通过该操作，可以访问指针所指向的值。

- **$x \triangleleft \&^{\kappa}_{\mu} \tau$**: 表示解引用后得到的值 $x$ 依然是类型 $\&^{\kappa}_{\mu} \tau$ 的指针，且遵循相同的生命周期和可变性规则。

#### 总结：
此推导规则描述了在拥有指针的情况下，如何通过解引用操作访问指针所指向的值，并确保类型及生命周期的一致性。在上下文 $\Gamma$ 下，如果生命周期 $\kappa$ 仍然有效，且 $p$ 是指向类型 $\tau$ 的拥有指针，那么通过解引用 $p$ 可以得到类型仍然为 $\&^{\kappa}_{\mu} \tau$ 的值。



### 公式 $S\text{-}DEREF\text{-}BOR\text{-}MUT$ 详解

#### 公式：
$$
\frac{\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \kappa \ alive \quad \Gamma \mid \mathbb{E}; \mathbb{L} \vdash \kappa \subseteq \kappa'}{\Gamma \mid \mathbb{E}; \mathbb{L} \mid p \triangleleft \&^{\kappa}_{\mu} \&^{\kappa'}_{mut} \tau \vdash *p \triangleright x . x \triangleleft \&^{\kappa}_{\mu} \tau}
$$

#### 解释：

- **$\Gamma$**: 类型上下文，记录当前作用域中变量的类型信息。

- **$\mathbb{E}; \mathbb{L}$**: 这是表达式和生命周期上下文，描述了程序中表达式的生命周期和环境信息。

- **$\kappa \ alive$**: 表示在上下文中，生命周期 $\kappa$ 是有效的（存活的）。该前提确保了生命周期在解引用操作中不会无效。

- **$\kappa \subseteq \kappa'$**: 表示生命周期 $\kappa$ 是生命周期 $\kappa'$ 的子集，或者说 $\kappa'$ 的生命周期至少和 $\kappa$ 一样长，确保指针的安全性。

- **$p \triangleleft \&^{\kappa}_{\mu} \&^{\kappa'}_{mut} \tau$**: 表示指针 $p$ 指向一个可变引用，该引用指向类型 $\tau$ 的数据，并且由两个生命周期 $\kappa$ 和 $\kappa'$ 控制，其中 $\kappa'$ 控制的是内部的可变引用。

- **$*p$**: 对指针 $p$ 进行解引用操作，访问其指向的值。

- **$x \triangleleft \&^{\kappa}_{\mu} \tau$**: 解引用后，得到的值 $x$ 仍然是生命周期 $\kappa$ 控制的类型 $\&^{\kappa}_{\mu} \tau$ 的值，表示该值具有相同的类型和生命周期规则。

#### 总结：
此推导规则描述了在多重引用、可变引用的场景下，如何通过解引用操作访问引用的值。在此规则中，确保生命周期 $\kappa$ 有效，并且 $\kappa$ 是 $\kappa'$ 的子集，然后可以通过解引用可变引用访问值，并且类型和生命周期的属性得到保持和验证。这种规则有助于在复杂生命周期管理中确保类型安全性。



### 公式 $S\text{-}SUM\text{-}ASSGN\text{-}UNIT$ 详解

#### 公式：
$$
\frac{\bar{\tau}_i = \Pi[\ ] \quad \Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau_1 \multimap \Sigma \bar{\tau'}}{\Gamma \mid \mathbb{E}; \mathbb{L} \mid p \triangleleft \tau_1 \vdash p := () \triangleright inj^i \ p \triangleleft \tau_1'}
$$

#### 解释：

- **$\bar{\tau}_i = \Pi[\ ]$**: 表示 $\bar{\tau}_i$ 是一个空的笛卡尔积（$\Pi$ 表示积类型，$\Pi[\ ]$ 意味着没有元素的积），这个前提指出了类型 $\bar{\tau}_i$ 的具体形式是空积。

- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau_1 \multimap \Sigma \bar{\tau'}$**: 这个前提表示在上下文 $\Gamma$ 和环境 $\mathbb{E}; \mathbb{L}$ 中，类型 $\tau_1$ 可以映射到一个求和类型 $\Sigma \bar{\tau'}$。这里 $\multimap$ 表示类型 $\tau_1$ 到类型 $\Sigma \bar{\tau'}$ 的转换关系，$\Sigma$ 表示的是类型 $\bar{\tau'}$ 的求和类型。

- **$p \triangleleft \tau_1$**: 表示指针 $p$ 指向类型 $\tau_1$ 的值。

- **$p := ()$**: 表示将指针 $p$ 赋值为单位元素 $()$，单位元素通常代表没有值或者空值。

- **$inj^i \ p$**: 表示通过第 $i$ 个注入操作 $inj^i$，将 $p$ 注入到求和类型中，形成 $inj^i(p)$。

- **$p \triangleleft \tau_1'$**: 表示最终的 $p$ 指向一个新类型 $\tau_1'$ 的值。

#### 总结：
这个推导规则描述了在处理空积类型和求和类型时的赋值操作。具体来说，当类型 $\bar{\tau}_i$ 是空积时，可以对指针 $p$ 进行单位赋值 $p := ()$，然后通过注入操作将其转换为一个求和类型的成员。这种规则在多态类型和代数数据类型的处理过程中至关重要。



### 公式 $S\text{-}MEMCPY$ 详解

#### 公式：
$$
\frac{size(\tau) = n \quad \Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau_1 \multimap^\tau \tau_1' \quad \Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau_2 \multimap^\tau \tau_2'}{\Gamma \mid \mathbb{E}; \mathbb{L} \mid p_1 \triangleleft \tau_1, p_2 \triangleleft \tau_2 \vdash p_1 :=_n *p_2 \triangleright p_1 \triangleleft \tau_1', p_2 \triangleleft \tau_2'}
$$

#### 解释：

- **$size(\tau) = n$**: 这个前提表示类型 $\tau$ 的大小是 $n$，也就是说类型 $\tau$ 占用了 $n$ 个存储单位。

- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau_1 \multimap^\tau \tau_1'$**: 在上下文 $\Gamma$ 和环境 $\mathbb{E}; \mathbb{L}$ 中，类型 $\tau_1$ 可以转换为类型 $\tau_1'$，其中 $^\tau$ 表示转换的类型大小受到 $\tau$ 的影响。

- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau_2 \multimap^\tau \tau_2'$**: 同样，在相同的上下文中，类型 $\tau_2$ 可以转换为类型 $\tau_2'$，并且转换的类型大小同样受 $\tau$ 的大小控制。

- **$p_1 \triangleleft \tau_1, p_2 \triangleleft \tau_2$**: 表示两个指针 $p_1$ 和 $p_2$ 分别指向类型 $\tau_1$ 和 $\tau_2$ 的值。

- **$p_1 :=_n *p_2$**: 表示指针 $p_1$ 将从指针 $p_2$ 指向的值中拷贝 $n$ 个存储单元的内容。$:=_n$ 指定了这个赋值操作的大小为 $n$，即执行一个内存拷贝操作。

- **$p_1 \triangleleft \tau_1', p_2 \triangleleft \tau_2'$**: 最终，$p_1$ 指向的是新的类型 $\tau_1'$，而 $p_2$ 也指向类型 $\tau_2'$ 的值。

#### 总结：
这个推导规则描述了内存拷贝（memcpy）的操作。通过检查类型大小 $n$ 并确定两种类型之间的转换关系，规则表明如何从指针 $p_2$ 拷贝内存到 $p_1$，并更新指针指向的新类型值。



### 公式 $S\text{-}SUM\text{-}MEMCPY$ 详解

#### 公式：
$$
\frac{size(\tau) = n \quad \Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau_1 \multimap_{\Sigma \bar{\tau}} \tau_1' \quad \Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau_2 \multimap^\tau \tau_2' \quad \bar{\tau}_i = \tau}{\Gamma \mid \mathbb{E}; \mathbb{L} \mid p_1 \triangleleft \tau_1, p_2 \triangleleft \tau_2 \vdash p_1 :=_n inj^i(*p_2) \triangleright p_1 \triangleleft \tau_1', p_2 \triangleleft \tau_2'}
$$

#### 解释：

- **$size(\tau) = n$**: 这个前提表示类型 $\tau$ 的大小是 $n$，即 $\tau$ 占用了 $n$ 个存储单元。

- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau_1 \multimap_{\Sigma \bar{\tau}} \tau_1'$**: 在上下文 $\Gamma$ 和环境 $\mathbb{E}; \mathbb{L}$ 中，类型 $\tau_1$ 可以通过加权合并 $\Sigma$ 进行转换为 $\tau_1'$。

- **$\Gamma \mid \mathbb{E}; \mathbb{L} \vdash \tau_2 \multimap^\tau \tau_2'$**: 同样地，类型 $\tau_2$ 可以转换为 $\tau_2'$，其中转换的大小由 $\tau$ 决定。

- **$\bar{\tau}_i = \tau$**: 表示参数列表 $\bar{\tau}$ 的第 $i$ 个元素等于 $\tau$。

- **$p_1 \triangleleft \tau_1, p_2 \triangleleft \tau_2$**: 表示指针 $p_1$ 和 $p_2$ 分别指向类型 $\tau_1$ 和 $\tau_2$ 的值。

- **$p_1 :=_n inj^i(*p_2)$**: 这是一个内存拷贝操作。指针 $p_1$ 从指针 $p_2$ 所指向的值中拷贝 $n$ 个存储单元，并将其注入类型 $i$ 中。$inj^i$ 是表示从 $p_2$ 中注入第 $i$ 个构造函数的操作。

- **$p_1 \triangleleft \tau_1', p_2 \triangleleft \tau_2'$**: 最终，指针 $p_1$ 和 $p_2$ 分别更新为新的类型 $\tau_1'$ 和 $\tau_2'$。

#### 总结：
这个推导规则描述了针对 sum 类型的内存拷贝操作（memcpy）。它通过检查类型 $\tau$ 的大小，并在两种类型 $\tau_1$ 和 $\tau_2$ 之间执行拷贝操作，将 $p_2$ 的值注入到 $p_1$ 中并转换为新的类型。

### ----------------------------------

### Well-typed functions公式详解

#### 公式：
$$
\Gamma \mid \mathbb{E}; \mathbb{L} \mid \mathbb{K}; \mathbb{T} \vdash F
$$

#### 解释：

- **$\Gamma \mid \mathbb{E}; \mathbb{L}$**: 这是上下文和环境部分。$\Gamma$ 是常规类型上下文，$\mathbb{E}$ 和 $\mathbb{L}$ 分别表示当前的外部和局部环境，它们描述了变量、类型、生命周期等。

- **$\mathbb{K}; \mathbb{T}$**: 这部分定义了函数的相关约束和类型。$\mathbb{K}$ 代表函数体内的约束，如类型变量、生命周期等，$\mathbb{T}$ 表示函数参数及其类型。

- **$\vdash F$**: 表示推导结果，$F$ 是函数的定义。根据以上环境和约束，推导出该函数 $F$ 的类型和其他属性。

#### 总结：
这个规则表示一个良构函数的推导方式。在已知上下文、局部环境、约束和参数类型的情况下，推导函数 $F$ 的类型是否符合预期。这一规则可用于确保函数的定义满足所有类型检查条件，尤其是在泛型、多参数和生命周期的复杂场景下。



### 公式详解

#### 公式：
$$
\frac{\Gamma \mid \mathbb{E}, \alpha \subseteq_e \kappa, \kappa \subseteq_e \alpha; \mathbb{L} \mid \mathbb{K}; \mathbb{T} \vdash F}{\Gamma \mid \mathbb{E}; \mathbb{L}, \alpha \subseteq [\kappa] \mid \mathbb{K}; \mathbb{T} \vdash F}
$$

#### 解释：

- **$\Gamma \mid \mathbb{E}, \alpha \subseteq_e \kappa, \kappa \subseteq_e \alpha$**: 这是推导规则的前提部分，表示在上下文 $\Gamma$ 和外部环境 $\mathbb{E}$ 中，有一个变量 $\alpha$ 满足生命周期子集关系 $\subseteq_e$，即 $\alpha$ 的生命周期包含于 $\kappa$，并且反过来 $\kappa$ 的生命周期也包含于 $\alpha$。这个前提表示 $\alpha$ 和 $\kappa$ 互为包含。

- **$\mathbb{L} \mid \mathbb{K}; \mathbb{T}$**: 这是局部环境、约束和参数类型。$\mathbb{L}$ 是局部的生命周期环境，$\mathbb{K}$ 是与函数相关的约束，$\mathbb{T}$ 是函数的参数类型。

- **$\vdash F$**: 推导函数 $F$ 在给定的上下文和环境下是否良构。

- **结论部分**:
  - **$\Gamma \mid \mathbb{E}; \mathbb{L}, \alpha \subseteq [\kappa] \mid \mathbb{K}; \mathbb{T} \vdash F$**: 推导的结论表示，更新后的局部环境 $\mathbb{L}$ 中包含 $\alpha \subseteq [\kappa]$，这意味着 $\alpha$ 被约束在 $\kappa$ 的生命周期中。这表明我们可以在局部环境中使用这个约束继续推导函数 $F$ 的良构性。

#### 总结：
这个推导规则用于处理生命周期的等价性问题。它表明如果 $\alpha$ 和 $\kappa$ 互相包含（即它们的生命周期等价），那么可以在局部环境中将 $\alpha$ 的生命周期限制为 $\kappa$ 的生命周期。这一规则有助于在涉及生命周期推导的场景中处理生命周期变量的约束，使得函数能够在严格的生命周期限制下良构。



### 公式详解

#### 公式：
$$
\frac{
\Gamma \mid \mathbb{E}; \mathbb{L} \mid \mathbb{K}; \mathbb{T} \vdash F_1 \quad \Gamma \mid \mathbb{E}; \mathbb{L} \mid \mathbb{K}; \mathbb{T} \vdash F_2
}
{
\Gamma \mid \mathbb{E}; \mathbb{L} \mid \mathbb{K}; \mathbb{T}, p \triangleleft bool \vdash if \ p \ then \ F_1 \ else \ F_2
}
$$

#### 解释：

- **前提部分**:
  - **$\Gamma \mid \mathbb{E}; \mathbb{L} \mid \mathbb{K}; \mathbb{T} \vdash F_1$**：在上下文 $\Gamma$ 和环境 $\mathbb{E}$ 下，局部环境 $\mathbb{L}$ 及约束 $\mathbb{K}$ 和类型环境 $\mathbb{T}$ 下，推导出分支 $F_1$ 是良构的。
  
  - **$\Gamma \mid \mathbb{E}; \mathbb{L} \mid \mathbb{K}; \mathbb{T} \vdash F_2$**：同样，分支 $F_2$ 在同样的环境下也是良构的。
  
- **结论部分**:
  - **$\Gamma \mid \mathbb{E}; \mathbb{L} \mid \mathbb{K}; \mathbb{T}, p \triangleleft bool \vdash if \ p \ then \ F_1 \ else \ F_2$**: 结论表示，如果条件 $p$ 的类型为布尔类型（$bool$），则 `if` 语句中，$F_1$ 和 $F_2$ 两个分支的类型相同，并且 `if` 语句整体良构。

#### 总结：
此推导规则是对 `if` 条件表达式进行类型推导的规则。前提是两个分支 $F_1$ 和 $F_2$ 分别在相同的环境中是良构的，并且条件表达式 $p$ 的类型是布尔类型 $bool$。基于这些前提，得出整个 `if` 语句也是良构的。



### 公式详解

#### 公式：
$$
\frac{
\forall i. (\Gamma \mid \mathbb{E}; \mathbb{L} \mid \mathbb{K}; \mathbb{T}, p.0 \triangleleft own_n \kappa, p.1 \triangleleft own_n \bar{\tau}_i \vdash F_i \quad \text{或} \quad \Gamma \mid \mathbb{E}; \mathbb{L} \mid \mathbb{K}; \mathbb{T}, p.0 \triangleleft own_n \kappa \vdash F_i )
}
{
\Gamma \mid \mathbb{E}; \mathbb{L} \mid \mathbb{K}; \mathbb{T}, p \triangleleft own_n \sum_i \bar{\tau} \vdash case \ *p \ of \ F
}
$$

#### 解释：

##### 前提部分 1：
- **$\Gamma \mid \mathbb{E}; \mathbb{L} \mid \mathbb{K}; \mathbb{T}, p.0 \triangleleft own_n \kappa, p.1 \triangleleft own_n \bar{\tau}_i \vdash F_i$**：
  在上下文 $\Gamma$、外部环境 $\mathbb{E}$、局部环境 $\mathbb{L}$、类型约束 $\mathbb{K}$ 下，给定 $p.0$ 对类型 $\kappa$ 的所有权和 $p.1$ 对 $\bar{\tau}_i$ 的所有权，表达式 $F_i$ 是良构的。

##### 前提部分 2：
- **$\Gamma \mid \mathbb{E}; \mathbb{L} \mid \mathbb{K}; \mathbb{T}, p.0 \triangleleft own_n \kappa \vdash F_i$**：
  在上下文 $\Gamma$ 和相同环境下，表达式 $F_i$ 仅需满足 $p.0$ 拥有对 $\kappa$ 的所有权，此时类型 $\bar{\tau}_i$ 的所有权信息不需要额外考虑。

##### 结论部分：
- **$\Gamma \mid \mathbb{E}; \mathbb{L} \mid \mathbb{K}; \mathbb{T}, p \triangleleft own_n \sum_i \bar{\tau} \vdash case \ *p \ of \ F$**：
  在上下文 $\Gamma$ 下，给定 $p$ 对类型 $\sum_i \bar{\tau}$ 的所有权，模式匹配表达式 `case *p of F` 是良构的。

#### 总结：
该推导规则用于验证带有所有权信息的 `case` 模式匹配表达式的良构性。前提分为两部分，第一部分要求在某些情况下，表达式 $F_i$ 依赖于 $p.0$ 和 $p.1$ 两个指针的所有权，而在其他情况下，仅 $p.0$ 的所有权就足够。

### --------------------------


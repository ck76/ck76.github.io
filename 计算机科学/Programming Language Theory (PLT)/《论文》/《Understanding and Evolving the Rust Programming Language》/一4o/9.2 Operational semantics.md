



这段内容定义了 $\lambda_{\text{Rust}}$ 中的相等性规则，主要包括整数、内存位置和值的相等性判断。下文详细解释每条规则的含义：

### 1. 整数相等性
$$
h \vdash z = z
$$
该规则表示在任何堆栈 $h$ 中，两个相同的整数 $z$ 被视为相等。

### 2. 内存位置相等性
$$
h \vdash \ell = \ell
$$
该规则类似于整数相等性，表示在堆栈 $h$ 中，两个相同的内存位置 $\ell$ 也被视为相等。

### 3. 不在堆栈中的内存位置
$$
\ell_1 \notin \text{dom}(h) \lor \ell_2 \notin \text{dom}(h) \quad \frac{}{\ h \vdash \ell_1 = \ell_2}
$$
当两个内存位置 $\ell_1$ 和 $\ell_2$ 中至少有一个不在堆栈 $h$ 的定义域中时（即这两个位置不存在于当前内存中），我们假定它们是相等的。

### 4. 值相等性
$$
h \vdash v_1 = v_2
$$
这条规则是对值的相等性做出的更抽象的定义，表明在堆栈 $h$ 中的两个值 $v_1$ 和 $v_2$ 是否相等是通过相应的规则来推导的。

### ---------------------------

该图片定义了 $\lambda_{\text{Rust}}$ 中的不等性规则，主要涉及整数、内存位置和值的不等性判断。以下是对每个规则的详细解释：

### 1. 整数不等性
$$
\frac{z_1 \neq z_2}{h \vdash z_1 \neq z_2}
$$
此规则表示，当两个整数 $z_1$ 和 $z_2$ 不相等时，我们可以在任何堆栈 $h$ 上直接推导出它们是不相等的。

### 2. 内存位置不等性
$$
\frac{\ell_1 \neq \ell_2}{h \vdash \ell_1 \neq \ell_2}
$$
类似于整数不等性，当两个内存位置 $\ell_1$ 和 $\ell_2$ 不相等时，在堆栈 $h$ 中它们可以被推导为不相等。

### 3. 值不等性
$$
h \vdash v_1 \neq v_2
$$
这条规则表达了更广泛的情况，表示在堆栈 $h$ 中的两个值 $v_1$ 和 $v_2$ 被推导为不相等。具体的判断依据依赖于前面的规则，例如判断值是否是不同的整数或内存位置。

### ---------------------------

图片展示了**小步操作语义**（Small-step operational semantics），这一语义描述的是程序在单步执行中的状态变化。

在这条规则中：

$$
h \mid e \to h' \mid e'_1, e'_2?
$$

这意味着在堆栈 $h$ 中表达式 $e$ 通过单步计算变成了表达式 $e'_1$ 和 $e'_2?$，同时堆栈从 $h$ 转变为 $h'$。在这个框架下，**小步语义**专注于描述程序执行中的微小转变，一步步地解释程序如何改变状态。

### 详细解读：
- $h$：代表程序的当前堆栈或内存状态。
- $e$：表示当前的程序或表达式。
- $h'$：表示程序执行一步后更新的堆栈或内存状态。
- $e'_1$ 和 $e'_2?$：表示下一步生成的一个或两个子表达式。这个记号（$?$）可能意味着 $e'_2$ 是可选的，视具体规则而定。

每一个这样的转换反映了程序从一个状态转移到下一个状态的具体操作。这种操作可以是值计算、内存读写、函数调用等具体的计算行为。

### ------------------------

这两个规则解释了在**小步操作语义**中的表达式评估上下文和投影操作。

### O-ECTX 规则

$$
\frac{h \mid e \to h \mid e'_1, e'_2?}{h \mid K[e] \to h \mid K[e'_1], e'_2?}
$$

这个规则描述的是**表达式上下文**（evaluation context）中的计算如何推进。关键部分在于：

- $K[e]$ 表示表达式 $e$ 嵌套在上下文 $K$ 中。
- 如果 $e$ 在堆栈 $h$ 中进行了一步计算，转变为 $e'_1$ 和可选的 $e'_2$，那么整个上下文 $K[e]$ 的计算也会相应推进为 $K[e'_1]$ 和 $e'_2?$。
  

这意味着在更复杂的上下文中，我们可以将计算递归地推进到内部表达式 $e$ 上。

### O-PROJ 规则

$$
\frac{\ell = (i, n')}{h \mid \ell.n \to h \mid (i, n + n')}
$$

这个规则解释了投影操作：

- $\ell = (i, n')$ 表示一个元组或结构体的位置（location），其中 $i$ 代表某种标识符，$n'$ 代表位置的某个偏移量。
- $\ell.n$ 表示我们在访问或投影出这个元组的第 $n$ 项。如果当前堆栈是 $h$，那么通过这个投影操作，最终结果是计算得出的新位置 $(i, n + n')$。

总结来说，这两个规则分别解释了在复杂表达式上下文中的计算如何推进，以及结构化数据的投影操作如何计算出一个具体的结果。

### -----------------------

这两个规则解释了**加法 (O-ADD)** 和 **减法 (O-SUB)** 在小步操作语义中的执行方式。

### O-ADD 规则

$$
\frac{z_1 + z_2 = z'}{h \mid z_1 + z_2 \to h \mid z'}
$$

- 这个规则表示在计算加法操作时：
  - $z_1$ 和 $z_2$ 是两个整数。
  - 计算结果 $z'$ 是这两个整数相加后的值，即 $z_1 + z_2 = z'$。
  - 如果我们有一个表达式 $z_1 + z_2$，那么在堆栈 $h$ 中，这个表达式可以一步计算为 $z'$。

该规则定义了整数加法的计算步骤，将加法运算简化为一个新的值 $z'$。

### O-SUB 规则

$$
\frac{z_1 - z_2 = z'}{h \mid z_1 - z_2 \to h \mid z'}
$$

- 这个规则描述的是减法操作的计算过程：
  - $z_1$ 和 $z_2$ 是两个整数。
  - 计算结果 $z'$ 是这两个整数相减的结果，即 $z_1 - z_2 = z'$。
  - 类似加法，表达式 $z_1 - z_2$ 可以在堆栈 $h$ 中一步计算为 $z'$。

这个规则定义了整数减法的计算步骤，减法操作会被一步计算为结果值 $z'$。

总结来说，**O-ADD** 和 **O-SUB** 这两个规则简单地说明了如何一步执行整数加法和减法，结果会在表达式中直接替换为计算出的值 $z'$。

### ----------------------

这四个规则描述了**比较运算**和**相等运算**的计算步骤，在小步操作语义中分别处理“比较”和“相等”的布尔值结果。

### O-LE-TRUE 规则

$$
\frac{z_1 \leq z_2}{h \mid z_1 \leq z_2 \to h \mid 1}
$$

- 当 $z_1 \leq z_2$ 为真时，比较运算会产生布尔值 $1$，表示比较结果为真。
- 这意味着表达式 $z_1 \leq z_2$ 将在堆栈 $h$ 中被简化为值 $1$。

### O-LE-FALSE 规则

$$
\frac{z_1 > z_2}{h \mid z_1 \leq z_2 \to h \mid 0}
$$

- 当 $z_1 \leq z_2$ 为假时，比较运算产生布尔值 $0$，表示比较结果为假。
- 这意味着表达式 $z_1 \leq z_2$ 将在堆栈 $h$ 中被简化为值 $0$。

### O-EQ-TRUE 规则

$$
\frac{h \vdash v_1 = v_2}{h \mid v_1 == v_2 \to h \mid 1}
$$

- 当在堆栈 $h$ 中 $v_1$ 和 $v_2$ 相等时，相等运算将产生布尔值 $1$，表示相等。
- 表达式 $v_1 == v_2$ 将在堆栈 $h$ 中被简化为 $1$。

### O-EQ-FALSE 规则

$$
\frac{h \vdash v_1 \neq v_2}{h \mid v_1 == v_2 \to h \mid 0}
$$

- 当 $v_1$ 和 $v_2$ 不相等时，相等运算将产生布尔值 $0$，表示不相等。
- 表达式 $v_1 == v_2$ 将在堆栈 $h$ 中被简化为 $0$。

### 总结

这些规则通过布尔值 $1$（表示真）或 $0$（表示假）来解释如何在堆栈中执行比较和相等运算。这些规则简化了比较运算和相等运算，明确指出在满足条件时该如何一步计算出布尔值结果。

### ------------------

这条推导规则 **O-ALLOC** 描述了内存分配操作的语义，即如何在堆中为变量分配一段新的内存空间。让我们分步解释规则的各个组成部分。

### 规则主体

$$
\frac{
n > 0 \quad \ell = (i, n') \quad \{i\} \times \mathbb{N} \# dom(h) \quad h' = h[\ell + m \mapsto (reading \, 0, \odot)] \quad m \in [<n]
}{
h \mid alloc(n) \to h' \mid \ell
}
$$

#### 条件部分：

- **$n > 0$**：确保分配的内存块大小 $n$ 是正整数，意味着必须分配至少一个内存单元。
  
- **$\ell = (i, n')$**：这里的 $\ell$ 表示新的内存地址，它是由某个标识符 $i$ 和当前内存块偏移量 $n'$ 组成的二元组。

- **$\{i\} \times \mathbb{N} \# dom(h)$**：这一条件表示内存地址 $\ell$ 不属于当前堆 $h$ 的域，即分配的地址 $\ell$ 不能与堆中已有的地址冲突。

- **$h' = h[\ell + m \mapsto (reading \, 0, \odot)]$**：表示新生成的堆 $h'$ 是在原堆 $h$ 的基础上添加了新分配的 $n$ 个内存单元，存储的初始值为 `(reading 0, ⊗)`。其中，`reading 0` 可能表示这个内存块的初始状态，初始值为 0，而 `⊗` 表示某种锁状态或未定义状态。

- **$m \in [<n]$**：$m$ 是新分配内存中的偏移量，范围在 $0$ 到 $n-1$ 之间，用于遍历每一个分配的内存单元。

#### 结果部分：

- **$h \mid alloc(n) \to h' \mid \ell$**：表示当我们在堆 $h$ 中执行分配大小为 $n$ 的内存块时，新的堆变为 $h'$，同时返回新的内存地址 $\ell$。

### 解释

- 内存分配的过程中，规则确保了要分配的内存大小为正，并且新内存地址 $\ell$ 是唯一的（即不会与现有的地址冲突）。
- 新生成的堆 $h'$ 包含 $n$ 个新的内存单元，这些单元被初始化为 `(reading 0, ⊗)`。
- 内存分配成功后，返回新分配的内存地址 $\ell$。

### 直观理解

当程序需要分配一块大小为 $n$ 的新内存时，系统将会在当前堆中找到一个可用的内存地址 $\ell$，并在该地址开始分配 $n$ 个单元。每个单元的初始状态为 `(reading 0, ⊗)`，之后，系统将更新堆的状态，并返回新的内存地址给程序。

这条规则为编程语言中的内存分配操作提供了形式化语义，确保内存分配的正确性和安全性。

### ----------------------------------

这条推导规则 **O-FREE** 描述了内存释放操作的语义，解释了在内存管理中如何正确地释放一段已分配的内存。让我们分步解释规则的各个组成部分。

### 规则主体

$$
\frac{
n > 0 \quad \ell = (i, n') \quad dom(h) \cap \{i\} \times \mathbb{N} = \{i\} \times [\geq n', < n' + n] \quad h' = h[\ell + m \mapsto \bot \mid m \in [<n]]
}{
(h \mid free(n, \ell)) \to (h' \mid \odot)
}
$$

#### 条件部分：

- **$n > 0$**：表示要释放的内存大小 $n$ 必须是正整数，意味着至少要释放一个内存单元。

- **$\ell = (i, n')$**：表示要释放的内存地址是以标识符 $i$ 和偏移量 $n'$ 组成的二元组。

- **$dom(h) \cap \{i\} \times \mathbb{N} = \{i\} \times [\geq n', < n' + n]$**：这一条件表示堆 $h$ 中从地址 $\ell = (i, n')$ 开始的 $n$ 个单元是当前已分配的内存，必须确保这些单元确实在堆中已存在。

- **$h' = h[\ell + m \mapsto \bot \mid m \in [<n]]$**：这是新的堆 $h'$，表示从地址 $\ell + m$ 开始的 $n$ 个单元都被释放，即将这些内存单元的值设置为 $\bot$，表示该内存单元为空闲状态。

#### 结果部分：

- **$(h \mid free(n, \ell)) \to (h' \mid \odot)$**：表示在堆 $h$ 上执行内存释放操作，释放大小为 $n$ 的内存块后，堆变为 $h'$，并返回一个特殊值 $\odot$，可能表示释放操作成功。

### 解释

1. **内存地址验证**：在执行 `free` 操作之前，必须确保要释放的内存确实存在于当前堆中，并且从地址 $\ell$ 开始的 $n$ 个单元是连续已分配的。

2. **内存释放**：释放操作将对应的内存单元设置为 $\bot$，表示这些内存单元可以重新分配。

3. **返回结果**：释放操作完成后，更新的堆 $h'$ 被返回，同时附带一个 $\odot$ 值，可能表示释放成功或用于其他标记目的。

### 直观理解

当程序释放一段大小为 $n$ 的内存时，系统首先确保这段内存确实已分配并存在于堆中，然后将这段内存的状态标记为未分配（即 $\bot$）。释放成功后，堆的状态被更新，程序可以继续执行后续的操作。

### 应用场景

这条规则为编程语言中的内存释放操作提供了形式化语义。它确保在释放内存时：
- 必须是合法的已分配内存；
- 内存被正确标记为未分配，以防止内存泄漏或其他内存错误。

这个规则在内存管理和垃圾回收系统中非常重要，用于处理动态内存分配和释放的正确性。

### ----------------------------------



这两个推导规则 **O-DEREF-SC** 和 **O-DEREF-NA** 详细描述了在两种不同的一致性模型下（顺序一致性 `SC` 和非原子性 `NA`）如何对内存地址进行解引用（deref）的操作。让我们逐条解释这两条规则的含义。

### 规则 O-DEREF-SC

$$
\frac{h(\ell) = (reading\, n, v)}{h \mid *^{sc} \ell \to h \mid v}
$$

#### 条件部分：
- **$h(\ell) = (reading\, n, v)$**：表示在堆 $h$ 中，地址 $\ell$ 对应的值处于一个读取操作状态，且值为 $v$，读取次数为 $n$。这里的 `reading` 状态表示这个内存位置的内容被读了 $n$ 次。

#### 结果部分：
- **$h \mid *^{sc} \ell \to h \mid v$**：在顺序一致性（sequential consistency，`SC`）模型下，对地址 $\ell$ 进行解引用操作，直接返回值 $v$，而堆 $h$ 保持不变。

### 解释：
在 **顺序一致性** 模型下，解引用操作是原子的且不需要对内存状态进行修改，只要检查地址 $\ell$ 中的值并返回即可。这里不涉及任何读取次数的变化，因此堆的状态保持不变。

---

### 规则 O-DEREF-NA

$$
\frac{h(\ell) = (reading\, n, v)}{(h \mid *^{na} \ell) \to (h[\ell \mapsto (reading\, n + 1, v)] \mid *^{na'} \ell)}
$$

#### 条件部分：
- **$h(\ell) = (reading\, n, v)$**：与 **O-DEREF-SC** 中相同，这里表示地址 $\ell$ 的内存位置的状态是 `reading`，且其值为 $v$，已经读取了 $n$ 次。

#### 结果部分：
- **$(h \mid *^{na} \ell) \to (h[\ell \mapsto (reading\, n + 1, v)] \mid *^{na'} \ell)$**：在非原子性（non-atomic，`NA`）模型下，对地址 $\ell$ 进行解引用时：
  - 内存状态发生变化，将读取次数 $n$ 增加 $1$；
  - 解引用操作返回同一个地址 $\ell$，但状态从 `*^{na}` 变为 `*^{na'}`，即标记为下一次的非原子解引用操作。

### 解释：
在 **非原子性模型** 下，解引用操作不仅要读取值，还要记录读取操作的次数。解引用操作会更新内存状态，将地址 $\ell$ 的读取次数从 $n$ 增加到 $n + 1$，以追踪该内存地址被读取的次数。因此，堆 $h$ 会发生更新。这一操作的目的是确保后续的读取或写入操作可以参考这个读取次数。

### 总结：

- **O-DEREF-SC** 描述了在顺序一致性模型下的解引用操作，这是最简单的内存读取操作，直接读取值而不改变内存状态。
- **O-DEREF-NA** 描述了在非原子性模型下的解引用操作，这种操作需要同时跟踪读取次数，因此在每次解引用后，会更新内存状态，使得读取次数增加。

这两种解引用规则体现了不同内存一致性模型下操作的差异：顺序一致性模型保证了所有操作的原子性和线性化顺序，而非原子性模型则需要在操作时额外记录和更新内存读取状态。



### ----------------------------
这两条推导规则 **O-DEREF-NA'** 和 **O-ASSIGN-SC** 详细描述了不同场景下内存操作的行为：一个是非原子性模型下的解引用操作，另一个是顺序一致性模型下的赋值操作。让我们逐条解释它们的含义。

### 规则 O-DEREF-NA'

$$
\frac{h(\ell) = (reading\, n+1, v)}{(h \mid *^{na'} \ell) \to (h[\ell \mapsto (reading\, n, v)] \mid v)}
$$

#### 条件部分：
- **$h(\ell) = (reading\, n+1, v)$**：表示在堆 $h$ 中，地址 $\ell$ 的内容已经被读取了 $n+1$ 次，当前的值为 $v$。

#### 结果部分：
- **$(h \mid *^{na'} \ell) \to (h[\ell \mapsto (reading\, n, v)] \mid v)$**：在非原子性模型下的解引用操作：
  - 解引用后，内存中的读取次数减少 $1$，即将 $n+1$ 次读取减为 $n$ 次；
  - 同时返回内存地址 $\ell$ 的当前值 $v$，并且内存状态有所变化。

### 解释：
这个规则表示在非原子性操作下，解引用不仅仅是读取值，还要管理读取状态的递减。每次解引用操作后，堆中的读取次数减少 $1$。最终返回的是值 $v$。与 **O-DEREF-NA** 的区别是，这里的读取次数由 $n+1$ 减少为 $n$，表明可能存在多个解引用操作的过程。

---

### 规则 O-ASSIGN-SC

$$
\frac{h(\ell) = (reading\, 0, v')}{(h \mid \ell :=_{sc} v) \to (h[\ell \mapsto (reading\, 0, v)] \mid \infty)}
$$

#### 条件部分：
- **$h(\ell) = (reading\, 0, v')$**：表示地址 $\ell$ 当前的值为 $v'$，且读取次数为 $0$，意味着该内存位置没有正在进行的读取操作。

#### 结果部分：
- **$(h \mid \ell :=_{sc} v) \to (h[\ell \mapsto (reading\, 0, v)] \mid \infty)$**：在顺序一致性模型下进行赋值操作：
  - 将地址 $\ell$ 的值从 $v'$ 修改为 $v$，且读取次数保持为 $0$；
  - 返回一个特殊值 $\infty$，表示成功完成了赋值操作。

### 解释：
在顺序一致性模型下，赋值操作是原子的且无并发读取冲突。该规则描述了如何在没有任何其他读取的情况下安全地对内存位置 $\ell$ 进行写操作。赋值完成后，内存状态从旧值 $v'$ 更新为新值 $v$，而读取次数保持为 $0$，表示该位置没有任何读取者。最终返回的特殊值 $\infty$，可能用于表示操作的结束或者成功。

---

### 总结：

- **O-DEREF-NA'** 描述了非原子性模型下解引用操作的状态更新，解引用后读取次数减少，并返回值。
- **O-ASSIGN-SC** 描述了顺序一致性模型下的赋值操作，确保内存值安全更新并返回操作结束标志。

这两条规则展示了两种内存一致性模型下的不同操作：顺序一致性保证原子操作，而非原子模型需要追踪和调整读取状态。
### ----------------------------
这两条推导规则 **O-ASSIGN-NA** 和 **O-ASSIGN-NA'** 描述了在非原子性（non-atomic，简写为 `na`）情况下的赋值操作的细节。让我们逐条解释这两条规则。

### 规则 O-ASSIGN-NA

$$
\frac{h(\ell) = (reading\, 0, v')}{(h \mid \ell :=_{na} v) \to (h[\ell \mapsto (writing, v')] \mid \ell :=_{na} v)}
$$

#### 条件部分：
- **$h(\ell) = (reading\, 0, v')$**：内存堆 $h$ 中的地址 $\ell$ 当前的状态是“读取中”，读取次数为 $0$，且值为 $v'$。这意味着该位置正处于无其他操作进行的读取状态。

#### 结果部分：
- **$(h \mid \ell :=_{na} v) \to (h[\ell \mapsto (writing, v')] \mid \ell :=_{na} v)$**：
  - 内存堆中的 $\ell$ 地址状态更新为“写入中”（`writing`），并且保持当前的值 $v'$。
  - 推导过程继续，将要执行的操作是 `\ell :=_{na} v`，即后续的非原子赋值操作。

### 解释：
这条规则表示在非原子性赋值中，当没有其他读取者时（读取次数为 0），可以开始对地址 $\ell$ 进行写入操作。但在开始写入时，我们先更新内存状态为“写入中”，并保持原来的值 $v'$，以便后续的写入操作继续进行。

---

### 规则 O-ASSIGN-NA'

$$
\frac{h(\ell) = (writing, v')}{(h \mid \ell :=_{na'} v) \to (h[\ell \mapsto (reading\, 0, v)] \mid \infty)}
$$

#### 条件部分：
- **$h(\ell) = (writing, v')$**：堆中地址 $\ell$ 目前处于“写入中”状态，值为 $v'$。这表示该内存位置正在被写入，但当前的写入值尚未完成。

#### 结果部分：
- **$(h \mid \ell :=_{na'} v) \to (h[\ell \mapsto (reading\, 0, v)] \mid \infty)$**：
  - 一旦写入操作完成，地址 $\ell$ 的状态将更新为“读取中”，且读取次数为 0，同时值变为新写入的 $v$。
  - 返回一个特殊值 $\infty$，表示写入操作结束。

### 解释：
这条规则表示在非原子赋值的过程中，写入操作完成后，地址 $\ell$ 的状态将从“写入中”转为“读取中”，并且赋值操作成功完成。新值 $v$ 已经写入内存，且返回 $\infty$ 作为操作结束的标志。

---

### 总结：

- **O-ASSIGN-NA** 描述了在非原子性模型下的赋值操作，当地址没有其他读取操作时，开始写入操作，并将内存状态更新为“写入中”。
- **O-ASSIGN-NA'** 描述了非原子性赋值操作的完成过程，写入完成后，内存地址状态从“写入中”变为“读取中”，并返回操作结束的标志 $\infty$。

这些规则展示了非原子操作中内存状态的变化，尤其是在处理多步写入过程中的不同阶段。
### ------------------------------
这两条推导规则 **O-CAS-FAIL** 和 **O-CAS-SUC** 处理的是原子性的 Compare-And-Swap (CAS) 操作。CAS 是一种重要的并发编程操作，它通过比较一个内存位置的值，如果值相同就将其更新为新值，否则保持原状。让我们分别解释这两条规则。

### 规则 O-CAS-FAIL

$$
\frac{h(\ell) = (reading\, n, v') \quad h \vdash v' \neq v_1}{(h \mid CAS(\ell, v_1, v_2)) \to (h \mid 0)}
$$

#### 条件部分：
- **$h(\ell) = (reading\, n, v')$**：内存地址 $\ell$ 处的状态是“读取中”，读取次数为 $n$，值为 $v'$。这表明当前有一些读取操作正在进行。
- **$h \vdash v' \neq v_1$**：堆 $h$ 中存储的值 $v'$ 和 CAS 操作中提供的比较值 $v_1$ 不相等。也就是说，CAS 操作失败，因为当前值和期望值不匹配。

#### 结果部分：
- **$(h \mid CAS(\ell, v_1, v_2)) \to (h \mid 0)$**：CAS 操作没有改变堆中的值，返回值是 `0`，表示失败。

### 解释：
这条规则表示 CAS 操作的失败情况。当内存中地址 $\ell$ 的当前值 $v'$ 与期望值 $v_1$ 不相等时，CAS 操作不会进行任何更改，直接返回 `0`，表明操作失败。

---

### 规则 O-CAS-SUC

$$
\frac{h(\ell) = (reading\, 0, v') \quad h \vdash v' = v_1}{(h \mid CAS(\ell, v_1, v_2)) \to (h[\ell \mapsto (reading\, 0, v_2)] \mid 1)}
$$

#### 条件部分：
- **$h(\ell) = (reading\, 0, v')$**：内存地址 $\ell$ 的当前状态是“读取中”，读取次数为 $0$，值为 $v'$。这表示没有其他正在进行的读取操作。
- **$h \vdash v' = v_1$**：堆 $h$ 中存储的值 $v'$ 和 CAS 操作的比较值 $v_1$ 相等。也就是说，当前值与期望值匹配，CAS 操作可以继续。

#### 结果部分：
- **$(h \mid CAS(\ell, v_1, v_2)) \to (h[\ell \mapsto (reading\, 0, v_2)] \mid 1)$**：
  - 内存地址 $\ell$ 的值被更新为新值 $v_2$，状态保持为“读取中”，读取次数为 0。
  - 返回值是 `1`，表示 CAS 操作成功。

### 解释：
这条规则表示 CAS 操作的成功情况。当地址 $\ell$ 的当前值与期望值 $v_1$ 相等时，CAS 操作将内存中该地址的值更新为新值 $v_2$，并返回 `1`，表明操作成功。

---

### 总结：

- **O-CAS-FAIL** 描述了 CAS 操作失败的情况：如果当前内存值与期望值不相等，则操作不会更新内存，并返回 `0` 表示失败。
- **O-CAS-SUC** 描述了 CAS 操作成功的情况：如果当前内存值与期望值相等，则操作将内存值更新为新值，并返回 `1` 表示成功。

这两条规则展示了 CAS 操作在并发场景中的重要性，确保原子性检查和更新。
### ---------------------------
这两条推导规则 **O-CAS-STUCK** 和 **O-CASE** 涉及并发场景中的 Compare-And-Swap (CAS) 操作和 case 表达式的行为。我们逐条解释：

### 规则 O-CAS-STUCK

$$
\frac{h(\ell) = (reading\, n, v') \quad n > 0 \quad h \vdash v' = v_1}{(h \mid CAS(\ell, v_1, v_2)) \to (h \mid 0())}
$$

#### 条件部分：
- **$h(\ell) = (reading\, n, v')$**：内存地址 $\ell$ 的当前状态是“读取中”，读取次数为 $n$，当前值为 $v'$。
- **$n > 0$**：表明有多个读取操作正在进行（读取次数 $n$ 大于 0）。
- **$h \vdash v' = v_1$**：堆中的当前值 $v'$ 与 CAS 操作的期望值 $v_1$ 相等。

#### 结果部分：
- **$(h \mid CAS(\ell, v_1, v_2)) \to (h \mid 0())$**：尽管当前值与期望值相等，但因为读取次数 $n > 0$，CAS 操作无法继续，返回 `0()` 表示操作“卡住”了。

### 解释：
这条规则描述了 CAS 操作在读-写竞争下被卡住的情况。当地址 $\ell$ 有多个读取操作时，尽管当前值与期望值相等，CAS 操作由于无法在多个读取过程中进行写操作而被阻塞，最终返回 `0()`，表示无法执行成功。

---

### 规则 O-CASE

$$
(h \mid case\ i\ of\ \bar{e}) \to (h \mid \bar{e}_i)
$$

#### 条件部分：
- **$(h \mid case\ i\ of\ \bar{e})$**：表示有一个 `case` 表达式，分支为 $\bar{e}$，当前选择的分支索引为 $i$。

#### 结果部分：
- **$(h \mid \bar{e}_i)$**：根据索引 $i$，选择相应的分支 $\bar{e}_i$ 并执行。

### 解释：
这条规则描述了 `case` 表达式的求值方式。当有多个分支表达式时，`case` 表达式会根据当前的索引 $i$ 选择并执行对应的分支 $\bar{e}_i$。

---

### 总结：

- **O-CAS-STUCK**：描述了 CAS 操作在读取过程中卡住的情况，即使当前值与期望值相等，但因为读取次数 $n > 0$，CAS 操作无法完成，返回 `0()` 表示失败。
- **O-CASE**：描述了 `case` 表达式的执行过程，通过索引选择并执行相应的分支表达式。

这两条规则共同展示了如何处理并发场景中的操作，以及如何在分支表达式中选择正确的执行路径。

### -------------------------------
### 规则 **O-APP**

$$
(h \mid (rec\ f(\bar{x}) := e)(\bar{v})) \to (h \mid e[rec\ f(\bar{x}) := e, \bar{v}/\bar{x}])
$$

#### 解释：
这条规则描述了**递归函数应用**的过程。规则的核心思想是，当你对一个递归函数进行调用时，实际会用传入的实参替换形参，并将递归函数体带入到函数体中进行计算。

- **左侧条件部分**：
  - $rec\ f(\bar{x}) := e$ 表示定义了一个递归函数 $f$，函数的形参为 $\bar{x}$，函数体为 $e$。
  - $f(\bar{v})$ 表示对函数 $f$ 进行应用，传入的实参为 $\bar{v}$。
  
- **右侧结果部分**：
  - $e[rec\ f(\bar{x}) := e, \bar{v}/\bar{x}]$ 表示将递归函数 $f$ 的定义插入函数体 $e$，并且用实参 $\bar{v}$ 替换形参 $\bar{x}$。

这条规则展示了如何处理递归函数的调用：通过将递归函数的定义以及实参带入到函数体中，继续执行递归函数。

---

### 规则 **O-FORK**

$$
h \mid fork\{e\} \to h \mid \oplus, e
$$

#### 解释：
这条规则描述了**并发计算**中的 `fork` 操作，`fork` 操作用于启动一个新的并发任务。

- **左侧条件部分**：
  - $fork\{e\}$ 表示启动一个新的并发任务，其任务的执行体是表达式 $e$。
  
- **右侧结果部分**：
  - $h \mid \oplus, e$ 表示在当前堆 $h$ 不变的情况下，新的并发任务 $e$ 被加入到并发任务池中，表示该任务被成功启动。

这条规则展示了在操作系统或并发环境下，如何通过 `fork` 操作来启动一个新的并发任务，新的任务 $e$ 被放入到当前计算的任务池中等待执行。

---

### 总结：

- **O-APP** 规则处理递归函数的应用，通过将实参带入到函数体中，并替换形参，来执行递归函数。
- **O-FORK** 规则处理并发任务的启动，通过 `fork` 操作启动一个新的任务，将该任务放入并发任务池中。

### ---------------------------
### 图中公式详细解释：

#### 1. **变量绑定 (Variable Binding)**

$$
let\ x = e\ in\ e' := (rec_{\_}([x]) := e')(e)
$$
**解释**：`let` 表达式在 $e$ 中计算值并绑定到变量 $x$，然后在 $e'$ 中使用 $x$。右边的表达式 $rec_{\_}([x]) := e'$ 表示一个匿名递归函数，它将 $x$ 作为参数，函数体是 $e'$，然后将该函数应用于表达式 $e$。

#### 2. **顺序表达式 (Sequence Expressions)**

$$
e'; e := let\_ = e' \ in\ e
$$
**解释**：该公式表示顺序执行两个表达式 $e'$ 和 $e$，即先计算 $e'$，然后计算 $e$，并丢弃 $e'$ 的结果。右侧定义为一个 `let` 表达式，其中 `_` 表示忽略绑定的变量。

#### 3. **空操作 (Skip Operation)**

$$
skip := \oplus ; \oplus
$$
**解释**：`skip` 表示空操作，它不会对程序状态产生任何影响。在这里，$⊕$ 是一个占位符，表示没有实际操作发生。

#### 4. **新生命周期 (New Lifetime)**

$$
newlft := \oplus
$$
**解释**：`newlft` 表示创建一个新的生命周期。在 Rust 或其他类似语言中，生命周期是与内存管理相关的概念，用来跟踪内存区域的有效期。

#### 5. **结束生命周期 (End Lifetime)**

$$
endlft := skip
$$
**解释**：`endlft` 表示结束生命周期，实际上等价于 `skip`，因为结束生命周期不需要实际的操作。

### 布尔值 (Boolean Values)

#### 6. **布尔常量 (Boolean Constants)**

$$
false := 0, \quad true := 1
$$
**解释**：布尔常量 `false` 定义为整数 0，`true` 定义为整数 1。这是许多编程语言中的常见实现，它们使用整数表示布尔值，通常 0 代表 `false`，非零数代表 `true`。

### 条件表达式 (Conditional Expressions)

#### 7. **条件语句 (Conditional Statements)**

$$
if\ e_0\ then\ e_1\ else\ e_2 := case\ e_0\ of\ [e_1, e_2]
$$
**解释**：`if` 表达式根据 $e_0$ 的值返回 $e_1$ 或 $e_2$，如果 $e_0$ 为真，则返回 $e_1$，否则返回 $e_2$。在这里，条件表达式等价于一个模式匹配 (`case`) 表达式。

### 延续与跳转 (Continuations and Jumps)

#### 8. **延续 (Continuation)**

$$
letcont\ k(\overline{x}) := e\ in\ e' := (let\ k = (rec\ k(\overline{x}) := e)\ in\ e')
$$
**解释**：`letcont` 定义一个延续 $k$，它的参数是 $\overline{x}$，并且延续的主体是表达式 $e$。延续允许程序捕获当前的控制状态，并在后续执行中恢复。

#### 9. **跳转 (Jump)**

$$
jump\ k(\overline{e}) := k(\overline{e})
$$
**解释**：`jump` 表示跳转到延续 $k$ 并将 $\overline{e}$ 作为参数进行调用。这是函数调用和控制流恢复的一部分。

### 递归函数 (Recursive Functions)

#### 10. **递归函数定义 (Recursive Function Definition)**

$$
funrec\ f(\overline{x})\ ret\ k := e := (rec\ f([k] ++ \overline{x}) := e)
$$
**解释**：`funrec` 定义递归函数 $f$，它的参数是 $\overline{x}$，返回点是 $k$，函数体为 $e$。这个定义表示 $f$ 可以递归调用自己，并且有一个返回点 $k$ 用于跳转回结果。

### 函数调用 (Function Call)

#### 11. **函数调用 (Function Call)**

$$
call\ f(\overline{e})\ ret\ k := f([k] ++ \overline{e})
$$
**解释**：`call` 表示调用函数 $f$，传递参数 $\overline{e}$，并在调用完成后跳转回延续 $k$。
### ----------------------

### 图中公式详细解释：

#### 1. **内存分配 (Memory Allocation)**
$$
new := rec\ new(size) :=
\begin{cases}
    (42, 1337) & \text{if } size == 0 \\
    alloc(size) & \text{else}
\end{cases}
$$
**解释**：`new` 表示一个递归函数，用于分配新的内存。如果 `size` 为 0，则返回值对 $(42, 1337)$，这是默认或占位符的返回值。如果 `size` 大于 0，则调用 `alloc(size)` 来分配指定大小的内存。

#### 2. **内存释放 (Memory Deallocation)**
$$
delete := rec\ delete(size, ptr) :=
\begin{cases}
    \oplus & \text{if } size == 0 \\
    free(size, ptr) & \text{else}
\end{cases}
$$
**解释**：`delete` 函数递归地根据 `size` 释放内存。如果 `size` 为 0，则没有操作 (`skip`)，否则调用 `free(size, ptr)` 来释放指针 `ptr` 指向的内存。

#### 3. **内存复制 (Memory Copy)**
$$
memcpy := rec\ memcpy(dst, len, src) :=
\begin{cases}
    \oplus & \text{if } len \leq 0 \\
    dst.0 := src.0; memcpy(dst.1, len - 1, src.1) & \text{else}
\end{cases}
$$
**解释**：`memcpy` 函数递归地将 `src` 的内存内容复制到 `dst`。如果 `len` 小于等于 0，则执行空操作 (`skip`)；否则，将 `src` 的第一个元素复制到 `dst` 的第一个元素，然后递归地处理剩余部分。

### 递归函数与指针操作 (Recursive Functions and Pointer Manipulation)

#### 4. **指针读取 (Dereferencing a Pointer)**
$$
*e := *na\ e
$$
**解释**：`*e` 表示读取指针 `e` 所指向的值，`*na e` 表示使用“非原子性”的读取操作，意味着该读取操作不需要保证原子性（不需要同时锁定内存资源）。

#### 5. **赋值操作 (Assignment Operations)**

- $$ e_1 := e_2 := e_1 := na\ e_2 $$
  
  **解释**：将 `e_2` 赋值给 `e_1`，这使用了非原子赋值，表示操作期间没有同步机制保证数据一致性。

#### 6. **内存块复制 (Memory Block Copy)**
$$
e_1 *e_2 := memcpy(e_1, n, e_2)
$$
**解释**：该表达式表示内存块复制，将内存块 `e_2` 的内容复制到 `e_1`，操作长度为 `n`。

#### 7. **注入 (Injection) 与投影 (Projection)**

  - $$ e_1 : inj\ i := e_2 $$
    
    **解释**：`inj i` 表示将值 `e_2` 作为某种类型注入到 `e_1` 中，`i` 代表注入的索引或标识。
  
  - $$ e_1 : inj\ i_n := e_2 $$
    
    **解释**：这里是类似的注入操作，但针对的是不同的变量 `e_1` 和 `e_2`，同时索引值为 `i_n`，表示这是某种注入操作链条中的第 `n` 个注入。

#### 8. **内存块递归复制 (Recursive Memory Block Copy)**
$$
e_1 inj\ i := e_1.0 := i; e_1.1 := e_2
$$
**解释**：该递归表达式表示将 `i` 赋值给 `e_1` 的第一个位置，接着将 `e_2` 赋值给 `e_1` 的第二个位置。这是一个分段的内存复制过程。

### 总结
- **new、delete** 函数用于动态内存的分配与释放，具体控制通过递归结构进行。
- **memcpy** 函数通过递归的方式逐步实现内存块的复制。
- 注入和投影操作则与递归赋值以及内存结构的逐步构造有关。


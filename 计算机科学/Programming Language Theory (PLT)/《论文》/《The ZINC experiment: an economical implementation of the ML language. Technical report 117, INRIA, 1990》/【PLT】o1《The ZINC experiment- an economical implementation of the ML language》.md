
 #  
 Thought for 30 seconds
**概览**

这段内容主要讨论了ZINC项目的动机和设计原则。作者首先介绍了为什么需要另一个ML语言的实现，强调了创建一个小型、可移植的ML实现的重要性，以及它在语言扩展和教学中的作用。接着，作者深入探讨了模块系统的设计，选择了一种类似于Modula-2的模块系统，而非标准ML的复杂模块系统。他还讨论了函数的柯里化与多元函数的效率问题，以及从右到左的求值顺序对于实现高效的多次函数应用的重要性。

**详细解读**

**第1章 动机**

**引用与背景**

作者以塞缪尔·贝克特的一句话开篇：“没有办法治愈它。”这句话可能暗示了对现有问题的无奈或挑战。随后，他介绍了ML语言的发展历程。最初，ML被设计为LCF证明助手的控制语言，后来发展成为一种通用的高级语言，特别适合教学和快速原型设计。

**现有ML实现的局限**

虽然已经有许多ML的实现，如Edinburgh ML、Lazy ML、CAML、Standard ML of New Jersey等，但这些实现都有一些共同的问题：

- **资源消耗大**：这些实现需要大量的CPU和内存资源。例如，CAML需要至少3 MIPS的处理能力和5 MB的内存才能获得良好的响应时间。
- **可移植性差**：通常只能在特定的硬件架构（如VAX和Sun工作站）上运行，因为它们通常生成本机机器码。
- **受众受限**：由于上述原因，ML的潜在用户群受到了严重限制。例如，没有在微型计算机上运行的ML实现，这阻碍了ML在教学中的广泛应用。
**开发新ML实现的目标**

基于以上原因，作者感到有必要开发另一个ML的实现，目标是：

1. **创建一个小型、可移植的ML实现**：减小资源需求，扩大ML的用户群，特别是在教学领域。
2. **作为语言扩展的测试平台**：由于ML的标准化可能有些仓促，许多新的扩展特性尚未得到充分实验和验证，如逻辑编程、面向对象编程、通信进程等。因此，需要一个易于扩展和实验的平台。
3. **用于教学目的**：深入理解一门语言的最佳方式之一是研究其实际实现。目前缺乏关于ML实现的详细文献，因此需要一个小型且易于理解的实现供教学使用。
**ZINC项目的诞生**

基于以上动机，作者开始开发ZINC项目。ZINC是“ZINC Is Not CAML”的递归首字母缩写，强调了它与现有实现（如CAML）的不同之处。

**第2章 设计原则**

**2.1 模块**

**模块化编程的重要性**

模块化编程被认为是处理大型软件系统的有效方法。它允许程序被分解为多个相对独立的部分（模块），使得依赖关系清晰，增强了代码的可维护性和重用性。

**2.1.1 标准ML中的模块**

标准ML引入了一个功能强大的模块系统，包括函子（functor）等高级特性。然而，作者认为这种复杂的模块系统并不适合ZINC，原因如下：

- **复杂性过高**：缺乏使用标准ML模块编写的大型软件系统的经验，因此尚不清楚这些高级特性是否真正必要。
- **使用不便**：在使用其他模块的值或类型时，程序员需要在当前模块的开头插入它们的签名，这在实践中非常繁琐，尤其是对于频繁使用的标准库函数。
- **编译时类型检查不足**：模块之间的不一致性在编译时无法检测，只有在链接时才会发现，这违背了真正的独立编译的原则。
**2.1.2 类似Modula的模块系统**

为了克服上述问题，作者提出了一种类似于Modula-2的模块系统：

- **接口和实现分离**：每个模块由接口和实现两部分组成。接口部分声明模块公开的所有内容，实施部分包含实际的代码实现。
- **使用点号表示法**：通过“module.data”的形式来引用其他模块中定义的值或类型。
- **类型抽象**：支持类型抽象，使得模块可以隐藏其内部实现细节，仅暴露必要的接口。
- **优点**：**简单易用**：无需在每个使用模块的地方重复声明导入的值和类型。**编译时一致性检查**：能够在编译时检测模块之间的类型不一致性，提高了代码的安全性和可靠性。**方便模块间的切换**：通过更改模块引用，可以轻松切换不同的实现版本。
**示例**

作者给出了一个集合（set）模块的示例，展示了如何定义模块的接口和实现，以及如何在其他模块中使用。

**2.1.3 非限定标识符的处理**

为了简化模块的使用，作者引入了非限定标识符的处理机制：

- **默认模块列表**：编译器维护一个默认模块列表，当遇到未限定的全局标识符时，会在该列表中搜索。
- **编译指令**：提供了#open和#close指令，可以在代码中动态地打开或关闭模块。
- **优点**：**减少代码冗余**：无需在代码中频繁使用限定标识符，提高了代码的可读性。**灵活性**：允许程序员在不同的实现之间进行选择，例如在调试和发布版本之间切换不同的模块实现。
**2.2 高效的柯里化与多元函数**

**2.2.1 多参数函数的需求**

在大多数编程语言中，多参数函数是常见的。然而，在ML中，函数本质上是单参数的，多参数函数需要通过以下方式实现：

- **传递一个元组**：将所有参数打包成一个元组传递给函数。
- **柯里化**：使用嵌套函数，每次接收一个参数，返回一个新的函数。
这两种方法在传统的执行模型中效率较低，因为它们需要在堆上分配额外的内存空间。

**2.2.2 柯里化的优势**

作者强调了柯里化函数的强大之处：

- **部分应用**：可以对函数进行部分应用，得到一个新的函数。
- **代码简洁**：更容易表达复杂的函数组合和高阶函数操作。
- **性能优化**：通过部分计算，减少重复计算，提高效率。
基于这些优势，作者决定专注于柯里化函数，目标是找到一种抽象机器，使得对多个参数的多次应用比对包含所有参数的元组进行单次应用更高效，甚至接近于多参数函数的效率。

**2.2.3 从右到左的求值顺序**

为了实现高效的多次应用，作者提出采用从右到左的求值顺序：

- **原因**：在对柯里化函数进行多次应用时，需要在函数执行前预先计算所有参数值。
- **优点**：避免在每次部分应用时创建中间闭包，从而提高执行效率。
- **影响**：需要程序员了解这种求值顺序，因为在存在副作用（如异常、可变状态、输入输出操作等）的情况下，求值顺序会影响程序的行为。
**求值顺序的讨论**

作者指出，求值顺序不仅仅是一个实现细节。在存在副作用的编程语言中，表达式的求值顺序会对程序的结果产生实际影响。因此，程序员需要对编译器采用的求值顺序有所了解，以正确预测程序的行为。

他还提到，一些语言（如C）并未指定表达式求值的顺序，这要求程序员编写代码时避免依赖特定的求值顺序，以确保程序的可移植性和可靠性。

**总结**

这段内容深入探讨了ZINC项目的动机和设计原则。作者在分析现有ML实现的不足后，提出了创建一个小型、可移植的ML实现的必要性，以扩大ML的应用范围，特别是在教学和语言扩展实验方面。

在设计模块系统时，他选择了一种类似于Modula-2的简单模块系统，强调了接口与实现的分离，以及非限定标识符的灵活处理。这种设计提高了模块的可用性和编译时类型检查的可靠性。

在函数设计上，作者强调了柯里化的优势，并提出了从右到左的求值顺序，以实现高效的多次函数应用。这种选择既保留了语言的函数式特性，又提升了执行效率。

总体而言，作者通过慎重的设计选择，使ZINC成为一个既实用又易于扩展的ML实现，为进一步的研究和教学提供了坚实的基础。
 #  
 Thought for 7 seconds
**概览**

这段内容主要来自于一篇技术报告，讨论了ZINC实验，这是对ML（MetaLanguage）语言的一种经济实现。作者详细阐述了开发ZINC的动机，包括对现有ML实现的局限性的认识，以及希望创建一个小型、可移植、易于扩展和教学友好的ML实现的愿望。

首先，作者回顾了ML语言的发展背景，指出了现有ML实现的问题，如资源需求高、可移植性差以及不适合实验和教学等。随后，作者提出了开发ZINC的三个主要目标：

1. **创建一个小型、可移植的ML实现**，以减少资源需求并扩大ML的使用范围。
2. **作为语言扩展的测试平台**，以便于实验新的语言特性和机制。
3. **用于教学目的**，提供一个易于理解的ML实现，以帮助学习者深入理解语言的实现细节。
接下来，作者讨论了设计ZINC时的主要原则，特别是关于模块系统和函数设计的选择。他选择了一种类似于Modula-2的简单模块系统，以提高可用性和编译时的类型检查。此外，他深入探讨了函数柯里化与多元函数的问题，并提出采用从右到左的求值顺序，以实现高效的多次函数应用。

**详细解读**

**第1章 动机**

**引用与背景**

文章以塞缪尔·贝克特（Samuel Beckett）的一句话开篇：“没有办法治愈它。”这句话可能表达了作者对现有问题的无奈，或者预示了接下来讨论的问题的复杂性和挑战性。

**ML语言的发展**

ML最初被设计为LCF（逻辑证明器）的控制语言[26]，随着时间的推移，它发展成为一种通用的、非常高级的语言，特别适合教学和快速原型设计。许多工作致力于其实现，不仅是为了获得高效的ML编译器，还为了构建良好的ML编程环境。例如：

- 原始的Edinburgh ML
- Chalmers大学开发的Gothenburg的Lazy ML
- INRIA的CAML
- Bell Labs的Standard ML of New Jersey
- 剑桥的Matthews的Poly/ML
这些努力使得人们相信ML实现领域已经被充分研究，不再是热门的研究课题。

**现有ML实现的问题**

然而，作者自身在使用和开发CAML系统的过程中，意识到了需要另一个ML实现，基于以下目标：

1. **获得一个小型、可移植的ML实现**
- **资源需求高**：当前的ML实现需要大量的CPU和内存资源。例如，CAML至少需要3 MIPS的处理能力和5 MB的内存才能获得令人满意的响应时间。
- **可移植性差**：通常只能在特定架构上工作（如VAX和Sun工作站），因为它们通常生成本机机器码。
- **受众受限**：这严重限制了ML的潜在受众。例如，没有在微型计算机上运行的ML实现，这是其在教学中广泛使用的主要障碍。
2. **作为语言扩展的测试平台**
- **ML标准化可能过于仓促**：最近提出了许多扩展，以整合来自其他计算范式的特性，如逻辑编程、面向对象编程或通信进程，以及ML的强静态类型、类型推断和高阶函数。
- **类型系统的扩展**：如具有结构子类型的记录[15, 31, 53]、Haskell的类型类[60]、动态对象[1]。
- **执行模型的新机制**：如基于统一调用（缩减）、通信进程。
- **新的高效实现技术**：如高级程序转换和强大的静态分析[22]。
- **现有实现的局限性**：在像CAML这样的大型实现中添加新特性需要大量工作，因为系统规模大，模块化程度低，各部分之间有许多意想不到的依赖关系，以及复杂的引导问题。因此，CAML不再适合用于实验。
3. **用于教学目的**
- **理解语言的最佳方式之一是研究其实际实现**。
- **缺乏ML实现的详细描述**：虽然有关于Standard ML of New Jersey实现的一些论文[5, 6, 4]，但它们都比较高层次，没有展示太多代码。
- **CAML系统的资料匮乏**：尚未发表任何关于CAML系统的论文，Ascander Suárez的论文[59]仍在酝酿中，而对其感兴趣的人只能面对70,000行注释很少的源代码。
**ZINC项目的诞生**

基于上述动机，作者开发了另一个ML实现，即ZINC。ZINC是“ZINC Is Not CAML”（ZINC不是CAML）的递归首字母缩写，这个名称强调了它与现有实现的不同之处。作者还将其戏称为“非正式项目”，强调了其主要是实践性的性质。

**报告结构**

- **第2章**：介绍了主要的设计决策和指导实现的原则。
- **第3章**：引入了执行模型，描述为一个抽象机器。
- **第4章**：展示了ML值的表示以及内存的结构。
- **第5章**：详细说明了编译器，提供了实际的ML代码。
- **第6章**：概述了运行时系统。
- **第7章**：总结了结论性意见。
- **附录A**：提供了基准测试结果。
**第2章 设计原则**

在这一章中，作者介绍了设计ZINC时所做的主要决策，以及为什么它与传统的ML实现略有不同。

**2.1 模块**

**模块化编程的必要性**

将程序分解为几个相对独立的部分（称为模块）已被证明是处理大型程序的有效方法[49]。在任何编程语言中都可以进行模块化编程，即使是Fortran，只要程序员有足够的毅力。然而，当语言提供特性来表达模块之间的依赖关系时，模块化编程会更加容易。这允许编译器自动检查它们的一致性。

从更实际的角度来看，语言对模块的支持是将强静态类型与独立编译相结合的唯一方法。因此，ZINC必须提供某种形式的模块。

**2.1.1 标准ML中的模块**

MacQueen提出了一个用于ML语言的模块系统[42]，现在已成为Standard ML定义的一部分[28]。它引入了非常强大的概念，如函子（functor），使其成为有史以来集成到编程语言中的最先进的模块系统之一。它还得到了相当令人满意的形式化处理，尽管有些复杂[43]。

**为何不采用标准ML的模块系统**

然而，作者认为这种复杂的模块系统不适合ZINC，原因如下：

1. **过度复杂性**
- **需求不明确**：尚不清楚是否真的需要如此复杂的系统，以及它在处理大型软件系统时是否真的有帮助。缺乏使用标准ML模块编写的大型软件系统的经验。
2. **使用不便**
- **导入值和类型的麻烦**：要使用另一个模块中定义的值或类型，程序员必须在当前模块的开头插入它们的签名（对于值是它们的类型，对于具体类型是它们的构造函数）。这在实践中非常繁琐，尤其是对于频繁导入的值，如ML实现的“前奏”（prelude）中的那些值。
3. **编译时一致性检查的不足**
- **链接时发现不一致性**：模块之间的不一致性不会在编译时检测，而是在链接时，当所有模块都已编写和编译时才发现。这违背了“真正的”独立编译的原则。
**2.1.2 Modula-2风格的模块系统**

**选择简单的模块系统**

作为对Standard ML模块的简单替代方案，作者提出了一种非常接近于Modula-2[63]中发现的模块系统。这种系统具有以下特点：

- **接口文件**：每个模块都有一个接口文件，声明它导出的内容。
- **点号表示法**：使用“module.data”形式引用由名为module的模块导出的标识符data。
- **类型抽象的扩展**：引入了一个用于类型抽象的简单机制，类似于Modula-3[47]。
- **导入模块的隐式性**：模块的导入是隐式的，使用它们的接口文件中找到的签名。
**与其他语言的比较**

- **功能语言中的类似系统**：在Cardelli的Quest语言[14]中，可以找到类似的模块系统，其中模块建立在称为抽象元组（即广义的二阶依赖积）的更基本的数据结构之上。然而，这需要二阶类型，并导致对“显式类型”（即导出其定义的类型）进行略有不同的处理。
**模块的组成部分**

一个ZINC模块由两部分组成：接口和实现。

- **接口部分**：声明模块导出的所有内容，如值标识符及其类型、具体类型的定义、抽象类型和异常的声明。
- **实现部分**：是一个常规的ML短语序列，绑定标识符到表达式的值，定义具体类型和异常，或评估单个表达式。它必须为接口声明的值和抽象类型提供定义。它还可以包含其他绑定，但这些是私有的，即在实现之外未知。
**模块示例**

以下是一个实现集合（set）数据结构的模块示例：

**接口文件（set.mli）**

```ml
type 'a set;; (* 抽象类型，表示其表示方式保持隐藏 *)
value emptyset: 'a set
and singleton: 'a -> 'a set
and union: 'a set -> 'a set -> 'a set
and empty: 'a set -> bool
and member: 'a -> 'a set -> bool;;
```

**实现文件（set.ml）**

```ml
type 'a set = EmptySet | Singleton of 'a | Union of 'a set * 'a set;;
let emptyset = EmptySet
and singleton x = Singleton x;;
let rec empty = function
  EmptySet -> true
| Singleton _ -> false
| Union(s1,s2) -> empty s1 & empty s2;;
let rec member x = function
  EmptySet -> false
| Singleton y -> x=y
| Union(s1,s2) -> member x s1 or member x s2;;
let union s1 s2 = Union(s1,s2);;
```

**使用模块**

要在模块外部使用模块提供的值和类型，可以使用点号表示法，即`module.data`。例如：

```ml
type intset_tree =
  Leaf of int set.set
| Node of intset_tree * intset_tree;;
let rec ints_of_intset_tree = function
  Leaf s -> s
| Node(t1,t2) -> set.union (ints_of_intset_tree t1) (ints_of_intset_tree t2)
;;
let contains_zero is = set.member 0 (ints_of_intset_tree is)
;;
```

**2.1.3 处理非限定标识符**

**自动完成非限定标识符**

为了简化模块的使用，作者提出了对非限定标识符的自动完成机制。

- **默认模块列表**：编译器维护一个“默认”模块的列表，当它遇到一个未限定的全局标识符s时，它会在该列表中搜索定义了s的模块m，然后将s替换为m.s，从而消除全局名称s的歧义。
- **默认模块的组成**：默认模块列表总是包括正在编译的模块（首先搜索）和一个特殊的basics模块，定义了非常原始的操作，如+（最后搜索）。
- **编译指令**：提供了两个编译指令#open "module"和#close "module"，用于在默认模块列表中添加或删除模块。
**优点**

- **减少代码冗余**：不需要在代码中频繁使用限定标识符，提高了代码的可读性和简洁性。
- **灵活性**：允许程序员选择使用不同的模块实现。例如，可以在调试和发布版本之间切换不同的模块实现。
- **避免了过载的需求**：通过这种机制，过载的需求不再那么迫切，虽然它没有提供过载的全部功能，但也没有过载的缺点。
**示例**

如果在代码的开头插入`#open "prelude"`，就不需要在代码中频繁地写`prelude.map`、`prelude.fst`等，可以直接使用`map`、`fst`等。

**在数值运算中的应用**

在处理数值运算时，这种机制也非常有用。例如，整数和浮点数的加法操作通常有不同的实现，可以定义两个模块`int`和`float`，分别实现整数和浮点数的加法操作。在需要时，可以打开相应的模块或直接使用限定标识符。

**2.2 高效的柯里化与多元函数**

**2.2.1 多参数函数的需求**

在大多数编程语言中，多参数函数是常见的，甚至那些具有一等函数的语言（如Scheme和实现良好的Pascal）也是如此。传递多个参数和传递一个参数一样容易。然而，ML一直坚持使用一元函数（单参数函数）。要定义一个多参数函数，如`f(x, y) = x + 3y`，需要以下两种方式之一：

1. **传递一个元组**：
```ml
let f = function (x, y) -> x + 3 * y in f(5,7);;
```
这种方式需要构建一个元组来保存参数，这可能导致效率低下。
2. **柯里化**：
```ml
let g = function x -> function y -> x + 3 * y in g 4 6;;
```
这种方式需要创建中间的闭包（一个用于每个参数，除了最后一个），这些闭包立即应用，然后不再使用。
**效率问题**

- **堆分配的开销**：在传统的执行模型（如FAM[11]或CAM[20]）中，这两种方式都效率不高，因为它们需要在堆上分配额外的内存。
- **调用开销**：对于真正的多元函数，可以使用更高效的调用约定（基于栈或寄存器），无需在堆上分配任何内容。
**2.2.2 柯里化的强大之处**

**部分应用的优势**

柯里化函数和对应的非柯里化函数（如接受元组的函数或多元函数）并不完全等价。柯里化版本更为强大，因为它允许部分应用。例如：

```ml
let g = function x -> function y -> x + 3 * y;;
map (g 4) [1; 2; 3; 4; 5];;
```

在这个例子中，`(g 4)`是一个合法的对象，我们可以将其应用于列表中的每个元素。

**性能优化**

部分应用可以导致函数体的部分计算，从而节省大量计算。例如：

```ml
let h x = let z = fibonacci x in fun y -> y + z;;
map (h 30) L;;
```

在这个例子中，`fibonacci 30`只计算一次，而不是对列表`L`中的每个元素都计算一次。

**决定放弃多元函数**

鉴于柯里化的这些优势，作者决定不考虑多元函数，而是专注于柯里化函数。挑战在于找到一种抽象机器，使得对多个参数的多次应用（即`M N1 N2 ... Nk`）比对包含所有参数的元组进行单次应用（即`M (N1, ..., Nk)`）更高效，甚至接近于调用一个多元函数。这至少意味着在执行过程中不需要构建任何中间的闭包。

**2.2.3 从右到左的求值顺序**

**多次应用的求值顺序问题**

采用柯里化函数并希望高效地进行多次应用，需要重新考虑求值顺序。

- **左到右的求值顺序的问题**：在左到右的求值顺序中，函数`M`首先被求值，然后是参数`N1`，然后进行部分应用`A1 = M N1`，接着求值`N2`，再进行`A2 = A1 N2`，依此类推。这种方式需要在每次部分应用时创建中间的闭包，导致效率低下。
- **需要预先计算所有参数**：为了提高效率，需要在开始计算`M`之前预先计算所有参数`N1`到`Nk`。这避免了在每次部分应用时暂停函数的求值并等待下一个参数的值。
**从右到左的求值顺序的优势**

- **一致的求值顺序**：在从右到左的求值顺序中，参数`Nk`到`N1`依次被求值，然后是函数`M`，接着是应用`A1`到`Ak`。这种方式与多次应用的高效机制相一致。
- **避免中间闭包的创建**：通过预先计算所有参数，可以避免在每次部分应用时创建中间闭包，提高了执行效率。
**语义影响**

- **求值顺序的重要性**：求值顺序不仅是实现细节，在存在副作用的语言中（如ML中的异常、可变值、输入/输出等），表达式的求值顺序会影响程序的语义。
- **程序员需要了解求值顺序**：因为求值顺序会影响程序的行为，程序员需要知道编译器采用的求值顺序，以便正确地理解和预测程序的行为。
**求值顺序的非指定性**

- **某些语言的不指定性**：一些语言（如C）没有指定表达式的求值顺序，除了少数具有强顺序性的构造（如顺序操作符“;”和声明`let...in...`）。
- **编程的影响**：这要求程序员编写的程序在任何可能的求值顺序下都有相同的行为，通常需要避免依赖特定的求值顺序。
**总结**

在这段内容中，作者详细阐述了开发ZINC的动机和设计原则。他认识到现有的ML实现存在资源需求高、可移植性差和不适合扩展和教学等问题，因此希望创建一个小型、可移植、易于扩展和教学友好的ML实现。

在设计模块系统时，作者选择了类似于Modula-2的简单模块系统，而不是标准ML的复杂模块系统。这种模块系统通过接口和实现的分离、点号表示法和非限定标识符的处理，提供了更好的可用性和编译时的一致性检查。

在函数设计上，作者强调了柯里化的优势，并提出了采用从右到左的求值顺序，以实现高效的多次函数应用。这种设计选择既保留了函数式编程的灵活性，又提高了执行效率。

总体而言，作者通过对现有问题的深入分析和对设计选择的详细论证，为ZINC的开发奠定了坚实的基础。这一工作不仅具有实践意义，也为进一步的研究和教学提供了宝贵的经验和参考。
 #  
 Thought for 23 seconds
**详细解读：**

**2.3 执行方法**

**引言**

在设计ZINC编译器时，需要决定生成何种类型的代码。这一实现问题涉及ZINC的许多方面，特别是可移植性、执行速度和交互性。作者回顾了最常见的方法，以证明直接解释抽象机器代码的选择是合理的。

**2.3.1 生成本机代码（Native code generation）**

**真实编译器的实践**

真实的编译器为真实的语言生成本机机器码（或汇编语言），以便在给定的硬件上运行尽可能快的编译程序。然而，这被称为“血、汗和泪”的方法：编写一个生成优良机器码的代码发射器（code emitter），比如可与手写的汇编代码相媲美，绝非易事。

**CISC架构的挑战**

在传统的复杂指令集计算机（CISC）架构上，如VAX或摩托罗拉68000系列，主要困难在于从大量的指令和寻址模式中选择正确的指令序列，并应对它们的非对称性。例如：

- **指令限制**：某些指令无法与所有寻址模式一起使用。
- **寄存器专用性**：某些寄存器专门用于某些操作。
**RISC架构的新问题**

在精简指令集计算机（RISC）架构上，指令选择更容易，但会出现新问题，例如：

- **利用新特性的挑战**：如延迟分支（delayed branches）的指令调度问题。
**寄存器分配的重要性**

无论是CISC还是RISC，良好的寄存器分配对于减少内存访问至关重要，这需要相当复杂的算法。

**可移植性的困难**

- **特定于处理器**：代码发射器是针对特定处理器的，因此对于每个新的目标处理器，都必须从头开始重新编写这项工作。
- **正确性的妥协**：代码发射器的正确性常常因巧妙的优化而受到影响。
**自动代码发射器的尝试**

为了自动化部分工作，许多尝试致力于从目标机器的形式化描述开始，自动生成代码发射器。一个流行且文档丰富的例子是GNU C编译器[57]。

- **现实架构的复杂性**：然而，真实架构很难进行形式化描述，因此描述要么被过度简化，导致非常初级的代码生成器，要么与代码发射器本身一样难以编写。
**2.3.2 抽象机器和代码展开**

**方法概述**

为了编写更可移植的编译器，一种流行的方法是为给定的机器生成代码，然后将此代码翻译为各种目标机器的本机代码。中间的机器不必是真实的：它可以是专为适应源语言而设计的抽象机器。

**示例：Le Lisp系统**

例如，Chailloux等人的Le Lisp系统[18]完全围绕LLM3抽象机器[17]构建。在这种方法中，编译器的与机器无关部分做出了所有艰难的决策（例如，寄存器分配）。然后，将抽象机器映射到真实架构本质上是微不足道的：每个抽象指令被展开为一系列真实的指令，而不考虑上下文。

**代码展开器的优点**

- **易于编写**：这样的代码展开器相当容易编写，因此将系统移植到另一种架构变得可管理（一个熟练的黑客只需一两周就能移植整个Le Lisp系统）。
**问题**

- **生成低效代码**：通常会生成丑陋的代码，存在大量冗余，并且只使用目标机器能力的一小部分。
**解决方案：优化**

- **微代码优化（Peephole optimization）**：在展开后进行优化，检测并移除无用的指令序列，将多个指令压缩为一个。
- **困难之处**：优秀的微代码优化器难以编写，并且高度依赖于具体机器，就像前面提到的代码生成器一样。
**替代方法：复杂的展开**

- **模拟栈移动**：一个著名的技巧是将基于栈的抽象机器映射到基于寄存器的处理器上，尝试在翻译期间模拟栈移动，以便将“推入”（push）指令和匹配的“弹出”（pop）指令替换为对空闲寄存器的读写，成本更低[50, p. 328]。参见[52]，了解CAML系统中实际实现的描述。
**时机问题**

- **信息丢失**：通常，生成真正优秀的代码为时已晚，因为抽象机器代码包含的信息比原始程序少。
- **评估顺序固定**：例如，抽象机器代码固定了评估顺序，因此几乎不可能重新排列子表达式的评估（也无法知道是否允许这样做，即这些子表达式是否没有副作用）。
- **信息推断困难**：当编译器特别简单时，可能可以从抽象机器代码中推断出此类信息，但这显然是荒谬的（直接从抽象语法树开始会更容易！）。
**2.3.3 翻译为另一种高级语言**

**问题**

- **低级代码的局限性**：前一种方法的主要弱点是编译器的输出（即抽象机器代码）过于低级，无法进行良好的代码生成。
**反向思考**

- **替代方法**：将源程序翻译为另一种高级语言，然后使用该语言的优秀编译器。
- **节省工作量**：可以节省大量工作：所有艰苦的工作（即为许多机器生成优良代码）都由他人完成，我们只需处理ML独特的高级特性，如类型推断和模式匹配编译。
**选择目标语言的标准**

- **标准化和流行度**：如果我们选择一种足够标准化、流行的目标语言，那么我们的实现将具有高度的可移植性，如果存在优秀的编译器，效率也相当高。
- **隐藏目标语言**：必须小心完全隐藏目标语言，以避免用户接触到它。
**候选目标语言**

1. **词法作用域的Lisp方言**
- **共同点**：这些语言与ML有重要的共同点：它们将函数作为一等值，并且一切都有值（即没有语句，只有表达式）。
- **优秀的编译器**：此外，已经有大量工作致力于为其实现高效的编译器（例如，Scheme的Orbit编译器[35]）。
2. **放弃Lisp的原因**
- **可用性问题**：并非每台机器上都有优秀的Lisp编译器。
- **方言众多**：许多方言并存，进一步限制了我们实现的潜在用户数量。
- **难以隐藏Lisp系统**：Lisp实现通常围绕一个toplevel构建，因此很难将底层的Lisp系统从用户中隐藏起来（正如ML 6.2的开发者和用户所深知的，ML 6.2是CAML的基于Le Lisp的前身）。
- **过于高级的抽象**：Lisp过于高级，无法访问机器的内部。例如，大多数Lisp方言无法表达它们自己的垃圾收集器和运行时系统，或直接与操作系统通信。
- **内存模型的不匹配**：Lisp的内存模型对“conses”（对）有很强的强调，几乎忽略了其他数据结构，如任意元组，或者提供它们，但实现效率低下（例如Le Lisp[18]）。然而，在ML中，三元组或单元元组的使用频率几乎与对等同，因此Lisp的内存模型并不适合编码ML的值，同时Lisp又阻止我们构建专门适用于ML的内存模型。
**更好的目标语言：C**

- **普遍可用性**：C编译器在所有Unix机器上都可用，Unix正变得越来越普及，其他平台（特别是微型计算机领域）也正在转向C作为主要的开发语言。
- **标准化进程**：C正在被标准化，即使大多数Unix C编译器不符合ANSI标准，它们都实现了第一版[33]中精确定义的核心语言，它们的特殊性很小（只需少量宏即可克服！）。
- **高效性和灵活性**：由于非常宽松的语义，C通常被高效编译。此外，C允许完全访问机器的内部，通过指针类型、指针算术和非常宽松的“类型转换”操作符。
- **管道式编译器**：Unix C编译器是“批处理”编译器，设计用于作为管道的一部分使用。
**C的应用实例**

- **C作为可移植的汇编语言**：因此，C似乎是我们一直在寻找的可移植汇编语言。我们并非唯一这样想的人，因为C已经是Bell Labs最初的C++实现、DEC和Olivetti的Modula-3实现以及京都Common Lisp的目标语言，举几个例子。
**生成C代码的缺点**

1. **交互性困难**
- **编译时间长**：调用批处理C编译器需要花费太多时间，无法在toplevel上为每个输入的短语都这样做。
- **需要解释器**：我们必须回到ML解释器来运行toplevel计算。
2. **垃圾收集器的集成困难**
- **复杂且混乱**：将垃圾收集器与C程序集成并不容易，而且相当混乱。
- **非可移植的汇编代码需求**：需要一些非可移植的汇编代码来获取寄存器的内容，并将它们提供给垃圾收集器，因为这些内容是内存图的根。
- **根的歧义性**：寄存器可能包含编译器生成的临时变量，其位模式看起来像堆中的指针，但实际上并非堆中的指针。
- **垃圾收集器的限制**：由此，指向这些模糊根的对象无法被释放或重定位。因此，通常高效的复制式收集器无法使用，我们必须使用效率低下的非压缩收集器，或更复杂的“主要复制”收集器，如[8]中的收集器。
**2.3.4 解释抽象机器代码**

**抽象机器的价值**

- **说明和规范执行模型的便利性**：使用抽象机器本身并非一个坏主意：它是解释和精确定义执行模型的非常方便的方式。
- **新的方法**：另一种方法是使用抽象机器的模拟器，即直接解释抽象机器代码的程序（在这种情况下通常称为字节码）。
**解释器的名声**

- **不良声誉**：在编程语言领域，解释器的声誉不佳；在大多数人心中，它与Lisp（最好情况下）或Basic（最坏情况下）联系在一起。
- **与传统解释器的区别**：这里考虑的方法完全不同：我们不直接解释源程序，而是首先将其编译为非常低级的代码。解析、作用域处理、符号表处理、高级构造的简化为低级构造，以及所有其他复杂的工作都已由编译器静态完成；解释器在运行时所要做的只是模拟某个低级机器。
**可移植性问题的解决**

- **固定的抽象机器**：抽象机器是固定的，不依赖于任何实际的硬件，因此编译器完全与机器无关。
- **高层语言编写的解释器**：如果字节码解释器用一些流行的高级语言（如C）编写，那么只要有C编译器，就可以在任何机器上运行，几乎不需要修改。
- **最坏情况下的移植**：在最坏的情况下，可能需要完全重写字节码解释器以将其移植到另一台机器上；但与编译器相比，这是一个小而简单的程序，编译器无需修改。
**对目标代码的完全控制**

- **设计机器无关的字节码**：例如，可以设计完全与机器无关的字节码，可以在任何类型的机器上不加修改地运行；这在异构网络的情况下非常重要。
- **“独立”代码**：我们还可以要求代码完全“独立”，即可重定位且不引用外部数据。这样，代码可以像任何其他数据一样被操作，例如写入文件或通过网络发送；这对于声称函数是一等值的函数式语言来说至关重要，就像整数或字符串一样。
- **Cardelli的Amber语言**：Cardelli的Amber语言[12]首次实现了这一点，得益于为此设计的字节码[13]。
- **新前景**：同时具有机器无关性和“独立性”的字节码开启了新的前景：例如，可以想象在异构网络的各种机器上运行多个解释器，通过网络交换代码片段，在它们之间分配计算任务。
**解释字节码的主要缺点：执行速度**

- **解释开销**：主要的缺点当然是执行速度，即臭名昭著的“解释开销”。
**深入分析解释的开销**

解释器包含执行抽象机器每个指令的代码。这个代码大致相当于展开为机器码后会产生的代码。因此，解释引入的减速并非来自这里。

**额外的计算**

解释需要以下额外的计算：

1. **额外的编码**
- **问题**：如果用高级语言编写，解释器可能无法直接操作字节码使用的对象，某种编码就变得必要。
- **示例**：例如，可能难以在主机处理器的实际寄存器中存储抽象机器的寄存器。同样，用Pascal编写的解释器无法执行指针算术，因此必须将抽象机器的堆表示为一个数组，地址作为数组的偏移量，字节码中的内存访问变成数组索引，这比指针解引用要慢。
2. **指令获取和解码**
- **内容**：这包括从字节码流中读取下一条指令，从操作码中提取可能的操作数，并分支到将执行读取指令的解释器部分。
- **硬件差异**：所有这些计算在实际机器中由硬件或微码执行。
3. **未专门化的代码**
- **问题**：执行一条字节码指令的代码是通用的，因为它必须处理所有可能的操作数值。有时，然而，可以使用成本更低的指令序列；例如，递增一个整数比添加两个整数通常更快；但一个以1为第二操作数的Add指令当然会由通用的加法执行，而不是更便宜的递增操作。
**解决额外编码的问题**

- **使用C语言**：第一个问题（额外的编码）可以通过使用某种能够完全访问主机机器内部的语言编写解释器来解决。汇编语言是一个明显的候选，但它不可移植。C语言可移植，并且通过指针算术和将局部变量放入寄存器的能力，几乎提供了与直接“操纵”主机处理器相同的功能。
**未专门化代码的影响较小**

- **实际影响不大**：第三个效率低下的来源（未专门化的代码）在实践中并不重要（远小于指令获取的成本！），并且可以通过在字节码中引入新的、专门的指令轻松修复，例如，使用Succ指令来执行与Add指令第二操作数为1相同的工作。
**指令获取成本的关键性**

- **需要减少操作码的解码**：必须尽可能减少操作码的解码。这禁止在操作码中放置寻址模式。
- **隐式操作数位置**：操作数的位置必须是隐式的，而不是明确包含在操作码中。
- **栈式机器的优势**：这就是为什么字节码解释更适合于基于栈的机器，而不是基于寄存器的机器。
**简化的指令格式**

- **简单格式**：对于基于栈的机器，可以使用非常简单的指令格式：一个字节用于存储操作码，其他什么都不需要；额外的操作数（例如常量）存储在后续字节中。
- **指令解码的简化**：然后，指令解码和获取只需一次内存访问，随后通过一个表进行跳转。
**在C语言中的实现**

```c
char * pc;
while(1)
  switch(*pc++) {
    case 0: /* Push */
      *--stack_pointer = accu;
      break;
    case 1: /* Pop */
      accu = *stack_pointer++;
      break;
    case 2: /* Quote */
      accu = *(long *)pc;
      pc += sizeof(int);
      break;
    /* etc */
  }
```

**效率问题**

- **指令获取的成本**：这个代码看起来是最优的。然而，对于像Push这样的简单指令，指令获取（即switch结构）花费的时间比实际执行的时间还要多。这意味着解释将执行速度降低了一半。
**降低开销的方法**

1. **减少要执行的指令数量**
- **复杂指令**：这当然意味着使用更复杂的指令，执行更多的工作。
- **指令合并**：一种实现方法是将经常使用的指令序列压缩为一条指令。例如，假设Quote将常量加载到累加器中，Push将累加器存储到栈顶，那么序列Quote <cst>; Push很常见，可以用单个指令QuotePush <cst>替换，因为它只需要一次指令获取，而不是两次。
- **优化编译器的机会**：更复杂的指令还有一个额外的好处：执行一条指令的C代码越大，优秀的编译器就越能“优化”它。
2. **部分求值指令获取和解码循环**
- **方法**：例如，我们可以用解释它的例程的地址来表示一条指令，而不是它的操作码。这样，通过表的跳转就可以被更便宜的索引跳转所取代。
- **实现示例**：
```c
label * pc;
goto *pc++; /* 开始执行 */
Push:
  *--stack_pointer = accu; goto *pc++;
Pop:
  accu = *stack_pointer++; goto *pc++;
/* etc */
```
- **解释**：对于每个指令，我们将其与执行它的例程相关联，然后获取下一条指令，即下一次要执行的例程的地址，并直接跳转到它。这种技术称为线程化代码解释（threaded code interpretation），通常用于实现Forth[41]。
- **效率提升**：它将解释开销降低了一半。
- **实现困难**：遗憾的是，我未能在C中实现这种技术，因此需要一些汇编语言。这似乎是最有效的解释技术。
**进一步优化的限制**

- **极限**：向部分求值迈进的下一步当然是完全消除指令获取，通过直接按照正确的顺序连接执行指令的例程，但这正是前面提到的展开为本机机器代码！
**总结**

- **解释抽象机器代码的优势****可移植性**：解释抽象机器代码似乎是获得真正可移植的ML实现以及能够像操作任何其他值一样操作代码（例如，将函数写入文件）的唯一方法。**控制权**：我们对目标代码有完全的控制。**代码作为数据**：可以设计完全与机器无关且“独立”的字节码，这对于功能性语言来说非常重要。
- **克服解释开销的方法****精心设计的抽象机器**：通过精心设计抽象机器，减少所需的指令数量。**解释器的技巧**：在解释器中使用一些技巧，例如线程化代码而不是字节码。
- **实践中的可行性****ZINC的尝试**：通过在ZINC中使用这些技术，我试图看看它们是否足以使这种开销在实践中可以容忍。
**2.4 对toplevel的批判**

（虽然你的问题中只包括了2.3节的内容，但如果你需要对2.4节的详细解读，请告知，我可以继续为你详解。）
 #  
 Thought for 26 seconds
**概览**

第2.4节讨论了与ML（MetaLanguage）编译器交互的两种主要方法：传统的以顶层（toplevel）为中心的方法和以独立编译为导向的方法。作者首先批判了传统的顶层循环方法，指出其在批处理使用、模块管理和独立程序生成方面的局限性。然后，他提出了一种替代方案，即类似Unix的架构，强调独立编译和生成小型的、独立的程序。这种方法更符合Unix的设计哲学，便于与其他工具集成，且有利于程序的调试、测试和部署。

**内容详解**

**2.4 顶层循环的弊端**

**引言**

本节探讨了用户如何与ML编译器交互的方式，重点关注了顶层循环（toplevel loop）的使用和其潜在的问题。

**2.4.1 以顶层为中心的方法**

**顶层循环的介绍**

- **概念**：通常的ML实现（如SML-NJ或CAML）主要围绕一个“顶层”循环构建。其理念与Lisp著名的“读取、求值、打印”循环相同。
- **过程**：与Lisp不同的是，每个短语（phrase）都被即时编译，然后执行以获取其值，因此实际上是一个“读取、编译、执行、打印”循环。
- **交互性**：这导致了完全交互式的系统，非常适合学习语言。特别是，能够看到刚输入的短语的值以及推断出的类型是令人着迷的。
**顶层循环的优点**

- **系统交互**：顶层循环提供了一种与系统“对话”的简单方式，即指定编译选项、加载文件、在函数上设置断点等。
- **示例**：要跟踪函数foobar，只需执行trace "foobar"。
**加载文件的局限性**

- **输入重定向**：可以加载文件的内容，但这几乎等同于输入重定向。
- **重复编译**：文件中的所有短语在每次加载时都会重新编译。
- **CAML的改进**：为节省工作，CAML能够将编译后的代码放入另一个文件，然后直接加载已编译的代码，而无需重新编译。
**独立编译的安全问题**

- **类型检查环境的不一致**：这种独立编译功能完全不安全，因为文件在编译时是在给定的全局环境中进行类型检查的，但没有任何机制阻止它在之后的不同环境中加载。
- **示例问题**：例如，一个引用函数foo的文件，在foo具有类型int->int的环境中编译，可能会在foo未定义的核心映像中加载，或者更糟的是，foo被定义为另一个类型。
**模块系统的引入**

- **解决方案**：为了防止上述情况的发生，SML和CAML都添加了模块系统。
- **模块的作用**：基本上，模块必须显式声明它期望在当前全局环境中找到的全局值及其类型，并在加载时检查这些全局值是否确实已定义且具有预期的类型。
- **类型安全性**：通过这种方式，即使在独立编译的情况下，也能确保类型安全。
**顶层方法的严重缺陷**

1. **批处理使用的困难**
- **Unix环境的特点**：批处理使用有时是有用的，特别是在Unix世界中。Unix编程环境是以“批处理”编译器为中心设计的，因此它们可以很容易地与其他通用实用程序组合，这些程序只执行一个简单的任务，但执行得很好，例如依赖处理器（make）、版本控制系统（sccs、rcs）、文本预处理器（sed、m4、awk）等。
- **顶层的局限性**：基于顶层的实现无法轻松地与这些工具进行管道连接；例如，几乎不可能使用make来处理程序的依赖关系。
- **集成的不可行性**：要在顶层中拥有上述所有功能，唯一的方法是将它们集成到系统中。这在实践中是不切实际的，因为系统会变得越来越大，用户必须重新学习如何使用这些功能。
2. **全局符号表的误导性**
- **单一全局符号表的问题**：只有一个全局符号表，在加载模块时会更新，这有时会产生误导。
- **模块重新加载的陷阱**：在重新编译和重新加载模块后，旧模块执行的绑定不会被丢弃，它们只是被新模块执行的绑定所隐藏，但如果某些导出的全局变量被重命名，它们仍可能显现出来。
- **示例问题**：**步骤**：有一个模块导出函数fobar，另一个模块导入并使用fobar。后来，发现fobar拼写错误，应为foobar，于是将第一个模块中的fobar重命名为foobar，但忘记在第二个模块中修改。还发现了foobar定义中的一个错误，因此进行了修改。然后重新加载两个模块。**问题**：没有发生错误，因为环境中仍有一个名为`fobar`的全局变量。第二个模块仍然使用旧的、有缺陷的`fobar`版本。**原因**：顶层保留了会话开始以来所做的定义的历史，因此用户程序的多个连续版本可能共存于内存中，并以奇怪的方式交互。
- **解决方法的缺乏**：当然，如果我们从头开始，模块系统会捕捉到这个错误。但问题在于，顶层保留了所有历史定义，使得这些问题难以及时发现。
3. **无法生成真正的独立程序**
- **同一进程的问题**：用户的程序被加载到运行顶层、编译器、调试器等的同一进程中；编译后的代码无法以其他方式执行。
- **核心映像的局限性**：因此，无法生成真正的独立程序；即使可以生成包含用户程序的可执行“核心映像”，这些“核心”仍包含整个系统（数兆字节的代码），即使它不再有用。
- **引导复杂性**：这使得引导（bootstrapping）更加复杂：需要一些技巧来获取最新版本系统的核心映像，该映像不包含用于编译最新版本的前一个版本的代码。
- **程序与元程序的混淆**：更普遍地说，用户的程序和元级程序（顶层、编译器等）之间没有任何区别，它们都生活在同一个世界中，这通常是荒谬的，特别是在引导的情况下。
**2.4.2 以独立编译为导向的方法**

**提出替代方案**

- **Unix风格的架构**：作为对以顶层为中心的实现的替代，作者提出了一种类似Unix的架构，面向独立编译和生成小型、独立的程序。
- **核心组件**：核心是一个独立的编译器，它接受一个源文件（模块的接口或实现），并生成相应的目标文件，即已编译的接口或符号代码流。
**编译和链接过程**

- **独立的链接器**：当一个程序的所有模块都已编译后，一个独立的链接器将目标代码文件聚集在一起，修复交叉引用等，并生成一个可执行文件。
- **字节码解释的情况**：在字节码解释的情况下，这个“可执行文件”实际上包含字节码，必须通过字节码解释器运行。
**组件总结**

- **三个主要程序**：编译器、链接器和解释器是生成独立程序所需的全部，也是如果它们用ZINC编写时引导编译器和链接器所需的全部。
**交互性的需求**

- **学习、测试和调试的需求**：然而，它们并未解决学习语言、测试和调试程序的问题。为此，必须提供一些交互式系统。
- **重用编译器和链接器**：想法是，如果编译器和链接器的大部分能够在交互式上下文中逐短语工作，那么一个短语可以被编译，与已定义的短语链接，并即时执行。
**构建交互式系统**

- **类似CAML的顶层**：这就是构建一个类似CAML的传统顶层所需的全部。
- **专门化的可能性**：但由于顶层不再是使用ZINC的基本机制，可能有趣的是为教学和调试目的专门化它，一方面限制它（例如禁止编译和加载整个模块），另一方面扩展它（能够询问“隐藏”变量的值，例如闭包的局部变量或模块的私有全局变量），甚至改变某些操作的语义。
**示例**

- **重新定义的语义变化**：例如，对于已经定义的f，let f = E可以被解释为f的重新定义，用E替换f的所有先前出现，而不是f的重新绑定（rebinding），后者不会更新先前对f的引用。前者对于调试目的肯定更有用。
**构建交互式ZINC系统**

- **混合特性**：换句话说，这个交互式的ZINC系统将是传统的、类似Lisp的顶层和现代的源代码级调试器的混合体。
- **与编辑器的集成**：与像Emacs[56]这样强大的文本编辑器的紧密集成也会很好。
**总结**

在第2.4节中，作者深入分析了传统的以顶层循环为中心的ML实现方法的局限性，特别是在批处理使用、模块管理和生成独立程序方面的问题。他指出，顶层方法在Unix环境中不利于与其他工具的集成，容易导致全局符号表的混乱，且无法生成真正的独立程序。

作为替代方案，作者提出了一种类似Unix的架构，强调独立编译和链接，生成小型的、独立的可执行文件。这种方法不仅符合Unix的设计哲学，而且有利于与其他工具（如`make`、版本控制系统等）集成。

为了满足学习、测试和调试的需求，作者建议在此基础上提供一个交互式系统，重用编译器和链接器的部分功能，允许逐短语编译、链接和执行。这种交互式系统可以专门化以适应教学和调试的需要，甚至可以改变某些操作的语义，以提高调试的效率。

总的来说，作者主张从以顶层为中心的方法转向以独立编译和生成独立程序为中心的方法，以克服传统方法的缺点，同时仍然满足用户对交互性和调试的需求。
 #  
 Thought for 14 seconds
**概览**

本章节介绍了ZINC（一个ML语言的经济实现）所使用的执行方法，特别是通过引入一种新的抽象机器来实现高效的多参数函数应用。传统的抽象机器，如SECD、FAM、CAM等，都在多次应用中需要构建多个中间闭包，导致效率低下。为了克服这一问题，作者首先介绍了Krivine的抽象机器，这是一种用于弱头范式（weak head normal form）求值的环境机器。然后，通过对Krivine的机器进行修改，作者设计了一种适用于严格（call-by-value）求值策略的抽象机器，能够在多次函数应用中避免不必要的闭包创建，从而提高执行效率。

**内容详解**

**3.1 Krivine的机器**

**3.1.1 介绍**

- **背景**：Krivine的抽象机器由J.-L. Krivine提出，用于对λ项进行弱头范式的求值，遵循标准的（最左、最外）策略。
- **特性**：在Krivine的机器中，λ项以闭包的形式表示，因此替换（substitutions）不会立即执行，而是被延迟，直到需要对变量求值时才进行。
- **目的**：通过介绍Krivine的机器，作者希望展示一种能够在多次函数应用中避免创建中间闭包的机制。
**指令集**

Krivine的机器只有三个指令：

1. **Access(n)**：访问环境中的第n个变量。
2. **Push**：将一个闭包压入栈。
3. **Grab**：处理λ抽象，捕获环境。
**编译规则**

- **变量**：[[n]] = Access(n)
- **应用**：[[(M N)]] = Push([[N]]); [[M]]
- **λ抽象**：[[λM]] = Grab; [[M]]
**机器的组成**

- **代码指针（Code）**：指向当前要执行的指令序列。
- **环境（Env）**：保存变量绑定的列表，每个元素是一个闭包（代码指针和环境的对）。
- **栈（Stack）**：保存待处理的闭包。
**状态转换规则**

1. **Access**：
- 如果访问环境中的第0个变量：将对应的闭包加载为当前执行状态。
- 如果访问环境中的第n+1个变量：递归地访问环境中的第n个变量。
2. **Push**：
- 将一个新的闭包（由代码指针和当前环境组成）压入栈。
3. **Grab**：
- 如果栈非空：从栈中弹出一个闭包，扩展当前环境，然后继续执行。
- 如果栈为空：表示遇到了一个λ抽象，需要等待参数。
**3.1.2 正确性**

为了证明Krivine机器的正确性，作者使用了Hardin和Lévy的λenv演算。这是一种显式处理替换的λ演算变体，适用于推迟替换的实现。

**λenv演算的定义**

- **语法**：**项（Terms）**：M ::= n | (M N) | λM | M[s]**替换（Substitutions）**：s ::= Id | Shift | M · s | s ◦ t | ⇑(s)
- **等式理论**：定义了一系列等式，用于表示项之间的等价关系。
**编码Krivine机器的状态**

- **代码序列与项的对应**：Access(n); c 对应于变量 nPush(c2); c1 对应于应用 (c1 c2)Grab; c 对应于λ抽象 λc
- **栈的编码**：栈中的闭包序列对应于一系列替换。
- **机器状态的项表示**：(c, e, s) 对应于项 (c[e] s0 ... sn)，其中s0 ... sn是栈中的闭包。
**正确性命题**

如果Krivine机器从状态 `(c1, e1, s1)` 转换到 `(c2, e2, s2)`，则对应的项是等价的，即 `(c1, e1, s1) = (c2, e2, s2)`。

**证明思路**

通过检查每个转换规则，验证机器状态对应的项在λenv演算中是等价的。

**3.1.3 多次应用**

- **问题**：在评估多次函数应用 `(M N1 ... Nk)` 时，传统的抽象机器需要创建 `k-1` 个中间闭包，导致效率低下。
- **Krivine机器的优势**：在执行多次应用时，只需要将参数 `Nk` 到 `N1` 的闭包压入栈，然后执行 `M`。每次遇到 `Grab` 指令（即λ抽象）时，从栈中弹出一个参数，将其添加到环境中，然后继续执行函数体。**关键点**：不需要为中间的部分应用（如 `(M N1)`、`(M N1 N2)` 等）创建闭包，仅需要为参数 `N1` 到 `Nk` 创建闭包。
- **比较**：**惰性CAM（Lazy CAM）**：需要创建 `2k - 1` 个闭包。**严格CAM（Strict CAM）** 和 **FAM**：需要创建 `k - 1` 个中间闭包。**Krivine机器**：只需要创建 `k` 个闭包（参数的闭包）。
**结论**

Krivine机器在多次应用中避免了创建中间闭包，实现了更高的效率。这为设计一种适用于严格求值的类似机器奠定了基础。

**3.2 带有栈标记的Krivine机器**

**引入**

为了使Krivine机器适用于严格（call-by-value）求值，需要能够在有可用参数的情况下停止对某些子项的求值。这需要在栈中的某些闭包上放置标记，指示“不将我放入环境，停止求值，恢复另一个求值过程”。

**3.2.1 介绍**

- **增加的指令**：添加了第四个指令 `Reduce(c)`，用于强制对 `c` 进行弱头范式的求值。
- **修改后的 Grab 指令**：当遇到带有标记的闭包时，不再将其添加到环境，而是切换到该闭包的求值。
- **标记闭包的表示**：用 `⟨c, e⟩` 表示带有标记的闭包。
**状态转换规则**

1. **Access**：与原来的Krivine机器相同。
2. **Push**：与原来的Krivine机器相同。
3. **Grab**：
- **正常情况**：如果栈顶是未标记的闭包，与原来的Krivine机器相同。
- **标记闭包**：如果栈顶是标记闭包，则切换到该闭包的求值，将当前的 `Grab` 指令和环境压入栈。
4. **Reduce**：
- 强制对给定的代码 c0 进行求值，将结果作为标记闭包压入栈。
**3.2.2 正确性**

- **机器状态的编码**需要扩展，以处理标记闭包。
- **证明思路**：通过证明每个状态转换保持项的等价性，验证机器的正确性。
**3.2.3 编译严格求值**

- **编译规则**：严格应用 `(M N)s` 编译为 `Reduce([[N]]); [[M]]`。
- **多次严格应用**：对于 `(M N1 ... Nk)s`，即 `((...((M N1)s N2)s ... Nk)s`，编译后执行时不会创建参数 `N1` 到 `Nk` 的闭包（因为它们被立即求值），也不会创建中间的部分应用闭包。
- **关键点**：在严格求值中，标记闭包不需要在堆上分配，因为它们不会被放入环境，只需在栈上处理即可。
- **结果**：严格的多次函数应用无需在堆上进行任何分配，实现了预期的高效性。
**总结**

本章节深入探讨了为ZINC设计高效的抽象机器的过程。传统的抽象机器在多次函数应用中需要创建多个中间闭包，导致效率低下。通过引入Krivine的机器，作者展示了一种能够在多次应用中避免创建中间闭包的机制。然而，Krivine的机器最初适用于惰性求值。

为适应严格求值，作者对Krivine的机器进行了修改，添加了栈标记和新的 `Reduce` 指令。这使得机器能够在有可用参数的情况下停止对某些子项的求值，并切换到其他求值过程。在严格的多次函数应用中，修改后的Krivine机器避免了在堆上分配闭包，只需在栈上处理标记闭包，从而实现了高效的执行。

通过对机器的正确性证明，作者验证了修改后的Krivine机器在严格求值下的有效性。最终，这种设计满足了ZINC的需求，即实现高效的多次函数应用，避免了传统抽象机器的效率问题。
 #  
 Thought for a few seconds
**概览**

本章节介绍了ZINC（一种ML语言的经济实现）所使用的执行方法。作者通过引入一种新的抽象机器，旨在实现对多个参数的高效函数应用，避免传统抽象机器在多次应用中需要构建多个中间闭包的问题。为此，作者首先介绍了Krivine的抽象机器，这是一种用于弱头范式（weak head normal form）求值的环境机器。然后，作者对Krivine的机器进行了修改，增加了栈上的标记，以适应严格（call-by-value）求值策略，从而在多次函数应用中避免不必要的闭包创建，提高执行效率。

**内容详解**

**第3章 抽象机器**

**引言**

- **目的**：本章介绍ZINC的执行方法，特别是通过一个抽象机器来指定执行模型。
- **背景**：对于严格的函数式语言，已有许多抽象机器，如Landin的SECD[37]、Cardelli的FAM[11]、Curien的CAM[20]等。然而，这些机器在多次应用到k个参数时，需要构建k-1个中间闭包，效率不高。
- **挑战**：作者希望设计一种新的抽象机器，使得对k个参数的多次应用几乎与调用一个k元函数一样高效。
**3.1 Krivine的机器**

**3.1.1 介绍**

- **Krivine的抽象机器**：由J.-L. Krivine提出[36, 21]，用于按照标准（最左、最外）策略进行弱头范式的求值。
- **特性**：λ项以闭包的形式表示，替换被延迟，直到需要对变量求值时才执行。
**语法和编译规则**

- **λ项的表示**：使用de Bruijn表示法[10]，消除了变量名，使用整数索引。
- **指令集**：只有三个指令：**Access(n)**：访问环境中第n个变量。**Push**：将一个闭包压入栈。**Grab**：处理λ抽象。
- **编译规则**：**变量**：[[n]] = Access(n)**应用**：[[(M N)]] = Push([[N]]); [[M]]**λ抽象**：[[λM]] = Grab; [[M]]
**机器的组成**

- **代码指针（Code）**：当前执行的指令序列。
- **环境（Env）**：保存变量绑定的列表，元素是闭包（代码指针和环境的对）。
- **栈（Stack）**：保存待处理的闭包。
**状态转换规则**

- **Access指令**：如果n = 0：从环境中获取第0个闭包(c0, e0)。转换为状态(c0, e0, s)。如果n > 0：减少n，继续访问环境中的下一个闭包。
- **Push指令**：将当前环境中的闭包(c0, e)压入栈。
- **Grab指令**：如果栈非空：从栈中弹出一个闭包(c0, e0)。扩展当前环境：(c0, e0) · e（将闭包添加到环境中）。继续执行。如果栈为空：终止或等待进一步的输入。
**示例**

假设我们有一个λ项`((λx. x) y)`，使用de Bruijn表示为`(λ 0) 1`。

- **编译过程**：[[λ 0]] = Grab; Access(0)[[1]] = Access(1)[((λ 0) 1)] = Push(Access(1)); Grab; Access(0)
- **执行过程**：初始状态：(Grab; Access(0), e, s)执行Grab，栈上有(Access(1), e)。将(Access(1), e)加入环境，环境变为(Access(1), e) · e。执行Access(0)，获取环境中的第0个闭包，即Access(1)。继续执行Access(1)，从环境中获取第1个闭包。
**3.1.2 正确性**

为了形式化地证明Krivine机器的正确性，作者引入了Hardin和Lévy的λenv演算[27]。

**λenv演算**

- **目的**：显式地处理替换，为推迟替换的实现提供一个良好的理论框架。
- **语法**：**项（Terms）**：M ::= n | (M N) | λM | M[s]**替换（Substitutions）**：s ::= Id | Shift | M · s | s ◦ t | ⇑(s)
- **等式规则**：定义了一系列等式，用于项和替换之间的转换和等价。
**关键等式规则**

- **Beta规约**：(λM) N = M[N · Id]
- **应用的替换**：(M N)[s] = M[s] N[s]
- **λ抽象的替换**：(λM)[s] = λ(M[⇑(s)])
- **变量替换**：自由变量：1[M · s] = M绑定变量：n + 1[M · s] = n[s]
**机器状态的编码**

- **指令序列与项的对应**：Access(n); c 对应于变量nPush(c2); c1 对应于应用(c1 c2)Grab; c 对应于λ抽象λc
- **栈的表示**：栈中的闭包序列对应于替换序列。
- **机器状态的项表示**：(c, e, s) 对应于项(c[e] c0[e0] ... cn[en])，其中(c0, e0)...(cn, en)是栈中的闭包。
**正确性命题**

- **命题1**：如果Krivine机器从状态(c1, e1, s1)转换到(c2, e2, s2)，则对应的项是等价的，即(c1, e1, s1) = (c2, e2, s2)。
- **证明思路**：验证每个转换规则保持项的等价性，使用λenv演算的等式规则。
**证明示例**

- **Access(0)指令**：状态转换：Access(0); c, (c0, e0) · e, s → c0, e0, s对应的项：1[c0[e0] · e] = c0[e0]，符合FVar规则。
- **Grab指令（栈非空）**：状态转换：Grab; c, e, (c0, e0) · s → c, (c0, e0) · e, s对应的项：((λM)[s] N) = M[N · s]，符合Beta规约和Closure规则。
**3.1.3 多次应用**

- **问题**：传统的抽象机器在评估多次应用(M N1 ... Nk)时，需要构建k - 1个中间闭包，效率低下。
- **Krivine机器的优势**：只需将参数的闭包压入栈，无需为中间应用构建闭包。在执行M时，遇到Grab指令，从栈中弹出参数，将其加入环境，继续执行。
- **对比**：**惰性CAM**：需要构建2k - 1个闭包。**严格CAM和FAM**：需要构建k - 1个中间闭包。**Krivine机器**：仅构建k个参数闭包。
**结论**

- Krivine机器在多次函数应用中更为高效，避免了中间闭包的创建。
**3.2 带有栈标记的Krivine机器**

**引入**

- **问题**：Krivine机器适用于惰性求值，但我们需要一种适用于严格求值（call-by-value）的机器。
- **解决方案**：在栈上的闭包添加标记，指示何时停止求值和恢复其他求值过程。
- **灵感**：这种标记的想法来自Fairbairn和Wray的三指令机器（Three-Instruction Machine）[24]，以及Crégut对Krivine机器的应用[21]。
**3.2.1 介绍**

- **新增指令**：Reduce(c)，用于强制对代码c进行弱头范式的求值。
- **修改后的Grab指令**：当栈顶是未标记的闭包时，行为与原Krivine机器相同。当栈顶是标记闭包时，切换到该闭包的求值，将当前状态压入栈。
- **标记闭包的表示**：用⟨c, e⟩表示标记闭包。
**状态转换规则**

1. **Access指令**：
- 与原来的Krivine机器相同。
2. **Push指令**：
- 与原来的Krivine机器相同。
3. **Grab指令**：
- **未标记闭包**：Grab; c, e, (c0, e0) · s → c, (c0, e0) · e, s
- **标记闭包**：Grab; c, e, ⟨c0, e0⟩ · s → c0, e0, (Grab; c, e) · s
4. **Reduce指令**：
- Reduce(c0); c, e, s → c0, e, ⟨c, e⟩ · s
**解释**

- **标记闭包的作用**：当遇到标记闭包时，不将其加入环境，而是切换到该闭包的求值，这样可以在有可用参数的情况下停止求值。
- **Reduce指令的作用**：强制对参数进行求值，在严格求值策略下，需要先对参数求值再应用函数。
**3.2.2 正确性**

- **机器状态的编码**需要扩展，以处理标记闭包。
- **项的表示**：**未标记栈元素**：(c, e, s · (c0, e0)) = ((c[e] c0[e0] ...))**标记栈元素**：(c, e, s · ⟨c0, e0⟩) = (c0[e0] c[e] s)
- **正确性命题**：**命题2**：如果机器状态从(c1, e1, s1)转换到(c2, e2, s2)，则对应的项是等价的，即(c1, e1, s1) = (c2, e2, s2)。
- **证明思路**：检查新增的状态转换规则，验证它们保持项的等价性。**示例**：**Grab指令（标记闭包）**：(c, e, ⟨c0, e0⟩ · s) ≡ (c0[e0] (c[e] s))，通过对s的归纳证明。**Reduce指令**：(Reduce(c2); c1, e, s) ≡ (c1[e] c2[e])，与状态转换后的项表示相符。
**3.2.3 编译严格求值**

- **编译规则**：**严格应用**：[[(M N)s]] = Reduce([[N]]); [[M]]
- **执行过程**：对于严格的多次应用(M N1 ... Nk)s，编译为Reduce([[Nk]]); ...; Reduce([[N1]]); [[M]]在执行时，对参数N1到Nk进行求值，结果作为标记闭包压入栈。执行M时，遇到Grab指令，从栈中弹出标记闭包，切换到参数的求值。
- **避免堆分配**：标记闭包只在栈上处理，不需要在堆上分配内存。因为这些标记闭包不会被放入环境中，无法在其他地方引用。
**关键点**

- **效率提升**：严格的多次函数应用无需在堆上进行任何分配，实现了高效的执行。
- **堆栈的使用**：所有的闭包处理都在栈上完成，避免了堆上的内存分配和垃圾回收的开销。
**总结**

本章节深入探讨了为ZINC设计高效抽象机器的过程。传统的抽象机器在多次函数应用中需要创建多个中间闭包，导致执行效率低下。作者首先介绍了Krivine的抽象机器，它在多次应用中避免了中间闭包的创建，但适用于惰性求值。

为了适应严格求值策略，作者对Krivine的机器进行了修改，添加了栈上的标记和新的`Reduce`指令。通过在栈上处理标记闭包，机器能够在严格求值中避免创建不必要的闭包，提高了执行效率。在多次严格应用中，修改后的Krivine机器无需在堆上分配内存，只需在栈上进行操作，实现了预期的高效性。

作者还通过形式化的证明，验证了修改后的Krivine机器在严格求值下的正确性。最终，这种设计满足了ZINC的需求，即实现高效的多次函数应用，避免了传统抽象机器的效率问题，为ZINC的高效执行奠定了基础。
 #  
 Thought for 46 seconds
**概览**

本段内容来自《ZINC实验：ML语言的经济实现》（The ZINC experiment: an economical implementation of the ML language）的第3.3节，介绍了ZINC机器（ZAM）的设计和工作原理。ZINC机器是对Krivine抽象机器的改进，专门用于严格（call-by-value）求值策略，并扩展了对常量的处理。作者详细描述了ZINC机器的架构，包括其寄存器、栈结构，以及指令集。还提供了两种编译方案：一种用于尾调用位置的表达式，另一种用于一般的表达式。本文逐步解释每个部分的内容，帮助理解ZINC机器的设计思想和实现细节。

**内容详解**

### **3.3 ZINC机器**

**ZINC机器的概念**

- **Krivine机器的扩展**：ZINC机器可以看作是Krivine机器的一个变体，专门针对严格（call-by-value）求值，并扩展了对常量的处理能力。
- **设计背景**：作者最初的设计更为实际，旨在设计一种基于栈的调用约定，其中函数可能不消耗其所有参数（类似于C语言），但其结果必须应用于剩余的参数。这导致了ZINC机器与Krivine机器之间的一些细微差别。
**ZINC机器的组成**

- **代码指针（Code Pointer）**：指向当前要执行的指令序列。
- **环境寄存器（Environment Register）**：保存当前环境，环境是值的列表，包括表示函数的闭包或常量（如整数、布尔值等）。
- **累加器（Accumulator）**：用于保存中间结果。由于ZINC机器处理常量，累加器是必要的；而在只处理闭包的Krivine机器中，累加器是不需要的。
- **栈的结构**：Krivine机器的栈被拆分为两个栈：**参数栈（Argument Stack）**：保存函数调用的参数，即一系列值，由标记（marks）分隔。标记现在不再是特殊的闭包，而是一个特殊的值，记作`ε`。**返回栈（Return Stack）**：保存未分配的闭包，即代码指针和环境的对。
- **设计优势**：**减少栈移动**：将栈拆分为两个部分，有助于减少栈操作的次数。**环境表示的改进**：这种设计允许进一步改进环境的表示方式。
**编译方案**

- **两种编译方案**：**T[[E]]**：用于尾调用位置的表达式`E`，即函数体正在评估的表达式，其值将直接作为函数的返回值。**C[[E]]**：适用于所有表达式，但通常效率较低。
- **说明**：作者将在后续部分定义这两种编译方案，并给出对应的ZAM指令的状态转换。
### **3.3.1 访问局部变量**

**编译方案**

- **局部变量的编译**：对于索引为`n`的局部变量，编译方案为：
```lua
T[[n]] = C[[n]] = Access(n)
```
**Access指令的语义**

- **目的**：从环境中获取第`n`个值。
- **状态转换**：**初始状态**：
```yaml
Code: Access(n); c
Accu: a
Env: e = v0, v1, ..., vn, ...
Arg. stack: s
Return stack: r
```
**转换后状态**：
```yaml
Code: c
Accu: vn (环境中的第n个值)
Env: e
Arg. stack: s
Return stack: r
```
- **解释**：**Accu（累加器）**：将环境中第`n`个值加载到累加器中。**环境（Env）**：环境保持不变。**栈**：参数栈和返回栈保持不变。
### **3.3.2 应用（函数调用）**

**编译方案**

- **尾调用位置的应用**（Tail Application）：
```lua
T[[(M N1 ... Nk)]] = C[[Nk]]; Push; ...; C[[N1]]; Push; C[[M]]; Appterm
```
- **一般的应用**：
```lua
C[[(M N1 ... Nk)]] = Pushmark; C[[Nk]]; Push; ...; C[[N1]]; Push; C[[M]]; Apply
```
- **说明**：**多参数应用**：应用自然是多参数的。**参数顺序**：参数从`N1`到`Nk`，但在编译时，从右到左处理，即首先编译`Nk`。
- **区别**：**Tail Application**：**不需要Pushmark**：在尾调用位置，不需要通过Pushmark来分隔参数，因为没有后续的计算需要保存上下文。**使用Appterm指令**：Appterm指令处理尾调用优化。**一般应用**：**需要Pushmark**：为了分隔新的参数并强制对函数进行弱头范式的求值，需要在参数栈上推入一个标记。**使用Apply指令**：Apply指令处理一般的函数调用，需要保存返回地址。
**指令的语义**

1. **Appterm指令**（用于尾调用）：
- **初始状态**：
```yaml
Code: Appterm; c0
Accu: a = (c1, e1) （函数闭包）
Env: e0
Arg. stack: v . s
Return stack: r
```
- **转换后状态**：
```yaml
Code: c1
Accu: a
Env: v . e1 （将参数v添加到函数的环境中）
Arg. stack: s
Return stack: r
```
- **解释**：**函数调用**：将参数与函数的环境合并，继续执行函数的代码`c1`。**尾调用优化**：由于是在尾调用位置，不需要保存当前的返回地址。
2. **Apply指令**（用于一般的函数调用）：
- **初始状态**：
```yaml
Code: Apply; c0
Accu: a = (c1, e1) （函数闭包）
Env: e0
Arg. stack: v . s
Return stack: r
```
- **转换后状态**：
```yaml
Code: c1
Accu: a
Env: v . e1
Arg. stack: s
Return stack: (c0, e0) . r （保存当前的返回地址）
```
- **解释**：**函数调用**：与Appterm类似，但需要保存返回地址以便后续返回。
3. **Push指令**：
- **初始状态**：
```yaml
Code: Push; c0
Accu: a
Env: e
Arg. stack: s
Return stack: r
```
- **转换后状态**：
```yaml
Code: c0
Accu: a
Env: e
Arg. stack: a . s （将累加器中的值推入参数栈）
Return stack: r
```
- **解释**：**参数传递**：将当前的累加器值作为参数，推入参数栈。
4. **Pushmark指令**：
- **初始状态**：
```yaml
Code: Pushmark; c0
Accu: a
Env: e
Arg. stack: s
Return stack: r
```
- **转换后状态**：
```yaml
Code: c0
Accu: a
Env: e
Arg. stack: ε . s （推入一个标记）
Return stack: r
```
- **解释**：**参数栈分隔**：推入一个标记，用于分隔新参数，标记参数栈的边界。
**多参数应用的处理**

- **参数顺序**：由于参数从右到左被推入栈，因此最左边的参数`N1`最后被推入。
- **函数调用过程**：**一般应用**：推入标记（Pushmark）。推入参数`Nk`到`N1`。将函数`M`的编译结果放入累加器。执行Apply指令。**尾调用应用**：不推入标记。推入参数`Nk`到`N1`。将函数`M`的编译结果放入累加器。执行Appterm指令。
### **3.3.3 抽象（λ表达式）**

**编译方案**

- **尾调用位置的抽象**：
```lua
T[[λE]] = Grab; T[[E]]
```
- **一般的抽象**：
```lua
C[[λE]] = Cur(T[[E]]; Return)
```
**指令的语义**

1. **Grab指令**（用于尾调用位置）：
- **目的**：处理λ抽象，在需要时捕获参数。
- **情况一：参数栈顶是标记（参数已耗尽）**：**初始状态**：
```yaml
Code: Grab; c0
Accu: a
Env: e0
Arg. stack: ε . s
Return stack: (c1, e1) . r
```
**转换后状态**：
```yaml
Code: c1
Accu: (c0, e0) （构建当前闭包）
Env: e1
Arg. stack: s
Return stack: r
```
**解释**：**返回闭包**：参数已耗尽，构建当前代码和环境的闭包，返回给调用者。
- **情况二：参数栈顶是值（还有参数可用）**：**初始状态**：
```yaml
Code: Grab; c
Accu: a
Env: e
Arg. stack: v . s
Return stack: r
```
**转换后状态**：
```yaml
Code: c
Accu: a
Env: v . e （将参数加入环境）
Arg. stack: s
Return stack: r
```
**解释**：**继续执行函数体**：将下一个参数加入环境，继续执行函数体。
2. **Cur指令**（用于一般的抽象）：
- **初始状态**：
```yaml
Code: Cur(c1); c0
Accu: a
Env: e
Arg. stack: s
Return stack: r
```
- **转换后状态**：
```yaml
Code: c0
Accu: (c1, e) （构建闭包）
Env: e
Arg. stack: s
Return stack: r
```
- **解释**：**构建闭包**：直接将函数体的代码和当前环境构建成闭包，放入累加器。**适用于非尾调用位置**：由于后续可能有更多的计算，不需要立即执行函数体。
3. **Return指令**：
- **目的**：终止函数体的执行，返回结果。
- **情况一：参数栈顶是标记（参数已耗尽）**：**初始状态**：
```vbnet
Code: Return; c0
Accu: a
Env: e0
Arg. stack: ε . s
Return stack: (c1, e1) . r
```
**转换后状态**：
```yaml
Code: c1
Accu: a
Env: e1
Arg. stack: s
Return stack: r
```
**解释**：**返回调用者**：参数已耗尽，销毁标记，返回到调用者。
- **情况二：参数栈顶是值（还有剩余参数）**：**初始状态**：
```vbnet
Code: Return; c0
Accu: a = (c1, e1) （函数闭包）
Env: e0
Arg. stack: v . s
Return stack: r
```
**转换后状态**：
```yaml
Code: c1
Accu: a
Env: v . e1
Arg. stack: s
Return stack: r
```
**解释**：**继续应用剩余参数**：将结果（函数闭包）应用于剩余的参数。
**示例**

- **例子**：`((λx.x) (λy.y + 1) 4)`**说明**：这里，`λx.x`是一个身份函数，它被应用于两个参数`(λy.y + 1)`和`4`。**过程**：**身份函数只能接受一个参数**，但被提供了两个参数。**通过Return指令的机制**，身份函数的结果（即第一个参数`(λy.y + 1)`）将被应用于剩余的参数`4`。**这体现了Return指令处理“过度应用”（over-application）的能力**。
### **3.3.4 局部声明**

**编译方案**

- **let表达式**：尾调用位置：
```lua
T[[let 1 = N in M]] = C[[N]]; Let; T[[M]]
```
一般情况：
```lua
C[[let 1 = N in M]] = C[[N]]; Let; C[[M]]; Endlet
```
- **let rec（递归定义）**：尾调用位置：
```lua
T[[let rec 1 = N in M]] = Dummy; C[[N]]; Update; T[[M]]
```
一般情况：
```lua
C[[let rec 1 = N in M]] = Dummy; C[[N]]; Update; C[[M]]; Endlet
```
**指令的语义**

1. **Let指令**：
- **初始状态**：
```vbnet
Code: Let; c
Accu: a
Env: e
Arg. stack: s
Return stack: r
```
- **转换后状态**：
```yaml
Code: c
Accu: a
Env: a . e （将累加器中的值添加到环境）
Arg. stack: s
Return stack: r
```
- **解释**：**环境扩展**：将新的绑定添加到环境中。
2. **Endlet指令**：
- **初始状态**：
```yaml
Code: Endlet; c
Accu: a
Env: v . e （最近的绑定在环境顶部）
Arg. stack: s
Return stack: r
```
- **转换后状态**：
```yaml
Code: c
Accu: a
Env: e （恢复原始环境）
Arg. stack: s
Return stack: r
```
- **解释**：**环境恢复**：移除最近的绑定，恢复到之前的环境。
3. **Dummy指令**（用于`let rec`）：
- **初始状态**：
```yaml
Code: Dummy; c
Accu: a
Env: e
Arg. stack: s
Return stack: r
```
- **转换后状态**：
```yaml
Code: c
Accu: a
Env: ? . e （在环境中添加一个占位符）
Arg. stack: s
Return stack: r
```
- **解释**：**占位符**：在环境中添加一个占位符，以便稍后更新。
4. **Update指令**：
- **初始状态**：
```yaml
Code: Update; c
Accu: a
Env: v . e1 （环境顶部是占位符v）
Arg. stack: s
Return stack: r
```
- **转换后状态**：
```yaml
Code: c
Accu: a
Env: [v ← a] . e1 （将占位符v更新为累加器中的值）
Arg. stack: s
Return stack: r
```
- **解释**：**物理更新**：将占位符替换为实际的值，实现递归绑定。
**说明**

- **let的优化**：由于`let`形式（相当于`((λx.M) N)`）非常常见，采用了更快、更简单的编译方案，而不是实际应用一个抽象。
- **递归定义的注意事项**：**可能的问题**：物理更新可能无法实现（例如，对于不可变的值，如整数），因此可能无法达到固定点。**常见情况的可行性**：对于`M`是λ抽象的情况，这种方法效果很好。**进一步优化**：正如Mauny和Suárez在CAM的环境中所指出的，可以直接在代码中循环，而不构建循环环境。这些解决方案也可以应用于ZAM。
### **3.3.5 原语操作**

**编译方案**

- **原语操作的编译**：
```lua
T[[p(M1, ..., Mk)]] = C[[p(M1, ..., Mk)]] = C[[Mk]]; Push; ...; C[[M2]]; Push; C[[M1]]; Prim(p)
```
- **说明**：**参数顺序**：参数从右到左被推入栈，最后处理`M1`。**Prim(p)指令**：对应于原语操作`p`的指令，例如`+`、`=`、`car`等。
**Prim(p)指令的语义**

- **初始状态**：
```yaml
Code: Prim(p); c
Accu: a （第一个参数）
Env: e
Arg. stack: v2, ..., vk . s （其余参数）
Return stack: r
```
- **转换后状态**：
```yaml
Code: c
Accu: p(a, v2, ..., vk) （将原语操作的结果放入累加器）
Env: e
Arg. stack: s
Return stack: r
```
- **解释**：**原语操作的执行**：从累加器和参数栈中获取参数，执行操作，将结果放回累加器。
### **3.3.6 控制结构**

**说明**

- **控制结构**（如条件语句、循环等）的编译方式是传统的。
- **未详细描述的原因**：**代码共享的需要**：为了描述代码共享，需要在代码中引入标签。**后续描述**：这些将在实现的描述中进行。
**总结**

本段内容详细介绍了ZINC机器（ZAM）的设计和工作原理。ZAM是Krivine机器的扩展，专为严格求值策略设计，并增加了对常量的处理。ZAM使用了两个栈：参数栈和返回栈，优化了栈操作和环境表示。

作者定义了两种编译方案：

1. **T[[E]]**：用于尾调用位置的表达式，优化了尾调用情况，避免不必要的栈操作。
2. **C[[E]]**：适用于一般表达式，保证了编译的正确性。
在各个子章节中，作者详细描述了ZAM的指令集及其语义，包括：

- **访问局部变量（Access）**：从环境中获取变量值。
- **函数应用（Appterm、Apply、Push、Pushmark）**：处理函数调用，包括尾调用和一般调用，优化了参数传递和返回机制。
- **λ抽象（Grab、Cur、Return）**：处理函数定义和执行，支持部分应用和过度应用的情况。
- **局部声明（Let、Endlet、Dummy、Update）**：处理`let`和`let rec`表达式，优化了变量绑定和环境管理。
- **原语操作（Prim(p)）**：处理内置的原始操作，如算术运算和比较。
作者还提到控制结构的编译将在实现描述中详细说明。

通过对ZAM的设计和指令的详细解释，读者可以理解ZINC机器如何高效地执行ML语言的代码，如何优化函数调用、变量访问和环境管理，从而实现对ML语言的经济实现。
 #  
 Thought for 5 seconds
**概览**

本段内容选自《ZINC实验：ML语言的经济实现》（The ZINC Experiment: An Economical Implementation of the ML Language）的第3.4节和3.5节，主要讨论了ZINC抽象机器（ZAM）中环境（environment）的另一种表示方法，以及对此方法的分析和结论。作者深入探讨了如何优化环境的表示，以减少在堆上分配闭包和环境块的次数，从而提高执行效率。他介绍了一种使用缓存（cache）机制的环境表示方法，解释了其理论基础、实现细节，以及对抽象机器的影响。最后，他总结了这种方法的优势，并讨论了潜在的复杂性和性能改进。

**内容详解**

### **3.4 环境的另一种表示方法**

**背景**

- **传统环境表示的限制**：在前面的讨论中，假设环境总是在堆（heap）上分配，以便随时将它们放入闭包中。这在大多数环境机器（如SECD、CAM、FAM）中也是如此，尽管它们在环境的表示方式上有所不同（链表或向量）。由于闭包构建的高频率，很难有其他更好的方法。例如，一个多参数的柯里化函数在接收每个参数时，会将一个值添加到环境中，并立即为其构建一个闭包。
- **ZINC机器的特殊性**：ZINC机器专门设计用来减少闭包的构建次数。这为以更低的堆分配成本表示环境打开了大门。
**新的环境表示方法**

- **核心思想**：**临时性环境**：当我们不需要构建任何闭包时，当前的环境不必在当前函数体的求值之后继续存在。因此，我们可以将其全部或部分存储在某些易失性的位置（如栈或寄存器）中，这些位置将在当前函数返回时自动回收。**缓存机制**：进一步地，假设很少构建闭包，一个合理的策略是系统地将添加到环境中的值放在这些易失性位置中，当需要构建闭包时，再将它们复制回持久性存储（即堆中）。
- **环境的结构**：**持久部分（Persistent Part）**：ak, ..., an，这是最近应用或构建的闭包的环境部分。**易失部分（Volatile Part）**：a0, ..., ak-1，这是自那时以来添加到环境中的值。
- **访问操作的复杂性**：**多种表示**：因此，给定的环境有多种不同的表示方式；这使得访问操作略微复杂。**需要处理易失部分和持久部分**：在访问环境时，需要知道所需的值是绑定在持久部分还是易失部分。
**形式化定义**

- **环境结构（Env）**：**类型**：Env是环境结构的抽象类型，具有以下操作：empty : Env：表示空环境。accessn : Env → Value：返回与索引n关联的值。add : Value × Env → Env：将给定的值绑定到索引0，并将其他绑定向上移动一个位置。remove : Env → Env：将所有绑定向下移动一个位置。
- **带缓存的环境结构（Env'）**：**类型**：Env'的对象是一个对⟨S, E⟩，其中S是值的栈，E是一个环境Env。**操作定义**：empty' = ⟨∅, empty⟩：空的易失部分和空的持久环境。accessn'⟨S, E⟩：如果n < |S|，则S[n]（从易失部分获取）。如果n ≥ |S|，则access(n - |S|)(E)（从持久部分获取）。add'(v, ⟨S, E⟩) = ⟨v . S, E⟩：将值v推入易失部分栈S。remove'⟨S, E⟩：如果S非空，⟨S', E⟩，其中S'是S的尾部（即弹出栈顶）。如果S为空，⟨∅, remove(E)⟩。
- **特殊操作：perpetuate（持久化）**：**目的**：将易失部分的内容复制到持久部分，以便构建闭包。**定义**：perpetuate⟨ak, ..., a1, a0, ∅, E⟩ = ⟨∅, add(a0, add(a1, ..., add(ak, E)))⟩。**解释**：将易失部分的所有值按顺序添加到持久环境E中，得到一个新的持久环境。
**正确性的证明**

- **映射到简单环境**：为了证明使用缓存不会破坏正确性，只需注意到带缓存的环境可以映射到简单环境：⟨a0, a1, ..., ak, ∅, E⟩ = add(a0, add(a1, ..., add(ak, E)))。**结论**：这将带缓存的机器的转换映射到相同机器在没有缓存时的转换。
**实现细节**

- **缓存可以添加到任何环境结构中**：**例如**：向量、线性链表、向量的链表等。**优势**：**减少操作频率**：添加缓存后，add和remove操作的频率大大降低。**消除remove操作**：在某些情况下，remove操作可以完全消除。
- **持久化的代价**：**全量复制**：当需要执行perpetuate操作时，需要将易失部分的所有值复制到持久环境中。**向量结构的优势**：由于访问可以在常数时间内完成，且由于缓存的存在，我们可以承担在需要时进行全量复制的代价。
- **缓存的管理**：**栈式管理**：每个活动的函数需要自己的缓存，并且在函数调用期间必须保留它。然而，缓存遵循栈式纪律（任何时候，只有最近分配的缓存是活动的），因此我们可以将它们分配在一个栈中。**返回栈的作用**：ZAM的返回栈非常适合于此目的。换句话说，返回栈仍然保存未分配的闭包，但这些闭包现在也包括环境的易失部分。
**修改后的抽象机器**

- **返回栈的结构**：**完整的块**：返回栈现在是一个包含完整块的序列，每个块包含：**代码指针**：要执行的代码的位置。**持久环境的指针**：指向持久环境（向量）。**易失部分的大小n**：易失环境中值的数量。**易失部分的值**：n个值，代表易失部分本身。**栈顶的特殊处理**：最顶部的块是不完整的，它只包含当前环境的易失部分，因为特殊寄存器保存当前的代码指针、持久环境和易失环境的大小。
- **指令的语义**作者提供了带有缓存的ZAM基本指令的语义（见表3.2）。为了便于理解，以下是指令的解释：**Access(n)指令**：**目的**：从环境中访问索引为n的值。**两种情况**：**易失部分大小m > n**：所需的值在易失部分中。**状态转换**：**初始状态**：Env中的易失部分有m个值，栈顶为r = v0, ..., vn, ..., vm-1 . r0。**转换后**：将vn加载到累加器Accu中。**易失部分大小m ≤ n**：所需的值在持久部分中。**状态转换**：**初始状态**：Env的易失部分有m个值，n超过了易失部分的范围，需要从持久环境中获取。**转换后**：将vn加载到累加器Accu中。**Appterm指令**（尾调用）：**目的**：在尾调用位置应用函数，无需保存返回地址。**状态转换**：**初始状态**：累加器Accu中有函数闭包(c1, e1)，参数栈有值v，易失环境大小为m。**转换后**：**代码指针**：切换到函数的代码c1。**环境**：使用函数的持久环境e1，易失环境大小为1（参数v）。**返回栈**：将参数v推入返回栈。**Apply指令**（一般调用）：**目的**：应用函数，需要保存返回地址。**状态转换**：**初始状态**：与Appterm类似，但需要保存当前的代码指针和环境。**转换后**：**返回栈**：将当前的代码指针c0、环境e0和易失环境大小m0保存到返回栈中。**Cur指令**：**目的**：构建一个闭包。**状态转换**：**初始状态**：累加器Accu中有值a，环境的易失部分为(vm, ..., vn)，易失环境大小为m。**转换后**：**累加器**：构建闭包(c1, (v0, ..., vn))。**环境**：易失环境大小重置为0。**Grab指令**：**目的**：处理λ抽象，捕获参数或返回闭包。**两种情况**：**参数栈顶是标记（参数已耗尽）**：**状态转换**：**累加器**：构建当前代码和环境的闭包。**返回栈**：弹出栈顶块，恢复之前的代码指针和环境。**参数栈顶是值（还有参数）**：**状态转换**：**环境**：增加易失环境的大小m。**返回栈**：将参数v推入返回栈。**Return指令**：**目的**：从函数返回，处理过度应用的情况。**两种情况**：**参数栈顶是标记（参数已耗尽）**：**状态转换**：**恢复**：弹出栈顶块，恢复之前的代码指针和环境。**参数栈顶是值（还有剩余参数）**：**状态转换**：**继续应用**：将结果作为函数，应用于剩余的参数。**Let指令**：**目的**：在环境中添加新的绑定。**状态转换**：**易失环境大小增加**：m = m + 1。**返回栈**：将新值a推入返回栈。**Endlet指令**：**目的**：移除环境中的最近绑定。**两种情况**：**易失环境大小m > 0**：**状态转换**：**易失环境大小减少**：m = m - 1。**返回栈**：弹出栈顶值v0。**易失环境大小m = 0**：**状态转换**：**环境**：恢复之前的环境，易失环境大小设置为n - 1。
**完整的指令语义表**

- **表3.2**：作者提供了带有缓存的ZAM抽象机器的指令语义（在原文中提供了详细的表格）。
**解释**

- **访问环境的复杂性**：由于环境现在分为易失部分和持久部分，访问操作需要根据索引n和易失环境的大小m来确定值的位置。
- **堆分配的减少**：通过这种方式，许多环境和闭包的分配都被避免了，因为易失环境可以在函数返回时自动回收。
### **3.5 结论**

**复杂性的讨论**

- **抽象机器的复杂性**：**复杂度增加**：试图减少在堆上分配的闭包和环境块，最终自然地导致了一个相当复杂的抽象机器，比SECD等传统机器复杂得多。**担忧**：可能会担心，与经典的抽象机器相比，这种复杂性是否值得，因为性能提升可能并不显著。
**性能改进的验证**

- **初步基准测试**：**结果**：通过查看附录A中提供的一些初步基准测试结果，可以缓解这种担忧。**发现**：**堆空间的显著节省**：ZAM的特殊机制通常会导致堆空间的显著节省，相对于SECD或CAM，可能有数量级的减少。**执行时间接近**：原始执行时间与传统的抽象机器非常接近。**垃圾回收时间未计入**：这些时间不包括垃圾回收所花费的时间，因此实际性能改进可能更大。
**关于测试数量的担忧**

- **测试的频率**：**执行中的测试**：在执行过程中，会进行大量的测试，例如检查参数栈是否为空，或在访问环境时确定值是绑定在持久部分还是易失部分。**担忧**：如果将这些指令展开为传统处理器的本机代码，如此多的测试会导致非常低效的代码。
- **解释器的优势**：**解释执行的影响**：**测试开销的相对性**：在字节码解释的情况下，执行这些测试所花费的时间相对于解释开销是微不足道的。**指令数量的减少**：这些测试有助于减少执行的指令数量，这在字节码解释的情况下至关重要。
**总结**

- **整体评价**：**复杂性与性能的权衡**：虽然ZAM的复杂性增加了，但带来的性能改进（特别是堆空间的节省）是值得的。**适用于字节码解释**：由于ZAM的设计特点，在字节码解释的环境中，其复杂性并不会带来显著的效率损失。
**全面详尽的总结**

在本段内容中，作者探讨了ZINC抽象机器（ZAM）中环境表示的优化方法，旨在减少堆上的分配，以提高执行效率。他引入了一种使用缓存机制的环境表示方式，将环境分为易失部分和持久部分。

- **易失部分**：存储在栈或寄存器中，函数返回时自动回收。适用于当前函数体中不会需要构建闭包的情况。
- **持久部分**：存储在堆中，需要在构建闭包时将易失部分的数据复制到持久部分。
通过这种方式，可以减少堆上环境和闭包的分配次数，提高内存使用效率。作者详细定义了这种环境的形式化表示，给出了操作的定义和正确性的证明。

在实现方面，他讨论了如何在抽象机器中修改指令的语义，以适应新的环境表示方法。他提供了详细的指令语义，解释了各个指令在新的环境表示下的行为。

最后，作者在结论中讨论了这种方法带来的复杂性，并通过初步的基准测试结果验证了性能的改进。他指出，尽管抽象机器的复杂性有所增加，但在字节码解释的环境中，这种复杂性并不会导致显著的效率损失，反而带来了堆空间的显著节省和性能的提升。

总体而言，本段内容深入阐述了ZINC抽象机器中环境表示的优化策略，展示了如何通过缓存机制和栈管理来减少堆分配，优化函数式语言的实现。这对于理解函数式编程语言的编译和执行机制，以及内存管理策略，有着重要的意义。
 #  
 Thought for 5 seconds
**概览**

本段内容来自《ZINC实验：ML语言的经济实现》（The ZINC experiment: an economical implementation of the ML language）的第4章，主要讨论了数据表示（Data representation）。作者在这一章中探讨了如何为ML语言中的值找到合适的表示方法，并添加指令来操作这些表示。他首先介绍了ML数据类型的分类，然后深入讨论了各种类型构造的含义，特别是和、积类型，以及如何在语言中表示这些类型。他还探讨了记录类型、包含（inclusion）记录、可扩展的和类型等高级特性。这些内容对于理解ML语言的数据表示和类型系统，以及ZINC实现的设计决策非常重要。

**内容详解**

### **第4章 数据表示**

为了完成上一章定义的执行模型，我们需要找到ML值的表示方法，并添加指令来操作这些表示。

#### **4.1 数据结构**

**ML数据类型的分类**

ML（Meta Language）中的数据类型可以分为三类：

1. **原子类型（Atomic, Predefined Types）**：
- **小整数（"small" integers）**：通常是机器字大小的整数。
- **浮点数（Floating-point numbers）**。
- **字符（Characters）**。
- **字符串（Strings）**。
- **可能还有任意精度整数（Arbitrary-precision integers）**。
2. **预定义的类型构造子（Predefined Type Constructors）**：
- **函数（Functions）**：即闭包（closures）。
- **向量（Vectors）**。
- **动态类型（Dynamics）**：一种允许运行时类型检查的类型。
3. **其他类型构造子**：
- **可以在ML中通过一种称为“具体类型”（concrete types）的通用机制来定义**。
- **示例**：
```ml
type envir = Empty
           | Regular of int * string list * envir
           | Special of int * string list * envir
           | Weird of string list * envir;;
```
这里定义了一个名为envir的类型，它是由多个构造子组成的和类型（sum type）。
**深入探讨具体类型**

本节剩余部分将更深入地研究这样的声明在更基本的类型构造（如和类型（sums）和积类型（products））方面的含义。

#### **4.1.1 和类型与对**

**背景**

- **最初的ML语言**只有一种类型构造，即**和类型（sums）**。
- **此外，还提供了一个内置的**对（pair）**运算符，用于将值组合在一起。
- **构造子（Constructors）**：在和类型中，构造子是构成类型的不同分支。**经典ML中区分了**：**零元构造子（Nullary Constructors）**：即**常量构造子（Constant Constructors）**，不带参数。**一元构造子（Unary Constructors）**：即**函数构造子（Functional Constructors）**，带一个参数。
**语法上的区别**

- 这种区别主要是语法上的：**一个常量构造子C总是可以被视为一个类型为unit的函数构造子C**，其中unit是只有一个值()的内置类型。
**示例**

- **给定**：
```ml
e = Regular(a, b, c)
```
- **在解析时**，可以将其视为：
```ml
Regular(a, (b, c))
```
- **表示为**（`R`代表与构造子`Regular`关联的标记）：
```css
R
 ↙
  a
 ↙
  (b, c)
```
- **进一步展开**：
```css
R
 ↙
  a
 ↙
  b  c
```
**效率问题**

- **这种表示方式的效率很低**，因为：**空间效率低**：需要额外的节点来表示对（pairs）。**时间效率低**：访问a、b和c需要多次间接访问。
**细粒度的解构**

- **优点**：这种表示允许对`e`进行非常细粒度的解构，因为构造子的参数序列（`(a, (b, c))`）甚至其后缀`(b, c)`都是合法的ML值。
- **例如**，以下模式匹配是合法的：
```ml
match e with
  Regular x -> Special x
| Special (x, y) -> Weird y
```
**解释**：当e匹配Regular x时，x是(a, (b, c))，可以传递给Special。当e匹配Special (x, y)时，x和y是进一步解构出来的。
**Lazy ML的改进**

- **为了提高效率**，哥德堡的Lazy ML[7]不仅提供了内置的对类型，还提供了三元组（triple）、四元组（quadruple）等类型。
- **在这种情况下**，`int * string list * envir`被解析为一个三元组类型，因此`Regular(a, b, c)`有更高效的表示：
```css
R
 ↙
  a  b  c
```
- **改进**：**减少了间接访问**：可以直接访问a、b、c。**空间效率提高**：不需要额外的节点来表示嵌套的对。
**但存在的问题**

- **不再能够表示(b, c)为合法的ML值**。
- **导致以下模式匹配非法**：
```ml
match e with
  Special(x, y) -> Weird y
```
**原因**：(x, y)是一个对，而Special期望的是一个三元组。
- **必须修改为**：
```ml
match e with
  Special(x, y, z) -> Weird(y, z)
```
**权衡**

- **提高了效率**，但**略微降低了表达能力**。
- **然而**，以下模式匹配仍然合法：
```ml
match e with
  Regular x -> Special x
```
#### **4.1.2 和类型与积类型**

**元组组件的识别**

- **在上述解决方案中**，元组的组件仍然通过其**位置**来识别，这可能容易出错。
**引入记录类型**

- **为了解决这个问题**，Standard ML和CAML 2.6引入了**记录类型（records）**。
- **记录是有序的、具名的积类型（ordered, named products）**。
**示例**

```ml
type envir = Empty
           | Regular of envir_triple
           | Special of envir_triple
           | Weird of envir_pair
and envir_triple = { size: int; names: string list; rest: envir }
and envir_pair = { names: string list; rest: envir }
```

**优点**

- **使程序更加清晰**，虽然可能不那么简洁。
- **消除了对内置元组类型的需求**。
**不便之处**

- **标签的重载（Overloading of labels）**：**一个给定的标签**（如size、names、rest）可能属于多个记录类型。**这是必要的**，因为程序员自然倾向于重复使用具有描述性的名称。
- **对类型推断的不良影响**：**示例**：函数{size = x; _} -> x + 1。**问题**：如果标签size属于多个记录类型，则该函数没有主类型（principal type）。
**总结**

- **记录类型提高了可读性**，但标签的重载会导致类型推断的困难。
#### **4.1.3 和积的和类型（Sums of products）**

**ZINC的选择**

- **ZINC保留了和类型作为唯一的类型构造运算符**。
- **但将经典ML中的零元和一元构造子****推广为**n**元构造子**。
- **换句话说**，这个运算符执行了多个积类型（product types）的和（sum）。
**与自由代数的类比**

- **这种和积类型的和（sums of products）与排序的自由代数有类似之处**。
**紧凑的表示**

- **这样的和积类型的和可以实现紧凑且“扁平”的表示**。
- **例如**，`Regular(a, b, c)`表示为：
```css
R a b c
```
- **优势**：**高效的表示**：直接存储构造子的标签和其参数。**减少了内存占用**和**访问时间**。
**对语言的影响**

- **由于构造子的参数序列不再是有效的ML对象**，某些之前的模式匹配将不再合法。
- **例如**，以下模式匹配现在是类型错误的：
```ml
match e with
  Regular x -> Special x
| Special (x, y) -> Weird y
```
**原因**：Regular和Special必须有**确切的三个参数**，而Weird有两个参数。
- **需要重写为**：
```ml
match e with
  Regular(x, y, z) -> Special(x, y, z)
| Special(x, y, z) -> Weird(y, z)
```
**权衡**

- **代码可能看起来不如原来简洁和优雅**。
- **但优势在于**：**更容易阅读**：明确了Regular需要三个参数，而不是一个可能是三元组的参数。**避免了混淆**：代码的意图更加清晰。
**消除内置元组类型的需要**

- **不再需要内置的元组类型**，因为可以使用特殊的语法轻松定义。
- **示例**：
```ml
type 'a & 'b = (* the empty string *) of 'a * 'b;;
```
**这样，我们可以表示传统的具体类型，带有一元构造子和由对（pairs）组成的树**。
**可变性和标签**

- **对于构造子的每个参数**，可以提供额外的信息，指定它应如何计算和更新。
- **使用mutable关键字**，可以声明一个参数可以被物理修改。
- **更新操作**：**通过id <- expr进行**，其中id是通过模式匹配绑定的标识符。
- **示例**：物理连接列表（physical concatenation of lists）
```ml
type 'a mlist = MNil | MCons of 'a * mutable 'a mlist;;

let rec physical_append =
  fun MNil x -> x
  | (MCons(elt, (MNil as tail)) as whole) x -> tail <- x; whole
  | (MCons(elt, tail) as whole) x -> physical_append tail x; whole;;
```
- **添加标签**：**可以为构造子的参数添加标签，并在模式匹配中使用这些标签**。**示例**：
```ml
type envir = Empty
           | Regular of { size: int; names: string list; rest: envir }
           | ...;;

let firstname = function
  Regular{ names = n::_; _ } -> n
| ...;;
```
- **好处**：**即使多次使用相同的标签，也没有问题**，因为构造子足以标识值所属的具体类型。
#### **4.1.4 具有包含的记录（Records with Inclusion）**

**问题**

- **重复使用标签名称的问题**：**程序员往往会重复使用一些具有描述性的标签名称**，如size、rest、name等。
- **这与类型推断的交互不佳**。
**解决方案：记录的包含**

- **另一种解决方案是**：**考虑具有更多字段的记录r'（即r'具有r的所有标签，外加一些）实际上是r的特例**。**换句话说，r'的类型是r类型的子类型（subtype）**。
- **含义**：**任何地方可以使用r的地方，都可以使用r'**。
- **优势**：**这种方法优雅地解决了为函数{size = x; _} -> x + 1赋予主类型的问题**。**更重要的是**，子类型化将继承与静态类型结合起来，为面向对象编程铺平了道路。
**相关研究**

- **更多详细的介绍和令人信服的示例**，可以参见Cardelli和Wegner的论文[15]。
- **具有包含的记录可以很好地集成到ML语言中，并且仍然允许类型推断**，如Jategaonkar和Mitchell[31]、Ohori和Buneman[48]、以及Rémy[53, 54]提出的系统。
**ZINC的实现**

- **目前，ZINC尚未实现具有包含的记录**。
- **但实现起来不应该太困难**，可以使用Rémy在其论文[54]中提出的类型检查器，以及下面将要介绍的高效记录表示方法（见4.3.4节）。
#### **4.1.5 可扩展的和类型（Extensible Sums）**

**概念**

- **最后一个要考虑的扩展是允许通过添加新的构造子来“扩展”一个和类型**，即在其定义之后添加新的构造子。
**示例**

- **在声明了可扩展类型'a list = Nil | Cons of 'a * 'a list之后**，我们应该能够为其添加一个特殊的情况，例如单元素列表：
```ml
extend 'a list with Singleton of 'a
```
- **所有“旧的”list类型的值也属于“新”的list类型**。
- **之前定义的所有函数**，如果接受旧类型`list`的参数，也应该接受新类型的参数。
- **当然，之前定义的模式匹配在遇到包含新构造子的值时会失败**。
**应用场景：异常处理**

- **这个扩展在获得异常的干净、通用处理方面似乎是绝对必要的**。
- **在ML中，异常具有一个符号名称，可能还有一个或多个参数**。
- **将异常视为给定具体类型exc的构造子是非常自然的**。
- **这样，raise构造不再需要特殊的类型**，它只是一个类型为`exc -> 'a`的原语。
- **类似地，try ... with ...现在只是基本原语handle（类型为'a * (exc -> 'a) -> 'a）上的语法糖**。
**类型问题**

- **问题是类型exc必须是可扩展的**，因为用户可以定义新的异常（例如exception End_of_file of int），这与将构造子End_of_file of int添加到类型exc紧密对应。
**局部扩展的类型问题**

- **局部扩展一个类型会引发一个微妙的类型问题**：**尽管扩展是局部的，例如在一个模块中，但无法静态地检查该模块是否未导出包含本地添加到可扩展类型的构造子的值（或返回这些值的函数）**。
- **继续上述示例**：**我可以定义函数**：
```ml
let f x = Singleton x
```
**以类型`'a -> 'a list`导出它，但不导出构造子`Singleton`。
- **问题**：**这本身并无害**。**我们必须防止的是**：在同一类型上用相同的构造子名称但不同的参数进行扩展，例如：
```ml
extend 'a list with Singleton of int
```
**这将允许以下违反类型系统的情况**：
```ml
let f x =
  extend 'a list with Singleton of 'a in Singleton x;;

let coerce_anything_to_int x =
  extend 'a list with Singleton of int in
  match f x with Singleton i -> i;;
```
**解决方案**

- **一种解决方案是**：为所有类型的本地扩展赋予不同的表示，即停止区分构造子的名称，而是使用某种唯一的标记。
- **另一种解决方案是**：简单地禁止在同一模块中使用相同的构造子多次扩展给定的类型，即使这些扩展是局部的。
**ZINC的实现**

- **ZINC实现了一种中间方案**：**本地扩展是模块局部的**（不允许表达式局部的扩展，因为认为它们无用）。**构造子由其完整的、限定的名称标识**（例如`module1.Singleton`或`module2.Singleton`）。**不可能在同一模块中使用相同的构造子多次扩展给定的类型**。
- **当前，ZINC实现了可扩展和类型的受限形式**：**只有一个可扩展类型，即异常值类型exc**。**声明一个异常在内部被视为扩展它**。**这主要是由于历史原因和作者自身的懒惰**。
- **基本上，一切都已准备好实现通用的开放和类型**。
**全面详尽的总结**

本段内容深入探讨了ML语言中的数据表示问题，特别关注了如何高效且清晰地表示和类型（sum types）和积类型（product types），以及这些类型在语言中的具体实现和使用。

作者首先介绍了ML数据类型的分类，指出除了原子类型和预定义的类型构造子外，其他所有类型构造子都可以通过ML中的具体类型机制来定义。然后，他详细讨论了和类型与对（pairs）的关系，指出了经典ML中处理构造子的方式，以及这种方式在效率和表达能力上的权衡。

接下来，作者提出了ZINC的解决方案，即将构造子推广为`n`元构造子，从而实现更紧凑和高效的表示。他解释了这种表示方式如何影响模式匹配和代码的可读性，强调了清晰明确的代码的重要性。

然后，作者讨论了记录类型和标签的使用，指出了标签重载带来的类型推断问题。为了解决这个问题，他介绍了具有包含的记录（Records with Inclusion），即通过子类型化的方法，使得具有更多字段的记录可以被视为具有较少字段的记录的子类型。

此外，作者还探讨了可扩展的和类型（Extensible Sums），强调了这种扩展在异常处理等场景中的重要性。他分析了类型系统可能面临的问题，并介绍了ZINC对这个问题的解决方案，即在模块范围内限制类型的扩展，并使用完全限定的构造子名称。

总体而言，本段内容深入探讨了ML语言类型系统的复杂性，以及在实现高效、清晰的数据表示时所面临的挑战和解决方案。这对于理解函数式编程语言的类型系统设计、数据表示方式，以及ZINC实现的设计决策具有重要意义。通过对各种类型构造和扩展的详细解释，作者为读者提供了全面的知识，有助于深入理解ML语言和ZINC的实现细节。
 #  
 Thought for 55 seconds
**概览**

本段内容选自《ZINC实验：ML语言的经济实现》（The ZINC Experiment: An Economical Implementation of the ML Language）的第4章，主要讨论了ZINC编译器和垃圾收集器在处理ML语言的值时的数据表示方式。作者首先介绍了内存模型，包括值在内存中的表示，以及堆的结构和标记方案。然后，他详细讨论了如何编码ML的各种值类型，包括原子类型、函数和具体类型（concrete types）。最后，他探讨了记录类型在存在子类型化（subtyping）情况下的高效表示方法，提出了一种利用强静态类型的创新性方案，能够将记录字段的访问复杂度从线性时间降至常数时间。

**内容详解**

### **4.2 内存模型**

#### **4.2.1 简介**

本节描述了编译后的程序所处理的数据的格式。这不仅涉及到ZINC编译器（它必须以特定的格式编码ML值），还涉及到垃圾收集器（Garbage Collector，GC）。垃圾收集器由Damien Doligez独立编写[23]，设计时希望能够被其他实现所使用，因此需要找到一个尽可能通用的内存模型。

在这个模型中，一个值是一个32位的字（word），它要么表示一个小整数，要么表示堆中的一个指针。GC必须能够在运行时区分它们，因此需要一个标记方案（tagging scheme）。

#### **4.2.2 未分配的对象**

**未分配（未装箱，unboxed）对象的唯一类型是小整数**。

- **指针对齐**：由于堆中只包含32位字，所有指向堆的指针都是32位对齐的，因此它们的低两位（最低有效位）总是`00`。
- **整数的编码**：因此，整数被编码为低位为`1`的值，即整数`n`表示为32位字段`n = 2n + 1`。**示例**：整数3表示为2 * 3 + 1 = 7。
- **算术运算**：对这些31位整数的算术运算相对简单：**取反**：-n = 2 - n**后继函数**：succ n = n + 2**加法**：n + m = n + m - 1**减法**：n - m = n - m + 1**乘法**：n * m = (n - 1) * (m / 2) + 1**除法**：n / m = (n - 1) / (m / 2) + 1
**注释**：

- **为什么使用低位为1的编码**：**目的**：确保整数和指针可以在运行时区分。**优势**：算术运算只需少量调整即可完成。
- **高位标记方案的缺点**：**效率低下**：使用高位作为标记需要在每次运算时对操作数和结果进行掩码处理（masking）。**相比之下，低位标记方案更高效**。
**替代编码方案**：

- **另一个编码方案**是将n = 2n，并将所有指针左移一位。**好处**：整数算术运算更加简单，例如n + m = n + m。**缺点**：内存访问可能稍微变慢，具体取决于硬件。
#### **4.2.3 分配的对象**

为了使垃圾收集成为可能，堆需要有一定的结构。因此，堆被划分为大小为`n`的块，每个块前面有一个一字节的头部。所有指向堆的指针必须指向一个头部。

**头部结构**：

- **2位**：供垃圾收集器用于标记目的（GC标记）。
- **22位**：表示块的大小（不包括头部），以字为单位。
- **8位**：表示块的类型，因为GC需要区分包含有效值的块（应递归遍历）和包含非结构化数据的块（如字符串的字符），后者是GC的终结对象。
**具体说明**：

- **结构化的块（structured blocks）**：**定义**：如果标记字段t < C（C是一个常数），则块是结构化的，意味着每个字段都包含有效的值。**处理方式**：GC需要递归遍历这些块中的字段。
- **非结构化的块（unstructured blocks）**：**定义**：如果t > C，则块是非结构化的，仅包含未被解释的字。**处理方式**：GC将这些块视为终结对象，不再深入遍历。
- **闭包（closures）**：**定义**：如果t = C，则块表示一个闭包。**说明**：区分闭包并没有太大用处，除非是为了给GC提供可能的提示，或者编写类似多态相等性的“肮脏”多态函数。
**常数C的取值**：

- **取值范围**：C接近于可用的最大值2^8 - 2 = 254。
- **原因**：标记字段主要用于紧凑地编码具体类型的值，而这些值始终是结构化的块。
**堆外的指针**：

- **允许在任何地方存在指向堆外的指针**。
- **目的**：允许静态分配不应被回收的数据，例如从未释放的对象，或者我们不知道如何回收的对象。
- **示例**：长度为零的块，即仅包含头部的块。**用途**：用于编码常量构造子。**注意**：如果GC是复制式的，这些块不能分配在堆中，因为没有空间存储转发指针。
### **4.3 编码ML值**

#### **4.3.1 原子类型**

**小整数（type int）**：

- **表示方法**：使用未装箱的31位整数表示，即前面提到的n = 2n + 1的编码。
- **字符（type char）**：**表示方法**：与小整数相同，使用未装箱的31位整数表示。
**浮点数（Floating-point numbers）**：

- **表示方法**：在堆中分配为长度为1、2或3个字的非结构化块。**取决于**：硬件的能力和所需的精度。
- **未装箱表示的可能性**：**方案**：使用低位为10的后缀进行编码，但这只能表示30位的浮点数。**问题**：**精度不足**：30位的浮点数精度不够。**不符合标准格式**：不对应任何标准格式，需要进行截断。**结论**：使用传统的64位IEEE标准浮点数更有用，即使需要分配内存。
**任意精度整数（Arbitrary precision integers）**：

- **表示方法**：存储在非结构化块中，即32位字的向量。
- **实现**：适用于Vuillemin等人的大数运算库[55]。
**字符串（Strings）**：

- **表示方法**：存储在非结构化块中。
- **细节**：**以零结尾（zero-terminated）**。**填充（padding）**：在末尾添加额外的零，以填充完整的字数。
- **长度计算**：**问题**：为了在常数时间内计算字符串的长度，并避免禁止字符串中间的空字节，需要特殊处理。**方案**（Damien Doligez提出）：**最后一个字节**：最后一个字的最后一个字节包含一个整数n ∈ {2, 3, 4, 5}，使得字符串的长度为4m - n，其中m是块的大小（以字为单位）。**解释**：假设字符串的最后六个字符是b6 b5 b4 b3 b2 b1，则其表示的最后两个字可能是：b6 b5 b4 b3 和 b2 b1 01（对应n = 2）b5 b4 b3 b2 和 b1 00 03（对应n = 3）b4 b3 b2 b1 和 00 00 04（对应n = 4）b3 b2 b1 00 和 00 00 05（对应n = 5）**作者的评价**：他似乎对此方案感到非常有趣。
**其他原子类型**：

- **位向量（bit vectors）等**：也可以表示为非结构化块。
#### **4.3.2 函数**

**函数值的表示**：

- **表示方法**：使用闭包（closures），即代码指针和环境（向量，即结构化块）的对。
- **代码**：**存储位置**：代码本身不在堆中分配，而是在一个单独的、静态的区域，且不进行垃圾收集。**原因**：**程序计数器和返回地址**通常指向代码块的中间，而不一定是其第一个字。**GC无法处理这些嵌入的指针**。
**垃圾收集器的考虑**：

- **代码块不被回收**。
- **独立程序的情况**：**代码块不被动态创建**。**所有代码块始终可通过包含闭包的全局变量访问**。**因此，代码块从未被释放，尝试回收它们没有意义**。
- **交互式使用的情况**：**当一个全局变量（先前绑定到一个闭包）被重新绑定时，可能出现未使用的代码块**。**即便如此，由于字节码的紧凑性，代码块的寿命相对较长，占用空间很小**。**可以期望静态区域不会增长太快**。**通常可以进行显式的内存释放**。
**代码块的限制**：

- **一旦代码块被放入静态区域**，它们不能包含指向堆的指针。**原因**：**GC不知道它们的存在**，因为它不会遍历静态区域。**如果将这些指针链接到堆中，使它们成为GC的附加根，将使GC变得更慢、更复杂**。
- **影响**：**结构化（非原子）常量不能同时分配在堆中并直接放入代码中作为立即数操作数**。**解决方案**：**将它们也分配在静态区域**（如果它们不包含可变对象，后者可能会被更新，然后指向堆）。**将它们与全局变量的值一起存储在全局表中，通过额外的间接访问来获取**。**作者的选择**：为了简化，选择了后者方案。
#### **4.3.3 具体类型（Concrete Types）**

**和积的和类型（sum-of-products approach）**：

- **优势**：允许对具体类型的值进行非常紧凑的表示。
- **方法**：**构造子与其参数存储在同一个元组中**。**尝试将构造子的信息放入元组头部的标记字段中**，因此构造子不需要在元组中占用额外的字段。
**具体实现**：

- **构造子编号**：对于具体类型的构造子`C0, C1, ..., Cn`，从零开始编号。
- **值的表示**：`Ci(v1, ..., vk)`表示为一个大小为`k`个字的块，标记为`i`，包含`v1, ..., vk`的表示。
```python
size = k    GC tag = i
v1
...
vk
```
- **特殊情况**：如果构造子的数量超过了标记字段的范围（即`0`到`C`之间，`C`约为`253`），需要使用较少紧凑的表示：**表示为**：整数i和v1, ..., vk的(k + 1)元组。
- **备注**：在常见的程序中，这种大型的和类型（具有大量构造子）非常罕见。
**常量构造子（Constant Constructors）**：

- **定义**：不带参数的构造子。
- **表示方法**：大小为0的块，其头部包含构造子的编号。**看起来有些不自然**，因为使用整数来表示常量构造子似乎更自然、更高效。
- **作者的解释**：**零大小的块与整数一样廉价**，因为每次评估常量构造子时不需要分配新的块。**共享性**：所有具有相同标记的零大小块可以安全地共享，因为它们不包含数据。**预分配**：可以在链接时预分配它们，然后只需操作指向这些块的唯一指针，效率与操作整数相同。
- **统一表示的优势**：**对常量和非常量构造子具有统一的表示更高效**。**特别是，在模式匹配中，可以根据块的标记进行单次跳转来区分构造子**。
```ml
match x with
  C0 -> a
| C1 x -> b
| C2(x,y) -> c
| C3 -> d
| ...
```
**对应的代码**：
```pseudo
case (tag_of x) of
  0 -> a
  1 -> b
  2 -> c
  3 -> d
  ...
```
- **如果使用整数表示常量构造子**：**需要额外的测试**：必须先测试表示是否是整数，然后根据结果跳转到不同的处理。
```pseudo
if is_int x then
  case x of 0 -> a; 1 -> d; ...
else
  case (tag_of x) of 0 -> b; 1 -> c; ...
```
**效率降低**：这种代码大约比前一种慢两倍。
- **结论**：统一的表示方式更高效，特别是对于大量的模式匹配操作。
#### **4.3.4 具有包含的记录（Records with Inclusion）**

**背景**：

- **没有子类型化的情况下**，带有n个标签l1, ..., ln的记录可以表示为大小为n的向量。
- **可以静态地知道每个标签的偏移量**，即向量中与标签关联的值所在的位置。
**引入子类型化的挑战**：

- **要求**：具有标签l1, ..., ln的记录的表示必须对包含l1, ..., ln子集的记录也是有效的。
- **影响**：无法同时拥有紧凑的表示和静态确定的偏移量。
**可能的解决方案**：

1. **全局标签集合的方法**：
- **收集整个程序中使用的标签集合L = {l1, ..., lN}**。
- **将任何记录表示为大小为N的向量**，标签`li`的值`vi`存储在槽位`i`中。
```mathematica
Slot 1    vi
Slot i    vi
Slot N
```
- **缺点**：**空间浪费**：大多数记录只使用L的一个小子集，导致大量空间浪费。**编译时依赖**：需要查看整个程序才能分配偏移量，直到链接时才能完成，阻碍了语言的交互式使用。
- **改进**：使用一个头部来减少空间浪费。**方法**：将记录表示为大小为`(n + 1)`的元组，字段`1, ..., n`保存值`v1, ..., vn`，字段`0`指向大小为`N`的向量（头部），头部的槽位`i1, ..., in`保存整数`1, ..., n`，其他槽位未定义。**缺点**：需要额外的间接访问，仍然不足以使这种方案实用。
2. **使用关联表（association tables）**：
- **示例**：Amber语言[13]将记录`(l1 = v1, ..., ln = vn)`表示为`2n`元组`l1, v1, ..., ln, vn`。
- **字段访问**：需要在运行时在线性搜索元组以检索标签`l`的值。
- **优点**：表示相对紧凑，不需要“闭合程序”假设（即我们知道使用的所有标签）。
- **缺点**：字段访问的时间与记录的字段数量成正比，速度较慢。
- **优化**：Amber使用缓存方案来提高性能。**方法**：将最后访问的标签及其偏移量存储在某个固定位置。**效果**：如果连续第二次访问相同的标签，可以避免再次搜索。
- **限制**：即使有缓存，平均行为仍与记录长度成正比。
**新的表示方案**：

- **利用强静态类型的优势**：**静态类型的保证**：在运行时请求记录`r`中标签为`l`的值时，`r`始终包含一个标记为`l`的字段。**含义**：我们不知道它在`r`中的存储位置，但我们知道它一定存在。
- **问题所在**：之前的表示方法没有利用这个假设，更适合动态类型设置，如Lisp或Smalltalk。
- **新的思路**：仅需要表示从标签集合`{l1, ..., ln}`到`{1, ..., n}`的**全函数**（total function）。
- **具体方案**：**标签映射为整数**：**方法**：将标签名称关联到唯一的整数，这在链接时很容易做到，对于交互式使用，可以逐步完成。**构建哈希映射**：**选择整数m**，使得对于所有`i ≠ j`，有：
```lua
li mod m ≠ lj mod m
```
**确定m的方法**：例如，`m = 1 + max_{i ≠ j} |li - lj|`。**构建向量h**：大小为m。对于所有i，在槽位li mod m中存储整数i。**记录的表示**：将记录(l1 = v1, ..., ln = vn)表示为(n + 1)元组(h, v1, ..., vn)。**字段访问**：**步骤**：**计算**：l mod sizeof(h)。**获取偏移量**：在h的计算所得槽位中获取值，得到所需值在元组中的偏移量。**访问值**：在元组中访问对应偏移量的值。**复杂度**：常数时间。**性能**：**计算量**：一次取模运算和三次内存访问。**与传统记录访问相比**：相当于一次间接访问的开销。**比Amber方案快一个数量级**：对于中等大小的记录，效率显著提高。
- **头部大小的可管理性**：**最小的m值**：`m0`是满足条件的最小`m`。**不等式**：
```css
n ≤ m0 ≤ 1 + max_{i ≠ j} |li - lj|
```
**分析**：**上限可能较大**，等于程序中使用的标签数量。**但在实际中，这个上限似乎过于悲观**。**示例**：n = 2，l1 = 1，l2 = 1000000，则m0 = 2，上限为1000000。**实验结果**：使用标签范围在`0`到`L`之间的随机标签集进行模拟，发现平均的`m0`非常接近其下限`n`。
- **进一步优化**：**考虑跳过头部**，直接将记录表示为大小为m0的向量，将值vi存储在槽位li mod m0中。**优势**：在每次访问时节省一次间接访问。**代价**：可能会浪费一些空间。**权衡**：对于常数时间访问的性能提升，这种空间浪费是值得的。
**结论**：

- **该表示方案是实现多重继承的高效实现的第一步**。
- **创新性**：据作者所知，这种方法以前未被考虑过，可能是因为它需要强静态类型，而大多数面向对象语言是动态类型的。
- **静态类型的优势**：**提高程序的安全性和性能**：减少了运行时的检查。**在此案例中**：无需在运行时检查记录中是否存在标签，将记录字段的访问复杂度从线性时间降低到常数时间。
**全面详尽的总结**

本段内容深入探讨了ZINC编译器和垃圾收集器在处理ML语言的值时的数据表示方法。作者首先描述了内存模型，其中一个值要么是一个小整数，要么是堆中的一个指针。为了使GC能够在运行时区分它们，采用了低位标记方案，将整数编码为低位为`1`的31位数。

接着，作者讨论了分配在堆中的对象的结构。堆被划分为带有头部的块，头部包含GC标记、块大小和块类型的信息。通过使用标记字段，GC可以区分结构化和非结构化的块，以及特殊的闭包块。

在编码ML值方面，作者详细说明了原子类型的表示方法，包括小整数、字符、浮点数、任意精度整数和字符串。他强调了在性能和精度之间的权衡，以及在实际实现中的选择。

对于函数，作者解释了为什么代码块不在堆中分配，而是在静态区域。这涉及到GC的限制和代码块的生命周期问题。他还讨论了如何处理结构化常量，以避免GC的复杂性。

在处理具体类型时，作者提出了使用和积的和类型（sum-of-products approach）来实现紧凑的表示方法。他详细解释了构造子的编号和值的存储方式，强调了统一表示常量和非常量构造子的优势。

最后，作者深入探讨了在存在子类型化的情况下，如何高效地表示记录类型。他提出了一种利用强静态类型的创新方案，通过构建标签的哈希映射，实现了记录字段的常数时间访问。这种方法不仅提高了性能，还为多重继承的高效实现奠定了基础。

总体而言，本段内容展示了作者在设计ZINC编译器和垃圾收集器时，为了提高性能和效率，深入考虑了数据表示和内存模型的问题。他通过对各种可能的方案的分析和权衡，提出了创新性的解决方案，充分利用了ML语言的强静态类型特性。这对于理解函数式编程语言的实现细节、内存管理策略以及类型系统的实际应用具有重要意义。
 #  
 Thought for 5 seconds
**概览**

本段内容选自《ZINC实验：ML语言的经济实现》（The ZINC Experiment: An Economical Implementation of the ML Language）的第5章，主要描述了ZINC的编译器。本章详细介绍了ZINC编译器的设计和实现，包括其多遍（multi-pass）结构、使用的中间表示（intermediate representations）、以及编译过程中的各个步骤。作者首先介绍了一些值得考虑的中间表示形式，然后深入讨论了编译器如何从源代码的抽象语法树开始，经过多次转换，最终生成可以直接由运行时系统执行的字节码文件。本章还包括实际的CAML代码示例，这些代码直接取自ZINC实现的源代码，有助于读者理解编译器的具体实现细节。

**内容详解**

### **第5章 编译器**

#### **5.1 一些中间表示**

**背景**

- **编译器结构**：ZINC编译器是一个**多遍编译器（multi-pass compiler）**。多遍编译器比单遍编译器更容易编写、维护和扩展。
- **中间表示的重要性**：每一遍（pass）都涉及程序表示的转换，从一种表示形式转换为另一种。因此，了解这些中间表示（intermediate representations）对于理解编译器的工作原理至关重要。
- **本节目标**：介绍几种值得考虑的中间表示形式。这些表示形式有助于理解编译器的不同步骤。需要注意的是，并非所有的表示形式都在ZINC编译器中使用，因为对于这样一个简单的编译器，许多步骤是多余的。
#### **5.1.1 抽象语法树（Abstract Syntax Tree，AST）**

**概述**

- **AST的定义**：抽象语法树是解析（parsing）过程中生成的第一种内部表示形式。它是源代码的结构化表示，去除了具体语法（如括号、逗号等），仅保留程序的逻辑结构。
- **ZINC中的表达式抽象语法**：以下是ZINC用于表达式的抽象语法定义：
```ocaml
type expression =
  mutable Zident of expr_ident                 (* 变量 "x" 或 "module.y" *)
| Zconstant of struct_constant                 (* 常量 "3.14" *)
| Zconstruct of constr_desc global & expression list (* 构造子应用 *)
| Zapply of expression & expression list       (* 多参数应用 *)
| Zlet of (pattern & expression) list & expression   (* 局部绑定 *)
| Zletrec of (pattern & expression) list & expression (* 局部递归绑定 *)
| Zfunction of (pattern list & expression) list       (* 函数（带模式匹配） *)
| Ztrywith of expression & (pattern & expression) list (* 异常处理 *)
| Zsequence of expression & expression         (* 序列 *)
| Zcondition of expression & expression & expression  (* 条件语句 if...then...else... *)
| Zwhile of expression & expression           (* "while" 循环 *)
| Zsequand of expression & expression         (* 顺序 "and" *)
| Zsequor of expression & expression          (* 顺序 "or" *)
| Zconstraint of expression & type_syntax     (* 类型约束 *)
| Zassign of string & expression              (* 赋值操作 *)
```
- **表达式标识符的定义**：
```ocaml
and expr_ident =
  Zglobal of value_desc global                (* 全局变量，带描述符 *)
| Zlocal of string                            (* 局部变量 *)
```
- **辅助类型定义**：**模式（pattern）**：
```ocaml
type pattern =
  Zwildpat                                    (* 通配符 "_" *)
| Zvarpat of string                           (* 变量模式 *)
| Zaliaspat of pattern & string               (* 别名 "... as y" *)
| Zconstantpat of atomic_constant             (* 常量模式 *)
| Zconstructpat of constr_desc global & pattern list (* 构造子模式 *)
| Zorpat of pattern & pattern                 (* 或模式 *)
| Zconstraintpat of pattern & type_syntax     (* 类型约束模式 *)
```
**原子常量（atomic_constant）**：
```ocaml
type atomic_constant =
  ACnum of num                                (* 数字常量 *)
| ACint of int                                (* 整数常量 *)
| ACfloat of float                            (* 浮点数常量 *)
| ACstring of string                          (* 字符串常量 *)
```
**结构化常量（struct_constant）**：
```ocaml
and struct_constant =
  SCatom of atomic_constant                   (* 原子常量 *)
| SCblock of constr_tag & struct_constant list (* 块常量，带构造子标签和常量列表 *)
```
**设计权衡**

- **需求的冲突**：**一方面**，抽象语法应尽可能接近“具体语法”（即源代码的文本表示）：使得解析过程简单。能够对抽象语法进行美化打印（pretty-print），以得到接近原始文本的表示。**另一方面**，抽象语法应反映程序的“真实”含义：在解析过程中，将各种语法糖（syntactic sugar）转换为更基本的构造。消除歧义的构造。
- **示例**：在真正的ML中，标识符可以表示构造子（constructor）或全局/局部变量。在语法上无法区分它们，但在语义上它们的行为完全不同，特别是在模式中！
- **选择**：作者选择**优先满足第二个需求**，即反映源程序的真实语义。因此，在上述类型定义中，明确区分了构造子和变量，以及构造子应用和函数应用。
**错误报告的考虑**

- **错误定位**：将注释（annotations）添加到语法树的每个节点上是有用的。例如，每个子树都包含指向对应源代码的指针（如源文件中第一个和最后一个字符的位置）。这样，报告错误位置变得简单，可以重新打印对应的源代码，甚至可以发送消息给智能文本编辑器，直接在源代码中高亮显示有问题的表达式。
- **美化打印的替代方法**：如果采用上述方法，就不必编写一个优秀的ML美化打印器，这是一项相当复杂的工作。这些注释在解析过程中很容易合成，只需在解析器的语法规则中添加相应的代码。
- **具体实现**：在Yacc语法中，将规则：
```ruby
A : B1 B2 B3 { $$ = ... $1 ... $2 ... $3 ...; }
```
转换为：
```ruby
A : B1 B2 B3 {
  $$.start = $1.start;
  $$.end = $3.end;
  $$.syntax = ... $1.syntax ... $2.syntax ... $3.syntax ...;
}
```
**注释的结构**：
```ocaml
type expression = {
  start: int;                    (* 起始位置 *)
  end: int;                      (* 结束位置 *)
  syntax: expression_syntax;     (* 语法结构 *)
}
```
**表达式语法**：
```ocaml
and expression_syntax =
  mutable Zident of expr_ident
| Zconstant of struct_constant
| Zconstruct of constr_desc global & expression list
| ...
```
**类型注释**

- **在语法树中添加类型信息也是有用的**：**目的**：使类型检查错误报告更容易理解。与智能文本编辑器结合时，可以选择一个子表达式并查看为其推断的类型。**对于调试器**：调试器可以显示任何子表达式的值。为了打印一个值，需要知道其类型。
#### **5.1.2 扩充的λ-演算（Enriched λ-calculus）**

**概述**

- **定义**：扩充的λ-演算是一种经典的中间语言[50, 第3章]，包含常量、原始操作、全局变量、条件构造，以及let和let rec绑定。
- **特点**：与抽象语法相比，模式匹配已被展开为一系列基本的测试。其余的歧义也已完全解决：明确区分了局部和全局标识符。绑定到原始操作的全局标识符（如+）已被识别和展开。所有全局标识符现在都带有它们所属的模块。局部变量之间的命名冲突已被解决，可以通过生成新的、唯一的名称，或使用de Bruijn索引[10]。
- **de Bruijn索引**：**优点**：这种解决方案优雅，并且在转换为抽象机器代码时节省工作量（因为抽象机器代码无论如何都使用de Bruijn索引）。**缺点**：在进行一些智能的分析时会变得复杂，例如想要收集表达式中所有局部变量的信息。
- **类型定义示例**（使用de Bruijn索引的示例）：
```ocaml
type lambda =
  Lvar of num                               (* 局部变量（de Bruijn编号） *)
| Lconst of struct_constant                 (* 常量 *)
| Lapply of lambda & lambda list            (* 多参数应用 *)
| Lfunction of num & lambda                 (* 柯里化函数（num = 元数，arity） *)
| Llet of lambda list & lambda              (* 局部绑定 *)
| Lletrec of lambda list & lambda           (* 局部递归绑定 *)
| Lprim of primitive & lambda list          (* 原始操作 *)
| Lcond of lambda & (atomic_constant & lambda) list (* 与常量的相等性测试 *)
| Lswitch of num & lambda & (constr_tag & lambda) list (* 通过表的跳转 *)
| Lstaticfail                               (* 类似于"raise failure"，但具有静态作用域 *)
| Lstatichandle of lambda & lambda          (* 静态失败的处理器 *)
| Lhandle of lambda & lambda                (* 异常处理器（动态作用域） *)
| Lifthenelse of lambda & lambda & lambda   (* 条件语句 *)
| Lsequence of lambda & lambda              (* 序列 *)
| Lwhile of lambda & lambda                 (* "while" 循环 *)
| Lsequand of lambda & lambda               (* 顺序 "and" *)
| Lsequor of lambda & lambda                (* 顺序 "or" *)
```
- **原始操作的定义**：
```ocaml
and primitive =
  Pget_global of string & string            (* 获取全局变量的值 *)
| Pset_global of string & string            (* 设置全局变量的值 *)
| Pmakeblock of constr_tag                  (* 在堆中构建元组 *)
| Pfield of num                             (* 访问元组的一个字段 *)
| Psetfield of num                          (* 修改元组的一个字段 *)
| Pccall of num                             (* 调用C语言的原始函数 *)
| Praise                                    (* 抛出异常 *)
| Ptest of bool_test                        (* 比较操作 *)
| ...                                       (* 算术操作等 *)
```
- **布尔测试的定义**：
```ocaml
and bool_test =
  Pequal_test                               (* 等于测试 *)
| Pnotequal_test                            (* 不等于测试 *)
| Peq_test                                  (* 物理相等测试 *)
| Pnoteq_test                               (* 物理不相等测试 *)
| Pnum_test of num prim_test                (* 数字测试 *)
| Pint_test of int prim_test                (* 整数测试 *)
| Pfloat_test of float prim_test            (* 浮点数测试 *)
| Pstring_test of string prim_test          (* 字符串测试 *)
| Peqtag_test of constr_tag                 (* 构造子标签相等测试 *)
| Pnoteqtag_test of constr_tag              (* 构造子标签不相等测试 *)
```
**原始测试的定义**：
```ocaml
and 'a prim_test =
  PTeq                                      (* 等于 *)
| PTnoteq                                   (* 不等于 *)
| PTnoteqimm of 'a                          (* 与立即数不等于 *)
| PTlt                                      (* 小于 *)
| PTle                                      (* 小于等于 *)
| PTgt                                      (* 大于 *)
| PTge                                      (* 大于等于 *)
```
**Lcond和Lswitch**

- **多路测试（multi-way tests）**：**Lcond**：用于高效的模式匹配。将其参数与一个常量列表进行匹配，并返回关联表达式的值。形式化表示：
```scss
Lcond(exp, [(cst1, exp1); ...; (cstN, expN)])
```
等价于：
```ocaml
let x = exp in
if x = cst1 then exp1
else if x = cst2 then exp2
...
else if x = cstN then expN
else raise staticfail
```
**Lswitch**：根据其参数的标签（假定为元组）进行判别。形式化表示：
```scss
Lswitch(n, exp, [(tag1, exp1); ...; (tagN, expN)])
```
等价于：
```ocaml
let x = tag_of exp in
if x = tag1 then exp1
else if x = tag2 then exp2
...
else if x = tagN then expN
else raise staticfail
```
**静态失败和处理**

- **Lstaticfail和Lstatichandle**：**实现静态作用域的异常**（不能逃离当前函数）。**优点**：这样的异常可以被非常高效地编译，仅需一个简单的goto，并且它们允许在该表示中表达代码共享。
**中间表示的优势**

- **简化和精确**：由于展开了模式匹配，表示形式更简单。同时，保留了整体的程序结构，因此更精确。
- **用途**：是进行程序分析和转换的理想表示形式，例如：**编译时的β-归约（函数内联）**。**常量传播（constant propagation）**。
#### **5.1.3 代码图（Graph of Code）**

**概述**

- **问题背景**：扩充的λ-演算仍然是一种树状结构。而机器代码本质上是“扁平的”（flat），即类似列表的结构。因此，需要在某个时刻将λ-表达式线性化。
- **解决方案**：可以将这个过程分为两部分：**生成基本块（basic blocks）**：即纯粹顺序执行的代码片段。连接它们的入口和出口点。**将图状结构展开**：通过插入标签和跳转，将其线性化。
- **中间表示的优势**：**代码图**（graph of code）适合表达代码共享和控制流。**示例**：while构造在图中自然地成为循环。
**ZINC机器代码的结构示例**

- **类型定义**：
```ocaml
type graph_code =
  Gstop                                         (* 顶层短语结束 *)
| Greturn                                       (* 函数结束 *)
| Gtermapply                                    (* 尾递归的函数应用 *)
| Gquote of quoteconst & code                   (* 加载常量 *)
| Ggrab of code                                 (* 吃掉一个参数 *)
| Gpush of code                                 (* 推入一个参数 *)
| ...                                           (* 更多简单指令 *)
| Gclosure of labeled_code & code               (* 构建一个闭包 *)
| Gbranch of labeled_code                       (* 无条件跳转 *)
| Gtest of labeled_code & labeled_code          (* 条件跳转（if-then-else） *)
| Gswitch of labeled_code vect                  (* 通过表的跳转 *)
```
- **标记的代码块**：
```ocaml
and labeled_code = {
  mutable lbl : code_label;                     (* 标签 *)
  code : graph_code;                            (* 基本块的内容 *)
}
```
- **代码标签**：
```ocaml
and code_label = Unlabeled | Label of num
```
**解释**

- **指令的特点**：大多数指令以它们应该在其后执行的代码（续体，continuation）作为参数。有些指令没有续体，例如`Gstop`、`Greturn`等。其他指令有多个续体，例如条件测试。
- **共享的处理**：为了得到更紧凑的表示，使用了两种不同的类型：graph_code：忽略共享，表示基本块的主体。labeled_code：带有额外的“标签”字段，可以在线性化过程中检测共享。标签最初是未定义的，但在展开（flattening）阶段，当第一次访问时，它们被定义。第二次访问时，不会再次发出标记的代码，而是替换为跳转到第一次生成的代码。
- **类型系统的作用**：这种细微的结构约束由类型系统自动强制执行。大多数指令的续体是`graph_code`类型，因为它们按顺序继续执行。跳转指令显式地连接基本块，因此它们的续体是`labeled_code`类型。
#### **5.1.4 线性代码（Linear Code）**

**概述**

- **定义**：最后一种表示形式是指令的线性列表，尽可能接近传递给解释器的字节串（bytecode）。
- **符号信息**：仍然需要保留一些符号信息。**示例**：全局变量仍然以名称表示，而字节码通过它们的地址引用它们。这是因为全局变量的分配只能在链接时完成。同样，跳转指令引用标签，而字节码包含目标的偏移量。原因是编译器不知道字节码指令的大小。
- **ZINC中的指令类型**：
```ocaml
type instruction =
  Kquote of struct_constant                   (* 将常量放入累加器 *)
| Kget_global of string & string              (* 获取全局标识符的值 *)
| Kset_global of string & string              (* 设置全局标识符的值 *)
| Kaccess of num                              (* 从环境中获取局部变量 *)
| Kgrab                                       (* 吃掉一个参数并放入环境 *)
| Kpush                                       (* 推入一个参数 *)
| Kpushmark                                   (* 推入一个标记 *)
| Klet                                        (* 在环境前添加一个值 *)
| Kendlet of num                              (* 从环境中移除前几个值 *)
| Kdummies of num                             (* 向环境中添加虚拟闭包 *)
| Kupdate of num                              (* 使用最终值更新虚拟闭包 *)
| Kapply                                      (* 函数调用 *)
| Ktermapply                                  (* 尾递归的函数调用 *)
| Kstartfun                                   (* 函数的入口点 *)
| Kreturn                                     (* 函数结束 *)
| Kclosure of label                           (* 构建一个闭包 *)
| Kmakeblock of constr_tag & num              (* 在堆中分配一个元组 *)
| Kprim of primitive                          (* 各种原始操作 *)
| Kpushtrap of label                          (* 设置异常处理器 *)
| Kpoptrap                                    (* 移除异常处理器 *)
| Klabel of label                             (* 定义一个标签 *)
| Kbranch of label                            (* 无条件跳转 *)
| Kbranchif of label                          (* 条件跳转 *)
| Kbranchifnot of label                       (* 条件跳转的反向 *)
| Kstrictbranchif of label                    (* 类似于上面的指令（用于解决一个微妙的错误） *)
| Kstrictbranchifnot of label                 (* 同上 *)
| Ktest of bool_test & label                  (* 各种条件跳转（= < > 等） *)
| Kswitch of label vect                       (* 通过表的跳转 *)
```
- **标签类型**：
```ocaml
and label = Nolabel | Label of num
```
**解释**

- **符号信息的保留原因**：编译器在编译阶段不知道全局变量和标签的确切地址或偏移量。这些信息只能在链接时确定。
- **线性代码的作用**：将程序表示为一系列指令，这些指令将被转换为字节码供解释器执行。在这个阶段，程序的控制流和数据流都已被线性化。
**全面详尽的总结**

本段内容深入描述了ZINC编译器的设计和实现，特别关注了编译过程中使用的各种中间表示形式。

首先，作者介绍了**抽象语法树（AST）**，这是解析过程中生成的第一种内部表示形式。AST保留了程序的逻辑结构，并在类型定义中明确区分了构造子和变量，以及不同的表达式类型。作者讨论了在AST中添加注释的重要性，例如源代码位置和类型信息，以便于错误报告和调试。

接下来，作者介绍了**扩充的λ-演算（Enriched λ-calculus）**，这是一种经典的中间语言。与AST相比，扩充的λ-演算展开了模式匹配，消除了剩余的歧义，并明确区分了局部和全局标识符。作者详细解释了这种表示形式的类型定义，包括如何表示变量、常量、函数、局部绑定、原始操作和控制流构造。这种中间表示更简化、更精确，适合用于程序分析和优化。

然后，作者讨论了**代码图（Graph of Code）**，这是在将λ-表达式线性化之前的一种中间表示。代码图适合表达代码共享和控制流，将程序划分为基本块，并连接它们的入口和出口点。作者解释了这种表示形式的类型定义，以及如何利用类型系统自动强制执行结构约束。

最后，作者介绍了**线性代码（Linear Code）**，这是编译器生成的最后一种表示形式，尽可能接近实际的字节码。由于全局变量和标签的地址和偏移量只能在链接时确定，因此在这个阶段仍然保留了一些符号信息。作者列出了ZINC中的指令类型，并解释了线性代码的作用。

总体而言，本段内容详细阐述了ZINC编译器从源代码到字节码的转换过程中使用的各种中间表示形式，以及它们在编译器设计和实现中的作用。通过对这些表示形式的深入解释，读者可以理解编译器如何逐步处理程序，进行语法解析、语义分析、优化和代码生成。这对于理解编译器的工作原理、程序的表示和转换，以及编程语言的实现细节具有重要的意义。
 #  
 Thought for 10 seconds
**概览**

本段内容选自《ZINC实验：ML语言的经济实现》（The ZINC Experiment: An Economical Implementation of the ML Language）的第5章第5.2.2节，标题为“类型推断”（Type inference）。作者在这一节中讨论了ZINC编译器中类型检查器的现状，指出当前的ZINC实现中还没有类型检查器。他提到了一些关于ML语言类型推断算法的简单实现的参考文献，并评述了这些实现的效率和特点。作者还指出，他计划将Didier Rémy在其博士论文中提出的高效类型推断算法集成到ZINC编译器中。为了帮助理解这一节的内容，我们需要了解类型推断的基本概念、ML语言中的类型系统，以及不同类型推断算法的特点和效率。

**详细解释**

### **背景知识**

#### **类型系统和类型检查**

- **类型系统**是编程语言的一个重要组成部分，用于在编译时或运行时检查程序中值的类型，以防止类型错误。
- **类型检查器（Type Checker）**是负责验证程序类型正确性的工具，通常在编译过程中进行。
- **类型推断（Type Inference）**是指在没有显式类型标注的情况下，编译器自动推导出表达式或程序片段的类型。
#### **ML语言中的类型推断**

- **ML（Meta Language）**是一种函数式编程语言，以其强大的类型系统和类型推断能力著称。
- **Hindley-Milner类型系统**是ML语言类型系统的基础，它允许编译器在大多数情况下自动推断出程序的类型，而无需程序员显式指定。
- **多态性**：ML支持参数多态性，允许函数和数据结构以通用的方式使用不同类型的值。
#### **类型推断算法**

- **核心算法**：类型推断的核心是**合一算法（Unification Algorithm）**，用于解决类型方程，使得表达式的类型一致。
- **破坏性合一（Destructive Unification）**：一种实现合一算法的方式，通过直接修改类型变量的绑定来合并类型信息，提高效率。
### **内容详解**

#### **当前ZINC实现中没有类型检查器**

- **陈述事实**：作者明确指出，在当前的ZINC实现中，还没有类型检查器（typechecker）。
- **影响**：这意味着ZINC编译器目前无法在编译时检测程序中的类型错误，可能会导致在运行时出现未捕获的错误。
#### **ML类型推断算法的简单实现**

- **参考文献[50]**：**内容**：在文献[50]中，作者解释了ML类型推断算法，但是在另一种语言**Miranda**的背景下。**实现特点**：提供了一个非常简单、非常低效的实现。**原因**：由于Miranda语言的特性（不可变性），实现中没有使用破坏性合一（destructive unification）。**结果**：由于缺乏破坏性合一，类型推断算法的效率很低。
- **什么是破坏性合一（Destructive Unification）**：**定义**：在合一算法中，破坏性合一通过直接修改类型变量的绑定（即在原地更新类型信息），避免了创建新的类型表达式，提高了算法的效率。**Miranda的限制**：Miranda是一种纯函数式语言，不允许副作用，因此不能使用破坏性合一。
#### **Michel Mauny的课程笔记[45]**

- **内容**：在Michel Mauny的课程笔记中，提供了一个针对ML子集的更现实的类型检查器。
- **实现特点**：**使用了破坏性合一**：通过直接修改类型变量的绑定，提高了类型推断的效率。**唯一的效率瓶颈**：类型的泛化（generalization）方式。**类型泛化**：在ML的类型系统中，泛化是指将类型变量提升为通用的，使得函数可以适用于多种类型。**效率问题**：如果泛化过程不高效，可能会影响整体的类型推断性能。
- **总体评价**：除了类型泛化的效率问题之外，该实现与“真实的”类型检查器（如CAML系统中的类型检查器）相当。
#### **高效的类型推断**

- **Didier Rémy的博士论文[54]**：**推荐**：作者建议读者参考Didier Rémy的博士论文，以了解非常高效的类型推断方法。**内容**：**两个原型的源代码**：**核心ML语言的类型推断器**：针对ML的核心特性，实现了高效的类型推断。**扩展了记录和变体（具有子类型化）的类型推断器**：支持更复杂的类型特性，包括记录（record）和变体类型（variant types），并且支持子类型化（subtyping）。**实现特点**：**高效的算法**：通过改进类型推断算法，实现了高效的类型检查。**支持高级类型特性**：扩展了ML类型系统，支持子类型化等特性。
- **作者的计划**：**集成到ZINC编译器**：作者计划将Didier Rémy论文中后一个类型推断器（支持记录和变体、子类型化的版本）集成到ZINC编译器中。**意义**：这将使ZINC编译器具备高效的类型推断能力，并支持更丰富的类型特性。
### **深入理解**

#### **为什么类型推断的重要性**

- **提高代码安全性**：类型检查可以在编译时捕获类型错误，防止运行时异常。
- **增强程序的可靠性和可维护性**：明确的类型信息有助于理解程序，提高代码质量。
- **自动化**：类型推断减少了程序员的负担，无需手动指定所有类型。
#### **破坏性合一的优势**

- **效率提升**：通过直接修改类型变量的绑定，避免了大量的类型复制和创建，显著提高了类型推断的效率。
- **适用于允许副作用的语言**：在允许副作用的语言中，如ML，破坏性合一是实现高效类型推断的关键。
#### **类型泛化的挑战**

- **复杂性**：在具有多态性和类型变量的类型系统中，正确地泛化类型以支持多态性是一个复杂的问题。
- **性能影响**：如果泛化过程涉及大量的类型检查和复制，可能会成为类型推断的瓶颈。
#### **Didier Rémy的贡献**

- **改进的类型推断算法**：通过优化类型推断算法，实现了高效的类型检查，即使在支持高级类型特性的情况下。
- **支持子类型化**：引入了子类型化的概念，使得类型系统更加强大和灵活。
- **实用性**：提供了实际的原型和源代码，可以直接用于编译器的实现。
### **作者的取舍和计划**

- **当前不实现类型检查器的原因**：**时间和资源限制**：实现一个高效且完整的类型检查器需要大量的工作。**已有的实现可供参考**：作者希望利用现有的高效实现，而不是从头开始编写。
- **选择Didier Rémy的实现**：**高效率**：Rémy的实现是已知的最有效的类型推断器之一。**先进的类型特性**：支持记录、变体和子类型化，与作者对ZINC编译器的需求相符。**可集成性**：Rémy提供了原型和源代码，方便集成到ZINC编译器中。
**全面详尽的总结**

在本节中，作者讨论了ZINC编译器中类型检查器的现状和未来计划。当前，ZINC实现中还没有类型检查器，这意味着编译器无法在编译时检测类型错误。作者提到了几种ML类型推断算法的实现，并评估了它们的效率和特点。

首先，他提到了文献[50]中的类型推断算法，该算法在Miranda语言的背景下解释了ML的类型推断。由于Miranda的特性，这个实现没有使用破坏性合一，导致了非常低效的类型推断。

接着，作者提到了Michel Mauny的课程笔记[45]，其中提供了一个更现实的ML子集的类型检查器。该实现使用了破坏性合一，显著提高了效率。然而，类型泛化的方式仍然是效率的唯一瓶颈。总体而言，这个实现与实际使用的类型检查器（如CAML系统中的类型检查器）相当。

为了实现高效的类型推断，作者推荐了Didier Rémy的博士论文[54]。Rémy提供了两个原型的源代码，一个用于核心ML语言，另一个扩展了记录和变体类型，并支持子类型化。作者计划将后者集成到ZINC编译器中。

通过这样做，ZINC编译器将获得高效的类型推断能力，支持高级的类型特性，提高编译器的功能和可靠性。这将使ZINC成为一个更完整、更强大的ML语言实现。

综上所述，本节强调了类型推断在编译器实现中的重要性，评估了不同实现的效率，并阐述了作者的计划，即通过集成现有的高效类型推断算法，增强ZINC编译器的能力。
 #  
 Thought for 40 seconds
**概览**

本段内容来自《ZINC实验：ML语言的经济实现》（The ZINC Experiment: An Economical Implementation of the ML Language）的第5章，特别是第5.2.3节，标题为“编译器，前端”（Compiler, front end）。作者在这一节中详细描述了ZINC编译器的第一遍（pass），即从抽象语法树（Abstract Syntax Tree，AST）到扩充的λ-演算（enriched λ-calculus）术语的转换过程。

在这一过程中，编译器执行了以下转换：

- **将模式匹配展开为简单测试的序列**：将复杂的模式匹配结构转换为一系列基本的、易于处理的测试。
- **将局部变量替换为de Bruijn索引和访问路径**：使用de Bruijn编号和访问路径来表示变量，简化变量的引用和绑定。
- **识别原始操作（primitive operations）**：检测并处理内置的原始操作，以优化代码。
- **简单的常量折叠（constant folding）**：对常量表达式进行计算，减少运行时的计算量。
作者首先提供了主函数（用于编译表达式）的源代码，并穿插了一些注释。接着，他解释了如何处理局部环境，以及变量绑定和访问的方式。最后，他提到了模式匹配的编译将在下一节中详细说明。

**详细解释**

### **5.2.3 编译器，前端**

#### **概述**

在编译器的第一遍中，目标是将源代码的抽象语法树（AST）转换为扩充的λ-演算（enriched λ-calculus）表示。这一过程涉及对源代码的深入分析和转换，以便为后续的编译步骤做好准备。

#### **主要转换**

编译器在这一遍中执行了以下转换：

1. **展开模式匹配**：将复杂的模式匹配结构转换为简单的测试序列，使得模式匹配更易于处理和优化。
2. **替换局部变量**：使用**de Bruijn索引**和**访问路径**来表示局部变量。这种表示方式消除了变量名称，提高了变量查找的效率。
3. **识别原始操作**：检测代码中的原始操作（如算术运算、比较操作等），以便对它们进行特殊处理和优化。
4. **常量折叠**：对可以在编译时计算的常量表达式进行求值，减少运行时的计算量，提高效率。
#### **主函数代码分析**

作者提供了编译表达式的主函数`translate`的源代码，并对其进行了解释。

```ocaml
let rec translate env = transl where rec transl = function
  Zconstant cst ->
    Lconst cst
```

- **解释**：当遇到一个常量时，直接将其转换为λ-演算中的常量表示Lconst cst。
```ocaml
| Zconstruct(c,args) ->
    let tr_args = map transl args in
    if c.desc.pure then
      try
        Lconst(SCblock(c.desc.tag,
          map (fun Lconst c -> c
            | _ -> failwith "const") tr_args))
      with failure _ ->
        Lprim(Pmakeblock c.desc.tag, tr_args)
    else
      Lprim(Pmakeblock c.desc.tag, tr_args)
```

- **解释**：**处理构造子应用**：`Zconstruct(c, args)`表示构造子`C`应用于参数`args`。**纯构造子**：如果构造子`C`是“纯”的（即其参数不可变），则进一步检查参数是否都是常量。**如果参数都是常量**：**共享常量**：不需要在每次计算时在堆中构建新的块，可以共享一个在链接时一次性构建的块。**将整个表达式转换为一个结构化常量**：`Lconst(SCblock(...))`。**如果参数中有非常量**：**使用Pmakeblock原语**：Lprim(Pmakeblock c.desc.tag, tr_args)，在运行时构建新的块。**非纯构造子**：直接使用`Pmakeblock`原语。
```ocaml
| Zapply(Zfunction matchlist, args) ->
    if size_of_match matchlist = length args then
      Llet(transl_let env args, transl_match partial_fun matchlist)
    else
      Lapply(transl funct, map transl args)
```

- **解释**：**处理函数应用**：当应用一个函数时，需要考虑特殊情况。**特殊情况1**：函数立即应用于所有参数，且参数数量匹配。**对应于match...with...结构**。**优化**：无需实际评估函数再应用参数，只需在环境中存储参数的值并立即执行模式匹配。**转换为**：`Llet(transl_let env args, transl_match partial_fun matchlist)`。**否则**：按一般情况处理。
```ocaml
| Zapply((Zident(Zglobal
    { desc = { prim = ValuePrim(arity,prim); _ }; _}) as f),
    args) ->
    if arity = length args then
      Lprim(prim, map transl args)
    else
      Lapply(transl f, map transl args)
```

- **解释**：**特殊情况2**：应用一个原始操作（primitive operation）并且提供了所有所需参数。**原始操作识别**：通过检查全局变量是否带有`ValuePrim`注释。**优化**：将其转换为`Lprim(prim, ...)`形式，直接调用原始操作。**否则**：按一般情况处理。
```ocaml
| Zapply(funct, args) ->
    Lapply(transl funct, map transl args)
```

- **解释**：一般情况下，直接递归地翻译函数和参数，生成Lapply表示。
**总结应用的翻译**

- **应用的翻译是直接的，但需要捕获两个特殊情况**：**函数立即应用于所有参数**：优化为直接进行模式匹配。**原始操作的应用**：识别并优化原始操作，避免不必要的函数调用开销。
```ocaml
| Zident(Zlocal s) as E ->
    translate_access s env
```

- **解释**：对于局部变量，使用translate_access函数，根据环境env生成正确的访问序列。
```ocaml
| Zident(Zglobal{ desc = { prim = ValuePrim(arity,prim); _ }; _}) ->
    let rec vars_list = fun 0 -> [] | n -> Lvar(n-1) :: vars_list(n-1) in
    Lfunction(arity, Lprim(prim, vars_list arity))
```

- **解释**：处理作为函数使用的原始操作（如部分应用或作为参数传递）。**构建对应的柯里化函数**：例如，对于加法操作，构建fun x y -> x + y。
```ocaml
| Zident(Zglobal g) ->
    Lprim(Pget_global(g.modname, g.name), [])
```

- **解释**：对于全局变量，使用Pget_global原语获取其值。
```ocaml
| Zassign(s,E) ->
    translate_update s env (transl E)
```

- **解释**：处理变量赋值，使用translate_update函数生成更新变量值的代码。
**环境中的变量查找和更新**

- **局部变量**：从环境`env`中获取，`translate_access`函数生成访问序列。
- **全局变量**：使用`Pget_global`原语。
- **特殊情况**：需要处理原始操作作为函数使用的情况，构建对应的λ-表达式。
```ocaml
| Zsequence(E1, E2) ->
    Lsequence(transl E1, transl E2)
| Zcondition(Eif, Ethen, Eelse) ->
    Lifthenelse(transl Eif, transl Ethen, transl Eelse)
| Zwhile(Econd, Ebody) ->
    Lwhile(transl Econd, transl Ebody)
| Zsequand(E1, E2) ->
    Lsequand(transl E1, transl E2)
| Zsequor(E1, E2) ->
    Lsequor(transl E1, transl E2)
| Zconstraint(E, _) ->
    transl E
```

- **解释**：简单的控制结构在中间表示中有直接对应的构造，只需递归地翻译其参数。
```ocaml
| Zfunction(matchlist) ->
    Lfunction(size_of_match matchlist, transl_match partial_fun matchlist)
```

- **解释**：处理函数定义，使用transl_match函数编译模式匹配部分。
```ocaml
| Ztrywith(body, pat_exprlist) ->
    Lhandle(transl body,
      transl_match partial_try
        (map (fun (pat,expr) -> [pat], expr) pat_exprlist))
```

- **解释**：处理异常捕获try...with...结构，将其转换为异常处理器Lhandle，并使用transl_match编译匹配部分。
```ocaml
| Zlet(pat_exprlist, body) ->
    let cas = map fst pat_exprlist
    and args = map snd pat_exprlist in
    Llet(transl_let env args, transl_match partial_let [cas, body])
```

- **解释**：处理`let`绑定。**分离模式和表达式**：`cas`为模式列表，`args`为对应的表达式列表。**编译绑定的表达式**：使用`transl_let`函数。**编译模式匹配**：使用`transl_match`函数。
```ocaml
| Zletrec(pat_exprlist, body) ->
    let cas = map fst pat_exprlist
    and args = map snd pat_exprlist in
    let transl_in_newenv = translate (make_env env cas) in
    Lletrec(map transl_in_newenv args,
      transl_match partial_let [cas, body])
```

- **解释**：处理递归绑定`let rec`。**与let类似**，但在编译绑定的表达式时，变量已经在环境中定义，因此需要在扩展的环境中编译。
**模式匹配的编译**

```ocaml
and transl_match failure_code casel =
    let transl_action (patlist, expr) =
      patlist, translate (make_env env patlist) expr in
    translate_matching failure_code (map transl_action casel)
```

- **解释**：**transl_match函数**负责编译模式匹配部分。**参数failure_code**：指示匹配失败时应执行的操作，例如在函数或`let`中抛出特殊异常`match_fail`。**casel**：模式和表达式的列表，表示多个匹配情况。**处理过程**：**翻译每个动作（右侧的表达式）**：在扩展的环境中编译，每个模式绑定的变量都在环境中定义。**将修改后的匹配传递给translate_matching函数**（将在后续部分解释）。
```ocaml
and transl_let env = function
  [] -> []
| a::L -> translate env a :: transl_let (Treserved env) L
```

- **解释**：`transl_let`函数负责编译`let`绑定的表达式列表。**递归地编译每个表达式**。**更新环境**：在编译下一个表达式时，环境需要调整，因为新的绑定会影响变量的索引。
#### **环境处理**

**变量绑定的两种处理方式**

1. **扩展环境**：模式匹配代码将绑定的变量的值放入环境的新槽位中。
- **优势**：在平坦的环境结构中，效率更高。
- **劣势**：实现起来稍微复杂。
2. **不扩展环境**：环境只包含被匹配的项，在模式匹配的右侧，变量的引用通过环境的访问和一系列间接寻址来获取变量的值。
- **作者选择了这种方式**，因为实现更简单。
**表示环境的数据结构**

```ocaml
type transl_env =
  Tnullenv
| Treserved of transl_env
| Tenv of (string & num list) list & transl_env
```

- **解释**：**Tnullenv**：表示空环境。**Treserved**：保留环境的一个槽位，不声明新的局部变量。用于编译`let`绑定时调整变量索引。**Tenv**：在现有环境前引入一个新值。在该槽位中，存储引用此值子项的局部变量列表，以及对应的访问路径。
**查找变量的函数**

```ocaml
let search_env s = search_rec 0 where rec search_rec i = function
  Tnullenv -> zinc_error "search_env : unknown local"
| Treserved env -> search_rec (i+1) env
| Tenv(L,env) -> try (i, assoc s L)
    with failure "find" -> search_rec (i+1) env
```

- **解释**：**search_env函数**用于查找变量`s`在环境中的位置和访问路径。**参数i**：当前环境的深度，用于计算de Bruijn索引。**处理过程**：**遇到Treserved**：环境深度增加1，继续搜索。**遇到Tenv**：检查变量是否在当前槽位的变量列表中。**如果找到**：返回当前深度和访问路径。**否则**：深度增加1，继续搜索。
**变量访问和更新的生成**

```ocaml
let translate_access s env =
  let (i,path) = search_env s env in
  list_it (fun n lambda -> Lprim(Pfield n, [lambda])) path (Lvar i)
```

- **解释**：**translate_access函数**生成访问局部变量`s`的表达式。**步骤**：**查找变量的位置和访问路径**：使用`search_env`。**构建访问表达式**：从环境中的位置开始，通过`Pfield`原语和访问路径，逐步获取变量的值。
```ocaml
and translate_update s env lambda =
  match search_env s env with
    (i, n::path) ->
      Lprim(Psetfield n,
        [list_it (fun m lambda -> Lprim(Pfield m, [lambda]))
          path (Lvar i);
        lambda])
  | _ -> zinc_error "translate_update : not mutable"
```

- **解释**：**translate_update函数**生成更新局部变量`s`的表达式。**步骤**：**查找变量的位置和访问路径**。**构建更新表达式**：使用`Psetfield`原语，在访问路径的最后一步设置新的值。**注意**：如果变量不可变（没有访问路径），则抛出错误。
**保持变量绑定的跟踪**

- **绑定的唯一构造**：多重模式匹配。
- **处理过程**：**计算模式中所有变量的访问路径**：
```ocaml
let rec paths_of_pat path = function
  Zvarpat s ->
    [s, path]
| Zaliaspat(pat,s) ->
    (s, path) :: paths_of_pat path pat
| Zconstructpat(_, patlist) ->
    let rec paths_of_patlist i = function
      [] -> []
    | p::pl -> paths_of_pat (i::path) p @ paths_of_patlist (i+1) pl
    in paths_of_patlist 0 patlist
| Zconstraintpat(pat,_) ->
    paths_of_pat path pat
| _ -> []
```
**解释**：**path**：表示当前访问路径，初始为空列表`[]`。**对于变量模式Zvarpat s**：将变量`s`与当前路径关联。**对于别名模式Zaliaspat**：处理别名和原始模式。**对于构造子模式Zconstructpat**：递归处理子模式，更新路径。**扩展环境**：
```ocaml
let make_env = it_list (fun env pat -> Tenv(paths_of_pat [] pat, env))
```
**解释**：对于每个模式`pat`，使用`paths_of_pat`计算变量的访问路径，并在环境前添加一个新的`Tenv`节点。**变量的编号**：模式`pi1, ..., pin`对应的变量编号为`n, ..., 1`。
**综合解释**

- **在编译模式匹配的右侧表达式ei时，需要在扩展的环境中编译**，其中模式`pi1, ..., pin`中绑定的变量已经在环境中定义。
- **通过上述处理，编译器可以正确地跟踪变量的绑定和引用，生成正确的λ-演算表示**。
**总结**

本节详细描述了ZINC编译器的前端部分，即将抽象语法树转换为扩充的λ-演算表示的过程。编译器在这一过程中进行了模式匹配的展开、变量的替换、原始操作的识别以及常量折叠等转换。

作者通过给出主函数的代码，解释了各个语言构造的处理方式，包括构造子应用、函数应用、变量访问和更新、控制结构以及模式匹配等。他特别强调了环境的处理方式，选择了不扩展环境的方法，通过访问路径来获取变量的值。这种方法实现相对简单，但需要仔细跟踪变量在环境中的位置和访问路径。

通过定义环境的数据结构`transl_env`，编译器可以准确地查找和生成变量的访问和更新表达式。同时，通过计算模式中变量的访问路径，编译器能够正确地处理模式匹配中的变量绑定。

总的来说，本节深入探讨了编译器在前端处理中的关键问题，包括变量绑定、环境管理和模式匹配的编译，为理解编译器的实现细节提供了重要的参考。
 #  
 Thought for 31 seconds
**概览**

本段内容选自《ZINC实验：ML语言的经济实现》（The ZINC Experiment: An Economical Implementation of the ML Language）的第5章，特别是第5.2.4节，标题为“编译模式匹配”（Compiling pattern matching）。作者在这一节中深入探讨了如何将ML语言中的模式匹配（pattern matching）编译为一系列基本的`if...then...else`测试。

模式匹配是函数式编程语言（如ML、Haskell）中的一个关键特性，它允许程序员以一种简洁而直观的方式对数据结构进行解构和处理。然而，将高级的模式匹配结构转换为底层可执行的代码（如一系列条件测试）并非易事。作者详细介绍了ZINC编译器中模式匹配编译器的实现，包括其使用的算法、数据结构和函数。

主要内容包括：

- **模式匹配编译的挑战和设计权衡**：为了保持编译器的简单性，作者选择了一种从左到右的遍历方式，虽然可能不是最优的，但实现起来更简单。
- **模式匹配的表示和处理**：讨论了模式匹配的矩阵表示，以及如何将复杂的模式转换为更基本的形式，以便于处理。
- **模式匹配编译的算法**：介绍了用于编译模式匹配的分治算法，包括`split_matching`和`divide_matching`函数。
- **构建λ-演算表示**：解释了如何从模式匹配构建对应的λ-演算表示，以及如何处理匹配失败和部分匹配的情况。
- **部分匹配和未使用的匹配情况的检测**：讨论了如何在编译过程中检测部分匹配和未使用的匹配模式。
**详细解释**

### **背景知识**

#### **模式匹配的重要性**

- **定义**：模式匹配是函数式编程语言中的一种特性，允许程序员根据数据的结构直接拆解数据，并根据不同的形态执行不同的操作。
- **示例**：在ML语言中，可以使用模式匹配来处理列表、树等数据结构，例如：
```ml
match list with
  [] -> (* 处理空列表 *)
| head :: tail -> (* 处理非空列表 *)
```
#### **编译模式匹配的挑战**

- **问题**：将高级的模式匹配结构转换为底层的可执行代码（如`if...then...else`语句）并不简单，特别是当模式复杂、多样时。
- **优化目标**：理想情况下，希望生成的代码执行效率高，避免不必要的测试和计算。
- **困难点**：**测试顺序的优化**：找到最佳的测试顺序，减少不必要的测试，提高执行效率。**处理复杂模式**：支持嵌套模式、别名、类型约束、或模式等。
- **设计权衡**：在追求最优代码和编译器的实现复杂度之间，需要进行权衡。
### **5.2.4 编译模式匹配**

#### **概述**

- **目标**：将模式匹配转换为一系列基本的`if...then...else`测试。
- **方法**：作者选择了一种简单的从左到右的遍历方式，尽管生成的测试序列可能不是最优的，但实现起来更简单。
- **局限性**：**非最优性**：可能会执行一些不必要的测试。**在严格求值语义下的影响**：由于ML采用严格求值，非最优的模式匹配不会导致语义上的差异（即使执行了不必要的测试，程序的行为仍然正确）。
#### **模式匹配的表示**

##### **匹配矩阵**

- **定义**：将模式匹配表示为一个模式矩阵，包含：**模式矩阵**：每行对应一个匹配情况，每列对应一个匹配项。**动作（actions）**：每行对应一个λ-表达式，表示匹配成功时要执行的代码。**访问路径（access paths）**：每列对应一个λ-表达式，用于访问被匹配的值。
- **示意图**：
```python
path1   ...   pathk
  ↓            ↓
p11   ...   p1k   →   act1
...
pn1   ...   pnk   →   actn
```
- **解释**：**path1, ..., pathk**：用于访问被匹配的值的λ-表达式列表。**pij**：表示第i行第j列的模式。**acti**：表示第i行匹配成功时要执行的动作。
##### **模式的简化**

- **变量和通配符**：**变量名的无关性**：在ML模式中，变量名本身不重要（模式是线性的），因此将变量模式Zvarpat和通配符Zwildpat视为相同，统一表示为Ω。
- **别名和类型约束**：**别名模式Zaliaspat(p, s)**：将`p as s`视为`p`。**类型约束Zconstraintpat**：在模式匹配编译中忽略类型约束。
- **或模式(p1 | p2)的处理**：**转换**：将或模式拆分为两个独立的模式匹配情况。**示例**：
```scss
(p1 | p2) ... pk   →   acti
```
转换为：
```
p1   ...   pk   →   acti
p2   ...   pk   →   acti
```
#### **模式匹配的表示类型**

- **定义**：
```ocaml
type pattern_matching = Matching of (pattern list & lambda) list & lambda list
```
- **解释**：**Matching**：包含一个模式列表和对应的动作列表，以及访问路径列表。**(pattern list & lambda) list**：表示多个匹配情况，每个情况包含模式列表和对应的动作。**lambda list**：访问路径列表。
#### **辅助函数**

##### **添加匹配情况**

- **函数**：
```ocaml
let add_to_match (Matching(casel, pathl)) cas =
  Matching(cas :: casel, pathl)
```
- **作用**：向匹配矩阵中添加一行新的匹配情况`cas`。
##### **构建匹配**

- **常量匹配**：
```ocaml
let make_constant_match (path :: pathl) cas =
  Matching([cas], pathl)
```
**作用**：从当前匹配矩阵中提取一行，丢弃最左边的模式（假设为叶子节点，如常量模式），构建新的匹配矩阵。
- **构造子匹配**：
```ocaml
and make_construct_match numargs (path :: pathl) cas =
  Matching([cas], make_path 0)
where rec make_path i =
  if i >= numargs then pathl else Lprim(Pfield i, [path]) :: make_path (i+1)
```
**作用**：处理带有构造子的模式，将模式展开，添加构造子参数的访问路径。
- **解释**：**make_constant_match**：处理常量模式，丢弃左边的模式，更新访问路径。**make_construct_match**：处理构造子模式，展开构造子的参数，将其添加到访问路径列表中。
#### **模式匹配编译的分治算法**

- **总体思路**：使用分治算法，将复杂的匹配矩阵逐步分解为更小的匹配，以便递归地处理。
##### **分割匹配（当左上模式是变量时）**

- **情况1**：左上模式是变量（或通配符`Ω`）。
- **处理**：**将匹配矩阵分为两部分**：**p1**：包含左上模式为变量的匹配情况。**p2**：包含左上模式不是变量的匹配情况。**示意图**：
```python
path1   path2   ...   pathk
  ↓        ↓            ↓
Ω    p12   ...   p1k   →   a1
...
Ω    pn2   ...   pnk   →   an
q11 ≠ Ω   q12   ...   q1k   →   b1
...
qm1   qm2   ...   qmk   →   bm
```
**结果**：**匹配矩阵vars**：
```python
path2   ...   pathk
  ↓            ↓
p12   ...   p1k   →   a1
...
pn2   ...   pnk   →   an
```
**匹配矩阵others**：
```python
path1   path2   ...   pathk
  ↓        ↓            ↓
q11   q12   ...   q1k   →   b1
...
qm1   qm2   ...   qmk   →   bm
```
- **对应的ML函数**：
```ocaml
let split_matching (Matching(casel, (_ :: endpathl as pathl))) =
  split_rec casel where rec split_rec = function
    ((Zwildpat | Zvarpat _) :: patl, action) :: rest ->
      let vars, others = split_rec rest in
      add_to_match vars (patl, action),
      others
  | (Zaliaspat(pat,v) :: patl, action) :: rest ->
      split_rec ((pat::patl, action) :: rest)
  | (Zconstraintpat(pat,ty) :: patl, action) :: rest ->
      split_rec ((pat::patl, action) :: rest)
  | (Zorpat(pat1, pat2) :: patl, action) :: rest ->
      split_rec ((pat1::patl, action) :: (pat2::patl, action) :: rest)
  | casel ->
      Matching([], endpathl), Matching(casel, pathl)
```
- **解释**：**split_rec函数**：递归地处理匹配情况。**处理变量和通配符**：将其加入`vars`匹配矩阵。**处理别名、类型约束和或模式**：展开或继续处理内部模式。**其他情况**：将匹配情况加入`others`匹配矩阵。
##### **分割匹配（当左上模式不是变量时）**

- **情况2**：左上模式不是变量。
- **处理**：**水平分割匹配矩阵**：在左列第一个变量之前，将匹配矩阵分为两部分。**示意图**：
```python
path1   ...   pathk
  ↓            ↓
p11 ≠ Ω   ...   p1,k-1   →   a1
...
pn1 ≠ Ω   ...   pn,k-1   →   an
Ω    ...   q1k   →   b1
...
qm1   ...   qmk   →   bm
```
**结果**：**匹配矩阵（非变量部分）**：
```python
path1   ...   pathk
  ↓            ↓
p11   ...   p1k   →   a1
...
pn1   ...   pnk   →   an
```
**匹配矩阵（变量部分）**：
```python
path1   path2   ...   pathk
  ↓        ↓            ↓
Ω    ...   q1k   →   b1
...
qm1   ...   qmk   →   bm
```
- **对左上模式进行进一步处理**：**将左列中具有相同顶层符号的匹配情况分组**。**对每个分组，构建子匹配矩阵**。
- **示例（常量模式）**：
```css
path1   path2   ...   pathn
  ↓        ↓            ↓
1    p2   ...   pn   →   a
2    q2   ...   qn   →   b
1    r2   ...   rn   →   c
```
**分组**：**常量1**：
```css
path2   ...   pathn
  ↓            ↓
p2   ...   pn   →   a
r2   ...   rn   →   c
```
**常量2**：
```css
path2   ...   pathn
  ↓            ↓
q2   ...   qn   →   b
```
- **示例（构造子模式）**：
```python
path1   path2   ...   pathn
  ↓        ↓            ↓
C(p', p'')   p2   ...   pn   →   a
D(q')      q2   ...   qn   →   b
C(r', r'')   r2   ...   rn   →   c
```
**展开构造子参数**：**对于构造子C**：
```python
path1;[0]   path1;[1]   path2   ...   pathn
  ↓            ↓            ↓            ↓
p'     p''     p2   ...   pn   →   a
r'     r''     r2   ...   rn   →   c
```
**对于构造子D**：
```css
path1;[0]   path2   ...   pathn
  ↓            ↓            ↓
q'     q2   ...   qn   →   b
```
- **对应的ML函数**：
```ocaml
let divide_matching (Matching(casel, (_ :: tailpathl as pathl))) =
  divide_rec casel where rec divide_rec = function
    [] ->
      [], [], Matching([], pathl)
  | ([], _) :: _ ->
      zinc_error "divide_matching"
  | (Zaliaspat(pat,v) :: patl, action) :: rest ->
      divide_rec ((pat::patl, action) :: rest)
  | (Zconstraintpat(pat,ty) :: patl, action) :: rest ->
      divide_rec ((pat::patl, action) :: rest)
  | (Zorpat(pat1, pat2) :: patl, action) :: rest ->
      divide_rec ((pat1::patl, action) :: (pat2::patl, action) :: rest)
  | (Zconstantpat(cst) :: patl, action) :: rest ->
      let (constant, others) = divide_rec rest in
      add_to_division (make_constant_match pathl) constant
        cst (patl, action),
      others
  | (Zconstructpat(c,args) :: patl, action) :: rest ->
      let (constant, constrs, others) = divide_rec rest in
      constant,
      add_to_division (make_construct_match (length args) pathl) constrs
        c.desc.tag (args @ patl, action),
      others
  | casel ->
      [], [], Matching(casel, pathl)
```
- **解释**：**divide_rec函数**：递归地处理匹配情况。**处理别名、类型约束和或模式**：展开或继续处理内部模式。**处理常量模式**：将具有相同常量的匹配情况分组，使用`add_to_division`函数。**处理构造子模式**：将具有相同构造子的匹配情况分组，展开构造子参数，使用`add_to_division`函数。**返回值**：返回一个三元组，包含常量匹配、构造子匹配和剩余的匹配矩阵。
##### **add_to_division函数**

- **定义**：
```ocaml
let add_to_division make_match divlist key cas =
  try
    let matchref = assoc key divlist in
    matchref := add_to_match !matchref cas; divlist
  with failure "find" ->
    (key, ref (make_match cas)) :: divlist
```
- **作用**：**将匹配情况cas添加到divlist中对应key的匹配中**。**如果key不存在**，则创建新的匹配并添加到`divlist`。
#### **构建λ-演算表示**

- **目标**：从模式匹配矩阵构建对应的λ-演算表达式。
- **处理不同的匹配情况**：**空的匹配矩阵**：总是匹配失败。
```ml
[empty matching] = staticfail
```
**平坦的匹配矩阵（没有模式）**：总是匹配成功，执行第一行的动作。
```ml
[flat matching] = act1
```
**匹配矩阵以变量开头**：**将匹配矩阵分为两部分**：`p1`和`p2`。**构建表达式**：
```ml
[p] = [p1] statichandle [p2]
```
**解释**：**p1**：左上模式为变量的匹配情况。**p2**：剩余的匹配情况。**statichandle**：表示静态作用域的异常处理器，如果`[p1]`匹配失败，则执行`[p2]`。**匹配矩阵不以变量开头**：**根据path1的值，分派到不同的子匹配**。**构建表达式**：**对于常量匹配**：
```ml
[p] = (case path1 of
          c1 : [m1];
          c2 : [m2];
          ...
       ) statichandle [m0]
```
**对于构造子匹配**：
```ml
[p] = (case tag_of(path1) of
          tag1 : [m1];
          tag2 : [m2];
          ...
       ) statichandle [m0]
```
- **最终的递归函数**
```ocaml
let rec conquer_matching =
  let rec conquer_divided_matching = function
    [] ->
      [], Total, 0
  | (key, matchref) :: rest ->
      let lambda1, partial1, unused1 = conquer_matching !matchref
      and list2, partial2, unused2 = conquer_divided_matching rest in
      (key, lambda1) :: list2,
      (match (partial1, partial2) with
        (Total,Total) -> Total
      | (Partial, _) -> Partial
      | (_, Partial) -> Partial
      | _ -> Dubious),
      unused1 @ unused2
  in function
    Matching([], _) ->
      Lstaticfail, Partial, 0
  | Matching(([],action) :: rest, _) ->
      action, Total, rest
  | Matching(_, (path :: _)) as matching ->
      if starts_by_a_variable matching then
        let vars, rest = split_matching matching in
        let lambda1, partial1, unused1 = conquer_matching vars
        and lambda2, partial2, unused2 = conquer_matching rest in
        if partial1 = Total then
          lambda1, Total, unused1 @ lines_of_matching rest
        else
          Lstatichandle(lambda1, lambda2),
          (if partial2 = Total then Total else Dubious),
          unused1 @ unused2
      else (match divide_matching matching with
        [], [], vars ->
          conquer_matching vars
      | constants, [], vars ->
          let condlist1, _ , unused1 = conquer_divided_matching constants
          and lambda2, partial2, unused2 = conquer_matching vars in
          Lstatichandle(Lcond(path, condlist1), lambda2),
          partial2,
          unused1 @ unused2
      | [], constrs, vars ->
          let switchlst, partial1, unused1 = conquer_divided_matching constrs
          and lambda, partial2, unused2 = conquer_matching vars in
          let span = get_span_of_matching matching in
          if length constrs = span & partial1 = Total then
            Lswitch(span, path, switchlst),
            Total,
            unused1 @ lines_of_matching vars
          else
            Lstatichandle(Lswitch(span, path, switchlst), lambda),
            (if partial1 = Total then partial2
            if partial2 = Total then Total
            else Dubious),
            unused1 @ unused2
      | _ -> zinc_error "conquer_matching : ill_typed matching")
    | _ -> zinc_error "conquer_matching"
```
- **解释**：**conquer_matching函数**：递归地处理匹配矩阵，构建对应的λ-演算表达式。**处理不同的匹配情况**：空的匹配、平坦的匹配、以变量开头的匹配、不以变量开头的匹配。**返回值**：**lambda**：构建的λ-演算表达式。**partial**：匹配的完整性信息，类型为`partiality = Partial | Total | Dubious`。**unused**：未使用的匹配情况列表。
#### **部分匹配和未使用的匹配情况的检测**

- **问题**：在模式匹配中，可能存在未涵盖所有情况的部分匹配，或者存在无法达到的匹配情况。
- **处理**：**partiality信息**：通过`Partial`、`Total`和`Dubious`来表示匹配的完整性。**Partial**：部分匹配，未涵盖所有可能情况。**Total**：完全匹配，涵盖所有可能情况。**Dubious**：不确定的匹配完整性。**未使用的匹配情况**：通过在编译过程中跟踪未使用的匹配情况，生成警告信息。
- **局限性**：对于复杂的匹配重叠，难以准确检测，可能只能近似地判断匹配的完整性。
#### **与编译器前端的集成**

- **代码**：
```ocaml
let translate_matching failure_code casel =
  let rec make_path =
    function 0 -> []
    | n -> Lvar(n-1) :: make_path(n-1) in
  let (lambda, partial, unused) =
    conquer_matching (Matching(casel, make_path (length (hd casel)))) in
  (match unused with
    [] -> ()
  | [_] -> message "1 unused case in this match."
  | _ -> print_num (length unused); message " unused cases in this match.");
  (match partial with
    Total -> lambda
  | _ -> Lstatichandle(lambda, failure_code partial))
```
- **解释**：**translate_matching函数**：将模式匹配编译器与编译器前端集成。**failure_code参数**：用于在匹配失败时生成适当的警告并返回抛出正确异常的λ-表达式。**处理流程**：**构建初始访问路径**。**调用conquer_matching**，获取λ-演算表达式、匹配完整性信息和未使用的匹配情况。**生成未使用匹配情况的警告**。**根据匹配完整性，可能添加异常处理器**。
#### **处理function和try...with...结构的匹配失败**

- **代码**：
```ocaml
let partial_fun par =
  if par = Partial then print_string "Partial function.\n";
  Lprim(Praise, [Lconst(SCblock(ConstrExtensible "match_fail", []))])
and partial_try par =
  Lprim(Praise, [Lvar 0]) (* reraise the trapped exception *)
```
- **解释**：**partial_fun**：用于处理`function`结构的匹配失败。**如果匹配是部分的**，则打印警告。**生成抛出`match_fail`异常的λ-表达式。**partial_try**：用于处理`try...with...`结构的匹配失败。**重新抛出被捕获的异常**。
**全面详尽的总结**

本节详细探讨了ZINC编译器中模式匹配编译器的实现，解释了如何将ML语言中的高级模式匹配结构转换为底层的可执行代码。作者选择了一种简单的从左到右的遍历方式，虽然可能不是最优的，但实现起来更简单，适合于严格求值语义的ML语言。

主要内容包括：

1. **模式匹配的表示**：将模式匹配表示为一个模式矩阵，包含模式、动作和访问路径。通过简化模式，统一处理变量、通配符、别名、类型约束和或模式。
2. **分治算法**：使用分治算法将匹配矩阵分割为更小的部分，递归地处理。根据左上模式是否为变量，采取不同的分割策略。
3. **构建λ-演算表示**：从匹配矩阵构建对应的λ-演算表达式，处理匹配失败、部分匹配和未使用的匹配情况。
4. **部分匹配和未使用匹配的检测**：在编译过程中，尝试检测匹配的完整性和未使用的匹配情况，生成警告信息。
5. **与编译器前端的集成**：将模式匹配编译器与编译器的第一遍集成，处理`function`和`try...with...`等结构的匹配失败。
通过这一节的详细解释，我们了解了模式匹配编译的复杂性，以及在编译器实现中需要考虑的各种因素。作者的实现虽然不追求最优的代码，但在保证正确性的前提下，简化了编译器的设计和实现。这对于理解编译器的工作原理、模式匹配的编译过程，以及函数式编程语言的实现细节具有重要的意义。
 #  
 Thought for 59 seconds
**概览**

本段内容选自《ZINC实验：ML语言的经济实现》（The ZINC Experiment: An Economical Implementation of the ML Language）的第5章，特别是第5.2.5节，标题为“编译器，后端”（Compiler, back end）。作者在这一节中详细描述了ZINC编译器的第二遍（pass），即将中间的λ-演算（lambda calculus）表达式转换为ZAM（ZINC Abstract Machine）代码的过程。

在这个过程中，编译器执行了代码的**顺序化（sequentialization）**，即将树状的λ-表达式转换为线性的指令序列。作者强调，这一遍只关注顺序化，不尝试通过分析或重组计算来修复原始表达式中的效率问题。然而，编译器尽力在顺序化过程中避免引入新的效率问题。例如，它不会生成跳转到跳转的指令，也不会跳转到返回指令。此外，它能够有效地编译复杂的条件表达式，如`if a = b or c < d then e else f`。

作者首先介绍了编译器在生成ZAM代码时的两种方法，并讨论了为何选择第二种方法更为优越。接着，他深入解释了编译器的主要函数`compile_expr`的实现细节，包括如何处理不同的λ-表达式构造，以及如何利用继续（continuation）信息优化生成的代码。最后，他介绍了编译器如何处理函数抽象体（abstractions）的编译，以及如何将编译结果组织并写入目标代码文件。

**详细解释**

### **5.2.5 编译器，后端**

#### **概述**

在编译器的第二遍，目标是将中间的λ-演算表达式转换为线性的ZAM代码列表。这一遍的主要任务是**顺序化**代码，将抽象的、树状的表达式转换为可以按顺序执行的指令列表。

- **顺序化（Sequentialization）**：将非线性的代码结构转换为线性的指令序列，以便在抽象机器上执行。
- **不引入新效率问题**：虽然编译器不尝试优化原始表达式中的效率问题，但它努力在顺序化过程中不引入新的效率问题。例如：**避免生成多余的跳转**：不会生成跳转到跳转的指令，或跳转到返回指令。**优化复杂的条件表达式**：能够有效地编译复杂的条件表达式，避免不必要的计算和跳转。
#### **示例：复杂条件表达式的编译**

考虑以下复杂条件表达式：

```ocaml
if a = b or c < d then e else f
```

编译器将其转换为更高效的ZAM代码：

```css
if a = b goto 1;
if c >= d goto 2;
1: e;
goto 3;
2: f;
3:
```

- **解释**：**第一个条件**：如果`a = b`为真，跳转到标签`1`。**第二个条件**：如果`c >= d`为真，跳转到标签`2`。**标签1**：执行表达式`e`。**标签2**：执行表达式`f`。**标签3**：程序继续执行。
#### **生成ZAM代码的方法**

编译器可以采用两种方法生成ZAM代码：

1. **子列表拼接法**：
- 为原始λ-表达式的每个子表达式生成一个代码子列表。
- 使用列表拼接操作符`@`将这些子列表组合成完整的代码列表。
- **缺点**：列表拼接操作代价较高，即使可以通过物理修改来优化。
2. **右到左单遍构建法**（**编译器采用的方法**）：
- 在一次从右到左的遍历中构建代码列表。
- 函数接受要编译的表达式和一个代码列表作为参数。
- 将与表达式对应的指令**前置**到代码列表之前。
- **优势**：**避免了列表拼接的高成本**。**可以访问表达式的**继续（continuation）**信息**，即表达式之后将要执行的代码。**继续信息的利用**：**识别尾调用（tail-call）位置**：如果继续以`Kreturn`指令开始，则表达式处于尾调用位置。**优化跳转指令**：根据继续的结构，决定是直接跳转到标签，还是插入返回指令。
##### **示例：检测尾调用**

```ocaml
let is_tail = function
  Kreturn :: _ -> true
| _ -> false
```

- **解释**：如果继续列表以Kreturn指令开始，则当前表达式处于尾调用位置。
##### **示例：优化跳转指令**

```ocaml
let make_branch = function
  Kreturn :: _ as C -> Kreturn, C
| (Kbranch _ as branch) :: _ as C -> branch, C
| C -> let lbl = new_label() in Kbranch lbl, Klabel lbl :: C
```

- **解释**：**第一种情况**：如果继续以`Kreturn`指令开始，则直接返回`Kreturn`指令，无需生成新的跳转。**第二种情况**：如果继续以`Kbranch`指令开始，可以直接使用已有的跳转指令。**第三种情况**：否则，生成新的标签和跳转指令。
##### **示例：给代码块加标签**

```ocaml
let label_code = function
  Kbranch lbl :: _ as C -> lbl, C
| Klabel lbl :: _ as C -> lbl, C
| C -> let lbl = new_label() in lbl, Klabel lbl :: C
```

- **解释**：**第一种情况**：如果代码以`Kbranch lbl`开始，返回已有的标签`lbl`。**第二种情况**：如果代码以`Klabel lbl`开始，返回已有的标签`lbl`。**第三种情况**：否则，生成新的标签，并在代码前添加`Klabel`指令。
#### **主要函数：compile_expr**

- **功能**：将中间的λ-表达式编译为ZAM代码列表。
- **参数**：**staticfail**：用于编译`Lstaticfail`和`Lstatichandle`指令的标签。表示当前静态异常处理器的标签。**中间λ-表达式**：要编译的表达式。**继续C**：表达式之后要执行的代码列表。
- **工作流程**：**模式匹配表达式**：根据λ-表达式的构造，选择对应的编译方法。**利用继续信息**：在需要时，根据继续`C`的结构，优化生成的代码。
##### **函数定义**

```ocaml
let rec compile_expr staticfail = compexp
where rec compexp = function
  (Lvar n) C ->
    Kaccess n :: C
  | (Lconst cst) C ->
    Kquote cst :: C
  | (Lapply(body, args)) ->
    (function
      Kreturn :: C ->
        compexplist args (Kpush :: compexp body (Ktermapply :: C))
    | C ->
        Kpushmark ::
        compexplist args (Kpush :: compexp body (Kapply :: C)))
```

- **解释**：**变量Lvar n**：生成Kaccess n指令，表示从环境中获取变量n。**常量Lconst cst**：生成Kquote cst指令，将常量放入累加器。**函数应用Lapply(body, args)**：**检测尾调用**：通过模式匹配继续`C`，如果继续以`Kreturn`开始，表示处于尾调用位置。**尾调用优化**：使用`Ktermapply`指令，进行尾调用优化。忽略后续的`Kreturn`指令（因为`Ktermapply`已经是尾调用，不需要返回）。**一般情况**：使用`Kapply`指令进行函数调用。在调用前，使用`Kpushmark`指令设置堆栈帧。**compexplist函数**：用于编译参数列表，在参数之间插入`Kpush`指令。
##### **处理函数定义Lfunction**

```ocaml
| (Lfunction(n, body)) C ->
    if is_tail C then
      iterate (cons Kgrab) n (compexp body C)
    else
      (let lbl = new_label() in
       add_to_compile (n, body, lbl);
       Kclosure lbl :: C)
```

- **解释**：**尾调用位置的函数定义**：不需要构建闭包。直接在当前位置展开函数体。使用`n`个`Kgrab`指令，将参数绑定到环境中。**一般情况**：生成`Kclosure lbl`指令，构建闭包。**推迟编译函数体**：由于当前正在编译其他代码，无法立即编译函数体。使用`add_to_compile`函数，将函数体加入待编译的队列中。在当前表达式完全编译后，再编译这些函数体。
##### **处理let绑定Llet**

```ocaml
| (Llet(args, body)) C ->
    let C1 = if is_tail C then C else Kendlet(length args) :: C in
    let C2 = compexp body C1 in
    let rec comp_args = function
      [] -> C2
    | exp::rest -> compexp exp (Klet :: comp_args rest) in
    comp_args args
```

- **解释**：**调整继续**：如果在尾调用位置，不需要添加`Kendlet`指令。否则，添加`Kendlet`指令，表示`let`绑定的结束。**编译body**：在新的继续C1下编译body。**编译绑定的表达式args**：递归地编译每个绑定的表达式。在每个表达式之间插入`Klet`指令，将其值加入环境。
##### **处理递归绑定Lletrec**

```ocaml
| (Lletrec(args, body)) C ->
    let size = length args in
    let C1 = if is_tail C then C else Kendlet size :: C in
    let C2 = compexp body C1 in
    let rec comp_args i = function
      [] -> C2
    | exp::rest -> compexp exp (Kupdate i :: comp_args (i-1) rest) in
    Kdummies size :: comp_args (size-1) args
```

- **解释**：**创建虚拟闭包**：使用Kdummies size指令，在环境中放置size个虚拟闭包。**编译递归函数**：递归地编译每个绑定的表达式。使用`Kupdate i`指令，更新第`i`个虚拟闭包。**编译body**：在继续C1下编译body。
##### **处理原始操作Lprim**

- **获取全局变量**：
```ocaml
| (Lprim(Pget_global qualid, [])) C ->
    Kget_global qualid :: C
```
**解释**：生成Kget_global指令，从全局环境中获取变量。
- **设置全局变量**：
```ocaml
| (Lprim(Pset_global qualid, [exp])) C ->
    compexp exp (Kset_global qualid :: C)
```
**解释**：先编译表达式exp，然后生成Kset_global指令，设置全局变量的值。
- **构建块（元组或记录）**：
```ocaml
| (Lprim(Pmakeblock tag, explist)) C ->
    compexplist explist (Kmakeblock(tag, length explist) :: C)
```
**解释**：编译表达式列表explist，然后生成Kmakeblock指令，在堆中构建块。
- **布尔操作和比较**：**处理not操作**：
```ocaml
| (Lprim(Pnot, [exp])) ->
    (function
      Kbranchif lbl :: C ->
        compexp exp (Kbranchifnot lbl :: C)
    | Kbranchifnot lbl :: C ->
        compexp exp (Kbranchif lbl :: C)
    | C ->
        compexp exp (Kprim Pnot :: C))
```
**解释**：**优化条件跳转**：如果`not`操作后跟条件跳转，可以直接反转跳转条件，避免实际计算`not`。**一般情况**：否则，正常编译`not`操作。**处理比较操作**：
```ocaml
| (Lprim((Ptest tst as p), explist)) ->
    (function
      Kbranchif lbl :: C ->
        compexplist explist (Ktest(tst,lbl) :: C)
    | Kbranchifnot lbl :: C ->
        compexplist explist (Ktest(invert_bool_test tst,lbl) :: C)
    | C ->
        compexplist explist (Kprim p :: C))
```
**解释**：**优化条件跳转**：如果比较操作后跟条件跳转，可以直接生成`Ktest`指令，避免计算布尔值。**invert_bool_test函数**：将比较操作取反，例如将`Pequal_test`转换为`Pnotequal_test`。**一般的原始操作**：
```ocaml
| (Lprim(p, explist)) C ->
    compexplist explist (Kprim p :: C)
```
**解释**：编译参数列表explist，然后生成对应的原始操作指令。
#### **优化布尔操作和条件跳转**

- **目标**：避免不必要的计算和跳转，生成更高效的代码。
- **策略**：**条件跳转优化**：当布尔操作的结果仅用于条件跳转时，直接生成条件跳转指令，避免计算布尔值。**短路求值**：在`and`和`or`等逻辑操作中，利用条件跳转优化，避免不必要的计算。
- **示例**：**not操作的优化**：如果`not`后跟`Kbranchif`，可以直接反转跳转条件。**比较操作的优化**：如果比较后跟条件跳转，使用`Ktest`指令。
#### **处理静态异常处理器**

- **静态异常处理器Lstatichandle和Lstaticfail**：**Lstatichandle**：
```ocaml
| (Lstatichandle(body, Lstaticfail)) C ->
    compexp body C
```
**解释**：如果处理器是Lstaticfail，直接编译body。**一般情况**：
```ocaml
| (Lstatichandle(body, handler)) C ->
    let branch1, C1 = make_branch C
    and lbl2 = new_label() in
    compile_expr lbl2 body (branch1 :: Klabel lbl2 :: compexp handler C1)
```
**解释**：更新当前静态异常处理器的标签`staticfail`。编译`body`，在遇到`Lstaticfail`时跳转到`lbl2`。编译`handler`，处理异常。**Lstaticfail**：
```ocaml
| (Lstaticfail) C ->
    Kbranch staticfail :: C
```
**解释**：生成跳转到当前静态异常处理器的指令。
#### **处理动态异常处理器Lhandle**

```ocaml
| (Lhandle(body, handler)) C ->
    let branch1, C1 = make_branch C in
    let lbl2 = new_label() in
    let C2 = if is_tail C1 then C1 else Kendlet 1 :: C1 in
    Kpushtrap lbl2 ::
    compexp body
      (Kpoptrap :: branch1 :: Klabel lbl2 :: compexp handler C2)
```

- **解释**：**设置异常处理器**：使用Kpushtrap lbl2指令，设置新的异常处理器，标签为lbl2。**编译body**：在遇到异常时，跳转到lbl2。**恢复异常处理器**：使用Kpoptrap指令，恢复之前的异常处理器。**编译handler**：在标签lbl2处编译异常处理器handler。
#### **处理控制结构**

- **条件语句Lifthenelse**：
```ocaml
| (Lifthenelse(cond, ifso, ifnot)) C ->
    comp_test2 cond ifso ifnot C
```
**解释**：使用辅助函数comp_test2编译条件语句。
- **序列Lsequence**：
```ocaml
| (Lsequence(exp1, exp2)) C ->
    compexp exp1 (compexp exp2 C)
```
**解释**：顺序编译exp1和exp2。
- **while循环Lwhile**：
```ocaml
| (Lwhile(cond, body)) C ->
    let lbl1 = new_label() and lbl2 = new_label() in
    Kbranch lbl1 :: Klabel lbl2 ::
    compexp body (Klabel lbl1 :: compexp cond (Kbranchif lbl2 :: C))
```
**解释**：创建循环的入口和条件检查的标签。编译循环体`body`和条件`cond`。
- **逻辑与Lsequand和逻辑或Lsequor**：**Lsequand**：
```ocaml
| (Lsequand(exp1, exp2)) ->
    (function
      Kbranch lbl :: _ as C ->
        compexp exp1 (Kbranchifnot lbl :: compexp exp2 C)
    | Kbranchifnot lbl :: _ as C ->
        compexp exp1 (Kbranchifnot lbl :: compexp exp2 C)
    | Kbranchif lbl :: C ->
        let lbl1, C1 = label_code C in
        compexp exp1 (Kbranchifnot lbl1 ::
                      compexp exp2 (Kbranchif lbl :: C1))
    | C ->
        let lbl = new_label() in
        compexp exp1 (Kstrictbranchifnot lbl ::
                      compexp exp2 (Klabel lbl :: C)))
```
**Lsequor**：
```ocaml
| (Lsequor(exp1, exp2)) ->
    (function
      Kbranch lbl :: _ as C ->
        compexp exp1 (Kbranchif lbl :: compexp exp2 C)
    | Kbranchif lbl :: _ as C ->
        compexp exp1 (Kbranchif lbl :: compexp exp2 C)
    | Kbranchifnot lbl :: C ->
        let lbl1, C1 = label_code C in
        compexp exp1 (Kbranchif lbl1 ::
                      compexp exp2 (Kbranchifnot lbl :: C1))
    | C ->
        let lbl = new_label() in
        compexp exp1 (Kstrictbranchif lbl ::
                      compexp exp2 (Klabel lbl :: C)))
```
**解释**：**短路求值和优化**：根据继续的结构，优化`and`和`or`的编译，避免不必要的计算。**处理布尔值的副作用**：确保在需要布尔值时，累加器中有正确的值。**使用Kstrictbranchif和Kstrictbranchifnot**：避免优化导致的累加器中值不正确的问题。强制执行条件跳转，不进行优化。
#### **处理多路分支**

- **Lcond**：
```ocaml
| (Lcond(arg, casel)) C ->
    let branch1, C1 = make_branch C in
    let rec comp_tests = function
      [] ->
        zinc_error "compile_exp (cond)"
    | [a,exp] ->
        Ktest(test_for_atom a, staticfail) :: compexp exp C1
    | (a,exp)::rest ->
        let lbl = new_label() in
        Ktest(test_for_atom a, lbl) ::
        compexp exp (branch1 :: Klabel lbl :: comp_tests rest) in
    compexp arg (comp_tests casel)
```
**解释**：编译条件表达式`arg`。对每个分支，生成比较和跳转指令。
- **Lswitch**：
```ocaml
| (Lswitch(size, arg, casel)) C ->
    let branch1, C1 = make_branch C in
    if switch_through_jumptable size casel then
      let switchtable = vector size of staticfail in
      let rec comp_case = function
        [] ->
          zinc_error "compile_exp (comp_case)"
      | [ConstrRegular(i,_), exp] ->
          let lbl = new_label() in
          switchtable.(i) <- lbl;
          Klabel lbl :: compexp exp C1
      | (ConstrRegular(i,_), exp) :: rest ->
          let lbl = new_label() in
          switchtable.(i) <- lbl;
          Klabel lbl :: compexp exp (branch1 :: comp_case rest)
      in compexp arg (Kswitch switchtable :: comp_case casel)
    else
      let rec comp_tests = function
        [] ->
          zinc_error "compile_exp (switch)"
      | [tag,exp] ->
          Ktest(Pnoteqtag_test tag, staticfail) :: compexp exp C1
      | (tag,exp)::rest ->
          let lbl = new_label() in
          Ktest(Pnoteqtag_test tag, lbl) ::
          compexp exp (branch1 :: Klabel lbl :: comp_tests rest)
      in compexp arg (comp_tests casel)
```
**解释**：**处理少量标签的情况**：如果只有一个标签，直接编译对应的表达式。如果有两个标签，使用`if...then...else`结构。**处理多标签的情况**：**密集的匹配**：如果标签值密集，可以使用跳转表`Kswitch`。**稀疏的匹配**：如果标签值稀疏，使用一系列条件测试。**限制**：对于开放的代数数据类型，构造子的标签在编译时未知，无法使用跳转表。当大部分情况都落入默认分支（`Lstaticfail`）且非默认分支少于10个时，倾向于使用条件测试。
#### **辅助函数**

- **编译表达式列表compexplist**：
```ocaml
and compexplist = fun
  [] C -> C
| [exp] C -> compexp exp C
| (exp::rest) C -> compexplist rest (Kpush :: compexp exp C)
```
- **编译条件测试comp_test2**：
```ocaml
and comp_test2 cond ifso ifnot C =
  let branch1, C1 = make_branch C
  and lbl2 = new_label() in
  compexp cond (Kbranchifnot lbl2 ::
                compexp ifso (branch1 :: Klabel lbl2 :: compexp ifnot C1))
```
#### **处理函数体的编译**

- **问题**：在编译`Lfunction`时，无法立即编译函数体（抽象体），需要推迟编译。
- **解决方案**：**使用待编译队列**：定义一个栈`still_to_compile`，用于存储待编译的函数体。定义三个函数：
```ocaml
let reset_to_compile, add_to_compile, get_to_compile =
  let still_to_compile = ref ([] : (num & lambda & label) list) in
  (fun () -> still_to_compile := []; ()),
  (fun bc -> still_to_compile := bc :: !still_to_compile; ()),
  (fun () -> match !still_to_compile with
    [] -> failwith "finished"
  | bc::rest -> still_to_compile := rest; bc)
```
**reset_to_compile**：重置队列。**add_to_compile**：将函数体加入队列。**get_to_compile**：从队列中取出函数体进行编译。
- **编译完整的λ-表达式**：
```ocaml
let compile_lambda =
  let rec compile_rest C =
    try
      match get_to_compile() with
        (1,exp,lbl) ->
          compile_rest (Klabel lbl :: Kstartfun ::
                        compile_expr Nolabel exp (Kreturn :: C))
      | (n,exp,lbl) ->
          compile_rest (Klabel lbl :: Kstartfun ::
                        iterate (cons Kgrab) (n-1)
                        (compile_expr Nolabel exp (Kreturn :: C)))
    with failure "finished" ->
      C in
  fun expr ->
    reset_to_compile(); reset_label();
    (compile_expr Nolabel expr [Kbranch(Label 0)], compile_rest [])
```
**解释**：**编译主表达式**：首先编译主表达式`expr`。**编译函数体**：通过`compile_rest`函数，递归地编译待编译队列中的函数体。**结果**：返回两个代码列表：**主表达式的代码**：只执行一次，可以在执行后丢弃。**闭包的代码**：需要保留在内存中，以供闭包引用。
#### **将编译结果写入目标代码文件**

- **方法**：对于每个顶层短语，编译器将得到的两个代码列表写入目标代码文件。使用结构化数据输出的`extern`功能。**参考**：作者提到了相关的文献[62, chap. 9]和[1]，讨论了将`extern`功能集成到ML等静态类型语言中的问题。
**全面详尽的总结**

在本节中，作者详细阐述了ZINC编译器的后端实现，即如何将中间的λ-演算表达式转换为线性的ZAM代码列表。编译器的这一遍主要关注**顺序化**代码，尽量避免在转换过程中引入新的效率问题。

作者首先讨论了生成ZAM代码的两种方法，并选择了更高效的右到左单遍构建法。通过利用继续（continuation）信息，编译器能够识别尾调用位置，优化跳转指令，避免生成多余的代码。

接着，作者深入介绍了主要的编译函数`compile_expr`的实现细节，解释了如何处理各种λ-表达式构造，包括变量、常量、函数应用、函数定义、`let`绑定、原始操作、布尔操作、控制结构和异常处理等。特别地，作者强调了在编译过程中如何利用继续信息进行优化，例如尾调用优化、条件跳转优化和短路求值等。

在处理函数体的编译时，作者设计了一个待编译队列，推迟编译函数体，避免在编译其他代码时混杂。通过定义辅助函数，编译器能够在主表达式编译完成后，再递归地编译所有待编译的函数体。

最后，作者解释了如何将编译结果组织并写入目标代码文件。对于每个顶层短语，编译器生成两个代码列表，一个用于主表达式，另一个用于闭包。主表达式的代码只需要执行一次，可以在执行后丢弃，而闭包的代码需要保留在内存中，以供后续调用。

总体而言，本节深入探讨了编译器后端的实现细节，包括代码生成、优化策略和编译流程。通过详细的解释，读者可以理解编译器如何将高级的λ-演算表达式转换为可执行的指令序列，同时保持代码的高效性和正确性。这对于理解编译器的工作原理、代码生成和优化技术，以及函数式编程语言的实现具有重要的意义。
 #  
 Thought for 5 seconds
**概览**

本节选自《ZINC实验：ML语言的经济实现》（The ZINC Experiment: An Economical Implementation of the ML Language）的第5章，特别是第5.2.6节，标题为“全局环境”（Global environment）。作者在这一节中讨论了如何在ZINC编译器中处理全局声明和全局环境。

主要内容包括：

- **全局环境的结构**：讨论了全局环境的组成部分，包括全局变量、构造子和类型三种独立的命名空间，以及它们的表示方式。
- **全局符号表的实现**：介绍了如何使用哈希表来存储和查找全局符号，以提高符号表查找的效率。
- **模块的描述**：讨论了模块的表示方式，以及模块之间的相互引用和全局环境的维护。
- **全局引用的解析**：解释了如何在编译过程中解析全局引用，处理可能的名称冲突和模块命名空间的问题。
通过这一节的学习，我们可以了解编译器如何管理和维护全局环境，以及在处理全局声明和引用时需要考虑的关键问题。

**详细解释**

### **全局环境的处理**

在编译器中，全局环境用于存储和管理全局声明，如全局变量、构造子和类型。全局环境的设计对于编译器正确解析和处理全局引用至关重要。

#### **全局环境的命名空间**

全局环境包含三个独立的命名空间：

1. **全局变量（“值”）**：用于存储全局定义的变量或函数。
2. **构造子**：用于存储数据类型的构造子，例如代数数据类型的构造函数。
3. **类型**：用于存储类型定义。
这些命名空间是独立的，意味着同一个名字可以在不同的命名空间中表示不同的实体。例如，`List`可以是一个类型名，也可以是一个构造子名。

#### **全局标识符的结构**

为了准确地识别和区分全局标识符，编译器使用**完全限定名（fully qualified name）**，包括：

- **定义模块的名称（modname）**：标识符所属的模块名。
- **模块内的名称（name）**：标识符在模块内部的名称。
同时，每个全局标识符还关联了与其相关的描述信息。

定义一个通用的全局标识符结构：

```ocaml
type 'a global = {
  modname : string;  (* 定义模块的名称 *)
  name : string;     (* 模块内的名称 *)
  desc : 'a          (* 关联的描述信息 *)
}
```

#### **全局变量的描述**

对于全局变量，需要存储以下信息：

- **类型（valtype）**：变量的类型表达式。
- **是否为原始操作（prim）**：标识符是否是一个原始操作，如果是，记录其对应的原始操作和参数个数。
定义全局变量的描述类型：

```ocaml
type value_global = value_desc global

and value_desc = {
  valtype: type_expr;   (* 变量的类型表达式 *)
  prim: prim_desc       (* 原始操作描述 *)
}

and prim_desc =
  | ValueNotPrim                   (* 非原始操作 *)
  | ValuePrim of num * primitive   (* 原始操作，包含参数个数和原始操作 *)
```

#### **构造子的描述**

对于构造子，需要存储以下信息：

- **所属的具体类型（result_type）**：构造子所属的具体类型表达式。
- **参数类型列表（arg_types）**：构造子的参数类型列表，每个参数包含一个布尔值表示是否可变（mutable），以及类型表达式。
- **构造子的标签（tag）**：用于在运行时标识构造子，通常是一个整数。
- **纯度标志（pure）**：指示构造子是否是“纯”的，即所有参数都是不可变的。这在常量传播和优化时有用。
定义构造子的描述类型：

```ocaml
type constr_global = constr_desc global

and constr_desc = {
  result_type: type_expr;                 (* 构造子所属的类型 *)
  arg_types : (bool * type_expr) list;    (* 参数类型列表，包含是否可变和类型 *)
  tag : constr_tag;                       (* 构造子的标签 *)
  pure : bool                             (* 构造子是否是“纯”的 *)
}
```

#### **类型的描述**

对于类型，需要存储以下信息：

- **类型的元数（arity）**：类型的参数个数（对于多态类型）。
- **构造子列表（constrs）**：类型的构造子描述列表。
定义类型的描述类型：

```ocaml
type type_global = type_desc global

and type_desc = {
  arity : num;                (* 类型的元数，即类型参数的个数 *)
  constrs: constr_desc list   (* 构造子描述列表 *)
}
```

#### **符号表的实现**

为了提高全局符号表的查找效率，编译器使用了哈希表来存储全局标识符的描述。哈希表的键是标识符的名称，值是对应的描述信息。

```ocaml
(* 定义哈希表类型 *)
type ('a, 'b) hashtable

(* 模块的描述 *)
type module_desc = {
  name : string;                              (* 模块名称 *)
  values : (string, value_desc) hashtable;    (* 全局变量哈希表 *)
  constrs : (string, constr_desc) hashtable;  (* 构造子哈希表 *)
  types : (string, type_desc) hashtable       (* 类型哈希表 *)
}
```

#### **哈希表的实现细节**

哈希表的实现采用了动态哈希，并使用了通用的（多态的）哈希函数。这种哈希表在桶过长时会动态增加大小，但不会重新哈希整个表，从而保证了平均访问时间与表中元素数量的对数成正比。

#### **全局环境的结构**

全局环境包含当前正在编译的模块，以及当前“打开”的模块列表。这些模块在解析非限定的全局名称时会被搜索。

```ocaml
(* 全局环境 *)
type global_environment = {
  defined_module: module_desc;            (* 当前正在编译的模块 *)
  mutable opened_modules: module_desc     (* 当前打开的模块列表 *)
}
```

#### **全局引用的解析**

在编译过程中，当遇到全局引用（如变量、构造子或类型）时，需要解析该引用，以获取其描述信息。全局引用可能是完全限定名（包含模块名）或非限定名。

定义全局引用的类型：

```ocaml
type global_reference =
  | GRname of string                   (* 非限定名，如 "x" *)
  | GRmodname of string * string       (* 完全限定名，如 "Module.x" *)
```

编译器在以下阶段执行全局表查找：

- **解析阶段（parsing）**：对于构造子和类型标识符，在解析阶段进行全局表查找。
- **类型检查阶段（typechecking）**：对于值标识符（变量和函数），在类型检查阶段进行全局表查找。
查找到的描述信息会直接放入语法树中，以便后续的编译步骤使用。

#### **查找全局描述的函数**

编译器定义了以下函数，用于查找全局变量、构造子和类型的描述：

```ocaml
let find_value_desc, find_constr_desc, find_type_desc =
  let find_desc extract =
    let find_with_name (md : module) s =
      let desc = find_in_hashtable (extract md) s in
      { modname = md.name; name = s; desc = desc }
    in
    function
    | GRname s ->
        let gl = current_globalenv() in
        try
          find_with_name gl.defined_module s
        with failure "find" ->
          find_rec gl.used_modules where rec find_rec = function
            | [] -> failwith "find"
            | [md] -> find_with_name md s
            | md::rest ->
                try find_with_name md s
                with failure "find" -> find_rec rest
    | GRmodname(modname, s) ->
        let gl = current_globalenv() in
        if modname = gl.defined_module.name then
          find_with_name gl.defined_module s
        else
          find_rec gl.used_modules where rec find_rec = function
            | [] -> failwith "find"
            | md::rest ->
                if md.name = modname then
                  try find_with_name md s
                  with failure "find" -> find_rec rest
                else
                  find_rec rest
  in
  find_desc (fun x -> x.values),     (* 查找全局变量描述 *)
  find_desc (fun x -> x.constrs),    (* 查找构造子描述 *)
  find_desc (fun x -> x.types)       (* 查找类型描述 *)
```

##### **函数解释**

- **find_desc**：一个高阶函数，接受一个提取函数`extract`，用于从模块描述中提取相应的哈希表（如`values`、`constrs`或`types`）。
- **find_with_name**：在给定的模块`md`中，查找名称为`s`的描述信息。
- **GRname s的处理**（非限定名）：**首先**，在当前定义的模块`gl.defined_module`中查找名称`s`。**如果未找到**，在当前打开的模块列表`gl.used_modules`中依次查找。
- **GRmodname(modname, s)的处理**（完全限定名）：**如果模块名modname等于当前定义的模块名**，在`gl.defined_module`中查找名称`s`。**否则**，在当前打开的模块列表`gl.used_modules`中查找模块名为`modname`的模块，并在其中查找名称`s`。
**全面详尽的总结**

本节详细介绍了ZINC编译器中全局环境的设计和实现，主要内容包括：

1. **全局环境的结构**：全局环境包含三个独立的命名空间，分别用于存储全局变量、构造子和类型。每个全局标识符都具有完全限定名，包括模块名和在模块内的名称。
2. **全局符号表的实现**：为了提高查找效率，编译器使用了哈希表来存储全局标识符的描述信息。这些哈希表使用动态哈希，并利用了通用的多态哈希函数。
3. **模块的描述**：模块被表示为包含名称和相应哈希表的结构体。模块之间可以相互引用，编译器通过维护一个当前打开的模块列表来处理模块之间的依赖。
4. **全局引用的解析**：编译器在解析和类型检查阶段需要解析全局引用。全局引用可以是非限定名或完全限定名。编译器提供了函数`find_value_desc`、`find_constr_desc`和`find_type_desc`来查找全局变量、构造子和类型的描述。
5. **处理名称冲突和命名空间**：当遇到非限定名时，编译器首先在当前定义的模块中查找，如果未找到，再在打开的模块列表中查找。这种机制允许程序员使用简洁的非限定名，同时提供了模块化和命名空间的支持。
通过这一节的学习，我们了解到编译器如何管理全局环境，以及在处理全局声明和引用时需要考虑的关键问题。全局环境的设计对于编译器的正确性和效率至关重要，它影响了符号表的查找、名称解析、模块之间的依赖关系等多个方面。

本节还展示了如何在编译器中使用高级的编程技巧，如高阶函数、哈希表、多态等。这些技巧有助于编写高效、可维护的编译器代码，对于理解编译器的实现细节具有重要的参考价值。
 #  
 Thought for 10 seconds
**概览**

本段内容选自《ZINC实验：ML语言的经济实现》（The ZINC Experiment: An Economical Implementation of the ML Language）的第6章，标题为“链接器和运行时系统”（The linker and the runtime system）。作者在这一章详细介绍了ZINC的剩余两个重要组成部分：

1. **运行时系统**：负责执行字节码，由C语言编写。
2. **链接器**：将编译器生成的目标代码文件链接在一起，生成可执行的字节码，由ML编写。
主要内容包括：

- **6.1 节：完整的指令集（The complete instruction set）**作者给出了字节码解释器的精确指令集，详细说明了每条指令的操作码、操作数及其格式。
- **6.2 节：链接器（The linker）**作者描述了链接器的功能，包括它如何将编译器生成的对象代码转换为可执行的字节码，以及它执行的各种转换。
**详细解释**

### **6.1 完整的指令集**

在这一节中，作者详细列出了ZINC字节码解释器的指令集，包括每条指令的操作码和操作数的格式。为了更好地理解这些指令，需要先了解一些基本概念。

#### **指令表示法**

- **操作码（opcode）**：指令的名称，例如Grab，在字节码中占用一个字节，在线程化代码中占用两个或四个字节。
- **操作数（operands）**：位于操作码之后，按照给定的顺序存储。
#### **操作数类型**

以下是操作数的类型及其说明：

- **n**：一个小整数，通常表示操作码的大小。
- **ofs（offset）**：用于相对跳转的偏移量，相对于存储它的地址，使用两个字节。
- **tag**：块（block）的标签，占用一个字节。
- **header**：一个格式良好的块头部，占用四个字节。
- **int8**：一个小的整数常量，占用一个字节。
- **int16**：一个中等大小的整数常量，占用两个字节。
- **int32**：一个大的整数常量，占用四个字节。
- **float**：一个浮点数，根据硬件不同，占用四、八或十个字节。
- **string**：一个字符字符串，存储方式与堆中的字符串相同（参见第4.3.1节）。
#### **注意事项**

- **字节码格式的依赖性**：可执行字节码的格式取决于所使用的解释方法（字节码或线程化代码），也取决于主机机器。例如，整数和浮点常量使用主机机器的格式，特别是要注意处理器的字节序（大端或小端）。
- **对齐约束**：某些处理器可能对操作数有对齐要求，例如16位的操作数可能需要对齐到16位边界。这需要通过在字节码中插入Nop（无操作）指令来实现必要的填充。
#### **指令集分类**

下面，我们按照功能对指令集进行分类，并详细解释每条指令。

##### **1. 常量和字面量（Constants and literals）**

- **Constbyte(int8)**：将一个8位整数常量放入累加器。
- **Constshort(int16)**：将一个16位整数常量放入累加器。
- **Constlong(int32)**：将一个32位整数常量放入累加器。`Constlong`可以加载任何常量，只要它不是堆中的指针。
- **Atom(n)**：将指向标签为`n`的零大小块（zero-sized block）的指针放入累加器。
- **Atom0 到 Atom9**：快速访问标签为0到9的零大小块。
- **GetGlobal(int16)**：从全局变量编号为`int16`的槽中加载值到累加器。
- **SetGlobal(int16)**：将累加器中的值存储到全局变量编号为`int16`的槽中。
##### **2. 函数处理（Function handling）**

- **Push**：将累加器中的值压入参数堆栈。
- **Pushmark**：在参数堆栈上压入一个标记（mark）。
- **Apply**：调用累加器中包含的闭包。
- **Appterm**：跳转到累加器中包含的闭包，用于尾调用优化。
- **Return**：如果参数堆栈顶部是一个标记（mark），则弹出它并返回到调用者。否则，跳转到累加器中包含的闭包。
- **Grab**：从参数堆栈中弹出一个值，并将其放入环境中。如果堆栈顶部是一个标记（mark），则构建一个闭包并将其返回给调用者。
- **Cur(ofs)**：构建一个以当前环境为环境、偏移量为ofs的闭包，并将其放入累加器。
##### **3. 环境处理（Environment handling）**

- **Access(n)**：从环境中获取第`n`个槽位的值，并将其放入累加器。
- **Access0 到 Access5**：快速访问环境中的前6个槽位。
- **Let**：将累加器中的值放入环境的前面。
- **Endlet(n)**：从环境中丢弃前`n`个局部变量。
- **Endlet1**：快速丢弃环境中的第一个局部变量。
- **Dummies(n)**：在环境的前面放置`n`个虚拟闭包（dummy closures）。
- **Update(n)**：用累加器中的值物理更新环境中第`n`个槽位的值。
- **Letrec1(ofs)**：相当于依次执行：`Dummies(1)`、`Closure(ofs)`、`Update(0)`。这是一个非常常见的序列，对应于`let rec f = function ... in ...`。
##### **4. 构建和解构块（Building and destructuring blocks）**

- **Makeblock(header)**：分配一个具有给定头部`header`的块。初始化字段0为累加器中的值，其余字段从参数堆栈中获取值。
- **Makeblock1(tag) 到 Makeblock4(tag)**：快速构建包含1到4个字段的块，标签为tag。
- **Getfield(n)**：访问累加器所指向的块的第`n`个字段，并将其放入累加器。
- **Getfield0 到 Getfield3**：快速访问前4个字段。
- **Setfield(n)**：从参数堆栈中弹出一个值，物理替换累加器所指向的块的第n个字段的值。
- **Setfield0 到 Setfield3**：快速替换前4个字段的值。
##### **5. 整数运算（Integers）**

- **SuccInt**：整数加1。
- **PredInt**：整数减1。
- **NegInt**：整数取负。
- **AddInt**：整数加法。
- **SubInt**：整数减法。
- **MulInt**：整数乘法。
- **DivInt**：整数除法。
- **ModInt**：整数取模。
- **AndInt**：整数按位与。
- **OrInt**：整数按位或。
- **XorInt**：整数按位异或。
- **ShiftLeftInt**：整数左移。
- **ShiftRightInt**：整数右移。
##### **6. 浮点数运算（Floating-point numbers）**

- **Floatop(n)**：为一个浮点结果分配空间。执行子指令`n`，例如`AddFloat`、`SubFloat`、`MulFloat`、`DivFloat`以及常见的超越函数。
- **FloatOfInt**：将整数转换为浮点数。
- **IntOfFloat**：将浮点数截断为整数。
##### **7. 字符串处理（Strings）**

- **Makestring**：分配一个长度为累加器中值的字符串。
- **StringLength**：获取累加器中字符串的长度。
- **GetChar**：读取字符串中的一个字符。
- **SetChar**：修改字符串中的一个字符。
- **FillString**：用给定字符填充子字符串。
- **BlitString**：将一个子字符串复制到另一个子字符串。
##### **8. 断言（Predicates）**

- **Boolnot**：取反操作。如果累加器中的块标签为`0`，则返回“true”（标签为`1`的零大小块）。否则，返回“false”（标签为`0`的零大小块）。
- **Eq**：指针相等性判断。
- **Equal**：结构相等性判断。
- **EqInt** 到 **GeInt**：整数的比较操作。
- **EqFloat** 到 **GeFloat**：浮点数的比较操作。
- **EqString** 到 **GeString**：字符串的比较操作。
##### **9. 跳转和条件跳转（Branches and conditional branches）**

- **Branch(ofs)**：无条件相对跳转，跳转偏移量为`ofs`。
- **Branchif(ofs)**：条件跳转。如果累加器所指向的块的标签`t ≠ 0`，则跳转。
- **Branchifnot(ofs)**：条件跳转。如果累加器所指向的块的标签`t = 0`，则跳转。
- **Branchifeqtag(tag, ofs)**：条件跳转。如果累加器所指向的块的标签`t = tag`，则跳转。
- **Branchifneqtag(tag, ofs)**：条件跳转。如果累加器所指向的块的标签`t ≠ tag`，则跳转。
- **Switch(ofs0, ..., ofsk)**：根据累加器中块的标签`t`，跳转到偏移量`ofst`。实现多路分支。
- **BranchifEq(ofs)** 到 **BranchifGeString(ofs)**：对应于上述断言的条件跳转指令。
- **BranchifNeqImmInt(int32, ofs)**：将累加器中的值与给定的32位整数常量比较。如果不相等，则跳转。
- **BranchifNeqImmFloat(float, ofs)**：将累加器中的值与给定的浮点数常量比较。如果不相等，则跳转。
- **BranchifNeqImmString(string, ofs)**：将累加器中的值与给定的字符串常量比较。如果不相等，则跳转。
##### **10. 杂项（Miscellaneous）**

- **CCall0(n)** 到 **CCall5(n)**：调用一个C函数，参数个数从0到5。C函数存储在一个特殊的表中，`n`是所需函数的编号。第一个参数是累加器中的值，其余参数从参数堆栈中弹出。结果存储在累加器中。
- **StartFun**：执行各种检查，例如堆栈溢出、挂起的中断等。旨在插入到每个函数和循环体的开头。
- **Nop1**，**Nop2**，**Nop3**：不执行任何操作，但分别跳过1、2和3个字节。用于将代码对齐到16位或32位边界。
### **6.2 链接器**

在这一节中，作者介绍了链接器的功能和工作原理。链接器将编译器生成的目标代码文件（对象代码）链接在一起，生成可由运行时系统直接执行的字节码文件。

#### **链接器的功能**

链接器执行以下转换：

1. **指令列表的转换**：
- 将编译器生成的ML表示的指令列表（参见5.1.4节中的instruction类型）转换为操作码和操作数的流，格式如6.1节所述。
2. **标签和引用的替换**：
- 使用经典的单遍算法，将标签和对标签的引用替换为偏移量（offset），对于前向引用使用回填（backpatching）。
3. **全局变量的处理**：
- 全局变量在编译时仍然表示为其限定名（qualified name）。
- 链接器为每个全局变量分配一个在可执行文件数据空间中的槽位（slot）。
- 代码中对全局变量的引用由其槽位的地址表示。
- 为结构化常量也保留了槽位，因为垃圾收集器不允许它们直接放在代码中。
4. **可扩展和类型的构造子的标签分配**：
- 对于属于可扩展和（extensible sums，如异常）的构造子，分配一个标签号（tag number）。
- 由于两个模块可以独立地扩展同一类型，因此在编译时无法完成标签分配。
5. **常量的格式转换**：
- 将常量转换为主机处理器期望的格式（例如，整数的大小端格式）。
- 如果主机需要操作数对齐到16位或32位边界，则插入`Nop`指令来实现对齐。
6. **初始化代码的链接**：
- 通过Branch指令将每个短语（phrase）的初始化代码序列链接在一起。
#### **可执行文件的格式**

链接器生成的可执行文件的格式如下：

1. **头部**：
- 这是一个字符串，例如`#!/usr/local/zinc/runtime/interp`。
- 对于Unix用户来说，这个格式允许直接执行字节码文件，运行时系统会被作为解释器。
2. **全局变量的数量**：
- 一个整数，表示使用的全局变量的数量。
3. **已初始化的全局变量的值**：
- 一个序列，包含以下内容：一个整数（全局变量的槽位编号）。一个ZINC值（以前缀形式表示）。
- 整数`-1`表示这个列表的结束。
4. **字节码（或线程化代码）**：
- 可以直接执行的代码。
- 入口点在偏移量`0`处。
**全面详尽的总结**

在本章中，作者详细介绍了ZINC的运行时系统和链接器的设计和实现。

- **6.1 完整的指令集**：作者提供了ZINC字节码解释器的完整指令集，包括每条指令的操作码、操作数类型和含义。指令集涵盖了常量加载、函数调用、环境管理、块的构建和解构、整数和浮点数运算、字符串处理、断言、跳转和条件跳转等各个方面。特别强调了操作数的存储格式需要适应主机机器的特性，例如字节序和对齐要求。
- **6.2 链接器**：链接器将编译器生成的对象代码文件链接在一起，生成可执行的字节码文件。链接器执行了一系列转换，包括指令列表的转换、标签替换、全局变量的槽位分配、可扩展类型构造子的标签分配、常量格式的转换和初始化代码的链接。可执行文件的格式被精心设计，以便直接在Unix系统上执行，利用了Unix的脚本执行机制。
通过本章的学习，我们了解了ZINC系统如何将高级的ML代码通过编译、链接，最终生成可执行的字节码，并在运行时系统中执行。这一过程涉及了编译器、链接器和运行时系统的紧密协作。

- **指令集的设计**：指令集的设计既要考虑表达语言的高级特性，又要兼顾在运行时的执行效率。对常用操作提供了快速指令（如`Access0`到`Access5`），对块操作、整数和浮点数运算等提供了丰富的指令支持。
- **链接器的作用**：链接器在编译器和运行时系统之间起到了桥梁作用。它负责将编译器生成的中间代码转换为可执行的字节码格式，处理全局变量、标签和常量等问题。
- **运行时系统的执行**：运行时系统以解释器的方式执行字节码。由于指令集的精心设计，运行时系统能够高效地执行各种语言构造。
总的来说，本章为我们提供了一个完整的视角，了解了编译器、链接器和运行时系统如何协同工作，将高级的ML程序转换为可执行的代码，并在运行时执行。这对于理解编程语言的实现原理、编译和执行机制，以及运行时系统的设计都有着重要的意义。
 #  
 Thought for 31 seconds
**概览**

本节选自《ZINC实验：ML语言的经济实现》（The ZINC Experiment: An Economical Implementation of the ML Language）的第6章，特别是第6.3节，标题为“运行时系统”（The runtime system）。作者在这一节中详细介绍了ZINC运行时系统的组成部分，包括加载器、解释器、垃圾收集器和原始函数。

主要内容包括：

- **6.3.1 加载器（The loader）**：负责读取可执行文件，分配和初始化全局变量表，并将字节码加载到内存中。
- **6.3.2 解释器（The interpreter）**：执行字节码或线程化代码。在字节码的情况下，解释器是一个大型的C函数。
- **6.3.3 垃圾收集器（The garbage collector）**：使用了一种先进的垃圾收集算法，结合了“标记-清除”和“停止-复制”算法，并实现了代际收集机制。
- **6.3.4 原始函数（Primitive functions）**：包括整数和字符串的实用函数，以及与操作系统的接口函数。
**详细解释**

### **6.3 运行时系统**

运行时系统（Runtime System）是ZINC的重要组成部分，负责在实际运行时执行字节码程序。它主要由C语言编写，除了可选的线程化代码解释器是用汇编语言编写的。运行时系统包括以下部分：

#### **6.3.1 加载器（The loader）**

加载器的职责是：

- 读取可执行文件。
- 分配和初始化全局变量表。
- 将字节码加载到内存中。
加载器的实现非常简单，只有大约100行代码。这是因为链接器已经完成了大部分复杂的工作，如地址解析、全局变量的分配等。

#### **6.3.2 解释器（The interpreter）**

解释器负责执行字节码或线程化代码。

- **字节码的情况**：解释器是一个大型的C函数，约800行代码。**原因**：ZAM（ZINC抽象机）的寄存器必须是局部变量，以便编译器将它们放入实际的CPU寄存器中，提高执行效率。
- **线程化代码的情况**：解释器用汇编语言编写。
下面是字节码解释器的部分代码，包括开头和结尾部分：

```c
void interprete(prog)
code prog;
{
    register code pc;
    register value * asp;       /* 参数堆栈指针（argument-stack pointer） */
    register value * rsp;       /* 返回堆栈指针（return-stack pointer） */
    register value * alloc_ptr; /* 堆内存分配指针 */
    register int cache_size;    /* 易失环境中的值的数量 */
    register value env;         /* 持久环境 */
    register value accu;        /* 累加器 */
    register value tmp;         /* 用于存储未初始化的分配对象 */

    /* 初始化寄存器 */
    asp = extern_asp;
    rsp = extern_rsp;
    alloc_ptr = extern_alloc_ptr;
    pc = prog;
    env = null_env;
    cache_size = 0;
    accu = MLINT(0); /* 将累加器初始化为整数0 */

    while(1) switch(*pc++){ /* 进入主循环，逐个解释指令 */
        case CONSTBYTE:
            accu = (value) *(char *) pc; /* 从pc指向的位置读取一个字符，转换为value类型，存入累加器 */
            pc += 1;                     /* pc前进1个字节 */
            break;
        case CONSTSHORT: /* 处理较小的整数 */
            accu = (value) *(short *) pc; /* 读取2字节的整数 */
            pc += 2;
            break;
        case CONSTLONG: /* 处理任意大小的整数 */
            accu = (value) *(long *) pc; /* 读取4字节的整数 */
            pc += 4;
            break;
        case PUSH:
            *--asp = accu; /* 将累加器的值压入参数堆栈 */
            break;
        case POP:
            accu = *asp++; /* 从参数堆栈弹出值，存入累加器 */
            break;
        /* 省略了大量代码 */
    }
}
```

**解释**：

- **interprete函数**：这是字节码解释器的主函数。
- **寄存器声明**：`pc`：程序计数器，指向当前执行的指令。`asp`：参数堆栈指针，管理函数调用的参数。`rsp`：返回堆栈指针，管理函数返回地址。`alloc_ptr`：堆内存分配指针，用于在堆中分配内存。`cache_size`：易失环境（volatile environment）中的值的数量。`env`：持久环境（persistent environment），存储闭包的环境。`accu`：累加器，主要的计算寄存器。`tmp`：临时变量，用于存储未初始化的分配对象。
- **初始化**：将全局变量（如`extern_asp`）的值赋给局部寄存器。
- **主循环**：使用`while(1) switch(*pc++)`构造，不断读取指令并执行。
- **指令处理**：`CONSTBYTE`：从字节码中读取一个字节，作为整数常量，存入累加器。`CONSTSHORT`：读取两个字节的整数常量。`CONSTLONG`：读取四个字节的整数常量。`PUSH`：将累加器的值压入参数堆栈。`POP`：从参数堆栈弹出值，存入累加器。
- **注释**：省略了大量其他指令的处理，以避免冗长。
**与外部交互**：

- **垃圾收集器的交互**：ZAM的寄存器需要被垃圾收集器识别，以找到根（roots）。由于这些寄存器是`interprete`函数的局部变量，在调用垃圾收集器之前，需要将它们保存到全局变量或全局可访问的区域。**堆和堆栈指针**：保存到全局变量。**累加器**：压入参数堆栈。**环境和cache_size**：压入返回堆栈。在垃圾收集后，需要重新加载这些寄存器，因为垃圾收集器可能已经移动了堆中的一些对象。
**示例：堆内存分配宏**

下面是用于在堆中分配内存的宏`ALLOC`：

```c
#define ALLOC(hdr, size) \
{ \
    tmp = VALUE(alloc_ptr); /* 将当前的分配指针转换为value类型，存入tmp */ \
    alloc_ptr += (size);    /* 更新分配指针 */ \
    if (alloc_ptr > young_end) { /* 如果超出了年轻代的末尾 */ \
        rsp -= sizeof(struct return_frame) / sizeof(value); /* 调整返回堆栈指针 */ \
        ((struct return_frame *) rsp)->env = env;          /* 保存环境到返回帧 */ \
        ((struct return_frame *) rsp)->cache_size = cache_size; /* 保存cache_size */ \
        *--asp = accu;    /* 将累加器的值压入参数堆栈 */ \
        extern_asp = asp; \
        extern_rsp = rsp; \
        extern_alloc_ptr = alloc_ptr - (size); /* 恢复alloc_ptr */ \
        tmp = call_minor_gc (size); /* 调用小型垃圾收集器，传入所需的大小 */ \
        alloc_ptr = extern_alloc_ptr; /* 更新alloc_ptr */ \
        accu = *asp++;  /* 从参数堆栈恢复累加器的值 */ \
        env = ((struct return_frame *) rsp)->env; /* 从返回帧恢复环境 */ \
        rsp += sizeof(struct return_frame) / sizeof(value); /* 恢复返回堆栈指针 */ \
    } \
    HEADER(tmp) = (hdr); /* 设置新分配对象的头部 */ \
}
```

**解释**：

- **目的**：在堆中分配大小为`size`的新对象，并设置其头部为`hdr`。
- **步骤**：**分配内存**：`tmp = VALUE(alloc_ptr);`：将当前的分配指针转换为`value`类型，存入`tmp`。`alloc_ptr += (size);`：更新分配指针，预留`size`大小的空间。**检查是否需要垃圾收集**：if (alloc_ptr > young_end)：如果超出了年轻代（young generation）的末尾，说明需要进行垃圾收集。**保存运行时状态**：`rsp`和`asp`：调整返回堆栈和参数堆栈指针，保存当前的`env`和`cache_size`。`extern_asp`，`extern_rsp`，`extern_alloc_ptr`：保存全局状态。**调用垃圾收集器**：tmp = call_minor_gc (size);：调用小型垃圾收集器，申请size大小的空间。**恢复运行时状态**：alloc_ptr，accu，env，rsp：从全局或堆栈中恢复运行时寄存器的值。**设置新对象的头部**：HEADER(tmp) = (hdr);：设置新分配对象的头部。
#### **线程化代码的解释器**

在线程化代码的情况下，解释器用汇编语言编写。

- **原因**：C语言无法直接实现间接跳转（indirect jump），只能进行间接调用（indirect call）。作者没有找到能够将尾部间接调用转换为间接跳转的C编译器。
- **示例**：以下是部分68020汇编代码的解释器实现：
```assembly
retsp = a7   /* 返回堆栈指针，使用寄存器a7 */
argsp = a5   /* 参数堆栈指针，使用寄存器a5 */
hp = a4      /* 堆指针，使用寄存器a4 */
mypc = a3    /* 程序计数器，使用寄存器a3 */
env = a2     /* 环境指针，使用寄存器a2 */
accu = a1    /* 累加器，使用寄存器a1 */
csize = d7   /* cache_size，使用数据寄存器d7 */
base = d6    /* 基址，使用数据寄存器d6 */

CONSTSHORT:
    movw mypc@+, accu      /* 从程序计数器指向的位置读取一个字（2字节），存入累加器 */
    movw mypc@+, a0        /* 读取下一条指令的地址，存入a0 */
    jmp a0@(base:l)        /* 跳转到a0加上基址指向的地址 */

CONSTLONG:
    movl mypc@+, accu      /* 从程序计数器读取一个长字（4字节），存入累加器 */
    movw mypc@+, a0        /* 读取下一条指令的地址 */
    jmp a0@(base:l)        /* 跳转 */

PUSH:
    movl accu, argsp@-     /* 将累加器的值压入参数堆栈 */
    movw mypc@+, a0        /* 读取下一条指令的地址 */
    jmp a0@(base:l)        /* 跳转 */

POP:
    movl argsp@+, accu     /* 从参数堆栈弹出值，存入累加器 */
    movw mypc@+, a0        /* 读取下一条指令的地址 */
    jmp a0@(base:l)        /* 跳转 */
```

**解释**：

- **寄存器分配**：指定了各个寄存器的用途，以提高执行效率。
- **指令实现**：**CONSTSHORT**：`movw mypc@+, accu`：从`mypc`指向的地址读取2字节数据，存入`accu`，`mypc`自增2。`movw mypc@+, a0`：读取下一条指令的地址，存入`a0`。`jmp a0@(base:l)`：跳转到`a0`加上`base`偏移量指向的地址。**CONSTLONG**：类似于CONSTSHORT，但读取4字节数据。**PUSH**：`movl accu, argsp@-`：将`accu`的值压入参数堆栈，`argsp`递减。其余步骤同上。**POP**：movl argsp@+, accu：从参数堆栈弹出值，存入accu，argsp递增。
#### **6.3.3 垃圾收集器（The garbage collector）**

ZINC使用了由Damien Doligez编写的高级垃圾收集器。

- **基础算法**：基于Lang和Dupont算法，统一和泛化了“标记-清除”（mark and sweep）和“停止-复制”（stop and copy）算法。
- **堆的分区**：**from-space**：源空间，存放需要处理的对象。**to-space**：目标空间，复制活跃对象到这里。**mark-space**：标记空间，标记正在使用的对象。
- **工作原理**：垃圾收集器遍历内存图。将`from-space`中的块复制到`to-space`。在`mark-space`中标记正在使用的块。最后，对`mark-space`进行清扫，收集未使用的块。
- **优势**：通过调整空间的大小，可以在“标记-清除”和“停止-复制”之间进行灵活的组合。可以享受复制式收集器的压缩特性，而不会像纯粹的“停止-复制”那样将堆占用限制在50%。
**代际收集机制**：

- **年轻代（young generation）**：对象首先分配在一个小的、独立的空间，即年轻代。当年轻代空间满了时，进行**小型垃圾收集（minor collection）**。识别并复制年轻代中的活跃对象到大型的主堆（老年代）。小型垃圾收集速度很快，能够回收大量空间，因为大多数对象都是短生命周期的。
- **老年代（old generation）**：主堆，存放生命周期较长的对象。**大型垃圾收集（major collection）**：对主堆进行垃圾收集。由于小型垃圾收集的存在，减少了大型垃圾收集的频率。
**实现细节**：

- 实现较为复杂，需要处理诸如在小型垃圾收集过程中启动大型垃圾收集，然后在大型垃圾收集完成后恢复小型垃圾收集等情况。
- 垃圾收集器和内存分配器共约1200行C代码。
#### **6.3.4 原始函数（Primitive functions）**

运行时系统的剩余部分由原始函数组成。

- **实用函数**：一些关于整数和字符串的实用函数，用C语言实现以提高效率。计划引入Vuillemin等人的任意精度整数运算包。
- **操作系统接口**：主要是与操作系统交互的接口函数。这些是简单的存根代码（stub code），用于在ZINC和C表示之间转换数据。理想情况下，应根据函数的类型自动生成。
**示例**：

```c
value unix_open(path, mode, rights)
value path, mode, rights;
{
    return MLINT(open(CSTRING(path), CINT(mode), CINT(rights)));
}
```

**解释**：

- **函数unix_open**：封装了Unix系统调用`open`，在ZINC环境中使用。
- **参数类型**：value path, mode, rights;：参数均为value类型，ZINC中的通用类型。
- **实现步骤**：`CSTRING(path)`：将ZINC的字符串类型转换为C语言的字符串。`CINT(mode)`：将ZINC的整数类型转换为C语言的整数。`open(...)`：调用C的`open`系统调用。`MLINT(...)`：将C的整数返回值转换为ZINC的整数类型。
- **作用**：实现ZINC和C之间的数据类型转换，提供对操作系统功能的访问。
**全面详尽的总结**

本节详细介绍了ZINC运行时系统的各个组成部分，解释了其设计原理和实现细节。

- **加载器（6.3.1）**：负责读取可执行文件，初始化全局变量表，将字节码加载到内存中。由于链接器已经完成了大部分工作，加载器的实现相对简单。
- **解释器（6.3.2）**：核心是一个大型的C函数，执行字节码。解释器需要高效地管理ZAM的寄存器，并与垃圾收集器进行协调。在处理线程化代码时，由于C语言的限制，使用汇编语言编写以实现高效的间接跳转。
- **垃圾收集器（6.3.3）**：采用了先进的垃圾收集算法，结合了“标记-清除”和“停止-复制”算法，并实现了代际收集机制。通过区分年轻代和老年代，提高了垃圾收集的效率，减少了程序暂停的时间。
- **原始函数（6.3.4）**：包括一些实用函数和操作系统接口函数。为了提高效率，这些函数用C语言实现，并负责在ZINC和C的表示之间进行数据转换。
通过对这些内容的详细解释，我们了解到ZINC运行时系统的设计目标是实现一个高效、可移植的ML语言运行环境。运行时系统的各个部分紧密协作，支持了ZINC语言的各种特性，如函数式编程、垃圾收集、异常处理等。同时，运行时系统还需要与底层操作系统进行交互，为程序提供系统级功能。

本节还强调了实现运行时系统时需要考虑的实际问题，例如语言和编译器的限制（如C语言无法直接实现间接跳转）、垃圾收集器的复杂性，以及与操作系统的接口等。这些细节对于理解编程语言实现和运行时系统设计具有重要的参考价值。
 #  
 Thought for 1m 16s
**概览**

本段内容选自《ZINC实验：ML语言的经济实现》（The ZINC Experiment: An Economical Implementation of the ML Language）的第7章，标题为“评估”（Assessment），以及附录A，标题为“基准测试”（Benchmarks）。作者在第7章中对ZINC系统进行了整体评估，讨论了项目的进展、实现细节、性能表现以及是否达到了最初的目标。附录A提供了关于ZINC与其他ML实现的性能比较，展示了ZINC在各种基准测试中的表现。

**详细解释**

### **第7章 评估**

在撰写本报告时，ZINC系统的以下部分已经可以运行：

1. **编译器和链接器**：都是用CAML语言编写的。
- **编译器的现状**：尚未实现类型检查（typing）。模块之间的一致性检查（consistency checks）也未实现。错误报告功能几乎不存在。
- **链接器的现状**：可以链接编译器生成的目标代码文件。
2. **运行时系统**：用C语言编写，包含以下组件：
- **字节码解释器**：执行编译器生成的字节码。
- **内存分配器**：管理内存的分配。
- **垃圾收集器**：回收不再使用的内存。
- **一些原始操作（primitives）**：提供基本的函数和操作。
此外，作者还编写了一个**线程化代码（threaded-code）解释器**和一个**68020汇编代码的翻译器**，但它们尚未与垃圾收集器集成。系统的原始操作和库函数几乎不存在，除了少量的Unix系统调用和一个小型的I/O库。

尽管如此，这些部分已经能够协同工作，不仅可以运行简单的程序。例如，作者成功地运行了一个中等规模（500行）的例子，直接取自CAML的文集（[25]）：Knuth-Bendix完备化过程的实现（见附录A）。作者还没有尝试让编译器和链接器自举（bootstrap），但他对编译器自我编译的能力充满信心；目前的瓶颈在于缺乏库和工具，例如解析器生成器。

#### **开发过程**

- **开发时间**：花了大约三个月的时间使系统能够运行上述程序。
- **主要工作**：**字节码解释器**：编写和调试字节码解释器以及它与垃圾收集器的接口占用了大部分时间。**编译器**：花费的时间相对较少，错误也较少；尤其是核心功能（表达式的编译器，包括模式匹配的展开）在最初就编写完成，之后几乎没有改变。
- **初始版本的设计缺陷**：**缺乏真正的模块系统**：最初的版本只有简单的独立编译（separate compilation）。**链接方式**：链接是在执行前即时完成的（on the fly），而不是独立的链接步骤。
- **改进**：额外花了两周时间实现了**独立的链接器**和**模块系统**。
#### **性能评估**

关于性能，特别是执行速度，通常认为**字节码解释**非常慢，因此作者并不期望有很好的结果。然而，ZINC的表现比预期要好，尤其是在非平凡的程序上。

- **基准测试**：在附录A中提供了一些数字。
- **总结**：**简单基准测试**：在诸如斐波那契函数这样的简单基准上，ZINC的速度比CAML慢三到四倍（包括垃圾收集时间）。**实际程序**：在Knuth-Bendix完备化过程这样的实际程序上，ZINC的字节码版本比CAML略快。**原因**：部分归因于CAML的垃圾收集器效率低下。**进一步分析**：即使不考虑垃圾收集时间，ZINC的线程化代码版本与CAML一样快，比被认为是当前最快的ML实现——Standard ML of New Jersey（SML-NJ）——仅慢50%。
- **意外的结果**：这是相当出乎意料的，因为CAML和SML-NJ生成的是本机机器码，而ZINC需要处理解释的开销。这表明了ZAM（ZINC抽象机）的“复杂”（baroque）机制（例如对多重应用的特殊处理、环境的缓存）在大型程序中确实有效。这也表明了CAML和SML-NJ的编译器相当“幼稚”（naive），或者更准确地说，它们所执行的复杂转换并没有带来很大的收益，而且它们没有解决真正的性能瓶颈。**类似结论**：Pierre Weis的元编译器（[61]）能够生成比CAML编译器更高效的ML编译器。
#### **关于字节码解释的实施难度**

另一个常见的说法是字节码解释的实现非常容易，但这也是错误的。与机器码生成相比，字节码解释引入了一个额外的错误来源：

- **错误定位的复杂性**：当一段汇编代码崩溃时，我们可以确定是编译器的问题。但在字节码解释的情况下，错误可能在解释器中。
- **调试的复杂性**：首先，需要编写一个字节码的反汇编器，以便读取编译器的输出。其次，由于字节码指令的语义可能会发生变化，因此很难一眼看出错误。最后，动态调试（例如在某些字节码指令上设置断点）需要在字节码解释器中添加断点和跟踪功能，或者在解释器程序本身上设置断点，尝试猜测字节码程序在做什么。这几乎像是使用示波器连接到机器的总线来调试程序一样不方便。
#### **ZINC是否达到了初始目标**

1. **获得一个小型、可移植的ML实现**：
- **ZINC的特点**：**体积小**：运行时系统大约占用100 KB。**编译后的程序非常紧凑**：得益于字节码的使用。**内存需求小**：得益于垃圾收集器的效率，程序可以在相对小的堆内存中运行。**可移植性强**：至少对于字节码版本来说，ZINC是完全可移植的。
- **但存在的问题**：ZINC很难被称为一个可用的ML实现。**证据**：它仍然需要CAML来运行其编译器和链接器！**阻碍自举的原因**：不是因为ZINC缺少语言构造（它实现了编译器中使用的所有构造）。而是缺少编译器的部分组件，例如词法分析器、解析器、类型检查器、调试器和交互式顶层环境。缺少一些库，例如输入/输出函数，以及许多原始操作。**解决方案**：这些都不难实现，使用已知的技术即可，但它们总共需要相当大量的（相对乏味的）工作。
2. **为ML的扩展提供测试平台**：
- **现状**：目前，ZINC实现了一个非常经典的ML，没有任何扩展。
- **潜力**：系统的简洁性肯定会使得扩展不太困难，但作者意识到整体设计可能没有预期的那么灵活，这可能使得某些扩展难以集成。
- **另一方面**：ZINC的实现本身探索了一些新技术。特别是，它质疑了“好的分析是静态分析”这一教条。ZINC证明了一些额外的运行时测试并不总是绝对有害，因为它们可以节省后续大量的计算。这是ZINC执行模型背后的主要思想，即使它导致了一个略显复杂的抽象机，它似乎在实践中比传统的抽象机效果更好。**主要问题**：这种方法需要对执行流程有完全的控制：ZAM在字节码解释中工作良好，但无法在现有硬件上高效映射，因为现有代码庞大且存在大量冗余。要超越字节码解释，需要对ZAM指令进行微代码化，以保持代码体积小，并利用复杂ZAM指令的多个步骤可以并行执行的优势。**然而**，可微编码的体系结构几乎不存在。
3. **学习如何实现ML**：
- 作者在设计和实现ZINC的过程中确实学到了很多东西。
- 这份报告是分享这些经验的尝试。
- 如果你觉得它有用，你应该感谢Gérard Huet，他促使作者写下了它；然而，所有的批评都应该针对作者本人。
### **附录A 基准测试**

#### **A.1 抽象机的简单基准测试**

这些初步的基准测试将ZINC机器与CAM（[20]中定义的）和某种形式的SECD（[37]）（更准确地说，是具有一个额外寄存器来保存环境的CAM）进行了比较。这里考虑了ZINC机器的三个变体，它们的区别仅在于环境的表示方式：

1. **线性列表（linear list）**。
2. **线性列表加缓存（linear list and a cache）**。
3. **向量加缓存（vector and a cache）**。
对于这五种机器的每一种，作者都用C语言编写了一个字节码解释器，并用CAML编写了一个简单的编译器。编译器和解释器都是以相同的风格编写的，因此可以希望比较是公平的。由于编译器无法编译多个表达式，因此作者不得不使用相当简单且众所周知的基准测试。

**测试的ML源代码如下**：

```ocaml
(* 斐波那契函数 *)
let rec fib = fun n -> if n < 2 then 1 else fib(n - 1) + fib(n - 2) in fib 26;;

(* Tak函数 *)
let rec tak = fun x -> fun y -> fun z ->
  if x > y then tak (tak (x - 1) y z) (tak (y - 1) z x) (tak (z - 1) x y)
  else z
in tak 18 12 6;;

(* 求和函数 *)
let rec sum = function [] -> 0 | a :: L -> a + sum L in
let rec interval = fun n -> if n = 0 then [] else n :: interval(n - 1) in
sum (interval 10000);;

(* 高阶函数的应用 *)
let double = fun f -> fun x -> f(f x) in
let quad = double double in
let oct = quad quad in
double oct (fun x -> x + 1) 1;;

(* 使用map函数的测试 *)
let rec interval = fun n -> if n = 0 then [] else n :: interval(n - 1) in
let double = fun f -> fun x -> f(f x) in
let quad = double double in
let succ = fun n -> n + 1 in
map (quad quad succ) (interval 1000);;
```

**解释**：

- **斐波那契函数**：测试函数调用（针对一个参数）的速度。
- **Tak函数**：高度递归，有三个参数；由于这里使用柯里化（curried），因此测试多重应用（multiple application）。
- **求和函数**：`sum (interval 10000)`测试递归调用和数据构建、解构的混合情况。
- **高阶函数的应用**：使用`double`函数测试函数值（例如部分应用的函数）的处理效果。
- **使用map函数的测试**：测试更复杂的函数式编程模式。
**基准测试结果**：

（见表A.1，简化版）

| 测试程序 | 执行时间（秒） | 堆内存使用（32位字） |
| ---- | ---- | ---- |
| **CAM** |  |  |
| fib 26 | 25.6 | 785,674 |
| tak 18 12 6 | 6.3 | 636,094 |
| sum (interval 10000) | 1.2 | 60,012 |
| map (quad quad succ) (interval 1000) | 13.4 | 1,030,088 |
| **SECD** |  |  |
| fib 26 | 19.1 | 785,674 |
| tak 18 12 6 | 5.1 | 636,094 |
| ... | ... | ... |
| **ZAM（无缓存）** |  |  |
| fib 26 | 21.7 | 785,674 |
| tak 18 12 6 | 4.6 | 381,658 |
| ... | ... | ... |
| **ZAM（缓存+列表）** |  |  |
| fib 26 | 24.0 | 4 |
| tak 18 12 6 | 4.9 | 4 |
| ... | ... | ... |
| **ZAM（缓存+向量）** |  |  |
| fib 26 | 23.3 | 4 |
| tak 18 12 6 | 4.6 | 4 |
| ... | ... | ... |
| **ZAM线程化代码（缓存+向量）** |  |  |
| fib 26 | 10.6 | 4 |
| tak 18 12 6 | 2.2 | 4 |
| ... | ... | ... |
| **CAML 40（版本2.6）** |  |  |
| fib 26 | 3.5 (+5.2) | 785,738 |
| tak 18 12 6 | 2.6 (+3.9) | 636,158 |
| ... | ... | ... |
| **SML-NJ（版本0.33）** |  |  |
| fib 26 | 2.0 | n/a |
| tak 18 12 6 | 1.0 | n/a |
| ... | ... | ... |
| **手写的C代码** |  |  |
| fib 26 | 1.4 | 0 |
| tak 18 12 6 | 0.2 | 0 |
| ... | ... | ... |

**说明**：

- **执行时间**：在Sun 3/60机器上测量。
- **堆内存使用**：以32位字为单位。
- **CAML的执行时间**：括号中的数字表示垃圾收集时间。
**分析**：

- **CAM和SECD的内存行为相同**：因为它们在每次函数调用时都分配一个对（pair）。**影响**：对于仅执行算术计算的函数（如`fib`），这非常糟糕。**即使对于主要进行结构构建的函数**（如`interval`和`sum`），仍然使用了比必要多三倍的堆内存（约60,000个字，而不是表示10,000元素列表所需的20,000个字）。
- **SECD比CAM快约25%**：因为额外的寄存器保存了当前环境，节省了大量的堆栈交换（CAM的`Swap`指令变得不必要）。
- **简单的ZINC机器（无缓存）**：**表现**：并没有真正的改进，除了在`tak`测试中，由于其有效的多重应用机制，节省了一些时间，并将堆使用量减少了一半；这对应于ZAM未构建的中间闭包。**执行时间**：介于CAM和SECD之间。
- **添加环境缓存后**：**堆分配大幅减少**：对于非函数式测试，堆使用量几乎是完成工作所需的最小值，例如`fib`和`fact`不需要堆内存，`sum(interval...)`需要20,000个字。**函数式测试**（如`map(quad quad succ)...`）仍然分配了约必要的两倍内存（20,000字中的40,000字），这是因为构建闭包需要将缓存刷新到堆中。**执行时间略有增加**：主要是由于环境访问的额外测试。**使用向量代替列表**：有助于将这种开销保持在可接受的范围内。
- **线程化代码解释**：比字节码解释快两倍。原因有两个：**指令解码更快**：只需一次间接跳转，而不是通过表的跳转。**解释例程直接用汇编语言编写**：因为C语言无法实现真正的间接跳转，作者能够编写比通常的C编译器更好的68020代码。
- **与其他实现的比较**：**CAML**：在原始执行时间上，比线程化ZAM代码快两到三倍，但其内存行为与原始CAM几乎相同，因此考虑垃圾收集时间后，并不比线程化ZAM代码快。**SML-NJ**：在这些简单测试中表现更好，给出的时间包括垃圾收集。**手写的C代码**：提供了一个参考点，展示了编译良好的语言在这些测试中的表现。
#### **A.2 ZINC的实际基准测试**

为了进行更实际的基准测试，作者使用了Knuth和Bendix的等式理论完备化过程的实现（[34]）。这个实现由Gérard Huet完成，原始的CAML源代码可以在[29]和[25]中找到。

- **特点**：一个简单但不完全幼稚的实现。以“经典ML”风格编写（无副作用，大量使用函数式编程）。代表了ML用于原型设计和教学的典型用法。
- **代码适应性**：原始代码需要非常少的修改即可在ZINC上运行。**唯一的不兼容性**：原始代码依赖于CAML解析`(a, b, c)`为`(a, (b, c))`，而在ZINC中，前者是三元组，后者是对。通过添加一些额外的括号立即解决了这个问题。为了方便，作者还将程序分成了六个小模块。
- **基准测试**：**内容**：对群的公理进行完备化。**运行环境**：在Sun 3/280上运行，使用以下实现：ZINC，使用C编写的字节码解释器。ZINC，使用68020汇编语言编写的线程化代码解释器。ZINC，生成68020本机代码的翻译器。CAML版本2.6。使用与ZINC相同的高效垃圾收集器和新的运行时系统的实验性CAML版本。Standard ML of New Jersey（SML-NJ）版本0.33。
- **结果**（见表A.2）：系统时间大小ZINC，字节码解释器29.0秒5.4 KBZINC，线程化代码解释器15.5秒8.2 KBZINC，扩展为68020本机代码9.7秒31.7 KBCAML 40（版本2.6）36.6秒（15.4秒 + GC 21.2秒）11.7 KBCAML（新运行时）14.7秒n/aSML-NJ（版本0.33）10.5秒n/a
**分析**：

- **解释执行的效率**：与生成机器码相比，解释执行表现相当好。扩展到68020汇编语言仅比线程化代码解释快三分之一。从字节码解释到线程化代码解释几乎与从字节码解释到生成本机代码一样高效。**原因**：在线程化代码解释器的情况下，执行指令的例程是手写的汇编代码，与扩展器生成的汇编代码一样高效。解释开销被降到最低。然而，解释器仍然花费了37%的时间来获取和解码下一条指令（字节码情况下为10.7秒，线程化代码情况下为5.6秒）。
- **与成熟实现的比较**：像ZINC这样的玩具实现与CAML和SML-NJ等成熟实现相比，表现相当不错。即使是可移植的、字节码解释的ZINC版本也比CAML快。**主要原因**：CAML的垃圾收集器效率低下。使用与ZINC相同的垃圾收集器的新运行时，将执行时间减少了一半。线程化代码解释器几乎与CAML一样快，比SML-NJ仅慢三分之一，而SML-NJ被认为是目前最快的ML实现之一。
- **结论**：这些结果相当出乎意料，鉴于初步基准测试的结果。它们表明了ZAM的特殊机制（如有效的多重应用、环境缓存等）在非平凡的程序中确实有效。
- **进一步的分析**：作者对字节码解释器进行了广泛的性能分析。**指令频率和执行时间总结**（见表A.3，简化版）：指令执行次数执行时间（秒）Access01,449,4973.1Push1,427,4453.7Getfield1792,5832.3.........**多重应用机制的有效性**：`Grab`指令几乎从未失败：在345,581次执行中，只有43次遇到了空的参数堆栈，需要构建闭包。这表明柯里化函数的部分应用很少发生。相应地，`Return`指令不返回给调用者，而是将结果应用于下一个剩余参数的情况并不少见（193,431次中的78,315次，即约40%）。**环境缓存的效果**：将环境的堆分配减少了四倍。在测试期间存储在环境中的1,237,285个字中，只有410,450个需要被复制回堆。对环境的访问具有69.8%的缓存命中率。活跃缓存的平均大小（即在返回堆栈中的那些）在2到3个字之间。**内存行为**：在堆中分配了1,178,465个字（不包括头部）。其中，35.3%用于数据结构，36.5%用于持久环境，剩下的28.2%是闭包。相比之下，CAML为运行此基准测试分配了2,027,906个conses（cons单元），即超过400万个字，其中只有8.3%用于数据结构。**主要性能瓶颈**：来自对局部函数定义的处理。每次构建闭包是缓存刷新的主要来源。
**全面详尽的总结**

在本节和附录中，作者对ZINC系统进行了全面的评估，重点讨论了以下内容：

1. **项目进展**：ZINC已经具备了基本的编译器、链接器和运行时系统，但尚未完全成熟，缺乏类型检查、错误报告和丰富的库。
2. **开发经验**：作者分享了开发过程中的经验，指出字节码解释器的实现并不如预期那样容易，调试也更加复杂。
3. **性能评估**：
- **初步基准测试**：通过与CAM和SECD等抽象机的比较，展示了ZINC在简单基准测试中的性能。**环境缓存的作用**：显著减少了堆内存的分配，改善了内存行为。**线程化代码解释器**：显著提高了执行速度。
- **实际基准测试**：使用Knuth-Bendix完备化过程的实现，对ZINC、CAML和SML-NJ进行了比较。**结果**：ZINC的字节码版本比CAML快，线程化代码版本几乎与CAML一样快，比SML-NJ仅慢三分之一。**分析**：ZINC的特殊机制（如多重应用处理、环境缓存）在非平凡程序中确实有效。
4. **实现目标的评估**：
- **小型、可移植的ML实现**：ZINC达到了体积小、可移植性强的目标，但尚未成为一个可用的ML实现，需要完善编译器、链接器和库。
- **为ML扩展提供测试平台**：ZINC的简洁性使其具有扩展的潜力，但设计可能不够灵活，集成某些扩展可能具有挑战性。
- **学习ML的实现方法**：作者在设计和实现ZINC的过程中学到了很多，并试图通过这份报告分享经验。
总的来说，作者对ZINC的评估表明，尽管存在一些局限性和改进空间，ZINC在性能和实现技术方面都取得了令人满意的结果。特别是，它挑战了关于字节码解释效率低下和实现容易的常见看法，展示了通过精心设计的抽象机和执行模型，可以实现高效的ML解释器。同时，作者也认识到，要将ZINC发展为一个可用的ML实现，还需要投入更多的工作完善其功能和工具链。
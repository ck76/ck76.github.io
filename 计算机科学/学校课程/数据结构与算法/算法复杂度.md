[TOC]

算法复杂度分为时间复杂度和空间复杂度。其作用：时间复杂度是指执行这个算法所需要的计算工作量；而空间复杂度是指执行这个算法所需要的内存空间。**时间和空间（即寄存器）都是计算机资源的重要体现，而算法的复杂性就是体现在运行该算法时的计算机所需的资源多少。** 

Ο(1)表示基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，其时间复杂度就是Ο(1)。其中**Ο(logn)、Ο(n)、 Ο(nlogn)、Ο(n^2)和Ο(n^3)**称为多项式时间，**而Ο(2^n)和Ο(n!)称为指数时间**。计算机科学家普遍认为前者（即多项式时间复杂度的算法）是有效算法，把这类问题称为**P（Polynomial,多项式）类问题**，而把后者（即指数时间复杂度的算法）称为**NP（Non-Deterministic Polynomial, 非确定多项式）问题**。 

# 时间复杂度

1：算法的时间复杂度反映了程序执行时间随输入规模增长而增长的量级，在很大程度上能很好地反映出算法的优劣与否；

2：算法执行时间需要依据该算法编制的程序在计算机上执行运行时所消耗的时间来度量，度量方法有两种，事后统计方法和事前分析估算方法，因为事后统计方法更多的依赖计算机的硬件，软件等环境因素，有时容易掩盖算法本身的优劣。因此常常采用事前分析估算的方法；

3：一个算法是由控制结构（顺序，分支，循环三种）和原操作（固有数据类型的操作）构成的，而算法时间取决于两者的综合效率；

4：一个算法花费的时间与算法中语句的执行次数成正比，执行次数越多，花费的时间就越多。一个算法中的执行次数称为语句频度或时间频度。记为T（n）；

5：在时间频度中，n称为问题的规模，当n不断变化时，它所呈现出来的规律，我们称之为时间复杂度（其实在这中间引入了一个辅助函数f（n），但它与t（n）是同数量级函数，我们且先这样理解。）

6：在各种算法中，若算法中的语句执行次数为一个常数，则时间复杂度为o（1）；同时，若不同算法的时间频度不一样，但他们的时间复杂度却可能是一样的，eg：T(n)=n^2+2n+4  与 T（n）=4n^2+n+8，他们的时间频度显然不一样，但他们的时间复杂度却是一样的，均为O(n^2)，时间复杂度只关注最高数量级，且与之系数也没有关系。

7： 求解算法的时间复杂度的具体步骤是：
　　⑴ 找出算法中的基本语句；
　　算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。
　　⑵ 计算基本语句的执行次数的数量级；
　　只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。
　　⑶ 用大Ο记号表示算法的时间性能。
　　将基本语句执行次数的数量级放入大Ο记号中。
　　如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，则将并列循环的时间复杂度相加   

对于时间复杂度的计算：（一般的时间复杂度，分治法时间复杂度，递归）

一般的：

1）一般情况下，对步进[循环语句只需考虑循环体中语句的执行次数，忽略该语句中步长加1、终值判别、控制转移等成分。

2）当有若干个循环语句时，[算法]的[时间复杂度]是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的

**下面分别对几个常见的时间复杂度进行示例说明：**==n2都是n^2==

### **(1)、O(1)**

```java
        Temp=i; i=j; j=temp;                    
```

以上三条单个语句的频度均为1，该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作T(n)=O(1)。**注意：如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。**

### **(2)、O($n^2$)**

2.1. 交换i和j的内容

```java
sum=0；                 （1次）  
for(i=1;i<=n;i++)       （n次）  
   for(j=1;j<=n;j++)    （n2次）  
    sum++；             （n2次）  
```

解：**因为Θ(2n^2+n+1)=n2^（Θ即：去低阶项，去掉常数项，去掉高阶项的常参得到），所以T(n)= =O(n^2)；**

2.2.   

```java
for (i=1;i<n;i++)  
 {   
     y=y+1;         ①     
     for (j=0;j<=(2*n);j++)      
        x++;         ②        
 }        
```

解： 语句1的频度是n-1
          语句2的频度是(n-1)*(2n+1)=2**n^2**-n-1
          f(n)=2**n^2**-n-1+(n-1)=2**n^2**-2；

​        又**Θ(2n^2-2)=n^2**
​          该程序的时间复杂度T(n)=O(**n^2**).  

　　==一般情况下，对步进循环语句只需考虑循环体中语句的执行次数，忽略该语句中步长加1、终值判别、控制转移等成分，当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的。==     

### **(3)、O(n)**                                                              

```java
a=0;  
  b=1;                      ①  
  for (i=1;i<=n;i++) ②  
  {    
     s=a+b;　　　　③  
     b=a;　　　　　④    
     a=s;　　　　　⑤  
  } 
```



解： 语句1的频度：2,        
           语句2的频度： n,        
          语句3的频度： n-1,        
          语句4的频度：n-1,    
          语句5的频度：n-1,                                  
          T(n)=2+n+3(n-1)=4n-1=O(n).

### **(4)、O($logn$)**

```java
i=1;     ①  
while (i<=n)  
  i=i*2; ②  
```



解： 语句1的频度是1,  
          设语句2的频度是f(n),   则：2^f(n)<=n;f(n)<=**logn**    
          取最大值f(n)=**logn**,
          T(n)=O(**logn** )

### **(5)、O($n^3$)** 

```java
for(i=0;i<n;i++)  
   {    
      for(j=0;j<i;j++)    
      {  
         for(k=0;k<j;k++)  
            x=x+2;    
      }  
   }  
```



解：当i=m, j=k的时候,内层循环的次数为k当i=m时, j 可以取 0,1,...,m-1 , 所以这里最内循环共进行了0+1+...+m-1=(m-1)m/2次所以,i从0取到n, 则循环共进行了: 0+(1-1)*1/2+...+(n-1)n/2=n(n+1)(n-1)/6所以时间复杂度为O(**n^3**).

**（5）常用的算法的时间复杂度和空间复杂度**



**一个经验规则：**其中c是一个常量，如果一个算法的复杂度为 n、 logn 、n^2 、 nlogn ,那么这个算法时间效率比较高 ，如果是2^n ,3^n ,n!，那么稍微大一些的n就会令这个算法不能动了，居于中间的几个则差强人意。

​       算法时间复杂度分析是一个很重要的问题，任何一个程序员都应该熟练掌握其概念和基本方法，而且要善于从数学层面上探寻其本质，才能准确理解其内涵。

# 空间复杂

  类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。渐近空间复杂度也常常简称为空间复杂度。
空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。一个算法在计算机存储器上所占用的存储空间，**==包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面==**。算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。算法在运行过程中临时占用的存储空间随算法的不同而异，有的算法只需要占用少量的临时工作单元，而且不随问题规模的大小而改变，我们称这种算法是“就地\"进行的，是节省存储的算法，如这一节介绍过的几个算法都是如此；有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如将在第九章介绍的快速排序和归并排序算法就属于这种情况。

如当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)；当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为0(10g2n)；当一个算法的空I司复杂度与n成线性比例关系时，可表示为0(n).若形参为数组，则只需要为它分配一个存储由实参传送来的一个地址指针的空间，即一个机器字长空间；若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便由系统自动引用实参变量。

1：空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度；

2：一个算法在计算机上占用的内存包括：程序代码所占用的空间，输入输出数据所占用的空间，辅助变量所占用的空间这三个方面，程序代码所占用的空间取决于算法本身的长短，输入输出数据所占用的空间取决于要解决的问题，是通过参数表调用函数传递而来，只有辅助变量是算法运行过程中临时占用的存储空间，与空间复杂度相关；

3：通常来说，只要算法不涉及到动态分配的空间，以及递归、栈所需的空间，空间复杂度通常为0(1)；

4： 对于一个算法，其时间复杂度和空间复杂度往往是相互影响的。当追求一个较好的时间复杂度时，可能会使空间复杂度的性能变差，即可能导致占用较多的存储空间；反之，求一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。另外，算法的所有性能之间都存在着或多或少的相互影响。因此，当设计一个算法(特别是大型算法)时，要综合考虑算法的各项性能，算法的使用频率，算法处理的数据量的大小，算法描述语言的特性，算法运行的机器系统环境等各方面因素，才能够设计出比较好的算法。



# 常见排序算法的复杂度

| 排序算法   | 最差时间分析 | 平均时间复杂度 | 稳定度 | 空间复杂度    |
| ---------- | ------------ | -------------- | ------ | ------------- |
| 冒泡排序   | O($n^2$)     | O($n^2$)     | 稳定   | O(1)          |
| 快速排序   | O($n^2$)     | O($nlog^n$) | 不稳定 | O($log^n$)~O(n) |
| 选择排序   | O($n^2$)        | O$n^2$)    | 稳定   | O(1)          |
| 二叉树排序 | O($n^2$)       | O($nlog^n$) | 不一顶 | O(n)          |
| 插入排序   | O($n^2$)       | O($n^2$)  | 稳定   | O(1)          |
| 堆排序     | O($nlog^n$) | O($nlog^n$) | 不稳定 | O(1)          |
| 希尔排序   | O            | O              | 不稳定 | O(1)          |

# 常见查找算法复杂度

| 算法                 | 查找    | 插入    |
| -------------------- | ------- | ------- |
| 顺序查找             | N/2     | N       |
| 二分查找             | lgN     | N/2     |
| 二叉查找树           | 1.39lgN | 1.39lgN |
| 红黑树               | 1.00lgN | 1.00lgN |
| Hash查找（拉链法）   | N/2M    | N/M     |
| Hash查找（线性探测） | <1.5    | <2.5    |

| 查找                 | 平均时间复杂度 | 查找条件               | 算法描述                                                     |
| -------------------- | -------------- | ---------------------- | ------------------------------------------------------------ |
| 顺序查找             | O(n)           | 无序或有序队列         | 按顺序比较每个元素，直到找到关键字为止                       |
| 二分查找（折半查找） | O(logn)        | 有序数组               | 查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。　如果在某一步骤数组为空，则代表找不到。 |
| 二叉排序树查找       | O(logn)        | 二叉排序树             | 在二叉查找树b中查找x的过程为：1. 若b是空树，则搜索失败2. 若x等于b的根节点的数据域之值，则查找成功；3. 若x小于b的根节点的数据域之值，则搜索左子树4. 查找右子树。 |
| 哈希表法（散列表）   | O(1)           | 先创建哈希表（散列表） | 根据键值方式(Key value)进行查找，通过散列函数，定位数据元素。 |
| 分块查找             | O(logn)        | 无序或有序队列         | 将n个数据元素"按块有序"划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须"按块有序"；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……。然后使用二分查找及顺序查找。 |
[TOC]

#### sleep()

```
-Thread.sleep(long millis)
-Thread.sleep(long millis, int nanos)
-TimeUnit.MILLISECONDS.sleep(long millis);
    Thread类的静态方法，强制当前线程休息睡眠若干时间,让其他线程可以有执行的机会，当睡眠时间到了，线程则返回到可执行状态下。
    但是当前线程并不释放对象锁，故如果是在synchronized方法中，其他线程仍然不能访问共享数据。
    sleep()方法可以使低优先级的线程有执行的机会，如果没有sleep()方法，那么只有等高优先级的线程执行完才执行较低优先级的线程(没有synchronized限制)。
    sleep()方法中指定的时间是线程不会运行的最短时间，时间结束之后，线程是返回到可运行的状态，而不是运行状态。所以，sleep()不保证线程在睡眠之后就开始执行。
```

#### yield()

```
-Thread.yield()
    Thread类的静态方法，让当前运行线程回到可运行状态，和sleep()类似，但是使用yield()的目的是为了使同等优先级的线程有执行的机会，而实际中让步的线程还有可能被线程调度程序再次选中。
```

#### synchronized

- 实现单例模式的时候该关键字锁住的是对象。

```
    java关键字，它用来修饰一个方法或者代码块的时候，意味着当前只能有一个线程执行该方法或者代码块。该关键字用于保护共享数据，所以要分清哪些数据是共享数据。每个对象都有一个锁标志，当一个线程访问到该对象，被synchronized修饰的数据将被"上锁"，阻止其他线程访问。当前线程访问完这部分数据后释放锁标志，其他线程就可以访问了。
    当两个并发的线程对同一个对象中的synchronized(this)方法或者代码块的时候，同一个时间内只能有一个线程得到执行，另一个线程必须等待前一个线程释放对象锁。
    当一个线程访问一个对象的synchronized方法时，另一个线程可以执行该对象的非synchronized方法或者代码块。
    当一个线程访问对象的synchronized(this)同步代码块时，其他线程对该对象中所有其它synchronized(this)同步代码块的访问将被阻塞。
```

#### wait()/notify()/notifyAll()

```
－java.lang.Object的方法
    这三个方法用于多线程对于共享数据的读取，所以必须在synchronized代码块中使用，synchronized关键字用于保护共享数据，阻止其他线程对于共享数据的读取，如何在当前线程没有退出synchronized代码块时让其他线程也有机会访问共享数据，可以使用这几个方法。
    wait()方法使当前线程暂停并释放对象锁，让其他线程可以进入synchronized代码块，当前线程被放入对象等待池。
    调用notify()方法后，将从对象的等待池移走一个任意的线程并放到锁标志等待池中，只有锁标志等待池中的线程能够获取锁标志，如果锁标记等待池中没有线程，那么notify()不起作用。
    notifyAll()则从对象等待池中移走所有等待那个对象的线程并放到锁标记等待池中。
```

#### join()

```
    Thread的非静态方法join()让一个线程A加入到另外一个线程B的尾部。在B执行完毕之前，A不能工作。
    join()方法还有带超时限制的重载版本。 例如t.join(5000);则让线程等待5000毫秒，如果超过这个时间，则停止等待，变为可运行状态。
    join()方法使调用该方法的线程在此之前执行完毕，也就是等待该方法的线程执行完毕后再往下继续执行。注意该方法也需要捕捉异常。
1234
```

#### run()/start()

```
    直接调用run方法和普通方法无异。线程的启动必须调用start()方法。
    把需要处理的代码放到run()方法中，start()方法启动线程将自动调用run()方法，这个由java的内存机制规定的。并且run()方法必需是public访问权限，返回值类型为void。
```

#### volatile

```
    java关键字，稍弱的同步机制，volatile变量，用来确保将变量的更新操作通知到其他线程。
    当变量被申明为volatile后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。
    volatile不会被缓存在寄存器或者其他处理器中，因此在读取volatile类型的变量时总会返回最新写入的值。
    加锁机制既可以确保可见性也可以确保原子性，而volatile变量只能保证可见性。
```



### 链接

- [引一篇多线程介绍，很详细](https://www.cnblogs.com/dolphin0520/p/3920373.html)
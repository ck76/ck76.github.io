> 从内核角度来讲，可以认为它并没有线程这个概念（其实并不是）。无论是我们所说的线程，还是进程，对于 Linux 而言，都属于 task，因此无论是进程还是线程，都拥有唯一属于自己的 task_struct 。实际上我们所谓的线程，更像是 task 这个概念，有的进程有一个task，就叫做单线程进程；有的进程有多个线程，就叫做多线程进程。



> 我们先看，进程是什么，或者说，我们感性里“认为”的进程，在 Linux 内核层面是什么样的过程呢？很容易理解的是，在静态的时候，程序是存储在磁盘上面的，进程是把程序的逻辑加载到内存的运行过程。我们需要把程序从磁盘读取到内存，通过操作寄存器，使用CPU执行程序，这个时候程序就变成了进程（进行中的程序）。一般而言，一个进程会拥有4G的虚拟内存，其中3G交付用户使用，1G用于存储内核相关的资源，而所谓的内核资源，就是前面提到的 task_struct 中的数据，这一部分资源呢，中文名字是进程控制块，也就是 PCB。



> 了解进程控制块都包含什么，只需要看一下 task_struct 的结构就好了。下面列举我们常见的一些概念在 task_struct 里面的对应。



> *long state; /\* 表示进程的状态 -1表示不可执行 0表示可执行 >0表示停止 \*/*
> *long counter; /\* 运行时间片 以jiffs递减计数 \*/*
> *long priority; /\* 运行优先数,开始时,counter = priority,值越大,表示优先数越高,等待时间越长. \*/*
> *long signal; /\* 信号.是一组位图,每一个bit代表一种信号. \*/*
> *struct sigaction sigaction[32]; /\* 信号响应的数据结构, 对应信号要执行的操作和标志信息 \*/*
> *long blocked; /\* 进程信号屏蔽码(对应信号位图) \*/*
> *int exit_code; /\* 任务执行停止的退出码 其父进程会取 \*/*
> *unsigned long start_code,end_code,end_data,brk,start_stack; /\* start_code代码段地址 end_code代码长度(byte),end_data 代码长度+数据长度(byte) brk总长度(byte) start_stack堆栈段地址 \*/*
> *long pid,father,pgrp,session,leader; /\* 进程号 父进程号 父进程组号 会话号 会话头(发起者)\*/*
> *unsigned short uid,euid,suid; /\* 用户id 号 有效用户 id 号 保存用户 id 号\*/*
> *unsigned short gid,egid,sgid; /\* 组标记号 (组id) 有效组 id 保存的组id \*/*
> *long alarm; /\* 报警定时值 (jiffs数) \*/*
> *long utime,stime,cutime,cstime,start_time; /\* 用户态运行时间 (jiffs数) 系统态运行时间 (jiffs数) 子进程 用户态运行时间 子进程系统态运行时间 进程开始运行时刻 \*/*
> *int tty; /\* 进程使用tty的子设备号 -1表示设有使用 \*/*
> *unsigned short umask; /\* 文件创建属性屏蔽位 \*/*
> *struct m_inode \* pwd; /\* 当前工作目录 i节点结构 \*/*
> *struct m_inode \* root; /\* 根目录i节点结构 \*/*
> *struct m_inode \* executable; /\* 执行文件i节点结构 \*/*
> *unsigned long close_on_exec; /\* 执行时关闭文件句柄位图标志 \*/*
> *struct file \* filp[NR_OPEN]; /\* 文件结构指针表 最多32项 表项号即是文件描述符的值 \*/*
> *struct desc_struct ldt[3]; /\* 任务局部描述符表 0-空 1-cs段,2-Ds和Ss段 \*/*
> *struct tss_struct tss; /\* 进程的任务状态段信息结构 \*/*



![img](https://pic2.zhimg.com/80/v2-4723f3a7c4616da3ba2db663d7949f21_hd.jpg)



> 进程创建的是通过 sys_fork 函数触发 0x80 中断实现的。如果看源码，会看到 sys_fork 中执行两个比较重要的函数： find_empty_process 和 copy_process 。前者负责为进程分配一个进程号，该值创建的依据是通过内核全局变量 last_pid 存放的最新进程 id，来指定新进程的进程号，这也是我们看到进程号随着进程的不断创建时循环趋势递增的原因。后者主要负责为新进程创建 task_struct ，并将父进程的 task_struct 复制给新进程，并更新一些新进程的 task_struct 的私有信息，之后，为新进程创建一个页表（通过调用 get_free_page 函数），同样，也需要把父进程的页表内容复制给新进程，接下来设置新进程共享父进程的文件，并设置新进程的全局描述符表（也就是 GDT） 的项目，例如内存基址等，这样才能加载代码、设置数据段基址、限长，也是复制页表的条件，最后把新进程设置为就绪态，就可以参与到进程的系统调度。



> 以上就是进程创建的过程，想必介绍到这里，你就了解了网络上介绍进程和线程区别的时候提到的页表、数据堆栈之类的概念都大概是什么，进程对于你也不应该再是一个“玄学”概念。



> 那么线程又是什么呢？实际上线程的概念最早出现在上世纪八十年代，远远早于 linux 的诞生。为什么要引入线程呢？我觉得可以思考一个问题，计算机为什么要有多个进程？是的，提升处理效率，使得用户可以在听音乐的同时写公众号文章。那为什么要有多个线程呢，也大概是这个原因，举个例子，在我用 office word 写文章的时候，跟踪光标输入的是一个线程，而语法纠错又会是另外一个线程。一个进程的多个线程会共享绝大部分该进程的数据资源，这也就是网络上所谓的“进程有独立的数据资源，线程几乎没有”的来源，实际上这句话有点误导，它会让你认为进程和线程是并列的两个概念，实际上线程从属于进程而已。



> 引入进程的原因，是因为同一个进程，内部可能存在多个不同的 task，这些 task 需要复用进程的数据，但是呢这些 task 操作的数据又有一定的独立性（或者可以通过锁实现安全修改），因此多个 task 并不需要按照时序执行，可以同时执行，因此就产生了线程的概念，线程的并行是随着多核处理器的产生而产生的，多个线程可以通过调度在不同的处理器核心上来实现并行处理。



> 可以这样讲，多进程实现了操作系统级别的并发，多线程实现了进程内部的并发。



> 在 linux 层面，线程的创建实际上是调用 clone 函数。我之所以最初说 linux 层面没有线程这个概念，是因为 linux 创建初期内核就一直不存在“线程”这回事，后来因为实际需求，产生了 LinuxThreads 这个项目。线程的创建“看起来”和进程的创建很像，所以你也能看到线程的 pid，区别在于父子进程会共享地址空间、文件系统资源、文件描述符、信号处理以及被阻断的信号等，这对于常规进程是不可能的事儿。因此说 linux 内核不存在线程的概念是有道理的，因为所谓的线程是一种特殊的进程，进程和线程是用户态的区分而不是内核态，内核处理线程的时候，会完全把它和进程当做相同的事物去处理。



> 这里解释一个问题，既然在 linux 内核眼中它们是相同事物，为什么 kill 掉线程的时候不会影响进程的运行，但是 kill 掉进程的时候也会消灭掉线程呢？这个可以参考 POSIX 标准：

- 查看进程列表的时候，相关的一组 task_struct 应当被展现为列表中的一个节点；
- 发送给这个”进程”的信号(对应 kill 系统调用)，将被对应的这一组 task_struct 所共享， 并且被其中的任意一个”线程”处理；
- 发送给某个”线程”的信号(对应 pthread_kill )，将只被对应的一个 task_struct 接收，并且由它自己来处理；
- 当”进程”被停止或继续时(对应 SIGSTOP/SIGCONT 信号)， 对应的这一组 task_struct 状态将改变；
- 当”进程”收到一个致命信号(比如由于段错误收到 SIGSEGV 信号)，对应的这一组 task_struct 将全部退出；



> 接下来介绍 linux 中三个著名的进程。



> idle_task 进程（pid=0，又称0号进程），是由操作系统自动创建，运行在内核态，它其实是操作系统创建的第一个进程，最初用于操作系统的加载，后来用于进程的调度管理。



> init_task（pid=1） 进程通过idle的内核线程创建，在内核空间完成初始化后，被释放在用户空间，它是操作系统一切用户进程的祖先进程。正如前面所说的 sys_fork 函数，一个用户进程的创建，实际上是从 init_task 进程 fork 出来的，除此之外，init_task 进程的任务就是守护监视其他进程。



> kthreadd_task 进程（pid=2）也是idle通过内核线程创建的，它和1号线程的区别是始终运行在内核空间，负责内核线程的调度和管理。



> 再介绍两个常见的进程类型的概念，孤儿进程和僵尸进程。



> 孤儿进程，指的是在父进程退出的时候，它的子进程（线程）因为各种原因还在运行，这种进程就被成为孤儿进程，孤儿进程会被init_task进程收养，由init_task代替退出的父进程对它们进行状态收集。



> 僵尸进程，则是指的那种被fork出来的子进程已经退出，但是父进程并没有调用 wait 函数或者 waitpid 函数获取子进程的状态信息，导致子进程的进程描述符仍然保存在操作系统中，这种实际上已经退出但是在操作系统上还能看到的进程就被称为僵尸进程。



> 这两种进程都涉及到进程退出的概念。进程如何退出呢，前面没有介绍。linux 中进程退出的机制是，进程接收到操作系统发出的退出信号，内核释放该进程的所有资源，包括内存和打开的文件，但仍然保存进程号和退出状态等信息，直到父进程通过 wait 或者 waitpid 函数来采集才会释放。联系到孤儿进程和僵尸进程，实际上孤儿进程对用户的可见性较低，因为孤儿进程会被init_task进程收养，init_task可以做到安全退出孤儿进程，僵尸进程则不然，它们会占用进程号等稀缺资源，当一个系统产生大量僵尸进程的时候，则无法创建新进程。

------
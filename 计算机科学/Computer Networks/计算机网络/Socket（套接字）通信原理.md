- https://www.cnblogs.com/myitnews/p/13790067.html
- https://segmentfault.com/a/1190000013712747



[toc]

### 一、Socket是什么

Socket 的中文翻译过来就是“套接字”。套接字是什么，我们先来看看它的英文含义：插座。

Socket 就像一个电话插座，负责连通两端的电话，进行点对点通信，让电话可以进行通信，端口就像插座上的孔，端口不能同时被其他进程占用。而我们建立连接就像把插头插在这个插座上，创建一个 Socket 实例开始监听后，这个电话插座就时刻监听着消息的传入，谁拨通我这个“IP 地址和端口”，我就接通谁。

实际上，Socket 是在应用层和传输层之间的一个抽象层，它把 TCP/IP 层复杂的操作抽象为几个简单的接口，供应用层调用实现进程在网络中的通信。Socket 起源于 UNIX，在 UNIX 一切皆文件的思想下，进程间通信就被冠名为`文件描述符（file descriptor）`，Socket 是一种“打开—读/写—关闭”模式的实现，服务器和客户端各自维护一个“文件”，在建立连接打开后，可以向文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。

另外我们经常说到的Socket 所在位置如下图：

![img](https://img2020.cnblogs.com/blog/660329/202010/660329-20201010094027768-397452978.png)

### 二、Socket有哪些类型

世界上有很多种套接字（socket），比如 DARPA Internet 地址（Internet 套接字）、本地节点的路径名（Unix套接字）、CCITT X.25地址（X.25 套接字）等。我们只介绍第一种套接字——Internet 套接字，它是最具代表性的，也是最经典最常用的。以后我们提及套接字，指的都是 Internet 套接字。

根据数据的传输方式，可以将 Internet 套接字分成两种类型。

##### 流格式套接字（SOCK_STREAM）

流格式套接字（Stream Sockets）也叫“面向连接的套接字”，是一种可靠的、双向的通信数据流，数据可以准确无误地到达另一台计算机，如果损坏或丢失，可以重新发送。

其特点：

- 数据在传输过程中不会消失；
- 数据是按照顺序传输的；
- 数据的发送和接收不是同步的（有的教程也称“不存在数据边界”）。

可以将 SOCK_STREAM 比喻成一条传送带，只要传送带本身没有问题（不会断网），就能保证数据不丢失；同时，较晚传送的数据不会先到达，较早传送的数据不会晚到达，这就保证了数据是按照顺序传递的。

为什么流格式套接字可以达到高质量的数据传输呢？这是因为它使用了 TCP 协议（The Transmission Control Protocol，传输控制协议），TCP 协议会控制你的数据按照顺序到达并且没有错误。

你也许见过 TCP，是因为你经常听说“TCP/IP”。TCP 用来确保数据的正确性，IP（Internet Protocol，网络协议）用来控制数据如何从源头到达目的地，也就是常说的“路由”。

那么，“数据的发送和接收不同步”该如何理解呢？

假设传送带传送的是水果，接收者需要凑齐 100 个后才能装袋，但是传送带可能把这 100 个水果分批传送，比如第一批传送 20 个，第二批传送 50 个，第三批传送 30 个。接收者不需要和传送带保持同步，只要根据自己的节奏来装袋即可，不用管传送带传送了几批，也不用每到一批就装袋一次，可以等到凑够了 100 个水果再装袋。

流格式套接字的内部有一个缓冲区（也就是字符数组），通过 socket 传输的数据将保存到这个缓冲区。接收端在收到数据后并不一定立即读取，只要数据不超过缓冲区的容量，接收端有可能在缓冲区被填满以后一次性地读取，也可能分成好几次读取。

也就是说，不管数据分几次传送过来，接收端只需要根据自己的要求读取，不用非得在数据到达时立即读取。传送端有自己的节奏，接收端也有自己的节奏，它们是不一致的。

流格式套接字有什么实际的应用场景吗？浏览器所使用的 http 协议就基于面向连接的套接字，因为必须要确保数据准确无误，否则加载的 HTML 将无法解析。

##### 数据报格式套接字（SOCK_DGRAM）

数据报格式套接字（Datagram Sockets）也叫“无连接的套接字”。计算机只管传输数据，不作数据校验，如果数据在传输中损坏，或者没有到达另一台计算机，是没有办法补救的。也就是说，数据错了就错了，无法重传。

因为数据报套接字所做的校验工作少，所以在传输效率方面比流格式套接字要高。

有以下特征：

- 强调快速传输而非传输顺序；
- 传输的数据可能丢失也可能损毁；
- 限制每次传输的数据大小；
- 数据的发送和接收是同步的

众所周知，速度是快递行业的生命。用摩托车发往同一地点的两件包裹无需保证顺序，只要以最快的速度交给客户就行。这种方式存在损坏或丢失的风险，而且包裹大小有一定限制。因此，想要传递大量包裹，就得分配发送。

另外，用两辆摩托车分别发送两件包裹，那么接收者也需要分两次接收，所以“数据的发送和接收是同步的”；换句话说，接收次数应该和发送次数相同。

总之，数据报套接字是一种不可靠的、不按顺序传递的、以追求速度为目的的套接字。

数据报套接字也使用 IP 协议作路由，但是它不使用 TCP 协议，而是使用 UDP 协议（User Datagram Protocol，用户数据报协议）。

QQ 视频聊天和语音聊天就使用 SOCK_DGRAM 来传输数据，因为首先要保证通信的效率，尽量减小延迟，而数据的正确性是次要的，即使丢失很小的一部分数据，视频和音频也可以正常解析，最多出现噪点或杂音，不会对通信质量有实质的影响。

注意：SOCK_DGRAM 没有想象中的糟糕，不会频繁的丢失数据，数据错误只是小概率事件。

### 三、Socket通信过程

Socket 保证了不同计算机之间的通信，也就是网络通信。对于网站，通信模型是服务器与客户端之间的通信。两端都建立了一个 Socket 对象，然后通过 Socket 对象对数据进行传输。通常服务器处于一个无限循环，等待客户端的连接。

下面是面向连接的 TCP 时序图：

![img](https://img2020.cnblogs.com/blog/660329/202010/660329-20201010094439156-1397820811.png)

##### 客户端过程

客户端的过程比较简单，创建 Socket，连接服务器，将 Socket 与远程主机连接（注意：只有 TCP 才有“连接”的概念，一些 Socket 比如 UDP、ICMP 和 ARP 没有“连接”的概念），发送数据，读取响应数据，直到数据交换完毕，关闭连接，结束 TCP 对话。

```
import socket
import sys

if __name__ == '__main__':
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # 创建 Socket 连接
    sock.connect(('127.0.0.1', 8001))  # 连接服务器
    while True:
        data = input('Please input data:')
        if not data:
            break
        try:
            sock.sendall(data)
        except socket.error as e:
            print('Send Failed...', e)
            sys.exit(0)
        print('Send Successfully')

        res = sock.recv(4096)  # 获取服务器返回的数据，还可以用 recvfrom()、recv_into() 等
        print(res)
    sock.close()
```

sock.sendall(data)
这里也可用 send() 方法：不同在于 sendall() 在返回前会尝试发送所有数据，并且成功时返回 None，而 send() 则返回发送的字节数量，失败时都抛出异常。

##### 服务端过程

服务端先初始化 Socket，建立流式套接字，与本机地址及端口进行绑定，然后通知 TCP，准备好接收连接，调用 `accept()` 阻塞，等待来自客户端的连接。如果这时客户端与服务器建立了连接，客户端发送数据请求，服务器接收请求并处理请求，然后把响应数据发送给客户端，客户端读取数据，直到数据交换完毕。最后关闭连接，交互结束。

```
import socket
import sys

if __name__ == '__main__':
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # 创建 Socket 连接（TCP）
    print('Socket Created')

    try:
        sock.bind(('127.0.0.1', 8001))  # 配置 Socket，绑定 IP 地址和端口号
    except socket.error as e:
        print('Bind Failed...', e)
        sys.exit(0)

    sock.listen(5)  # 设置最大允许连接数，各连接和 Server 的通信遵循 FIFO 原则

    while True:  # 循环轮询 Socket 状态，等待访问
        conn, addr = sock.accept()
        try:
            conn.settimeout(10)  # 如果请求超过 10 秒没有完成，就终止操作

            # 如果要同时处理多个连接，则下面的语句块应该用多线程来处理
            while True:  # 获得一个连接，然后开始循环处理这个连接发送的信息
                data = conn.recv(1024)
                print('Get value ' + data, end='\n\n')
                if not data:
                    print('Exit Server', end='\n\n')
                    break
                conn.sendall('OK')  # 返回数据
        except socket.timeout:  # 建立连接后，该连接在设定的时间内没有数据发来，就会引发超时
            print('Time out')

        conn.close()  # 当一个连接监听循环退出后，连接可以关掉
    sock.close()
```

conn, addr = sock.accept()

调用 `accept()` 时，Socket 会进入waiting状态。客户端请求连接时，方法建立连接并返回服务器。`accept()` 返回一个含有两个元素的元组 (conn, addr)。第一个元素 conn 是新的 Socket 对象，服务器必须通过它与客户端通信；第二个元素 addr 是客户端的 IP 地址及端口。

data = conn.recv(1024)

接下来是处理阶段，服务器和客户端通过 `send()` 和 `recv()` 通信（传输数据）。
服务器调用 `send()`，并采用字符串形式向客户端发送信息，`send()` 返回已发送的字符个数。
服务器调用 `recv()` 从客户端接收信息。调用 `recv()` 时，服务器必须指定一个整数，它对应于可通过本次方法调用来接收的最大数据量。`recv()` 在接收数据时会进入blocked状态，最后返回一个字符串，用它表示收到的数据。如果发送的数据量超过了 `recv()` 所允许的，数据会被截短。多余的数据将缓冲于接收端，以后调用 `recv()` 时，会继续读剩余的字节，如果有多余的数据会从缓冲区删除（以及自上次调用 `recv()` 以来，客户端可能发送的其它任何数据）。传输结束，服务器调用 Socket 的 `close()` 关闭连接。

### 四、从 TCP 连接的视角看 Socket 过程

##### TCP 三次握手的 Socket 过程

![img](https://img2020.cnblogs.com/blog/660329/202010/660329-20201010111311841-1023720840.png)

1. 服务器调用 `socket()`、`bind()`、`listen()` 完成初始化后，调用 `accept()` 阻塞等待；
2. 客户端 Socket 对象调用 `connect()` 向服务器发送了一个 SYN 并阻塞；
3. 服务器完成了第一次握手，即发送 SYN 和 ACK 应答；
4. 客户端收到服务端发送的应答之后，从 `connect()` 返回，再发送一个 ACK 给服务器；
5. 服务器 Socket 对象接收客户端第三次握手 ACK 确认，此时服务端从 `accept()` 返回，建立连接。

接下来就是两个端的连接对象互相收发数据。

##### TCP 四次挥手的 Socket 过程

![img](https://img2020.cnblogs.com/blog/660329/202010/660329-20201010111352844-514391838.png)

1. 某个应用进程调用 `close()` 主动关闭，发送一个 FIN；
2. 另一端接收到 FIN 后被动执行关闭，并发送 ACK 确认；
3. 之后被动执行关闭的应用进程调用 `close()` 关闭 Socket，并也发送一个 FIN；
4. 接收到这个 FIN 的一端向另一端 ACK 确认。

说明：上面的服务端代码只有处理完一个客户端请求才会去处理下一个客户端的请求，这样的服务器处理能力很弱，而实际中服务器都需要有并发处理能力，为了达到并发处理，服务器就需要 fork 一个新的进程或者线程去处理请求。
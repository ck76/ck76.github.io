[TOC]

### 描述



## **前言**

在有些人看来，lisp是种“反智”的，违反人类自然语言逻辑的语言，它只在数理逻辑上拥有一定意义。事实证明了它只能在小范围普及使用，但不妨经常有人对它推崇备至并宣传。

**对LISP语言不同观点以及看法，我觉得应该要勇于实践实践，学了再自己做判断。没有自己思考和实践，不要轻易相信或者排斥任何观点。这些观点的唯一作用就是提供了你一个看事物的新角度和调查的起点。**

本文只是个人的对LISP语言特点以及总的概括，如有不足之处还请见谅。

## **关于LISP概述**

程序语言本身就不是为了符合自然语言的逻辑而去开发的，它是为了开发为人所用的软件的，它是为了更容易兼容机器，让机器理解是首要考虑，Lisp也一样，数理逻辑只是一套方法，Lisp是活生生的具体实现了，显然比那些高逼格的理论要来得实际得多，这一点比数理逻辑要高级吧。

早期的程序员用Lisp的可是很多的，只不过后来随着软件规模的扩大，需要扩充的东西比较多，而Lisp是以简洁著称的，由于它的开发环境实在太简陋，所以越来越不能被多数程序员接受。其实它一样可以开发现有的软件的，只要你愿意去用，它绝不输现在的任何流行语言。

人们推崇它很大一方面是受了某些人的宣传然后为了满足一下自己的好奇心，就去尝试了。真的有那么多人推崇Lisp吗？真的有用它去开发东西吗？这我无法回答。 
 

**看法一：（支持）**

1、lisp**高级又基础**，lisp没有python或者ruby里那些便利的数组或者hash操作函数，很多时候，lisp的数据只由2个部分组成：

（AAA 、 BBB）

第一个元素AAA称为car部分，剩下的另外一半。不管有多少，称为cdr部分。也就是对称的第二个元素。这叫con cell元素。很多复杂的数据结构，比如数组，hash表，红黑树，二叉树都是由它实现的。你说它不基础？但是lisp又很高级，c语言的一个特性是，机器效率虽高，但是人工效率很低。而lisp不同，《黑客与画家》中指出，lisp只需要c语言十分之一的代码就能实现同等的功能。而lisp甚至能直接操作cpu的寄存器，这是哪种高级虚拟机语言能实现的？

2、**lisp很简洁**，用一句话就能概括lisp的语法：

例如（A B C）

用圆括号括起来称为一个列表，列表中第一个原子被视为函数，其他原子被视为变量。而由单括号‘前导的元素什么也不视为（不求值），只按原样返回。

完了，就这么简单。剩下的都是细节。要知道真理都是很简洁的，比如e=mc2，真理总结出来都这么简单。所以lisp很强。

用多数人可以理解的话说，lisp没有”保留字“。我们知道每种语言包括c但是有保留字的。这意味着2点：

（1）他们的处理语句和数据是分开的，不一样的。

（2）他们都是被限制了的

但是lisp没有保留字，为什么呢？你看多数语言像c++，Java根本就没有所谓符号（symbol），ruby有符号，但是应用很少。lisp不同，lisp大多数原子都是符号。比如（print atom-1 atom-2），每一个符号可以连接着一个函数定义，或者一个变量定义，这个例子就是对atom-1，atom-2 两个符号进行求值，找出他们的变量定义然后交给print这个函数去运算。你可以把它调过来。（atom-1 print atom-2） ，这个例子就是对print，atom-2 两个符号进行求值，找出他们的变量定义然后交给atom-1连接的函数去运算，区别可能是print可能是一个系统预先定义好的函数，而atom-1可能是用户自定义函数。所以说lisp是没有保留字，也不需要保留字的。

所以我们就可以看到了，lisp一个有名的特点，数据和语句是一样的，是怎么实现的了。非常简单，同样的东西，你把它放在列表第一个，就是函数，否则就是变量，如果加上单引号不求值，那就是数据。如此，lisp也可以实现非常强大的宏系统，这也是独一无二的，其他语言都不能，因为他们都不可以把数据和语句区别开来。简单的说，宏就是接受一个参数，然后返回对应的代码，插入到调用宏的位置

（ defmacros （args）

`（defun aaaaa（，args）

;; process ））

这样的东西

把对应的代码恢复到对应位置，只要求值，就和普通的代码无异。所以lisp可以。而其他语言不可以。你返回一段语句，这段货的数据类型是啥？它就是数据，不是语句。要运行它，eval它，然后只能得到一个结果（以我对ruby粗浅的了解，它已经比java灵活太多了）。不像lisp可以替代源代码中的一个部分，比如替代函数中的一部分，这段代码可以操作参数，其他语言可以么？

**但是lisp这么强大，为什么1958年就被发明，半个世纪以来，lisp没有广泛的应用？**

lisp并非没有得到过应用。在教学领域，lisp是一门非常广泛使用的语言，那些不急功近利的学校比如麻省理工，入门课都采用schme（一门lisp的方言），而在商业领域，有名的《黑客与画家》的作者P··G在创立世界第一家互联网企业viaweb时，使用的是lisp。lisp之所以没有被广泛应用，是因为它太强大了，这么说似乎有点欠揍，但强大就意味着灵活，而灵活就意味着几乎没有语法。那些商业公司想要的只是稳定，把工作完成，他们并不在乎你用什么语言开发。他们才恨不得每一行都是钉死的，所有人都用一个名字写函数，因为这样可以花更少的钱维护。

ruby之父松本行宏曾这么说：

而lisp的问题在于，只要你掌握了s表达式，想写出什么样的程序都行，这意味lisp是没有语法的。这在应用上带来了一定的麻烦。我不希望自己的语言是没有语法的。所以ruby加入了一定的语法限制。

而在程序员的角度来说，以我看来，大多数人似乎不那么聪明，多数人喜欢用一种死语言（java/c++）也无可厚非，因为他们的思维可能就是死的。lisp可能更适用于强大的黑客，自己或者少数人每个人都很强的类型，它是一种黑客语言，而不是一种商业语言。

综上所述，lisp是灵活的，天马行空的，没有限制的。在我看来，一旦使用lisp，就不会想在去使用其他语言。lisp有一种和谐的美。我认为，Fortran，c++，java这样的东西是应需而生的，他们是为了满足当下的需要和硬件条件而设计使用的。而lisp从开始就是为了迎合真理和美而生。所以50年过去了，lisp还没有过时。lisp就是计算机界的真理，记得漫画《风云》中有这么一句，因为不管到哪里，真理（或者是类似的词）就是真理，所以绝世好剑的形状在哪都是一样的。lisp也是一样。以后可能会出现别的名字的语言，也可能不叫lisp，但是真理总是真理，所以绝世好剑的形状总是一样的。

**但是从现实的角度来看，我们要编程，如何运用lisp呢？**

emacs使用emacs lisp作为架构语言（不仅仅是扩展语言），这是绝佳的学习lisp的途径

common lisp和scheme作为lisp最有名的两门方言，广为人知。但是在教育领域应用比较多。实际用途似乎比较少

GNU组织使用guile作为gnu通用扩展语言，但是我没听说哪有它的应用。

时下最火的clojure，你可能听说过，这是一种运行在java虚拟机上的lisp，编译为java字节码，具有和java一样的速度，使用它可以无缝使用jdk里的所有库和java的无数第三方库，现在你知道它为啥火了。clojure的一个子集可以编译为javaascript运行在浏览器中，这带来了无尽的可能，尽情的享受那些愚民们的成果吧，node.js貌似也行。

**看法二：（不支持）**

认为Lisp永远成不了编程主流语言。他们认为Lisp未能成为主流的根本原因是这一语言是反人性的，它的先进是对于机器的先进，就像二进制对于计算机来说是先进的一样。人是生物，对事物的需求都有着多样性的需求，人类的所有语言对漂亮的形容词从来不止一个，对颜色的要求从来就不止黑白亮色，所以在数字上选择了十进制而不选择二进制，这是最基本的人性。Lisp使用S表达式抹平了一切多样性，禁止人类数千年来不约而同选择的的A+B这样的中缀表达式规则，违反了人性，所以受到了广大开发者的不接受。

简单说就是Lisp语言违反了人类人性中对事物多样性的需求而不能成为编程语言中的主流。

## **lisp语言特点**

LISP为函数式程序设计语言，所有运算都能以函数作用于参数的方式来实现。

LISP没有命令式语言程序中常见赋值语句和变量，重复的过程可以使用递归的函数调用来表示，并不需要使用循环模式。

LISP是古老的函数语言、弱类型、动态推断，其代码本身就是各种列表。每一个表项均可以储存任何类型的数据如数字、函数、符号或一个子表等，在编码时，可以随时操作以更新列表。

LISP核心的操作符只有7个操作符：quote、atom、eq、car、cdr、cons、cond。前三者quote、atom、eq用于符号的推断；car、cdr、cons操纵表格；cond负责分支判断。这种简洁定义，非常接近图灵机原型的纯函数式语言，是现代语言完全无法比拟的。

LISP作为弱类型这优点相对缺点则是运行效率的低下。原始定义简洁的缺点使到大型开发工程变得困难，自底层到高层，自二维表查询到面向对象，使用者需要嵌入更多的函数来实现，致使LISP众多方言的衍生。

## **Lisp优势：**

\- 不寻常的语法对智商是一个过滤

\- 语法糖特别适合对编辑器优化， 语言本身并没有给你任何不可跨越的限制。

\- Emacs配置本来就是个人行为。代码量不会很大，都放到同一个目录下grep就行了。所以也不存在多人开发导致质量下降的问题。

\#p##e#

## **各种Lisp系语言大检阅**

主要特色：

CommonLISP ： lisp系集大成者， 工业化强度的大型语言。 拥有理论上最高的表达力， 非常复杂， 学习难度极大。 喜欢的人捧到天上， 觉得它是一切语言的终点， 不喜欢的人恶心死， 觉得各种混乱各种冗余， 缺失美感。 （工业化语言）

Scheme： 一种以静态作用域和强制严格尾递归实现为特色， 遵从的理念是编程语言发展不该越来越复杂，不断堆叠新的功能和特色， 而是应该不断消除缺陷和限制， 以使得不再需要添加功能和特性就能达到目的。 追求数学上的美感， 跟CommonLISP在很多理念上完全相反， 相对简单，但是极端灵活。 由于缺少实用的库而长期沦为教学语言， 很少用于实用。 （算法语言）

Clojure： 一种新兴的lisp， 起于jvm平台， 现在已经移植到了.Net 和 Node.js 因为根植于几个非常流行的平台，使得其具有得天独厚的优势， 市场占有率节节上升， 直追前两大lisp. 语法上充分利用了多种括号，使得括号总数减少了。同时追求工业化强度和数学美感之间的平衡。 启动时间过长是最大的缺点。

newLISP： 剑走偏锋的独特lisp， 有大量创新内容， 同时保留一些在lisp系进化过程中被抛弃的设计（可能是过于大胆或者过于灵活副作用太大等原因），这些魔鬼设计的组合形成了一个强大独特的动态脚本语言系统。最大特色是语言好小，整个只有200k.

AutoLISP：曾经作为AutoCAD软件的内置脚本而成为最多人使用的lisp，但是语法古老， 缺陷很多，性能低下，代码丑陋， 世人关于lisp的种种不实的评论很多是由它而来。 现在已经被淘汰， 新版本AutoCAD用CommonLISP.

EmacsLISP： Emacs编辑器的扩展脚本语言， 现在依然存活的最古老的lisp语法之一， 因为编辑器而为世人所知。 但是跟AutoLISP一样，是一种古老的落后的lisp语言。

各个有影响力的分支：

Scheme的分支：

Racket： 以Scheme为基础， 增加了大量实用的语法和库， 使其成为一种更实用的语言而不仅仅是教学语言， 完全兼容低版本的scheme， 大部分兼容高版本的scheme.

IronScheme： .Net上的Scheme实现， 在R6RS标准的95%之上， 增加了跟.Net库的互操作和集成， 使得其成为一种实用的嵌入.NET程序的灵活脚本语言。在ngen的帮助上， 它成为启动最快的.Net lisp.

Clojure的分支：

ClojureCLR： .NET的DLR上的Clojure，并不是对jvm版的翻译，而是根据.Net而定制的实现。

ClojureScript： 把Clojure编译为javascript以运行在浏览器或Node.js. 是clpjure的子集

社区和文档：

CommonLISP 社区对新人很不友好， 充满歧视。 教程很多， 但是很古老，文档多但是都过于庞大， 让人望而生畏。

EmacsLISP 社区教程丰富细致

Scheme社区像大学， 文档都像论文一样

Clojure社区非常友好， 同时文档书籍以很快的速度增加着

Racket文档庞杂，社区没什么人， 并且设计者很有闭门造车的意味

newLISP社区在没落，文档不完整， 但整体方向没问题。

流行程度：

CommonLISP （30几位）

Scheme （40几位）

Clojure （50-100位）

其他（不在前100）





- http://m.elecfans.com/article/611016.html
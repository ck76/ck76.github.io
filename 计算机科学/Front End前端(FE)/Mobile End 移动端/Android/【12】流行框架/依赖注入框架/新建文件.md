[TOC]

## 使用Dagger 2依赖注入 - DI介绍

不久之前，在克拉科夫的 [Tech Space](http://frogermcs.github.io/dependency-injection-with-dagger-2-introdution-to-di/) 的 Google I/O 扩展中，我 [展示](https://speakerdeck.com/frogermcs/dependency-injection-with-dagger-2) 了一些关于使用Dagger 2来进行依赖注入。在准备期间我认识到有太多相关的东西需要去讲，无法用一打幻灯片就能覆盖到全部。但是它可以作为一个很好的进入点来开展更多这一系列主题－Android端的依赖注入。

在这一章中我会去通过之前所展示的来进行一个总结。可能并不是按部就班的 - 我认为现在是时候打破过去，使用一些原本我们不会使用或者不应该使用的方法来解决问题了。**Jake Wharton** [讲述](https://www.parleys.com/tutorial/5471cdd1e4b065ebcfa1d557/) 了相关历史（Guice, Dagger 1），**Gregory Kick** [也是](https://www.youtube.com/watch?v=oK_XtfXPkqw)（几乎有一半是关于Spring, Guice, Dagger 1）。我也会花几分钟的时间讲述以前的解决方式。但是此刻是时候开始了。

### 依赖注入

依赖注入的全部就是构建对象并在我们需要时把它们传入。我不会深入到它的学说（查看维基百科对[DI的定义](http://en.wikipedia.org/wiki/Dependency_injection)）。想象一个简单的类：`UserManager`，它依赖`UserStore`和`ApiService`。如果没有使用依赖注入，这个类会看起来像这样：

![img](http://frogermcs.github.io/images/13/user_manager_no_di.png)

`UserStore` 和 `ApiService` 两者都是在`UserManager`类中构造和提供的：

```java
class UserManager {
    
    private ApiService apiService;
    private UserStore userStore;

    //No-args constructor. Dependencies are created inside.
    public UserManager() {
        this.apiService = new ApiSerivce();
        this.userStore = new UserStore();
    }

    void registerUser() {/*  */}

}

class RegisterActivity extends Activity {

    private UserManager userManager;

    @Override
    protected void onCreate(Bundle b) {
        super.onCreate(b);
        this.userManager = new UserManager();
    }

    public void onRegisterClick(View v) {
        userManager.registerUser();
    }
}
```

为什么这些代码会给我们制造一些问题呢？让我们想象一下，你希望去改变`UserStore`的实现，用`SharedPreferences`来作为它的存储机制。它需要至少一个`Context`对象来创建一个实例，所以我们需要把它通过构造器传入到`UserStore`。它意味着`UserManager`类中也需要被修改来使用新的`UserStore`构造器。现在想象下有很多类使用了`UserStore` - 它们全部都需要被修改。

现在再来看下我们使用了依赖注入的`UserManager`类：

![img](http://frogermcs.github.io/images/13/user_manager_di.png)

它的依赖是在类的外面创建和提供的：

```java
class UserManager {

    private ApiService apiService;
    private UserStore userStore;

    //Dependencies are passed as arguments
    public UserManager(ApiService apiService, UserStore userStore) {
        this.apiService = apiService;
        this.userStore = userStore;
    }

    void registerUser() {/*  */}

}

class RegisterActivity extends Activity {

    private UserManager userManager;

    @Override
    protected void onCreate(Bundle b) {
        super.onCreate(b);
        ApiService api = ApiService.getInstance();
        UserStore store = UserStore.getInstance();
        
        this.userManager = new UserManager(api, store);
    }

    public void onRegisterClick(View v) {
        userManager.registerUser();
    }

}
```

现在在相似的情况下 - 我们改变它其中一个依赖的实现方式 - 我们不需要修改`UserManager`源代码。所有它的依赖都是从外面提供的，所以我们唯一一个需要修改的地方就是我们构造的`UserStore`对象。

所以使用依赖注入的优势是什么呢？

#### 构造/使用 的分离

当我们构造类的实例 - 通常这些对象会在其它的地方被使用到，多亏这个方法让我们的代码更加模块化 - 所有的依赖都可以被很简单地替换掉（只要他们实现了相同的接口），并且不会与我们应用的逻辑产生冲突。想要改变`DatabaseUserStore`为`SharedPrefsUserStore` ？好的，只需要关心公开的API（与`DatabaseUserStore`相同的）或者实现相同的接口。

#### 单元测试（Unit testing）

真正的单元测试假设一个类是可以完全被隔离进行测试的 - 不需要了解它的相关依赖。在实践中，基于我们的`UserManager`类，这里有一个我们应该编写的单元测试的例子：

```java
public class UserManagerTests {

    UserManager userManager;

    @Mock
    ApiService apiServiceMock;
    @Mock
    UserStore userStoreMock;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        userManager = new UserManager(apiServiceMock, userStoreMock);
    }

    @After
    public void tearDown() {
    }

    @Test
    public void testSomething() {
        //Test our userManager here - all its dependencies are satisfied
    }
}
```

它可能只能使用DI - 多亏`UserManager`是完全独立于`UserStore`和`ApiService`实现的。我们可以提供这些类的mock（简单地说 - mocks是一些拥有相同公开API的类，它在方法中不做任何事情并且/或者返回我们期望的值），然后在一个与所依赖的真实实现分离出来的环境下进行对`UserManager`的测试。

#### 独立/并行开发

多亏模块化的代码（`UserStore`可以从`UserManager`中独立出来进行实现），它也可以非常方便在程序员间进行代码的分离。只需要`UserStore`相关的接口被每个人知道（尤其是在`UserManager`中使用到的`UserStore`中的公开方法）即可。剩下的（实现，逻辑）可以通过单元测试来测试。

### 依赖注入框架

依赖注入除了这些优点之外还有一些缺点。其中一个缺点是会产生很大的模版代码。想象一个简单的`LoginActivity`类，它在MVP（model-view-presenter）模式中被实现。这个类看起来就像这样：

![img](http://frogermcs.github.io/images/13/login_activity_diagram.png)

唯一有问题的部分代码就是`LoginActivityPresenter`的初始化，如下：

```java
public class LoginActivity extends AppCompatActivity {

    LoginActivityPresenter presenter;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        OkHttpClient okHttpClient = new OkHttpClient();
        RestAdapter.Builder builder = new RestAdapter.Builder();
        builder.setClient(new OkClient(okHttpClient));
        RestAdapter restAdapter = builder.build();
        ApiService apiService = restAdapter.create(ApiService.class);
        UserManager userManager = UserManager.getInstance(apiService);
        
        UserDataStore userDataStore = UserDataStore.getInstance(
                getSharedPreferences("prefs", MODE_PRIVATE)
        );

        //Presenter is initialized here
        presenter = new LoginActivityPresenter(this, userManager, userDataStore);
    }
}
```

它看起来不太友好，不是吗？

这就是DI框架需要解决的问题。相同功能的代码看起来就像这样：

```java
public class LoginActivity extends AppCompatActivity {

    @Inject
    LoginActivityPresenter presenter;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        //Satisfy all dependencies requested by @Inject annotation
        getDependenciesGraph().inject(this);
    }
}
```

简单多了，对吧？当然DI框架没有地方可以获取到对象 - 他们仍然需要在我们代码的某个地方进行初始化和配置。但是对象构建从使用中分离出来了（实质上这是DI模式的准则）。DI框架关心怎么样去把它们联系在一起（怎么在对象被需要时分配给它们）。

### 未完待续

我上面所有描述的东西都是使用Dagger 2的简单的背景 - 用于Android和Java开发的依赖注入框架。在下一章我将尝试讲解所有Dagger 2的API。如果你等不急可以尝试我的[Github client example](https://github.com/frogermcs/GithubClient)，它建立在Dagger 2之上并且会用在我的展示中。一个小提示 - `@Module`和`@Component`就是构建/提供对象的地方。`@Inject`是我们对象使用到的地方。

More detailed description - soon.



# 使用Dagger 2依赖注入 - 自定义Scope

> 原文：http://frogermcs.github.io/dependency-injection-with-dagger-2-custom-scopes/

这章是展示使用Dagger 2在Android端实现依赖注入的系列中的一部分。今天我会花点时间在自定义Scope（作用域）上面 - 它是很实用，但是对于刚接触依赖注入的人会有一点困难。

## Scope - 它给我们带来了什么？

几乎所有的项目都会用到单例 - 比如API clients，database helpers，analytics managers等。因为我们不需要去关心实例化（由于依赖注入），我们不应该在我们的代码中考虑关于怎么得到这些对象。取而代之的是`@Inject`注解应该提供给我们适合的实例。

在Dagger 2中，Scope机制可以使得在scope存在时保持类的单例。在实践中，这意味着被限定范围为`@ApplicationScope`的实例与Applicaiton对象的生命周期一致。`@ActivityScope`保证引用与Activity的生命周期一致（举个例子我们可以在这个Activity中持有的所有fragment之间分享一个任何类的单例）。

简单来说 - scope给我们带来了“局部单例”，生命周期取决于scope自己。

但是需要弄清楚的是 - Dagger 2默认并不提供`@ActivityScope` 或者/并且 `@ApplicationScope` 这些注解。这些只是最常用的自定义Scope。只有`@Singleton` scope是默认提供的（由Java自己提供）。

## Scope - 实践案例

为了更好地去理解Dagger 2中的scope，我们直接进入实践案例。我们将要去实现比Application/Activity scope更加复杂一点的scope。为此我们将使用 [上一文章](http://frogermcs.github.io/dependency-injection-with-dagger-2-the-api/) 中的 [GithubClient](https://github.com/frogermcs/GithubClient) 例子。我们的app应需要三种scope：

- **@Sigleton** - application scope
- **@UserScope** - 用于与被选中的用户联系起来的类实例的scope（在真实的app中可以是当前登录的用户）。
- **@ActivityScope** - 生命周期与Activity（在我们例子中的呈现者）一致的实例的scope

讲解的`@UserScope`是今天方案与以前文章之间的主要的不同之处。从用户体验的角度来说它没有带给我们任何东西，但是从架构的观点来说它帮助我们在不传入任何意图参数的情况下提供了User实例。使用方法参数获取用户数据的类（在我们的例子中是`RepositoriesManager`）中我们可以通过构造参数（它将通过依赖图表提供）的方式来获取User实例并在需要的时候被初始化，而不是在app启动的时候创建它。这意味着`RepositoriesManager`可以在我们从Github API获取到用户信息（在`RepositoriesListActivity`呈现之前）之后被创建。

这里有个我们app中scopes和components呈现的简单图表。

![img](http://frogermcs.github.io/images/15/dagger-scopes.png)

单例（Application scope）是最长的scope（在实践中是与application一样长）。UserScope作为Application scope的一个子集scope，它可以访问它的对象（我们可以从父scope中得到对象）。ActivityScope（生命周期与Activity一致）也是如此 - 它可以从UserScope和ApplicationScope中得到对象。

## Scope生命周期的例子

这里有一个我们app中scope生命周期的案例：

![img](http://frogermcs.github.io/images/15/scopes-lifecycle.png)

单例的生命周期是从app启动后的所有的时期，当我们从Github API（在真实app中是用户登录之后）得到了`User`实例时UserScope被创建了，然后当我们回退到SplashActivity（在真实app中是用户退出之后）时被销毁。

## 实现

在Dagger 2中，Scope的实现归结于对Components的一个正确的设置。一般情况下我们有两种方式 - 使用`Subcomponent`注解或者使用Components依赖。它们两者最大的区别就是对象图表的共享。Subcomponents可以访问它们parent的所有对象图表，而Component依赖只能访问通过Component接口暴露的对象。

我选择第一种使用 `@Subcomponent` 注解，如果你之前使用过Dagger 1，它几乎与从`ObjectGraph`创建一个subgraphs（子图表）是一样的。此外，对于创建一个subgraphs的方法我们会使用类似的命名法则（但这不是强制性的）。

我们从`AppComponent`的实现开始：

```java
@Singleton
@Component(
        modules = {
                AppModule.class,
                GithubApiModule.class
        }
)
public interface AppComponent {

    UserComponent plus(UserModule userModule);

    SplashActivityComponent plus(SplashActivityModule splashActivityModule);

}
```

它将会是其它subcomponents的根Components：`UserComponent`和Activities Components。正如你注意到的那样（尤其如果你在前面的文章中看过的[AppComponent 实现](https://github.com/frogermcs/GithubClient/blob/1bf53a2a36c8a85435e877847b987395e482ab4a/app/src/main/java/frogermcs/io/githubclient/AppComponent.java)）所有的返回依赖图表对象的公开方法全部消失了。因为我们有subcomponents了，我们不需要去公开去暴露依赖了 - 无论如何subgraphs都可以访问它们全部了。

作为替代，我们新增了两个方法：

- `UserComponent plus(UserModule userModule);`
- `SplashActivityComponent plus(SplashActivityModule splashActivityModule);`

这表示，我们可以从`AppComponent`创建两个子Components（subcomponents）：`UserComponent`和`SplashActivityComponent`。因为它们都是AppComponent的subcomponents，所以它们两者都可以访问`AppModule`和`GithubApiModule`创建的实例。

*这些方法的命名法则是：返回类型是subcomponent类，方法名字随意，参数是这个subcomponent需要的modules。*

如你所见，`UserComponent`需要另一个module（它通过`plus()`方法的参数传入）。这样，我们通过增加一个新的用于生成对象的module，继承`AppComponent`图表。`UserComponent`类看起来这样：

```java
@UserScope
@Subcomponent(
        modules = {
                UserModule.class
        }
)
public interface UserComponent {
    RepositoriesListActivityComponent plus(RepositoriesListActivityModule repositoriesListActivityModule);

    RepositoryDetailsActivityComponent plus(RepositoryDetailsActivityModule repositoryDetailsActivityModule);
}
```

当然`@UserScope`注解是我们自己创建的：

```java
@Scope
@Retention(RetentionPolicy.RUNTIME)
public @interface UserScope {
}
```

我们可以从`UserComponent`创建另外两个subcomponents：`RepositoriesListActivityComponent`和`RepositoryDetailsActivityComponent`。

```java
@UserScope
@Subcomponent(
        modules = {
                UserModule.class
        }
)
public interface UserComponent {
    RepositoriesListActivityComponent plus(RepositoriesListActivityModule repositoriesListActivityModule);

    RepositoryDetailsActivityComponent plus(RepositoryDetailsActivityModule repositoryDetailsActivityModule);
}
```

并且更重要的是所有scope的东西都发生在这里。所有`UserComponent`中从`AppComponent`继承过来的仍然shi是单例的（是 Applicaton scope）。但是`UserModule`（`UserComponent`的那部分）创建的对象将会是“局部单例”，它的生命周期跟`UserComponent`实例是一样的。

所以，每次一创建另一个`UserComponent`实例将会调用：

```java
UserComponent appComponent = appComponent.plus(new UserModule(user))
```

从`UserModule`中获取的对象将是不同的实例。

但是这里很重要的一点是 - 我们要负责`UserComponent`的生命周期。所以我们应该关心它的初始化和释放。在我们的例子中，我为它增加了两个额外的方法：

```java
public class GithubClientApplication extends Application {

    private AppComponent appComponent;
    private UserComponent userComponent;

    //...

    public UserComponent createUserComponent(User user) {
        userComponent = appComponent.plus(new UserModule(user));
        return userComponent;
    }

    public void releaseUserComponent() {
        userComponent = null;
    }

    //...
}
```

`createUserComponent()`方法会在我们从Github API（在`SplashActivity`中）获取到`User`对象时调用。`releaseUserComponent()`方法会在我们从`RepositoriesListActivity`（这个时候我们不再需要user scope了）中返回时调用。

## Dagger 2中的Scope - 内部实现

查看它的内部的工作原理是很不错的。通常在这种情况下可以确定，在Dagger 2的scope机制下并不存在什么魔法。

我们从`UserModule.provideRepositoriesManager()`方法开始研究。它提供了`RepositoriesManager`实例，它应该使用`@UserScope`Scope。我们来检验这个方法哪里被调用（第8行）：

```java
@Generated("dagger.internal.codegen.ComponentProcessor")
public final class UserModule_ProvideRepositoriesManagerFactory implements Factory<RepositoriesManager> {

  //...
  
  @Override
  public RepositoriesManager get() {  
    RepositoriesManager provided = module.provideRepositoriesManager(userProvider.get(), githubApiServiceProvider.get());
    if (provided == null) {
      throw new NullPointerException("Cannot return null from a non-@Nullable @Provides method");
    }
    return provided;
  }

  public static Factory<RepositoriesManager> create(UserModule module, Provider<User> userProvider, Provider<GithubApiService> githubApiServiceProvider) {  
    return new UserModule_ProvideRepositoriesManagerFactory(module, userProvider, githubApiServiceProvider);
  }
}
```

`UserModule_ProvideRepositoriesManagerFactory`仅仅是一个工厂模式的现实，它从`UserModule`中获取到`RepositoriesManager`实例。我们应该往更深层次挖掘。

`UserModule_ProvideRepositoriesManagerFactory`在`UserComponentImpl`中被使用 - 我们component的实现（line 15）：

```java
private final class UserComponentImpl implements UserComponent {

    //...

    private UserComponentImpl(UserModule userModule) {
      if (userModule == null) {
        throw new NullPointerException();
      }
      this.userModule = userModule;
      initialize();
    }

    private void initialize() {
      this.provideUserProvider = ScopedProvider.create(UserModule_ProvideUserFactory.create(userModule));
      this.provideRepositoriesManagerProvider = ScopedProvider.create(UserModule_ProvideRepositoriesManagerFactory.create(userModule, provideUserProvider, DaggerAppComponent.this.provideGithubApiServiceProvider));
    }

    //...
    
}
```

`provideRepositoriesManagerProvider`对象在我们每次请求它时负责提供`RepositoriesManager`实例。如我们所见，provider是通过`ScopedProvider`实现的。来看下它的部分代码：

```java
public final class ScopedProvider<T> implements Provider<T> {
  
  //...

  private ScopedProvider(Factory<T> factory) {
    assert factory != null;
    this.factory = factory;
  }

  @SuppressWarnings("unchecked") // cast only happens when result comes from the factory
  @Override
  public T get() {
    // double-check idiom from EJ2: Item 71
    Object result = instance;
    if (result == UNINITIALIZED) {
      synchronized (this) {
        result = instance;
        if (result == UNINITIALIZED) {
          instance = result = factory.get();
        }
      }
    }
    return (T) result;
  }

  //...

}
```

再简单不过了吧？第一次调用`ScopedProvider`从factory（我们的例子中是`UserModule_ProvideRepositoriesManagerFactory`）中获取实例并像单例模式一样存储起来。我们的scoped provider只是`UserComponentImpl`中的一个属性，所以简单说就是`ScopedProvider`返回一个与依赖于Component的单例。

在这里你可以查看 [ScopedProvider](https://github.com/google/dagger/blob/master/core/src/main/java/dagger/internal/ScopedProvider.java) 的所有的实现。

就是这样。我们弄清楚了Dagger 2中Scope底层是怎么工作的。现在我们知道，它们没有以任何方式于Scope注解连接。自定义注解只是给了我们一个简单的方式来进行编译时代码校验和标记一个类是单例/非单例。所有的scope相关东西都是与Component的生命周期相关联。

以上就是今天的全部内容。我希望从现在开始scopes会变得更加容易使用。感谢阅读！

### 代码：

以上描述的完整代码可见Github [repository](https://github.com/frogermcs/GithubClient)。

## 作者

[Miroslaw Stanek](http://about.me/froger_mcs)

Head of Mobile Development @ [Azimo](https://azimo.com/)



# 使用Dagger 2依赖注入 - 图表创建的性能

> 原文：http://frogermcs.github.io/dagger-graph-creation-performance/

[#PerfMatters](https://twitter.com/search?q=%23perfmatters) - 最近非常流行标签，尤其在Android世界中。不管怎样，apps只需要正常工作就可以的时代已经过去了。现在所有的一切都应该是令人愉悦的，流畅并且快速。举个例子，Instagram [花费了半年的时间](http://instagram-engineering.tumblr.com/post/97740520316/betterandroid) 只是让app更加快速，更加美观，和更好的屏幕适配性。

这就是为什么今天我想去分享给你一些小的建议，它会在你app启动时间上有很大的影响（尤其是当app使用了一些额外库的时候）。

## 对象图表的创建

大多情况下，在app开发过程中，它的启动时间或多或少会增加。有时随着一天天地开发它是很难被注意到的，但是当你把第一个版本和你能找到的最近的版本比较时区别就会相对比较大了。

原因很可能就在于dagger对象图表的创建过程。

Dagger 2？你可能会问，确切地说 - 就算你移除了那些基于反射的实现方案，并且你的代码是在编译时期生成的，但是别忘了对象的创建仍然发生是在运行时。

对象（还有它的依赖）会在第一次被注入时创建。Jake Wharton 在Dagger 2演示中的一些幻灯片很清楚地展示了这一点：

以下表示在我们的 [GithubClient](https://github.com/frogermcs/GithubClient) 例子app中它是怎样的：

1. App第一次（被kill之后）被启动。Application对象并没有`@Inject`属性，所以只有`AppComponent`对象被创建。
2. App创建了`SplashActivity` - 它有两个`@Inject`属性：`AnalyticsManager`和`SplashActivityPresenter`。
3. `AnalyticsManager`依赖已被创建的`Application`对象。所以只有`AnalyticsManager`构造方法被调用。
4. `SplashSctivityPresenter`依赖：`SplashActivity`，`Validator`和`UserManager`。`SplashActivity`已被提供，`Validator`和`UserManager`应该被创建。
5. `UserManager`依赖需要被创建的`GithubApiService`。之后`UserManager`被创建。
6. 现在我们拥有了所有依赖，`SplashActivityPresenter`被创建。

![img](http://frogermcs.github.io/images/18/graph.png)

有点混乱，但是就结果来说，在`SplashActivity`被创建之前（我们假设对象注入的操作只会在`onCreate()`方法中执行）我们必须要等待以下构造方法（可选配置）：

- `GithubApiService`（它也使用了一些依赖，如`OkHttpClient`，一个`RestAdapter`）
- `UserManager`
- `Validator`
- `SplashActivityPresenter`
- `AnalyticsManager`

一个接一个地被创建。

嘿，别担心，更复杂地图表也几乎被立即创建。

## 问题

现在让我们想象下，我们有两个外部的库需要在app启动时被初始化（比如，Crashlytics, Mixpanel, Google Analytics, Parse等等）。想象下我们的`HeavyExternalLibrary`看起来如下：

```java
public class HeavyExternalLibrary {

    private boolean initialized = false;

    public HeavyExternalLibrary() {
    }

    public void init() {
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        initialized = true;
    }

    public void callMethod() {
        if (!initialized) throw new RuntimeException("Call init() before you use this library");
    }
}
```

简单说 - 构造方法是空的，并且调用几乎不花费任何东西。但是有一个`init()`方法，它耗时500ms并且在我们使用这个库之前必须要被调用。确保在我们module的某处的某一时刻调用了`init()`：

```java
//AppModule

@Provides
@Singleton
HeavyExternalLibrary provideHeavyExternalLibrary() {
    HeavyExternalLibrary heavyExternalLibrary = new HeavyExternalLibrary();
    heavyExternalLibrary.init();
    return heavyExternalLibrary;
}
```

现在我们的`HeavyExternalLibrary`成为了`SplashActivityPresenter`的一部分：

```java
@Provides
@ActivityScope
SplashActivityPresenter
provideSplashActivityPresenter(Validator validator, UserManager userManager, HeavyExternalLibrary heavyExternalLibrary) {
    return new SplashActivityPresenter(splashActivity, validator, userManager, heavyExternalLibrary);
}
```

然后会发生什么？我们app启动时间需要500ms还多，只是因为`HeavyExternalLibrary`的初始化，这过程会在SplashActivityPresenter依赖图表创建中执行。

## 测量

Android SDK（Android Studio本身）给我们提供了一个随着应用执行的时间的可视化的工具 - [Traceview](http://tools.android.com/tips/traceview)。多亏这个我们可以看见每个方法花了多少时间，并且找出注入过程中的瓶颈。

顺便说一下，如果你以前没有见过它，可以在[Udi Cohen的博客](http://blog.udinic.com/2015/09/15/speed-up-your-app/)看下这篇Android性能优化相关的文章。

Traceview可以直接从Android Studio（Android Monitor tab -> CPU -> Start/Stop Method Tracing）启动，它有时并不是那么精确的，尤其是当我们尝试在app启动时点击`Start`。

对于我们而言，幸运的是当我们知道确切的需要被测量的代码位置时，有一个可以使用的方法。[Debug.startMethodTracing()](http://developer.android.com/reference/android/os/Debug.html#startMethodTracing(java.lang.String))可以用来指定我们代码中需要被启动测量的位置。`Debug.stopMethodTracing()`停止追踪并且创建一个新的文件。

为了实践，我们测量了SplashActivity的注入过程：

```java
@Override
protected void setupActivityComponent() {
    Debug.startMethodTracing("SplashTrace");
    GithubClientApplication.get(this)
            .getAppComponent()
            .plus(new SplashActivityModule(this))
            .inject(this);
    Debug.stopMethodTracing();
}
```

`setupActivityComponent()`是在`onCreate()`中调用的。

文档结果被保存在`/sdcard/SplashTrace.trace`中。

在你的terminal中把它pull出来：

```
$ adb pull /sdcard/SplashTrace.trace
```

现在阅读这个文件所要做的全部事情只是把它拖拽到Android Studio：

![img](http://frogermcs.github.io/images/18/trace.png)

你应该会看到类似以下的东西：

![img](http://frogermcs.github.io/images/18/traceview.png)

当然，我们这个例子中的结果是非常清晰的：`AppModule_ProvideHeavyExternalLibraryFactory.get()`（HeavyExternalLibrary被创建的地方）花费了500ms。

真正好玩的地方是，缩放trace尾部的那一小块地方：

![img](http://frogermcs.github.io/images/18/traceview2.png)

看到不同之处了吗？比如构建类：`AnalyticsManager`花了小于1ms。

如果你想看到它，这里有这个例子中的[SplashTrace.trace](https://github.com/frogermcs/frogermcs.github.io/raw/master/files/18/SplashTrace.trace)文件。

## 解决方案

不幸的是，对于这类性能问题，有时并没有明确的回答。这里有两种方式会给我们很大的帮助。

### 懒加载（临时的解决方案）

首先，我们要思考是否你需要所有的注入依赖。也许其中一部分可以延迟一定时间后再加载？当然这并不解决真正的问题（UI线程将会在第一次调用Lazy<>.get()方法的时候阻塞）。但是在某些情况下对启动耗时有帮助（尤其是很少地方会使用到的一些对象）。查看[Lazy<>](http://google.github.io/dagger/api/2.0/dagger/Lazy.html)接口文档获取更多的信息和例子代码。

简单说，每一个你使用`@Inject SomeClass someClass`的地方都可以替换成`@Inject Lazy<SomeClass> someClassLazy`（构造方法注入也是）。然后获取某个类的实例时必须要调用`someClassLazy.get()`。

### 异步对象创建

第二种选择（它仍然只是更多的想法而不是最终的解决方案）是在后台线程中的某处进行对象的初始化，缓存所有方法的调用并在初始化之后再回调它们。

这种方案的缺点是它必须要单独地准备我们要包含的所有类。并且它只有在方法调用可以被执行的将来（就像任何的analytics - 在一些事件被发生之后才可以），这些对象才可能正常工作。

以下就是我们的`HeavyExternalLibrary`使用这种解决方案后的样子：

```java
public class HeavyLibraryWrapper {

    private HeavyExternalLibrary heavyExternalLibrary;

    private boolean isInitialized = false;

    ConnectableObservable<HeavyExternalLibrary> initObservable;

    public HeavyLibraryWrapper() {
        initObservable = Observable.create(new Observable.OnSubscribe<HeavyExternalLibrary>() {
            @Override
            public void call(Subscriber<? super HeavyExternalLibrary> subscriber) {
                HeavyLibraryWrapper.this.heavyExternalLibrary = new HeavyExternalLibrary();
                HeavyLibraryWrapper.this.heavyExternalLibrary.init();
                subscriber.onNext(heavyExternalLibrary);
                subscriber.onCompleted();
            }
        }).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).publish();

        initObservable.subscribe(new SimpleObserver<HeavyExternalLibrary>() {
            @Override
            public void onNext(HeavyExternalLibrary heavyExternalLibrary) {
                isInitialized = true;
            }
        });

        initObservable.connect();
    }

    public void callMethod() {
        if (isInitialized) {
            HeavyExternalLibrary.callMethod();
        } else {
            initObservable.subscribe(new SimpleObserver<HeavyExternalLibrary>() {
                @Override
                public void onNext(HeavyExternalLibrary heavyExternalLibrary) {
                    heavyExternalLibrary.callMethod();
                }
            });
        }
    }
}
```

当`HeavyLibraryWrapper`构造方法被调用，库的初始化会在后台线程（这里的`Schedulers.io()`）中执行。在此期间，当用户调用`callMethod()`，它会增加一个新的subscription到我们的初始化过程中。当它完成时（onNext()方法返回一个已初始化的HeavyExternalLibrary对象）被缓存的回调会被传送到这个对象。

目前为止，这个想法还是非常简单并且仍然是在开发之中。这里可能会引起内存泄漏（比如，我们不得不在callMethod()方法中传入一些参数），但一般还是适用于简单的情况下的。

### 还有其它方案？

性能优化的过程是非常孤独的。但是如果你想要分享你的ideas，请在这里分享吧。

感谢你的阅读！

### 代码：

以上描述的完整代码可见Github [repository](https://github.com/frogermcs/GithubClient)。

## 作者

[Miroslaw Stanek](http://about.me/froger_mcs)

Head of Mobile Development @ [Azimo](https://azimo.com/)



# Dagger2Metrics - 测量DI图表初始化的性能

> 原文：http://frogermcs.github.io/dagger2metrics-measure-performance-of-graph-initialization/

几个月前我们通过 [Dagger 2 - graph creation performance](http://frogermcs.github.io/dagger-graph-creation-performance/) 经历了一些可能会遇到的问题。多亏 [TraceView](http://tools.android.com/tips/traceview) 这个工具我们可以很确切地看到初始化所有需要的依赖需要多少时间。但是这并不简单 - 我们必须要在我们代码中找出需要开始和停止测量的地方，然后在Android Studio中dump和分析它们。为了让它变得更简单，我们准备了一个简单的库，它可以帮助我们捕捉潜在的性能问题。

## Dagger2Metrics

### Dagger 2 初始化过程的性能测量库

*下面的描述内容是从 Dagger2Metrics Github [项目网站](https://github.com/frogermcs/dagger2metrics)拷贝过来的。*

如果你在Android应用中使用Dagger 2来进行依赖注入，你可能知道它最大的一处优化就是Google（原来是Square）的优秀工程师通过使用非反射代码实现。

即使有了所有的这些优化以及完全的非动态代码生成，但是仍然有潜在的性能问题隐藏在我们的代码中和所有通过Dagger 2注入的第三方代码中。

性能的问题通常是慢慢地变慢的，所以在每天的开发中是很难意识到我们的app（或者Activity、或者其他View）启动50ms或者更长。又一次变成150ms，又一次变成100ms...

使用Dagger2Metrics，你将可以看到初始化所有需要的依赖需要多少时间（以及这些依赖之间的依赖关系）。

![img](https://raw.githubusercontent.com/frogermcs/dagger2metrics/master/art/dagger2metrics.png)

### 准备开始

在你的`build.gradle`中：

```groovy
buildscript {
  repositories {
    jcenter()
  }

  dependencies {
    classpath 'com.frogermcs.dagger2metrics:dagger2metrics-plugin:0.2'
  }
}

apply plugin: 'com.android.application'
apply plugin: 'com.frogermcs.dagger2metrics'
```

在你的`Application`类中：

```java
public class ExampleApplication extends Application {

 @Override
 public void onCreate() {
     super.onCreate();
     //Use it only in debug builds
     if (BuildConfig.DEBUG) {
         Dagger2Metrics.enableCapturing(this);
     }
  }
 }
```

这样就完成了。在你的app中，你将会看到notification，它可以打开所有已完成的初始化的一个简单的概述。

![img](https://raw.githubusercontent.com/frogermcs/dagger2metrics/master/art/dagger2metrics-notification.png)

### 它是怎么工作的？

Dagger2Metrics会捕捉所有的初始化，通过 - 所有带有 `@Module` -> `@Provides` 注解的方法和`@Inject`注解的构造方法。

总之，你会看到大多数顶级注入依赖地依赖关系树。每一个依赖显示了提供这些对象到Dagger 2对象图表需要多少时间（构建本身所用时间以及所有的依赖）。

![img](https://raw.githubusercontent.com/frogermcs/dagger2metrics/master/art/dagger2metrics.png)

### 为什么我看不到所有（子）依赖？

测量树不会显示那些已经提供给Dagger图表的依赖，所以只有从头开始构建的才会显示出来。主要是因为可读性以及另外一个简单的理由就是 - 我们不想在大多数没有错误的情况下去测量Dagger 2的性能。我们应该确保我们的代码尽可能快地提供依赖。

### 自定义

Dagger2Metrics 有3种默认级别的警告：

```
Dagger2Metrics.WARNING_1_LIMIT_MILLIS // 30ms
Dagger2Metrics.WARNING_2_LIMIT_MILLIS // 50ms
Dagger2Metrics.WARNING_3_LIMIT_MILLIS // 100ms
```

你可以根据你的需要对它们进行调整。

### 例子app

你可以查看 [GithubClient](https://github.com/frogermcs/githubclient) 项目 - 一个展示怎么使用Dagger 2的Android app的例子。最近的版本在debug build中使用了Dagger2Metrics。

### 更多关于Dagger 2

如果你刚开始接触Dagger 2，下面的资源列表可以帮助你：

[GithubClient](https://github.com/frogermcs/githubclient) - 基于Dagger 2依赖注入框架的Github API 客户端实现的例子。

Blog posts：

- [Dagger 1 to 2 migration process](http://frogermcs.github.io/dagger-1-to-2-migration/)
- [Introdution to Dependency Injection](http://frogermcs.github.io/dependency-injection-with-dagger-2-introdution-to-di/)
- [Dagger 2 API](http://frogermcs.github.io/dependency-injection-with-dagger-2-the-api/)
- [Dagger 2 - custom scopes](http://frogermcs.github.io/dependency-injection-with-dagger-2-custom-scopes/)
- [Dagger 2 - graph creation performance](http://frogermcs.github.io/dagger-graph-creation-performance/)

### 代码：

以上描述的完整代码可见Github [repository](https://github.com/frogermcs/GithubClient)。



# 使用Dagger 2进行依赖注入 - Producers

> 原文：http://frogermcs.github.io/dependency-injection-with-dagger-2-producers/

本文是在Android中使用Dagger 2框架进行依赖注入的系列文章中的一部分。今天我们将探索下Dagger Producers - 使用Java实现异步依赖注入的Dagger2的一个扩展。

## 初始化性能问题

我们都知道Dagger 2是一个优化得很好的依赖注入框架。但是即使有这些全部的微优化，仍然在依赖注入的时候存在可能的性能问题 - “笨重”的第三方库和/或我们那些主线程阻塞的代码。

依赖注入是在尽可能短的时间内在正确的地方传递所请求的依赖的过程 - 这些都是Dagger 2做得很好的。但是DI也会去创建各种依赖。如果我们需要花费几百毫秒创建它们，那么以纳秒级的时间去提供依赖还有什么意义呢？

当我们的app创建了一系列繁重的单例并立即由Dagger2提供服务之后也许可能没有这么重要。但是在我们创建它们的时候仍然需要一个时间成本 - 大多数情况下决定了app启动的时间。

这问题（已经给了提示怎么去调适它）已经在我之前的一篇博客中描述地很详细了：[Dagger 2 - graph creation performance](http://frogermcs.github.io/dagger-graph-creation-performance/)。

在很短的时间内，让我们想象这么一个场景 - 你的app有一个初始化的界面（SplashScreen），需要在app启动后立即做一些需要的事情：

- 初始化所有tracking libs（Goole Analytics, Crashlytics）然后发送第一份数据给它们。
- 创建用于API和/或数据库通信的整个栈。
- 我们试图的交互逻辑（MVP中的Presenters，MVVM中的ViewModels等等）。

即使我们的代码是优化地非常好的，但是仍然有可能有些额外的库需要几十或者几百毫秒的时间来初始化。在我们启动界面之前将展示必须初始化和交付的所有请求的依赖（和它们的依赖）。这意味着启动时间将会是它们每一个初始化时间的总和。

由 [AndroidDevMetrics](https://github.com/frogermcs/androiddevmetrics) 测量的示例堆栈可能如下所示：

![img](http://frogermcs.github.io/images/24/example_dependencies.png)

用户将会在600ms（＋额外的系统work）内看到SplashActivity - 所有初始化时间的总和。

## Producers - 异步依赖注入

Dagger 2 有一个名为 **Producers** 的扩展，或多或少能为我们解决这些问题。

思路很简单 - 整个初始化流程可以在一个或多个后台线程中被执行，然后延后再交付给app的主线程。

#### @ProducerModule

类似于`@Module`，这个被用来标记用于传递依赖的类。多亏于它，Dagger将会知道去哪里找到被请求的依赖。

#### @Produces

类似于`@Provide`，这个注解用来标记带有`@ProducerModule`注解的类中的返回依赖的方法。`@Produces`注解的方法可以返回`ListenableFuture<T>`或者自身的对象（也会在所给的后台线程中进行初始化）。

#### @ProductionComponent

类似于`@Component`，它负责依赖的传递。它是我们代码与`@ProducerModule`之间的桥梁。唯一跟`@Component`的不同之处是我们不能决定依赖的scope。这意味着提供给 *component* 的每一个 *Produces 方法* 在 *每个component 实例* 中最多只会被调用一次，不管它作为一个 *依赖* 用于多少次绑定。

也就是说，每一个服务于`@ProductionComponent`的对象都是一个单例（只要我们从这个特殊的component中获取）。

------

Producers的文档已经足够详细了，所以这里没有必要去拷贝到这里。直接看：[Dagger 2 Producers docs](http://google.github.io/dagger/producers.html)。

### Producers的代价

在我们开始实践前，有一些值得提醒的事情。Producers相比Dagger 2本身有一点更复杂。它看起来手机端app不是他们它们主要使用的目标，而且知道这些事情很重要：

- Producers使用了Guava库，并且建立在ListenableFuture类之上。这意味着你不得不处理15k的额外方法在你的app中。这可能导致你不得不使用*Proguard*来处理并且需要一个更长的编译时间。
- 就如你将看到的，创建`ListenableFutures`并不是没有成本的。所以如果你指望Producers会帮你从10ms优化到0ms那你可能就错了。但是如果规模更大（100ms --> 10ms），你就能有所发现。
- 现在无法使用`@Inject`注解，所以你必须要手动处理ProductionComponents。它会使得你的标准整洁的代码变得混乱。

[这里](http://stackoverflow.com/questions/35617378/injects-after-produces)你可以针对`@Inject`注解找到好的间接的解决方案的尝试。

## Example app

如果你仍然希望使用Producers来处理，那就让我们更新 [GithubClient](https://github.com/frogermcs/GithubClient/) 这个app使得它在注入过程使用Producers。在实现之前和之后我们将会使用 [AndroidDevMetrics](https://github.com/frogermcs/androiddevmetrics) 来测量启动时间和对比结果。

[这里](https://github.com/frogermcs/GithubClient/tree/1c14683691e0e7af17b26055a0fd041d4a7df424)是一个在使用producers更新之前的 GithubClient app的版本。并且它测量的平均启动时间如下：

![img](http://frogermcs.github.io/images/24/before_update.png)

我们的计划是处理UserManager让它的所有的依赖来自Producers。

### 配置

我们将给一个Dagger v2.1的尝试（但是当前2.0版本的Producers也是可用的）。

让我们在项目中加入一个Dagger新的版本：

***app/build.gradle：***

```groovy
apply plugin: 'com.android.application'
apply plugin: 'com.neenbedankt.android-apt'
apply plugin: 'com.frogermcs.androiddevmetrics'

repositories {
    maven {
        url "https://oss.sonatype.org/content/repositories/snapshots"
    }
}
//...

dependencies {
    //...

    //Dagger 2
    compile 'com.google.dagger:dagger:2.1-SNAPSHOT'
    compile 'com.google.dagger:dagger-producers:2.1-SNAPSHOT'
    apt 'com.google.dagger:dagger-compiler:2.1-SNAPSHOT'

    //...
}
```

如你所见，Producers 作为一个新的依赖，在dagger 2库的下面。还有值得一说的是Dagger v2.1终于不需要`org.glassfish:javax.annotation:10.0-b28`的依赖了。

### Producer Module

现在，让我们移动代码从`GithubApiModule`到新创建的`GithubApiProducerModule`中。原来的代码可以在这里找到：[GithubApiModule](https://github.com/frogermcs/GithubClient/blob/1c14683691e0e7af17b26055a0fd041d4a7df424/app/src/main/java/frogermcs/io/githubclient/data/api/GithubApiModule.java)

***GithubApiProducerModule.java***

```java
@ProducerModule
public class GithubApiProducerModule {

    @Produces
    static OkHttpClient produceOkHttpClient() {
        final OkHttpClient.Builder builder = new OkHttpClient.Builder();
        if (BuildConfig.DEBUG) {
            HttpLoggingInterceptor logging = new HttpLoggingInterceptor();
            logging.setLevel(HttpLoggingInterceptor.Level.BODY);
            builder.addInterceptor(logging);
        }

        builder.connectTimeout(60 * 1000, TimeUnit.MILLISECONDS)
                .readTimeout(60 * 1000, TimeUnit.MILLISECONDS);

        return builder.build();
    }

    @Produces
    public Retrofit produceRestAdapter(Application application, OkHttpClient okHttpClient) {
        Retrofit.Builder builder = new Retrofit.Builder();
        builder.client(okHttpClient)
                .baseUrl(application.getString(R.string.endpoint))
                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
                .addConverterFactory(GsonConverterFactory.create());
        return builder.build();
    }

    @Produces
    public GithubApiService produceGithubApiService(Retrofit restAdapter) {
        return restAdapter.create(GithubApiService.class);
    }

    @Produces
    public UserManager produceUserManager(GithubApiService githubApiService) {
        return new UserManager(githubApiService);
    }

    @Produces
    public UserModule.Factory produceUserModuleFactory(GithubApiService githubApiService) {
        return new UserModule.Factory(githubApiService);
    }
}
```

看起来很像？没错，我们只是修改了：

- `@Module` 改为 `@ProducerModule`
- `@Provides @Singleton` 改为 `@Produces`。*你还记得吗？在Producers中我们默认就有一个单例*

`UserModule.Factory` 依赖只是因为app的逻辑原因而添加。

## Production Component

现在让我们创建`@ProductionComponent`，它将会为`UserManager`实例提供服务：

```java
@ProductionComponent(
        dependencies = AppComponent.class,
        modules = GithubApiProducerModule.class
)
public interface AppProductionComponent {
    ListenableFuture<UserManager> userManager();

    ListenableFuture<UserModule.Factory> userModuleFactory();
}
```

又一次，非常类似原来的[Dagger's @Component](https://github.com/frogermcs/GithubClient/blob/master/app/src/main/java/frogermcs/io/githubclient/AppComponent.java)。

ProductionComponent的构建也是与标准的Component非常相似：

```java
AppProductionComponent appProductionComponent = DaggerAppProductionComponent.builder()
    .executor(Executors.newSingleThreadExecutor())
    .appComponent(appComponent)
    .build();
```

额外附加的参数是`Executor`实例，它告诉ProductionComponent依赖应该在哪里（哪个线程）被创建。在我们的例子中我们使用了一个single-thread executor，但是当然增加并行级别并使用多线程执行不是一个问题。

## 获取依赖

就像我说的，当前我们不能去使用`@Inject`注解。相反，我们必须直接询问ProductionComponent（你可以在[SplashActivityPresenter](https://github.com/frogermcs/GithubClient/blob/master/app/src/main/java/frogermcs/io/githubclient/ui/activity/presenter/SplashActivityPresenter.java)找到这些代码）：

```java
appProductionComponent = splashActivity.getAppProductionComponent();
Futures.addCallback(appProductionComponent.userManager(), new FutureCallback<UserManager>() {
    @Override
    public void onSuccess(UserManager result) {
        SplashActivityPresenter.this.userManager = result;
    }

    @Override
    public void onFailure(Throwable t) {

    }
});
```

这里重要的是，对象初始化是在你第一次调用`appProductionComponent.userManager()`的时候开始的。在这之后`UserManager`对象将会被缓存。这表示每一个绑定都拥有跟component实例相同的生命周期。

以上几乎就是所有了。当然你应该知道在`Future.onSuccess()`方法被调用之前userManager实例会时`null`。

## 性能

在最后让我们来看下现在注入的性能是怎么样的：

![img](http://frogermcs.github.io/images/24/after_update.png)

是的，没错 - 这时平均值大约是15ms。它小于同步注入（平均. 25ms）但是并不如你期望的那样少。这时因为Producers并不像Dagger本身那样轻量。

所以现在取决于你了 - 是否值得使用Guava, Proguard和代码复杂度来做**这种**优化。

请记住，如果你觉得Producers并不是最适合你的app的，你可以在你的app中尝试使用RxJava或者其他异步代码来包装你的注入。

感谢阅读！

### 代码：

以上描述的完整代码可见Github [repository](https://github.com/frogermcs/GithubClient)。



# 在Dagger 2中使用RxJava来进行异步注入

> 原文：http://frogermcs.github.io/async-injection-in-dagger-2-with-rxjava

几星期前我写了一篇关于在Dagger 2中使用*Producers*进行异步注入的[文章](https://medium.com/@froger_mcs/dependency-injection-with-dagger-2-producers-c424ddc60ba3)。在后台线程中执行对象的初始化又一个很好的优势 - 它负责实时（[每秒60帧](https://www.youtube.com/watch?v=CaMTIgxCSqU)可以保持界面流畅）绘制UI时不会在主线程中阻塞。

值得一提的是，缓慢的初始化过程并不是每个人都会觉得是个问题。但是如果你真的关心这个，所有外部库在构造以及在任何`init()`方法中进行磁盘/网络的操作会很常见。如果你不能确定这一点，我建议你尝试下[AndroidDevMetrics](https://github.com/frogermcs/AndroidDevMetrics) - 我的Android性能测量库。它会告诉你在app中需要花多少时间来显示特定的界面，还有（如果你使用了Dagger 2）在依赖图表中提供每个对象消耗了多少时间。

不幸的是Producers并不是为Android设计的，它有以下缺陷：

- 依赖使用了Guava（会引起64k方法问题，增加build时间）
- 并不是非常快的（注入机制会阻塞主线程几毫秒到几十毫秒的世界，这取决于设备）
- 不能使用@Inject注解（代码会有一点混乱）

虽然我们不能解决最后两个问题，但是第一个我们可以在Android Project中解决。

## 使用RxJava进行异步注入

幸运的是，有大量的Android开发者使用了RxJava（和[RxAndroid](https://github.com/ReactiveX/RxAndroid)）来在我们app中编写异步代码。让我们来尝试在Dagger 2中使用它来进行异步注入。

### 异步@Singleton注入

这是我们繁重的对象：

```java
@Provides
@Singleton
HeavyExternalLibrary provideHeavyExternalLibrary() {
    HeavyExternalLibrary heavyExternalLibrary = new HeavyExternalLibrary();
    heavyExternalLibrary.init(); //This method takes about 500ms
    return heavyExternalLibrary;
}
```

现在让我们来创建一个额外的`provide...()`方法，它返回一个`Observable<HeavyExternalLibrary>`对象，它会异步调用以下代码：

```java
@Singleton
@Provides
Observable<HeavyExternalLibrary> provideHeavyExternalLibraryObservable(final Lazy<HeavyExternalLibrary> heavyExternalLibraryLazy) {
    return Observable.create(new Observable.OnSubscribe<HeavyExternalLibrary>() {
        @Override
        public void call(Subscriber<? super HeavyExternalLibrary> subscriber) {
            subscriber.onNext(heavyExternalLibraryLazy.get());
        }
    }).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread());
}
```

让我们逐行来分析：

- `@Singleton` - 记住这个很重要，`Observable`对象将会是一个单例，而不是`HeavyExternalLibrary`。Singleton也会阻止创建额外的Observable对象。
- `@Providers` - 因为这个方法是`@Module`注解了的类的一部分。你还记得[Dagger 2 API](http://frogermcs.github.io/dependency-injection-with-dagger-2-the-api/)吗？
- `Lazy<HeavyExternalLibrary> heavyExternalLibraryLazy`对象阻止Dagger（否则，在调用`provideHeavyExternalLibraryObservable()`方法调用的瞬间对象就会被创建）内部对HeavyExternalLibrary对象的初始化。
- `Observable.create(...)`代码 - 它将在每次这个Observable被订阅时通过调用`heavyExternalLibraryLazy.get()`返回`heavyExternalLibrary`对象。
- `.subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread());` - 默认情况下RxJava代码会在Observable被创建的线程中执行。这就是为什么我们要把执行移动到后台线程（这里的`Schedulers.io()`），然后在主线程中（`AndroidSchedulers.mainThread()`）观察结果。

我们的Observable像图表中其它对象一样被注入，但是`heavyExternalLibrary`对象本身将会延迟一点才可用：

```java
public class SplashActivity {

	@Inject
	Observable<HeavyExternalLibrary> heavyExternalLibraryObservable;

	//This will be injected asynchronously
	HeavyExternalLibrary heavyExternalLibrary; 

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate();
		//...
		heavyExternalLibraryObservable.subscribe(new SimpleObserver<HeavyExternalLibrary>() {
            @Override
            public void onNext(HeavyExternalLibrary heavyExternalLibrary) {
	            //Our dependency will be available from this moment
	            SplashActivity.this.heavyExternalLibrary = heavyExternalLibrary;
            }
        });
	}
}
```

### 异步新实例的注入

上面的代码展示了怎么去注入单例的对象。那如果我们想异步注入新的实例呢？

确认我们的对象不再使用了@Singleton注解：

```java
@Provides
HeavyExternalLibrary provideHeavyExternalLibrary() {
    HeavyExternalLibrary heavyExternalLibrary = new HeavyExternalLibrary();
    heavyExternalLibrary.init(); //This method takes about 500ms
    return heavyExternalLibrary;
}
```

我们`Observable<HeavyExternalLibrary>` provider方法也会有一点改变。我们不能使用`Lazy<HeavyExternalLibrary>`因为它只会在第一次调用`get()`方法的时候（详见[Lazy文档](http://google.github.io/dagger/api/latest/dagger/Lazy.html)）才会创建新的实例。

这里是更新后的代码：

```java
@Singleton
@Provides
Observable<HeavyExternalLibrary> provideHeavyExternalLibraryObservable(final Provider<HeavyExternalLibrary> heavyExternalLibraryProvider) {
    return Observable.create(new Observable.OnSubscribe<HeavyExternalLibrary>() {
        @Override
        public void call(Subscriber<? super HeavyExternalLibrary> subscriber) {
            subscriber.onNext(heavyExternalLibraryProvider.get());
        }
    }).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread());
}
```

我们的`Observable<HeavyExternalLibrary>`可以是一个单例，，但是每一次我们去调用它的subscribe()方法的时候，我们将会在onNext()方法中得到一个新的`HeavyExternalLibrary`实例：

```java
heavyExternalLibraryObservable.subscribe(new SimpleObserver<HeavyExternalLibrary>() {
    @Override
    public void onNext(HeavyExternalLibrary heavyExternalLibrary) {
        //New instance of HeavyExternalLibrary
    }
});
```

### 完全的异步注入

还有另一个方法是用RxJava在Dagger 2中进行异步注入。我们可以使用Observable简单封装整个注入过程。

我们注入的执行是这样的（代码摘自[GithubClient](https://github.com/frogermcs/GithubClient/)项目）：

```java
public class SplashActivity extends BaseActivity {

    @Inject
    SplashActivityPresenter presenter;
    @Inject
    AnalyticsManager analyticsManager;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
    }

    //This method is called in super.onCreate() method
    @Override
    protected void setupActivityComponent() {
        final SplashActivityComponent splashActivityComponent = GithubClientApplication.get(SplashActivity.this)
                .getAppComponent()
                .plus(new SplashActivityModule(SplashActivity.this));
        splashActivityComponent.inject(SplashActivity.this);
    }
}
```

要让它变成异步我们只需要使用Observable封装`setupActivityComponent()`方法：

```java
@Override
protected void setupActivityComponent() {
    Observable.create(new Observable.OnSubscribe<Object>() {
        @Override
        public void call(Subscriber<? super Object> subscriber) {
            final SplashActivityComponent splashActivityComponent = GithubClientApplication.get(SplashActivity.this)
                    .getAppComponent()
                    .plus(new SplashActivityModule(SplashActivity.this));
            splashActivityComponent.inject(SplashActivity.this);
            subscriber.onCompleted();
        }
    })
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(new SimpleObserver<Object>() {
                @Override
                public void onCompleted() {
                    //Here is the moment when injection is done.
                    analyticsManager.logScreenView(getClass().getName());
                    presenter.callAnyMethod();
                }
            });
}
```

正如注释，所有`@Inject`注解了的对象将被未来某一时刻注入。在返回注入过程是异步的并且不会对主线程有很大的影响。

当然创建`Observable`对象和额外`subscribeOn()`线程并不是完全免费的 - 它将会花费一点时间。这类似于**Producers**代码所产生的影响。

![img](http://frogermcs.github.io/images/26/splash_metrics.png)

感谢阅读！



# 在Dagger 2中Activities和Subcomponents的多绑定

> 原文：http://frogermcs.github.io/activities-multibinding-in-dagger-2

几个月前，在[MCE^3](http://2016.mceconf.com/)会议中，Gregory Kick在他的[演讲](https://www.youtube.com/watch?v=iwjXqRlEevg)中展示了一个提供Subcomponents（比如，为Activity）的新概念。新的方式给我们带来了一个创建不使用AppComponent对象引用（以前时Activities Subcomponents的工厂）的方式。为了让它成为现实，我们不得不等到了新的Dagger release版本：[version 2.7](https://github.com/google/dagger/releases/tag/dagger-2.7)。

## 问题

在Dagger 2.7之前，创建Subcomponent（比如，`AppComponent`的subcomponent `MainActivityComponent`）我们必须要在父Component中声明它的工厂：

```java
@Singleton
@Component(
    modules = {
        AppModule.class
    }
)
public interface AppComponent {
    MainActivityComponent plus(MainActivityComponent.ModuleImpl module);

    //...
}
```

多亏Dagger理解这个声明，`MainActivityComponent`能够访问从`AppComponent`的依赖。

有了这个，`MainActivity`中的注入看起来如下：

```java
@Override
protected ActivityComponent onCreateComponent() {
    ((MyApplication) getApplication()).getComponent().plus(new MainActivityComponent.ModuleImpl(this));
    component.inject(this);
    return component;
}
```

这个代码的问题在于：

- Activity依赖于`AppComponent`（通过`((MyApplication) getApplication()).getComponent())`返回 - 我们是否想要去创建Subcomponent，我们需要去访问父Component的对象）。
- `AppComponent`必须要去声明所有Subcomponents（或者它们的builders），比如：`MainActivityComponent plus(MainActivityComponent.ModuleImpl module);`。

## Modules.subcomponents

从Dagger 2.7开始，我们有了一个新的方法来声明subcomponents的父级。`@Module`注解有一个可选的[subcomponents](http://google.github.io/dagger/api/2.7/dagger/Module.html#subcomponents--)属性，它可以得到subcomponents类的列表，它们应该是安装此module组件的子component。

### Example：

```java
@Module(
        subcomponents = {
                MainActivityComponent.class,
                SecondActivityComponent.class
        })
public abstract class ActivityBindingModule {
    //...
}
```

`ActivityBindingModule`在`AppComponent`中被安装。这表示`MainActivityComponent`和`SecondActivityComponent`两者都是`AppComponent`的Subcomponents。

Subcomponents的声明在这种方法中不需要明确地在`AppComponent`中进行声明（就像本章开头的代码）。

## Activities的多绑定

让我们来看看我们怎么样使用`Modules.subcomponents`来构建Activities多绑定并且摆脱AppComponent对象传入Activity（这在[这个演讲](https://www.youtube.com/watch?v=iwjXqRlEevg&feature=youtu.be&t=1693)中也解释到）。我将只浏览代码中最重要的部分。整个实现已在Github中可用：[Dagger2Recipes-ActivitiesMultibinding](https://github.com/frogermcs/Dagger2Recipes-ActivitiesMultibinding)。

我们的app包含两个屏幕：`MainActivity`和`SecondActivity`。我们想要去给它们两者提供Subcomponents且并不传入`AppComponent`对象。

让我们从为所有Activity Components builders构建一个基本的接口来开始：

```java
public interface ActivityComponentBuilder<M extends ActivityModule, C extends ActivityComponent> {
    ActivityComponentBuilder<M, C> activityModule(M activityModule);
    C build();
}
```

Subcomponents：`MainActivityComponent`的例子看起来如下：

```java
@ActivityScope
@Subcomponent(
        modules = MainActivityComponent.MainActivityModule.class
)
public interface MainActivityComponent extends ActivityComponent<MainActivity> {

    @Subcomponent.Builder
    interface Builder extends ActivityComponentBuilder<MainActivityModule, MainActivityComponent> {
    }

    @Module
    class MainActivityModule extends ActivityModule<MainActivity> {
        MainActivityModule(MainActivity activity) {
            super(activity);
        }
    }
}
```

现在我们可以使用Subcomponents builders的`Map`来得到每一个Activity类的意图builder。让我们如下使用`Multibinding`特性：

```java
@Module(
        subcomponents = {
                MainActivityComponent.class,
                SecondActivityComponent.class
        })
public abstract class ActivityBindingModule {

    @Binds
    @IntoMap
    @ActivityKey(MainActivity.class)
    public abstract ActivityComponentBuilder mainActivityComponentBuilder(MainActivityComponent.Builder impl);

    @Binds
    @IntoMap
    @ActivityKey(SecondActivity.class)
    public abstract ActivityComponentBuilder secondActivityComponentBuilder(SecondActivityComponent.Builder impl);
}
```

`ActivityBindingModule`在`AppComponent`中被安装。就如它被解释的那样，多亏`MainActivityComponent`和`SecondActivityComponent`将会是`AppComponent`的Subcomponent。

现在我们可以注入`Subcomponents` builder的Map（比如，注入到`MyApplication` class）：

```java
public class MyApplication extends Application implements HasActivitySubcomponentBuilders {

    @Inject
    Map<Class<? extends Activity>, ActivityComponentBuilder> activityComponentBuilders;

    private AppComponent appComponent;

    public static HasActivitySubcomponentBuilders get(Context context) {
        return ((HasActivitySubcomponentBuilders) context.getApplicationContext());
    }

    @Override
    public void onCreate() {
        super.onCreate();
        appComponent = DaggerAppComponent.create();
        appComponent.inject(this);
    }

    @Override
    public ActivityComponentBuilder getActivityComponentBuilder(Class<? extends Activity> activityClass) {
        return activityComponentBuilders.get(activityClass);
    }
}
```

我们创建了`HashActivitySubcomponentBuilders`接口作为额外的抽象（因为builders的`Map`不一定是注入到`Appliction`类的）：

```java
public interface HasActivitySubcomponentBuilders {
    ActivityComponentBuilder getActivityComponentBuilder(Class<? extends Activity> activityClass);
}
```

然后最后在Activity class中进行注入的实现：

```java
public class MainActivity extends BaseActivity {

    //...

    @Override
    protected void injectMembers(HasActivitySubcomponentBuilders hasActivitySubcomponentBuilders) {
        ((MainActivityComponent.Builder) hasActivitySubcomponentBuilders.getActivityComponentBuilder(MainActivity.class))
                .activityModule(new MainActivityComponent.MainActivityModule(this))
                .build().injectMembers(this);
    }
}
```

它非常类似于我们的第一个实现，但如上，最重要的事是我们不再传入`ActivityComponent`对象到我们的Activities中。

## 用例example —— instrumentation tests mocking

除了解耦和解决循环依赖（Activity <-> Application），这不是一个大的问题，尤其是在较小的项目/团队中，让我们思考一个这个实现有帮助的真实用例 —— 在instrumentation testing中的mocking依赖。

目前在Android Instrumentation测试中mocking依赖最著名的方式之一是使用[DaggerMock](https://medium.com/@fabioCollini/android-testing-using-dagger-2-mockito-and-a-custom-junit-rule-c8487ed01b56#.eh5zfyou5)（Github [项目地址](https://github.com/fabioCollini/DaggerMock)）。虽然DaggerMock是一个强大的工具，但是非常难理解它面具之下是怎么工作的。其中有一些反射代码不容易被追踪。

在Activity中直接构建Subcomponent，而不需要访问AppComponent类给了我们一个方式来测试单独的Activity并从我们app的其它部分解耦。

听起来很酷，现在我们来看下代码。

在我们的instrumentation test中使用Applicaton类：

```java
public class ApplicationMock extends MyApplication {

    public void putActivityComponentBuilder(ActivityComponentBuilder builder, Class<? extends Activity> cls) {
        Map<Class<? extends Activity>, ActivityComponentBuilder> activityComponentBuilders = new HashMap<>(this.activityComponentBuilders);
        activityComponentBuilders.put(cls, builder);
        this.activityComponentBuilders = activityComponentBuilders;
    }
}
```

`putActivityComponentBuilder()`方法给我们一个对给定Activity类替换ActivityComponentBuilder的实现的方法。

现在来看下我们Espresso Instrumentation Test例子：

```java
@RunWith(AndroidJUnit4.class)
public class MainActivityUITest {

    @Rule
    public MockitoRule mockitoRule = MockitoJUnit.rule();

    @Rule
    public ActivityTestRule<MainActivity> activityRule = new ActivityTestRule<>(MainActivity.class, true, false);

    @Mock
    MainActivityComponent.Builder builder;
    @Mock
    Utils utilsMock;

    private MainActivityComponent mainActivityComponent = new MainActivityComponent() {
        @Override
        public void injectMembers(MainActivity instance) {
            instance.mainActivityPresenter = new MainActivityPresenter(instance, utilsMock);
        }
    };

    @Before
    public void setUp() {
        when(builder.build()).thenReturn(mainActivityComponent);
        when(builder.activityModule(any(MainActivityComponent.MainActivityModule.class))).thenReturn(builder);

        ApplicationMock app = (ApplicationMock) InstrumentationRegistry.getTargetContext().getApplicationContext();
        app.putActivityComponentBuilder(builder, MainActivity.class);
    }
```

一步一步来：

- 我们提供了`MainActivityComponent.Builder`的Mock和所有我们必须要mock的依赖（在本例中只是`Utils`）。我们mocked`Builder`返回一个`MainActivityComponent`的一个自定义实现，它用于注入`MainActivityPresenter`（其中使用了mocked `Utils`）。
- 然后我们的`MainActivityComponent.Builder`替换了在`MyApplication`（28行）中被注入的原始Builder：`app.putActivityComponentBuilder(builder, MainActivity.class);`
- 最后测试 —— 我们mock`Util.getHardcodedText()`方法。注入过程发生在Activity被创建（36行）：`activityRule.launchActivity(new Intent());`接着在最后我们使用Espresso来检验结果。

以上就是全部。如你所见，几乎一切都发生在`MainActivityUITest`类中，而且代码相当简单和可读。

## 源码

如果你想自己去测试这个实现，源码与工作例子展示怎么去创建**Activities Multibinding**和在Instrumentation Tests中mock依赖见Github：[Dagger2Recipes-ActivitiesMultibinding](https://github.com/frogermcs/Dagger2Recipes-ActivitiesMultibinding)

感谢阅读！



# 在Android上编写模块化项目（翻译）

当我们在 Android Studio 上创建一个新的项目时，自带一个 `app` module。这时我们大多数人编写整个应用的地方。每次点击 `run` 按钮都会触发我们整个所有 module 上的 gradle 构建，并检查所有文件是否有变化。这就是为什么 gradle 构建会在更大的应用程序上花费 [10分钟](https://eng.uber.com/android-monorepo/)的时间，并且减慢开发者的[输出](https://imgs.xkcd.com/comics/compiling.png)。

要解决这个问题，复杂的应用程序，如 Uber 决定对它们的应用程序进行模块化并从中[获得](https://www.youtube.com/watch?v=j6CiHlapado)了很多。下面是试用模块化项目的一些优势：

- [更快](https://proandroiddev.com/modular-architecture-for-faster-build-time-d58397cb7bfe)的 gradle 构建
- 跨应用/模块复用通用的功能
- 易于插拔到[Instant apps](https://developer.android.com/topic/instant-apps/overview.html#features)
- 更好的团队工作，一个人可以单独负责一个模块
- 更流畅地git flows

由于上述优势，当我刚开始[Posts](https://github.com/karntrehan/Posts/)这个应用时，我就在始终坚持使用模块化方法。对此，Android 团队已经给我们提供了一些[工具](https://developer.android.com/google/play/publishing/multiple-apks.html#CreatingApks)，但是我确实遇到了一些障碍，一下是我学习到的内容：

## 我该怎么分割我的 modules ？

你的应用程序是流程集构成的，比如，Google Play 有**应用详情**流，它包含了简要，描述详情，应用截图，评论活动等。

![img](https://user-images.githubusercontent.com/5423194/36140651-ed8f0d6c-10dc-11e8-9733-e306fd72f9d0.jpeg)

所有这些都可以归为同一模块 —— `app-details`。

你的应用会包含多个类似流程的模块，有 `authentication`, `settings`, `on-boarding`等等。当然还有一些不需要UI元素呈现的模块如 —— `notifications`, `analytics`, `first-fetch`等等。这些模块包含与流程有关的 activities, repositories, entities和依赖注入相关东西。

![img](https://user-images.githubusercontent.com/5423194/36140945-09253f5a-10de-11e8-8ded-003e53fd78b6.png)

但是这些模块中总是有一些共同的功能和工具。这就是为什么你需要一个 core 模块。

## 什么是 core 模块 ？

`Core` 模块是一个你项目中简单的 module 库。core 库可以（除其它外），

- 给你的依赖注入框架提供全局依赖，如 [Retrofit](https://github.com/karntrehan/Posts/blob/master/core/src/main/java/com/karntrehan/posts/core/di/NetworkModule.kt), [SharedPreferences](https://github.com/karntrehan/Posts/blob/master/core/src/main/java/com/karntrehan/posts/core/di/StorageModule.kt)等等。
- 包含工具类和[扩展方法](https://github.com/karntrehan/Posts/tree/master/core/src/main/java/com/karntrehan/posts/core/extensions)
- 包含[全局类](https://github.com/karntrehan/Posts/blob/master/core/src/main/java/com/karntrehan/posts/core/networking/Outcome.kt)和回调
- 在 application 类中的[初始化库](https://github.com/karntrehan/Posts/blob/master/core/src/main/java/com/karntrehan/posts/core/application/CoreApp.kt)，如 Firebase Analytics，Crashlytics，LeakCanary，Stetho等等

## 怎么使用第三方库？

核心(`core`)模块的其中一个职责是为你的功能(`feature`)模块提供外部依赖。这使得很容易实现在你的 `feature` 模块中共享相同版本的库。只需要在你的 `core` 模块的 dependencies 中使用 `api`，这样你就能在所有 `feature` 模块中使用它们。

```groovy
dependencies {
    api fileTree(include: ['*.jar'], dir: 'libs')
    api deps.support.appCompat
    api deps.support.recyclerView
    api deps.support.cardView
    api deps.support.support
    api deps.support.designSupport

    api deps.android.lifecycleExt
    api deps.android.lifecycleCommon
    api deps.android.roomRuntime
    api deps.android.roomRx

    api deps.kotlin.stdlib

    api deps.reactivex.rxJava
    api deps.reactivex.rxAndroid

    api deps.google.dagger
    kapt deps.google.daggerProcessor

    api deps.square.picasso
    api deps.square.okhttpDownloader

    api deps.square.retrofit
    api deps.square.okhttp
    api deps.square.gsonConverter
    api deps.square.retrofitRxAdapter

    implementation deps.facebook.stetho
    implementation deps.facebook.networkInterceptor

    testApi deps.test.junit
    androidTestApi deps.test.testRunner
    androidTestApi deps.test.espressoCore
}
```

有种依赖的可能性是只有对 `feature-a` 模块有用，但是在 `feature-b` 中无用。对于这种情况，我推荐在你的 core 的依赖中使用 `api`，因为 proguard 注意到而不会包含在 `feature-b` instant app 中。

## 怎么使用 Room ？

这个困扰我挺久的时间。我们希望把我们的数据库定义到 `core` 模块中，因为它是我们应用程序要共享的通用的功能。为了让 Room 工作，你需要一个包含了所有 entity 类的数据库文件。

```kotlin
@Database(entities = [Post::class, User::class, Comment::class], version = 1,exportSchema = false)
abstract class PostDb : RoomDatabase() {
    abstract fun postDao(): PostDao
    abstract fun userDao(): UserDao
    abstract fun commentDao(): CommentDao
}
```

但是，如上面提到的，我们的 entity 类是被定义在 `feature` 模块中，而且 `core` 模块不能去访问它们。这是我碰到障碍的地方，经过一番思考后，你做了一件最棒的事，寻求 [Yigit](https://github.com/yigit) 的帮助。

Yigit 阐明了观点，你必须要在每个 `feature`模块中都创建一个新的 db 文件，然后每个模块一个数据库。

这有几个好处：

- [迁移](https://medium.com/google-developers/understanding-migrations-with-room-f01e04b07929)是模块化的
- 即时 app 仅包含它们需要的表
- 查询会更快

缺点：

- 跨模块数据关系将不可能

*注意：为了 Room 的注解能够工作，不要忘记在你的 `feature` 模块中增加下面依赖*

```groovy
kapt "android.arch.persistence.room:compiler:${versions.room}"
```

## 怎么使用 Dagger 2 ？

同样的问题 Dagger 也遇到了。我的 core 模块中的 application 类不能访问和初始化我 `feature` 模块中的组件。这是从属组件完美的用例。

你的 core 组件定义了它想要暴露给依赖组件的依赖关系

```kotlin
@Singleton
@Component(modules = [AppModule::class, NetworkModule::class, StorageModule::class, ImageModule::class])
interface CoreComponent {

    fun context(): Context

    fun retrofit(): Retrofit

    fun picasso(): Picasso

    fun sharedPreferences(): SharedPreferences

    fun scheduler(): Scheduler
}
```

您的模块组件将 `CoreComponent` 定义为依赖项，并使用传递的依赖

```kotlin
@ListScope
@Component(dependencies = [CoreComponent::class], modules = [ListModule::class])
interface ListComponent {
    fun inject(listActivity: ListActivity)
}

@Module
@ListScope
class ListModule {

    /*Uses parent's provided dependencies like Picasso, Context and Retrofit*/
    @Provides
    @ListScope
    fun adapter(picasso: Picasso): ListAdapter = ListAdapter(picasso)

    @Provides
    @ListScope
    fun postDb(context: Context): PostDb = Room.databaseBuilder(context, PostDb::class.java, Constants.Posts.DB_NAME).build()

    @Provides
    @ListScope
    fun postService(retrofit: Retrofit): PostService = retrofit.create(PostService::class.java)
}
```

## 在哪里初始化我的 components ？

我为我的功能的所有组件创建了一个单例 holder。这个 holder 用于创建，维护和销毁我的 component 实例。

```kotlin
@Singleton
object PostDH {
    private var listComponent: ListComponent? = null

    fun listComponent(): ListComponent {
        if (listComponent == null)
            listComponent = DaggerListComponent.builder().coreComponent(CoreApp.coreComponent).build()
        return listComponent as ListComponent
    }

    fun destroyListComponent() {
        listComponent = null
    }
}
```

*注意：为了 Dagger 的注解能够工作，不要忘记在你的 `feature` 模块中增加下面依赖*

```groovy
kapt "com.google.dagger:dagger-compiler:${versions.dagger}"
```

## 总结

尽管把你的单独的 application 转成模块化有一些棘手，其中一些我试图通过上面的方法来解决，优点是深刻的。如果您在模块中遇到任何障碍，请随时在下面提及它们，我们可以一起讨论解决方案。

谢谢。



https://www.cnblogs.com/tiantianbyconan/p/5092083.html

http://frogermcs.github.io/dependency-injection-with-dagger-2-introdution-to-di/